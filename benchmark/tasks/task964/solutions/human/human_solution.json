[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cstdint>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\nstruct UnionFind {\n  vector<int> c, s;\n  UnionFind(size_t n) : c(n), s(n, 1) { iota(begin(c), end(c), 0); }\n  int root(int i) { return c[i] == i ? i : (c[i] = root(c[i])); }\n  bool same(int i, int j) { return root(i) == root(j); }\n  void unite(int i, int j) {\n    i = root(i); j = root(j);\n    if (i != j) {\n      if (s[i] > s[j]) { c[j] = i; s[i] += s[j]; }\n      else { c[i] = j; s[j] += s[i]; }\n    }\n  }\n  int size(int i) { return s[root(i)]; }\n};\n\ni64 n, m;\nusing P = pair<i64, i64>;\nvector<vector<P>> g;\nvector<vector<i64>> mw;\n\nvoid dfs(i64 r, i64 u, i64 b) {\n  for (auto p : g[u]) {\n    i64 v, c;\n    tie(v, c) = p;\n    if (v == b) continue;\n    mw[r][v] = max(mw[r][u], c);\n    dfs(r, v, u);\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  vector<tuple<i64, i64, i64>> es, tes;\n  for (i64 i = 0; i < m; ++i) {\n    i64 a, b, c;\n    cin >> a >> b >> c;\n    es.emplace_back(c, a, b);\n  }\n  sort(begin(es), end(es));\n  UnionFind uf(n + 1);\n  i64 csum = 0;\n  for (i64 i = 0; tes.size() < n - 1; ++i) {\n    auto t = es[i];\n    i64 a, b, c;\n    tie(c, a, b) = t;\n    if (!uf.same(a, b)) {\n      tes.emplace_back(c, a, b);\n      csum += c;\n      uf.unite(a, b);\n    }\n  }\n  \n  init_n(g, n + 1);\n  for (auto e : tes) {\n    i64 a, b, c;\n    tie(c, a, b) = e;\n    g[a].emplace_back(b, c);\n    g[b].emplace_back(a, c);\n  }\n\n  init_n(mw, n + 1, vector<i64>(n + 1));\n  for (i64 r = 1; r <= n; ++r) {\n    dfs(r, r, 0);\n  }\n\n  i64 q;\n  cin >> q;\n  while (q--) {\n    i64 s, t;\n    cin >> s >> t;\n    cout << csum - mw[s][t] << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\nvector<vector<pair<int, int64_t>>> mct;\n\nint64_t dfs(int p, int s, int t) {\n  if (s == t) return -1;\n  int64_t res = 0;\n  for (auto e : mct[s]) {\n    if (e.first == p) continue;\n    auto r = dfs(s, e.first, t);\n    if (r == 0) continue;\n    res = max(res, max(e.second, r));\n  }\n  return res;\n}\n\nint main() {\n  int n, m, q;\n  cin >> n >> m;\n  vector<vector<pair<int, int64_t>>> graph(n);\n  mct.resize(n);\n  for (int i = 0; i < m; ++i) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    graph[a - 1].emplace_back(b - 1, c);\n    graph[b - 1].emplace_back(a - 1, c);\n  }\n  priority_queue<tuple<int64_t, int, int>, vector<tuple<int64_t, int, int>>, greater<tuple<int64_t, int, int>>> que;\n  for (auto& e : graph[0]) que.emplace(e.second, 0, e.first);\n  vector<bool> used(n);\n  used[0] = true;\n  int64_t sum = 0;\n  while (!que.empty()) {\n    auto e = que.top();\n    que.pop();\n    if (used[get<2>(e)]) continue;\n    used[get<2>(e)] = true;\n    mct[get<1>(e)].emplace_back(get<2>(e), get<0>(e));\n    mct[get<2>(e)].emplace_back(get<1>(e), get<0>(e));\n    sum += get<0>(e);\n    for (auto& d : graph[get<2>(e)]) {\n      que.emplace(d.second, get<2>(e), d.first);\n    }\n  }\n  cin >> q;\n  for (int i = 0; i < q; ++i) {\n    int s, t;\n    cin >> s >> t;\n    cout << sum - dfs(-1, s - 1, t - 1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\nstruct edge{\n  Int from,to,cost,used;\n  edge(){}\n  edge(Int from,Int to,Int cost):from(from),to(to),cost(cost),used(0){}\n  bool operator<(const edge& e) const{\n    return cost<e.cost;\n  }\n};\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  void add_edge(Int u,Int v,Int c){\n    edges.push_back(edge(u,v,c));\n  }\n\n  void input(Int m,Int offset=0){\n    Int a,b,c;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      add_edge(a+offset,b+offset,c);\n    }\n  }\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\te.used=1;\n      }\n    }\n    return res;\n  }\n};\n\n\nstruct HLDecomposition {\n  Int n,pos;\n  vector<vector<Int> > G;\n  vector<Int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(Int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(Int u, Int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<Int> rs={0}) {\n    Int c=0;\n    for(Int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(Int rt) {\n    using T = pair<Int, Int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      Int v=st.top().first;\n      Int &i=st.top().second;\n      if(i<(Int)G[v].size()){\n\tInt u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tInt res=0;\n\tfor(Int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(Int r,Int c) {\n    Int &k=pos;\n    queue<Int> q({r});\n    while(!q.empty()){\n      Int h=q.front();q.pop();\n      for(Int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(Int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  Int lca(Int u,Int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  Int distance(Int u,Int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  Int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(Int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(Int)v.size()) build(n_,v);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(Int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(Int a,Int b){\n    T vl=d1,vr=d1;\n    for(Int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\n\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  Kruskal k(n);\n  k.input(m,-1);\n  Int val=k.build();\n  auto es=k.edges;\n  es.erase(remove_if(es.begin(),es.end(),[](edge e){return !e.used;}),es.end());\n  //cout<<es.size()<<endl;\n  //for(auto e:es) cout<<e.used<<endl;\n  HLDecomposition hld(n);\n  for(auto e:es) hld.add_edge(e.from, e.to);\n  hld.build();\n  \n  SegmentTree<Int, Int> seg(n,\n\t\t\t    [](Int a,Int b){return max(a,b);},\n\t\t\t    [](Int a,Int b){return b;},\n\t\t\t    0);\n  for(auto e:es){\n    Int u=e.from,v=e.to,c=e.cost;\n    if(hld.dep[u]>hld.dep[v]) swap(u,v);\n    seg.update(hld.vid[v],c);\n  }\n  \n  Int q;\n  cin>>q;\n  //if(q>3000) exit(1);\n  for(Int i=0;i<q;i++){\n    Int s,t;\n    cin>>s>>t;\n    s--;t--;\n    Int x=0;\n    hld.for_each_edge(s,t,[&](Int l,Int r){\n\tx=max(x,seg.query(l,r+1));\n      });\n    cout<<val-x<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<ll>> tree(N);\n\tUnionFindTree uf(N);\n\tif(!N){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tusing t = pair<ll,pair<int,int>>;\n\tpriority_queue<t,vector<t>,greater<>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tll c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth();\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<int> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n    Edge(int f, int t, int c) : from(f), to(t), cost(c) {}\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nconst int MAXN = 4010;\nstruct UnionFind {\n    int node[MAXN];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        node[x] += node[y];\n        node[y] = x;\n        return true;\n    }\n};\n\nusing Graph = vector< vector<Edge> >;\nint max_edge[MAXN][MAXN];\n\nvoid dfs(Graph &G, int cur, int par, int orig) {\n    int prev_max = (par < 0 ? 0 : max_edge[orig][par]);\n    for(auto e : G[cur]) {\n        if(e.to == par) continue;\n        chmax(max_edge[orig][e.to], max(prev_max, e.cost));\n        dfs(G, e.to, cur, orig);\n    }\n}\n \nUnionFind uf;\nsigned main() {\n    int N, M; cin >> N >> M;\n    \n    vector<Edge> edges;\n    for(int i=0; i<M; i++) {\n        int u, v, cost; cin >> u >> v >> cost;\n        u--; v--;\n        edges.emplace_back(u, v, cost);\n    }\n    sort(edges.begin(), edges.end());\n\n    int sum = 0;\n    Graph MST(N);\n    for(int i=0; i<M; i++) {\n        Edge e = edges[i];\n        if(uf.unite(e.from, e.to)) {\n            MST[e.from].emplace_back(e.from, e.to  , e.cost);\n            MST[e.to  ].emplace_back(e.to,   e.from, e.cost);\n            sum += e.cost;\n        }\n    }\n\n    for(int i=0; i<N; i++) dfs(MST, i, -1, i);\n\n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        // printf(\"max_edge = %lld\\n\", max_edge[s][t]);\n        cout << sum - max_edge[s][t] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    //cin >> a[i],b[i],c[i];\n    scanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n    a[i]--; b[i]--;\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<long long>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  int sz = 13;\n  \n  vector<vector<int>> p(n, vector<int>(sz, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(sz, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<sz; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    //cin >> u,v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n\n    long long sub = 0;\n\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<sz; k++){\n      if( ((depth[v] - depth[u]) >> k) & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=sz-1; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n    if(u!=v){\n      sub = max({sub, mx_e[u][0], mx_e[v][0]});\n    }\n\n    //println( mst_cost - sub );\n    printf(\"%lld\\n\", mst_cost - sub);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<ll>> tree(N);\n\tUnionFindTree uf(N);\n\tif(N==1){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tusing t = pair<ll,pair<int,int>>;\n\tpriority_queue<t,vector<t>,greater<>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tll c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth(0);\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<ll> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tUnionFindTree uf(N);\n\tvector<int> a(M), b(M);\n\tvector<ll> c(M);\n\tvector<pair<ll, int>> ord(M);\n\tfor(int i = 0; i < M; ++i){\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\ta[i]--, b[i]--;\n\t\tord[i] = { c[i],i };\n\t}\n\tsort(ALL(ord));\n \n\tTree<treeOperator<ll>> tree(N);\n\tll sum = 0;\n\tfor (int i = 0; i < M; ++i){\n\t\tint j = ord[i].second;\n\t\tif (uf.same(a[j], b[j])) {\n\t\t\ta[j] = b[j] = -1;\n\t\t}\n\t\telse {\n\t\t\tuf.unite(a[j], b[j]);\n\t\t\tsum += c[j];\n\t\t\ttree.makeEdge(a[j], b[j]);\n\t\t\ttree.makeEdge(b[j], a[j]);\n\t\t}\n\t}\n\ttree.makeDepth(0);\n\tvector<vector<int>> edge(N, vector<int>(20,0));\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (a[i] == -1 || b[i] == -1) continue;\n\t\tif (tree.depth[a[i]] < tree.depth[b[i]]) swap(a[i], b[i]);\n\t\tedge[a[i]][0] = c[i];\n\t}\n \n\ttree.makeParent();\n\ttree.makeAncestor();\n\tfor (int bit = 1; bit < 20; ++bit) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tedge[i][bit] = max(edge[tree.ancestor[i][bit - 1].first][bit - 1], edge[i][bit - 1]);\n\t\t}\n\t}\n\tint Q; cin >> Q;\n\tvector<ll> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tif (tree.depth[s] < tree.depth[t]) swap(s, t);\n\t\tint u = tree.lca(s, t).first;\n\t\tint ds = tree.depth[s] - tree.depth[u];\n\t\tint dt = tree.depth[t] - tree.depth[u];\n\t\tint es = 0;\n\t\tint et = 0;\n\t\tfor (int bit = 0; bit < 20; ++bit) if (ds & (1 << bit)) {\n\t\t\tes = max(es, edge[s][bit]);\n\t\t\ts = tree.ancestor[s][bit].first;\n\t\t}\n\t\tfor (int bit = 0; bit < 20; ++bit) if (dt & (1 << bit)) {\n\t\t\tet = max(et, edge[t][bit]);\n\t\t\tt = tree.ancestor[t][bit].first;\n\t\t}\n\t\tans[i] = sum - max(es, et);\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[4010],rank[4010];\n\tvoid init(){\n\t\tfor(int i=0;i<4010;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\trank[y]++;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to;\n\tll cost;\n\tedge(){}\n\tedge(int from,int to,ll cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge &a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint N,M,Q;\nvector<edge> es;\nvector<edge> g[4010];\nint par[15][4010];\nll cost[15][4010];\nint depth[4010];\nvoid add_edge(edge e){\n\tg[e.from].pb(e);\n\tswap(e.from,e.to);\n\tg[e.from].pb(e);\n}\nvoid dfs(int v,int p,int c,int d){\n\tdepth[v]=d;\n\tpar[0][v]=p;\n\tcost[0][v]=c;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tedge e = g[v][i];\n\t\tif(e.to==p)continue;\n\t\tdfs(e.to,v,e.cost,d+1);\n\t}\n}\nll query(int u,int v){\n\t//cout << u << ' ' << v << endl;\n\tif(depth[u]>depth[v])swap(u,v);\n\tll res = 0ll;\n\tfor(int i=14;i>=0;i--){\n\t\tif(((depth[v]-depth[u])>>i)&1){\n\t\t\tres = max(res,cost[i][v]);\n\t\t\tv = par[i][v];\n\t\t}\n\t}\n\tif(u==v)return res;\n\tfor(int i=14;i>=0;i--){\n\t\tif(par[i][u]!=par[i][v]){\n\t\t\tres = max(res,cost[i][u]);\n\t\t\tres = max(res,cost[i][v]);\n\t\t\tu = par[i][u];\n\t\t\tv = par[i][v];\n\t\t}\n\t}\n\tres = max(res,cost[0][u]);\n\tres = max(res,cost[0][v]);\n\tassert(par[0][u]==par[0][v]);\n\treturn res;\n}\nint main(){\n\tcin >> N >> M;\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tll c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\tes.pb(edge(a,b,c));\n\t}\n\tsort(all(es));\n\tuf.init();\n\tll base = 0ll;\n\tfor(int i=0;i<es.size();i++){\n\t\tif(uf.same(es[i].from,es[i].to))continue;\n\t\tbase += es[i].cost;\n\t\tuf.unite(es[i].from,es[i].to);\n\t\t//cout << es[i].from << ' ' << es[i].to << ' ' << es[i].cost << endl;\n\t\tadd_edge(es[i]);\n\t}\n\tdfs(0,-1,-1,0);\n\t/*for(int i=0;i<N;i++){\n\t\tprintf(\"%d %d %lld\\n\",i,par[0][i],cost[0][i]);\n\t}*/\n\tfor(int i=0;i<14;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(par[i][j]==-1){\n\t\t\t\tpar[i+1][j]=-1;\n\t\t\t\tcost[i+1][j]=cost[i][j];\n\t\t\t}else{\n\t\t\t\tpar[i+1][j]=par[i][par[i][j]];\n\t\t\t\tcost[i+1][j]=max(cost[i][j],cost[i][par[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> Q;\n\tfor(int i=0;i<Q;i++){\n\t\tint S,T;\n\t\tcin >> S >> T;\n\t\tS--;T--;\n\t\tcout << base-query(S,T) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v)const{\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\ntemplate<class T> class max_cost_on_path{\npublic:\n    const int max_pow=20;\n    vector<vector<T>> max_cost;\n    const lca_solver* const ls;\n    max_cost_on_path(const lca_solver &ls_,std::vector<std::unordered_map<int,T>> &cost):ls(&ls_),max_cost(max_pow){\n        const int n=ls->children.size();\n        for(int i=0; i<max_pow; ++i) max_cost[i].resize(n);\n        for(int i=0; i<n; ++i){\n            if(i==ls->root) continue;\n            int j=ls->parent_pow2[0][i];\n            max_cost[0][i]=cost[i][j];\n        }\n        for(int i=1; i<max_pow; ++i){\n            for(int j=0; j<n; ++j){\n                if(ls->depth[j]-(1<<i)<0) continue;\n                max_cost[i][j]=std::max(max_cost[i-1][j],max_cost[i-1][ls->parent_pow2[i-1][j]]);\n            }\n        }\n    }\n\n    T sub(int u,int v)const{\n        T res=0;\n        for(int i=max_pow-1; i>=0; --i){\n            if(ls->depth[u]-ls->depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls->parent_pow2[i][u];\n            }\n        }\n        return res;\n    }\n\n    T calc(int u,int v)const{\n        int lca=ls->lca(u,v);\n        return max(sub(u,lca),sub(v,lca));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    int64_t sum_cost=0;\n    vector<vector<int>> mst(n);\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        mst[e.from].push_back(e.to);\n        mst[e.to].push_back(e.from);\n    }\n\n    int root=0;\n    vector<vector<int>> children(n);\n    function<void(int,int)> dfs=[&](int u,int p){\n        for(int v:mst[u]){\n            if(v==p) continue;\n            children[u].push_back(v);\n            dfs(v,u);\n        }\n    };\n    dfs(root,-1);\n    lca_solver ls(children,root);\n    max_cost_on_path<int> mcop(ls,cost);\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-mcop.calc(s,t) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\ntemplate <class T>\nclass segtree\n{\npublic:\n    lli n;\n    vector<T> dat;\n    function<T(T, T)> func;\n    T dummy;\n    segtree<T>(lli _n, function<T(T, T)> f, T dummy) : func(f), dummy(dummy)\n    {\n        n = 1;\n        while (n < _n) {\n            n = n * 2;\n        }\n        dat.assign(2 * n - 1, dummy);\n    }\n    void update(lli k, T a)\n    {\n        k += n - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b)\n    {\n        return query(a, b, 0, 0, n);\n    }\n    // [a,b)の何かを求める.\n    T query(int a, int b, int k, int l, int r)\n    {\n        //交差しないときはダミー\n        if (r <= a || b <= l)\n            return dummy;\n        if (a <= l && r <= b)\n            return dat[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return func(vl, vr);\n        }\n    }\n    T get(int a)\n    {\n        return query(a, a + 1, 0, 0, n);\n    }\n};\ntemplate <class T>\nstruct hldec {\n    int n;\n    int col = 0;\n    vector<vector<int>> e;\n    vector<vector<int>> heavy;\n    vector<vector<int>> light;\n    vector<vector<T>> cls;\n    vector<T> vers;\n    vector<pair<int, int>> pos;\n    vector<pair<int, int>> par;\n    map<pair<int, int>, int> dict;\n    function<T(T, T)> f;\n    T unit;\n    vector<segtree<T>> vec_seg;\n    int root = 0;\n    vector<int> size;\n    hldec(int n, vector<T> vers, function<T(T, T)> f, T unit, int root = 0) : n(n), root(root), vers(vers), unit(unit), f(f)\n    {\n        e.assign(n, {});\n        par.assign(n, make_pair(-1, -1));\n        heavy.assign(n, {});\n        light.assign(n, {});\n        size.assign(n, 0);\n        pos.assign(n, make_pair(-1, -1));\n        cls.assign(n, {});\n    }\n    void add(int u, int v)\n    {\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    int sub_tree_size(int cur, int par)\n    {\n        int tmp = 1;\n        for (auto s : e[cur]) {\n            if (par != s) {\n                tmp += sub_tree_size(s, cur);\n            }\n        }\n        size[cur] = tmp;\n        return tmp;\n    }\n    void dfs_label(int cur, int par)\n    {\n        lli idx = -1;\n        lli mem = 0;\n        rep(i, e[cur].size())\n        {\n            auto s = e[cur][i];\n            if (s != par) {\n                if (size[s] > mem) {\n                    mem = size[s];\n                    idx = i;\n                }\n            }\n        }\n        if (idx == -1)\n            return;\n        rep(i, e[cur].size())\n        {\n            auto s = e[cur][i];\n            if (s != par) {\n                if (idx == i) {\n                    heavy[cur].push_back(s);\n                } else {\n                    light[cur].push_back(s);\n                }\n                dfs_label(s, cur);\n            }\n        }\n    }\n    void edge_labeling()\n    {\n        sub_tree_size(root, -1);\n        dfs_label(root, -1);\n    }\n    void dfs_arrays(int cur, int c)\n    {\n        cls[c].push_back(vers[cur]);\n        int idx = cls[c].size() - 1;\n        pos[cur] = make_pair(c, cls[c].size() - 1);\n        dict[pos[cur]] = cur;\n\n        for (auto s : heavy[cur]) {\n            dfs_arrays(s, c);\n        }\n        for (auto s : light[cur]) {\n            col++;\n            par[col] = make_pair(c, idx);\n            dfs_arrays(s, col);\n        }\n    }\n    void make_arrays()\n    {\n        dfs_arrays(root, 0);\n    }\n    void build_segtree()\n    {\n        rep(j, cls.size())\n        {\n            auto& s = cls[j];\n            int size = s.size();\n            segtree<T> seg(size, f, unit);\n            rep(i, size)\n            {\n                seg.update(i, s[i]);\n            }\n            vec_seg.push_back(seg);\n        }\n    }\n    void build(bool opt = false)\n    {\n        edge_labeling();\n        if (opt) {\n            e.clear();\n        }\n        cerr << \"labeled done\" << endl;\n        make_arrays();\n\n        cerr << \"arrays\" << endl;\n        if (opt) {\n            heavy.clear();\n            light.clear();\n        }\n\n        build_segtree();\n\n        cerr << \"seg_build\" << endl;\n    }\n    T query(int u, int v)\n    {\n\n        vector<pair<int, int>> hist_u;\n        vector<pair<int, int>> hist_v;\n        rep(j, 2)\n        {\n            int tmp = j == 1 ? u : v;\n            while (true) {\n                int cur_col = pos[tmp].first;\n                if (j)\n                    hist_u.push_back(pos[tmp]);\n                else\n                    hist_v.push_back(pos[tmp]);\n                if (cur_col == 0)\n                    break;\n                tmp = dict[par[cur_col]];\n            }\n        }\n        int pivot = 0;\n        T ans = unit;\n        set<int> hist_u_set;\n        map<int, int> post;\n        for (auto s : hist_u) {\n            hist_u_set.insert(s.first);\n            post[s.first] = s.second;\n        }\n        rep(i, hist_v.size())\n        {\n            if (hist_u_set.find(hist_v[i].first) != hist_u_set.end()) {\n                int h = post[hist_v[i].first];\n                ans = f(vec_seg[hist_v[i].first].query(min(h, hist_v[i].second), max(h, hist_v[i].second) + 1), ans);\n                pivot = hist_v[i].first;\n                break;\n            }\n        }\n\n        rep(i, hist_u.size())\n        {\n            if (hist_u[i].first == pivot)\n                break;\n            ans = f(vec_seg[hist_u[i].first].query(0, hist_u[i].second + 1), ans);\n        }\n        rep(i, hist_v.size())\n        {\n            if (hist_v[i].first == pivot)\n                break;\n            ans = f(vec_seg[hist_v[i].first].query(0, hist_v[i].second + 1), ans);\n        }\n        return ans;\n    }\n};\n\nvector<pair<lli, lli>> e[4005];\nvector<pair<lli, lli>> ne[4005];\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int a, b;\n    lli c;\n    rep(i, m)\n    {\n        cin >> a >> b >> c;\n        a--, b--;\n        e[a].push_back(make_pair(b, c));\n        e[b].push_back(make_pair(a, c));\n    }\n    using p = pair<lli, pair<lli, lli>>;\n    priority_queue<p, vector<p>, greater<p>> que;\n    bool used[4005] = {};\n    que.push(make_pair(0, make_pair(0, -1)));\n    lli ans = 0;\n    int hoge = n;\n    vector<pair<lli, lli>> edge;\n    vector<lli> v(2 * n, 0);\n    while (!que.empty()) {\n        auto cur = que.top().second;\n        auto cost = que.top().first;\n        que.pop();\n        if (used[cur.first])\n            continue;\n        used[cur.first] = true;\n        ans += cost;\n        if (cur.second != -1) {\n            edge.push_back(make_pair(cur.first, hoge));\n            edge.push_back(make_pair(cur.second, hoge));\n            v[hoge] = cost;\n            hoge++;\n        }\n        for (auto s : e[cur.first]) {\n            que.push(make_pair(s.second, make_pair(s.first, cur.first)));\n        }\n    }\n\n    auto f = [](lli u, lli v) -> lli { return max(u, v); };\n    hldec<lli> tr(hoge, v, f, 0);\n    for (auto s : edge) {\n        tr.add(s.first, s.second);\n    }\n    // tr.add(0, 1);\n    // tr.add(0, 2);\n    // tr.add(1, 3);\n    // tr.add(1, 4);\n    tr.build(true);\n    int s, t, q;\n    cin >> q;\n    rep(i, q)\n    {\n        cin >> s >> t;\n        cout << ans - tr.query(s - 1, t - 1) << endl;\n    }\n    // //cout << tr.query(0,1)<<endl;\n    // cout << tr.query(3, 4) << endl;\n};\n;\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\n\nconst int M = 400010;\nint n, m;\nint a[M], b[M];\nll c[M];\n\ntypedef pair<ll, int> PLI;\nconst int N = 4010;\nvector<PLI> edges[N];\n\nll dfs(int v, int p, int t) {\n  if (v == t) {\n    return 0;\n  }\n  REP(i, 0, edges[v].size()) {\n    PLI e = edges[v][i];\n    int w = e.second;\n    if (p == w) continue;\n    ll res = dfs(w, v, t);\n    if (res == -1) continue;\n    return max(res, e.first);\n  }\n  return -1;\n}\n\nll solve(int s, int t) {\n  return dfs(s, -1, t);\n  \n}\n\nint main(void){\n  cin >> n >> m;\n  REP(i, 0, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n  }\n  int q;\n  cin >> q;\n  assert (q <= 3001);\n  vector<PLI> pool;\n  ll tot = 0;\n  REP(i, 0, m) {\n    pool.push_back(PLI(c[i], i));\n  }\n  sort(pool.begin(), pool.end());\n  UnionFind uf(n);\n  REP(i, 0, pool.size()) {\n    int idx = pool[i].second;\n    int u = a[idx];\n    int v = b[idx];\n    if (not uf.is_same_set(u, v)) {\n      uf.unite(u, v);\n      tot += pool[i].first;\n      edges[u].push_back(PLI(pool[i].first, v));\n      edges[v].push_back(PLI(pool[i].first, u));\n    }\n  }\n  REP(i, 0, q) {\n    int s,t;\n    cin >> s >> t;\n    s--, t--;\n    // max edge in s-t path\n    ll tk = solve(s, t);\n    cout << tot - tk << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Weight=long long;\nstruct Edge{\n    int from,to;\n    Weight c;\n};\nbool operator<(const Edge &lhs,const Edge &rhs){\n    return lhs.c<rhs.c;\n}\nbool operator>(const Edge &lhs,const Edge &rhs){\n    return lhs.c>rhs.c;\n}\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nGraph MST(int n,Graph& g){\n    vector<int> used(n,false);\n    priority_queue<Edge,vector<Edge>,greater<>> que;\n    que.push({-1,0,0});\n    Graph res(n);\n    while(!que.empty()){\n        Edge ret=que.top();\n        que.pop();\n        int f=ret.from;\n        int v=ret.to;\n        Weight c=ret.c;\n        if(used[v]) continue;\n        used[v]=true;\n        if(f!=-1){\n            res[f].push_back(Edge{f,v,c});\n            res[v].push_back(Edge{v,f,c});\n        }\n        for(int i=0;i<g[v].size();i++){\n            que.push(g[v][i]);\n        }\n    }\n    return res;\n}\nint main(){\n    int n,m;;\n    cin>>n>>m;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int a,b;\n        Weight c;\n        cin>>a>>b>>c;\n        a--,b--;\n        g[a].push_back(Edge{a,b,c});      \n        g[b].push_back(Edge{b,a,c});\n    }\n    \n    Graph mst=MST(n,g);\n    Edges edges;\n    for(int i=0;i<mst.size();i++){\n        for(int j=0;j<mst[i].size();j++) edges.push_back(mst[i][j]);\n    }\n    sort(edges.begin(),edges.end(),greater<>());\n    \n    auto adder=[](Weight lhs,Edge& e){\n        return lhs+e.c;\n    };\n    Weight sum=accumulate(edges.begin(),edges.end(),0LL,adder)/2;\n    \n    vector<vector<Weight>> sc(n,vector<Weight>(n,0));\n    vector<vector<int>> slash(n,vector<int>(n,false));\n\n    function<void(int,int,vector<int>&)> dfs=[&](int v,int pre,vector<int>& vs){\n        vs.push_back(v);\n        for(int i=0;i<mst[v].size();i++){\n            if(mst[v][i].to!=pre && !slash[v][mst[v][i].to]){\n                dfs(mst[v][i].to,v,vs);\n            }\n        }\n        return;\n    };\n\n    for(int i=0;i<edges.size();i++){\n        int v0=edges[i].from;\n        int v1=edges[i].to;\n        Weight c=edges[i].c;\n        slash[v0][v1]=true;\n        slash[v1][v0]=true;\n        vector<int> v0s;\n        vector<int> v1s;\n        dfs(v0,-1,v0s);\n        dfs(v1,-1,v1s);\n        for(int j=0;j<v0s.size();j++){\n            for(int k=0;k<v1s.size();k++){\n                sc[v0s[j]][v1s[k]]=c;\n                sc[v1s[k]][v0s[j]]=c;\n            }\n        }\n    }\n\n    int q;\n    cin>>q;\n    for(int i=0;i<q;i++){\n        int s,t;\n        cin>>s>>t;\n        s--,t--;\n        cout<<sum-sc[s][t]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 400010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct UF {\n\tvector<int> par, ran;\n\tvoid init(int n) {\n\t\tpar.resize(n); ran.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tUF(int mx = 0) { init(mx); }\n\n\tint find(int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\n//////////////\n\nint N, M, E;\nstruct edge { int u, v, cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nedge es[100010];\nvector<pi> G[MAX_N];\nint depth[MAX_N];\nint par[MAX_N];\nint cost[MAX_N];\n\nint kruskal() {\n\tsort(es, es + E, comp);\n\tUF uf(N);//init union_find\n\tint res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tG[e.u].pb(pi(e.v, e.cost));\n\t\t\tG[e.v].pb(pi(e.u, e.cost));\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid add_edge(int s, int t, int cost) {\n\tes[E++] = edge{s, t, cost};\n}\n\nvoid loop(int v, int p, int k) {\n\tdepth[v] = k;\n\tpar[v] = p;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst;\n\t\tif(n == p) continue;\n\t\tcost[n] = G[v][i].sec;\n\t\tloop(n, v, k + 1);\n\t}\n}\n\nvoid solve() {\n\tE = 0;\n\tcin >> N >> M;\n\trep(i, 0, M) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c; a--; b--;\n\t\tadd_edge(a, b, c);\n\t}\n\tll S = kruskal();\n\tloop(0, -1, 0);\n\tint Q; cin >> Q;\n\twhile(Q--) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tif(depth[a] < depth[b]) swap(a, b);\n\t\tint mv = -1;\n\t\twhile(depth[a] > depth[b]) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\ta = par[a];\n\t\t}\n\t\t// debug(depth[a], depth[b], a, b);\n\t\twhile(a != b) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\tMAX(mv, cost[b]);\n\t\t\ta = par[a]; b = par[b];\n\t\t}\n\t\tcout << S - mv << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n//class LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nclass LCA{\n\tvvi par;\n\tvvl pmax;\n\tvi dep;\npublic:\n\tLCA(vector<vpil>&E,int root):\n\t\tpar(MSB(E.size())+1,vi(E.size())),\n\t\tpmax(MSB(E.size())+1,vl(E.size())),\n\t\tdep(E.size())\n\t{\n\t\tfunction<void(int,int)>dfs=[&](int i,int p){\n\t\t\tfor(pil j:E[i])if(j.first!=p){\n\t\t\t\tpar[0][j.first]=i;\n\t\t\t\tpmax[0][j.first]=j.second;\n\t\t\t\tdep[j.first]=dep[i]+1;\n\t\t\t\tdfs(j.first,i);\n\t\t\t}\n\t\t};\n\t\tpar[0][root]=root;\n\t\tdfs(root,root);\n\t\tfr(i,par.size()-1){\n\t\t\tfr(j,par[0].size()){\n\t\t\t\tpar[i+1][j]=par[i][par[i][j]];\n\t\t\t\tpmax[i+1][j]=max(pmax[i][j],pmax[i][par[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tint operator()(int a,int b){\n\t\tll z=0;\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tfor(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){\n\t\t\tif(t&1){\n\t\t\t\tchmax(z,pmax[i][b]);\n\t\t\t\tb=par[i][b];\n\t\t\t}\n\t\t}\n\t\tif(a==b)return z;\n\t\trf(i,par.size()){\n\t\t\tif(par[i][a]!=par[i][b]){\n\t\t\t\tchmax(z,pmax[i][a]);\n\t\t\t\ta=par[i][a];\n\t\t\t\tchmax(z,pmax[i][b]);\n\t\t\t\tb=par[i][b];\n\t\t\t}\n\t\t}\n\t\tchmax(z,pmax[0][a]);\n\t\tchmax(z,pmax[0][b]);\n\t\treturn z;\n\t}\n};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tvector<pair<ll,pii>>E0;\n\tfr(i,M){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tE0<<pair<ll,pii>{c,{a,b}};\n\t}\n\tSort(E0);\n\tUnionFind uf;\n\tll mst=0;\n\tvector<vpil>E(N+1);\n\tfor(auto&p:E0){\n\t\tif(!uf.same(p.second)){\n\t\t\tuf.unite(p.second);\n\t\t\tmst+=p.first;\n\t\t\tE[p.second.first]<<pil{p.second.second,p.first};\n\t\t\tE[p.second.second]<<pil{p.second.first,p.first};\n\t\t}\n\t}\n\tLCA f(E,1);\n\tint Q;cin>>Q;\n\tfr(i,Q){\n\t\tint S,T;cin>>S>>T;\n\t\tprint(mst-f(S,T));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<tuple<int, int, int>> es;\n  vector<vector<pair<int, int>>> G(N);\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es.emplace_back(c, a, b);\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es.begin(), es.end());\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  int dist[N][N];\n  zero(dist);\n\n  rep(i, N) {\n    dist[i][i] = 0;\n    queue<int> q;\n    q.push(i);\n    vector<bool> vis(N);\n    vis[i] = 1;\n    while(!q.empty()) {\n      int p = q.front();\n      q.pop();\n      rep(k, G[p].size()) {\n        int to, pc; tie(to, pc) = G[p][k];\n        if(vis[to]) continue;\n        vis[to] = 1;\n        maximize(dist[i][to], pc);\n        q.push(to);\n      }\n    }\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; cin >> s >> t; s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mk(a,b) make_pair(a,b)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, pll> plpll;\ntypedef pair<pll, pll> llll;\n\nint N, M;\nvector<pll> G[4010];\nvector<pll> T[4010];\nvector<pll> cost;\nvector<plpll> E;\nbool is_tree[400010];\nint par[4010];\nll sum;\nint current_root;\nll max_cost[4010][4010];\n\nvoid init(int N)\n{\n    for(int i = 0; i < N; i++)par[i] = i;\n    return;\n}\n\nint root(int x)\n{\n    if(par[x] == x)return x;\n    return par[x] = root(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n    x = root(x);\n    y = root(y);\n\n    if(x == y)return;\n\n    par[x] = y;\n    return;\n}\n\nbool same(int x, int y)\n{\n    return root(x) == root(y);\n}\n\nvoid DFS(int v, int p = -1, ll d = 0)\n{\n    max_cost[current_root][v] = d;\n    for(int i = 0; i < T[v].size(); i++)\n    {\n        int next = T[v][i].fi, id = T[v][i].se;\n        ll cost = E[id].fi;\n        if(p == next || !is_tree[id])continue;\n        DFS(next, v, max(d, cost));\n    }\n    return;\n}\n\nint main()\n{\n    cin >> N >> M;\n    for(int i = 0; i < M; i++)\n    {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        cost.push_back(mk(c, i));\n        E.push_back(mk(c, mk(a, b)));\n        G[a].push_back(mk(b, i));\n        G[b].push_back(mk(a, i));\n    }\n\n    init(N);\n    sort(cost.begin(), cost.end());\n    for(int i = 0; i < M; i++)\n    {\n        int now = cost[i].se;\n        int a = E[now].se.fi, b = E[now].se.se;\n        if(!same(a, b))\n        {\n            sum += cost[i].fi;\n            T[a].push_back(mk(b, now));\n            T[b].push_back(mk(a, now));\n            is_tree[now] = true;\n            unite(a, b);\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n    {\n        current_root = i;\n        DFS(i);\n    }\n\n    int Q;\n    cin >> Q;\n    for(int i = 0; i < Q; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        cout << sum - max_cost[a][b] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\nvector<pair<lli, lli>> e[4005];\nvector<pair<lli, lli>> ne[4005];\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int a, b;\n    lli c;\n    rep(i, m)\n    {\n        cin >> a >> b >> c;\n        a--, b--;\n        e[a].push_back(make_pair(b, c));\n        e[b].push_back(make_pair(a, c));\n    }\n    lli q;\n    cin >> q;\n    if (q != 1)\n        return 0;\n    cin >> a >> b;\n    a--, b--;\n    using p = pair<lli, pair<lli, lli>>;\n    priority_queue<p, vector<p>, greater<p>> que;\n    bool used[4005] = {};\n    que.push(make_pair(0, make_pair(a, -1)));\n    que.push(make_pair(0, make_pair(b, -1)));\n    lli ans = 0;\n    while (!que.empty()) {\n        auto cur = que.top().second;\n        auto cost = que.top().first;\n        que.pop();\n        if (used[cur.first])\n            continue;\n        ans += cost;\n        used[cur.first] = true;\n        if (cur.second != -1) {\n            e[cur.first].push_back(make_pair(cur.second, cost));\n            e[cur.second].push_back(make_pair(cur.first, cost));\n        }\n        for (auto s : e[cur.first]) {\n            que.push(make_pair(s.second, make_pair(s.first, cur.first)));\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \ntemplate<class T>\nstruct SparseTable{\n\tvector<T> st[21];\n\tvoid Init(int N,vector<T> data){\n\t\tif(N<=0)\n\t\t\treturn;\n\t\tint h = 1;\n\t\twhile ((1 << h) < N) h++;\n\t\tfor(int i=0;i<N;i++) st[0].push_back(data[i]);\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tfor(int i=0;i<N-(1<<j)+1;i++){\n\t\t\t\tst[j].push_back(min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]));\n\t\t\t}\n\t\t}\n\t}\n\tinline int TopBit(int t){\n\t\treturn 31-__builtin_clz(t);\n\t}\n\tT GetMin(int b,int e){\n\t\tint diff = TopBit(e-b);\n\t\treturn min(st[diff][b], st[diff][e - (1 << diff)]);\n\t}\n};\nstruct LowestCommonAncestor{\n    int N;\n    vector<int> path, depth, in_order, out_order;\n    std::vector<pair<int,int>> dat;\n\tSparseTable<pair<int,int>> table;\n\n    LowestCommonAncestor(const vector<vector<int>> &G,int root)\n        : N(G.size()),\n          path(N * 2 - 1),\n          depth(N * 2 - 1),\n          in_order(N),\n          out_order(N) {\n        int k = 0;\n        dfs(G, root, -1, 0, k);\n        for (int i = 0; i < (int)depth.size(); ++i){\n            dat.push_back(make_pair(depth[i],i));\n\t\t}\n\t\ttable.Init(dat.size(),dat);\n    }\n\n    int Querry(int u,int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = table.GetMin(l,r);\n        return path[res.second];\n    }\n\n    void dfs(const vector<vector<int>> &G,int v,int f,int d,int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : G[v]){\n            if (e != f) {\n                dfs(G,e,v,d+1,k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k-1;\n    }\n};\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\npair<long,pair<int,int>> Edge[400000];\nlong cost[3999];\nint leader[4000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tfor(int i=0;i<M;i++){\n\t\tint f = rei()-1;\n\t\tint t = rei()-1;\n\t\tEdge[i] = {rel(),{f,t}};\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tleader[i] = i+N-1;\n\t}\n\tsort(Edge,Edge+M);\n\tvector<vector<int>> G(2*N-1);\n\tUnionFind U(N);\n\tint c = N-2;\n\tlong ans = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint f = Edge[i].second.first;\n\t\tint t = Edge[i].second.second;\n\t\tif(!U.Same(f,t)){\n\t\t\tcost[c] = Edge[i].first;\n\t\t\tans += Edge[i].first;\n\t\t\tG[c].push_back(leader[U.Get(f)]);\n\t\t\tG[c].push_back(leader[U.Get(t)]);\n\t\t\tU.Union(f,t);\n\t\t\tleader[U.Get(f)] = c--;\n\t\t}\n\t}\n\tLowestCommonAncestor LCA(G,0);\n\tint Q = rei();\n\tfor(int i=0;i<Q;i++){\n\t\tint s = rei()-1;\n\t\tint t = rei()-1;\n\t\tcout << ans - cost[LCA.Querry(s+N-1,t+N-1)] << endl;;\n\t}\n\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nclass UnionFind {\n    int cnt;\n    vector<int> par, rank, size;\npublic:\n    UnionFind() {}\n    UnionFind(int _n) :cnt(_n), par(_n), rank(_n), size(_n, 1) {\n        for (int i = 0; i<_n; ++i) par[i] = i;\n    }\n    int find(int k) {\n        return (k == par[k]) ? k : (par[k] = find(par[k]));\n    }\n    int operator[](int k) {\n        return find(k);\n    }\n    int getSize(int k) {\n        return size[find(k)];\n    }\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return;\n        --cnt;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            size[y] += size[x];\n        } else {\n            par[y] = x;\n            size[x] += size[y];\n            if (rank[y] == rank[x]) ++rank[x];\n        }\n    }\n    int count() {\n        return cnt;\n    }\n};\n\ntemplate<class Weight>\nstruct KruskalMST {\n    using Edges = vector<tuple<Weight, int, int>>;\n    Weight sum;\n    Edges mst;\n    KruskalMST(int V, Edges edges) :sum(0) {\n        sort(edges.begin(), edges.end());\n        UnionFind uf(V);\n        each(e, edges) {\n            Weight w;\n            int u, v;\n            tie(w, u, v) = e;\n            if (uf[u] != uf[v]) {\n                mst.emplace_back(e);\n                uf.unite(u, v);\n                sum += w;\n            }\n        }\n    }\n};\n\nint N, M, ma[4001][4001];\nvector<pii> G[4001];\n\nvoid dfs(int u, int s, int p=-1, int x=0) {\n    ma[s][u] = x;\n    each(e, G[u]) {\n        if (e.first != p) {\n            dfs(e.first, s, u, max(x, e.second));\n        }\n    }\n}\n\nvoid solve() {\n    cin >> N >> M;\n\n    vector<tuple<ll, int, int>> E(M);\n    rep(i, M) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        E[i] = tie(c, a, b);\n    }\n\n    auto mst = KruskalMST<ll>(N, E);\n    each(e, mst.mst) {\n        ll ww;\n        int w, u, v;\n        tie(ww, u, v) = e;\n        w = (int)ww;\n        G[u].emplace_back(v, w);\n        G[v].emplace_back(u, w);\n    }\n\n    rep(i, N)dfs(i, i);\n\n    int Q;\n    cin >> Q;\n    rep(i, Q) {\n        int s, t;\n        cin >> s >> t;\n        --s; --t;\n        ll ans = mst.sum - ma[s][t];\n        cout << ans << endl;\n    }\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct UnionFind {\n    int n, cc, *u;\n    UnionFind() : n(0), cc(0), u(NULL) {}\n    UnionFind(int n_) : n(n_), cc(n_) {\n\tu = new int[n_];\n\tmemset(u, -1, sizeof (int) * n);\n    }\n    UnionFind(const UnionFind &y) : n(y.n), cc(y.cc) {\n\tu = new int[y.n];\n\tmemcpy(u, y.u, sizeof (int) * n);\n    }\n    ~UnionFind() {\n\tdelete[] u; u = NULL;\n\tn = cc = 0;\n    }\n    friend void swap(UnionFind &x, UnionFind &y) {\n\tswap(x.n, y.n); swap(x.cc, y.cc); swap(x.u, y.u);\n    }\n    UnionFind& operator=(UnionFind y) { \n\tswap(*this, y);\n\treturn *this;\n    }\n    int root(int x) {\n\tint y = x, t;\n\twhile (u[y] >= 0) y = u[y];\n\twhile (x != y) { t = u[x]; u[x] = y; x = t; }\n\treturn y;\n    }\n    bool link(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tif (u[y] < u[x]) swap(x, y);\n\tu[x] += u[y]; u[y] = x; cc--;\n\treturn true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -u[root(x)]; }\n    int count() { return cc; }\n};\n\n\nint N, M;\nstruct Edge {\n    int x, y;\n    int c;\n    \n    bool operator<(const Edge &e) const {\n\treturn c < e.c;\n    }\n} E[400011];\nvector<pair<int, int> > G[4011];\nint par[15][4011];\nint cst[15][4011];\nint depth[4011];\n\nint get_max(int x, int y) {\n    int ret = 0;\n    if (depth[x] > depth[y]) swap(x, y);\n    for (int t=15; t--;) {\n\tif ((depth[y]-depth[x])>>t&1) {\n\t    amax(ret, cst[t][y]);\n\t    y = par[t][y];\n\t}\n    }\n    if (x == y) return ret;\n    for (int t=15; t--;) {\n\tif (par[t][x] != par[t][y]) {\n\t    amax(ret, cst[t][x]);\n\t    amax(ret, cst[t][y]);\n\t    x = par[t][x];\n\t    y = par[t][y];\n\t}\n    }\n    amax(ret, cst[0][x]);\n    amax(ret, cst[0][y]);\n    return ret;\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, M) {\n\tint a, b, c;\n\tscanf(\"%d%d%d\", &a, &b, &c);\n\ta--; b--;\n\tE[i].x = a;\n\tE[i].y = b;\n\tE[i].c = c;\n    }\n\n    LL sum = 0;\n    sort(E, E+M);\n    UnionFind U(N);\n    REP (i, M) {\n\tint x = E[i].x;\n\tint y = E[i].y;\n\tint c = E[i].c;\n\tif (!U.same(x, y)) {\n\t    G[x].emplace_back(y, c);\n\t    G[y].emplace_back(x, c);\n\t    U.link(x, y);\n\t    sum += c;\n\t}\n    }\n    VI ord;\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (e->first != par[0][v]) {\n\t    par[0][e->first] = v;\n\t    cst[0][e->first] = e->second;\n\t    depth[e->first] = depth[v] + 1;\n\t    ord.push_back(e->first);\n\t}\n    }\n\n    REP (t, 14) REP (i, N) {\n\tint p = par[t][i];\n\tpar[t+1][i] = par[t][p];\n\tcst[t+1][i] = max(cst[t][i], cst[t][p]);\n    }\n\n    int Q;\n    scanf(\"%d\", &Q);\n    REP ($, Q) {\n\tint s, t;\n\tscanf(\"%d%d\", &s, &t);\n\ts--; t--;\n\tLL ans = sum - get_max(s, t);\n\tprintf(\"%lld\\n\", ans);\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#define TESTING\n\n// INCLUDE\n#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <numeric>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <cassert>\n\nusing namespace std;\n\n// types\ntypedef long long            int64 ;\ntypedef unsigned long long   uint64 ;\ntypedef unsigned char uchar;\ntypedef unsigned short ushort;\ntypedef int64 hash_type;\n\n// Shortcuts\n#define all(_xx)             _xx.begin(), _xx.end()\n#define pb                   push_back\n#define SS                   stringstream\n#define mp(XX, YY)           make_pair(XX, YY)\n#define fi                   first\n#define se                   second\n\n#define pii                  pair<int, int>\n#define pcc                  pair<char, char>\n#define pucc                 pair<uchar, uchar>\n#define pll                  pair<long long, long long>\n#define pdd                  pair<double, double>\n\n#define vl                   vector<long long>\n#define vs                   vector<string>\n#define vd                   vector<double>\n#define vc                   vector<char>\n#define vi                   vector<int>\n#define vvc                  vector<vector<char>>\n#define vvi                  vector<vector<int>>\n#define vvl                  vector<vector<long long>>\n#define vpcc                 vector<pair<char,char> >\n#define vpdd                 vector<pair<double,double> >\n#define vpii                 vector<pair<int,int>> \n#define vpll                 vector<pair<long long,long long>> \n\n#define re(II, NN)           for (int II(0), _NN(NN); (II) < (_NN); ++(II))\n#define fod(II, XX, YY)      for (int II(XX), _YY(YY); (II) >= (_YY); --(II))\n#define fo(II, XX, YY)       for (int II(XX), _YY(YY); (II) <= (_YY); ++(II))\n\ntemplate <class T> int size (const T& value) {return value.size();}\n\n// ostream operator for STL types: pair, vector, vector<vector>, set, unordered_set, map, unordered_map\ntemplate <class T>\nstd::ostream& PrintContainer (std::ostream& stream, const T& container) {\n    for (auto el : container) stream << el << \" \"; return stream;\n}\n\ntemplate<class T> std::ostream&  operator <<(std::ostream& stream, const set<T> & s) {\n    return PrintContainer (stream, s);\n}\n\ntemplate<class T> std::ostream&  operator <<(std::ostream& stream, const unordered_set<T> & s) {\n    return PrintContainer (stream, s);\n}\n\ntemplate<class T> std::ostream&  operator << (std::ostream& stream, const vector<T> & v) {\n    return PrintContainer (stream, v);\n}\n\ntemplate<class T, class V> std::ostream&  operator << (std::ostream& stream, const map<T, V> & m) {\n    return PrintContainer (stream, m);\n}\n\ntemplate<class T, class V> std::ostream&  operator << (std::ostream& stream, const unordered_map<T, V> & m) {\n    return PrintContainer (stream, m);\n}\n\ntemplate<class T, class V> std::ostream&  operator << (std::ostream& stream, const pair<T, V> & p) {\n    stream << p.first << \",\" << p.second << \" \";\n    return stream;\n}\n\ntemplate<class T> std::ostream&  operator <<(std::ostream& stream, const vector<vector<T> > & v) {\n    for (auto line : v) { for (auto el : line) stream << el << \" \"; stream << \"\\n\";}\n    return stream;\n}\n// End ostream\n\n// Variable debug, enabled with TESTING\n#ifdef TESTING\n// Adapted from http://codeforces.com/blog/entry/15643\nvector<string> debug_split(const string& s, char c) {\n    vector<string> v; stringstream ss(s); string x;\n    while (getline(ss, x, c)) v.emplace_back(x); return move(v);}\n\nvoid debug_err() {cerr << \"\\n\";}\ntemplate<typename T, typename... Args>\nvoid debug_err(vector<string>::iterator it, T a, Args... args) {\n    cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" | \";\n    debug_err(++it, args...);\n}\n\nclass Debugger {\npublic:\n    template <class T> void Output (const T& v) {cerr << v << \" \";}\n    template <class T> Debugger& operator , (const T& v) {Output(v);return *this;}\n} dbg;\n\n#define trace(args...) { vector<string> _v = debug_split(#args, ','); debug_err(_v.begin(), args); }\n#define warn(args...) {dbg,args; cerr << \"\\n\"; cerr.flush();}\n#define echo(arg) {cerr << #arg << \": \"; dbg,arg; cerr << \"\\n\"; cerr.flush();}\n#else\n#define warn(args...) {}\n#define echo(arg) {}\n#define trace(args..) {}\n#endif\n// End debug\n\n// Helper\ntemplate <typename U, typename V>\nvoid remin (U& A, V B) {\n    if (A > B) A = B;\n}\n\ntemplate <typename U, typename V>\nvoid remax (U& A, V B) {\n    if (A < B) A = B;\n}\n//---- End of template code -----//\nconst int MAXN = 4001;\n\nint N, M, Q;\n\nvector<pair<int, pair<int, int>>> edges;\nvector<vector<int>> g;\n\nint answer[MAXN][MAXN];\nint cost[MAXN][MAXN];\nint64 tot_cost;\n\nint parent[MAXN];\n\nint find_parent(int x) {\n    if (x != parent[x])\n        return parent[x] = find_parent(parent[x]);\n    return x;\n}\n\nvoid dfs(int x, int p, int el, int cur) {\n    answer[el][x] = answer[x][el] = cur;\n    for (auto v : g[x]) {\n        if (v != p) {\n            dfs(v, x, el, max(cur, cost[x][v]));\n        }\n    }\n}\n\nint main() {\n    cin >> N >> M;\n    for (int i = 1; i <= M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        edges.push_back(make_pair(c, make_pair(a, b)));\n    }\n\n    sort(edges.begin(), edges.end());\n\n    for (int i = 0; i < N; i++)\n        parent[i] = i;\n\n    g.resize(N);\n\n    //cerr << \"?\\n\";\n\n    for (auto e : edges) {\n        int c = e.first;\n        int a = e.second.first;\n        int b = e.second.second;\n\n        if (find_parent(a) != find_parent(b)) {\n            tot_cost += c;\n            if (rand() & 1) {\n                parent[ parent[a] ] = parent[b];\n            } else {\n                parent[ parent[b] ] = parent[a];\n            }\n            g[a].push_back(b);\n            g[b].push_back(a);\n\n            cost[a][b] = c;\n            cost[b][a] = c;\n\n            //for (int i = 0; i < N; i++) cerr << parent[i] << \" \";\n            //cerr << \"\\n\";\n            //cerr << a << \" \" << b << \"\\n\";\n        }\n    }\n\n    //cerr << \"dfs\\n\";\n\n    for (int i = 0; i < N; i++)\n        dfs(i, -1, i, 0);\n\n    //cerr << \"yeah\\n\";\n    cin >> Q;\n    for (int i = 1; i <= Q; i++) {\n        int S, T;\n        cin >> S >> T;\n        S--, T--;\n        cout << tot_cost - answer[S][T] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    union_find uf(n);\n    vector<bool> use(m);\n    int sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        use[i]=true;\n    }\n\n    vector<vector<pair<int,int>>> graph(n);\n    rep(i,0,m){\n        if(!use[i]) continue;\n        graph[edges[i].from].push_back(make_pair(edges[i].to,edges[i].cost));\n        graph[edges[i].to].push_back(make_pair(edges[i].from,edges[i].cost));\n    }\n\n    vector<vector<int>> max_cost(n,vector<int>(n));\n    vector<bool> done(n);\n    function<void(int,int,int)> dfs=[&](int s,int u,int ma){\n        done[u]=true;\n        max_cost[s][u]=ma;\n        for(auto &p:graph[u]){\n            if(done[p.first]) continue;\n            dfs(s,p.first,max(ma,p.second));\n        }\n        done[u]=false;\n    };\n    rep(i,0,n) dfs(i,i,0);\n    rep(i,0,n) rep(j,0,n) assert(max_cost[i][j]==max_cost[j][i]);\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-max_cost[s][t] << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    int64_t sum_cost=0;\n    vector<vector<int>> mst(n);\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        mst[e.from].push_back(e.to);\n        mst[e.to].push_back(e.from);\n    }\n\n    int root=0;\n    vector<vector<int>> children(n);\n    function<void(int,int)> dfs=[&](int u,int p){\n        for(int v:mst[u]){\n            if(v==p) continue;\n            children[u].push_back(v);\n            dfs(v,u);\n        }\n    };\n    dfs(root,-1);\n    lca_solver ls(children,root);\n\n    vector<vector<int>> max_cost(20,vector<int>(n));\n    rep(i,0,n){\n        if(i==root) continue;\n        int j=ls.parent_pow2[0][i];\n        max_cost[0][i]=cost[i][j];\n    }\n    rep(i,1,20){\n        rep(j,0,n){\n            if(ls.depth[j]-(1<<i)<0) continue;\n            max_cost[i][j]=max(max_cost[i-1][j],max_cost[i-1][ls.parent_pow2[i-1][j]]);\n        }\n    }\n\n    auto f=[&](int u,int v){\n        int res=0;\n        rep(i,0,20){\n        //for(int i=19; i>=0; --i){\n            if(ls.depth[u]-ls.depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls.parent_pow2[i][u];\n            }\n        }\n        return res;\n    };\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        int u=ls.lca(s,t);\n        cout << sum_cost-max(f(s,u),f(t,u)) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 1010;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    tuple<ll, int, int> edges[M];\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = {c, --a, --b};\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    vector<pair<int, int>> path[N];\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    // 0を親としたときの各ノードの深さ\n    int d[N];\n    fill(d, d + N, -1);\n    d[0] = 0;\n\n    // lca[x][v] = (vから2^xだけ遡った頂点,\n    //              そこに行くまでに辿った辺でのコストの最大値)\n    pair<int, ll> lca[15][N];\n    lca[0][0] = mp(0, 0);\n\n    // 幅優先探索でdとlca[0]を埋める\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto p : path[v]) {\n            int sv, cost;\n            tie(sv, cost) = p;\n            if (d[sv] >= 0) continue;\n\n            d[sv] = d[v] + 1;\n            lca[0][sv] = mp(v, cost);\n            que.push(sv);\n        }\n    }\n\n    // lcaを埋める\n    for (int x = 1; x < 15; ++x) {\n        for (int v = 0; v < N; ++v) {\n            int mid = lca[x - 1][v].first;\n            ll cost = max(lca[x - 1][v].second, lca[x - 1][mid].second);\n\n            lca[x][v] = mp(lca[x - 1][mid].first, cost);\n        }\n    }\n\n    // ようやくクエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        ll trim = 0;\n        if (d[s] > d[t]) swap(s, t);\n        // d[s] <= d[t]\n        // tの深さをsに合わせる\n\n        while (d[s] < d[t]) {\n            // sより浅くないtの祖先を漁る\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && d[s] > d[lca[x][t].first]) continue;\n                trim = max(trim, lca[x][t].second);\n                t = lca[x][t].first;\n            }\n        }\n\n        // LCAを探す\n        while (s != t) {\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && lca[x][s].first == lca[x][t].first) continue;\n                trim = max(trim, max(lca[x][s].second, lca[x][t].second));\n                s = lca[x][s].first;\n                t = lca[x][t].first;\n            }\n        }\n\n        cout << total - trim << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n    Edge(int f, int t, int c) : from(f), to(t), cost(c) {}\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nconst int MAXN = 4010;\nstruct UnionFind {\n    int node[MAXN];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        node[x] += node[y];\n        node[y] = x;\n        return true;\n    }\n};\n\nusing Graph = vector< vector<Edge> >;\nint max_edge[MAXN][MAXN];\n\nvoid dfs(Graph &G, int cur, int par, int orig) {\n    int prev_max = (par < 0 ? 0 : max_edge[orig][par]);\n    for(auto e : G[cur]) {\n        if(e.to == par) continue;\n        chmax(max_edge[orig][e.to], max(prev_max, e.cost));\n        dfs(G, e.to, cur, orig);\n    }\n}\n \nUnionFind uf;\nsigned main() {\n    int N, M; cin >> N >> M;\n    \n    vector<Edge> edges;\n    for(int i=0; i<M; i++) {\n        int u, v, cost; cin >> u >> v >> cost;\n        u--; v--;\n        edges.emplace_back(u, v, cost);\n    }\n    sort(edges.begin(), edges.end());\n\n    int sum = 0;\n    Graph MST(N);\n    for(int i=0; i<M; i++) {\n        Edge e = edges[i];\n        if(uf.unite(e.from, e.to)) {\n            MST[e.from].emplace_back(e.from, e.to  , e.cost);\n            MST[e.to  ].emplace_back(e.to,   e.from, e.cost);\n            sum += e.cost;\n        }\n    }\n\n    for(int i=0; i<N; i++) dfs(MST, i, -1, i);\n\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            printf(\"max_edge[%lld][%lld] = %lld\\n\", i+1, j+1, max_edge[i][j]);\n        }\n    }\n    */\n\n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        // printf(\"max_edge = %lld\\n\", max_edge[s][t]);\n        cout << sum - max(max_edge[s][t], max_edge[t][s]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\ntypedef struct UnionFindTree{\n    vector<int> par;\n\n    UnionFindTree(int n): par(n, -1){}\n\n    int find(int x){\n        if(par[x] < 0) return x;\n        return par[x] = find(par[x]);\n    }\n\n    int size(int x){\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n}UF;\n\ntemplate<class T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n\ntemplate<class T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n\n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n\n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n\n    pair<bool, vector<T>> bellman_ford(int s){\n        T d_INF = numeric_limits<T>::max();\n        vector<T> d(n, d_INF);\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        d[s] = 0;\n        rep(i, n)for(edge<T> &e: E){\n            if(d[e.from] != d_INF && d[e.from] + e.cost < d[e.to]){\n                d[e.to] = d[e.from] + e.cost;\n                if(i == n-1) return make_pair(true, d);\n            }\n        }\n        return make_pair(false, d);\n    }\n\n    vector<T> dijkstra(int s){\n        using P = pair<T, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<T> d(n, numeric_limits<T>::max());\n        d[s] = 0;\n        que.push(P((T)0, s));\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(edge<T> &e : G[v]){\n                if(d[e.to] > d[v] + e.cost){\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n        return d;\n    }\n\n    pair<bool, vector<vector<T>>> warshall_floyd(){\n        T d_INF = numeric_limits<T>::max();\n        vector<vector<T>> d = vector<vector<T>>(n, vector<T>(n, d_INF));\n        rep(i, n){\n            for(edge<T> &e: G[i]) d[i][e.to] = e.cost;\n            d[i][i] = 0;\n        }\n        rep(k, n)rep(i, n)rep(j, n)if(d[i][k] < d_INF && d[k][j] < d_INF){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        rep(i, n)if(d[i][i] < 0) return make_pair(true, d);\n        return make_pair(false, d);\n    }\n\n    pair<T, Graph<T>> kruskal(){\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        sort(E.begin(), E.end(), [](const edge<T> &e1, const edge<T> &e2){return e1.cost < e2.cost;});\n        UF uf(n);\n        T ret = 0;\n        Graph<T> MST(n);\n        for(edge<T> &e: E){\n            if(!uf.same(e.from, e.to)){\n                uf.unite(e.from, e.to);\n                ret += e.cost;\n                MST.add_edge(e.from, e.to, e.cost);\n                MST.add_edge(e.to, e.from, e.cost);\n            }\n        }\n        return {ret, MST};\n    }\n\n    pair<bool, vector<int>> toposo(){\n        vector<int> ret(n, -1), in(n, 0);\n        rep(i, n)for(edge<T> &e: G[i]) ++in[e.to];\n        int cur = 0;\n        stack<int> st;\n        rep(i, n)if(!in[i]) st.push(i);\n        if(st.empty()) return make_pair(false, ret);\n        while(!st.empty()){\n            int v = st.top(); st.pop();\n            ret[cur++] = v;\n            for(edge<T> &e: G[v]){\n                if(!in[e.to]) return make_pair(false, ret);\n                --in[e.to];\n                if(!in[e.to]) st.push(e.to);\n            }\n        }\n        return make_pair(cur==n, ret);\n    }\n\n    bool has_cycle(){\n        return !toposo().fi;\n    }\n\n    void scc_dfs(int v, vector<bool> &used, vector<int> &vs){\n        used[v] = true;\n        for(edge<T> &e: G[v])if(!used[e.to]) scc_dfs(e.to, used, vs);\n        vs.push_back(v);\n    }\n\n    void scc_rdfs(int v, int k, vector<int> &cmp, vector<bool> &used, vector<vector<int>> &rG){\n        used[v] = true;\n        cmp[v] = k;\n        for(int nv: rG[v])if(!used[nv]) scc_rdfs(nv, k, cmp, used, rG);\n    }\n\n    tuple<int, vector<int>, vector<vector<int>>> scc(){\n            vector<vector<int>> rG(n);\n            rep(i, n)for(edge<T> &e: G[i]) rG[e.to].push_back(i);\n            vector<bool> used(n, false);\n            vector<int> vs;\n            vector<int> vtoc(n);\n            rep(i, n)if(!used[i]) scc_dfs(i, used, vs);\n            fill(used.begin(), used.end(), false);\n            int k = 0;\n            vector<vector<int>> ctov=vector<vector<int>>(n, vector<int>());\n            rrep(i, n)if(!used[vs[i]]) scc_rdfs(vs[i], k++, vtoc, used, rG, ctov);\n            return make_tuple(k, vtoc, ctov);\n    }\n\n    int bridge_dfs(int v, int pv, int &idx, vector<int> &ord, vector<int> &low, vector<pii> &bridge){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=pv){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], bridge_dfs(nv, v, idx, ord, low, bridge));\n                if(low[nv]>ord[v]) bridge.emplace_back(min(v, nv), max(v, nv));\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<pii> get_bridge(){\n        vector<int> ord(n, -1), low(n, -1);\n        vector<pii> bridge;\n        int idx=0;\n        bridge_dfs(0, -1, idx, ord, low, bridge);\n        sort(bridge.begin(), bridge.end());\n        bridge.erase(unique(bridge.begin(), bridge.end()), bridge.end());\n        return bridge;\n    }\n\n    int art_dfs(int v, int prev, int &idx, vector<int> &ord, vector<int> &low, vector<int> &art){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=prev){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], art_dfs(nv, v, idx, ord, low, art));\n                if((prev<0 && ord[nv]!=1) || (prev>=0 && low[nv]>=ord[v])){\n                    art.push_back(v);\n                }\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<int> get_art(){\n        vector<int> ord(n, -1), low(n, -1), art;\n        int idx=0;\n        art_dfs(0, -1, idx, ord, low, art);\n        sort(art.begin(), art.end());\n        art.erase(unique(art.begin(), art.end()), art.end());\n        return art;\n    }\n};\n\nlint M[4010][4010];\nmultiset<lint> S;\n\nvoid dfs(int v, int pv, int root, Graph<lint> &mst){\n    if(v != root) M[root][v] = *S.rbegin();\n    for(auto &e: mst.G[v])if(e.to != pv){\n        S.insert(e.cost);\n        dfs(e.to, v, root, mst);\n        S.erase(S.find(e.cost));\n    }\n}\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    Graph<lint> gr(n);\n    rep(i, m){\n        int a, b;\n        lint c;\n        scanf(\"%d%d%lld\", &a, &b, &c);\n        --a; --b;\n        gr.add_edge(a, b, c);\n        gr.add_edge(b, a, c);\n    }\n    lint w;\n    Graph<lint> mst(n);\n    tie(w, mst) = gr.kruskal();\n    rep(i, n) dfs(i, -1, i, mst);\n\n    int q;\n    scanf(\"%d\", &q);\n    rep(_, q){\n        int s, t;\n        scanf(\"%d%d\", &s, &t);\n        --s; --t;\n        printf(\"%lld\\n\", w - M[s][t]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\n\nstruct uni {\n  vector<int> p;\n  uni(int n) :\n      p(n, -1) {}\n  int root(int a) {\n    return p[a] < 0 ? a : (p[a] = root(p[a]));\n  }\n  bool find(int a, int b) {\n    return root(a) == root(b);\n  }\n  bool merge(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return false;\n    p[a] = b;\n    return true;\n  }\n};\n\nstruct edge {\n  int f, t, c;\n  edge() {}\n  edge(int f, int t, int c) :\n      f(f), t(t), c(c) {}\n  bool operator<(const edge& e) const {\n    return c < e.c;\n  }\n};\n\nedge e[444444];\nvector<edge> g[4444];\nint res[4444][4444];\n\nvoid solve(int f, int v, int p, int c) {\n  res[f][v] = c;\n  for (int i = 0; i < int(g[v].size()); i++) {\n    if (g[v][i].t == p) continue;\n    solve(f, g[v][i].t, v, max(c, g[v][i].c));\n  }\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  uni u(n);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &e[i].f, &e[i].t, &e[i].c);\n    --e[i].f;\n    --e[i].t;\n  }\n  sort(e, e+m);\n  long long c = 0;\n  for (int i = 0; i < m; i++) {\n    if (u.merge(e[i].f, e[i].t)) {\n      c += e[i].c;\n      g[e[i].f].push_back(edge(e[i].f, e[i].t, e[i].c));\n      g[e[i].t].push_back(edge(e[i].t, e[i].f, e[i].c));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    solve(i, i, -1, 0);\n  }\n  int q; scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int s, t; scanf(\"%d%d\", &s, &t); --s; --t;\n    printf(\"%lld\\n\", c-res[s][t]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, m;\nint q;\n\nstruct edge{int cost, u, v;};\nvector<edge> edges;\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nint ans[4000][4000];\n\nstruct UnionFind {\n  vector<int> par, rank;\n  UnionFind(int size) : par(size), rank(size)\n  {\n    rep(i, size) par[i] = i;\n  }\n\n  int find_root(int x) {\n    if (par[x] != x) return par[x] = find_root(par[x]);\n    else return x;\n  }\n\n  bool same(int x, int y) {\n    return find_root(x) == find_root(y);\n  }\n\n  void unite(int x, int y, int c) {\n    int u = find_root(x);\n    int v = find_root(y);\n    rep(i, n)rep(j, n) {\n      if ((find_root(i) == u && find_root(j) == v) || (find_root(i) == v && find_root(j) == u)) {\n        ans[i][j] = c;\n      }\n    }\n    if (rank[u] > rank[v]) swap(u, v);\n    par[u] = v;\n    if (rank[u] == rank[v]) rank[v]++;\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    edges.push_back({c, a, b});\n  }\n\n  sort(all(edges), comp);\n  UnionFind uf(n);\n  int sum_cost = 0LL;\n  rep(i, m) {\n    edge e = edges[i];\n    if (uf.same(e.u, e.v)) continue;\n    uf.unite(e.u, e.v, e.cost);\n    sum_cost += e.cost;\n  }\n\n  cin >> q;\n  rep(i, q) {\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum_cost - ans[s][t] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN -2147483648\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int,int> P;\n\nstruct node {\n\tbool done;\n\tvi to, dist;\n\tint id, from;\n\tll d;\n\tint depth;\n\tbool operator<(const node & another) const {\n\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t}\n};\n\nclass Prim {\npublic:\n\tvector<node> nodes;\n\tint n;\n\tPrim(vector<node> A) {\n\t\tn = A.size();\n\t\tnodes = A;\n\t\tpriority_queue<node> pq;\n\t\tnodes[0].d = 0;\n\t\tpq.push(nodes[0]);\n\t\twhile (pq.size()) {\n\t\t\tnode focus = pq.top(); pq.pop();\n\t\t\tif (nodes[focus.id].done) continue;\n\t\t\tLoop(i, focus.to.size()) {\n\t\t\t\tint b = focus.to[i];\n\t\t\t\tif (!nodes[b].done && focus.dist[i] < nodes[b].d) {\n\t\t\t\t\tnodes[b].d = focus.dist[i];\n\t\t\t\t\tnodes[b].from = focus.id;\n\t\t\t\t\tnodes[b].depth = focus.depth + 1;\n\t\t\t\t\tpq.push(nodes[focus.to[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodes[focus.id].done = true;\n\t\t}\n\t\treturn;\n\t}\n\t//sとtをつなぐパスの中で最もコストの大きい辺のコストを返す\n\tll max_path_between(int s, int t) {\n\t\tll ret = 0;\n\t\twhile (nodes[s].depth > nodes[t].depth) {\n\t\t\tret = max(ret, nodes[s].d);\n\t\t\ts = nodes[s].from;\n\t\t}\n\t\twhile (nodes[s].depth < nodes[t].depth) {\n\t\t\tret = max(ret, nodes[t].d);\n\t\t\tt = nodes[t].from;\n\t\t}\n\t\twhile (s != t) {\n\t\t\tret = max(ret, max(nodes[s].d, nodes[t].d));\n\t\t\ts = nodes[s].from;\n\t\t\tt = nodes[t].from;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<node> nodes(n);\n\tLoop(i, n) nodes[i] = { false,{},{}, i, -1, INFLL, 0 };\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\ts--; t--;\n\t\tnodes[s].to.push_back(t);\n\t\tnodes[s].dist.push_back(d);\n\t\tnodes[t].to.push_back(s);\n\t\tnodes[t].dist.push_back(d);\n\t}\n\tPrim prim(nodes);\n\tll sum = 0;\n\tLoop(i, n) sum += prim.nodes[i].d;\n\tint q; cin >> q;\n\tLoop(i, q) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tcout << sum - prim.max_path_between(s, t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, q;\nint d[5010];\n\nstruct edge{\n   int to, cost;\n//    edge(int to, int cost):to(to), cost(cost){}\n};\nvector<edge> G[5010]; \n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       rep(i, 0, n) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nvector<pair<int, P> > es; \n// vector<int> path;\nint pMAX[4010][4010];\nint cost[4010][4010];\n\nvoid dfs(int now, int pre, int MAX, int root){\n    // cout << \" \" << now << \" \" << pre << endl;\n    // path[now] = pre;\n    pMAX[root][now] = MAX;\n    // if(now == dest) return;\n    rep(i, 0, G[now].size()){\n        int next = G[now][i].to;\n        if(next == pre) continue;\n        // path[next] = now;       \n        dfs(next, now, max(MAX, cost[now][next]), root);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    rep(i, 0, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        // G[a].push_back(edge{b, c});\n        // G[b].push_back(edge{a, c});\n        es.push_back(pair<int, P>(c, P(a, b)));\n        cost[a][b] = c;\n        cost[b][a] = c;\n    }\n    sort(all(es));\n    UF uf(n);\n    int sum = 0, cnt = 0;\n    rep(i, 0, es.size()){\n        int from = es[i].second.first;\n        int to = es[i].second.second;\n        if(uf.same(from, to) == false){\n            uf.unite(from, to);\n            sum += es[i].first;\n            G[from]. push_back(edge{to, es[i].first});\n            G[to]. push_back(edge{from, es[i].first});\n        }\n    }\n    // cout << sum << endl;\n    rep(i, 0, n){\n        // path.clear(); path.resize(n, -1);\n        dfs(i, -1, 0, i);\n    }\n    cin >> q;\n    rep(i, 0, q){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        // path.clear(); path.resize(n, -1);\n        // dfs(s, -1, t);\n        cout << sum - pMAX[s][t] << endl;\n        // int MAX = 0;\n        // int now = t;\n        // while(now != s){\n        //     int next = path[now];\n        //     chmax(MAX, cost[now][next]);\n        //     now = next;\n        // }\n        // cout << sum - MAX << endl;\n        // rep(j, 0, path.size()){\n        //     cout << path[j] << \" \";\n        // }\n        // cout << endl;\n        // dijkstra(s);\n        // cout << d[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, m, a, b, c);\n\tstd::vector<std::vector<PAIR>> g(n);\n\tstd::vector<PAIR> edge(m);\n\tREP(i, m) {\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].emplace_back(b[i], c[i]);\n\t\tg[b[i]].emplace_back(a[i], c[i]);\n\t\tedge[i] = PAIR(c[i], i);\n\t}\n\tstd::sort(ALL(edge));\n\n\t// 最小全域木\n\tstd::vector<std::vector<PAIR>> G(n); // (to, cost)\n\tUnionFind uf(n);\n\tint sum = 0;\n\tfor (auto& p : edge) {\n\t\tauto ei = p.second;\n\t\tint A = a[ei], B = b[ei], C = c[ei];\n\t\tif (uf.same(A, B)) continue;\n\t\tuf.unite(A, B);\n\t\tG[A].emplace_back(B, C);\n\t\tG[B].emplace_back(A, C);\n\t\tsum += C;\n\t}\n\n\tstd::vector<std::vector<int>> ma(n, std::vector<int>(n, 0));\n\t// O(N^2)で任意2頂点間のパスのコストの最大値を求めておく\n\tint root = 0;\n\tstd::function<void(int,int)> dfs = [&](int v, int par) {\n\t\tfor (auto& e : G[v]) if (e.first != par) {\n\t\t\tCHMAX(ma[root][e.first], ma[root][v]);\n\t\t\tCHMAX(ma[root][e.first], e.second);\n\t\t\tdfs(e.first, v);\n\t\t}\n\t};\n\tfor (; root < n; ++root) dfs(root, -1);\n\n\t// クエリ\n\tVAR(int, Q);\n\tREP(_, Q) {\n\t\tVAR(int, s, t);\n\t\t--s; --t;\n\t\tOUT(sum - ma[s][t])BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include <cassert>\n#include <functional>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(...) ;\n#else\n#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n\nvoid _tostr_rec(ostringstream &oss) {\n  oss << \"\\b\\b \\b\";\n}\n\ntemplate<typename Head, typename... Tail>\nvoid _tostr_rec(ostringstream &oss, Head &&head, Tail &&... tail) {\n  oss << head << \", \";\n  _tostr_rec(oss, forward<Tail>(tail)...);\n}\n\ntemplate<typename... T>\nstring _tostr(T &&... args) {\n  ostringstream oss;\n  int size = sizeof...(args);\n  if (size > 1) oss << \"{\";\n  _tostr_rec(oss, forward<T>(args)...);\n  if (size > 1) oss << \"}\";\n  return oss.str();\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 400010\n\n/* UnionFind */\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int s): data(s, -1) {}\n\n  int root(int x) {\n    if (data[x] < 0) return x;\n    return data[x] = root(data[x]);\n  }\n\n  bool set(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n\n  bool check(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nvector<pair<int, int>> G[SIZE];\nint depth[SIZE], parent[20][SIZE];\nint dp[20][SIZE];\n\nvoid dfs(int now, int back = -1, int d = 0, int c = 0) {\n  depth[now] = d;\n  parent[0][now] = back;\n  dp[0][now] = c;\n\n  for (auto e : G[now]) {\n    int to = e.first;\n    int c = e.second;\n    if (back == to) continue;\n    dfs(to, now, d + 1, c);\n  }\n}\n\nint main() {\n  int N, M, Q, a[SIZE], b[SIZE], c[SIZE];\n  ll ans = 0;\n  pair<int, int> es[SIZE];\n\n  scanf(\"%d%d\", &N, &M);\n\n  UnionFind uf(N);\n\n  for (int i = 0; i < M; i++) {\n    scanf(\"%d%d%d\", a + i, b + i, c + i);\n    a[i]--;\n    b[i]--;\n    es[i] = {c[i], i};\n  }\n\n  sort(es, es + M);\n\n  for (int i = 0; i < M; i++) {\n    int idx = es[i].second;\n\n    if (uf.set(a[idx], b[idx])) {\n      G[a[idx]].push_back({b[idx], c[idx]});\n      G[b[idx]].push_back({a[idx], c[idx]});\n      ans += c[idx];\n    }\n  }\n\n  dfs(0);\n\n  for (int i = 0; i < 15; i++) {\n    for (int j = 0; j < N; j++) {\n      if (parent[i][j] != -1) {\n        parent[i + 1][j] = parent[i][parent[i][j]];\n        dp[i + 1][j] = max(dp[i][j], dp[i][parent[i][j]]);\n      } else {\n        parent[i + 1][j] = -1;\n        dp[i + 1][j] = 0;\n      }\n    }\n  }\n\n  scanf(\"%d\", &Q);\n\n  for (int i = 0; i < Q; i++) {\n    int S, T;\n    scanf(\"%d%d\", &S, &T);\n    S--;\n    T--;\n\n    if (depth[S] > depth[T]) swap(S, T);\n\n    int maxC = 0;\n\n    for (int i = 15; i >= 0; i--) {\n      if (depth[S] + (1 << i) > depth[T]) continue;\n\n      maxC = max(maxC, dp[i][T]);\n      T = parent[i][T];\n    }\n\n    assert(depth[S] == depth[T]);\n\n    for (int i = 15; i >= 0; i--) {\n      if (parent[i][S] != parent[i][T]) {\n        maxC = max({maxC, dp[i][S], dp[i][T]});\n        S = parent[i][S];\n        T = parent[i][T];\n      }\n    }\n\n    if (S != T) {\n      assert(parent[0][S] == parent[0][T]);\n      maxC = max({maxC, dp[0][S], dp[0][T]});\n    }\n\n    debug(maxC);\n    printf(\"%lld\\n\", ans - maxC);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tUnionFindTree uf(N);\n\tvector<int> a(M), b(M);\n\tvector<ll> c(M);\n\tvector<pair<ll, int>> ord(M);\n\tfor(int i = 0; i < M; ++i){\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\ta[i]--, b[i]--;\n\t\tord[i] = { c[i],i };\n\t}\n\tsort(ALL(ord));\n \n\tTree<treeOperator<ll>> tree(N);\n\tll sum = 0;\n\tfor (int i = 0; i < M; ++i){\n\t\tint j = ord[i].second;\n\t\tif (uf.same(a[j], b[j])) {\n\t\t\ta[j] = b[j] = -1;\n\t\t}\n\t\telse {\n\t\t\tuf.unite(a[j], b[j]);\n\t\t\tsum += c[j];\n\t\t\ttree.makeEdge(a[j], b[j], c[j]);\n\t\t\ttree.makeEdge(b[j], a[j], c[j]);\n\t\t}\n\t}\n\ttree.makeDepth(0);\n\tvector<vector<int>> edge(N, vector<int>(20,0));\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (a[i] == -1 || b[i] == -1) continue;\n\t\tif (tree.depth[a[i]] < tree.depth[b[i]]) swap(a[i], b[i]);\n\t\tedge[a[i]][0] = c[i];\n\t}\n \n\ttree.makeParent();\n\ttree.makeAncestor();\n\tfor (int bit = 1; bit < 20; ++bit) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tedge[i][bit] = max(edge[tree.ancestor[i][bit - 1].first][bit - 1], edge[i][bit - 1]);\n\t\t}\n\t}\n\tint Q; cin >> Q;\n\tvector<ll> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tans[i] = sum - tree.lca(s, t).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nclass UF {\nprivate:\n  vector<int> data; // parent or size\n  vector<int> next;\n  vector<int> last;\n  void init(int n) {\n    data.assign(n, -1);\n    next.assign(n, -1);\n    last.resize(n);\n    for (int i = 0; i < n; ++i) {\n      last[i] = i;\n    }\n  }\n\npublic:\n  UF() {}\n  UF(int n) {\n    init(n);\n  }\n  int root(int x) {\n    if (data[x] < 0) return x;\n    return data[x] = root(data[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (data[x] > data[y]) swap(x, y); // data[x] and data[y] are negative.\n    data[x] += data[y];\n    data[y] = x;\n    next[last[x]] = y;\n    last[x] = last[y];\n    return true;\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int get_next(int x) {\n    return next[x];\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m)\n  vvi edge(m, vi(3));\n  rep (i, m) {\n    scanf(\"%d%d%d\", &edge[i][1], &edge[i][2], &edge[i][0]);\n    edge[i][1] -= 1; edge[i][2] -= 1;\n  }\n  sort(all(edge));\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  cost += edge[0][0];\n  uf.unite(edge[0][1], edge[0][2]);\n  maxcost[edge[0][1]][edge[0][2]] = maxcost[edge[0][2]][edge[0][1]] = edge[0][0];\n  FOR (i, 1, m) {\n    int x = edge[i][1];\n    int y = edge[i][2];\n    if (!(uf.same(x, y))) {\n      cost += edge[i][0];\n      for (int j = uf.root(x); j != -1; j = uf.get_next(j)) {\n        for (int k = uf.root(y); k != -1; k = uf.get_next(k)) {\n          maxcost[j][k] = maxcost[k][j] = edge[i][0];\n        }\n      }\n      uf.unite(x, y);\n    }\n  }\n \n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;ll cost; };\n//最大全域木にしたい場合は<を>にする\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge es[400000];\nint V, E;\nstruct edge2 { int to; ll cost; };\nvector<edge2> G[4000];\nll kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V);\n\tll res = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t\tG[e.u].push_back({ e.v,e.cost });\n\t\t\tG[e.v].push_back({ e.u,e.cost });\n\t\t}\n\t}\n\treturn res;\n}\nll d[4000][4000];\nint main() {\n\tcin >> V >> E;\n\trep(i, E) {\n\t\tint a, b; ll c; cin >> a >> b >> c; a--; b--;\n\t\tes[i] = { a,b,c };\n\t}\n\tll sum = kruskal();\n\trep(i, V) {\n\t\tint used[4000] = {}; used[i] = 1;\n\t\td[i][i] = 0;\n\t\tqueue<int> q; q.push(i);\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\tint len = G[x].size();\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[x][j].to;\n\t\t\t\tif (used[v])continue;\n\t\t\t\tused[v] = true; q.push(v);\n\t\t\t\td[i][v] = max(d[i][x], G[x][j].cost);\n\t\t\t}\n\t\t}\n\t}\n\tint q; cin >> q;\n\trep(i, q) {\n\t\tint s, t; cin >> s >> t; s--; t--;\n\t\tcout << sum - d[s][t] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    cin >> a[i],b[i],c[i];\n    a[i]--; b[i]--;\n\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<int>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  vector<vector<int>> p(n, vector<int>(14, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(14, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<14; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u,v;\n    u--; v--;\n\n    long long sub = 0;\n\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<14; k++){\n      if( (depth[v] - depth[u]) >> k & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=13; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n\n    println( mst_cost - sub );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\n\nstruct uni {\n  vector<int> p;\n  uni(int n) :\n      p(n, -1) {}\n  int root(int a) {\n    return p[a] < 0 ? a : (p[a] = root(p[a]));\n  }\n  bool find(int a, int b) {\n    return root(a) == root(b);\n  }\n  bool merge(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return false;\n    p[a] = b;\n    return true;\n  }\n};\n\nstruct edge {\n  int f, t, c;\n  edge() {}\n  edge(int f, int t, int c) :\n      f(f), t(t), c(c) {}\n  bool operator<(const edge& e) const {\n    return c < e.c;\n  }\n};\n\nedge e[444444];\nvector<edge> g[4444];\nint res[4444][4444];\n\nint solve(int f, int t, int p) {\n  for (int i = 0; i < int(g[f].size()); i++) {\n    if (g[f][i].t == p) continue;\n    if (g[f][i].t == t) {\n      return g[f][i].c;\n    } else {\n      int r = solve(g[f][i].t, t, f);\n      if (r > 0) {\n        return max(g[f][i].c, r);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  uni u(n);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &e[i].f, &e[i].t, &e[i].c);\n    --e[i].f;\n    --e[i].t;\n  }\n  sort(e, e+m);\n  long long c = 0;\n  for (int i = 0; i < m; i++) {\n    if (u.merge(e[i].f, e[i].t)) {\n      c += e[i].c;\n      g[e[i].f].push_back(edge(e[i].f, e[i].t, e[i].c));\n      g[e[i].t].push_back(edge(e[i].t, e[i].f, e[i].c));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n; j++) {\n      res[i][j] = res[j][i] = solve(i, j, -1);\n    }\n  }\n  int q; scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int s, t; scanf(\"%d%d\", &s, &t); --s; --t;\n    printf(\"%lld\\n\", c-res[s][t]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\nclass UF {\nprivate:\n  vector<int> data; // parent or size\n  vector<int> next;\n  vector<int> last;\n  void init(int n) {\n    data.assign(n, -1);\n    next.assign(n, -1);\n    last.resize(n);\n    for (int i = 0; i < n; ++i) {\n      last[i] = i;\n    }\n  }\n\npublic:\n  UF() {}\n  UF(int n) {\n    init(n);\n  }\n  int root(int x) {\n    if (data[x] < 0) return x;\n    return data[x] = root(data[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return false;\n    if (data[x] > data[y]) swap(x, y); // data[x] and data[y] are negative.\n    data[x] += data[y];\n    data[y] = x;\n    next[last[x]] = y;\n    last[x] = last[y];\n    return true;\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int get_next(int x) {\n    return next[x];\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  vvi edge(m, vi(3));\n  rep (i, m) {\n    scanf(\"%d%d%d\", &edge[i][1], &edge[i][2], &edge[i][0]);\n    edge[i][1] -= 1; edge[i][2] -= 1;\n  }\n  sort(all(edge));\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  cost += edge[0][0];\n  uf.unite(edge[0][1], edge[0][2]);\n  maxcost[edge[0][1]][edge[0][2]] = maxcost[edge[0][2]][edge[0][1]] = edge[0][0];\n  FOR (i, 1, m) {\n    int x = edge[i][1];\n    int y = edge[i][2];\n    if (!(uf.same(x, y))) {\n      cost += edge[i][0];\n      for (int j = uf.root(x); j != -1; j = uf.get_next(j)) {\n        for (int k = uf.root(y); k != -1; k = uf.get_next(k)) {\n          maxcost[j][k] = maxcost[k][j] = edge[i][0];\n        }\n      }\n      uf.unite(x, y);\n    }\n  }\n \n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF      1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nstruct UF{\n\tint par[4000];\n\tint rank[4000];\n\tint si[4000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\nint n, m, k;\nbool saw[4000];\nll sum = 0;\nvector<PP> e;\nvector<P> ee[4000];\nll par[30][4000];\nll cnt[30][4000];\nll dep[4000];\n\nll lca(int s, int t){\n    ll ret = 0;\n    if(dep[s] > dep[t]){\n        ll dif = dep[s]-dep[t];\n        for(int i = 0;;i++){\n            if(dif == 0) break;\n            if(dif&1){\n                ret = max(ret,cnt[i][s]);\n                s = par[i][s];\n            }\n            dif /= 2;\n        }\n    }\n    if(dep[s] < dep[t]){\n        ll dif = dep[t]-dep[s];\n        for(int i = 0;;i++){\n            if(dif==0)break;\n            if(dif&1){\n                ret = max(ret,cnt[i][t]);\n                t = par[i][t];\n            }\n            dif /= 2;\n        }\n    }\n    //cout << s << \" \" << t<< \" \" << ret << endl;\n    if(s == t){\n        return ret;\n    }\n    for(int i = 29; i >= 0; i--){\n        if(par[i][s] == par[i][t]) continue;\n        ret = max(ret,cnt[i][t]);\n        ret = max(ret,cnt[i][s]);\n        s = par[i][s];\n        t = par[i][t];\n    }\n    ret = max(ret,cnt[0][t]);\n    ret = max(ret,cnt[0][s]);\n    return ret;\n}\n\nvoid dfs(int v){\n    saw[v] = true;\n    rep(i,ee[v].size()){\n        if(saw[ee[v][i].first]) continue;\n        dep[ee[v][i].first] = dep[v]+1;\n        dfs(ee[v][i].first);\n        par[0][ee[v][i].first] = v;\n        cnt[0][ee[v][i].first] = ee[v][i].second;\n    }\n}\n\nint main(){\n    cin >> n >> m;\n    uf.init(n);\n    rep(i,m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        e.push_back(PP(c,P(a,b)));\n    }\n    sort(e.begin(),e.end());\n    rep(i,e.size()){\n        if(!uf.same(e[i].second.first,e[i].second.second)){\n            uf.unite(e[i].second.first,e[i].second.second);\n            ee[e[i].second.first].push_back(P(e[i].second.second,e[i].first));\n            ee[e[i].second.second].push_back(P(e[i].second.first,e[i].first));\n            //cout << e[i].second.second << \" \" << e[i].second.first << endl;\n            sum += e[i].first;\n        }\n    }\n    //cout << sum << endl;\n    dfs(0);\n    //rep(i,n) cout << dep[i] << \" \";\n    //cout << endl;\n    for(int j = 1; j < 30; j++){\n        rep(i,n){\n            par[j][i] = par[j-1][par[j-1][i]];\n            cnt[j][i] = max(cnt[j-1][i],cnt[j-1][par[j-1][i]]);\n        }\n    }\n    cin >> k;\n    rep(i,k){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        cout << sum - lca(s,t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nstruct LowestCommonAncestor{\n    int N;\n    int ss;\n    vector<int> path, depth, in_order, out_order;\n    std::vector<pair<int,int>> dat;\n    const pair<int,int> INF = make_pair(1000000000, 1000000000);\n\n    LowestCommonAncestor(const vector<vector<int>> G,int root)\n        : N(G.size()),\n          path(N * 2 - 1),\n          depth(N * 2 - 1),\n          in_order(N),\n          out_order(N) {\n        int k = 0;\n        dfs(G, root, -1, 0, k);\n        for (ss = 1; ss < N * 2 - 1; ss <<= 1);\n        dat.assign(ss * 2, INF);\n        for (int i = 0; i < (int)depth.size(); ++i)\n            dat[ss + i] = make_pair(depth[i], i);\n        for (int i = ss - 1; i >= 1; --i)\n            dat[i] = min(dat[i * 2], dat[i * 2 + 1]);\n    }\n\n    int Querry(int u,int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = range_min(1, ss, l, r);\n        return path[res.second];\n    }\n\n    void dfs(const vector<vector<int>> G,int v,int f,int d,int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : G[v]){\n            if (e != f) {\n                dfs(G,e,v,d+1,k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k-1;\n    }\n    pair<int,int> range_min(int v,int w,int l,int r){\n        if (r <= l || w == 0) return INF;\n        if (r-l == w) return dat[v];\n        int m = w/2;\n        return min(range_min(v*2,m,l,std::min(r,m)),\n                   range_min(v*2+1,m,std::max(0,l-m),r-m));\n    }\n};\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\npair<long,pair<int,int>> Edge[400000];\nlong cost[3999];\nint leader[4000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tfor(int i=0;i<M;i++){\n\t\tint f = rei()-1;\n\t\tint t = rei()-1;\n\t\tEdge[i] = {rel(),{f,t}};\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tleader[i] = i+N-1;\n\t}\n\tsort(Edge,Edge+M);\n\tvector<vector<int>> G(2*N-1);\n\tUnionFind U(N);\n\tint c = N-2;\n\tlong ans = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint f = Edge[i].second.first;\n\t\tint t = Edge[i].second.second;\n\t\tif(!U.Same(f,t)){\n\t\t\tcost[c] = Edge[i].first;\n\t\t\tans += Edge[i].first;\n\t\t\tG[c].push_back(leader[U.Get(f)]);\n\t\t\tG[c].push_back(leader[U.Get(t)]);\n\t\t\tU.Union(f,t);\n\t\t\tleader[U.Get(f)] = c--;\n\t\t}\n\t}\n\tLowestCommonAncestor LCA(G,0);\n\tint Q = rei();\n\tfor(int i=0;i<Q;i++){\n\t\tint s = rei()-1;\n\t\tint t = rei()-1;\n\t\tcout << ans - cost[LCA.Querry(s+N-1,t+N-1)] << endl;;\n\t}\n\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\nclass partially_persistent_union_find {\npublic:\n  using value_type = T;\n\nprivate:\n  int size;\n  value_type last_query;\n  const value_type inf;\n  std::vector<int> parent;\n  std::vector<value_type> updated;\n  std::vector<std::pair<value_type, int>> component;\n  std::vector<std::vector<std::pair<value_type, int>>> history;\n\npublic:\n  partially_persistent_union_find(): inf(std::numeric_limits<value_type>::max()) { }\n  partially_persistent_union_find(int size_): \n    inf(std::numeric_limits<value_type>::max())\n  { init(size_);}\n\n  void init(int size_) {\n    size = size_;\n    last_query = std::numeric_limits<value_type>::min();\n    parent.assign(size_, 1);\n    updated.assign(size_, inf);\n    component.assign(1, { last_query, size_ });\n    history.assign(size_, { { last_query, 1 } });\n  }\n\n  int find_parent(int i, const value_type &t) const {\n    if (updated[i] > t) {\n      return i;\n    }\n    else {\n      return find_parent(parent[i], t);\n    }\n  }\n\n  int count_components(const value_type &t) const {\n    return (--std::upper_bound(component.begin(), component.end(), std::make_pair(t, size))) -> second;\n  }\n  int component_size(int i, const value_type &t) const {\n    i = find_parent(i, t);\n    return (--std::upper_bound(history[i].begin(), history[i].end(), std::make_pair(t, size))) -> second;\n  }\n  bool same_component(int i, int j, const value_type &t) const {\n    return find_parent(i, t) == find_parent(j, t);\n  }\n\n  value_type united(int i, int j) const {\n    if (!same_component(i, j, last_query)) {\n      return inf;\n    }\n    int ok = last_query, ng = -1;\n    while (ok - ng > 1) {\n      int md = (ok + ng) / 2;\n      (same_component(i, j, md) ? ok : ng) = md;\n    }\n    return ok;\n  }\n\n  bool unite(int i, int j, const value_type &t) {\n    i = find_parent(i, last_query);\n    j = find_parent(j, last_query);\n    last_query = t;\n    if (i == j) {\n      return false;\n    }\n    if (parent[i] < parent[j]) {\n      std::swap(i, j);\n    }\n    parent[i] += parent[j];\n    parent[j] = i;\n    updated[j] = last_query;\n    int tmp = component.back().second;\n    component.emplace_back(last_query, tmp - 1);\n    history[i].emplace_back(last_query, parent[i]);\n    return true;\n  }\n\n};\n\nint main() {\n  int N, M, Q, a, b, c;\n  scanf(\"%d %d\", &N, &M);\n  std::vector<std::tuple<int, int, int>> edges;\n  while (M--) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    edges.emplace_back(c, a - 1, b - 1);\n  }\n  std::sort(edges.begin(), edges.end());\n  partially_persistent_union_find<int> dsu(N);\n  long long sum = 0;\n  for (auto e: edges) {\n    std::tie(c, a, b) = e;\n    if (dsu.unite(a, b, c)) {\n      sum += c;\n    }\n  }\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%lld\\n\", sum - dsu.united(a - 1, b - 1));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[125252];             // グラフ\nint depth[125252];        // 根付き木の深さ\nint anc[125252][20];      // anc[i][k] := iの2^k個上の祖先\nint query[125252][20];\n \nint data[125252];\nint init(){\n  REP(i,125252)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n        // DEBUG(a);\n        // DEBUG(b);\n      }\n    }\n  }\n \n  queue<int> Q;\n \n  // 根付き木にする\n  // そしてダブリングの準備\n  REP(i,n) depth[i]=INF;\n  REP(i,n)REP(k,20) anc[i][k]=query[i][k]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      Q.push(to);\n      // ダブリング準備\n      anc[to][0] = pos;\n      query[to][0] = c;\n      int id = 1;\n      int cur = pos;\n      while(anc[cur][id-1]!=INF){\n        int next = anc[cur][id-1];\n        anc[to][id] = next;\n        query[to][id] = min(query[to][id-1], query[cur][id-1]);\n        cur = next;\n        ++id;\n      }\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n    // LCAを取る\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    // 同じ高さにズラす\n    int diff = depth[b]-depth[a];\n    int k = 0;\n    while(diff){\n      CHMIN(x,(ll)query[b][0]);\n      b = anc[b][0];\n      --diff;\n      // if(diff&1){\n      //   CHMIN(x,(ll)query[b][k]);\n      //   b = anc[b][k];\n      // }\n      // diff>>=1;\n      // ++k;\n    }\n    k = 19;\n    while(anc[a][0]!=INF && anc[a][0]!=anc[b][0]){\n      CHMIN(x,(ll)query[a][0]);\n      CHMIN(x,(ll)query[b][0]);\n      a = anc[a][0];\n      b = anc[b][0];\n    }\n    // while(k>=0){\n    //   if(anc[a][k]!=INF && anc[a][k]!=anc[b][k]){\n    //     CHMIN(x,(ll)query[a][k]);\n    //     CHMIN(x,(ll)query[b][k]);\n    //     a = anc[a][k];\n    //     b = anc[b][k];\n    //   }\n    //   --k;\n    // }\n    int lca = a;\n    if(a!=b){\n      CHMIN(x,(ll)query[a][0]);\n      lca = anc[a][0];\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n//OK\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\nreturn;\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long from; long long to; long long cost; \n\tbool operator<(const edge& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\npriority_queue<edge> pq;\n\nll const MAX = 4006;\nll dep[MAX];\nll parent_uf[MAX];\nll rk[MAX];\n\nvoid init(ll n) {\n\tfor (ll i = 1; i <= n; i++) {\n\t\tparent_uf[i] = i;\n\t\trk[i] = 1;\n\t}\n}\n\nll find(ll x) {\n\tif (parent_uf[x] == x) {\n\t\treturn x;\n\t}\n\tparent_uf[x] = find(parent_uf[x]);\n\treturn parent_uf[x];\n}\n\nbool same(ll x, ll y) {\n\treturn find(x) == find(y);\n}\n\nvoid unite(ll x, ll y) {\n\tif (!same(x, y)) {\n\t\tx = parent_uf[x];\n\t\ty = parent_uf[y];\n\t\tif (rk[x] < rk[y]) {\n\t\t\tparent_uf[x] = y;\n\t\t}\n\t\telse {\n\t\t\tparent_uf[y] = x;\n\t\t\tif (rk[x] == rk[y]) {\n\t\t\t\trk[x]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll n, m, q;\nvector<edge> G[MAX];\n\nll make_tree() {\n\tll cnt = n - 1;\t\n\tll ttl = 0;\n\n\twhile (cnt > 0) {\n\t\tedge cur = pq.top();\n\t\tpq.pop();\n\t\tll cf = cur.from; ll ct = cur.to; ll cc = cur.cost;\n\t\tif (!same(cf, ct)) {\n\t\t\tunite(cf, ct);\n\t\t\tttl += cur.cost;\n\t\t\tG[cf].push_back({ cf,ct,cc });\n\t\t\tG[ct].push_back({ ct,cf,cc });\n\t\t\tcnt--;\n\t\t}\n\t}\n\treturn ttl;\n}\n\nll parent[MAX];\nll costing[MAX];\n\nvoid dfs() {\n\tparent[1] = 1;\n\tstack<ll> st;\n\tst.push(1);\n\tdep[1] = 0;\n\twhile (!st.empty()) {\n\t\tll cur = st.top();\n\t\tst.pop();\n\t\tfor (ll i = 0; i < SIZE(G[cur]); i++) {\n\t\t\t\n\t\t\tll next = G[cur][i].to;\n\t\t\tif (next == parent[cur]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout << cur << \" \" << next << endl;\n\t\t\tparent[next] = cur;\n\t\t\tdep[next] = dep[cur] + 1;\n\t\t\tcosting[next] = G[cur][i].cost;\n\t\t\t//cout << costing[next] << endl;\n\t\t\tst.push(next);\n\t\t}\n\t}\n}\n\nll dp[MAX][MAX] = {};\n\nll query(ll s, ll t) {\n\tif (s == t) {\n\t\treturn 0;\n\t}\t\n\tif (dep[s] < dep[t]) {\n\t\tswap(s, t);\n\t}\n\n\tif (dp[s][t] != 0) {\n\t\treturn dp[s][t];\n\t}\n\t//cout << v << \" ?\" << endl;\n\tdp[s][t] = max(costing[s],query(parent[s], t));\n\treturn dp[s][t];\n}\n\nint main() {\n\tcin >> n >> m;\n\tinit(n);\n\tREP(i, 1, m) {\n\t\tll a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tpq.push({ a,b,c });\n\t}\n\tll ttl = make_tree();\n\tdfs();\n\tcin >> q;\n\tREP(i, 1, q) {\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tcout << ttl - query(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 2e9;\nconst ld EPS = 1e-8;\n\ntypedef ll Weight;\ntypedef int Flow;\n\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nbool comp(const Edge &e1, const Edge &e2){\n  return e1.cost < e2.cost;\n}\n\npair<Weight, Edges> kruskal(Edges &es, int v){\n  sort(ALL(es), comp);\n  UnionFind uni(v);\n  Edges mst;\n  Weight res = 0;\n  for(Edge e: es){\n    if(!uni.findSet(e.src, e.dest)){\n      uni.unionSet(e.src, e.dest);\n      mst.push_back(e);\n      res += e.cost;\n    }\n  }\n  return make_pair(res, mst);\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  Edges es;\n  REP(i,M) {\n    int a, b, c;\n    cin >> a >> b >> c; --a; --b;\n    es.push_back(Edge(a, b, c));\n    es.push_back(Edge(b, a, c));\n  }\n\n  pair<Weight, Edges> mst = kruskal(es, N);\n  Graph g(N);\n  for(Edge e: mst.second) {\n    g[e.src].push_back(e);\n    g[e.dest].push_back(Edge(e.dest, e.src, e.cost));\n  }\n  /*\n  REP(i,N) {\n    for(Edge e: g[i]) {\n      cout << e.dest << \" \";\n    }\n    cout << endl;\n  }\n  */\n\n  vector<vector<int>> d(N, vector<int> (N, 0));\n  REP(i,N) {\n    queue<tuple<int,int,ll>> que;\n    que.push(make_tuple(i, -1, 0));\n    while(!que.empty()) {\n      int curr, prev, cst;\n      tie(curr, prev, cst) = que.front(); que.pop();\n      d[i][curr] = max(d[i][curr], cst);\n      for(Edge e: g[curr]) {\n        if(e.dest == prev) continue;\n        que.push(make_tuple(e.dest, curr, max((ll)cst, e.cost)));\n      }\n    }\n  }\n  /*\n  REP(i,N){\n    REP(j,N) cout << \" \" << d[i][j];\n    cout << endl;\n  }\n  */\n\n  int Q;\n  cin >> Q;\n  REP(q, Q) {\n    int S, T;\n    cin >> S >> T; --S; --T;\n    ll res = mst.first - d[S][T];\n    cout << res << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint dist[4000][4000];\nvector<vector<pair<int, int>>> G;\n\nvoid dfs(int curr, int par, int start, int max) {\n  dist[curr][start] = max;\n  for(auto const& e: G[curr]) {\n    if(e.first != par) dfs(e.first, curr, start, std::max(max, e.second));\n  }\n};\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<tuple<int, int, int>> es;\n  G.resize(N);\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es.emplace_back(c, a, b);\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es.begin(), es.end());\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  rep(i, N) {\n    dfs(i, -1, i, 0);\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; scanf(\"%d%d\", &s, &t); s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM+1];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      es[i] = edge{a, b, c};\n    }\n    ll Q;\n    cin >> Q;\n    if(Q > 3000) return 0;\n    ll index = M;\n    rep(q, Q){\n      ll s, t;\n      cin >> s >> t;\n      s--; t--;\n      es[index] = edge{s, t, 0};\n      ll ans = 0;\n      if(q == 0) sort(es, es+M+1, comp);\n      UnionFind uf(N);\n      uf.initialize();\n      rep(i, M+1){\n        edge& e = es[i];\n        if(e.cost == 0) index = i;\n        if(!uf.isSame(e.u, e.v)){\n          uf.merge(e.u, e.v);\n          ans += e.cost;\n        }\n      }\n      cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\ntemplate <class T>\nclass segtree\n{\npublic:\n    lli n;\n    vector<T> dat;\n    function<T(T, T)> func;\n    T dummy;\n    segtree<T>(lli _n, function<T(T, T)> f, T dummy) : func(f), dummy(dummy)\n    {\n        n = 1;\n        while (n < _n) {\n            n = n * 2;\n        }\n        dat.assign(2 * n - 1, dummy);\n    }\n    void update(lli k, T a)\n    {\n        k += n - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b)\n    {\n        return query(a, b, 0, 0, n);\n    }\n    // [a,b)の何かを求める.\n    T query(int a, int b, int k, int l, int r)\n    {\n        //交差しないときはダミー\n        if (r <= a || b <= l)\n            return dummy;\n        if (a <= l && r <= b)\n            return dat[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return func(vl, vr);\n        }\n    }\n    T get(int a)\n    {\n        return query(a, a + 1, 0, 0, n);\n    }\n};\n\ntemplate <class T>\nstruct hldec {\n    int n;\n    int col = 0;\n    vector<vector<int>> e;\n    vector<vector<int>> heavy;\n    vector<vector<int>> light;\n    vector<vector<T>> cls;\n    vector<T> vers;\n    vector<pair<int, int>> pos;\n    vector<pair<int, int>> par;\n    map<pair<int, int>, int> dict;\n    function<T(T, T)> f;\n    T unit;\n    vector<segtree<T>> vec_seg;\n    int root = 0;\n    vector<int> size;\n    hldec(int n, vector<T> vers, function<T(T, T)> f, T unit, int root = 0) : n(n), root(root), vers(vers), unit(unit), f(f)\n    {\n        e.assign(n, {});\n        par.assign(n, make_pair(-1, -1));\n        heavy.assign(n, {});\n        light.assign(n, {});\n        size.assign(n, 0);\n        pos.assign(n, make_pair(-1, -1));\n        cls.assign(n, {});\n    }\n    void add(int u, int v)\n    {\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    int sub_tree_size(int cur, int par)\n    {\n        int tmp = 1;\n        for (auto s : e[cur]) {\n            if (par != s) {\n                tmp += sub_tree_size(s, cur);\n            }\n        }\n        size[cur] = tmp;\n        return tmp;\n    }\n    void dfs_label(int cur, int par)\n    {\n        lli idx = -1;\n        lli mem = 0;\n        rep(i, e[cur].size())\n        {\n            auto s = e[cur][i];\n            if (s != par) {\n                if (size[s] > mem) {\n                    mem = size[s];\n                    idx = i;\n                }\n            }\n        }\n        if (idx == -1)\n            return;\n        rep(i, e[cur].size())\n        {\n            auto s = e[cur][i];\n            if (s != par) {\n                if (idx == i) {\n                    heavy[cur].push_back(s);\n                } else {\n                    light[cur].push_back(s);\n                }\n                dfs_label(s, cur);\n            }\n        }\n    }\n    void edge_labeling()\n    {\n        sub_tree_size(root, -1);\n        dfs_label(root, -1);\n    }\n    void dfs_arrays(int cur, int c)\n    {\n        cls[c].push_back(vers[cur]);\n        int idx = cls[c].size() - 1;\n        pos[cur] = make_pair(c, cls[c].size() - 1);\n        dict[pos[cur]] = cur;\n\n        for (auto s : heavy[cur]) {\n            dfs_arrays(s, c);\n        }\n        for (auto s : light[cur]) {\n            col++;\n            par[col] = make_pair(c, idx);\n            dfs_arrays(s, col);\n        }\n    }\n    void make_arrays()\n    {\n        dfs_arrays(root, 0);\n    }\n    void build_segtree()\n    {\n        rep(j, cls.size())\n        {\n            auto& s = cls[j];\n            int size = s.size();\n            segtree<T> seg(size, f, unit);\n            rep(i, size)\n            {\n                seg.update(i, s[i]);\n            }\n            vec_seg.push_back(seg);\n        }\n    }\n    void build(bool opt = false)\n    {\n        edge_labeling();\n        if (opt) {\n            e.clear();\n        }\n        cerr << \"labeled done\" << endl;\n        make_arrays();\n\n        cerr << \"arrays\" << endl;\n        if (opt) {\n            heavy.clear();\n            light.clear();\n        }\n\n        build_segtree();\n\n        cerr << \"seg_build\" << endl;\n    }\n    T query(int u, int v)\n    {\n        vector<pair<int, int>> hist_u;\n        vector<pair<int, int>> hist_v;\n        rep(j, 2)\n        {\n            int tmp = j == 1 ? u : v;\n            while (true) {\n                int cur_col = pos[tmp].first;\n                if (j)\n                    hist_u.push_back(pos[tmp]);\n                else\n                    hist_v.push_back(pos[tmp]);\n                tmp = dict[par[cur_col]];\n                if (cur_col == 0)\n                    break;\n            }\n        }\n        int cnt = 0;\n        T ans = unit;\n        while (true) {\n            int idx_u = hist_u.size() - cnt - 1;\n            int idx_v = hist_v.size() - cnt - 1;\n            if (hist_u[idx_u].first == hist_v[idx_v].first) {\n                int r = max(hist_u[idx_u].second, hist_v[idx_v].second) + 1;\n                int l = min(hist_u[idx_u].second, hist_v[idx_v].second);\n                ans = f(vec_seg[hist_u[idx_u].first].query(l, r), ans);\n                break;\n            }\n            cnt++;\n        }\n        rep(i, hist_u.size() - cnt - 1)\n        {\n            ans = f(vec_seg[hist_u[i].first].query(0, hist_u[i].second + 1), ans);\n        }\n        rep(i, hist_v.size() - cnt - 1)\n        {\n            ans = f(vec_seg[hist_v[i].first].query(0, hist_v[i].second + 1), ans);\n        }\n        return ans;\n    }\n};\nvector<pair<lli, lli>> e[4005];\nvector<pair<lli, lli>> ne[4005];\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int a, b;\n    lli c;\n    rep(i, m)\n    {\n        cin >> a >> b >> c;\n        a--, b--;\n        e[a].push_back(make_pair(b, c));\n        e[b].push_back(make_pair(a, c));\n    }\n    using p = pair<lli, pair<lli, lli>>;\n    priority_queue<p, vector<p>, greater<p>> que;\n    bool used[4005] = {};\n    que.push(make_pair(0, make_pair(0, -1)));\n    lli ans = 0;\n    int hoge = n;\n    vector<pair<lli, lli>> edge;\n    vector<lli> v(2 * n, 0);\n    while (!que.empty()) {\n        auto cur = que.top().second;\n        auto cost = que.top().first;\n        que.pop();\n        if (used[cur.first])\n            continue;\n        used[cur.first] = true;\n        ans += cost;\n        if (cur.second != -1) {\n            edge.push_back(make_pair(cur.first, hoge));\n            edge.push_back(make_pair(cur.second, hoge));\n            v[hoge] = cost;\n            hoge++;\n        }\n        for (auto s : e[cur.first]) {\n            que.push(make_pair(s.second, make_pair(s.first, cur.first)));\n        }\n    }\n\n    auto f = [](lli u, lli v) -> lli { return max(u, v); };\n    hldec<lli> tr(hoge, v, f, 0);\n    for (auto s : edge) {\n        tr.add(s.first, s.second);\n    }\n    // tr.add(0, 1);\n    // tr.add(0, 2);\n    // tr.add(1, 3);\n    // tr.add(1, 4);\n    tr.build(true);\n    int s, t, q;\n    cin >> q;\n    rep(i, q)\n    {\n        cin >> s >> t;\n        cout << ans - tr.query(s - 1, t - 1) << endl;\n    }\n    // //cout << tr.query(0,1)<<endl;\n    // cout << tr.query(3, 4) << endl;\n};\n;\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\ntypedef std::pair<ll, int> PLI;\n\n/**\n * Lowest Common Ancestor. Call lca(x, y) to get the lca of them.\n * Header Requirement: vector, cassert\n * Verified by: AtCoder ABC014-D (http://abc014.contest.atcoder.jp/submissions/759125)\n */\nclass LowestCommonAncestor {\nprivate:\n  int n, bn;\n  std::vector<PLI> parent; // 0 is root, parent[0] = 0\n  std::vector<int> dep;\n  \n  // Lowest Common Ancestor\n  \n  std::vector<std::vector<PLI> > lca_tbl;\n  \n  void dfs(const std::vector<std::vector<PLI> > &edges, int v, int par, int d, ll x) {\n    parent[v].second = par;\n    parent[v].first = x;\n    dep[v] = d;\n    \n    for (int i = 0; i < edges[v].size(); ++i) {\n      int u = edges[v][i].second;\n      if (u != par) {\n\tdfs(edges, u, v, d + 1, edges[v][i].first);\n      }\n    }\n  }\n  \n  void lca_init(void) {\n    for (int v = 0; v < n; ++v) {\n      lca_tbl[v] = std::vector<PLI>(bn + 1, PLI(0, 0));\n      lca_tbl[v][0] = parent[v];\n    }\n    for (int i = 1; i <= bn; ++i) {\n      for (int v = 0; v < n; ++v) {\n\tPLI tmp = lca_tbl[v][i - 1];\n        PLI tmp2 = lca_tbl[tmp.second][i - 1];\n\tlca_tbl[v][i] = PLI(max(tmp.first, tmp2.first), tmp2.second);\n      }\n    }\n  }\npublic:\n  ll lca(int x, int y) const {\n    int dx = dep[x];\n    int dy = dep[y];\n    ll res = 0;\n    if (dx > dy) {\n      return lca(y, x);\n    }\n    // Go up from y to the depth of x\n    for (int l = bn; l >= 0; --l) {\n      if (dy - dx >= 1 << l) {\n        PLI ny = lca_tbl[y][l];\n\tres = max(res, ny.first);\n\ty = ny.second;\n\tdy -= 1 << l;\n      }\n    }\n\n    assert (dx == dy);\n\n    if (x == y) {\n      return res;\n    }\n  \n    for (int l = bn; l >= 0; --l) {\n      if (lca_tbl[x][l].second != lca_tbl[y][l].second) {\n\tPLI nx = lca_tbl[x][l];\n\tPLI ny = lca_tbl[y][l];\n\tres = max(res, max(nx.first, ny.first));\n\tx = nx.second;\n\ty = ny.second;\n      }\n    }\n    return max(res, max(lca_tbl[x][0].first, lca_tbl[y][0].first));\n  }\n  int depth(int a) const {\n    return dep[a];\n  }\n  LowestCommonAncestor(int n, const std::vector<std::vector<PLI> > &edges)\n    : n(n), parent(n), dep(n), lca_tbl(n) {\n    bn = 0;\n    while (n > 1 << bn) {\n      bn++;\n    }\n    dfs(edges, 0, 0, 0, 0);\n    lca_init();\n  }\n};\n\n\n\nconst int M = 400010;\nint n, m;\nint a[M], b[M];\nll c[M];\n\nconst int N = 4010;\nvector<PLI> edges[N];\n\nll dfs(int v, int p, int t) {\n  if (v == t) {\n    return 0;\n  }\n  REP(i, 0, edges[v].size()) {\n    PLI e = edges[v][i];\n    int w = e.second;\n    if (p == w) continue;\n    ll res = dfs(w, v, t);\n    if (res == -1) continue;\n    return max(res, e.first);\n  }\n  return -1;\n}\n\nll solve(int s, int t) {\n  return dfs(s, -1, t);\n  \n}\n\nint main(void){\n  cin >> n >> m;\n  REP(i, 0, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n  }\n  int q;\n  cin >> q;\n  vector<PLI> pool;\n  ll tot = 0;\n  REP(i, 0, m) {\n    pool.push_back(PLI(c[i], i));\n  }\n  sort(pool.begin(), pool.end());\n  UnionFind uf(n);\n  vector<vector<PLI> > edges_i(n);\n  REP(i, 0, pool.size()) {\n    int idx = pool[i].second;\n    int u = a[idx];\n    int v = b[idx];\n    if (not uf.is_same_set(u, v)) {\n      uf.unite(u, v);\n      tot += pool[i].first;\n      edges[u].push_back(PLI(pool[i].first, v));\n      edges[v].push_back(PLI(pool[i].first, u));\n      edges_i[u].push_back(PLI(pool[i].first, v));\n      edges_i[v].push_back(PLI(pool[i].first, u));\n    }\n  }\n  LowestCommonAncestor lca(n, edges_i);\n  REP(i, 0, q) {\n    int s,t;\n    cin >> s >> t;\n    s--, t--;\n    // max edge in s-t path\n    ll tk = lca.lca(s, t);\n    cout << tot - tk << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,30){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,q){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tif(r[i]-l[i]>1){\n\t\t\tif(l[i]==0)abort();\n\t\t}\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> Pll;\ntypedef pair<int, ll> Pl;\n\nint par[4002];\nint rk[4002];\n \nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i;\n\t}\n}\n \nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n \nvoid unite(int x, int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rk[x]==rk[y]) rk[x]++;\n\t}\n}\n \nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\n\nvector<Pl> g[4000];\nll mx[4000][4000];\nbool used[4000];\n\nvoid dfs(int s, int x){\n\tused[x]=1;\n\tfor(int i=0; i<g[x].size(); i++){\n\t\tint y=g[x][i].first;\n\t\tif(used[y]) continue;\n\t\tmx[s][y]=max(mx[s][x], g[x][i].second);\n\t\tdfs(s, y);\n\t}\n}\n\nint main()\n{\n\tint n, m;\n\tcin>>n>>m;\n\tvector<Pll> eg;\n\tfor(int i=0; i<m; i++){\n\t\tint a, b; ll c;\n\t\tcin>>a>>b>>c;\n\t\ta--; b--;\n\t\teg.push_back(Pll(c, P(a, b)));\n\t}\n\tsort(eg.begin(), eg.end());\n\tinit(n);\n\tll sum=0;\n\tint ct=0;\n\tfor(int i=0; i<m; i++){\n\t\tint a=eg[i].second.first, b=eg[i].second.second;\n\t\tif(same(a, b)) continue;\n\t\tunite(a, b);\n\t\tct++;\n\t\tll c=eg[i].first;\n\t\tsum+=c;\n\t\tg[a].push_back(Pl(b, c));\n\t\tg[b].push_back(Pl(a, c));\n\t\tif(ct==n-1) break;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfill(used, used+n, 0);\n\t\tdfs(i, i);\n\t}\n\tint q;\n\tcin>>q;\n\tfor(int i=0; i<q; i++){\n\t\tint s, t;\n\t\tcin>>s>>t;\n\t\ts--; t--;\n\t\tcout<<sum-mx[s][t]<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint root[4001];\n\nint find(int x){\n\tif(x != root[x]){\n\t\troot[x]=find(root[x]);\n\t}\n\treturn root[x];\n}\n\nvoid union_set(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\troot[x]=y;\n\t}\n\treturn;\n}\n\n\nint main(){\n\tfor(int i=0;i<4001;i++){\n\t\troot[i] = i;\n\t}\n\tint n,m,q,a,b,s,t,c;\n\tlong long ans=0;\n\tvector<pair<long long,pair<int,int> > > node,node2;\n\tcin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tpair<long long,pair<int,int> > tmp;\n\t\tcin >> a >> b >> c;\n\t\ttmp = make_pair(c,make_pair(a,b));\n\t\tnode.push_back(tmp);\n\t}\n\tsort(node.begin(),node.end());\n\tfor(int i=0;i<node.size();i++){\n\t\tif(find(node[i].second.first)!=find(node[i].second.second)){\n\t\t\tunion_set(node[i].second.first,node[i].second.second);\n\t\t\tnode2.push_back(node[i]);\n\t\t}\n\t}\n\tcin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tcin >> s >> t;\n\t\tvector<pair<long long,pair<int,int> > > node3;\n\t\tnode3 = node2;\n\t\tnode3.insert(node3.begin(),make_pair(0,make_pair(s,t)));\n\t\tfor(int i=0;i<4001;i++){\n\t\t\troot[i] = i;\n\t\t}\n\t\tans =0;\n\t\tfor(int i=0;i<node3.size();i++){\n\t\t\tif(find(node3[i].second.first)!=find(node3[i].second.second)){\n\t\t\t\tans += node3[i].first;\n\t\t\t\tunion_set(node3[i].second.first,node3[i].second.second);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n    Edge(int f, int t, int c) : from(f), to(t), cost(c) {}\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nconst int MAXN = 4010;\nstruct UnionFind {\n    int node[MAXN];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        node[x] += node[y];\n        node[y] = x;\n        return true;\n    }\n};\n\nusing Graph = vector< vector<Edge> >;\nint max_edge[MAXN][MAXN];\n\nvoid dfs(Graph &G, int cur, int par, int orig) {\n    int prev_max = max_edge[orig][cur];\n    for(auto e : G[cur]) {\n        if(e.to == par) continue;\n        chmax(max_edge[orig][e.to], max(prev_max, e.cost));\n        dfs(G, e.to, cur, orig);\n    }\n}\n \nUnionFind uf;\nsigned main() {\n    int N, M; cin >> N >> M;\n    \n    vector<Edge> edges;\n    for(int i=0; i<M; i++) {\n        int u, v, cost; cin >> u >> v >> cost;\n        u--; v--;\n        edges.emplace_back(u, v, cost);\n    }\n    sort(edges.begin(), edges.end());\n\n    int sum = 0;\n    Graph MST(N);\n    for(int i=0; i<M; i++) {\n        Edge e = edges[i];\n        if(uf.unite(e.from, e.to)) {\n            MST[e.from].emplace_back(e.from, e.to  , e.cost);\n            MST[e.to  ].emplace_back(e.to,   e.from, e.cost);\n            sum += e.cost;\n        }\n    }\n\n    for(int i=0; i<N; i++) dfs(MST, i, -1, i);\n\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            printf(\"max_edge[%lld][%lld] = %lld\\n\", i+1, j+1, max_edge[i][j]);\n        }\n    }\n    */\n\n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        // printf(\"max_edge = %lld\\n\", max_edge[s][t]);\n        cout << sum - max(max_edge[s][t], max_edge[t][s]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nconst int UF_MAX = 1000000;\n\nclass UF{\n\tint x[UF_MAX];\n\t\npublic:\n\t\n\tUF(){\n\t\tfor(int i = 0 ; i < UF_MAX ; ++i) x[i] = -1;\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool find(int a , int b){\n\t\treturn boss(a) == boss(b);\n\t}\n\t\n\tint count(int a){\n\t\tint b = 0;\n\t\tfor(int i = 0 ; i < a ; ++i) if(x[i] < 0) ++b;\n\t\treturn b;\n\t}\n} uf;\n\nint N,M,Q;\nvector<P2> V[4004];\nvector<P3> E;\nint d[4004];\nint p[4004];\nint q[4004];\n\nvoid dfs(int a){\n\trepv(P2,it,V[a]){\n\t\tif(d[(*it).second] < 0){\n\t\t\td[(*it).second] = d[a] + 1;\n\t\t\tp[(*it).second] = a;\n\t\t\tq[(*it).second] = (*it).first;\n\t\t\tdfs((*it).second);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\" , &N , &M);\n\trepp(i,0,M){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\" , &a , &b , &c);\n\t\tE.PB(M3P(c,a,b));\n\t}\n\tsort(E.begin(),E.end());\n\tint w = 0;\n\trepp(i,0,M){\n\t\tint x = E[i].first.second;\n\t\tint y = E[i].second;\n\t\tif(!uf.find(x,y)){\n\t\t\tuf.uni(x,y);\n\t\t\tV[x].PB(MP(E[i].first.first,y));\n\t\t\tV[y].PB(MP(E[i].first.first,x));\n\t\t\tw += E[i].first.first;\n\t\t}\n\t}\n\tfill(d,d+N+1,-1);\n\tfill(p,p+N+1,-1);\n\tfill(q,q+N+1,0);\n\td[1] = 0;\n\tdfs(1);\n\tscanf(\"%d\" , &Q);\n\trepp(i,0,Q){\n\t\tint s,t;\n\t\tscanf(\"%d%d\" , &s , &t);\n\t\tint ans = 0;\n\t\twhile(s != t){\n\t\t\tif(d[s] > d[t]){\n\t\t\t\tans = max(ans , q[s]);\n\t\t\t\ts = p[s];\n\t\t\t} else {\n\t\t\t\tans = max(ans , q[t]);\n\t\t\t\tt = p[t];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\" , w - ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,30){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tif(r[i]-l[i]>1){\n\t\t\tif(l[i]==0)abort();\n\t\t}\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \ntemplate<class T>\nstruct SparseTable{\n\tvector<T> st[21];\n\tvoid Init(int N,vector<T> data){\n\t\tif(N<=0)\n\t\t\treturn;\n\t\tint h = 1;\n\t\twhile ((1 << h) < N) h++;\n\t\tfor(int i=0;i<N;i++) st[0].push_back(data[i]);\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tfor(int i=0;i<N-(1<<j)+1;i++){\n\t\t\t\tst[j].push_back(min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]));\n\t\t\t}\n\t\t}\n\t}\n\tinline int TopBit(int t){\n\t\treturn 31-__builtin_clz(t);\n\t}\n\tT GetMin(int b,int e){\n\t\tint diff = TopBit(e-b);\n\t\treturn min(st[diff][b], st[diff][e - (1 << diff)]);\n\t}\n};\nstruct LowestCommonAncestor{\n    int N;\n    vector<int> path, depth, in_order, out_order;\n    std::vector<pair<int,int>> dat;\n\tSparseTable<pair<int,int>> table;\n\n    LowestCommonAncestor(const vector<vector<int>> G,int root)\n        : N(G.size()),\n          path(N * 2 - 1),\n          depth(N * 2 - 1),\n          in_order(N),\n          out_order(N) {\n        int k = 0;\n        dfs(G, root, -1, 0, k);\n        for (int i = 0; i < (int)depth.size(); ++i){\n            dat.push_back(make_pair(depth[i],i));\n\t\t}\n\t\ttable.Init(dat.size(),dat);\n    }\n\n    int Querry(int u,int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = table.GetMin(l,r);\n        return path[res.second];\n    }\n\n    void dfs(const vector<vector<int>> G,int v,int f,int d,int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : G[v]){\n            if (e != f) {\n                dfs(G,e,v,d+1,k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k-1;\n    }\n};\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\npair<long,pair<int,int>> Edge[400000];\nlong cost[3999];\nint leader[4000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tfor(int i=0;i<M;i++){\n\t\tint f = rei()-1;\n\t\tint t = rei()-1;\n\t\tEdge[i] = {rel(),{f,t}};\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tleader[i] = i+N-1;\n\t}\n\tsort(Edge,Edge+M);\n\tvector<vector<int>> G(2*N-1);\n\tUnionFind U(N);\n\tint c = N-2;\n\tlong ans = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint f = Edge[i].second.first;\n\t\tint t = Edge[i].second.second;\n\t\tif(!U.Same(f,t)){\n\t\t\tcost[c] = Edge[i].first;\n\t\t\tans += Edge[i].first;\n\t\t\tG[c].push_back(leader[U.Get(f)]);\n\t\t\tG[c].push_back(leader[U.Get(t)]);\n\t\t\tU.Union(f,t);\n\t\t\tleader[U.Get(f)] = c--;\n\t\t}\n\t}\n\tLowestCommonAncestor LCA(G,0);\n\tint Q = rei();\n\tfor(int i=0;i<Q;i++){\n\t\tint s = rei()-1;\n\t\tint t = rei()-1;\n\t\tcout << ans - cost[LCA.Querry(s+N-1,t+N-1)] << endl;;\n\t}\n\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM];\nll mx[MAXN][MAXN];\nbool visited[MAXN];\nvector<P> G[MAXN];\n\nvoid dfs(ll v, ll p, ll m = -1)\n{\n  if(visited[v]) return;\n  mx[p][v] = m;\n  visited[v] = true;\n  for(auto a : G[v]){\n    dfs(a.first, p, max(m, a.second));\n  }\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N >> M;\n  rep(i, M){\n    ll a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    es[i] = edge{a, b, c};\n  }\n  ll sum = 0;\n  {\n    sort(es, es+M, comp);\n    UnionFind uf(N);\n    uf.initialize();\n    ll cnt = 0;\n    rep(i, M){\n      edge& e = es[i];\n      if(!uf.isSame(e.u, e.v)){\n        uf.merge(e.u, e.v);\n        es[cnt] = edge{e.u, e.v, e.cost};\n        cnt++;\n        sum += e.cost;\n        G[e.u].push_back(make_pair(e.v, e.cost));\n        G[e.v].push_back(make_pair(e.u, e.cost));\n      }\n    }\n  }\n  for(int i=0; i<N; i++){\n    memset(visited, false, sizeof(visited));\n    dfs(i, i);\n  }\n\n  ll Q;\n  cin >> Q;\n  rep(q, Q){\n    ll s, t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum-mx[s][t] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to,cost;\n    edge(){}\n    edge(Int from,Int to,Int cost):from(from),to(to),cost(cost){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  void add_edge(Int u,Int v,Int c){\n    edges.push_back(edge(u,v,c));\n  }\n\n  void input(Int m,Int offset=0){\n    Int a,b,c;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      add_edge(a+offset,b+offset,c);\n    }\n  }\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n      }\n    }\n    return res;\n  }\n};\n\n\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  Kruskal k(n);\n  k.input(m,-1);\n  auto es=k.edges;\n  Int q;\n  cin>>q;\n  for(Int i=0;i<q;i++){\n    Int s,t;\n    cin>>s>>t;\n    s--;t--;\n    Kruskal p(n);\n    p.edges=es;\n    p.add_edge(s,t,0);\n    cout<<p.build()<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r1, int r2) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r1, 0) );\n  Q.push( Edge(-1, r2, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\tGraph g(N);\n\tfor(;M--;){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\tg[b-1].emplace_back(b-1,a-1,c);\n\t}\n\tscanf(\"%d\",&Q);\n\tif(Q>3000)return 1;\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tprintf(\"%lld\\n\",minimumSpanningTree(g,a-1,b-1).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//ifstream fi(\"ELECTRIC.INP\");\n//ofstream fo(\"ELECTRIC.OUT\");\n\n#define N 4005\n\nstruct edge\n{\n    int s,t;\n    long long w;\n};\n\nint n,m,cha[N],q,aa,bb;\nlong long res,ans;\nvector <edge> v;\nvector < pair <int,long long> > tree[N];\nbool dd[N],check;\n\nbool cmp(const edge &a,const edge &b)\n{\n    return a.w<b.w;\n}\n\nlong long tim(long long u)\n{\n    if (cha[u]==u) return u;\n    return cha[u]=tim(cha[u]);\n}\n\nbool join(long long u,long long v)\n{\n    u=tim(u);\n    v=tim(v);\n    if (u==v) return false;\n    cha[u]=v;\n    return true;\n}\n\nvoid dfs(int u,int p,long long val)\n{\n    dd[u]=1;\n    ans=max(ans,val);\n    if (u==p)\n    {\n        check=1;\n        return;\n    }\n    for (int i=0;i<tree[u].size();i++)\n        if (!dd[tree[u][i].first] && !check) dfs(tree[u][i].first,p,tree[u][i].second);\n    return;\n}\n\nint main()\n{\n    cin>>n>>m;\n    int k1,k2;\n    long long k3;\n    for (int i=1;i<=m;i++)\n    {\n        cin>>k1>>k2>>k3;\n        v.push_back({k1,k2,k3});\n    }\n    sort(v.begin(),v.end(),cmp);\n    for (int i=1;i<=n;i++)\n        cha[i]=i;\n    for (int i=0;i<v.size();i++)\n    {\n        if (join(v[i].s,v[i].t))\n        {\n            res+=v[i].w;\n            tree[v[i].s].push_back({v[i].t,v[i].w});\n            tree[v[i].t].push_back({v[i].s,v[i].w});\n        }\n    }\n    cin>>q;\n    for (int i=1;i<=q;i++)\n    {\n        memset(dd,0,sizeof(dd));\n        ans=0;\n        check=0;\n        cin>>aa>>bb;\n        dfs(aa,bb,-1e9);\n        cout<<res-ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, M, Q, S, T, a, b, c, uf[4000], r[4000], d[4000][2][15];\npriority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\nvector<pair<int, int>>v[4000];\nll e;\n\nint t(int x) {\n\tif (uf[x] < 0)return x;\n\treturn uf[x] = t(uf[x]);\n}\n\nbool u(int x, int y) {\n\tx = t(x);\n\ty = t(y);\n\tif (x == y)return false;\n\tif (uf[x] < uf[y]) {\n\t\tuf[x] += uf[y];\n\t\tuf[y] = x;\n\t}\n\telse {\n\t\tuf[y] += uf[x];\n\t\tuf[x] = y;\n\t}\n\treturn true;\n}\n\nvoid dfs(int x) {\n\tfor (auto p : v[x]) {\n\t\tif (!r[p.second]) {\n\t\t\tr[p.second] = r[x] + 1;\n\t\t\td[p.second][0][0] = p.first;\n\t\t\td[p.second][1][0] = x;\n\t\t\tdfs(p.second);\n\t\t}\n\t}\n}\n\nint calc(int x, int y) {\n\tint m = 0;\n\tif (r[x] < r[y]) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (r[x] + (1 << i) <= r[y]) {\n\t\t\t\tm = max(m, d[y][0][i]);\n\t\t\t\ty = d[y][1][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (r[x] > r[y]) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (r[y] + (1 << i) <= r[x]) {\n\t\t\t\tm = max(m, d[x][0][i]);\n\t\t\t\tx = d[x][1][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (x != y) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (d[x][1][i] != d[y][1][i]) {\n\t\t\t\tm = max(m, d[x][0][i]);\n\t\t\t\tm = max(m, d[y][0][i]);\n\t\t\t\tx = d[x][1][i];\n\t\t\t\ty = d[y][1][i];\n\t\t\t}\n\t\t}\n\t\tm = max(m, d[x][0][0]);\n\t\tm = max(m, d[y][0][0]);\n\t}\n\treturn m;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> a >> b >> c;\n\t\tq.push(mkp(c, mkp(a - 1, b - 1)));\n\t}\n\tmemset(uf, -1, sizeof uf);\n\twhile (!q.empty()) {\n\t\tif (u(q.top().second.first, q.top().second.second)) {\n\t\t\tv[q.top().second.first].push_back(mkp(q.top().first, q.top().second.second));\n\t\t\tv[q.top().second.second].push_back(mkp(q.top().first, q.top().second.first));\n\t\t\te += q.top().first;\n\t\t}\n\t\tq.pop();\n\t}\n\tr[0] = 1;\n\tdfs(0);\n\tfor (int i = 0; i < 14; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\td[j][0][i + 1] = max(d[j][0][i], d[d[j][1][i]][0][i]);\n\t\t\td[j][1][i + 1] = d[d[j][1][i]][1][i];\n\t\t}\n\t}\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> S >> T;\n\t\tcout << e - calc(S - 1, T - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4040;\nint uf[maxn];\nint find(int x){\n\tif(x == uf[x]) return x;\n\treturn uf[x] = find(uf[x]);\n}\nvector<pair<int,int> > e[maxn];\nint dep[maxn], par[maxn], cost[maxn];\nvoid dfs(int u){\n\tfor(auto to : e[u]){\n\t\tif(to.first == par[u]) continue;\n\t\tdep[to.first] = dep[u] + 1;\n\t\tcost[to.first] = to.second;\n\t\tpar[to.first] = u;\n\t\tdfs(to.first);\n\t}\n}\nint main(){\n\tiota(uf, uf + maxn, 0);\n\tint n, m; cin >> n >> m;\n\tvector<tuple<int,int,int> > eds;\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v, w; cin >> u >> v >> w;\n\t\teds.push_back(make_tuple(w, u, v));\n\t}\n\tsort(eds.begin(), eds.end());\n\tlong long mst = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v, w; tie(w, u, v) = eds[i];\n\t\tif(find(u) != find(v)){\n\t\t\te[u].push_back({v, w});\n\t\t\te[v].push_back({u, w});\n\t\t\tmst += w;\n\t\t\tuf[find(u)] = find(v);\n\t\t}\n\t}\n\tdfs(1);\n\tint q; scanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++){\n\t\tint s, t; cin >> s >> t;\n\t\tint big = 0;\n\t\twhile(s != t){\n\t\t\tif(dep[s] < dep[t]) swap(s, t);\n\t\t\tbig = max(big, cost[s]);\n\t\t\ts = par[s];\n\t\t}\n\t\tprintf(\"%lld\\n\", mst - big);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a}); // 0:cost, 1:opponent, 2:self\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n  assert(0);\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    cand.erase(begin(cand));\n    if (uf.same(edge[1], edge[2])) {\n      continue;\n    }\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (i, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[i] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nstruct UnionFind {\n\tvector<int> data;\n\tvoid init(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x != y) {\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\nvector<int> t_parent;\nvi t_ord;\n\ntemplate<typename T>\nvoid wtree_getorder(const vector<vector<pair<int, T> > > &gw, int root, vector<T> &t_weight) {\n\tint n = (int)gw.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\tt_weight.assign(n, T());\n\n\tvector<int> stk; stk.push_back(root);\n\twhile(!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor(int j = (int)gw[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = gw[i][j].first;\n\t\t\tif(t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tt_weight[c] = gw[i][j].second;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstruct Edge {\n\tint a, b, c;\n\tbool operator<(const Edge &that) const {\n\t\treturn c < that.c;\n\t}\n};\n\nstruct Sum {\n\tint maxC;\n\tSum() : maxC(-INF) {}\n\texplicit Sum(int x) : maxC(x) {}\n\tSum &operator+=(const Sum &that) {\n\t\tamax(maxC, that.maxC);\n\t\treturn *this;\n\t}\n};\nstruct PathCompressionTree {\nprivate:\n\tvector<int> parent;\n\tvector<Sum> val, sum;\npublic:\n\tvoid init(int n, const vector<Sum> &initval) {\n\t\tparent.assign(n, -1);\n\t\tval = initval;\n\t\tsum.assign(n, Sum());\n\t}\n\tvoid link(int c, int p) {\n\t\tassert(parent[c] == -1 && p != -1);\n\t\tparent[c] = p;\n\t\tsum[c] = val[c];\n\t}\n\tint find(int u) {\n\t\tint p = parent[u], g;\n\t\tif(p == -1) return u;\n\t\tg = parent[u] = find(p);\n\t\tsum[u] += sum[p];\n\t\treturn g;\n\t}\n\tSum get(int u) {\n\t\tfind(u);\n\t\treturn sum[u];\n\t}\n};\n\nstruct Query {\n\tint u, v;\n\tint i;\n};\n\nvector<vi> g;\nvector<bool> visited;\nPathCompressionTree pct;\nvector<vector<Query>> queries, lca;\nvector<Sum> vals, ans;\n\nvoid dfs(int i, int p) {\n\tfor(int j : g[i]) if(j != p)\n\t\tdfs(j, i);\n\tvisited[i] = true;\n\tfor(const Query &q : queries[i]) {\n\t\tif(visited[q.v])\n\t\t\tlca[pct.find(q.v)].push_back(q);\n\t}\n\tfor(const Query &q : lca[i]) {\n\t\tans[q.i] += pct.get(q.u);\n\t\tans[q.i] += pct.get(q.v);\n\t}\n\tif(p != -1)\n\t\tpct.link(i, p);\n}\n\nint main() {\n\tint N; int M;\n\twhile(~scanf(\"%d%d\", &N, &M)) {\n\t\tvector<Edge> edges(M);\n\t\trep(i, M) {\n\t\t\tint a; int b; int c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c), -- a, -- b;\n\t\t\tedges[i] = { a, b, c };\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tUnionFind uf; uf.init(N);\n\t\tg.assign(N, vi());\n\t\tvector<vector<pair<int, Sum>>> gw(N);\n\t\tll cost = 0;\n\t\tfor(auto &&e : edges) {\n\t\t\tif(uf.unionSet(e.a, e.b)) {\n\t\t\t\tg[e.a].push_back(e.b);\n\t\t\t\tg[e.b].push_back(e.a);\n\t\t\t\tgw[e.a].emplace_back(e.b, Sum(e.c));\n\t\t\t\tgw[e.b].emplace_back(e.a, Sum(e.c));\n\t\t\t\tcost += e.c;\n\t\t\t}\n\t\t}\n\t\twtree_getorder(gw, 0, vals);\n\t\tqueries.assign(N, vector<Query>());\n\t\tint Q;\n\t\tscanf(\"%d\", &Q);\n\t\trep(i, Q) {\n\t\t\tint u; int v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tqueries[u].push_back(Query{ u, v, i });\n\t\t\tqueries[v].push_back(Query{ v, u, i });\n\t\t}\n\t\tlca.assign(N, vector<Query>());\n\t\tans.assign(Q, Sum());\n\t\tvisited.assign(N, false);\n\t\tpct.init(N, vals);\n\t\tdfs(0, -1);\n\t\trep(i, Q) {\n\t\t\tll x = cost - max(0, ans[i].maxC);\n\t\t\tprintf(\"%lld\\n\", x);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    union_find uf(n);\n    vector<bool> use(m);\n    int64_t sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        use[i]=true;\n    }\n\n    vector<vector<pair<int,int>>> graph(n);\n    rep(i,0,m){\n        if(!use[i]) continue;\n        graph[edges[i].from].push_back(make_pair(edges[i].to,edges[i].cost));\n        graph[edges[i].to].push_back(make_pair(edges[i].from,edges[i].cost));\n    }\n\n    vector<vector<int>> max_cost(n,vector<int>(n));\n    vector<bool> done(n);\n    function<void(int,int,int)> dfs=[&](int s,int u,int ma){\n        done[u]=true;\n        max_cost[s][u]=ma;\n        for(auto &p:graph[u]){\n            if(done[p.first]) continue;\n            dfs(s,p.first,max(ma,p.second));\n        }\n        done[u]=false;\n    };\n    rep(i,0,n) dfs(i,i,0);\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-max_cost[s][t] << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n//OK\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\nreturn;\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\n//RE\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        union_find uf(n);\n        int sum=0;\n        for(edge &edge:edges){\n            int a=uf.find(edge.from),b=uf.find(edge.to);\n            s=uf.find(s);\n            t=uf.find(t);\n            if(uf.is_same_group(a,b) or (a==s and b==t) or (b==s and a==t)) continue;\n            uf.unite(a,b);\n            sum+=edge.cost;\n        }\n        cout << sum << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \ntemplate<class T>\nstruct SparseTable{\n\tvector<T> st[21];\n\tvoid Init(int N,vector<T> &data){\n\t\tif(N<=0)\n\t\t\treturn;\n\t\tint h = 1;\n\t\twhile ((1 << h) < N) h++;\n\t\tfor(int i=0;i<N;i++) st[0].push_back(data[i]);\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tfor(int i=0;i<N-(1<<j)+1;i++){\n\t\t\t\tst[j].push_back(min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]));\n\t\t\t}\n\t\t}\n\t}\n\tinline int TopBit(int t){\n\t\treturn 31-__builtin_clz(t);\n\t}\n\tT GetMin(int b,int e){\n\t\tint diff = TopBit(e-b);\n\t\treturn min(st[diff][b], st[diff][e - (1 << diff)]);\n\t}\n};\nstruct LowestCommonAncestor{\n    int N;\n    vector<int> path, depth, in_order, out_order;\n    std::vector<pair<int,int>> dat;\n\tSparseTable<pair<int,int>> table;\n\n    LowestCommonAncestor(const vector<vector<int>> &G,int root)\n        : N(G.size()),\n          path(N * 2 - 1),\n          depth(N * 2 - 1),\n          in_order(N),\n          out_order(N) {\n        int k = 0;\n        dfs(G, root, -1, 0, k);\n        for (int i = 0; i < (int)depth.size(); ++i){\n            dat.push_back(make_pair(depth[i],i));\n\t\t}\n\t\ttable.Init(dat.size(),dat);\n    }\n\n    int Querry(int u,int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = table.GetMin(l,r);\n        return path[res.second];\n    }\n\n    void dfs(const vector<vector<int>> &G,int v,int f,int d,int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : G[v]){\n            if (e != f) {\n                dfs(G,e,v,d+1,k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k-1;\n    }\n};\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\npair<long,pair<int,int>> Edge[400000];\nlong cost[3999];\nint leader[4000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tfor(int i=0;i<M;i++){\n\t\tint f = rei()-1;\n\t\tint t = rei()-1;\n\t\tEdge[i] = {rel(),{f,t}};\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tleader[i] = i+N-1;\n\t}\n\tsort(Edge,Edge+M);\n\tvector<vector<int>> G(2*N-1);\n\tUnionFind U(N);\n\tint c = N-2;\n\tlong ans = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint f = Edge[i].second.first;\n\t\tint t = Edge[i].second.second;\n\t\tif(!U.Same(f,t)){\n\t\t\tcost[c] = Edge[i].first;\n\t\t\tans += Edge[i].first;\n\t\t\tG[c].push_back(leader[U.Get(f)]);\n\t\t\tG[c].push_back(leader[U.Get(t)]);\n\t\t\tU.Union(f,t);\n\t\t\tleader[U.Get(f)] = c--;\n\t\t}\n\t}\n\tLowestCommonAncestor LCA(G,0);\n\tint Q = rei();\n\tfor(int i=0;i<Q;i++){\n\t\tint s = rei()-1;\n\t\tint t = rei()-1;\n\t\tcout << ans - cost[LCA.Querry(s+N-1,t+N-1)] << endl;;\n\t}\n\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 1010;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\ntuple<ll, int, int> edges[500000];\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = mt(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    vector<pair<int, int>> path[N];\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    // 0を親としたときの各ノードの深さ\n    int d[N];\n    fill(d, d + N, -1);\n    d[0] = 0;\n\n    // lca[x][v] = (vから2^xだけ遡った頂点,\n    //              そこに行くまでに辿った辺でのコストの最大値)\n    pair<int, ll> lca[15][N];\n    lca[0][0] = mp(0, 0);\n\n    // 幅優先探索でdとlca[0]を埋める\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto p : path[v]) {\n            int sv, cost;\n            tie(sv, cost) = p;\n            if (d[sv] >= 0) continue;\n\n            d[sv] = d[v] + 1;\n            lca[0][sv] = mp(v, cost);\n            que.push(sv);\n        }\n    }\n\n    // lcaを埋める\n    for (int x = 1; x < 15; ++x) {\n        for (int v = 0; v < N; ++v) {\n            int mid = lca[x - 1][v].first;\n            ll cost = max(lca[x - 1][v].second, lca[x - 1][mid].second);\n\n            lca[x][v] = mp(lca[x - 1][mid].first, cost);\n        }\n    }\n\n    // ようやくクエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        ll trim = 0;\n        if (d[s] > d[t]) swap(s, t);\n        // d[s] <= d[t]\n        // tの深さをsに合わせる\n\n        while (d[s] < d[t]) {\n            // sより浅くないtの祖先を漁る\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && d[s] > d[lca[x][t].first]) continue;\n                trim = max(trim, lca[x][t].second);\n                t = lca[x][t].first;\n            }\n        }\n\n        // LCAを探す\n        while (s != t) {\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && lca[x][s].first == lca[x][t].first) continue;\n                trim = max(trim, max(lca[x][s].second, lca[x][t].second));\n                s = lca[x][s].first;\n                t = lca[x][t].first;\n            }\n        }\n\n        cout << total - trim << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    int q;\n    cin >> q;\n    if(int64_t(m)*q>10000000) return;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        union_find uf(n);\n        uf.unite(s,t);\n        int sum=0;\n        for(edge &edge:edges){\n            int a=edge.from,b=edge.to;\n            int x=uf.find(s),y=uf.find(t);\n            if(uf.is_same_group(a,b)) continue;\n            uf.unite(a,b);\n            sum+=edge.cost;\n        }\n        cout << sum << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#ifndef ___Rank_Union_Find\n#define ___Rank_Union_Find\n\n#include <vector>\n\n// ------ Class ------ //\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\n\n#endif\n\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge { int a, b, cost; };\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint N, M, Q, s, t;\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tvector<edge> e(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d%d\", &e[i].a, &e[i].b, &e[i].cost);\n\t\te[i].a--; e[i].b--;\n\t}\n\tsort(e.begin(), e.end());\n\tscanf(\"%d\", &Q);\n\tif (Q > 3000) return 0;\n\twhile (Q--) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tUnionFind uf(N); uf.unite(s, t);\n\t\tlong long sum = 0;\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < M && cnt < N - 2; i++) {\n\t\t\tif (!uf.same(e[i].a, e[i].b)) {\n\t\t\t\tsum += e[i].cost;\n\t\t\t\tuf.unite(e[i].a, e[i].b);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n};\nint N,M,Q;\nvector<pair<int,pair<int,int> > >E;\nvector<pair<int,int> >G[4000];\nint T[4000][4000];\nvoid dfs(int u,int p,int now,int f)\n{\n\tT[f][u]=now;\n\tfor(pair<int,int>q:G[u])\n\t{\n\t\tif(q.first==p)continue;\n\t\tdfs(q.first,u,max(now,q.second),f);\n\t}\n}\nmain()\n{\n\tcin>>N>>M;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\ta--,b--;\n\t\tE.push_back(make_pair(c,make_pair(a,b)));\n\t}\n\tsort(E.begin(),E.end());\n\tUF uf(N);\n\tlong sum=0;\n\tfor(pair<int,pair<int,int> >p:E)\n\t{\n\t\tint u=p.second.first,v=p.second.second;\n\t\tif(uf.unite(u,v))\n\t\t{\n\t\t\tsum+=p.first;\n\t\t\tG[u].push_back(make_pair(v,p.first));\n\t\t\tG[v].push_back(make_pair(u,p.first));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tdfs(i,-1,0,i);\n\t}\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\ta--,b--;\n\t\tcout<<sum-T[a][b]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define nyan \"(=^・ω・^=)\"\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007;\nconst int mod998 = 998244353;\n\nint N, M, a, b, c, Q, s, t, uf[4000], d[4000][2][15], Rank[4000];\nll res;\nvector<pair<int, int>>v[4000];\npriority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\n\nint Top(int x) {\n\tif (uf[x] < 0)return x;\n\telse return uf[x] = Top(uf[x]);\n}\n\nbool Uni(int x, int y) {\n\tx = Top(x);\n\ty = Top(y);\n\tif (x == y)return false;\n\tif (uf[x] < uf[y]) {\n\t\tuf[x] += uf[y];\n\t\tuf[y] = x;\n\t}\n\telse {\n\t\tuf[y] += uf[x];\n\t\tuf[x] = y;\n\t}\n\treturn true;\n}\n\nvoid dfs(int x) {\n\tfor (auto i : v[x]) {\n\t\tif (!Rank[i.second]) {\n\t\t\tRank[i.second] = Rank[x] + 1;\n\t\t\td[i.second][0][0] = i.first;\n\t\t\td[i.second][1][0] = x;\n\t\t\tdfs(i.second);\n\t\t}\n\t}\n}\n\nint calc(int x, int y) {\n\tint MAX = -1;\n\tif (Rank[x] < Rank[y]) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (Rank[y] - (1 << i) >= Rank[x]) {\n\t\t\t\tMAX = max(MAX, d[y][0][i]);\n\t\t\t\ty = d[y][1][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (Rank[x] > Rank[y]) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (Rank[x] - (1 << i) >= Rank[y]) {\n\t\t\t\tMAX = max(MAX, d[x][0][i]);\n\t\t\t\tx = d[x][1][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (x == y)return MAX;\n\tfor (int i = 14; i >= 0; --i) {\n\t\tif (d[x][1][i] != d[y][1][i]) {\n\t\t\tMAX = max({ MAX,d[x][0][i],d[y][0][i] });\n\t\t\tx = d[x][1][i];\n\t\t\ty = d[y][1][i];\n\t\t}\n\t}\n\tMAX = max({ MAX,d[x][0][0],d[y][0][0] });\n\treturn MAX;\n}\n\nint main() {\n\tcin >> N >> M;\n\twhile (M--) {\n\t\tcin >> a >> b >> c;\n\t\tq.push(mkp(c, mkp(a - 1, b - 1)));\n\t}\n\tmemset(uf, -1, sizeof uf);\n\twhile (!q.empty()) {\n\t\ta = q.top().second.first;\n\t\tb = q.top().second.second;\n\t\tc = q.top().first;\n\t\tq.pop();\n\t\tif (Uni(a, b)) {\n\t\t\tv[a].push_back(mkp(c, b));\n\t\t\tv[b].push_back(mkp(c, a));\n\t\t\tres += c;\n\t\t}\n\t}\n\tRank[0] = 1;\n\tdfs(0);\n\tfor (int i = 1; i < 15; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\td[j][0][i] = max(d[j][0][i - 1], d[d[j][1][i - 1]][0][i]);\n\t\t\td[j][1][i] = d[d[j][1][i - 1]][1][i];\n\t\t}\n\t}\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> s >> t;\n\t\tcout << res - calc(s - 1, t - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "            #include <bits/stdc++.h>\n            #include<iostream>\n            #include<cstdio>\n            #include<vector>\n            #include<queue>\n            #include<map>\n            #include<cstring>\n            #include<string>\n            #include <math.h>\n            #include<algorithm>\n        //    #include <boost/multiprecision/cpp_int.hpp>\n            #include<functional>\n          #define int long long\n            #define inf  1000000007\n            #define pa pair<int,int>\n    #define ll long long\n            #define pal pair<ll,ll>\n            #define ppa pair<int,pa>\n            #define  mp make_pair\n            #define  pb push_back\n            #define EPS (1e-10)\n            #define equals(a,b) (fabs((a)-(b))<EPS)\n     \n            using namespace std;\n     \n            class Point{\n            \tpublic:\n            \tdouble x,y;\n            \tPoint(double x=0,double y=0):x(x),y(y) {}\n            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n            \tPoint operator * (double a) {return Point(x*a,y*a);}\n            \tPoint operator / (double a) {return Point(x/a,y/a);}\n            \tdouble absv() {return sqrt(norm());}\n            \tdouble norm() {return x*x+y*y;}\n            \tbool operator < (const Point &p) const{\n            \t\treturn x != p.x ? x<p.x: y<p.y;\n            \t}\n            \tbool operator == (const Point &p) const{\n            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n            \t}\n            };\n            typedef Point Vector;\n     \n            struct Segment{\n            Point p1,p2;\n            };\n     \n        double hen(Vector a){\n        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n        else if(a.y>0) return acos(a.x/a.absv());\n        else return 2*acos(0)+acos(-a.x/a.absv());\n     \n        }\n     \nint gcd(int v,int b){\n\tif(v>b) return gcd(b,v);\n\tif(v==b) return b;\n\tif(b%v==0) return v;\n\treturn gcd(v,b%v);\n}\n            double dot(Vector a,Vector b){\n            \treturn a.x*b.x+a.y*b.y;\n            }\n            double cross(Vector a,Vector b){\n            \treturn a.x*b.y-a.y*b.x;\n            }\n        \n            //----------------kokomade tenpure------------\n\nint par[100100],ranks[100100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n if(x==y) return;\n if(ranks[x]<ranks[y]) par[x]=y;\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n }\n}\nint shiten;\n\nvector<ppa> ve;\nvector<pa> G[5000];\nint omoi[4010][4010];\n\n\n\tvoid dfs(int ima,int mae,int omosa){\n\t\tomoi[shiten][ima]=omosa;\n\t\tfor(int i=0;i<G[ima].size();i++){\n\t\t\tif(G[ima][i].first==mae) continue;\n\t\t\tdfs(G[ima][i].first,ima,max(omosa,G[ima][i].second));\n\t\t}\n\t\treturn;\n\t} \n\n    signed  main(){\n    \tshoki(100000);\n    \tint n,m;\n    \tcin>>n>>m;\n    \tfor(int i=0;i<m;i++){\n    \t\tint a,b,c;\n    \t\tcin>>a>>b>>c;\n    \t\tve.pb(mp(c,mp(a,b)));\n    \t\t\n    \t}\n    \tint cnt=0;\n    \tint cost=0;\n    \tsort(ve.begin(),ve.end());\n    \tfor(int i=0;i<m;i++){\n    \t\tpa zzz=ve[i].second;\n    \t\t\n    \t\tif(same(zzz.first,zzz.second)) continue;\n    \t    unite(zzz.first,zzz.second);\n    \t\tG[zzz.first].pb(mp(zzz.second,ve[i].first));\n    \t\tG[zzz.second].pb(mp(zzz.first,ve[i].first));\n    \t\tcost += ve[i].first;\n    \t\tcnt++;\n    \t\tif(cnt>=n-1) break;\n    \t}\n    \t\n    \t\n    \tfor( shiten=1;shiten<=n;shiten++){\n    \t\tdfs(shiten,-1,0);\n    \t}\t\n    \t\n    \t\n    \tint q;\n    \tcin>>q;\n    \tfor(int i=0;i<q;i++){\n    \t\tint s,t;\n    \t\tcin>>s>>t;\n    \t\tcout<<cost-omoi[s][t]<<endl;\n    \t}\n\n    //\tprintf(\"%.10f\\n\",ans);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> par;\n    vector<int> dep;\n    \n    UnionFind(int siz){\n        par.assign(siz,0);\n        dep.assign(siz,0);\n        for(int i=0;i<siz;i++){\n            par[i]=i;\n        }\n    };\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y){\n            return;\n        }\n        if(dep[x]<dep[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(dep[x]==dep[y]){\n                dep[x]++;\n            }\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\nstruct edge{int from,to;ll cost;};\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost<e2.cost;\n}\nstruct edge2{int to;ll cost;};\nvector<edge2> G[100010];\nedge es[100010];\nll s[4010][4010];\nvoid dfs(int now,int p,int st,ll ma){\n\tfor(auto e:G[now]){\n\t\tif(e.to==p)continue;\n\t\ts[st][e.to]=max(ma,e.cost);\n\t\tdfs(e.to,now,st,max(ma,e.cost));\n\t}\n}\n\t\nint main(){\n\tint n,m,q;cin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;a--;b--;\n\t\tes[i]={a,b,c};\n\t}\n\tsort(es,es+m,comp);\n\tUnionFind uf(n);\n\tll ans=0;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=es[i];\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tG[e.from].push_back({e.to,e.cost});\n\t\t\tG[e.to].push_back({e.from,e.cost});\n\t\t\tans+=e.cost;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs(i,-1,i,0);\n\t}\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tcout<<ans-s[a][b]<<endl;\n\t}\n\t\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    vector<int> use;\n    int64_t sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        use.push_back(i);\n        sum_cost+=e.cost;\n    }\n\n    vector<vector<int>> children(n);\n    vector<int> parent(n,-1);\n    rep(i,0,n-1){\n        edge &e=edges[use[i]];\n        int a=e.from,b=e.to;\n        if(parent[a]==-1){\n            children[b].push_back(a);\n            parent[a]=b;\n        }else{\n            children[a].push_back(b);\n            parent[b]=a;\n        }\n    }\n    int root;\n    rep(i,0,n){\n        if(parent[i]==-1){\n            root=i;\n            break;\n        }\n    }\n\n    lca_solver ls(children,root);\n    vector<vector<int>> max_cost(20,vector<int>(n));\n    rep(i,0,n){\n        if(i==root) continue;\n        int j=ls.parent_pow2[0][i];\n        max_cost[0][i]=cost[i][j];\n    }\n    rep(i,1,20){\n        rep(j,0,n){\n            if(ls.depth[j]-(1<<i)<0) continue;\n            max_cost[i][j]=max(max_cost[i-1][j],max_cost[i-1][ls.parent_pow2[i-1][j]]);\n        }\n    }\n\n    auto f=[&](int u,int v){\n        int res=0;\n        //rep(i,0,20){\n        for(int i=19; i>=0; --i){\n            if(ls.depth[u]-ls.depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls.parent_pow2[i][u];\n            }\n        }\n        return res;\n    };\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        int u=ls.lca(s,t);\n        cout << sum_cost-max(f(s,u),f(t,u)) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n;\nint m;\nstruct edge { int from, to, cost; };\nstruct edge2 { LL to, cost; };\ntypedef pair<int, int> PP;\n\nvector<edge> e;\nvector<edge2> G[4040];\n\nint Par[100000];\nint Rank[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\n// ソート時に比較するための関数 \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal() {\n\tinit(n);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tG[e[i].from].emplace_back(edge2{ e[i].to,e[i].cost });\n\t\t\tG[e[i].to].emplace_back(edge2{ e[i].from,e[i].cost });\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\n\nLL ans[4040][4040];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\te.emplace_back(edge{ a,b,c });\n\t}\n\tLL num = kruskal();\n\tREP(i, n) {\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(i, -1));\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> cur = q.front();\n\t\t\tq.pop();\n\t\t\tREP(j, G[cur.first].size()) {\n\t\t\t\tif (G[cur.first][j].to != cur.second) {\n\t\t\t\t\tans[i][G[cur.first][j].to] = max(ans[i][cur.first], G[cur.first][j].cost);\n\t\t\t\t\tq.push(make_pair(G[cur.first][j].to, cur.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\tREP(qqq, q) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--, t--;\n\t\tcout << num - ans[s][t] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<long long> par;\n    vector<long long> rank;\n    vector<long long> time;\n    const long long INF = 1e18;\n\n    void initialize(long long n){\n        par.resize(n);\n        rank.resize(n);\n        time.resize(n);\n        for(long long i=0; i<n; i++){\n            par[i] = i;\n            rank[i] = 0;\n            time[i] = INF;\n        }\n    }\n\n    long long find(long long x, long long t){\n        if(time[x] > t){\n            return x;\n        }else{\n            return find(par[x], t);\n        }\n    }\n\n    void unite(long long x, long long y, long long t){\n        x = find(x, t);\n        y = find(y, t);\n        if(x == y) return;\n        if(rank[x] < rank[y]){\n            par[x] = y;\n            time[x] = t;\n        }else{\n            par[y] = x;\n            time[y] = t;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(long long x, long long y, long long t){\n        return find(x, t) == find(y, t);\n    }\n};\n\nstruct edge{long long u, v, cost;};\nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\nUnionFind uf;\n\nlong long kruskal(long long N, vector<edge> es){\n    sort(es.begin(), es.end(), comp);\n    uf.initialize(N);\n    long long res = 0;\n    for(long long i=0; i<es.size(); i++){\n        edge e = es[i];\n        if(!uf.same(e.u, e.v, e.cost)){\n            uf.unite(e.u, e.v, e.cost);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\n\nint main(){\n    long long i, j, k;\n    long long N, M;\n    cin >> N >> M;\n    vector<edge> es;\n    for(i=0; i<M; i++){\n        long long a, b, c;\n        cin >> a >> b >> c;\n        es.push_back({a, b, c});\n    }\n    long long sum = kruskal(N+1, es);\n\n    long long Q;\n    cin >> Q;\n    for(i=0; i<Q; i++){\n        long long s, t;\n        cin >> s >> t;\n        long long ok=0, ng=1e10; \n        while(ng-ok>1){\n            long long mid = (ng+ok)/2;\n            if(uf.same(s, t, mid)){\n                ng = mid;\n            }else{\n                ok = mid;\n            }\n        }\n        cout << (sum-ok-1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\nlong long hen;\n\n//           cost,   ,            src, dst\nvector<pair<long long, pair<long long, long long> > >vec;\nvector<pair<long long, pair<long long, long long> > >fvec;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n\t  // 最初は全てのデータiがグループiに存在するものとして初期化\n\t  for(int i = 0; i < n; i++){\n\t\t  par[i] = i;\n\t  }\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n\nvoid solve(int s, int t){\n\tUnionFind uf(N + 1);\t\n\tuf.unite(s, t);\n\n\tset<long> done;\n\tlong long ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tlong long src = vec[i].second.first;\n\t\tlong long dst = vec[i].second.second;\n\t\tlong long cost = vec[i].first;\n\t\tif(uf.same(src, dst) == false){\n\t\t\tuf.unite(src, dst);\n\t\t\tans += cost;\n\t\t}\n\t\tif(uf.size(s) == N){\n\t\t\tcout << ans << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid prepare(){\n\tUnionFind uf(N + 1);\t\n\n\tset<long> done;\n\tlong long ans = 0;\n\tfor(int i = 0; i < fvec.size(); i++){\n\t\tlong long src = fvec[i].second.first;\n\t\tlong long dst = fvec[i].second.second;\n\t\tlong long cost = fvec[i].first;\n\t\tif(uf.same(src, dst) == false){\n\t\t\tuf.unite(src, dst);\n\t\t\tvec.push_back(fvec[i]);\n\t\t}\n\t\tif(uf.size(0) == N){\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\tfvec.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(fvec.begin(), fvec.end());\n\n\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\n\tprepare();\n\t\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPP(i,m,n) for(long long i=m;i<n;++i)\n#define rep(i,n) for(long long i = n-1;i>=0;--i)\n#define repp(i,n,m) for(long long i = n-1; i >= m; --i)\n#define ALL(N) (N.begin(),N.end())\n#define de cout << \"line : \" << __LINE__ << \" debug\" << endl;\n#define pb push_back\n#define pq priority_queue\n#define Dcout(N) cout << setprecision(20) << N << endl\nconstexpr long long INF = 2147483647;\nconstexpr long long INFF = 9223372036854775807;\n\nstruct edge{long long u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n    return e1.cost < e2.cost;\n}\n\n\nstruct UnionFind{\n    vector<long long> par,r;\n\n    //はじめに全てが根であるとしておく\n    UnionFind(long long N):par(N),r(N,1){iota(par.begin(),par.end(),0);}\n\n    long long root(long long x){//根に当たるまで再帰で探す\n        if(par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n\n    bool same(long long x,long long y){//つながっているかどうか判定\n        return par[x] == par[y];\n    }\n\n    long long size(long long x){ //根の大きさを判定する\n        return r[root(x)];\n    }\n\n    void unite(long long x, long long y){//根が同じでなかったらつなげる\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(r[x] < r[y]) swap(x,y); //値を小さいほうを根にする\n        r[x] += r[y];\n        par[y] = x;\n        return;\n    }\n};\n\nedge es[400100];\nlong long V,E;\nvector<pair<long long,long long>> G[4100];\n\nlong long kruskal(){\n    sort (es,es + E,comp);\n    UnionFind UF(V);\n    long long res = 0;\n    REP(i,E){\n        edge e = es[i];\n        if(!UF.same(e.u,e.v)){\n            UF.unite(e.u,e.v);\n            res += e.cost;\n            G[e.u].pb({e.v,e.cost});\n            G[e.v].pb({e.u,e.cost});\n        }\n    }\n    return res;\n}\n\nlong long dis[4100][4100];\nbool seen[4100][4100];\n\nvoid dfs(long long &X,long long& st,long long& co){\n    long long m = co;\n    REP(i,G[X].size()){\n        co = m;\n        if(!seen[st][G[X][i].first]){\n            seen[st][G[X][i].first] = 1;\n        }\n        else continue;\n        if(co < G[X][i].second) co = G[X][i].second;\n        dis[st][G[X][i].first] = max(co,dis[st][G[X][i].first]);\n        dfs(G[X][i].first,st,co);\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n    cin >> V >> E;\n    REP(i,E){\n        cin >> es[i].u >> es[i].v >> es[i].cost;--es[i].u;--es[i].v;\n    }\n    long long mincost = kruskal();\n    long long Q;cin >> Q;\n    long long c = 0,S,T;\n    REP(i,V){\n        dfs(i,i,c);c = 0;\n        //REP(j,V) seen[i][j] = 0;\n    }\n    REP(i,Q){\n        cin >> S >> T;--S;--T;\n        cout << mincost - dis[S][T] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nusing vector2 = vector<vector<T>>;\ntemplate <typename T>\nvector2<T> initVec2(size_t n0, size_t n1, T e = T()){\n    return vector2<T>(n0, vector<T>(n1, e));\n}\n\ntemplate <typename T>\nusing vector3 = vector<vector<vector<T>>>;\ntemplate <typename T>\nvector3<T> initVec3(size_t n0, size_t n1, size_t n2, T e = T()){\n    return vector3<T>(n0, vector2<T>(n1, vector<T>(n2, e)));\n}\n\ntemplate <typename T>\nclass UnionFind{\n    public:\n        int n;\n        vector<T> p, rank;\n\n        UnionFind(int n)\n            : n(n), p(n+1, -1), rank(n+1) {}\n\n        int find(int v){\n            if(p[v] == -1){\n                return v;\n            }\n            p[v] = find(p[v]);\n            return p[v];\n        }\n\n        bool unite(int u, int v){\n            u = find(u);\n            v = find(v);\n\n            if(u == v){\n                return false;\n            }\n\n            if(rank[u] < rank[v]){\n                swap(u, v);\n            }\n\n            if(rank[u] == rank[v]){\n                rank[u]++;\n            }\n\n            p[v] = u;\n            return true;\n        }\n\n        bool same(int u, int v){\n            u = find(u);\n            v = find(v);\n            return u == v;\n        }\n};\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<tuple<int, int, int>> edge(m);\n    rep(i, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        edge[i] = make_tuple(c, a, b);\n    }\n    sort(ALL(edge));\n\n    auto graph = initVec2<P>(n + 1, 0);\n    UnionFind<int> uf(n);\n    int sum = 0;\n    rep(i, m){\n        int u, v, w;\n        tie(w, u, v) = edge[i];\n        if(uf.unite(u, v)){\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n            sum += w;\n        }\n    }\n\n    auto weight = initVec2<int>(n + 1, n + 1);\n    for(int i = 1; i <= n; i++){\n        stack<tuple<int, int, int>> st;\n        st.emplace(i, 0, 0);\n\n        while(not st.empty()){\n            int v, p, w;\n            tie(v, p, w) = st.top();\n            st.pop();\n\n            weight[i][v] = w;\n\n            for(P pp : graph[v]){\n                int u = pp.first;\n                int we = pp.second;\n                if(u == p){\n                    continue;\n                }\n                st.emplace(u, v, max(w, we));\n            }\n        }\n    }\n\n    int q;\n    cin >> q;\n    rep(i, q){\n        int s, t;\n        cin >> s >> t;\n\n        cout << sum - weight[s][t] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<tuple<int, int, int>> es;\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es.emplace_back(c, a, b);\n  }\n\n  sort(es.begin(), es.end());\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; cin >> s >> t; s--, t--;\n    tree::union_find uf(N);\n    uf.unite(s, t);\n    ll ans = 0;\n    rep(k, M) {\n      int a, b, c; tie(c, a, b) = es[k];\n      if(!uf.same(a, b)) {\n        uf.unite(a, b);\n        ans += c;\n      }\n    }\n\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    int q;\n    cin >> q;\n    if(int64_t(m)*q>10000000) return;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        union_find uf(n);\n        int sum=0;\n        for(edge &edge:edges){\n            int a=edge.from,b=edge.to;\n            if(uf.is_same_group(a,b) or (uf.is_same_group(a,s) and uf.is_same_group(b,t)) or (uf.is_same_group(b,s) and uf.is_same_group(a,t))) continue;\n            uf.unite(a,b);\n            sum+=edge.cost;\n        }\n        cout << sum << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <stack>\n#include <climits>\n#include <set>\n#include <queue>\n#include <algorithm>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld;\n\n\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\nconst int N = 100001;\nconst int MOD = 1e9 + 7;\n\nbool pairCompare(const std::pair<int,pair<int,int>>& firstElem, const std::pair<int,pair<int,int>>& secondElem) {\n    return firstElem.first < secondElem.first;\n    \n}\n\nvoid initialize(int size[], int Arr[ ], int N)\n{\n    for(int i = 0;i<N;i++)\n    {\n        Arr[ i ] = i ;\n        size[ i ] = 1;\n    }\n}\n\nint root (int Arr[ ] ,int i)\n{\n    while(Arr[ i ] != i)\n    {\n        Arr[ i ] = Arr[ Arr[ i ] ] ;\n        i = Arr[ i ];\n    }\n    return i;\n}\n\n/*modified union function where we connect the elements by changing the root of one of the element */\n/*\n void unio(int Arr[ ] ,int A ,int B)\n {\n int root_A = root(Arr, A);\n int root_B = root(Arr, B);\n Arr[ root_A ] = root_B ;       //setting parent of root(A) as root(B).\n }\n */\n\nvoid weightedunio(int Arr[ ],int size[ ],int A,int B)\n{\n    int root_A = root(Arr, A);\n    int root_B = root(Arr, B);\n    if(size[root_A] < size[root_B ])\n    {\n        Arr[ root_A ] = Arr[root_B];\n        size[root_B] += size[root_A];\n    }\n    else\n    {\n        Arr[ root_B ] = Arr[root_A];\n        size[root_A] += size[root_B];\n    }\n    \n}\n\nbool find(int Arr[], int A,int B)\n{\n    if( root(Arr, A)==root(Arr, B) )       //if A and B have same root,means they are connected.\n        return true;\n    else\n        return false;\n}\n\n\n\nint main(int argc, const char * argv[]) {\n    \n    \n    int n, m;\n    cin>>n>>m;\n    vector<pair<int,pair<int,int>>> adj;\n    for(int i = 0; i < m; i++){\n        int a,b,c;\n        cin>>a>>b>>c; a--; b--;\n        adj.push_back(mp(c,mp(a,b)));\n    }\n    \n    \n    \n    int q;\n    cin>>q;\n    for(int i = 0; i < q; i++){\n        int s,t;\n        cin>>s>>t;s--;t--;\n        adj.push_back(mp(0,mp(s,t)));\n        sort(adj.begin(), adj.end(), pairCompare);\n        \n        int ans = 0;\n        \n       \n        \n        int size[n], arr[n];\n        initialize(size, arr, n);\n        \n        for(int i = 0; i <= m; i++){\n            if(!find(arr, adj[i].second.first, adj[i].second.second)){\n                ans += adj[i].first;\n                weightedunio(arr,size,adj[i].second.first, adj[i].second.second);\n            }\n        }\n        \n        cout<<ans<<endl;\n        \n    }\n    \n    /*\n     4 3\n     1 2 3\n     2 3 4\n     3 4 5\n     1\n     2 3*/\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef pair<int64_t,int64_t> P;\ntypedef pair<int64_t,P> T;\nvector<P> G[4001];\nint64_t ans[4001][4001]={};\nclass uft {//union-find tree\npublic:\n    int parent[4010];\n    int size[4010];\n    int root(int x);\n    bool same(int x,int y);\n    void unite(int x,int y);\n};\nint uft::root(int x){\n    if(parent[x]==x){\n        return x;\n    }\n    return parent[x] = root(parent[x]);\n}\nbool uft::same(int x,int y){\n    if(root(x)==root(y)){\n        return true;\n    }else{\n        return false;\n    }\n}\nvoid uft::unite(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x == y) return;\n    parent[x] = y;\n    size[y] = size[y]+size[x];\n}\nint64_t Kruskal(priority_queue<T, vector<T>, greater<T> > q,int N){\n    uft u;\n    for(int i=0;i<N;i++){\n        u.parent[i]=i;\n        u.size[i]=1;\n    }\n    int64_t ret=0;\n    while(u.size[u.root(0)] != N && !q.empty()){\n        T edge = q.top(); q.pop();\n        int s=(edge.second).first;\n        int t=(edge.second).second;\n        if(u.root(s) != u.root(t) ){\n            u.unite(s,t);\n            ret += edge.first;\n            G[s].push_back(P(t,edge.first));\n            G[t].push_back(P(s,edge.first));\n            //cout<<s<<' '<<t<<' '<<edge.first<<endl;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    priority_queue<T, vector<T>, greater<T> > q;\n    for(int i=0;i<M;i++){\n        int a,b;\n        int64_t c;\n        cin>>a>>b>>c;\n        a--; b--;\n        T d = T(c,P(a,b));\n        q.push(d);\n    }\n    int64_t an=Kruskal(q,N);\n    //cout<<an<<endl;\n    for(int i=0;i<N;i++){\n        bool used[4010]={};\n        used[i]=true;\n        queue<P> qu;\n        qu.push(P(i,0));\n        while (!qu.empty()) {\n            P v  = qu.front(); qu.pop();\n            //cout<< v.first <<' '<< v.second <<endl;\n            for(int j=0;j<G[v.first].size();j++){\n                P u = G[v.first][j];\n                if(!used[u.first]){\n                    //cout<<v.first<<' '<<v.second<<' '<<u.first<<' '<<u.second<<endl;\n                    used[u.first]=true;\n                    ans[i][u.first]=max(v.second,u.second);\n                    //cout<<\"ans \"<<i<<' '<<u.first<<' '<<ans[i][u.first]<<endl;cout<<endl;\n                    qu.push(P(u.first,ans[i][u.first]));\n                }\n            }\n        }\n    }/*\n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            cout<<ans[i][j]<<' ';\n        }cout<<endl;\n    }*/\n    int Q;\n    cin>>Q;\n    for(int i=0;i<Q;i++){\n        int s,t;\n        cin>>s>>t;\n        s--;t--;\n        cout<< an - ans[s][t] << endl;\n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nclass UnionFind{\n\tprivate:\n\t\tvector<int> parent;\n\t\tvector<int> rank;\n\tpublic:\n\t\tUnionFind(int n)\n\t\t\t:parent(n + 1),rank(n + 1,1){\n\t\t\tfor(int i = 1;i <= n;i++) parent [i] = i;\n\t\t}\n\t\tint find(int x){\n\t\t\tif(parent [x] == x) return x;\n\t\t\treturn parent [x] = find(parent [x]);\n\t\t}\n\t\tbool connect(int x,int y){\n\t\t\tx = find(x),y = find(y);\n\t\t\tif(x == y) return false;\n\t\t\tif(rank [x] < rank [y]) swap(x,y);\n\t\t\tif(rank [x] == rank [y]) rank [x]++;\n\t\t\tparent [y] = x;\n\t\t\treturn true;\n\t\t}\n\t\tbool same(int x,int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n};\n\nint N,M,Q;\nlist< pair<int,ll> > edge [4001],used_edge [4001];\nstruct st{\n\tint a,b;\n\tll c;\n\tbool operator<(const st& other){\n\t\treturn this->c < other.c;\n\t}\n};\nll max_edge [4001] [4001];\n\nll dfs(int curr,int prev,int s,ll mx)\n{\n\tmax_edge [s] [curr] = mx;\n\tmax_edge [curr] [s] = mx;\n\tfor(auto&& it : used_edge [curr]) if(it.first != prev){\n\t\tdfs(it.first,curr,s,max(mx,it.second));\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tvector<st> A(M);\n\tFOR(i,0,M){\n\t\tscanf(\"%d%d%lld\",&A [i].a,&A [i].b,&A [i].c);\n\t\tedge [A [i].a].push_back({A [i].b,A [i].c});\n\t\tedge [A [i].b].push_back({A [i].a,A [i].c});\n\t}\n\tsort(ALL(A));\n\n\tscanf(\"%d\",&Q);\n\tvector< pair<int,int> > query(Q);\n\tFOR(i,0,Q){\n\t\tscanf(\"%d%d\",&query [i].first,&query [i].second);\n\t}\n\n\tll ans = 0;\n\tUnionFind uf(N);\n\tFOR(i,0,M){\n\t\tif(uf.same(A [i].a,A [i].b) == false){\n\t\t\tuf.connect(A [i].a,A [i].b);\n\t\t\tused_edge [A [i].a].push_back({A [i].b,A [i].c});\n\t\t\tused_edge [A [i].b].push_back({A [i].a,A [i].c});\n\t\t\tans += A [i].c;\n\t\t}\n\t}\n\n\tfor(int i = 1;i <= N;i++){\n\t\tdfs(i,-1,i,0);\n\t}\n\n\tFOR(i,0,Q){\n\t\tprintf(\"%lld\\n\",ans - max_edge [query [i].first] [query [i].second]);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, m;\nint q;\n\nstruct edge{int cost, u, v;};\nvector<edge> edges;\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nint ans[4000][4000];\n\nstruct UnionFind {\n  vector<int> par, rank;\n  vector<vector<int>> cmp;\n  UnionFind(int size) : par(size), rank(size), cmp(size)\n  {\n    rep(i, size) {\n      par[i] = i;\n      cmp[i].push_back(i);\n    }\n  }\n\n  int find_root(int x) {\n    if (par[x] != x) return par[x] = find_root(par[x]);\n    else return x;\n  }\n\n  bool same(int x, int y) {\n    return find_root(x) == find_root(y);\n  }\n\n  void unite(int x, int y, int c) {\n    int u = find_root(x);\n    int v = find_root(y);\n    for (auto uu : cmp[u]) {\n      for (auto vv : cmp[v]) {\n        ans[uu][vv] = c;\n        ans[vv][uu] = c;\n      }\n    }\n    if (rank[u] > rank[v]) swap(u, v);\n    par[u] = v;\n    for (auto uu : cmp[u]) cmp[v].push_back(uu);\n    if (rank[u] == rank[v]) rank[v]++;\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    edges.push_back({c, a, b});\n  }\n\n  sort(all(edges), comp);\n  UnionFind uf(n);\n  int sum_cost = 0LL;\n  rep(i, m) {\n    edge e = edges[i];\n    if (uf.same(e.u, e.v)) continue;\n    uf.unite(e.u, e.v, e.cost);\n    sum_cost += e.cost;\n  }\n\n  cin >> q;\n  rep(i, q) {\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum_cost - ans[s][t] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\nlong long hen;\n\n//           cost,   ,            src, dst\nvector<pair<long long, pair<long long, long long> > >vec;\nvector<pair<long long, pair<long long, long long> > >fvec;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n\t  // 最初は全てのデータiがグループiに存在するものとして初期化\n\t  for(int i = 0; i < n; i++){\n\t\t  par[i] = i;\n\t  }\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n\nvoid solve(int s, int t){\n\tUnionFind uf(N + 1);\t\n\tuf.unite(s, t);\n\n\tset<long> done;\n\tlong long ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tlong long src = vec[i].second.first;\n\t\tlong long dst = vec[i].second.second;\n\t\tlong long cost = vec[i].first;\n\t\tif(uf.same(src, dst) == false){\n\t\t\tuf.unite(src, dst);\n\t\t\tans += cost;\n\t\t}\n\t\tif(uf.size(s) == N){\n\t\t\tcout << ans << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid prepare(){\n\tUnionFind uf(N + 1);\t\n\n\tset<long> done;\n\tlong long ans = 0;\n\tfor(int i = 0; i < fvec.size(); i++){\n\t\tlong long src = fvec[i].second.first;\n\t\tlong long dst = fvec[i].second.second;\n\t\tlong long cost = fvec[i].first;\n\t\tif(uf.same(src, dst) == false){\n\t\t\tuf.unite(src, dst);\n\t\t\tvec.push_back(fvec[i]);\n\t\t}\n\t\tif(uf.size(0) == N){\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\tfvec.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(fvec.begin(), fvec.end());\n\n\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\n\tprepare();\n\t\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\ntypedef struct UnionFindTree{\n    vector<int> par;\n\n    UnionFindTree(int n): par(n, -1){}\n\n    int find(int x){\n        if(par[x] < 0) return x;\n        return par[x] = find(par[x]);\n    }\n\n    int size(int x){\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n}UF;\n\ntemplate<class T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n\ntemplate<class T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n\n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n\n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n\n    pair<bool, vector<T>> bellman_ford(int s){\n        T d_INF = numeric_limits<T>::max();\n        vector<T> d(n, d_INF);\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        d[s] = 0;\n        rep(i, n)for(edge<T> &e: E){\n            if(d[e.from] != d_INF && d[e.from] + e.cost < d[e.to]){\n                d[e.to] = d[e.from] + e.cost;\n                if(i == n-1) return make_pair(true, d);\n            }\n        }\n        return make_pair(false, d);\n    }\n\n    vector<T> dijkstra(int s){\n        using P = pair<T, int>;\n        priority_queue<P, vector<P>, greater<P>> que;\n        vector<T> d(n, numeric_limits<T>::max());\n        d[s] = 0;\n        que.push(P((T)0, s));\n        while(!que.empty()){\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(edge<T> &e : G[v]){\n                if(d[e.to] > d[v] + e.cost){\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n        return d;\n    }\n\n    pair<bool, vector<vector<T>>> warshall_floyd(){\n        T d_INF = numeric_limits<T>::max();\n        vector<vector<T>> d = vector<vector<T>>(n, vector<T>(n, d_INF));\n        rep(i, n){\n            for(edge<T> &e: G[i]) d[i][e.to] = e.cost;\n            d[i][i] = 0;\n        }\n        rep(k, n)rep(i, n)rep(j, n)if(d[i][k] < d_INF && d[k][j] < d_INF){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        rep(i, n)if(d[i][i] < 0) return make_pair(true, d);\n        return make_pair(false, d);\n    }\n\n    pair<T, Graph<T>> kruskal(){\n        vector<edge<T>> E;\n        rep(i, n)for(edge<T> &e: G[i]) E.push_back(e);\n        sort(E.begin(), E.end(), [](const edge<T> &e1, const edge<T> &e2){return e1.cost < e2.cost;});\n        UF uf(n);\n        T ret = 0;\n        Graph<T> MST(n);\n        for(edge<T> &e: E){\n            if(!uf.same(e.from, e.to)){\n                uf.unite(e.from, e.to);\n                ret += e.cost;\n                MST.add_edge(e.from, e.to, e.cost);\n                MST.add_edge(e.to, e.from, e.cost);\n            }\n        }\n        return {ret, MST};\n    }\n\n    pair<bool, vector<int>> toposo(){\n        vector<int> ret(n, -1), in(n, 0);\n        rep(i, n)for(edge<T> &e: G[i]) ++in[e.to];\n        int cur = 0;\n        stack<int> st;\n        rep(i, n)if(!in[i]) st.push(i);\n        if(st.empty()) return make_pair(false, ret);\n        while(!st.empty()){\n            int v = st.top(); st.pop();\n            ret[cur++] = v;\n            for(edge<T> &e: G[v]){\n                if(!in[e.to]) return make_pair(false, ret);\n                --in[e.to];\n                if(!in[e.to]) st.push(e.to);\n            }\n        }\n        return make_pair(cur==n, ret);\n    }\n\n    bool has_cycle(){\n        return !toposo().fi;\n    }\n\n    void scc_dfs(int v, vector<bool> &used, vector<int> &vs){\n        used[v] = true;\n        for(edge<T> &e: G[v])if(!used[e.to]) scc_dfs(e.to, used, vs);\n        vs.push_back(v);\n    }\n\n    void scc_rdfs(int v, int k, vector<int> &cmp, vector<bool> &used, vector<vector<int>> &rG){\n        used[v] = true;\n        cmp[v] = k;\n        for(int nv: rG[v])if(!used[nv]) scc_rdfs(nv, k, cmp, used, rG);\n    }\n\n    tuple<int, vector<int>, vector<vector<int>>> scc(){\n            vector<vector<int>> rG(n);\n            rep(i, n)for(edge<T> &e: G[i]) rG[e.to].push_back(i);\n            vector<bool> used(n, false);\n            vector<int> vs;\n            vector<int> vtoc(n);\n            rep(i, n)if(!used[i]) scc_dfs(i, used, vs);\n            fill(used.begin(), used.end(), false);\n            int k = 0;\n            vector<vector<int>> ctov=vector<vector<int>>(n, vector<int>());\n            rrep(i, n)if(!used[vs[i]]) scc_rdfs(vs[i], k++, vtoc, used, rG, ctov);\n            return make_tuple(k, vtoc, ctov);\n    }\n\n    int bridge_dfs(int v, int pv, int &idx, vector<int> &ord, vector<int> &low, vector<pii> &bridge){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=pv){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], bridge_dfs(nv, v, idx, ord, low, bridge));\n                if(low[nv]>ord[v]) bridge.emplace_back(min(v, nv), max(v, nv));\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<pii> get_bridge(){\n        vector<int> ord(n, -1), low(n, -1);\n        vector<pii> bridge;\n        int idx=0;\n        bridge_dfs(0, -1, idx, ord, low, bridge);\n        sort(bridge.begin(), bridge.end());\n        bridge.erase(unique(bridge.begin(), bridge.end()), bridge.end());\n        return bridge;\n    }\n\n    int art_dfs(int v, int prev, int &idx, vector<int> &ord, vector<int> &low, vector<int> &art){\n        ord[v]=low[v]=idx++;\n        for(auto &e: G[v])if(e.to!=prev){\n            int nv=e.to;\n            if(ord[nv]<0){\n                chmin(low[v], art_dfs(nv, v, idx, ord, low, art));\n                if((prev<0 && ord[nv]!=1) || (prev>=0 && low[nv]>=ord[v])){\n                    art.push_back(v);\n                }\n            }\n            else chmin(low[v], ord[nv]);\n        }\n        return low[v];\n    }\n\n    vector<int> get_art(){\n        vector<int> ord(n, -1), low(n, -1), art;\n        int idx=0;\n        art_dfs(0, -1, idx, ord, low, art);\n        sort(art.begin(), art.end());\n        art.erase(unique(art.begin(), art.end()), art.end());\n        return art;\n    }\n};\n\nlint M[4010][4010];\nset<lint> S;\n\nvoid dfs(int v, int pv, int root, Graph<lint> &mst){\n    if(v != root) M[root][v] = *S.rbegin();\n    for(auto &e: mst.G[v])if(e.to != pv){\n        S.insert(e.cost);\n        dfs(e.to, v, root, mst);\n        S.erase(e.cost);\n    }\n}\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    Graph<lint> gr(n);\n    rep(i, m){\n        int a, b;\n        lint c;\n        scanf(\"%d%d%lld\", &a, &b, &c);\n        --a; --b;\n        gr.add_edge(a, b, c);\n        gr.add_edge(b, a, c);\n    }\n    lint w;\n    Graph<lint> mst(n);\n    tie(w, mst) = gr.kruskal();\n    rep(i, n) dfs(i, -1, i, mst);\n\n    int q;\n    scanf(\"%d\", &q);\n    rep(_, q){\n        int s, t;\n        scanf(\"%d%d\", &s, &t);\n        --s; --t;\n        printf(\"%lld\\n\", w - M[s][t]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint dist[4000][4000];\nvector<pair<int, int>> G[4000];\ntuple<int, int, int> es[4000];\n\nvoid dfs(int curr, int par, int start, int max) {\n  dist[curr][start] = max;\n  for(auto const& e: G[curr]) {\n    if(e.first != par) dfs(e.first, curr, start, std::max(max, e.second));\n  }\n};\n\nint main() {\n\n  int N, M; cin >> N >> M;\n\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es[i] = make_tuple(c, a, b);\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es, es+M);\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  rep(i, N) {\n    dfs(i, -1, i, 0);\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; scanf(\"%d%d\", &s, &t); s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> par;\n    vector<int> dep;\n    \n    UnionFind(int siz){\n        par.assign(siz,0);\n        dep.assign(siz,0);\n        for(int i=0;i<siz;i++){\n            par[i]=i;\n        }\n    };\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y){\n            return;\n        }\n        if(dep[x]<dep[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(dep[x]==dep[y]){\n                dep[x]++;\n            }\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\nstruct edge{int from,to;ll cost;};\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost<e2.cost;\n}\nstruct edge2{int to;ll cost;};\nvector<edge2> G[4010];\nedge es[4010];\nll s[4010][4010];\nvoid dfs(int now,int p,int st,ll ma){\n\tfor(auto e:G[now]){\n\t\tif(e.to==p)continue;\n\t\ts[st][e.to]=max(ma,e.cost);\n\t\tdfs(e.to,now,st,max(ma,e.cost));\n\t}\n}\n\t\nint main(){\n\tint n,m,q;cin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;a--;b--;\n\t\tes[i]={a,b,c};\n\t}\n\tsort(es,es+m,comp);\n\tUnionFind uf(n+1);\n\tll ans=0;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=es[i];\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tG[e.from].push_back({e.to,e.cost});\n\t\t\tG[e.to].push_back({e.from,e.cost});\n\t\t\tans+=e.cost;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs(i,-1,i,0);\n\t}\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tcout<<ans-s[a][b]<<endl;\n\t}\n\t\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<57;\nconst double pi=acos(-1);\nconst double eps=1e-6;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,1,1,1,0},DY[8]={1,0,-1,-1,-1,0,1,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]) Par[x]=y;\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvp List;\n\tvip e;\n\tvb used;\n\tvoid Rec(int v,int M,vl& d){\n\t\tused[v]=1;\n\t\td[v]=M;\n\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\tint u=List[v][i].first,c=List[v][i].second;\n\t\t\tif(!used[u]) Rec(u,max(M,c),d);\n\t\t}\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tList=vvp(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back({t,c});\n\t\tList[t].push_back({s,c});\n\t\te.push_back({c,{s,t}});\n\t}\n\tvvl func(){\n\t\tvvl d(V,vl(V));\n\t\tfor(int i=0;i<V;i++){\n\t\t\tused=vb(V,0);\n\t\t\tRec(i,0,d[i]);\n\t\t}\n\t\treturn d;\n\t}\n\tvoid solve(){\n\t\tUnion_Find_Tree uft(V);\n\t\tGraph G(V);\n\t\tll cost=0;\n\t\tsort(e.begin(),e.end());\n\t\tfor(int i=0;i<e.size();i++){\n\t\t\tll c=e[i].first,s=e[i].second.first,t=e[i].second.second;\n\t\t\tif(!uft.Same(s,t)){\n\t\t\t\tuft.Unite(s,t);\n\t\t\t\tG.add_edge(s,t,c);\n\t\t\t\tcost+=c;\n\t\t\t}\n\t\t}\n\t\tvvl d=G.func();\n\t\tint q;\n\t\tcin>>q;\n\t\tfor(int i=0;i<q;i++){\n\t\t\tint s,t;\n\t\t\tcin>>s>>t;\n\t\t\tcout<<cost-d[s-1][t-1]<<endl;\n\t\t}\n\t}\n};\n\nint n,m;\n\nint main(){\n\tcin>>n>>m;\n\tGraph g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tg.add_edge(a-1,b-1,c);\n\t}\n\tg.solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 400010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct UF {\n\tvector<int> par, ran;\n\tvoid init(int n) {\n\t\tpar.resize(n); ran.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tUF(int mx = 0) { init(mx); }\n\n\tint find(int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\n//////////////\n\nint N, M, E;\nstruct edge { int u, v, cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nedge es[400010];\nvector<pi> G[MAX_N];\nint depth[MAX_N];\nint par[MAX_N];\nint cost[MAX_N];\n\nll kruskal() {\n\tsort(es, es + E, comp);\n\tUF uf(N);//init union_find\n\tll res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tG[e.u].pb(pi(e.v, e.cost));\n\t\t\tG[e.v].pb(pi(e.u, e.cost));\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid add_edge(int s, int t, int cost) {\n\tes[E++] = edge{s, t, cost};\n}\n\nvoid loop(int v, int p, int k) {\n\tdepth[v] = k;\n\tpar[v] = p;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst;\n\t\tif(n == p) continue;\n\t\tcost[n] = G[v][i].sec;\n\t\tloop(n, v, k + 1);\n\t}\n}\n\nvoid solve() {\n\tE = 0;\n\tcin >> N >> M;\n\trep(i, 0, M) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c; a--; b--;\n\t\tadd_edge(a, b, c);\n\t}\n\tll S = kruskal();\n\tloop(0, -1, 0);\n\tint Q; cin >> Q;\n\twhile(Q--) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tif(depth[a] < depth[b]) swap(a, b);\n\t\tint mv = -1;\n\t\twhile(depth[a] > depth[b]) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\ta = par[a];\n\t\t}\n\t\t// debug(depth[a], depth[b], a, b);\n\t\twhile(a != b) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\tMAX(mv, cost[b]);\n\t\t\ta = par[a]; b = par[b];\n\t\t}\n\t\tcout << S - mv << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n#include <assert.h>\n#include <unordered_set>\n\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\n\n\n\n\n\n\nclass unionfind {\nprivate:\n    vector<int> par;\n    vector<int> rank;\n    vector<int> counter;\npublic:\n    unionfind(int n) : rank(n), counter(n, 1){\n        for(int i = 0; i < n; i++){\n            par.push_back(i);\n        }\n    }\n    \n    int find(int x){\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            return par[x] = find(par[x]);\n        }\n    }\n    \n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        \n        if (rank[x] < rank[y]) {\n            counter[y] += counter[x];\n            counter[x] = counter[y];\n            par[x] = y;\n        }\n        else {\n            counter[y] += counter[x];\n            counter[x] = counter[y];\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n    \n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n    ll count(int x){\n        return counter[find(x)];\n    }\n};\n\n\ntemplate <typename T>\nclass kruskal {\nprivate:\n    struct edge{\n        T cost;\n        int u, v;\n        \n        bool operator<(const edge& e1) const {\n            return cost < e1.cost;\n        }\n    };\n    vector<edge> es;\n    int n;\npublic:\n    kruskal(int n) : n(n){}\n    \n    void add_edge(int u, int v, T cost){\n        es.push_back({cost, u, v});\n        es.push_back({cost, v, u});\n    }\n    \n    pair<vector<pair<pair<ll, ll>, ll>>, T> run(){\n        sort(es.begin(), es.end());\n    \n        unionfind uni(n);\n        T res = 0;\n        vector<pair<pair<ll, ll>, ll>> edges;\n        \n        for(auto& e : es){\n            if(!uni.same(e.u, e.v)){\n                uni.unite(e.u, e.v);\n                res += e.cost;\n                edges.push_back({{e.u, e.v}, e.cost});\n            }\n        }\n        \n        return {edges, res};\n    }\n};\n\nclass LCA {\n    ll n, log_n;\n    vector<vector<pair<ll, ll>>> parent;\n    vector<ll> depth;\n    vector<bool> used;\n    \nprivate:\n    void dfs(const vector<vector<pair<ll, ll>>> &g, ll now, ll par, ll d, ll cost){\n        parent[0][now].first = par;\n        parent[0][now].second = cost;\n        depth[now] = d;\n        used[now] = true;\n        \n        for(auto &edge : g[now]){\n            ll child = edge.first, c = edge.second;\n            if(child != par){\n                dfs(g, child, now, d + 1, c);\n            }\n        }\n    }\n    \npublic:\n    LCA(const vector<vector<pair<ll, ll>>> &g) : n(g.size()), log_n(0), depth(n), used(n) {\n        for(ll v = n; v > 0; v /= 2){\n            log_n++;\n        }\n        parent.resize(log_n, vector<pair<ll, ll>>(n));\n        for(ll i = 0; i < n; i++){\n            if(!used[i]){\n                dfs(g, i, -1, 0, 0);\n            }\n        }\n        for(ll k = 0; k < log_n - 1; k++){\n            for(ll v = 0; v < n; v++){\n                if(parent[k][v].first < 0){\n                    parent[k + 1][v] = parent[k][v];\n                }\n                else{\n                    parent[k + 1][v].first = parent[k][parent[k][v].first].first;\n                    parent[k + 1][v].second = max(parent[k][v].second, parent[k][parent[k][v].first].second);\n                }\n            }\n        }\n    }\n    \n    ll query(ll u, ll v){\n        if(depth[u] > depth[v]){\n            swap(u, v);\n        }\n        ll res = 0;\n        for(ll k = 0; k < log_n; k++){\n            if(((depth[v] - depth[u]) >> k) & 1){\n                res = max(res, parent[k][v].second);\n                v = parent[k][v].first;\n            }\n        }\n        if(u == v){\n            return res;\n        }\n        for(ll k = log_n - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                res = max(res, parent[k][u].second);\n                res = max(res, parent[k][v].second);\n                u = parent[k][u].first;\n                v = parent[k][v].first;\n            }\n        }\n        return res;\n    }\n};\n\n\n\n\n\n\n\n\nint main(){\n    ll n, m;\n    cin >> n >> m;\n    kruskal<ll> krus(n);\n    REP(i, m){\n        ll a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        krus.add_edge(a, b, c);\n    }\n    \n    auto tmp = krus.run();\n    auto e = tmp.first;\n    ll cost = tmp.second;\n    vector<vector<pair<ll, ll>>> g(n);\n    REP(i, e.size()){\n        ll a = e[i].first.first, b = e[i].first.second, c = e[i].second;\n        g[a].push_back({b, c});\n        g[b].push_back({a, c});\n    }\n    \n    LCA lca(g);\n    ll q;\n    cin >> q;\n    REP(i, q){\n        ll s, t;\n        cin >> s >> t;\n        s--; t--;\n        cout << cost - lca.query(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\n\nvoid solve(long long N, long long M, vector<long long> a, vector<long long> b, vector<long long> c, long long Q, vector<long long> S, vector<long long> T){\n\tvector< array<int,3> > es;\n\tfor(int i = 0 ; i < M ; i++)\n\t\tes.push_back({c[i],a[i]-1,b[i]-1});\n\tsort(es.begin(),es.end());\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tUnionFind uf(N);\n\t\tS[i]--,T[i]--;\n\t\tuf.unionSet(S[i],T[i]);\n\t\tint ans = 0;\n\t\tfor(auto e : es)\n\t\t\tif( uf.unionSet(e[1],e[2]) ){\n\t\t\t\tans += e[0];\n\t\t\t}\n\t\tcout << ans << endl;\n\t}\t\t\n}\n\n\n\nsigned main(){\t\n\tios::sync_with_stdio(false);\n\tlong long Q;\n\tlong long N;\n\tlong long M;\n\tcin >> N;\n\tcin >> M;\n\tvector<long long> c(M-1+1);\n\tvector<long long> b(M-1+1);\n\tvector<long long> a(M-1+1);\n\tfor(int i = 0 ; i <= M-1 ; i++){\n\t\tcin >> a[i];\n\t\tcin >> b[i];\n\t\tcin >> c[i];\n\t}\n\tcin >> Q;\n\tvector<long long> T(Q-1+1);\n\tvector<long long> S(Q-1+1);\n\tfor(int i = 0 ; i <= Q-1 ; i++){\n\t\tcin >> S[i];\n\t\tcin >> T[i];\n\t}\n\tsolve(N, M, a, b, c, Q, S, T);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\n#include <vector>\n#include <list>\n#include<stack>\n#include<queue>\n#include<array>\n\n#include <set>\n#include<map>\n\n#include<string>\n#include<stdlib.h>\n\n#include<algorithm>\n#include <functional>\n#include<math.h>\n\n#include<fstream>\n#include<iomanip>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int,int>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\n\n//変数\n\n\nclass UnionFind {\npublic:\n\tvector<int>rank, parent;\n\t//初期化\n\tUnionFind(int size) {\n\t\trank.resize(size, 0);\n\t\tparent.resize(size, 0);\n\t\tREP(i, size)parent[i] = i;\n\t}\n\t//木の根を求める\n\tint find(int x) {\n\t\tif (parent[x] == x)return x;\n\t\telse return parent[x] = find(parent[x]);\n\t}\n\t//xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])\n\t\t\tparent[x] = y;\n\t\telse {\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t//xとyが同じ集合に属するか否か\n\tbool same(int x, int y) {\n\t\treturn (find(x) == find(y));\n\t}\n};\n\n\nstruct Edge { ll u, v, cost; };\nbool comp(const Edge& r1, const Edge& r2) {\n\treturn r1.cost < r2.cost;\n}\n\nint N, M, Q;\nvector<Edge> edges;\nvector<pair<ll, ll>> st;\n\n//サブ関数\n//入力\nvoid input()\n{\n\tcin >> N >> M;\n\n\tint a, b, c;\n\tREP(i, M) {\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges.push_back({ a,b,c });\n\t}\n\tcin >> Q;\n\tREP(i, Q) {\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tst.push_back({ a,b });\n\t}\n}\n\nvector<Edge> kruskal() {\n\tUnionFind uf(N);\n\tvector<Edge> res;\n\n\tsort(edges.begin(), edges.end(), comp);\n\tfor (auto e : edges) {\n\t\tif (!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tres.push_back(e);\n\t\t}\n\t}\n\treturn res;\n}\n\nll kruskal(vector<Edge> edges) {\n\tUnionFind uf(N);\n\tll res = 0;\n\n\tsort(edges.begin(), edges.end(), comp);\n\tfor (auto e : edges) {\n\t\tif (!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\n//計算\nvoid calc()\n{\n\tauto minimalTree = kruskal();\n\tfor (const auto& p : st) {\n\t\tauto graph = minimalTree;\n\t\tgraph.push_back({ p.first,p.second,0 });\n\t\tcout << kruskal(graph) << endl;\n\t}\n}\n\n\n//出力\nvoid output()\n{\n\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\tinput();\n\tcalc();\n\toutput();\n\tdebug();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Graph2d {\npublic:\n    typedef ll numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nvoid warshall_floyd(Graph2d& g) {\n    int i, j, k;\n    for (i = 0; i < g.n; i++) {\n        for (j = 0; j < g.n; j++) {\n            for (k = 0; k < g.n; k++) {\n                g(j, k) = min(g(j, k), g(j, i) + g(i, k));\n            }\n        }\n    }\n}\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nGraph graph(1);\nvector<vector<ll>> edges;\nll answer[4040][4040];\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer[start][idx] = total - wmax;\n        answer[idx][start] = total - wmax;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    graph_mat.resize(n);\n    graph.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        graph.connect(a, b);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n    \n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        cout << answer[u][v] << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n\t\n\n\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;} cout << endl;\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nstruct edge {\n    int from, to, cost;\n    edge(){}\n    edge(int _from, int _to, int _cost) : from(_from), to(_to), cost(_cost) {}\n    bool operator< (const edge& e) const {\n        return cost == e.cost ? (from == e.from ? to < e.to : from < e.from) : cost < e.cost;\n    }\n};\n\nclass Kruskal {\nprivate:\n    int n;\n    vector<edge> edges;\n    UnionFind uf;\npublic:\n    Kruskal(int _n) : n(_n), uf(_n) {}\n    void addEdge(int _from, int _to, int _cost) {\n        edges.emplace_back(_from, _to, _cost);\n    }\n    pair<int, vector<edge>> calc() {\n        sort(all(edges));\n        int res = 0;\n        vector<edge> selected_edges;\n        rep(i, edges.size()) {\n            if (uf.unite(edges[i].from, edges[i].to)) {\n                res += edges[i].cost;\n                selected_edges.emplace_back(edges[i]);\n            }\n        }\n        return make_pair(res, selected_edges);\n    }\n};\n\n// a.cpp\n\nint ma[4001][4001];\ntypedef vector<vector<Pii>> Graph; // Pii = {to, cost}\n\nvoid dfs(const Graph& G, int s, int now, int pre, int ma_cost) {\n    ma[s][now] = ma_cost;\n    for (auto e : G[now]) {\n        if (e.first == pre) continue;\n        dfs(G, s, e.first, now, max(e.second, ma_cost));\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    Kruskal ks(n);\n    rep(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        ks.addEdge(a, b, c);\n    }\n\n    int cost;\n    vector<edge> edges;\n    tie(cost, edges) = ks.calc();\n\n    Graph G(n);\n    rep(i, edges.size()) {\n        G[edges[i].from].emplace_back(edges[i].to, edges[i].cost);\n        G[edges[i].to].emplace_back(edges[i].from, edges[i].cost);\n    }\n\n    rep(i, n) {\n        dfs(G, i, i, -1, 0);\n    }\n\n    int Q;\n    cin >> Q;\n    rep(i, Q) {\n        int s, t;\n        cin >> s >> t;\n        s--, t--;\n        cout << cost - ma[s][t] << endl;\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 100000000\n\nstruct unionfind{\n\tvector<int> data;\n\tvector<int> size;\n\tunionfind(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdata.push_back(i);\n\t\t\tsize.push_back(1);\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(data[x]==x)return x;\n\t\treturn data[x]=find(data[x]);\n\t}\n\t\n\tbool unite(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return false;\n\t\tdata[x]=y;\n\t\tsize[y]+=size[x];\n\t\treturn true;\n\t}\n\t\n\tbool check(int x,int y){\n\t\treturn (find(x)==find(y));\n\t}\n\t\n\tint get_size(int x){\n\t\tint X = find(x);\n\t\treturn size[X];\n\t}\n};\n\n\nvoid dfs(vector<vector<long long>> &ans,vector<vector<pair<int,long long>>> &E,int now,int parent,int first,long long maxi){\n\t\n\tans[first][now] = maxi;\n\t\n\tfor(int i=0;i<E[now].size();i++){\n\t\tint to = E[now][i].first;\n\t\tlong long c = E[now][i].second;\n\t\tif(to==parent)continue;\n\t\tdfs(ans,E,to,now,first,max(maxi,c));\n\t}\n\t\n}\n\n\nint main(){\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tvector<pair<long long,pair<int,int>>> V;\n\t\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tlong long c;\n\t\tcin>>c;\n\t\t\n\t\tV.emplace_back(c,make_pair(a,b));\n\t}\n\t\n\tvector<vector<pair<int,long long>>> E(N,vector<pair<int,long long>>());\n\tunionfind uf(N);\n\t\n\tsort(V.begin(),V.end());\n\tlong long sum = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint a=V[i].second.first,b=V[i].second.second;\n\t\tlong long cost = V[i].first;\n\t\t\n\t\tif(uf.unite(a,b)){\n\t\t\tsum+=cost;\n\t\t\tE[a].emplace_back(b,cost);\n\t\t\tE[b].emplace_back(a,cost);\n\t\t}\n\t}\n\t\n\tvector<vector<long long>> ans(N,vector<long long>(N,0));\n\t\n\tfor(int i=0;i<N;i++){\n\t\tdfs(ans,E,i,-1,i,0);\n\t}\n\t\n\tint Q;\n\tcin>>Q;\n\t\n\tfor(int i=0;i<Q;i++){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\ts--;t--;\n\t\t\n\t\tcout<<sum - ans[s][t]<<endl;\n\t}\n\t\n\t\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author cherrypi59\n */\n\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"tree-vectorize\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define FFOR(i, a, b) FOR(i, a, b+1)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) FOR(i, 1, n+1)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define LEN(x) (int)(x).size()\n#define DUMP(x) cerr<<__LINE__<<' '<<#x<<\"=\"<<(x)<<endl;\n#define popcnt(x) __builtin_popcount(x)\n#define popcntll(x) __builtin_popcountll(x)\n#define pb push_back\n\nusing namespace std;\nusing lint = long long;\nusing pii =  pair<int, int>;\nusing pll =  pair<lint, lint>;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vector<T>>;\ntemplate <typename T> inline bool chmax(T &a, T b){if(a<b){a = b; return true;} return false;}\ntemplate <typename T> inline bool chmin(T &a, T b){if(a>b){a = b; return true;} return false;}\n\nconstexpr lint ten(int n) {return n==0 ? 1 : ten(n-1)*10;}\n\nclass UnionFind{\nprivate:\n    int n;\n    vector<int> parent, r;\n\n    int _find(int x){\n        assert(x<n);\n        if(parent[x] == x) return x;\n        else return parent[x] = _find(parent[x]);\n    }\n\n    void _unite(int x, int y){\n        x = _find(x); y = _find(y);\n        if(x == y) return;\n        if(r[x]<r[y]){\n            parent[x] = y;\n            r[y] += r[x];\n        }\n        else{\n            parent[y] = x;\n            r[x] += r[y];\n        }\n    }\n\npublic:\n    int find(int x){\n        return _find(x);\n    }\n\n    void unite(int x, int y){\n        _unite(x, y);\n    }\n\n    int count(int x){\n        return r[_find(x)];\n    }\n\n    int operator[](int i){\n        return _find(i);\n    }\n\n    UnionFind() : n(0){}\n\n    explicit UnionFind(size_t _n) : n(_n){\n        parent = vector<int>(n);\n        r = vector<int>(n);\n        for(int i=0;i<n;i++){\n            parent[i] = i;\n            r[i] = 1;\n        }\n    }\n};\n\nstruct edge{\n    int x, y, c;\n    bool operator<(const edge& other){\n        return c < other.c;\n    }\n};\n\nclass A {\npublic:\n    static void marge(vc<int>& v1, vc<int>& v2){\n        if(LEN(v1)<LEN(v2)) swap(v1, v2);\n        for(auto& v : v2) v1.emplace_back(v);\n    }\n\n    void solve(std::istream& in, std::ostream& out){\n        ios_base::sync_with_stdio(false);\n        in.tie(nullptr), out.tie(nullptr);\n        int N, M;\n        in>>N>>M;\n        vc<edge> E(M);\n        for(auto& e : E){\n            in>>e.x>>e.y>>e.c;\n            e.x--, e.y--;\n        }\n        sort(ALL(E));\n        UnionFind uf(N);\n        vvc<int> S(N), f(N, vc<int>(N));\n        REP(i, N) S[i].emplace_back(i);\n        lint cost = 0;\n        for(auto& e : E){\n            int p1 = uf[e.x], p2 = uf[e.y];\n            if(p1!=p2){\n                auto& vec1 = S[p1], vec2 = S[p2];\n                for(auto& u : vec1){\n                    for(auto& v : vec2){\n                        f[u][v] = f[v][u] = e.c;\n                    }\n                }\n                cost += e.c;\n                uf.unite(e.x, e.y);\n                int p = uf[e.x];\n                if(p!=p1) swap(vec1, vec2);\n                marge(vec1, vec2);\n            }\n        }\n        int Q;\n        in>>Q;\n        while(Q--){\n            int s, t;\n            in>>s>>t;\n            s--, t--;\n            out<<cost-f[s][t]<<'\\n';\n        }\n    }\n};\n\n\nint main() {\n\tA solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\nvector<int>E[5000];\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-v[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint dist[4000][4000];\nvector<pair<int, int>> G[4000];\ntuple<int, int, int> es[4000];\n\nvoid dfs(int curr, int par, int start, int max) {\n  dist[curr][start] = max;\n  for(auto const& e: G[curr]) {\n    if(e.first != par) dfs(e.first, curr, start, std::max(max, e.second));\n  }\n};\n\nint main() {\n\n  int N, M; cin >> N >> M;\n\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es[i] = {c, a, b};\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es, es+N);\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  rep(i, N) {\n    dfs(i, -1, i, 0);\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; scanf(\"%d%d\", &s, &t); s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nusing vector2 = vector<vector<T>>;\ntemplate <typename T>\nvector2<T> initVec2(size_t n0, size_t n1, T e = T()){\n    return vector2<T>(n0, vector<T>(n1, e));\n}\n\ntemplate <typename T>\nusing vector3 = vector<vector<vector<T>>>;\ntemplate <typename T>\nvector3<T> initVec3(size_t n0, size_t n1, size_t n2, T e = T()){\n    return vector3<T>(n0, vector2<T>(n1, vector<T>(n2, e)));\n}\n\ntemplate <typename T>\nclass UnionFind{\n    public:\n        int n;\n        vector<T> p, rank;\n\n        UnionFind(int n)\n            : n(n), p(n+1, -1), rank(n+1) {}\n\n        int find(int v){\n            if(p[v] == -1){\n                return v;\n            }\n            p[v] = find(p[v]);\n            return p[v];\n        }\n\n        bool unite(int u, int v){\n            u = find(u);\n            v = find(v);\n\n            if(u == v){\n                return false;\n            }\n\n            if(rank[u] < rank[v]){\n                swap(u, v);\n            }\n\n            if(rank[u] == rank[v]){\n                rank[u]++;\n            }\n\n            p[v] = u;\n            return true;\n        }\n\n        bool same(int u, int v){\n            u = find(u);\n            v = find(v);\n            return u == v;\n        }\n};\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, P>> edge(m);\n    rep(i, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        edge[i] = {c, make_pair(a, b)};\n    }\n    sort(ALL(edge));\n\n    auto graph = initVec2<P>(n + 1, 0);\n    auto used = initVec2<bool>(n + 1, n + 1, false);\n    UnionFind<int> uf(n);\n    int sum = 0;\n    rep(i, m){\n        int u = edge[i].second.first;\n        int v = edge[i].second.second;\n        int w = edge[i].first;\n        if(uf.unite(u, v)){\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n            used[u][v] = used[v][u] = true;\n            sum += w;\n        }\n    }\n\n    auto weight = initVec2<int>(n + 1, n + 1);\n    for(int i = 1; i <= n; i++){\n        stack<tuple<int, int, int>> st;\n        st.emplace(i, 0, 0);\n\n        while(not st.empty()){\n            int v, p, w;\n            tie(v, p, w) = st.top();\n            st.pop();\n\n            weight[i][v] = w;\n\n            for(P pp : graph[v]){\n                int u = pp.first;\n                int we = pp.second;\n                if(u == p){\n                    continue;\n                }\n                st.emplace(u, v, max(w, we));\n            }\n        }\n    }\n\n    int q;\n    cin >> q;\n    rep(i, q){\n        int s, t;\n        cin >> s >> t;\n\n        cout << sum - weight[s][t] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> cld;\nclass disjoint_set {\n  public:\n    int cnt;\n    vector<int> rank, prt, now, lg;\n    disjoint_set(int size) {\n      cnt = size;\n      rank.resize(size);\n      prt.resize(size);\n      now.resize(size);\n      lg.resize(2 * size - 1);\n      lg.resize(2 * size - 1);\n      for (int i = 0; i < size; i++) {\n        prt[i] = i;\n        rank[i] = 0;\n        now[i] = i;\n      }\n    }\n  int find (int x) {\n    if (x == prt[x]) return x;\n    return prt[x] = find(prt[x]);\n  }\n  bool is_equiv (int x, int y) {\n    return find(x) == find(y);\n  }\n  int unite (int x, int y) {\n    x = find(x);\n    y = find(y);\n    lg[now[x]] = lg[now[y]] = cnt;\n    cld[cnt].push_back(now[x]);\n    cld[cnt].push_back(now[y]);\n    now[x] = now[y] = cnt;\n    if (x == y) return false;\n    if (rank[x] > rank[y]) swap(x, y);\n    prt[x] = y;\n    if (rank[x] == rank[y]) rank[y]++;\n    return cnt++;\n  }\n};\nvector<int> dpt;\nvoid dfs (int crr, int d) {\n  dpt[crr] = d;\n  for (int nxt : cld[crr]) {\n    dfs(nxt, d + 1);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, pair<int, int>>> grh(m);\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    grh[i] = {c, {--a, --b}};\n  }\n  sort(grh.begin(), grh.end());\n  int N = 2 * n - 1;\n  cld.resize(N);\n  vector<int> cut(N);\n  disjoint_set djs(n);\n  long long sum = 0;\n  int cnt = 0;\n  for (auto e : grh) {\n    int c = e.first;\n    int a = e.second.first;\n    int b = e.second.second;\n    if (!djs.is_equiv(a, b)) {\n      cut[djs.unite(a, b)] = c;\n      sum += c;\n      cnt++;\n    }\n  }\n  const int PMAX = 20;\n  vector<vector<int>> asc(PMAX, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    asc[0][i] = djs.lg[i];\n  }\n  asc[0][N - 1] = N - 1;\n  for (int p = 1; p < PMAX; p++) {\n    for (int i = 0; i < N; i++) {\n      asc[p][i] = asc[p - 1][asc[p - 1][i]];\n    }\n  }\n  dpt.resize(N);\n  dfs(N - 1, 0);\n  int q;\n  cin >> q;\n  while (q--) {\n    int s, t;\n    cin >> s >> t;\n    if (dpt[--s] > dpt[--t]) swap(s, t);\n    int d = dpt[t] - dpt[s];\n    for (int p = 0; p < PMAX; p++){\n      if (d & 1) {\n        t = asc[p][t];\n      }\n      d >>= 1;\n      if (d == 0) break;\n    }\n    long long ret = sum;\n    for (int p = PMAX - 1; p >= 0; p--) {\n      if (asc[p][s] != asc[p][t]) {\n        s = asc[p][s];\n        t = asc[p][t];\n      }\n    }\n    if (s != t) {\n      s = asc[0][s];\n      t = asc[0][t];\n    }\n    ret -= cut[s];\n    cout << ret << '\\n';\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nll unipar[4010];\nll unilen[4010];\nvector<pll> vn[4010];\nstruct edge{\n  ll len,from,to;\n};\nbool cmp(edge& a,edge& b){\n  return a.len<b.len;\n}\nvoid uniinit(ll n){\n  for(ll i=1;i<=n;i++){\n    unipar[i]=i;\n    unilen[i]=0;\n  }\n}\nll root(ll n){\n  if(unipar[n]==n)return n;\n  return unipar[n]=root(unipar[n]);\n}\nvoid unit(ll a,ll b){\n  a=root(a);\n  b=root(b);\n  if(a==b)return;\n  if(unilen[a]<unilen[b]){\n    unipar[a]=b;\n  }\n  else{\n    unipar[b]=a;\n    if(unipar[b]==unipar[a])unilen[a]++;\n  }\n}\nll ne;\nll par[60][4010];\nll dep[4010];\nvoid lcadfs(ll v,ll p,ll d){\n  par[0][v]=p;\n  dep[v]=d;\n  for(ll i=0;i<vn[v].size();i++){\n    if(vn[v][i].first!=p)lcadfs(vn[v][i].first,v,d+1);\n  }\n}\nvoid lcainit(ll n){\n  lcadfs(ne,-1,0);\n  for(ll i=0;i<59;i++){\n    for(ll j=1;j<=n;j++){\n      if(par[i][j]<0)par[i+1][j]=-1;\n      else par[i+1][j]=par[i][par[i][j]];\n    }\n  }\n}\nll lca(ll u,ll v){\n  if(dep[u]>dep[v])swap(u,v);\n  for(ll i=0;i<60;i++){\n    if((dep[v]-dep[u])>>i&1)v=par[i][v];\n  }\n  if(u==v)return u;\n  for(ll i=59;i>=0;i--){\n    if(par[i][u]!=par[i][v]){\n      u=par[i][u];\n      v=par[i][v];\n    }\n  }\n  return par[0][u];\n}\nll mae[60][4010];\nvoid maedfs(ll v,ll p,ll dis){\n  mae[0][v]=dis;\n  for(ll i=0;i<vn[v].size();i++){\n    if(vn[v][i].first!=p)maedfs(vn[v][i].first,v,vn[v][i].second);\n  }\n}\nvoid maeinit(ll n){\n  maedfs(ne,-1,-1);\n  for(ll i=0;i<59;i++){\n    for(ll j=1;j<=n;j++){\n      if(par[i][j]<0)mae[i+1][j]=-1;\n      else mae[i+1][j]=max(mae[i][j],mae[i][par[i][j]]);\n    }\n  }\n}\nll maxedge(ll u,ll v){\n  ll r=lca(u,v);\n  ll ret=0;\n  for(ll i=59;i>=0;i--){\n    if((dep[u]-dep[r])>>i&1){\n      ret=max(ret,mae[i][u]);\n      u=par[i][u];\n    }\n  }\n  for(ll i=59;i>=0;i--){\n    if((dep[v]-dep[r])>>i&1){\n      ret=max(ret,mae[i][v]);\n      v=par[i][v];\n    }\n  }\n  return ret;\n}\nint main(){\n  ll n,m;cin>>n>>m;\n  vector<edge> v;\n  for(ll i=0;i<m;i++){\n    ll a,b,c;cin>>a>>b>>c;\n    v.push_back((edge){c,a,b});\n  }\n  sort(v.begin(),v.end(),cmp);\n  uniinit(n);\n  ll now=0;\n  ll sum=0;\n  for(ll i=0;i<m;i++){\n    edge e=v[i];\n    ll a=e.from,b=e.to;\n    if(root(a)!=root(b)){\n      unit(a,b);\n      sum+=e.len;\n      vn[a].push_back(make_pair(b,e.len));\n      vn[b].push_back(make_pair(a,e.len));\n      now++;\n    }\n    if(now==n-1)break;\n  }\n  ne=1;\n  lcainit(n);\n  maeinit(n);\n  ll q;cin>>q;\n  for(ll i=0;i<q;i++){\n    ll s,t;cin>>s>>t;\n    ll dd=maxedge(s,t);\n    cout<<sum-dd<<endl;\n  }\n  //cout<<maxedge(5,7)<<endl;\n  //for(ll i=0;i<10;i++){\n    //for(ll j=1;j<=7;j++)cout<<par[i][j]<<\" \";\n    //cout<<endl;\n  //}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    int64_t sum_cost=0;\n    vector<vector<int>> mst(n);\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        mst[e.from].push_back(e.to);\n        mst[e.to].push_back(e.from);\n    }\n\n    int root=0;\n    vector<vector<int>> children(n);\n    function<void(int,int)> dfs=[&](int u,int p){\n        for(int v:mst[u]){\n            if(v==p) continue;\n            children[u].push_back(v);\n            dfs(v,u);\n        }\n    };\n    dfs(root,-1);\n    lca_solver ls(children,root);\n\n    vector<vector<int>> max_cost(20,vector<int>(n));\n    rep(i,0,n){\n        if(i==root) continue;\n        int j=ls.parent_pow2[0][i];\n        max_cost[0][i]=cost[i][j];\n    }\n    rep(i,1,20){\n        rep(j,0,n){\n            if(ls.depth[j]-(1<<i)<0) continue;\n            max_cost[i][j]=max(max_cost[i-1][j],max_cost[i-1][ls.parent_pow2[i-1][j]]);\n        }\n    }\n\n    auto f=[&](int u,int v){\n        int res=0;\n        //rep(i,0,20){\n        for(int i=19; i>=0; --i){\n            if(ls.depth[u]-ls.depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls.parent_pow2[i][u];\n            }\n        }\n        return res;\n    };\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        int u=ls.lca(s,t);\n        cout << sum_cost-max(f(s,u),f(t,u)) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM];\nll mx[MAXN][MAXN];\nbool visited[MAXN];\nvector<P> G[MAXN];\n\nvoid dfs(ll v, ll p, ll m = -1)\n{\n  if(visited[v]) return;\n  mx[p][v] = m;\n  visited[v] = true;\n  for(auto a : G[v]){\n    dfs(a.first, p, max(m, a.second));\n  }\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N >> M;\n  rep(i, M){\n    ll a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    es[i] = edge{a, b, c};\n    G[a].push_back(make_pair(b, c));\n    G[b].push_back(make_pair(a, c));\n  }\n  ll sum = 0;\n  {\n    sort(es, es+M, comp);\n    UnionFind uf(N);\n    uf.initialize();\n    ll cnt = 0;\n    rep(i, M){\n      edge& e = es[i];\n      if(!uf.isSame(e.u, e.v)){\n        uf.merge(e.u, e.v);\n        es[cnt] = edge{e.u, e.v, e.cost};\n        cnt++;\n        sum += e.cost;\n      }\n    }\n  }\n  for(int i=0; i<N; i++){\n    memset(visited, false, sizeof(visited));\n    dfs(i, i);\n  }\n\n  ll Q;\n  cin >> Q;\n  rep(q, Q){\n    ll s, t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum-mx[s][t] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nstruct DisjointSet {\n\t// ２つのグループを１つにまとめる　と　2つの要素が同じグループに所属しているかどうかを判定する\n\tvector<int> rank, p, S; // p->parent  S[findSet(v)] ->連結成分の大きさ\n\tDisjointSet() {}\n\tDisjointSet(int size) {\n\t\tS.resize(size, 1);\n\t\trank.resize(size, 0);\n\t\tp.resize(size, 0);\n\t\trep(i, 0, size) makeSet(i);\n\t}\n\tvoid makeSet(int x) {\n\t\tp[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y) { // 判定する\n\t\treturn findSet(x) == findSet(y);\n\t}\n\tvoid unite(int x, int y) { // 連結するときにはこれを使う\n\t\tif (same(x, y))\n\t\t\treturn;\n\t\tlink(findSet(x), findSet(y));\n\t}\n\tvoid link(int x, int y) {\n\t\tif (rank[x] > rank[y]) {\n\t\t\tp[y] = x;\n\t\t}\n\t\telse {\n\t\t\tp[x] = y;\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\n\t\tS[x] = S[y] = S[x] + S[y];\n\t}\n\tint findSet(int x) {\n\t\tif (x != p[x]) {\n\t\t\tp[x] = findSet(p[x]); // path compression\n\t\t}\n\t\treturn p[x];\n\t}\n\tint connectedComponentSize(int x) { return S[findSet(x)]; }\n};\n\n\n\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<Edge> kruskal(int N, vector<Edge> &edges) {\n\tint totalCost = 0;\n\tsort(all(edges));\n\tDisjointSet dset(N);\n\tvector<Edge>mst;\n\trep(i, 0, edges.size()) {\n\t\tEdge e = edges[i];\n\t\tif (!dset.same(e.s, e.d)) {\n\t\t\tmst.push_back(e);\n\t\t\ttotalCost += e.w;\n\t\t\tdset.unite(e.s, e.d);\n\t\t}\n\t}\n\treturn mst;\n}\n\nstruct Tree { // rooted tree\n\tvector<vector<int>>parent,weight;\n\tGraph g;\n\tint root, V, log2_n;\n\tvector<int> depth;\n\tint get_depth(int x) { return depth[x]; }\n\tvoid dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\trep(i, 0, g[v].size()) {\n\t\t\tif (g[v][i].d != p) {\n\t\t\t\tweight[0][g[v][i].d] = g[v][i].w;\n\t\t\t\tdfs(g[v][i].d, v, d + 1);\n\t\t\t}\n\t\t}\n\t}\n\tTree(Graph G, int root)\n\t\t: root(root), V(G.size()), g(G), depth(V), log2_n(1 + (int)log2(V)) {\n\t\tparent.resize(log2_n, vector<int>(V));\n\t\tweight.resize(log2_n, vector<int>(V));\n\t\tdfs(root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\tif (parent[k][v] < 0) {\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t\tweight[k + 1][v] = weight[k][v];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t\tweight[k + 1][v] = max(weight[k][parent[k][v]], weight[k][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\tint w = -1;\n\t\tif (depth[u] > depth[v])\n\t\t\tswap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tchmax(w, weight[k][v]);\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)\n\t\t\treturn w;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tchmax(w, weight[k][u]);\n\t\t\t\tchmax(w, weight[k][v]);\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n};\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, M; cin >> N >> M;\n\tvector<Edge>edges;\n\trep(i, 0, M) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--, b--;\n\t\tedges.eb(a, b, c);\n\t}\n\tauto mst = kruskal(N,edges);\n\tint sum = 0;\n\tGraph g(N);\n\tfor (auto &e : mst) {\n\t\taddEdge(g, e.s, e.d, e.w);\n\t\tsum += e.w;\n\t}\n\tTree tree(g, 0);\n\n\tint Q; cin >> Q;\n\tloop(Q) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tint u = tree.lca(s, t);\n\t\tcout << sum - u << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,30){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tassert(r[i]-l[i]==1);\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,1)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a){return parent[a]!=a?parent[a]=find(parent[a]):a;}\n\tbool same(int a,int b){return find(a)==find(b);}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b]+=rank[a];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a]+=rank[b];\n\t\t}\n\t\treturn true;\n\t}\n};\nint N,M,Q;\nvector<pair<int,pair<int,int> > >E;\nvector<pair<int,int> >G[4001];\nint T[4001][4001];\nvoid dfs(int u,int p,int now,int f)\n{\n\tT[f][u]=now;\n\tfor(pair<int,int>q:G[u])if(q.first!=p)dfs(q.first,u,max(now,q.second),f);\n}\nmain()\n{\n\tcin>>N>>M;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tE.push_back({c,{a,b}});\n\t}\n\tsort(E.begin(),E.end());\n\tUF uf(N+1);\n\tlong sum=0;\n\tfor(pair<int,pair<int,int> >p:E)\n\t{\n\t\tint u=p.second.first,v=p.second.second;\n\t\tif(uf.unite(u,v))\n\t\t{\n\t\t\tsum+=p.first;\n\t\t\tG[u].push_back({v,p.first});\n\t\t\tG[v].push_back({u,p.first});\n\t\t}\n\t}\n\tfor(int i=0;i++<N;)dfs(i,0,0,i);\n\tcin>>Q;\n\tfor(int i=0;i<Q;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\tcout<<sum-T[a][b]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ull INF = ULLONG_MAX;\nconst ll MOD = 998244353;\n\ntypedef ll Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Graph> Prim(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tGraph T(n);\n\tWeight total = 0;\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-1, r, 0));\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif (visited[e.dst])\n\t\t\tcontinue;\n    if(e.src>=0){\n  \t\tT[e.src].push_back(e);\n      T[e.dst].push_back({e.dst,e.src,e.weight});\n    }\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tfor (Edge f:g[e.dst])\n\t\t\tif (!visited[f.dst])\n\t\t\t\tQ.push(f);\n\t}\n\treturn pair<Weight, Graph>(total, T);\n}\n\n\n\ninline int get_min2pow(int n) {\n\tint res = 1;\n\twhile (res < n)\n\t\tres *= 2;\n\treturn res;\n}\n\n///Segment Tree////////\n\ntemplate<typename T,T dval>\nstruct segtree {\n\tint N;\n\tvector<T> node;\n\t//例外値　ex)INF,0\n\tT default_value = dval;\n\tstatic inline T merge(const T& l, const T& r) {\n\t\t//RMQ\n\t\treturn max(l,r);\n\t\t//RSQ\n\t\t//return l+r;\n\t}\n\tsegtree(int n) {\n\t\tN = get_min2pow(n);\n\t\tnode.resize(2 * N, default_value);\n\t}\n\tsegtree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tN = get_min2pow(sz);\n\t\tnode.resize(2 * N, default_value);\n\t\tfor (int i = 0; i < sz; i++)\n\t\t\tnode[i + N - 1] = v[i];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t\tnode[i] = merge(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\t// update k th element\n\tvoid update(int k, T val) {\n\t\tk += N - 1; // leaf\n\t\tnode[k] = val;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l)\n\t\t\treturn default_value;\n\t\tif (a <= l and r <= b)\n\t\t\treturn node[k];\n\t\tint m = (l + r) / 2;\n\t\tT vl = query(a, b, k * 2 + 1, l, m);\n\t\tT vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn merge(vl, vr);\n\t}\n};\n\n\nstruct HLDecomposition{\n  int V;\n  vint dep,par,heavy,head,id,size,dat;\n  segtree<ll,0> RMQ;\n  HLDecomposition(const Graph &g,int root=0)\n  :V(g.size()),dep(V,0),par(V,-1),heavy(V,-1),head(V),id(V),size(V,1),dat(V,-1),RMQ(V){\n    //make par\n    par[root]=0;\n    vint q(V);\n    int l=0,r=0;\n    q[r++]=root;\n    while(l<r){\n      int v=q[l++];\n      for(const Edge &w:g[v])\n      if(par[w.dst]<0){\n        q[r++]=w.dst;\n        par[w.dst]=v;\n        dat[w.dst]=w.weight;\n        dep[w.dst]=dep[v]+1;\n      }\n    }\n    par[root]=-1;\n    //calculate heavy\n    reverse(q.begin(),q.end());\n    repeat(i,V){\n      int v=q[i];\n      if(par[v]<0)continue;\n      size[par[v]]+=size[v];\n      if(heavy[par[v]]<0||size[v]>size[heavy[par[v]]])heavy[par[v]]=v;\n    }\n    //calculate id\n    int idx=0;\n    repeat(v,V){\n      if(par[v]<0||heavy[par[v]]!=v){\n        for(int w=v;w!=-1;w=heavy[w]){\n          head[w]=v;\n          id[w]=idx++;\n          RMQ.update(id[w],dat[w]);\n        }\n      }\n    }\n  }\n  // [u,v]\n  ll query(int u,int v){\n    ll ret=0;\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]!=head[v]){\n        ret = max(ret,RMQ.query(id[head[v]],id[v]+1));\n        v=par[head[v]];\n      }else{\n        if(u!=v)ret = max(ret,RMQ.query(id[u]+1,id[v]+1));\n        return ret;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]==head[v])return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\nint main(){\n  int N,M;cin>>N>>M;\n  Graph g(N);\n  repeat(i,M){\n    int a,b;\n    Weight c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back({a,b,c});\n    g[b].push_back({b,a,c});\n  }\n  pair<Weight, Graph> tree=Prim(g,0);\n  HLDecomposition hld(tree.second,0);\n  int Q;cin>>Q;\n  repeat(q,Q){\n    int s,t;cin>>s>>t;\n    s--;t--;\n    ll ans=tree.first-hld.query(s,t);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, q;\nint d[4010];\n\nstruct edge{\n   int to, cost;\n//    edge(int to, int cost):to(to), cost(cost){}\n};\nvector<edge> G[4010]; \n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       rep(i, 0, n) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nvector<pair<int, P> > es; \n// vector<int> path;\nint pMAX[4010][4010];\n// int cost[4010][4010];\n\nvoid dfs(int now, int pre, int MAX, int root){\n    // cout << \" \" << now << \" \" << pre << endl;\n    // path[now] = pre;\n    pMAX[root][now] = MAX;\n    // if(now == dest) return;\n    rep(i, 0, G[now].size()){\n        int next = G[now][i].to;\n        if(next == pre) continue;\n        // path[next] = now;       \n        dfs(next, now, max(MAX, G[now][i].cost), root);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    rep(i, 0, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        // G[a].push_back(edge{b, c});\n        // G[b].push_back(edge{a, c});\n        es.push_back(pair<int, P>(c, P(a, b)));\n        // cost[a][b] = c;\n        // cost[b][a] = c;\n    }\n    sort(all(es));\n    UF uf(n);\n    int sum = 0, cnt = 0;\n    rep(i, 0, es.size()){\n        int from = es[i].second.first;\n        int to = es[i].second.second;\n        if(uf.same(from, to) == false){\n            uf.unite(from, to);\n            sum += es[i].first;\n            G[from]. push_back(edge{to, es[i].first});\n            G[to]. push_back(edge{from, es[i].first});\n        }\n    }\n    // cout << sum << endl;\n    rep(i, 0, n){\n        // path.clear(); path.resize(n, -1);\n        dfs(i, -1, 0, i);\n    }\n    cin >> q;\n    rep(i, 0, q){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        // path.clear(); path.resize(n, -1);\n        // dfs(s, -1, t);\n        cout << sum - pMAX[s][t] << endl;\n        // int MAX = 0;\n        // int now = t;\n        // while(now != s){\n        //     int next = path[now];\n        //     chmax(MAX, cost[now][next]);\n        //     now = next;\n        // }\n        // cout << sum - MAX << endl;\n        // rep(j, 0, path.size()){\n        //     cout << path[j] << \" \";\n        // }\n        // cout << endl;\n        // dijkstra(s);\n        // cout << d[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint root[4000];\nint getRoot(int v){ return root[v] == -1 ? v : root[v] = getRoot(root[v]); }\n\nvector<vector<long long>> solve(int N, const vector<pair<int, pair<int,int>>>& edge){\n\tfill(root, root+N, -1);\n\tvector<vector<pair<int,int>>> g(N);\n\tlong long sum = 0;\n\tfor(auto& e : edge){\n\t\tint src = e.second.first;\n\t\tint dst = e.second.second;\n\t\tint p = getRoot(src);\n\t\tint q = getRoot(dst);\n\t\tif(p != q){\n\t\t\tsum += e.first;\n\t\t\troot[q] = p;\n\t\t\tg[src].emplace_back(dst, e.first);\n\t\t\tg[dst].emplace_back(src, e.first);\n\t\t}\n\t}\n\tvector<vector<long long>> res(N, vector<long long>(N, -1));\n\tfor(int i=0;i<N;i++){\n\t\tres[i][i] = 0;\n\t\tqueue<int> qu; qu.push(i);\n\t\twhile(!qu.empty()){\n\t\t\tint pos = qu.front(); qu.pop();\n\t\t\tfor(auto& e : g[pos]){\n\t\t\t\tint dst = e.first;\n\t\t\t\tif(res[i][dst] >= 0) continue;\n\t\t\t\tres[i][dst] = max<long long>(res[i][pos], e.second);\n\t\t\t\tqu.push(dst);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto& v : res){\n\t\tfor(auto& t : v) t = sum - t;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M){\n\t\tvector<pair<int, pair<int, int>>> edge(M);\n\t\tfor(auto& p : edge){\n\t\t\tcin >> p.second.first >> p.second.second >> p.first;\n\t\t\t--p.second.first;\n\t\t\t--p.second.second;\n\t\t}\n\t\tsort(edge.begin(), edge.end());\n\t\tauto res = solve(N, edge);\n\t\tint Q; cin >> Q;\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << res[s-1][t-1] << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    //cin >> a[i],b[i],c[i];\n    scanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n    a[i]--; b[i]--;\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<long long>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  int sz = 13;\n  \n  vector<vector<int>> p(n, vector<int>(sz, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(sz, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<sz; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    //cin >> u,v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n\n    long long sub = 0;\n\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<sz; k++){\n      if( ((depth[v] - depth[u]) >> k) & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=sz-1; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n    if(u!=v){\n      sub = max({sub, mx_e[u][0], mx_e[v][0]});\n    }\n\n    println( mst_cost - sub );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint N,M,Q,S[400010],T[400010];\nll sum = 0,dist[4001][4001],C[400010];\nvector<vector<int>> mst(4010);\nint visited[4010] = {0};\n\nint p[4010] = {0},r[4010] = {0};\nvoid init(int N){\n\tfor(int i=0;i<=N;++i) p[i] = i;\n}\n\nint root(int a){\n\tif(p[a] == a) return a;\n\treturn (p[a] = root(p[a]));\n}\n\nbool is_same_set(int a,int b){\n\treturn root(a) == root(b);\n}\n\nvoid unite(int a, int b){\n\ta = root(a);\n\tb = root(b);\n\tif(a==b) return;\n\tif(r[a]<r[b]){\n\t\tp[a] = b;\n\t}else{\n\t\tp[b] = a;\n\t\tif(r[a] == r[b]) r[a]++;\n\t}\n}\n\nvoid dfs(int s,int n,ll cost){\n\tvisited[n] = 1;\n\tfor(int i=0;i<mst[n].size();i++){\n\t\tint t = mst[n][i];\n\t\tif(visited[t]==0){\n\t\t\tll ma = max(cost,dist[n][t]);\n\t\t\tdist[s][t] = ma;\n\t\t\tdist[t][s] = ma;\n\t\t\tdfs(s,t,ma);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N >> M;\n\tinit(N);\n\tvector<pair<ll,int>> v;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> S[i] >> T[i] >> C[i];\n\t\tdist[S[i]][T[i]] = C[i];\n\t\tdist[T[i]][S[i]] = C[i];\n\t\tv.push_back({C[i],i});\n\t}\n\tsort(v.begin(),v.end());\n\tfor(int i=0;i<v.size();i++){\n\t\tint t = v[i].second;\n\t\tif(!is_same_set(S[t],T[t])){\n\t\t\tsum += C[t];\n\t\t\tunite(S[t],T[t]);\n\t\t\tmst[S[t]].push_back(T[t]);\n\t\t\tmst[T[t]].push_back(S[t]);\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tdfs(i,i,0);\n\t\tfor(int j=1;j<=N;j++) visited[j] = 0;\n\t}\n\tcin >> Q;\n\tint a,b;\n\tfor(int i=0;i<Q;i++){\n\t\tcin >> a >> b;\n\t\tcout << sum-dist[a][b] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<int>> tree(N);\n\tUnionFindTree uf(N);\n\tif(!N){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tusing t = pair<int,pair<int,int>>;\n\tpriority_queue<t,vector<t>,greater<>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tint c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth();\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<int> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint UF[4100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\npair<int,pair<int,int> > edge[410000];\nvector<pair<int,pair<int,int> > >v;\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tp--;q--;\n\t\tedge[i]=make_pair(r,make_pair(p,q));\n\t}\n\tstd::sort(edge,edge+b);\n\tfor(int i=0;i<a;i++)UF[i]=-1;\n\tfor(int i=0;i<b;i++){\n\t\tif(FIND(edge[i].second.first)==FIND(edge[i].second.second))continue;\n\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\tv.push_back(edge[i]);\n\t}\n\tint c;scanf(\"%d\",&c);\n\twhile(c--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);x--;y--;\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tUNION(x,y);\n\t\tlong long ret=0;\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(FIND(v[i].second.first)==FIND(v[i].second.second))continue;\n\t\t\tret+=v[i].first;\n\t\t\tUNION(v[i].second.first,v[i].second.second);\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\nreturn ret;\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n//OK\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n//OK\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\n//RE\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct UF {\n\tvector<int> par, ran;\n\tvoid init(int n) {\n\t\tpar.resize(n); ran.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tUF(int mx = 0) { init(mx); }\n\n\tint find(int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\n//////////////\n\nint N, M, E;\nstruct edge { int u, v, cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nedge es[100010];\nvector<pi> G[MAX_N];\nint depth[MAX_N];\nint par[MAX_N];\nint cost[MAX_N];\n\nint kruskal() {\n\tsort(es, es + E, comp);\n\tUF uf(N);//init union_find\n\tint res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tG[e.u].pb(pi(e.v, e.cost));\n\t\t\tG[e.v].pb(pi(e.u, e.cost));\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid add_edge(int s, int t, int cost) {\n\tes[E++] = edge{s, t, cost};\n}\n\nvoid loop(int v, int p, int k) {\n\tdepth[v] = k;\n\tpar[v] = p;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst;\n\t\tif(n == p) continue;\n\t\tcost[n] = G[v][i].sec;\n\t\tloop(n, v, k + 1);\n\t}\n}\n\nvoid solve() {\n\tE = 0;\n\tcin >> N >> M;\n\trep(i, 0, M) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c; a--; b--;\n\t\tadd_edge(a, b, c);\n\t}\n\tll S = kruskal();\n\tloop(0, -1, 0);\n\tint Q; cin >> Q;\n\twhile(Q--) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tif(depth[a] < depth[b]) swap(a, b);\n\t\tint mv = -1;\n\t\twhile(depth[a] > depth[b]) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\ta = par[a];\n\t\t}\n\t\t// debug(depth[a], depth[b], a, b);\n\t\twhile(a != b) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\tMAX(mv, cost[b]);\n\t\t\ta = par[a]; b = par[b];\n\t\t}\n\t\tcout << S - mv << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<int>> tree(N);\n\tUnionFindTree uf(N);\n\tif(!N){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tpriority_queue<pair<int,pair<int,int>>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tint c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth();\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<int> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<ll>> tree(N);\n\tUnionFindTree uf(N);\n\tif(N==1){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tusing t = pair<ll,pair<int,int>>;\n\tpriority_queue<t,vector<t>,greater<>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tll c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth();\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<int> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\nstruct edge{\n  Int from,to,cost,used;\n  edge(){}\n  edge(Int from,Int to,Int cost):from(from),to(to),cost(cost),used(0){}\n  bool operator<(const edge& e) const{\n    return cost<e.cost;\n  }\n};\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  void add_edge(Int u,Int v,Int c){\n    edges.push_back(edge(u,v,c));\n  }\n\n  void input(Int m,Int offset=0){\n    Int a,b,c;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      add_edge(a+offset,b+offset,c);\n    }\n  }\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\te.used=1;\n      }\n    }\n    return res;\n  }\n};\n\n\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  Kruskal k(n);\n  k.input(m,-1);\n  k.build();\n  auto es=k.edges;\n  es.erase(remove_if(es.begin(),es.end(),[](edge e){return !e.used;}),es.end());\n  //cout<<es.size()<<endl;\n  //for(auto e:es) cout<<e.used<<endl;\n  Int q;\n  cin>>q;\n  if(q>3000) exit(1);\n  for(Int i=0;i<q;i++){\n    Int s,t;\n    cin>>s>>t;\n    s--;t--;\n    Kruskal p(n);\n    p.edges=es;\n    p.add_edge(s,t,0);\n    cout<<p.build()<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nstruct LowestCommonAncestorTreeMax {\n        const int LOGM = 30;\n        vector<int> depth, par_w;\n        vector<vector<int>> parent, parmax;\n        LowestCommonAncestorTreeMax(int root, const vector<vector<pair<int, int>>> &g) {\n                int n = g.size();\n                depth.resize(n);\n                par_w.resize(n);\n                parent.resize(LOGM);\n                parmax.resize(LOGM);\n                for (int i = 0; i < LOGM; i ++) { \n                        parent[i].resize(n);\n                        parmax[i].resize(n);\n                }\n                function<void (int, int, int)> dfs = [&](int u, int prev, int d) {\n                        parent[0][u] = prev;\n                        parmax[0][u] = par_w[u];\n                        depth[u] = d;\n                        for (auto e : g[u]) { \n                                int v = e.first;\n                                if (v != prev) { \n                                        par_w[v] = e.second;\n                                        dfs(v, u, d + 1);\n                                }\n                        }\n                };\n                dfs(root, -1, 0);\n                for (int k = 0; k < LOGM - 1; k ++) {\n                        for (int i = 0; i < n; i ++) {\n                                if (parent[k][i] < 0) { \n                                        parent[k + 1][i] = -1;\n                                } else { \n                                        parent[k + 1][i] = parent[k][parent[k][i]];\n                                        if (parent[k + 1][i] >= 0) {\n                                                parmax[k + 1][i] = max(parmax[k][i], parmax[k][parent[k][i]]);\n                                        }\n                                }\n                        }\n                }\n        }\n        int lca(int u, int v) { \n                if (depth[u] > depth[v]) swap(u, v);\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((depth[v] - depth[u]) >> k & 1) { \n                                v = parent[k][v];\n                        }\n                }\n                if (u == v) return u;\n                for (int k = LOGM - 1; k >= 0; k --) {\n                        if (parent[k][u] != parent[k][v]) {\n                                u = parent[k][u];\n                                v = parent[k][v];\n                        }\n                }\n                return parent[0][u];\n        }\n        int dist(int u, int v) {\n                return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n        }\n        int getmax(int v, int ancestor) {\n                int res = 0;\n                int d = depth[v] - depth[ancestor];\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((d >> k) & 1) {\n                                res = max(res, parmax[k][v]);\n                                v = parent[k][v];\n                        }\n                }\n                return res;\n        }\n};\n\nstruct edge {\n    int a, b, c;\n};\n\nvi par;\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return true;\n    par[x] = y;\n    return false;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int n, m;\n    cin >> n >> m;\n    vector<edge> edges;\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.push_back({a - 1, b - 1, c});\n    }\n\n    sort(edges.begin(), edges.end(), [](edge a, edge b) {return a.c < b.c;});\n    par = vi(n + 1);\n    iota(par.begin(), par.end(), 0);\n\n    unordered_set<int> ns;\n\n    vector<vector<pair<int, int>>> adj(n);\n    i64 sum = 0;\n    for (int i = 0; i < m && ns.size() < n; i++) {\n        int x = edges[i].a, y = edges[i].b;\n        if (!unite(x, y)) {\n            ns.insert(x);\n            ns.insert(y);\n            adj[x].push_back(make_pair(y, edges[i].c));\n            adj[y].push_back(make_pair(x, edges[i].c));\n            sum += edges[i].c;\n        }\n    }\n\n    LowestCommonAncestorTreeMax tree(0, adj);\n    auto maxw = [&](int s, int t) {\n        int lca = tree.lca(s, t);\n        return max(tree.getmax(s, lca), tree.getmax(t, lca));\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        cout << sum - maxw(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tassert(r[i]-l[i]==1);\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<tuple<int, int, int>> es;\n  vector<vector<pair<int, int>>> G(N);\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es.emplace_back(c, a, b);\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es.begin(), es.end());\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  static int dist[4000][4000];\n  std::function<void(int, int, int, int)> dfs = [&](int curr, int par, int start, int max) {\n    dist[curr][start] = max;\n    for(auto const& e: G[curr]) {\n      if(e.first != par) dfs(e.first, curr, start, std::max(max, e.second));\n    }\n  };\n\n  rep(i, N) {\n    dfs(i, -1, i, 0);\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; scanf(\"%d%d\", &s, &t); s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nint ctoi(char c) {\n\tswitch (c) {\n\tcase '0': return 0;\n\tcase '1': return 1;\n\tcase '2': return 2;\n\tcase '3': return 3;\n\tcase '4': return 4;\n\tcase '5': return 5;\n\tcase '6': return 6;\n\tcase '7': return 7;\n\tcase '8': return 8;\n\tcase '9': return 9;\n\tdefault: return -1;\n\t}\n}\n\nchar S[5];\nint K;\n\nint main(){\nscanf(\"%d\",&K);\nscanf(\"%s\",&S);\nif(K!=0){\n\nif(strlen(S)==2){\nif(ctoi(S[0])>=ctoi(S[1])){printf(\"%d¥n\",ctoi(S[0]));}\nelse{printf(\"%d¥n\",ctoi(S[1]));}\n}\nelse{printf(\"%d¥n\",ctoi(S[0]));}\n\n}\nelse{printf(\"%s¥n\",S);}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconstexpr double EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr int MOD = 1e9+7;\n\nstruct Edge{\n    int from, to;\n    ll cost;\n    Edge(int from,int to,ll cost): from(from),to(to), cost(cost){}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool operator < (const Edge &e, const Edge &f){\n    return e.cost > f.cost;\n}\n\nstruct UF {\n\tvector<int> data;\n\tUF(int size) : data(size, -1) { }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;cin>>n>>m;\n    Graph g(n);\n    priority_queue<Edge> pq;\n    for(int i=0;i<m;i++){\n      int a,b;cin>>a>>b;a--;b--;\n      ll c;cin>>c;\n      pq.push(Edge(a,b,c));\n      g[a].push_back(Edge(a,b,c));\n      g[b].push_back(Edge(b,a,c));\n    }\n    ll sum=0;\n    UF uf(n);\n    Graph mst(n);\n    while(!pq.empty()){\n      Edge e=pq.top();pq.pop();\n      if(uf.find(e.from,e.to)) continue;\n      uf.unite(e.from,e.to);\n      mst[e.from].push_back(Edge(e.from,e.to,e.cost));\n      mst[e.to].push_back(Edge(e.to,e.from,e.cost));\n      sum += e.cost;\n    }\n    vector<vector<ll>> dis(n,vector<ll>(n,-1));\n    for(int i=0;i<n;i++){\n      queue<int> q;\n      dis[i][i]=0;\n      q.push(i);\n      while(!q.empty()){\n        int v=q.front();q.pop();\n        for(int j=0;j<(int)mst[v].size();j++){\n          int next=mst[v][j].to;\n          if(dis[i][next]!=-1) continue;\n          dis[i][next]=max(dis[i][v], mst[v][j].cost);\n          q.push(next);\n        }\n      }\n    }\n    int q;cin>>q;\n    for(int i=0;i<q;i++){\n      int s,t;cin>>s>>t;s--;t--;\n      cout<<sum-dis[s][t]<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//「何らかの全域木からS--Tパス上の辺を取り除いたもの」を考えればよく、実は「MST - (S--Tパス上の最大コストの辺)」が答えになりそう。\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nstruct UF {\n\tint par[4000];\n\tUF() { for (int i = 0; i < 4000; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid unit(int x, int y) { x = root(x); y = root(y); par[x] = y; }\n\tbool isSame(int x, int y) { return root(x) == root(y); }\n};\n\nstruct Edge {\n\tint from, to, cost;\n\tEdge(int from, int to, int cost) { this->from = from; this->to = to; this->cost = cost; }\n\tEdge() {}\n\tbool operator<(const Edge &r) const { return cost < r.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint n, m, q;\nEdges edges;\nUF uf;\nGraph mst;\nint parents[20][4000];\nint depth[4000];\nint maxScores[20][4000];\n\nvoid dfs(int p, int v, int ecost, int dep) {\n\tparents[0][v] = p;\n\tdepth[v] = dep;\n\tmaxScores[0][v] = ecost;\n\t\n\tfor (int i = 0; i < mst[v].size(); i++) {\n\t\tint nv = mst[v][i].to;\n\t\tif (nv == p) continue;\n\t\tdfs(v, nv, mst[v][i].cost, dep + 1);\n\t}\n}\n\nint maxPath(int u, int v) {\n\tint ret = 0, i;\n\t\n\tif (depth[u] > depth[v]) swap(u, v);\n\tif (depth[v] > depth[u]) {\n\t\tint d = depth[v] - depth[u];\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((d >> i) & 1) {\n\t\t\t\tret = max(ret, maxScores[i][v]);\n\t\t\t\tv = parents[i][v];\n\t\t\t}\n\t\t}\n\t}\n\tif (u == v) { return ret; }\n\tif (parents[0][u] == parents[0][v]) {\n\t\tint res = max(maxScores[0][u], maxScores[0][v]);\n\t\treturn max(ret, res);\n\t}\n\t\n\tfor (i = 19; i > 0; i--) {\n\t\tif (parents[i][u] != parents[i][v]) break;\n\t}\n\tint res1 = maxPath(parents[i][u], parents[i][v]);\n\tint res2 = max(maxScores[i][u], maxScores[i][v]);\n\tint res = max(res1, res2);\n\treturn max(ret, res);\n}\n\nsigned main() {\n\tint i, j;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges.push_back(Edge(a, b, c));\n\t}\n\tsort(edges.begin(), edges.end());\n\t\n\tint mstCost = 0;\n\tmst.resize(n);\n\tfor (i = 0; i < edges.size(); i++) {\n\t\tint u = edges[i].from;\n\t\tint v = edges[i].to;\n\t\t\n\t\tif (!uf.isSame(u, v)) {\n\t\t\tuf.unit(u, v);\n\t\t\tmstCost += edges[i].cost;\n\t\t\tmst[u].push_back(Edge(u, v, edges[i].cost));\n\t\t\tmst[v].push_back(Edge(v, u, edges[i].cost));\n\t\t}\n\t}\n\t\n\tdfs(0, 0, 0, 0);\n\tfor (i = 1; i < 20; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tparents[i][j] = parents[i - 1][parents[i - 1][j]];\n\t\t\tmaxScores[i][j] = max(maxScores[i - 1][j], maxScores[i - 1][parents[i - 1][j]]);\n\t\t}\n\t}\n\t\n\tcin >> q;\n\tfor (i = 0; i < q; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t; s--; t--;\n\t\tif (n <= 2) { cout << 0 << endl; continue; }\n\t\tint res = maxPath(s, t);\n\t\tcout << mstCost - res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a) for(int i=0;i<(a);i++)\nconst ll MOD=1000000007;\n\nconst int MAX_V=4040;\nstruct edge {int to,cost;};\nvector<vector<edge>> G(MAX_V);\nvector<tuple<int,int,int> > E;\nint N,M;\n\nint par[MAX_V]; //　親\nint rnk[MAX_V]; // rank, 木の深さ\n\n// V要素で初期化\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    par[i]=i;\n    rnk[i]=0;\n  }\n}\n\n// 木の根を求める\nint find(int x){\n  if (par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\n// ｘとｙの属する集合を併合\nvoid unite(int x, int y){\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n\n  if (rnk[x] < rnk[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if (rnk[x] == rnk[y]) rnk[x]++;\n  }\n}\n\n// ｘとｙが同じ集合に属するかどうか\nbool same(int x, int y){\n  return find(x) == find(y);\n}\n\nint maxE[4040][4040];\n\nint main(){\n  cin>>N>>M;\n  rep(i,M){\n    int a,b,c; cin>>a>>b>>c; a--,b--;\n    E.push_back(make_tuple(c,a,b));\n  }\n  sort(E.begin(),E.end());\n  init();\n  ll sum=0;\n  rep(i,M){\n    tuple<int,int,int> t=E[i];\n    int c=get<0>(t),a=get<1>(t),b=get<2>(t);\n    if(!same(a,b)){\n      unite(a,b);\n      G[a].push_back({b,c});\n      G[b].push_back({a,c});\n      sum+=c;\n    }\n  }\n  rep(s,N){\n    queue<tuple<int,int,int> > que;\n    que.push(make_tuple(s,-1,0));\n    while(que.size()){\n      tuple<int,int,int> t=que.front(); que.pop();\n      int v=get<0>(t), p=get<1>(t), ma=get<2>(t);\n      for(auto e:G[v]) if(e.to!=p){\n        if(e.cost>ma) ma=e.cost;\n        maxE[s][e.to]=ma;\n        que.push(make_tuple(e.to,v,ma));\n      }\n    }\n  }\n  int Q; cin>>Q;\n  rep(i,Q){\n    int s,t; cin>>s>>t; s--,t--;\n    cout<<sum-maxE[s][t]<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define N 4010\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> >PP;\n\nll primsum=0;\nvector<P> v[N],u[N];\npriority_queue<PP,vector<PP>,greater<PP> >Q;\nvoid Qpush(int cost,int now,int from){\n    Q.push(make_pair(cost,make_pair(now,from)));\n}\nvoid Prim(){\n    bool vis[N]={0};\n    Qpush(0,0,-1);\n    while(!Q.empty()){\n\tint cost=Q.top().first;\n\tint x=Q.top().second.first;\n\tint from=Q.top().second.second;\n\tQ.pop();\n\tif(vis[x]==true)continue;\n\tvis[x]=true;\n\tif(from!=-1){\n\t    u[x].push_back(make_pair(cost,from));\n\t    u[from].push_back(make_pair(cost,x));\n\t    primsum+=cost;\n\t}\n\tlol(i,v[x].size()){\n\t    if(v[x][i].second==from)continue;\n\t    Qpush(v[x][i].first,v[x][i].second,x);\n\t}\n    }\n}\n\nll ans[N][N];\nvoid DFS(int x,int maxi,int root,int from){\n    ans[root][x]=maxi;\n    lol(i,u[x].size()){\n\tif(u[x][i].second==from)continue;\n\tint cost=u[x][i].first;\n\tDFS(u[x][i].second,max(maxi,cost),root,x);\n    }\n}\n\nint main(){\n    int n,m,q;cin>>n>>m;\n    lol(i,m){\n\tint a,b,c;cin>>a>>b>>c;a--,b--;\n\tv[a].push_back(make_pair(c,b));\n\tv[b].push_back(make_pair(c,a));\n    }\n    Prim();\n    lol(i,n)DFS(i,0,i,-1);\n    cin>>q;\n    lol(i,q){\n\tint a,b;cin>>a>>b;a--,b--;\n\tcout<<primsum-ans[a][b]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    int q;\n    cin >> q;\n    if(int64_t(m)*q>10000000) return;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        union_find uf(n);\n        uf.unite(s,t);\n        int64_t sum=0;\n        for(edge &edge:edges){\n            int a=edge.from,b=edge.to;\n            if(uf.is_same_group(a,b)) continue;\n            uf.unite(a,b);\n            sum+=edge.cost;\n        }\n        cout << sum << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,M, ans[100000], par[4001];\nset<int> Z[4001];\nvi v[4001];\n\nint main() {\n    setIO();  re(N,M);\n    vector<pair<int,pi>> ed;\n    F0R(i,M) {\n        int a,b,c; re(a,b,c);\n        ed.pb({c,{a,b}});\n    }\n    sort(all(ed));\n    int Q; re(Q);\n    F0R(i,Q) {\n        int S,T; re(S,T);\n        Z[S].insert(i), Z[T].insert(i);\n    }\n    FOR(i,1,N+1) {\n        par[i] = i;\n        v[i].pb(i);\n    }\n    ll ret = 0;\n    trav(t,ed) {\n        t.s.f = par[t.s.f], t.s.s = par[t.s.s];\n        if (t.s.f == t.s.s) continue;\n        if (sz(v[t.s.f]) < sz(v[t.s.s])) swap(t.s.f,t.s.s);\n        trav(x,v[t.s.s]) {\n            par[x] = t.s.f;\n            v[t.s.f].pb(x);\n        }\n        trav(x,Z[t.s.s]) {\n            if (Z[t.s.f].count(x)) {\n                Z[t.s.f].erase(x);\n                ans[x] = t.f;\n            } else Z[t.s.f].insert(x);\n        }\n        v[t.s.s].clear();\n        ret += t.f;\n    }\n    F0R(i,Q) ps(ret-ans[i]);\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 5000;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    tuple<ll, int, int> edges[M];\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = mt(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    vector<pair<int, ll>> path[N];\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    ll emax[N][N];\n    // emax[i][j] = iからjのパス上で最大コストの辺のコスト\n\n    for (int r = 0; r < N; ++r) {\n        fill(emax[r], emax[r] + N, -1);\n        emax[r][r] = 0;\n        queue<int> que;\n        que.push(r);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n\n            for (auto p : path[v]) {\n                int sv;\n                ll cost;\n                tie(sv, cost) = p;\n\n                if (emax[r][sv] >= 0) continue;\n                emax[r][sv] = max(emax[r][v], cost);\n                que.push(sv);\n            }\n        }\n    }\n\n    // クエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        cout << total - emax[--s][--t] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\ntemplate<typename T, typename S>\nistream& operator >> (istream& is, pair<T, S>& p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v) {\n    for (auto& x : v) {\n        is >> x;\n    }\n    return is;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& v) {\n    for (auto& x : v) {\n        os << x << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\n\nvector<int> BuildSuffArray(const string& S) {\n    const int LEN = S.size();\n    const int ALPHABET = 11;\n\n    vector<int> p(LEN), cnt(ALPHABET, 0), c(LEN);\n    for (auto c : S) cnt[int(c) + 1 - int('0')]++;\n    for (int i = 1; i < ALPHABET; ++i) cnt[i] += cnt[i - 1];\n    for (int i = 0; i < LEN; ++i) p[--cnt[int(S[i]) + 1 - int('0')]] = i;\n    c[p[0]] = 0;\n    int classes = 1;\n    for (int i=1; i<LEN; ++i) {\n        if (S[p[i]] != S[p[i-1]])  ++classes;\n        c[p[i]] = classes-1;\n    }\n    // cout << p;\n\n    vector<int> pn(LEN), cn(LEN);\n    for (int h=0; (1<<h)<LEN; ++h) {\n        for (int i=0; i<LEN; ++i) {\n            pn[i] = p[i] - (1<<h);\n            if (pn[i] < 0)  pn[i] += LEN;\n        }\n        cnt.assign(classes, 0);\n        for (int i=0; i<LEN; ++i)\n            ++cnt[c[pn[i]]];\n        for (int i=1; i<classes; ++i)\n            cnt[i] += cnt[i-1];\n        for (int i=LEN-1; i>=0; --i)\n            p[--cnt[c[pn[i]]]] = pn[i];\n        cn[p[0]] = 0;\n        classes = 1;\n        for (int i=1; i<LEN; ++i) {\n            int mid1 = (p[i] + (1<<h)) % LEN,  mid2 = (p[i-1] + (1<<h)) % LEN;\n            if (c[p[i]] != c[p[i-1]] || c[mid1] != c[mid2])\n                ++classes;\n            cn[p[i]] = classes-1;\n        }\n        c = cn;\n        // cout << p;\n    }\n    // cout << endl;\n    return p;\n}\n\nint MinParts(const string& S, const vector<int>& pos, const int L, const int max_pos) {\n    // cout << max_pos << \"!\\n\";\n    int N = S.size() - 1;\n\n    int cur_idx = 0;\n    int num_parts = 0;\n    while (cur_idx < N && num_parts <= N) {\n        // cout << cur_idx << \" \" << pos[cur_idx] << \" \";\n        if (pos[cur_idx] <= max_pos) {\n            // cout << L << \"\\n\";\n            cur_idx += L;\n        } else {\n            // cout << L - 1 << \"\\n\";\n            cur_idx += L - 1;\n        }\n        ++num_parts;\n    }\n    // cout << num_parts << \"!!\\n\";\n    return num_parts;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); \n    cin.tie(NULL);\n\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n    int K;\n    string S;\n    cin >> K >> S;\n    int N = S.size();\n    int L = (N + K) / (K + 1);\n\n    S.push_back('0' - 1);\n    auto order = BuildSuffArray(S);\n\n    vector<int> pos(N + 1);\n    for (int i = 0; i <= N; ++i) pos[order[i]] = i;\n\n    int l = 0, r = N;\n    while (r - l > 1) {\n        int t = (r + l) / 2;\n        if (MinParts(S, pos, L, t) <= K + 1) {\n            r = t;\n        } else {\n            l = t;\n        }\n    }\n    int ans_st = order[r];\n    for (int i = ans_st; i < ans_st + L; ++i) {\n        if (i < N) \n            cout << S[i];\n        else \n            cout << '0';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass Graph2d {\npublic:\n    typedef ll numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nvoid warshall_floyd(Graph2d& g) {\n    int i, j, k;\n    for (i = 0; i < g.n; i++) {\n        for (j = 0; j < g.n; j++) {\n            for (k = 0; k < g.n; k++) {\n                g(j, k) = min(g(j, k), g(j, i) + g(i, k));\n            }\n        }\n    }\n}\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nvector<vector<ll>> edges;\nvector<vector<ll>> answer;\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    vector<int> cycle_detector(n);\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer[start][idx] = total - wmax;\n        answer[idx][start] = total - wmax;\n        assert(!cycle_detector[idx]);\n        cycle_detector[idx] = 1;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        fill(ALL(cycle_detector), 0);\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    answer.resize(n);\n    for (auto&v : answer)\n        v.resize(n);\n\n    graph_mat.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n\n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        printer << answer[u][v] << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,30){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tassert(r[i]-l[i]<=1);\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define nyan \"(=^・ω・^=)\"\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007;\nconst int mod998 = 998244353;\n\nint N, M, a, b, c, Q, s, t, uf[4000], d[4000][2][15], R[4000];\nll res;\nvector<pair<int, int>>v[4000];\npriority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\n\nint Top(int x) {\n\tif (uf[x] < 0)return x;\n\telse return uf[x] = Top(uf[x]);\n}\n\nbool Uni(int x, int y) {\n\tx = Top(x);\n\ty = Top(y);\n\tif (x == y)return false;\n\tif (uf[x] < uf[y]) {\n\t\tuf[x] += uf[y];\n\t\tuf[y] = x;\n\t}\n\telse {\n\t\tuf[y] += uf[x];\n\t\tuf[x] = y;\n\t}\n\treturn true;\n}\n\nvoid dfs(int x) {\n\tfor (auto i : v[x]) {\n\t\tif (!R[i.second]) {\n\t\t\tR[i.second] = R[x] + 1;\n\t\t\td[i.second][0][0] = i.first;\n\t\t\td[i.second][1][0] = x;\n\t\t\tdfs(i.second);\n\t\t}\n\t}\n}\n\nint calc(int x, int y) {\n\tint MAX = -1;\n\tif (R[x] < R[y]) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (R[y] - (1 << i) >= R[x]) {\n\t\t\t\tMAX = max(MAX, d[y][0][i]);\n\t\t\t\ty = d[y][1][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (R[x] > R[y]) {\n\t\tfor (int i = 14; i >= 0; --i) {\n\t\t\tif (R[x] - (1 << i) >= R[y]) {\n\t\t\t\tMAX = max(MAX, d[x][0][i]);\n\t\t\t\tx = d[x][1][i];\n\t\t\t}\n\t\t}\n\t}\n\tif (x == y)return MAX;\n\tfor (int i = 14; i >= 0; --i) {\n\t\tif (d[x][1][i] != d[y][1][i]) {\n\t\t\tMAX = max({ MAX,d[x][0][i],d[y][0][i] });\n\t\t\tx = d[x][1][i];\n\t\t\ty = d[y][1][i];\n\t\t}\n\t}\n\tMAX = max({ MAX,d[x][0][0],d[y][0][0] });\n\treturn MAX;\n}\n\nint main() {\n\tcin >> N >> M;\n\twhile (M--) {\n\t\tcin >> a >> b >> c;\n\t\tq.push(mkp(c, mkp(a - 1, b - 1)));\n\t}\n\tmemset(uf, -1, sizeof uf);\n\twhile (!q.empty()) {\n\t\ta = q.top().second.first;\n\t\tb = q.top().second.second;\n\t\tc = q.top().first;\n\t\tq.pop();\n\t\tif (Uni(a, b)) {\n\t\t\tv[a].push_back(mkp(c, b));\n\t\t\tv[b].push_back(mkp(c, a));\n\t\t\tres += c;\n\t\t}\n\t}\n\tR[0] = 1;\n\tdfs(0);\n\tfor (int i = 1; i < 15; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\td[j][0][i] = max(d[j][0][i - 1], d[d[j][1][i - 1]][0][i]);\n\t\t\td[j][1][i] = d[d[j][1][i - 1]][1][i];\n\t\t}\n\t}\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> s >> t;\n\t\tcout << res - calc(s - 1, t - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF      1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nstruct UF{\n\tint par[4000];\n\tint rank[4000];\n\tint si[4000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\nint n, m, k;\nbool saw[4000];\nll sum = 0;\nvector<PP> e;\nvector<P> ee[4000];\nll par[30][4000];\nll cnt[30][4000];\nll dep[4000];\n\nll lca(int s, int t){\n    ll ret = 0;\n    if(dep[s] > dep[t]){\n        ll dif = dep[s]-dep[t];\n        for(int i = 0;;i++){\n            if(dif == 0) break;\n            if(dif&1){\n                ret = max(ret,cnt[i][t]);\n                t = par[i][t];\n            }\n            dif /= 2;\n        }\n    }\n    if(dep[s] < dep[t]){\n        ll dif = dep[t]-dep[s];\n        for(int i = 0;;i++){\n            if(dif==0)break;\n            if(dif&1){\n                ret = max(ret,cnt[i][s]);\n                s = par[i][s];\n            }\n            dif /= 2;\n        }\n    }\n    if(s == t){\n        return ret;\n    }\n    for(int i = 29; i >= 0; i--){\n        if(par[i][s] == par[i][t]) continue;\n        ret = max(ret,cnt[i][t]);\n        ret = max(ret,cnt[i][s]);\n        s = par[i][s];\n        t = par[i][t];\n    }\n    ret = max(ret,cnt[0][t]);\n    ret = max(ret,cnt[0][s]);\n    return ret;\n}\n\nvoid dfs(int v){\n    saw[v] = true;\n    rep(i,ee[v].size()){\n        if(saw[ee[v][i].first]) continue;\n        dep[ee[v][i].first] = dep[v]+1;\n        dfs(ee[v][i].first);\n        par[0][ee[v][i].first] = v;\n        cnt[0][ee[v][i].first] = ee[v][i].second;\n    }\n}\n\nint main(){\n    cin >> n >> m;\n    uf.init(n);\n    rep(i,m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        e.push_back(PP(c,P(a,b)));\n    }\n    sort(e.begin(),e.end());\n    rep(i,e.size()){\n        if(!uf.same(e[i].second.first,e[i].second.second)){\n            uf.unite(e[i].second.first,e[i].second.second);\n            ee[e[i].second.first].push_back(P(e[i].second.second,e[i].first));\n            ee[e[i].second.second].push_back(P(e[i].second.first,e[i].first));\n            sum += e[i].first;\n        }\n    }\n    dfs(0);\n    for(int j = 1; j < 30; j++){\n        rep(i,n){\n            par[j][i] = par[j-1][par[j-1][i]];\n            cnt[j][i] = max(cnt[j-1][i],cnt[j-1][par[j-1][i]]);\n        }\n    }\n    cin >> k;\n    rep(i,k){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        cout << sum - lca(s,t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n//class LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nclass LCA{\n\tvvi par;\n\tvvi pmax;\n\tvi dep;\npublic:\n\tLCA(vector<vpii>&E,int root):\n\t\tpar(MSB(E.size())+1,vi(E.size())),\n\t\tpmax(MSB(E.size())+1,vi(E.size())),\n\t\tdep(E.size())\n\t{\n\t\tfunction<void(int,int)>dfs=[&](int i,int p){\n\t\t\tfor(pii j:E[i])if(j.first!=p){\n\t\t\t\tpar[0][j.first]=i;\n\t\t\t\tpmax[0][j.first]=j.second;\n\t\t\t\tdep[j.first]=dep[i]+1;\n\t\t\t\tdfs(j.first,i);\n\t\t\t}\n\t\t};\n\t\tpar[0][root]=root;\n\t\tdfs(root,root);\n\t\tfr(i,par.size()-1){\n\t\t\tfr(j,par[0].size()){\n\t\t\t\tpar[i+1][j]=par[i][par[i][j]];\n\t\t\t\tpmax[i+1][j]=max(pmax[i][j],pmax[i][par[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tint operator()(int a,int b){\n\t\tint z=0;\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tfor(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){\n\t\t\tif(t&1){\n\t\t\t\tchmax(z,pmax[i][b]);\n\t\t\t\tb=par[i][b];\n\t\t\t}\n\t\t}\n\t\tif(a==b)return z;\n\t\trf(i,par.size()){\n\t\t\tif(par[i][a]!=par[i][b]){\n\t\t\t\tchmax(z,pmax[i][a]);\n\t\t\t\ta=par[i][a];\n\t\t\t\tchmax(z,pmax[i][b]);\n\t\t\t\tb=par[i][b];\n\t\t\t}\n\t\t}\n\t\tchmax(z,pmax[0][a]);\n\t\tchmax(z,pmax[0][b]);\n\t\treturn z;\n\t}\n};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tvector<pair<int,pii>>E0;\n\tfr(i,M){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tE0<<pair<int,pii>{c,{a,b}};\n\t}\n\tSort(E0);\n\tUnionFind uf;\n\tll mst=0;\n\tvector<vpii>E(N+1);\n\tfor(auto&p:E0){\n\t\tif(!uf.same(p.second)){\n\t\t\tuf.unite(p.second);\n\t\t\tmst+=p.first;\n\t\t\tE[p.second.first]<<pii{p.second.second,p.first};\n\t\t\tE[p.second.second]<<pii{p.second.first,p.first};\n\t\t}\n\t}\n\tLCA f(E,1);\n\tint Q;cin>>Q;\n\tfr(i,Q){\n\t\tint S,T;cin>>S>>T;\n\t\tprint(mst-f(S,T));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nll ugauss(ll a, ll b) { if (!a) return 0; if (a>0^b>0) return a/b; else return (a+(a>0?-1:1))/b+1; }\nll lgauss(ll a, ll b) { if (!a) return 0; if (a>0^b>0) return (a+(a>0?-1:1))/b-1; else return a/b; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nsize_t random_seed; struct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    // x, yをマージ, O(A^-1)\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    // x, yが同じ集合なら1, O(A^-1)\n    bool find(int x, int y) {\n        return root(x) == root(y);\n    }\n    // xの根を探す。同じ集合なら同じ根が帰る, O(A^-1)\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    // xが含まれる集合の大きさを返す, O(A^-1)\n    int size(int x) {\n        return -data[root(x)];\n    }\n    // 分離されている集合の数を返す, O(n)\n    int getSetNum(void) {\n        unordered_map<int, int> c;\n        rep(i, data.size()) {\n            c[root(i)]++;\n        }\n        return c.size();\n    }\n    // 頂点vと連結な集合を返す, O(n)\n    vector<int> getContainingSet(int v) {\n        vector<int> ret;\n        for (int i = 0; i < data.size(); i++) \n            if (root(i) == root(v))\n                ret.push_back(i);\n        return ret;\n    }\n\n    // 集合ごとに全部の要素を出力, O(n)\n    vector<vector<int>> getUnionList(void) {\n        map<int, vector<int>> c;\n        for (int i = 0; i < data.size(); i++) \n            c[root(i)].pb(i);\n        vector<vector<int>> v;\n        for (auto x : c) \n            v.push_back(x.second);\n        return v;\n    }\n};\nostream &operator<<(ostream &o, struct UnionFind v) {  v.getUnionList(); int i = 0; for (auto x : v.getUnionList()) { o << i << \"\\t\"; for (auto y : x) o << y << \" \"; o << endl; i++;} return o; }\n\n\nll n, m;\nll cost[4010][4010];\nvector<vector<P>> g;\nvector<vector<P>> t;\nvoid update(ll i) {\n    vector<bool> used(n);\n    function<void(ll, ll, ll)> dfs = [&](ll i, ll j, ll c) {\n        if (used[j]) return;\n        used[j] = 1;\n        cost[i][j] = c;\n//        cout << mt(i, j) << \" \" << c << endl;\n        for (auto uc : t[j]) {\n            ll next_u = uc.fi;\n            ll next_c = uc.se;\n            dfs(i, next_u, max(cost[i][j], next_c));\n        }\n    };\n    dfs(i, i, 0);\n}\nint main(void) {\n    cin >> n >> m;\n    g.resize(n);\n    t.resize(n);\n\n    vector<vll> edges;\n    rep(i, m) {\n        ll u, v, c; cin >> u >> v >> c; u--, v--;\n        g[u].pb(P(v, c));\n        g[v].pb(P(u, c));\n        edges.pb((vll){c, u, v});\n    }\n    sort(all(edges));\n\n    ll mst = 0;\n    UnionFind uf(n);\n    for (auto cuv : edges) {\n        ll c = cuv[0];\n        ll u = cuv[1];\n        ll v = cuv[2];\n        if (!uf.find(u, v)) {\n            uf.unite(u, v);\n            t[u].pb(P(v, c));\n            t[v].pb(P(u, c));\n            mst += c;\n        }\n    }\n    /*\n    cout << \"##############\" << endl;\n    cout << mst << endl;\n    cout << edges << endl;\n    cout << t << endl;\n    cout << uf << endl;\n    */\n\n\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    rep(i, n) {\n        update(i);\n    }\n\n    /*\n    rep(i, n) {\n        rep(j, n) {\n            cout << cost[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    */\n\n    ll q; cin >> q;\n    rep(_, q) {\n        ll x, y; cin >> x >> y; x--, y--;\n        cout << mst - cost[x][y] << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\nreturn;\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll INF = 1e18;\nll N, M;\nll cost[MAXN][MAXN];\nll mincost[MAXN];\nbool used[MAXN];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, MAXN) rep(j, MAXN) cost[i][j] = INF;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    ll Q;\n    cin >> Q;\n    if(Q != 1) return 0;\n    ll s, t;\n    cin >> s >> t;\n    s--; t--;\n    rep(i, MAXN) mincost[i] = INF;\n    rep(i, MAXN) used[i] = false;\n    cost[s][t] = 0;\n    cost[t][s] = 0;\n    mincost[0] = 0;\n    ll ans = 0;\n    while(true){\n      ll v = -1;\n      rep(u, N){\n        if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n      }\n      if(v == -1) break;\n      used[v] = true;\n      ans += mincost[v];\n\n      rep(u, N){\n        mincost[u] = min(mincost[u], cost[v][u]);\n      }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >ttree[4005];\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < ttree[dst].size(); i++){\n\t\t\tlong long ncost = ttree[dst][i].first;\n\t\t\tlong long next = ttree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid prepare(){\n\tset<long long> done;\n\t//                     cost  ,      src\t,     dst\n\tpriority_queue<pair<long long, pair<long long, long long> >, vector<pair<long long, pair<long long, long long> > >, greater<pair<long long, pair<long long, long long> > > > Q;\n\tQ.push(make_pair(0, make_pair(-1, 0)));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, src, dst;\n\t\tcost = Q.top().first;\n\t\tsrc = Q.top().second.first;\n\t\tdst = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tdone.insert(dst);\n\t\tif(src != -1){\n\t\t\tttree[src].push_back(make_pair(cost, dst));\n\t\t\tttree[dst].push_back(make_pair(cost, src));\n\t\t}\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, make_pair(dst, next)));\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tprepare();\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].to==p))< ve.size() && (f = ve[gi].from,t=ve[gi].to, c = ve[gi].cost,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> vector<T> rev(vector<T> &a) {\n    vector<T> ret = a;\n    reverse(all(ret));\n    return ret;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    fora(e, g.edges) chmin(dis[e.from][e.to], e.cost);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].to;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        fora(e, edges)if (e.cost != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, cost, eid++, ty);\n        g[t].emplace_back(t, f, cost, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, cost, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    if (g.edges.size() == 0)return true;\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.from, e.to + g.n), uf.unite(e.from + g.n, e.to);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\n\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.to] == 0)st.push(e.to);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.to] == 0)q.push(e.to);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\nvoid solve() {\n    cin >> n >> m;\n    digraph<> g(2 * k5);\n    rep(i, m) {\n        int f, t, c;\n        cin >> f >> t >> c;\n        --f, --t;\n        g.add(f, t, c);\n    }\n    cin >> q;\n    din(s, tt);\n    s--, tt--;\n    sort(g.edges);\n    UnionFind uf(k5);\n    uf.unite(s, tt);\n    fora(e, g.edges) {\n        if (uf.same(e.from, e.to))con;\n        uf.unite(e.from, e.to);\n        cou += e.cost;\n    }\n    cout << cou << endl;\n}\nint my(int n, vi a) {\n    return 0;\n}\nint sister(int n, vi a) {\n    return 0;\n}\n\nsigned main() {\n    solve();\n\n#define _arg n,a\n    //cin>>n;\n    //na(a,n);\n    //my(_arg);\n    //cout << my(_arg) << endl;\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 3);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            cout << n << endl;\n            cout << a << endl;\n            cout << \"正解 : \" << res << endl;\n            cout << \"出力 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\nint n, m, q, a[400000], b[400000], c[400000], dist[5000], D[5000][5000];\nvector<pair<int, int>>vec; vector<pair<int, int>>x[5000];\nvoid query(int r1) {\n\tfill(dist + 1, dist + n + 1, 1299999999);\n\tqueue<int>Q; Q.push(r1); dist[r1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] == 1299999999) {\n\t\t\t\tdist[x[a1][i].first] = max(dist[a1], x[a1][i].second);\n\t\t\t\tQ.push(x[a1][i].first);\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; vec.push_back(make_pair(c[i], i));\n\t}\n\tsort(vec.begin(), vec.end());\n\tUnionFind UF(n + 1); long long sum = 0;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tint to = vec[i].second;\n\t\tif (UF.same(a[to], b[to]) == false) {\n\t\t\tUF.unite(a[to], b[to]); sum += c[to];\n\t\t\tx[a[to]].push_back(make_pair(b[to], c[to]));\n\t\t\tx[b[to]].push_back(make_pair(a[to], c[to]));\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tquery(i); for (int j = 1; j <= n; j++)D[i][j] = dist[j];\n\t}\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint p1, p2; cin >> p1 >> p2;\n\t\tcout << sum - D[p1][p2] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <string>\n    #include <vector>\n    #include <cstdio>\n    #include <cstdlib>\n    #include <cmath>\n    #include <algorithm>\n    #include <queue>\n    #include <map>\n    #include <set>\n    #include <iostream>\n    #include <sstream>\n    #include <cstring>\n    #include <numeric>\n    using namespace std;\n    typedef long long ll;\n    typedef pair<int,int> pii;\n    #define F0(i,n) for (int i = 0; i < n; i++)\n    #define F1(i,n) for (int i = 1; i <= n; i++)\n    #define CL(a,x) memset(x, a, sizeof(x));\n    #define SZ(x) ((int)x.size())\n    const double eps = 1e-10;\n    const int inf = 1000000009;\n    int i, j, k, m, n, l;\n    int ans;\n    string s;\n    const int N = 5000;\n    int a[N], b[N], id[N], p[N];\n    int c[N][N], u[N], best[N];\n     \n     \n    int main() {\n    \t//freopen(\"x.in\", \"r\", stdin);\n     \n    \tcin >> n >> m;\n    \tF0(i, m) {\n    \t\tcin >> a[i] >> b[i] >> j;\nif (c[a[i]][b[i]] == 0 || c[a[i]][b[i]] > j)\n    \t\tc[a[i]][b[i]] = c[b[i]][a[i]] = j;\n     \t}\n     \n    \tint Q, S, T;\n    \tcin >> Q;\n    \twhile (Q--) {\n    \t\tcin >> S >> T;\n     \n    \t\tset<pii> SE;\n    \t\tF1(i, n) if (i != S && i != T) {\n  best[i] = min(c[S][i], c[T][i]);\n    \t SE.insert(pii(best[i], i));\n    \t\t\tu[i] = 0;\n    \t\t}\nu[S] = u[T] = 1;\n     \n    \t\tll ans = 0;\n    \t\tF0(i, n - 2) {\n    \t\t\tpii p = *SE.begin(); SE.erase(SE.begin());\n    \t\t\tans += p.first;\n    \t\t\tu[p.second] = 1;\n    \t\t\tF1(i, n) if (!u[i]) {\n    \t\t\t\tif (c[p.second][i] < best[i]) {\nSE.erase(SE.find(pii(best[i], i)));\nbest[i] = c[p.second][i];\nSE.insert(pii(best[i], i));\n}\n    \t\t\t}\n     \n    \t\t}\n    \t\tcout << ans << endl;\n    \t}\n    \t\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n;\nint m;\nstruct edge { int from, to, cost; };\nstruct edge2 { LL to, cost; };\ntypedef pair<int, int> PP;\n\nvector<edge> e;\nvector<edge2> G[4040];\n\nint Par[100000];\nint Rank[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\n// ソート時に比較するための関数 \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal() {\n\tinit(n);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tG[e[i].from].emplace_back(edge2{ e[i].to,e[i].cost });\n\t\t\tG[e[i].to].emplace_back(edge2{ e[i].from,e[i].cost });\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\n\nLL ans[4040][4040];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\te.emplace_back(edge{ a,b,c });\n\t}\n\tLL num = kruskal();\n\tREP(i, n) {\n\t\tqueue<pair<int, int>> q;\n\t\tq.push(make_pair(i, -1));\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> cur = q.front();\n\t\t\tq.pop();\n\t\t\tREP(j, G[cur.first].size()) {\n\t\t\t\tif (G[cur.first][j].to != cur.second) {\n\t\t\t\t\tans[i][G[cur.first][j].to] = max(ans[i][cur.first], G[cur.first][j].cost);\n\t\t\t\t\tq.push(make_pair(G[cur.first][j].to, cur.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\tREP(qqq, q) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--, t--;\n\t\tcout << num - ans[s][t] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 1010;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\ntuple<ll, int, int> edges[500000];\nvector<pair<int, ll>> path[5000];\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = mt(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    // d[v] = 0を親としたときのノードvの深さ\n    int d[N];\n    fill(d, d + N, -1);\n    d[0] = 0;\n\n    // lca[x][v] = (vから2^xだけ遡った頂点,\n    //              そこに行くまでに辿った辺でのコストの最大値)\n    pair<int, ll> lca[15][N];\n    lca[0][0] = mp(0, 0);\n\n    // 幅優先探索でdとlca[0]を埋める\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto p : path[v]) {\n            int sv;\n            ll cost;\n            tie(sv, cost) = p;\n            if (d[sv] >= 0) continue;\n\n            d[sv] = d[v] + 1;\n            lca[0][sv] = mp(v, cost);\n            que.push(sv);\n        }\n    }\n\n    // lcaを埋める\n    for (int x = 1; x < 15; ++x) {\n        for (int v = 0; v < N; ++v) {\n            int mid = lca[x - 1][v].first;\n            ll cost = max(lca[x - 1][v].second, lca[x - 1][mid].second);\n\n            lca[x][v] = mp(lca[x - 1][mid].first, cost);\n        }\n    }\n\n    // ようやくクエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        ll trim = 0;\n        if (d[s] > d[t]) swap(s, t);\n        // d[s] <= d[t]\n\n        // tの深さをsに合わせる\n        for (int x = 14; x >= 0; --x) {\n            // 祖先が浅すぎる\n            if (x > 0 && d[s] > d[lca[x][t].first]) continue;\n            trim = max(trim, lca[x][t].second);\n            t = lca[x][t].first;\n        }\n\n        if (d[s] != d[t]) return 0;\n\n        // LCAを探す\n        for (int x = 14; x >= 0; --x) {\n            // 祖先が浅すぎる\n            if (x > 0 && lca[x][s].first == lca[x][t].first) continue;\n            trim = max(trim, max(lca[x][s].second, lca[x][t].second));\n            s = lca[x][s].first;\n            t = lca[x][t].first;\n        }\n\n        if (s != t) return 0;\n\n        cout << total - trim << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPP(i,m,n) for(long long i=m;i<n;++i)\n#define rep(i,n) for(long long i = n-1;i>=0;--i)\n#define repp(i,n,m) for(long long i = n-1; i >= m; --i)\n#define ALL(N) (N.begin(),N.end())\n#define de cout << \"line : \" << __LINE__ << \" debug\" << endl;\n#define pb push_back\n#define pq priority_queue\n#define Dcout(N) cout << setprecision(20) << N << endl\nconstexpr long long INF = 2147483647;\nconstexpr long long INFF = 9223372036854775807;\n\nstruct edge{long long u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n    return e1.cost < e2.cost;\n}\n\n\nstruct UnionFind{\n    vector<long long> par,r;\n\n    //はじめに全てが根であるとしておく\n    UnionFind(long long N):par(N),r(N,1){iota(par.begin(),par.end(),0);}\n\n    long long root(long long x){//根に当たるまで再帰で探す\n        if(par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n\n    bool same(long long x,long long y){//つながっているかどうか判定\n        return par[x] == par[y];\n    }\n\n    long long size(long long x){ //根の大きさを判定する\n        return r[root(x)];\n    }\n\n    void unite(long long x, long long y){//根が同じでなかったらつなげる\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(r[x] < r[y]) swap(x,y); //値を小さいほうを根にする\n        r[x] += r[y];\n        par[y] = x;\n        return;\n    }\n};\n\nedge es[400100];\nlong long V,E;\nvector<pair<long long,long long>> G[4100];\n\nlong long kruskal(){\n    sort (es,es + E,comp);\n    UnionFind UF(V);\n    long long res = 0;\n    REP(i,E){\n        edge e = es[i];\n        if(!UF.same(e.u,e.v)){\n            UF.unite(e.u,e.v);\n            res += e.cost;\n            G[e.u].pb({e.v,e.cost});\n            G[e.v].pb({e.u,e.cost});\n        }\n    }\n    return res;\n}\n\nlong long dis[4100][4100];\n\nvoid dfs(){\n    REP(i,V){\n        REP(j,V){\n            dis[i][j] = -1;\n        }\n        dis[i][i] = 0;\n        queue<int> Q;\n        Q.push(i);\n        while(!Q.empty()){\n            int a = Q.front();Q.pop();\n            REP(k,G[a].size()){\n                int b = G[a][k].first;\n                ll c = G[a][k].second;\n                if(dis[i][b] != -1) continue;\n                dis[i][b] = max(dis[i][a],c);\n                Q.push(b);\n            }\n        }\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n    cin >> V >> E;\n    REP(i,E){\n        cin >> es[i].u >> es[i].v >> es[i].cost;--es[i].u;--es[i].v;\n    }\n    long long mincost = kruskal();\n    long long Q;cin >> Q;\n    long long c,S,T;dfs();\n    REP(i,Q){\n        cin >> S >> T;--S;--T;\n        cout << mincost - dis[S][T] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\nclass UnionFind{\npublic:\n    int n, c;\n    vector<int> par;\n    UnionFind(int n) : n(n), c(0), par(n, -1){}\n    int Find(int x){return par[x] < 0 ? x : Find(par[x]);}\n    bool Unite(int x, int y){\n        if((x = Find(x)) == (y = Find(y)))\n            return false;\n        if(par[x] > par[y])\n            swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        ++c;\n        return true;\n    }\n};\n\nsigned main(){\n    int n, m, q;\n    cin >> n >> m;\n    vector<vector<pair<int,int>>> edges(n);\n    priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int,int>>>, greater<pair<int, pair<int,int>>>> que;\n    for(int i = 0; i < m; ++i){\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges[--a].emplace_back(--b, c);\n        edges[b].emplace_back(a, c);\n        que.emplace(c, make_pair(a, b));\n    }\n    i64 mst_cost = 0;\n    UnionFind uni(n);\n    vector<vector<pair<int,int>>> tr(n);\n    while(uni.c != n - 1){\n        int cost;\n        pair<int,int> p;\n        tie(cost, p) = que.top();\n        que.pop();\n        if(uni.Unite(p.first, p.second)){\n            mst_cost += cost;\n            tr[p.first].emplace_back(p.second, cost);\n            tr[p.second].emplace_back(p.first, cost);\n        }\n    }\n    vector<vector<int>> v(n, vector<int>(n, -1));\n    function<void(int,int, int)> max_cost = [&](int from, int pos, int ma){\n        for(auto& e : tr[pos]){\n            if(v[from][e.first] == -1){\n                int nex = max(e.second, ma);\n                v[from][e.first] = nex;\n                max_cost(from, e.first, nex);\n            }\n        }\n    };\n    for(int i = 0; i < n; ++i){\n        v[i][i] = 0;\n        max_cost(i, i, 0);\n    }\n    cin >> q;\n    for(int i = 0; i < q; ++i){\n        int s, t;\n        cin >> s >> t;\n        cout << mst_cost - v[--s][--t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 7;\nconst int MAXN = 4005;\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstruct edg{\n\tint s, e, x;\n\tbool operator<(const edg &e)const{\n\t\treturn x < e.x;\n\t}\n};\n\nint n, m;\nvector<pi> gph[MAXN];\nvector<edg> ed;\nint dep[MAXN], par[12][MAXN], pva[12][MAXN];\n\nvoid dfs(int x, int p){\n\tfor(auto &i : gph[x]){\n\t\tif(i.second == p) continue;\n\t\tpar[0][i.second] = x;\n\t\tpva[0][i.second] = i.first;\n\t\tdep[i.second] = dep[x] + 1;\n\t\tdfs(i.second, x);\n\t}\n}\n\nint get(int s, int e){\n\tif(dep[e] < dep[s]) swap(s, e);\n\tint dx = dep[e] - dep[s];\n\tint ans = 0;\n\tfor(int i=0; i<12; i++){\n\t\tif((dx >> i) & 1){\n\t\t\tans = max(ans, pva[i][e]);\n\t\t\te = par[i][e];\n\t\t}\n\t}\n\tfor(int i=11; i>=0; i--){\n\t\tif(par[i][s] != par[i][e]){\n\t\t\tans = max({ans, pva[i][s], pva[i][e]});\n\t\t\ts = par[i][s];\n\t\t\te = par[i][e];\n\t\t}\n\t}\n\tif(s != e){\n\t\tans = max({ans, pva[0][s], pva[0][e]});\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i=0; i<m; i++){\n\t\tint s, e, x;\n\t\tscanf(\"%d %d %d\",&s,&e,&x);\n\t\ted.push_back({s, e, x});\n\t}\n\tsort(ed.begin(), ed.end());\n\tlint ans = 0;\n\tdisj.init(n);\n\tfor(auto &i : ed){\n\t\tif(disj.uni(i.s, i.e)){\n\t\t\tans += i.x;\n\t\t\tgph[i.s].push_back(pi(i.x, i.e));\n\t\t\tgph[i.e].push_back(pi(i.x, i.s));\n\t\t}\n\t}\n\tdfs(1, 0);\n\tfor(int i=1; i<12; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tpar[i][j] = par[i-1][par[i-1][j]];\n\t\t\tpva[i][j] = max(pva[i-1][j], pva[i-1][par[i-1][j]]);\n\t\t}\n\t}\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tprintf(\"%lld\\n\", ans - get(s, e));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  UF(int n) : par(n), sizes(n, 1) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n    }\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vvi edge(m, vi(3));\n  rep (i, m) {\n    cin >> edge[i][1] >> edge[i][2] >> edge[i][0];\n    edge[i][1] -= 1; edge[i][2] -= 1;\n  }\n  sort(all(edge));\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  set<int> si;\n  ll cost = 0;\n  cost += edge[0][0];\n  uf.unite(edge[0][1], edge[0][2]);\n  maxcost[edge[0][1]][edge[0][2]] = maxcost[edge[0][2]][edge[0][1]] = edge[0][0];\n  si.insert(edge[0][1]);\n  si.insert(edge[0][2]);\n  FOR (i, 1, m) {\n    if (!(uf.same(edge[i][1], edge[i][2]))) {\n      cost += edge[i][0];\n      uf.unite(edge[i][1], edge[i][2]);\n      int append;\n      if (si.find(edge[i][1]) == end(si)) {\n        append = edge[i][1];\n      } else {\n        append = edge[i][2];\n      }\n      for (int x : si) {\n        maxcost[append][x] = maxcost[x][append] = edge[i][0];\n      }\n      si.insert(append);\n    }\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nint UF[4100];\nvector<int>s[4100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;\n\tif(UF[a]>UF[b])swap(a,b);\n\tUF[a]+=UF[b];UF[b]=a;\n\tfor(int i=0;i<s[b].size();i++)s[a].push_back(s[b][i]);\n\ts[b].clear();\n}\npair<int,pair<int,int> > edge[410000];\nvector<pair<int,pair<int,int> > >v;\nint neg[4100][4100];\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tp--;q--;\n\t\tedge[i]=make_pair(r,make_pair(p,q));\n\t}\n\tstd::sort(edge,edge+b);\n\tlong long tmp=0;\n\tfor(int i=0;i<a;i++)s[i].push_back(i);\n\tfor(int i=0;i<a;i++)UF[i]=-1;\n\tfor(int i=0;i<b;i++){\n\t\tif(FIND(edge[i].second.first)==FIND(edge[i].second.second))continue;\n\t\tfor(int j=0;j<s[FIND(edge[i].second.first)].size();j++){\n\t\t\tfor(int k=0;k<s[FIND(edge[i].second.second)].size();k++){\n\t\t\t\tneg[s[FIND(edge[i].second.first)][j]][s[FIND(edge[i].second.second)][k]]=\n\t\t\t\tneg[s[FIND(edge[i].second.second)][k]][s[FIND(edge[i].second.first)][j]]=\n\t\t\t\tedge[i].first;\n\t\t\t}\n\t\t}\n\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\tv.push_back(edge[i]);\n\t\ttmp+=edge[i].first;\n\t}\n\tint c;scanf(\"%d\",&c);\n\twhile(c--){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);x--;y--;\n\t\tif(x>y)swap(x,y);\n\t\tlong long ret=tmp-neg[x][y];\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\n//const long long int MOD = 1000000007;\nconst int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R\n\nstruct Edge {\n\tint a, b, cost;\n\tbool operator <(const Edge&e)const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v])parent[u] = v;\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<Edge>edge(M);\n\tfor (auto &i : edge)cin >> i.a >> i.b >> i.cost;\n\tsort(edge.begin(), edge.end());\n\tUnionFind uf(N);\n\tvector<vector<Edge>>v(N + 1);\n\tlong long int ans = 0;\n\tfor (auto i : edge) {\n\t\tif (uf.Check_Same(i.a, i.b))continue;\n\t\tuf.Unite(i.a, i.b);\n\t\tv[i.a].push_back({ i.a,i.b,i.cost });\n\t\tv[i.b].push_back({ i.b,i.a,i.cost });\n\t\tans += i.cost;\n\t}\n\tvector<vector<int>>minus(N + 1, vector<int>(N + 1));\n\tfor (int i = 1; i <= N; i++) {\n\t\tvector<int>used(N + 1);\n\t\tqueue<int>Q;\n\t\tQ.push(i);\n\t\tused[i] = 1;\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (auto j : v[cn]) {\n\t\t\t\tif (used[j.b])continue;\n\t\t\t\t//if (minus[i][j.b] < max(minus[i][j.a], j.cost)) {\n\t\t\t\tminus[i][j.b] = max(minus[i][cn], j.cost);\n\t\t\t\tused[j.b] = 1;\n\t\t\t\tQ.push(j.b);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\tcin >> K;\n\twhile (K--) {\n\t\tcin >> L >> R;\n\t\tcout << ans - minus[L][R] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = 2e9;\nconst ld EPS = 1e-8;\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n  int src, dest, rev;\n  Flow cap;\n  Weight cost;\n  bool operator < (const Edge &rhs) const {\n    return cost > rhs.cost;\n  }\n  Edge(int s, int d) : src(s), dest(d) { ; }\n  Edge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n  Edge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nbool comp(const Edge &e1, const Edge &e2){\n  return e1.cost < e2.cost;\n}\n\npair<Weight, Edges> kruskal(Edges &es, int v){\n  sort(ALL(es), comp);\n  UnionFind uni(v);\n  Edges mst;\n  Weight res = 0;\n  for(Edge e: es){\n    if(!uni.findSet(e.src, e.dest)){\n      uni.unionSet(e.src, e.dest);\n      mst.push_back(e);\n      res += e.cost;\n    }\n  }\n  return make_pair(res, mst);\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  Edges es;\n  REP(i,M) {\n    int a, b, c;\n    cin >> a >> b >> c; --a; --b;\n    es.push_back(Edge(a, b, c));\n    es.push_back(Edge(b, a, c));\n  }\n\n  pair<int,Edges> mst = kruskal(es, N);\n  Graph g(N);\n  for(Edge e: mst.second) {\n    g[e.src].push_back(e);\n    g[e.dest].push_back(Edge(e.dest, e.src, e.cost));\n  }\n  /*\n  REP(i,N) {\n    for(Edge e: g[i]) {\n      cout << e.dest << \" \";\n    }\n    cout << endl;\n  }\n  */\n\n  vector<vector<int>> d(N, vector<int> (N, 0));\n  REP(i,N) {\n    queue<tuple<int,int,int>> que;\n    que.push(make_tuple(i, -1, 0));\n    while(!que.empty()) {\n      int curr, prev, cst;\n      tie(curr, prev, cst) = que.front(); que.pop();\n      d[i][curr] = max(d[i][curr], cst);\n      for(Edge e: g[curr]) {\n        if(e.dest == prev) continue;\n        que.push(make_tuple(e.dest, curr, max(cst, e.cost)));\n      }\n    }\n  }\n  /*\n  REP(i,N){\n    REP(j,N) cout << \" \" << d[i][j];\n    cout << endl;\n  }\n  */\n\n  int Q;\n  cin >> Q;\n  REP(q, Q) {\n    int S, T;\n    cin >> S >> T; --S; --T;\n    cout << mst.first - d[S][T] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define iREP(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\ntypedef long long ll;\n\nint maxcost[4010][4010];\nbool used[4010];\nvector<int> G[4010];\nint cost[4010][4010];\n\nclass UnionFindFixed{\n    vector<int> data;\npublic:\n    UnionFindFixed(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nvoid dfs(int v, int mcost,int ori){\n    stack< pair<int,int> > sta; sta.push(make_pair(v,mcost));\n    while(sta.size()!=0){\n        int vt=sta.top().first;\n        int costt=sta.top().second;\n        sta.pop();\n        used[vt]=true;\n        REP(i,G[vt].size()){\n            if(!used[G[vt][i]]){\n                costt=max(costt,cost[vt][G[vt][i]]);\n                maxcost[ori][G[vt][i]]=costt;\n                maxcost[ori][G[vt][i]]=costt;\n                sta.push(make_pair(G[vt][i],costt));\n            }\n        }\n    }\n}\n\nint main(){\n    \n    int N,M; cin>>N>>M;\n    vector< pair<int,pair<int,int> > > v(M);\n    REP(i,M)cin>>v[i].second.first>>v[i].second.second>>v[i].first;\n    sort(v.begin(),v.end());\n    \n    ll totalcost=0;\n    UnionFindFixed inst(4010);\n    REP(i,M){\n        int a=v[i].second.first,b=v[i].second.second,c=v[i].first;\n        if(!inst.findSet(a,b)){\n            inst.unionSet(a,b);\n            G[a].push_back(b);\n            G[b].push_back(a);\n            cost[a][b]=cost[b][a]=c;\n            totalcost+=c;\n        }\n    }\n    \n    for(int i=1;i<=N;i++){\n        REP(j,4010)used[j]=false;\n        dfs(i,0,i);\n    }\n    \n    /* for(int i=1;i<=N;i++){\n     for(int j=1;j<=N;j++)cout<<maxcost[i][j]<<\" \";\n     cout<<endl;\n     }*/\n    \n    int Q; cin>>Q;\n    REP(i,Q){\n        int S,T; cin>>S>>T;\n        cout<<totalcost-maxcost[S][T]<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\n// Description: 素集合を管理するデータ構造\n// TimeComplexity: 初期化$\\mathcal{O}(n)$ 更新$\\mathcal{O}(\\log n)$\n// Verifyed: AOJ DSL_1_A\n\nstruct Union_find {\n\tUnion_find(int n) {par.resize(n), iota(_all(par), 0);}\n\tint find(int x) {return (par[x] == x) ? x : par[x] = find(par[x]);}\n\tvoid unite(int a, int b) {a = find(a), b = find(b); par[a] = b;}\n\tbool same(int a, int b) {return find(a) == find(b);}\n\tvector<int> par;\n};\n\nusing edge = struct {int to; ll cost;};\nusing G = vector<vector<edge>>;\nG graph;\n\nconst int limit = 4010;\nll dist[limit][limit];\n\nvoid dfs(int v, int p, int s, ll c) {\n\tchmax(dist[s][v], c);\n\tfor (auto &e : graph[v]) {\n\t\tif (e.to == p) continue;\n\t\tdfs(e.to, v, s, max(c, e.cost));\n\t}\n}\n\nint main(void) {\n\tint n, m;\n\tcin >> n >> m;\n\n\tusing edge = tuple < ll, ll, ll>;\n\tvector<edge> edges;\n\n\trep(i, m) {\n\t\tll a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tedges.push_back(edge(c, a, b));\n\t}\n\n\tsort(begin(edges), end(edges));\n\tUnion_find uf(n);\n\n\tll res = 0LL;\n\tgraph = G(n);\n\n\tfor (auto &e : edges) {\n\t\tll c, a, b;\n\t\ttie(c, a, b) = e;\n\t\tif (uf.same(a, b)) continue;\n\t\tuf.unite(a, b);\n\t\tres += c;\n\t\tgraph[a].push_back({b, c});\n\t\tgraph[b].push_back({a, c});\n\t}\n\n\trep(v, n) dfs(v, -1, v, 0LL);\n\n\tint q;\n\tcin >> q;\n\trep(loop, q) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--, t--;\n\t\tcout << res - dist[s][t] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, auto& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct QU {\n  V<> par, rank, _size;\n\n  QU(int n) { \n    par.resize(n);\n    iota(par.begin(), par.end(), 0);\n    rank.resize(n);\n    _size.assign(n, 1);\n  }\n\n  int find(int a) {\n    if (par[a] == a) return a;\n    return par[a] = find(par[a]);\n  }\n\n  bool same(int a, int b) { return find(a) == find(b); }\n\n  int size(int a) { return _size[find(a)]; }\n\n  void unite(int a, int b) {\n    a = find(a), b = find(b);\n    if (a == b) return;\n    if (rank[a] < rank[b]) {\n      par[a] = b;\n      _size[b] += _size[a];\n    } else {\n      par[b] = a;\n      _size[a] += _size[b];\n    }\n    if (rank[a] == rank[b]) rank[a]++;\n  }\n};\n\ntemplate<class T> struct edge { int id, from, to; T w; };\n\ntemplate<class T> T kruskal(V< edge<T> >& g, int n, V<bool>& used) {\n  T res = 0;\n  QU qu(n);\n  sort(g.begin(), g.end(), [](auto a, auto b) { return a.w < b.w; });\n  for (auto&& e : g) {\n    if (!qu.same(e.from, e.to)) {\n      qu.unite(e.from, e.to);\n      res += e.w;\n      used[e.id] = true;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V< edge<lint> > es(m);\n  for (int i = 0; i < m; i++) {\n    int a, b, c; cin >> a >> b >> c, a--, b--;\n    es[i] = {i, a, b, c};\n  }\n  V<bool> used(m);\n  lint sm = kruskal<lint>(es, n, used);\n  struct edge2 { int to; lint w; };\n  VV<edge2> g(n);\n  for (int i = 0; i < m; i++) if (used[es[i].id]) {\n    g[es[i].from].push_back({es[i].to, es[i].w});\n    g[es[i].to].push_back({es[i].from, es[i].w});\n  }\n  VV<lint> res; assign(res, n, n, -1e18);\n  for (int i = 0; i < n; i++) {\n    queue<int> q;\n    V<bool> vis(n);\n    vis[i] = true; q.push(i);\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      for (auto&& e : g[v]) if (!vis[e.to]) {\n        vis[e.to] = true;\n        res[i][e.to] = max(res[i][v], e.w);\n        q.push(e.to);\n      }\n    }\n  }\n  int q; cin >> q;\n  for (int iq = 0; iq < q; iq++) {\n    int s, t; cin >> s >> t, s--, t--;\n    cout << sm - res[s][t] << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\ntypedef long long ll;\n\nvector<int> par,rk;\n\nvoid init(const int n){\n\tpar.resize(n);\n\trk.resize(n);\n\tfor(int i=0;i<n;++i) par[i]=i;\n\tfill(rk.begin(),rk.end(),0);\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y){\n\t\treturn;\n\t}else if(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rk[x]==rk[y]){\n\t\t\t++rk[x];\n\t\t}\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nstruct edge{\n\tint from,to;\n\tll cost;\n};\n\nbool cmp(edge e,edge f){\n\treturn e.cost<f.cost;\n}\n\n#define MAX_Q 100000\n\nvector<edge> es;\n\n#define MAX_N 4000\n\nvector<int> g[MAX_N];\nll d[MAX_N][MAX_N];\n\nvoid dfs(int v0,int v){\n\tfor(int j=0;j<g[v].size();++j){\n\t\tint e=g[v][j],w=es[e].from;\n\t\tif(v==w) w=es[e].to;\n\t\tif(d[v0][w]>=0) continue;\n\t\td[v0][w]=max(d[v0][v],es[e].cost);\n\t\tdfs(v0,w);\n\t}\n}\n\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m-->0){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tes.pb((edge){--a,--b,c});\n\t}\n\tsort(es.begin(),es.end(),cmp);\n\tinit(n);\n\tll sc=0;\n\tfor(int j=0,e=0;e<n-1;++j){\n\t\tint v=es[j].from,w=es[j].to;\n\t\tif(same(v,w)) continue;\n\t\tunite(v,w);\n\t\tsc+=es[j].cost;\n\t\tg[v].pb(j);\n\t\tg[w].pb(j);\n\t\t++e;\n\t}\n\tfor(int v=0;v<n;++v){\n\t\tfill(d[v],d[v]+n,-1);\n\t\td[v][v]=0;\n\t\tdfs(v,v);\n\t}\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q-->0){\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tprintf(\"%lld\\n\",sc-d[--s][--t]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint root[4000];\nint getRoot(int v){ return root[v] == -1 ? v : root[v] = getRoot(root[v]); }\n\nvector<vector<int>> solve(int N, const vector<pair<int, pair<int,int>>>& edge){\n\tfill(root, root+N, -1);\n\tvector<vector<pair<int,int>>> g(N);\n\tint sum = 0;\n\tfor(auto& e : edge){\n\t\tint src = e.second.first;\n\t\tint dst = e.second.second;\n\t\tint p = getRoot(src);\n\t\tint q = getRoot(dst);\n\t\tif(p != q){\n\t\t\tsum += e.first;\n\t\t\troot[q] = p;\n\t\t\tg[p].emplace_back(q, e.first);\n\t\t\tg[q].emplace_back(p, e.first);\n\t\t}\n\t}\n\tvector<vector<int>> res(N, vector<int>(N, -1));\n\tfor(int i=0;i<N;i++){\n\t\tres[i][i] = 0;\n\t\tqueue<int> qu; qu.push(i);\n\t\twhile(!qu.empty()){\n\t\t\tint pos = qu.front(); qu.pop();\n\t\t\tfor(auto& e : g[pos]){\n\t\t\t\tint dst = e.first;\n\t\t\t\tif(res[i][dst] >= 0) continue;\n\t\t\t\tres[i][dst] = max(res[i][pos], e.second);\n\t\t\t\tqu.push(dst);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto& v : res){\n\t\tfor(auto& t : v) t = sum - t;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M){\n\t\tvector<pair<int, pair<int, int>>> edge(M);\n\t\tfor(auto& p : edge){\n\t\t\tcin >> p.second.first >> p.second.second >> p.first;\n\t\t\t--p.second.first;\n\t\t\t--p.second.second;\n\t\t}\n\t\tsort(edge.begin(), edge.end());\n\t\tauto res = solve(N, edge);\n\t\tint Q; cin >> Q;\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << res[s-1][t-1] << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ull INF = ULLONG_MAX;\nconst ll MOD = 998244353;\n\ntypedef ll Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Graph> Prim(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tGraph T(n);\n\tWeight total = 0;\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-1, r, 0));\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif (visited[e.dst])\n\t\t\tcontinue;\n    if(e.src>=0){\n  \t\tT[e.src].push_back(e);\n      T[e.dst].push_back({e.dst,e.src,e.weight});\n    }\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tfor (Edge f:g[e.dst])\n\t\t\tif (!visited[f.dst])\n\t\t\t\tQ.push(f);\n\t}\n\treturn pair<Weight, Graph>(total, T);\n}\n\n\n\ninline int get_min2pow(int n) {\n\tint res = 1;\n\twhile (res < n)\n\t\tres *= 2;\n\treturn res;\n}\n\n///Segment Tree////////\n\ntemplate<typename T,T dval>\nstruct segtree {\n\tint N;\n\tvector<T> node;\n\t//例外値　ex)INF,0\n\tT default_value = dval;\n\tstatic inline T merge(const T& l, const T& r) {\n\t\t//RMQ\n\t\treturn max(l,r);\n\t\t//RSQ\n\t\t//return l+r;\n\t}\n\tsegtree(int n) {\n\t\tN = get_min2pow(n);\n\t\tnode.resize(2 * N, default_value);\n\t}\n\tsegtree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tN = get_min2pow(sz);\n\t\tnode.resize(2 * N, default_value);\n\t\tfor (int i = 0; i < sz; i++)\n\t\t\tnode[i + N - 1] = v[i];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t\tnode[i] = merge(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\t// update k th element\n\tvoid update(int k, T val) {\n\t\tk += N - 1; // leaf\n\t\tnode[k] = val;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l)\n\t\t\treturn default_value;\n\t\tif (a <= l and r <= b)\n\t\t\treturn node[k];\n\t\tint m = (l + r) / 2;\n\t\tT vl = query(a, b, k * 2 + 1, l, m);\n\t\tT vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn merge(vl, vr);\n\t}\n};\n\n\nstruct HLDecomposition{\n  int V;\n  vint dep,par,heavy,head,id,size,dat;\n  segtree<ll,0> RMQ;\n  HLDecomposition(const Graph &g,int root=0)\n  :V(g.size()),dep(V,0),par(V,-1),heavy(V,-1),head(V),id(V),size(V,1),dat(V,-1),RMQ(V){\n    //make par\n    par[root]=0;\n    vint q(V);\n    int l=0,r=0;\n    q[r++]=root;\n    while(l<r){\n      int v=q[l++];\n      for(const Edge &w:g[v])\n      if(par[w.dst]<0){\n        q[r++]=w.dst;\n        par[w.dst]=v;\n        dat[w.dst]=w.weight;\n        dep[w.dst]=dep[v]+1;\n      }\n    }\n    par[root]=-1;\n    //calculate heavy\n    reverse(q.begin(),q.end());\n    repeat(i,V){\n      int v=q[i];\n      if(par[v]<0)continue;\n      size[par[v]]+=size[v];\n      if(heavy[par[v]]<0||size[v]>size[heavy[par[v]]])heavy[par[v]]=v;\n    }\n    //calculate id\n    int idx=0;\n    repeat(v,V){\n      if(par[v]<0||heavy[par[v]]!=v){\n        for(int w=v;w!=-1;w=heavy[w]){\n          head[w]=v;\n          id[w]=idx++;\n          RMQ.update(id[w],dat[w]);\n        }\n      }\n    }\n  }\n  // [u,v]\n  ll query(int u,int v){\n    ll ret=0;\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]!=head[v]){\n        ret = max(ret,RMQ.query(id[head[v]]+1,id[v]+1));\n        v=par[head[v]];\n      }else{\n        if(u!=v)ret = max(ret,RMQ.query(id[u]+1,id[v]+1));\n        return ret;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]==head[v])return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\nint main(){\n  int N,M;cin>>N>>M;\n  Graph g(N);\n  repeat(i,M){\n    int a,b;\n    Weight c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back({a,b,c});\n    g[b].push_back({b,a,c});\n  }\n  pair<Weight, Graph> tree=Prim(g,0);\n  HLDecomposition hld(tree.second,0);\n  int Q;cin>>Q;\n  repeat(q,Q){\n    int s,t;cin>>s>>t;\n    s--;t--;\n    ll ans=tree.first-hld.query(s,t);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 4003\n\nint parent[N];\nint root(int x) {\n  if(x != parent[x]) x = parent[x] = root(parent[x]);\n  return x;\n}\nvoid unite(int x, int y) {\n  int px = root(x), py = root(y);\n  if(px < py) {\n    parent[py] = px;\n  } else {\n    parent[px] = py;\n  }\n}\n\nvector<P> g[N];\nll maxi[N][N];\nvoid dfs(int s, int v, int prev, int cost) {\n  maxi[s][v] = cost;\n  rep(i, g[v].size()) {\n    P &e = g[v][i];\n    if(prev != e.first) {\n      dfs(s, e.first, v, maxd(cost, e.second));\n    }\n  }\n}\n\nint main() {\n  int n, m; cin >> n >> m;\n  vector<IP> v;\n  ll su = 0;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    v.push_back(IP(c, P(a, b)));\n  }\n  sort(ALL(v));\n  rep(i, n) parent[i+1] = i+1;\n  rep(i, m) {\n    IP &e = v[i];\n    int a = e.second.first, b = e.second.second, c = e.first;\n    if(root(a) != root(b)) {\n      unite(a, b);\n      su += c;\n      g[a].push_back(P(b, c));\n      g[b].push_back(P(a, c));\n    }\n  }\n  rep(i, n) {\n    dfs(i+1, i+1, -1, 0);\n  }\n  int q;cin >> q;\n  rep(i, q) {\n    int s, t; cin >> s >> t;\n    cout << su - maxi[s][t] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\nlong long hen;\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >ttree[4005];\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < ttree[dst].size(); i++){\n\t\t\tlong long ncost = ttree[dst][i].first;\n\t\t\tlong long next = ttree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid prepare(){\n\tset<long long> done;\n\t//                     cost  ,      src\t,     dst\n\tpriority_queue<pair<long long, pair<long long, long long> >, vector<pair<long long, pair<long long, long long> > >, greater<pair<long long, pair<long long, long long> > > > Q;\n\tQ.push(make_pair(0, make_pair(-1, 0)));\n\twhile(done.size() < N){\n\t\tlong long cost, src, dst;\n\t\tcost = Q.top().first;\n\t\tsrc = Q.top().second.first;\n\t\tdst = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tdone.insert(dst);\n\t\tif(src != -1){\n\t\t\tttree[src].push_back(make_pair(cost, dst));\n\t\t\tttree[dst].push_back(make_pair(cost, src));\n\t\t\then++;\n\t\t}\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, make_pair(dst, next)));\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tprepare();\n\t//cout << \"hen = \" << hen <<endl;\n\tif(hen > N){\n\t\treturn 1;\n\t}\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      es[i] = edge{a, b, c};\n    }\n    ll Q;\n    cin >> Q;\n    if(Q != 1) return 0;\n    ll s, t;\n    cin >> s >> t;\n    s--; t--;\n    es[M] = edge{s, t, 0};\n    ll ans = 0;\n    sort(es, es+M+1, comp);\n    UnionFind uf(N);\n    uf.initialize();\n    rep(i, M){\n      edge& e = es[i];\n      if(!uf.isSame(e.u, e.v)){\n        uf.merge(e.u, e.v);\n        ans += e.cost;\n      }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nstruct LowestCommonAncestorTreeMax {\n        const int LOGM = 30;\n        vector<int> depth, par_w;\n        vector<vector<int>> parent, parmax;\n        LowestCommonAncestorTreeMax(int root, const vector<vector<pair<int, int>>> &g) {\n                int n = g.size();\n                depth.resize(n);\n                par_w.resize(n);\n                parent.resize(LOGM);\n                parmax.resize(LOGM);\n                for (int i = 0; i < LOGM; i ++) { \n                        parent[i].resize(n);\n                        parmax[i].resize(n);\n                }\n                function<void (int, int, int)> dfs = [&](int u, int prev, int d) {\n                        parent[0][u] = prev;\n                        parmax[0][u] = par_w[u];\n                        depth[u] = d;\n                        for (auto e : g[u]) { \n                                int v = e.first;\n                                if (v != prev) { \n                                        par_w[v] = e.second;\n                                        dfs(v, u, d + 1);\n                                }\n                        }\n                };\n                dfs(root, -1, 0);\n                for (int k = 0; k < LOGM - 1; k ++) {\n                        for (int i = 0; i < n; i ++) {\n                                if (parent[k][i] < 0) { \n                                        parent[k + 1][i] = -1;\n                                } else { \n                                        parent[k + 1][i] = parent[k][parent[k][i]];\n                                        if (parent[k + 1][i] >= 0) {\n                                                parmax[k + 1][i] = max(parmax[k][i], parmax[k][parent[k][i]]);\n                                        }\n                                }\n                        }\n                }\n        }\n        int lca(int u, int v) { \n                if (depth[u] > depth[v]) swap(u, v);\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((depth[v] - depth[u]) >> k & 1) { \n                                v = parent[k][v];\n                        }\n                }\n                if (u == v) return u;\n                for (int k = LOGM - 1; k >= 0; k --) {\n                        if (parent[k][u] != parent[k][v]) {\n                                u = parent[k][u];\n                                v = parent[k][v];\n                        }\n                }\n                return parent[0][u];\n        }\n        int dist(int u, int v) {\n                return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n        }\n        int getmax(int v, int ancestor) {\n                int res = 0;\n                int d = depth[v] - depth[ancestor];\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((d >> k) & 1) {\n                                res = max(res, parmax[k][v]);\n                                v = parent[k][v];\n                        }\n                }\n                return res;\n        }\n};\n\nstruct edge {\n    int a, b, c;\n};\n\nvi par;\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return true;\n    par[x] = y;\n    return false;\n}\n\nsigned main() {\n    // freopen(\"/Users/xuzijian/atcoder/hoge/input\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int n, m;\n    cin >> n >> m;\n    vector<edge> edges;\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        edges.push_back({a, b, c});\n    }\n\n    sort(edges.begin(), edges.end(), [](edge a, edge b) {return a.c < b.c;});\n    par = vi(n + 1);\n    iota(par.begin(), par.end(), 0);\n\n    unordered_set<int> ns;\n\n    vector<vector<pair<int, int>>> adj(n);\n    i64 sum = 0;\n    for (int i = 0; i < m; i++) {\n        int x = edges[i].a, y = edges[i].b;\n        if (!unite(x, y)) {\n            ns.insert(x);\n            ns.insert(y);\n            assert(0 <= x && x < n && 0 <= y && y < n);\n            adj[x].push_back(make_pair(y, edges[i].c));\n            adj[y].push_back(make_pair(x, edges[i].c));\n            sum += edges[i].c;\n        }\n    }\n\n    LowestCommonAncestorTreeMax tree(0, adj);\n    auto maxw = [&](int s, int t) {\n        int lca = tree.lca(s, t);\n        // cout << \"lca\" << lca << endl;\n        // cout << s << \" \" << t << endl;\n        return max(tree.getmax(s, lca), tree.getmax(t, lca));\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        // cout << \"hoge\" << q << endl;\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        cout << sum - maxw(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct CentroidPathDecomposition\n{\n  struct Centroid\n  {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    Centroid(int idx, int dep, int deep) : ParIndex(idx), ParDepth(dep), Deep(deep) {}\n\n    inline size_t size()\n    {\n      return (node.size());\n    }\n\n    inline int &operator[](int k)\n    {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up()\n    {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  vector< vector< int > > graph;\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth;\n  vector< Centroid > Centroids;\n\n  void BuildSubTreeSize()\n  {\n    stack< pair< int, int > > s;\n    s.emplace(0, -1);\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      if(~SubTreeSize[p.first]) {\n        NextPath[p.first] = -1;\n        for(auto &to : graph[p.first]) {\n          if(p.second == to) continue;\n          SubTreeSize[p.first] += SubTreeSize[to];\n          if(NextPath[p.first] == -1 || SubTreeSize[NextPath[p.first]] < SubTreeSize[to]) {\n            NextPath[p.first] = to;\n          }\n        }\n      } else {\n        s.push(p);\n        SubTreeSize[p.first] = 1;\n        for(auto &to : graph[p.first]) {\n          if(p.second != to) s.emplace(to, p.first);\n        }\n      }\n    }\n  }\n\n  void BuildPath()\n  {\n    stack< pair< int, int > > s;\n    Centroids.emplace_back(-1, -1, 0);\n    s.emplace(0, -1);\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = (int) Centroids[TreeIndex[p.first]].size();\n      for(auto &to : graph[p.first]) {\n        if(p.second == to) continue;\n        if(to == NextPath[p.first]) { // Centroid-Path\n          TreeIndex[to] = TreeIndex[p.first];\n        } else {                  // Not Centroid-Path\n          TreeIndex[to] = (int) Centroids.size();\n          Centroids.emplace_back(TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1);\n        }\n        s.emplace(to, p.first);\n      }\n      Centroids[TreeIndex[p.first]].node.emplace_back(p.first);\n    }\n  }\n\n  void AddEdge(int x, int y)\n  {\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  virtual void Build()\n  {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline size_t size()\n  {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx)\n  {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid &operator[](int k)\n  {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  inline virtual void query(int a, int b, const function< void(int, int, int) > &f)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        f(TreeIdxA, 0, TreeDepthA + 1);\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        f(TreeIdxB, 0, TreeDepthB + 1);\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(TreeIdxA, TreeDepthA, TreeDepthB + 1);\n  }\n\n  CentroidPathDecomposition(int SZ)\n  {\n    graph.resize(SZ);\n    SubTreeSize.assign(SZ, -1);\n    NextPath.resize(SZ);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n  }\n};\n\nstruct TreeArray : CentroidPathDecomposition\n{\n  TreeArray(int sz) : CentroidPathDecomposition(sz) {}\n\n  vector< int > index;\n\n  void Build()\n  {\n    CentroidPathDecomposition::Build();\n    int ptr = 0;\n    for(auto &centroid : Centroids) {\n      index.emplace_back(ptr);\n      ptr += centroid.size();\n    }\n  }\n\n  inline int get(int a)\n  {\n    auto p = Information(a);\n    return (index[p.first] + p.second);\n  }\n\n  inline void query(int a, int b, const function< void(int, int) > &f)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        f(index[TreeIdxA], index[TreeIdxA] + TreeDepthA);\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        f(index[TreeIdxB], index[TreeIdxB] + TreeDepthB);\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(index[TreeIdxA] + TreeDepthA + 1, index[TreeIdxA] + TreeDepthB + 1);\n  }\n};\n\nstruct SegNode\n{\n  int v;\n\n  SegNode(int v) : v(v) {}\n\n  SegNode operator*(const SegNode &r) const\n  {\n    return (v > r.v ? *this : r);\n  }\n} e(0);\n\nstruct SegmentTree\n{\n  int sz;\n  vector< SegNode > seg;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, e);\n  }\n\n  void update(int k, const SegNode &x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = seg[2 * k + 1] * seg[2 * k + 2];\n    }\n  }\n\n  SegNode query(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (e);\n    if(a <= l && r <= b) return (seg[k]);\n    return (query(a, b, 2 * k + 1, l, (l + r) >> 1) * query(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n\n  SegNode query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n};\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nusing int64 = long long;\n\nint main()\n{\n  int N, M, Q;\n  scanf(\"%d %d\", &N, &M);\n  vector< tuple< int, int, int > > vs;\n  for(int i = 0; i < M; i++) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    --a, --b;\n    vs.emplace_back(c, a, b);\n  }\n  sort(begin(vs), end(vs));\n  UnionFind uf(N);\n  TreeArray tree(N);\n  int64 ret = 0;\n  map< pair< int, int >, int > conv;\n  for(auto &e : vs) {\n    int cost;\n    int a, b;\n    tie(cost, a, b) = e;\n    if(uf.unite(a, b)) {\n      tree.AddEdge(a, b);\n      conv[minmax(a, b)] = cost;\n      ret += cost;\n    }\n  }\n  tree.Build();\n  SegmentTree seg(N);\n  for(auto &p : conv) {\n    seg.update(max(tree.get(p.first.first), tree.get(p.first.second)), p.second);\n  }\n\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int sub = 0;\n    tree.query(--a, --b, [&](int x, int y)\n    {\n      sub = max(sub, seg.query(x, y).v);\n    });\n    printf(\"%lld\\n\", ret - sub);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \ntemplate<class T>\nstruct SparseTable{\n\tvector<T> st[21];\n\tvoid Init(int N,vector<T> data){\n\t\tif(N<=0)\n\t\t\treturn;\n\t\tint h = 1;\n\t\twhile ((1 << h) < N) h++;\n\t\tfor(int i=0;i<N;i++) st[0].push_back(data[i]);\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tfor(int i=0;i<N-(1<<j)+1;i++){\n\t\t\t\tst[j].push_back(min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]));\n\t\t\t}\n\t\t}\n\t}\n\tinline int TopBit(int t){\n\t\treturn 31-__builtin_clz(t);\n\t}\n\tT GetMin(int b,int e){\n\t\tint diff = TopBit(e-b);\n\t\treturn min(st[diff][b], st[diff][e - (1 << diff)]);\n\t}\n};\nstruct LowestCommonAncestor{\n    int N;\n    vector<int> path, depth, in_order, out_order;\n    std::vector<pair<int,int>> dat;\n\tSparseTable<pair<int,int>> table;\n\n    LowestCommonAncestor(const vector<vector<int>> G,int root)\n        : N(G.size()),\n          path(N * 2 - 1),\n          depth(N * 2 - 1),\n          in_order(N),\n          out_order(N) {\n        int k = 0;\n        dfs(G, root, -1, 0, k);\n        for (int i = 0; i < (int)depth.size(); ++i){\n            dat.push_back(make_pair(depth[i],i));\n\t\t}\n\t\ttable.Init(dat.size(),dat);\n    }\n\n    int Querry(int u,int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = table.GetMin(l,r);\n        return path[res.second];\n    }\n\n    void dfs(const vector<vector<int>> G,int v,int f,int d,int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : G[v]){\n            if (e != f) {\n                dfs(G,e,v,d+1,k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k-1;\n    }\n};\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\npair<long,pair<int,int>> Edge[400000];\nlong cost[3999];\nint leader[4000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tfor(int i=0;i<M;i++){\n\t\tint f = rei()-1;\n\t\tint t = rei()-1;\n\t\tEdge[i] = {rel(),{f,t}};\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tleader[i] = i+N-1;\n\t}\n\tsort(Edge,Edge+M);\n\tvector<vector<int>> G(2*N-1);\n\tUnionFind U(N);\n\tint c = N-2;\n\tlong ans = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint f = Edge[i].second.first;\n\t\tint t = Edge[i].second.second;\n\t\tif(!U.Same(f,t)){\n\t\t\tcost[c] = Edge[i].first;\n\t\t\tans += Edge[i].first;\n\t\t\tG[c].push_back(leader[U.Get(f)]);\n\t\t\tG[c].push_back(leader[U.Get(t)]);\n\t\t\tU.Union(f,t);\n\t\t\tleader[U.Get(f)] = c--;\n\t\t}\n\t}\n\t//LowestCommonAncestor LCA(G,0);\n\tint Q = rei();\n\tfor(int i=0;i<Q;i++){\n\t\tint s = rei()-1;\n\t\tint t = rei()-1;\n\t//\tcout << ans - cost[LCA.Querry(s+N-1,t+N-1)] << endl;;\n\t}\n\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long unsigned int ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nint parent[4005][4005];\n\nstruct path{\n    int from;\n    int to;\n    ll cost;\n};\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        return true;\n    }\n};\n\nbool comp(path a, path b){\n    if(a.cost > b.cost){\n        return true;\n    }\n    return false;\n}\n\nint main() {\n    //cout.precision(10);\n    int n, m;\n    cin >> n >> m;\n    vector<path> pathes;\n    for(int i = 0; i < m; i++){\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        struct path in;\n        in.from = a;\n        in.to = b;\n        in.cost = c;\n        pathes.push_back(in);\n    }\n    sort(pathes.begin(), pathes.end(), comp);\n    ll cost[4005];\n    UnionFind uni(n + 1);\n    ll sum = 0;\n    for(int time = 1; time <= n - 1; time++){\n        path test;\n        while(true){\n            test = pathes.back();\n            pathes.pop_back();\n            if(uni.issame(test.from, test.to)){\n                continue;\n            }\n            break;\n        }\n        cost[time] = test.cost;\n        sum += cost[time];\n        uni.merge(test.from, test.to);\n        for(int i = 1; i <= n; i++){\n            uni.root(i);\n        }\n        for(int i = 1; i <= n; i++){\n            parent[time][i] = uni.root(i);\n        }\n    }\n    int q;\n    cin >> q;\n    for(int time = 1; time <= q; time++){\n        int s, t;\n        cin >> s >> t;\n        int ok = n - 1;\n        int ng = 0;\n        while(ok - ng > 1){\n            int mid = (ok + ng) / 2;\n            if(parent[mid][s] == parent[mid][t]){\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n        cout << sum - cost[ok] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass Graph2d {\npublic:\n    typedef int numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nvector<array<int,3>> edges;\nll answer[4040][4040];\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer[start][idx] = total - wmax;\n        answer[idx][start] = total - wmax;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, (ll)graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    graph_mat.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n\n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        printer << answer[u][v] << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint root[4001];\nint del[4001][4001]={};\nint p;\nvector<pair<int,int> > graph[4001];\nint find(int x){\n\tif(x != root[x]){\n\t\troot[x]=find(root[x]);\n\t}\n\treturn root[x];\n}\n\nvoid union_set(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y){\n\t\troot[x]=y;\n\t}\n\treturn;\n}\n\nvoid dfs(int x,int y,int z){\n\tdel[p][x] = z;\n\tfor(int i=0;i<graph[x].size();i++){\n\t\tif(graph[x][i].first==y)continue;\n\t\tdfs(graph[x][i].first,x,max(z,graph[x][i].second));\n\t}\n}\n\nint main(){\n\tfor(int i=0;i<4001;i++){\n\t\troot[i] = i;\n\t}\n\tint n,m,q,a,b,s,t,c;\n\tlong long ans=0;\n\tlong long sum=0;\n\tvector<pair<long long,pair<int,int> > > node,node2;\n\tcin >> n >> m;\n\tfor(int i=0;i<m;i++){\n\t\tpair<long long,pair<int,int> > tmp;\n\t\tcin >> a >> b >> c;\n\t\ttmp = make_pair(c,make_pair(a,b));\n\t\tnode.push_back(tmp);\n\t}\n\tsort(node.begin(),node.end());\n\tfor(int i=0;i<node.size();i++){\n\t\tif(find(node[i].second.first)!=find(node[i].second.second)){\n\t\t\tsum += node[i].first;\n\t\t\tunion_set(node[i].second.first,node[i].second.second);\n\t\t\tnode2.push_back(node[i]);\n\t\t\tgraph[node[i].second.first].push_back(make_pair(node[i].second.second,node[i].first));\n\t\t\tgraph[node[i].second.second].push_back(make_pair(node[i].second.first,node[i].first));\n\t\t}\n\t}\n\tfor(p=1;p<=n;p++){\n\t\tdfs(p,-1,-1);\n\t}\n\tcin >> q;\n\tfor(int i=0;i<q;i++){\n\t\tcin >> s >> t;\n\t\tans = sum-del[s][t];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll INF = 1e18;\nll N, M;\nll cost[MAXN][MAXN];\nll mincost[MAXN];\nbool used[MAXN];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, MAXN) rep(j, MAXN) cost[i][j] = INF;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    ll Q;\n    cin >> Q;\n    if(Q != 1) return 0;\n    ll s, t;\n    cin >> s >> t;\n    s--; t--;\n    rep(i, MAXN) mincost[i] = INF;\n    rep(i, MAXN) used[i] = false;\n    cost[s][t] = 0;\n    mincost[0] = 0;\n    ll ans = 0;\n    while(true){\n      ll v = -1;\n      rep(u, N){\n        if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n      }\n      if(v == -1) break;\n      used[v] = true;\n      ans += mincost[v];\n\n      rep(u, N){\n        mincost[u] = min(mincost[u], cost[v][u]);\n      }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct CentroidPathDecomposition\n{\n  struct Centroid\n  {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    Centroid(int idx, int dep, int deep) : ParIndex(idx), ParDepth(dep), Deep(deep) {}\n\n    inline size_t size()\n    {\n      return (node.size());\n    }\n\n    inline int &operator[](int k)\n    {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up()\n    {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  vector< vector< int > > graph;\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth;\n  vector< Centroid > Centroids;\n\n  void BuildSubTreeSize()\n  {\n    stack< pair< int, int > > s;\n    s.emplace(0, -1);\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      if(~SubTreeSize[p.first]) {\n        NextPath[p.first] = -1;\n        for(auto &to : graph[p.first]) {\n          if(p.second == to) continue;\n          SubTreeSize[p.first] += SubTreeSize[to];\n          if(NextPath[p.first] == -1 || SubTreeSize[NextPath[p.first]] < SubTreeSize[to]) {\n            NextPath[p.first] = to;\n          }\n        }\n      } else {\n        s.push(p);\n        SubTreeSize[p.first] = 1;\n        for(auto &to : graph[p.first]) {\n          if(p.second != to) s.emplace(to, p.first);\n        }\n      }\n    }\n  }\n\n  void BuildPath()\n  {\n    stack< pair< int, int > > s;\n    Centroids.emplace_back(-1, -1, 0);\n    s.emplace(0, -1);\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = (int) Centroids[TreeIndex[p.first]].size();\n      for(auto &to : graph[p.first]) {\n        if(p.second == to) continue;\n        if(to == NextPath[p.first]) { // Centroid-Path\n          TreeIndex[to] = TreeIndex[p.first];\n        } else {                  // Not Centroid-Path\n          TreeIndex[to] = (int) Centroids.size();\n          Centroids.emplace_back(TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1);\n        }\n        s.emplace(to, p.first);\n      }\n      Centroids[TreeIndex[p.first]].node.emplace_back(p.first);\n    }\n  }\n\n  void AddEdge(int x, int y)\n  {\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  virtual void Build()\n  {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline size_t size()\n  {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx)\n  {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid &operator[](int k)\n  {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  inline virtual void query(int a, int b, const function< void(int, int, int) > &f)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        f(TreeIdxA, 0, TreeDepthA + 1);\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        f(TreeIdxB, 0, TreeDepthB + 1);\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(TreeIdxA, TreeDepthA, TreeDepthB + 1);\n  }\n\n  CentroidPathDecomposition(int SZ)\n  {\n    graph.resize(SZ);\n    SubTreeSize.assign(SZ, -1);\n    NextPath.resize(SZ);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n  }\n};\n\nstruct TreeArray : CentroidPathDecomposition\n{\n  TreeArray(int sz) : CentroidPathDecomposition(sz) {}\n\n  vector< int > index;\n\n  void Build()\n  {\n    CentroidPathDecomposition::Build();\n    int ptr = 0;\n    for(auto &centroid : Centroids) {\n      index.emplace_back(ptr);\n      ptr += centroid.size();\n    }\n  }\n\n  inline int get(int a)\n  {\n    auto p = Information(a);\n    return (index[p.first] + p.second);\n  }\n\n  inline void query(int a, int b, const function< void(int, int) > &f)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        f(index[TreeIdxA], index[TreeIdxA] + TreeDepthA + 1);\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        f(index[TreeIdxB], index[TreeIdxB] + TreeDepthB + 1);\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(index[TreeIdxA] + TreeDepthA + 1, index[TreeIdxA] + TreeDepthB + 1);\n  }\n};\n\nstruct SegNode\n{\n  int v;\n\n  SegNode(int v) : v(v) {}\n\n  SegNode operator*(const SegNode &r) const\n  {\n    return (v > r.v ? *this : r);\n  }\n} e(0);\n\nstruct SegmentTree\n{\n  int sz;\n  vector< SegNode > seg;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, e);\n  }\n\n  void update(int k, const SegNode &x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = seg[2 * k + 1] * seg[2 * k + 2];\n    }\n  }\n\n  SegNode query(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (e);\n    if(a <= l && r <= b) return (seg[k]);\n    return (query(a, b, 2 * k + 1, l, (l + r) >> 1) * query(a, b, 2 * k + 2, (l + r) >> 1, r));\n  }\n\n  SegNode query(int a, int b)\n  {\n    return (query(a, b, 0, 0, sz));\n  }\n};\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nusing int64 = long long;\n\nint main()\n{\n  int N, M, Q;\n  scanf(\"%d %d\", &N, &M);\n  vector< tuple< int, int, int > > vs;\n  for(int i = 0; i < M; i++) {\n    int a, b, c;\n    scanf(\"%d %d %d\", &a, &b, &c);\n    --a, --b;\n    vs.emplace_back(c, a, b);\n  }\n  sort(begin(vs), end(vs));\n  UnionFind uf(N);\n  TreeArray tree(N);\n  int64 ret = 0;\n  map< pair< int, int >, int > conv;\n  for(auto &e : vs) {\n    int cost;\n    int a, b;\n    tie(cost, a, b) = e;\n    if(uf.unite(a, b)) {\n      tree.AddEdge(a, b);\n      conv[minmax(a, b)] = cost;\n      ret += cost;\n    }\n  }\n  tree.Build();\n  SegmentTree seg(N);\n  for(auto &p : conv) {\n    seg.update(max(tree.get(p.first.first), tree.get(p.first.second)), p.second);\n  }\n\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int sub = 0;\n    tree.query(--a, --b, [&](int x, int y)\n    {\n      sub = max(sub, seg.query(x, y).v);\n    });\n    printf(\"%lld\\n\", ret - sub);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef KOMAKI_LOCAL\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n#include <sys/time.h>\n#include <unistd.h>\nusing namespace std;\n#define i64         int64_t\n#define rep(i, n)   for(i64 i = 0; i < ((i64)(n)); ++i)\n#define sz(v)       ((i64)((v).size()))\n#define bit(n)      (((i64)1)<<((i64)(n)))\n#define all(v)      (v).begin(), (v).end()\n\nstd::string dbgDelim(int &i){ return (i++ == 0 ? \"\" : \", \"); }\n#define dbgEmbrace(exp) { int i = 0; os << \"{\"; { exp; } os << \"}\"; return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> v);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q);\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp);\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp);\ntemplate <int INDEX, class TUPLE> void dbgDeploy(std::ostream &os, TUPLE tuple){}\ntemplate <int INDEX, class TUPLE, class H, class ...Ts> void dbgDeploy(std::ostream &os, TUPLE t)\n{ os << (INDEX == 0 ? \"\" : \", \") << get<INDEX>(t); dbgDeploy<INDEX + 1, TUPLE, Ts...>(os, t); }\ntemplate <class T, class K> void dbgDeploy(std::ostream &os, std::pair<T, K> p, std::string delim)\n{ os << \"(\" << p.first << delim << p.second << \")\"; }\ntemplate <class ...Ts> std::ostream& operator<<(std::ostream &os, std::tuple<Ts...> t)\n{ os << \"(\"; dbgDeploy<0, std::tuple<Ts...>, Ts...>(os, t); os << \")\"; return os; }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::pair<T, K> p)\n{ dbgDeploy(os, p, \", \"); return os; }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::vector<T> v)\n{ dbgEmbrace( for(T t: v){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::set<T> s)\n{ dbgEmbrace( for(T t: s){ os << dbgDelim(i) << t; }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.front(); }); }\ntemplate <class T> std::ostream& operator<<(std::ostream &os, std::priority_queue<T> q)\n{ dbgEmbrace( for(; q.size(); q.pop()){ os << dbgDelim(i) << q.top();   }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\ntemplate <class T, class K> std::ostream& operator<<(std::ostream &os, std::unordered_map<T, K> mp)\n{ dbgEmbrace( for(auto p: mp){ os << dbgDelim(i); dbgDeploy(os, p, \"->\"); }); }\n#define DBG_OUT std::cerr\n#define DBG_OVERLOAD(_1, _2, _3, _4, _5, _6, macro_name, ...) macro_name\n#define DBG_LINE() { char s[99]; sprintf(s, \"line:%3d | \", __LINE__); DBG_OUT << s; }\n#define DBG_OUTPUT(v) { DBG_OUT << (#v) << \"=\" << (v); }\n#define DBG1(v, ...) { DBG_OUTPUT(v); }\n#define DBG2(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG1(__VA_ARGS__); }\n#define DBG3(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG2(__VA_ARGS__); }\n#define DBG4(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG3(__VA_ARGS__); }\n#define DBG5(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG4(__VA_ARGS__); }\n#define DBG6(v, ...) { DBG_OUTPUT(v); DBG_OUT << \", \"; DBG5(__VA_ARGS__); }\n\n#define DEBUG0() { DBG_LINE(); DBG_OUT << std::endl; }\n#define DEBUG(...)                                                      \\\n  {                                                                     \\\n    DBG_LINE();                                                         \\\n    DBG_OVERLOAD(__VA_ARGS__, DBG6, DBG5, DBG4, DBG3, DBG2, DBG1)(__VA_ARGS__); \\\n    DBG_OUT << std::endl;                                               \\\n  }\n\n\n\nclass UnionFind\n{\npublic:\n  int getGroupId(int index);\n  void putTogether(int index0, int index1);\n\n  UnionFind();\n  UnionFind(int size);\n\nprivate:\n  int size;\n  std::vector<int> parents;\n};\n\ninline UnionFind::UnionFind()\n{\n}\n\ninline UnionFind::UnionFind(int size)\n{\n  this->size = size;\n  parents = std::vector<int>(size);\n  for(int i = 0; i < size; ++i){\n    parents[i] = i;\n  }\n}\n\ninline void UnionFind::putTogether(int index0, int index1)\n{\n  parents[getGroupId(index0)] = getGroupId(index1);\n}\n\ninline int UnionFind::getGroupId(int index)\n{\n  if(parents[index] == index) return index;\n  return parents[index] = getGroupId(parents[index]);\n}\n\n\n\nvoid recur(i64 root, i64 pos, i64 parent, vector<i64> &path, vector<unordered_map<i64, vector<i64>>> &queries, vector<i64> &ans, vector<vector<pair<i64, i64>>> &edges)\n{\n  if(queries[root].count(pos)){\n    i64 maxi = 0;\n    for(i64 t: path) maxi = max(maxi, t);\n    for(i64 index: queries[root][pos]) ans[index] = maxi;\n  }\n  for(pair<i64, i64> edge: edges[pos]){\n    if(edge.first == parent) continue;\n    path.push_back(edge.second);\n    recur(root, edge.first, pos, path, queries, ans, edges);\n    path.pop_back();\n  }\n}\n\nint main()\n{\n  i64 n, m, q;\n  i64 total_edge_cost = 0;\n  cin >> n >> m;\n  vector<pair<i64, pair<i64, i64>>> raw_edges(m);\n  rep(i, m) cin >> raw_edges[i].second.first >> raw_edges[i].second.second >> raw_edges[i].first;\n  rep(i, m) --raw_edges[i].second.first;\n  rep(i, m) --raw_edges[i].second.second;\n  sort(all(raw_edges));\n  UnionFind uf(n);\n  vector<vector<pair<i64, i64>>> edges(n);\n  //DEBUG0();\n  for(auto edge: raw_edges){\n    if(uf.getGroupId(edge.second.first) == uf.getGroupId(edge.second.second)) continue;\n    uf.putTogether(edge.second.first, edge.second.second);\n    total_edge_cost += edge.first;\n    edges[edge.second.first].push_back(make_pair(edge.second.second, edge.first));\n    edges[edge.second.second].push_back(make_pair(edge.second.first, edge.first));\n  }\n  //DEBUG0();\n  cin >> q;\n  vector<unordered_map<i64, vector<i64>>> queries(n);\n  rep(i, q){\n    i64 a, b;\n    cin >> a >> b;\n    queries[a - 1][b - 1].push_back(i);\n  }\n  vector<i64> ans(q, -1);\n\n\n  rep(root, n){\n    vector<i64> path;\n    recur(root, root, -1, path, queries, ans, edges);\n  }\n\n  rep(i, sz(ans)) cout << total_edge_cost - ans[i] << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string> \n#include <vector>\n#include <bitset>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n\nusing namespace std;\nusing ll = long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll LLINF = (ll)1e18;\nconst ll INTINF = (ll)1e9;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) { if (flg) { cout << hoge << endl; exit(0); } }\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) { o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o; }\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) { o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o; }\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) { o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o; }\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) { o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o; }\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) { o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o; }\nvoid print(void) { cout << endl; }\ntemplate <class Head> void print(Head&& head) { cout << head; print(); }\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) { cout << head << \" \"; print(forward<Tail>(tail)...); }\n\nvoid YN(bool flg) { cout << ((flg) ? \"YES\" : \"NO\") << endl; }\nvoid Yn(bool flg) { cout << ((flg) ? \"Yes\" : \"No\") << endl; }\nvoid yn(bool flg) { cout << ((flg) ? \"yes\" : \"no\") << endl; }\n\n//Union Find Tree\nclass Union_Find_Tree {\npublic:\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tUnion_Find_Tree(int N = 1) : parent(N), rank(N, 0) {\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n\n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n\tbool same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n\n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif (rank[n]<rank[m]) {\n\t\t\tparent[n] = m;\n\t\t}\n\t\telse {\n\t\t\tparent[m] = n;\n\t\t\tif (rank[n] == rank[m]) rank[n]++;\n\t\t}\n\t}\n};\n\nclass Lowest_Common_Ancestor {\npublic:\n\tint N, MAX_bit;\n\tvector<vector<int>> edge;\n\tvector<int> depth;\n\tvector<vector<int>> parent;\n\tvector<vector<int>> child;\n\tvector<vector<int>> descendant;\n\n\tLowest_Common_Ancestor(int N, int MAX_bit = 20) :N(N), MAX_bit(MAX_bit), edge(N), depth(N, -1), parent(N, vector<int>(MAX_bit)), child(N), descendant(N) {\n\t\t//do nothing\n\t}\n\n\t//O(1)\n\tvoid make_edge(int from, int to) {\n\t\tedge[from].push_back(to);\n\t}\n\n\t//O(N)\n\tvoid make_depth(int root) {\n\t\tqueue<int> q;\n\t\tdepth[root] = 0;\n\t\tq.push(root);\n\t\twhile (q.size()) {\n\t\t\tint from = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto to : edge[from]) {\n\t\t\t\tif (depth[to] != -1) continue;\n\t\t\t\tdepth[to] = depth[from] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\t//O(MAX_bit*N)\n\tvoid make_parent() {\n\t\tfor (int i = 0; i < N; ++i) parent[i][0] = i;\n\t\tfor (int i = 0; i < N; ++i) for (auto j : edge[i]) if (depth[i] > depth[j]) parent[i][0] = j;\n\t\tfor (int bit = 1; bit < MAX_bit; ++bit) for (int i = 0; i < N; ++i) parent[i][bit] = parent[parent[i][bit - 1]][bit - 1];\n\t}\n\n\t//O(N)\n\tvoid make_child() {\n\t\tfor (int i = 0; i < N; ++i) for (auto j : edge[i]) if (depth[i] < depth[j]) child[i].push_back(j);\n\t}\n\n\t//O(N^2)\n\tvoid make_descendant() {\n\t\tvector<pair<int, int>> ord(N);\n\t\tfor (int i = 0; i < N; ++i) ord[i] = { depth[i],i };\n\t\tsort(ord.begin(), ord.end(), greater<>());\n\t\tfor (int i = 0; i < N; ++i) descendant[i].push_back(i);\n\t\tfor (int i = 0; i < N; ++i) for (auto j : edge[ord[i].second]) if (depth[ord[i].second] < depth[j]) for (auto k : descendant[j]) descendant[ord[i].second].push_back(k);\n\t}\n\n\t//O(MAX_bit*logN)\n\tint lca(int l, int r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (diff & (1 << bit)) l = parent[l][bit];\n\t\tint ok = (1 << MAX_bit), ng = -1, md;\n\t\twhile (ok - ng>1) {\n\t\t\tmd = (ok + ng) / 2;\n\t\t\tint x = l, y = r;\n\t\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (md & (1 << bit)) x = parent[x][bit];\n\t\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (md & (1 << bit)) y = parent[y][bit];\n\t\t\t(x == y ? ok : ng) = md;\n\t\t}\n\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (ok & (1 << bit)) l = parent[l][bit];\n\t\treturn l;\n\t}\n\n\tvoid print() {\n\t\tcout << \" depth { \" << depth[0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << depth[i];\n\t\tcout << \" }\" << endl;\n\n\t\tcout << \"parent { \" << parent[0][0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << parent[i][0];\n\t\tcout << \" }\" << endl;\n\n\t\tcout << \" child { \" << child[0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << child[i];\n\t\tcout << \" }\" << endl;\n\n\t\tcout << \"descen { \" << descendant[0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << descendant[i];\n\t\tcout << \" }\" << endl;\n\t}\n\n};\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tUnion_Find_Tree uf(N);\n\tV<int> a(M), b(M);\n\tV<ll> c(M);\n\tV<P<ll, int>> ord(M);\n\tfor(int i = 0; i < M; ++i){\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\ta[i]--, b[i]--;\n\t\tord[i] = { c[i],i };\n\t}\n\tsort(ALL(ord));\n\n\tLowest_Common_Ancestor tree(N);\n\tll sum = 0;\n\tfor (int i = 0; i < M; ++i){\n\t\tint j = ord[i].second;\n\t\tif (uf.same(a[j], b[j])) {\n\t\t\ta[j] = b[j] = -1;\n\t\t}\n\t\telse {\n\t\t\tuf.unite(a[j], b[j]);\n\t\t\tsum += c[j];\n\t\t\ttree.make_edge(a[j], b[j]);\n\t\t\ttree.make_edge(b[j], a[j]);\n\t\t}\n\t}\n\ttree.make_depth(0);\n\tV<V<int>> edge(N, V<int>(20,0));\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (a[i] == -1 || b[i] == -1) continue;\n\t\tif (tree.depth[a[i]] < tree.depth[b[i]]) swap(a[i], b[i]);\n\t\tedge[a[i]][0] = c[i];\n\t}\n\n\ttree.make_parent();\n\tfor (int bit = 1; bit < 20; ++bit) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tedge[i][bit] = max(edge[tree.parent[i][bit - 1]][bit - 1], edge[i][bit - 1]);\n\t\t}\n\t}\n\tint Q; cin >> Q;\n\tV<ll> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tif (tree.depth[s] < tree.depth[t]) swap(s, t);\n\t\tint u = tree.lca(s, t);\n\t\tint ds = tree.depth[s] - tree.depth[u];\n\t\tint dt = tree.depth[t] - tree.depth[u];\n\t\tint es = 0;\n\t\tint et = 0;\n\t\tfor (int bit = 0; bit < 20; ++bit) if (ds & (1 << bit)) {\n\t\t\tes = max(es, edge[s][bit]);\n\t\t\ts = tree.parent[s][bit];\n\t\t}\n\t\tfor (int bit = 0; bit < 20; ++bit) if (dt & (1 << bit)) {\n\t\t\tet = max(et, edge[t][bit]);\n\t\t\tt = tree.parent[t][bit];\n\t\t}\n\t\tans[i] = sum - max(es, et);\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nint A[404040],B[404040];\nll C[404040];\nvector<pair<int,int>> E[4040];\nint Q;\nll D[4040][4040];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<500000> uf;\n\nvoid dfs(int st,int cur,int pre,int ma) {\n\tD[st][cur]=ma;\n\tFORR(e,E[cur]) if(e.first != pre) {\n\t\tdfs(st,e.first,cur,max(ma,e.second));\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tpriority_queue<pair<int,int>> EE;\n\tFOR(i,M) {\n\t\tcin>>A[i]>>B[i]>>C[i], A[i]--, B[i]--;\n\t\tEE.push({-C[i],i});\n\t}\n\t\n\tll tot=0;\n\twhile(EE.size()) {\n\t\tauto e=EE.top();\n\t\tx = A[e.second];\n\t\ty = B[e.second];\n\t\tEE.pop();\n\t\tif(uf[x]!=uf[y]) {\n\t\t\tuf(x,y);\n\t\t\tE[x].push_back({y,-e.first});\n\t\t\tE[y].push_back({x,-e.first});\n\t\t\ttot+=-e.first;\n\t\t}\n\t}\n\t\n\tFOR(i,N) dfs(i,i,-1,0);\n\t\n\tcin>>M;\n\tFOR(i,M) {\n\t\tcin>>x>>y;\n\t\tcout<<tot-D[x-1][y-1]<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"inspect.hpp\"\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nGraph opt; //optimal edges for minimum-spanning\nvector<vector<int>> max_edge;\nWeight minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) /*if (u < e->dst)*/ Q.push(*e);\n  UnionFind uf(n);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n      opt[e.src].emplace_back(e.src,e.dst,e.weight);\n      opt[e.dst].emplace_back(e.dst,e.src,e.weight);\n    }\n  }\n  return total; //pair<Weight, Edges>(total, F);\n}\n\nvoid dfs(int z,int c,long long k,vector<int>&v){\n\tmax_edge[z][c]=k;\n\tv[c]=1;\n\tfor(auto &e:opt[c])if(!v[e.dst])dfs(z,e.dst,max(k,e.weight),v);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\topt.resize(N);\n\tWeight w;\n\t{\n\t\tGraph g(N);\n\t\tfor(;M--;){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\t}\n\t\tw=minimumSpanningForest(g);\n\t}\n\tmax_edge.resize(N);\n\tfor(int i=0;i<N;i++)max_edge[i].resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tvector<int>v(N);\n\t\tdfs(i,i,0,v);\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tprintf(\"%lld\\n\",w-max_edge[a-1][b-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<ll>> tree(N);\n\tUnionFindTree uf(N);\n\tif(N==1){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tusing t = pair<ll,pair<int,int>>;\n\tpriority_queue<t,vector<t>,greater<>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tll c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth(0);\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<int> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAX_V = 5000;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    tuple<ll, int, int> edges[M];\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = make_tuple(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    vector<pair<int, ll>> path[N];\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(make_pair(b, c));\n        path[b].push_back(make_pair(a, c));\n    }\n\n    ll emax[N][N];\n    // emax[i][j] = iからjのパス上で最大コストの辺のコスト\n\n    // 各頂点始点のBFS\n    for (int r = 0; r < N; ++r) {\n        fill(emax[r], emax[r] + N, -1);\n        emax[r][r] = 0;\n        queue<int> que;\n        que.push(r);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n\n            for (auto p : path[v]) {\n                int sv;\n                ll cost;\n                tie(sv, cost) = p;\n\n                if (emax[r][sv] >= 0) continue;\n                emax[r][sv] = max(emax[r][v], cost);\n                que.push(sv);\n            }\n        }\n    }\n\n    // クエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        cout << total - emax[--s][--t] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define test cout<<\"test\"<<endl;\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nvoid chmin(T &a,T b){if(a>b)a=b;}\ntemplate<typename T>\nvoid chmax(T &a,T b){if(a<b)a=b;}\nvoid pmod(ll &a,ll b){a=(a+b)%MOD;}\nvoid pmod(ll &a,ll b,ll c){a=(b+c)%MOD;}\nvoid qmod(ll &a,ll b){a=(a*b)%MOD;}\nvoid qmod(ll &a,ll b,ll c){a=(b*c)%MOD;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nostream &operator<<(ostream &os, pair<ll, ll>&p){\n  return os << p.first << \" \" << p.second;\n}  \nstruct UnionFind {\n  vector<ll> data;\n  ll num;\n  UnionFind(ll size) : data(size, -1) ,num(size){ }\n  bool unite(ll x, ll y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n\t  num--;\n    }\n    return x != y;\n  }\n  bool find(ll x, ll y) {\n    return root(x) == root(y);\n  }\n  ll root(ll x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  ll size(ll x) {\n    return -data[root(x)];\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  UnionFind uf(n);\n  auto ret=vec(n,n,0LL);\n  vector<tuple<ll,ll,ll>>e;\n  rep(i,0,m){\n    ll a,b,c;cin>>a>>b>>c;a--;b--;\n    e.EB(c,a,b);\n  }\n  sort(ALL(e));\n  for(auto z:e){\n    ll u,v,w;tie(w,u,v)=z;\n    if(uf.find(u,v))continue;\n    res+=w;\n    vector<ll>v1,v2;\n    rep(i,0,n){\n      if(uf.find(u,i))v1.PB(i);\n      if(uf.find(v,i))v2.PB(i);\n    }\n    for(auto k1:v1)for(auto k2:v2){\n      ret[k1][k2]=w;\n      ret[k2][k1]=w;\n    }\n    uf.unite(u,v);\n  }\n  ll q;cin>>q;\n  while(q--){\n    ll u,v;cin>>u>>v;u--;v--;\n    cout<<res-ret[u][v]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nstruct LowestCommonAncestorTreeMax {\n        const int LOGM = 30;\n        vector<int> depth, par_w;\n        vector<vector<int>> parent, parmax;\n        LowestCommonAncestorTreeMax(int root, const vector<vector<pair<int, int>>> &g) {\n                int n = g.size();\n                depth.resize(n);\n                par_w.resize(n);\n                parent.resize(LOGM);\n                parmax.resize(LOGM);\n                for (int i = 0; i < LOGM; i ++) { \n                        parent[i].resize(n);\n                        parmax[i].resize(n);\n                }\n                function<void (int, int, int)> dfs = [&](int u, int prev, int d) {\n                        parent[0][u] = prev;\n                        parmax[0][u] = par_w[u];\n                        depth[u] = d;\n                        for (auto e : g[u]) { \n                                int v = e.first;\n                                if (v != prev) { \n                                        par_w[v] = e.second;\n                                        dfs(v, u, d + 1);\n                                }\n                        }\n                };\n                dfs(root, -1, 0);\n                for (int k = 0; k < LOGM - 1; k ++) {\n                        for (int i = 0; i < n; i ++) {\n                                if (parent[k][i] < 0) { \n                                        parent[k + 1][i] = -1;\n                                } else { \n                                        parent[k + 1][i] = parent[k][parent[k][i]];\n                                        if (parent[k + 1][i] >= 0) {\n                                                parmax[k + 1][i] = max(parmax[k][i], parmax[k][parent[k][i]]);\n                                        }\n                                }\n                        }\n                }\n        }\n        int lca(int u, int v) { \n                if (depth[u] > depth[v]) swap(u, v);\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((depth[v] - depth[u]) >> k & 1) { \n                                v = parent[k][v];\n                        }\n                }\n                if (u == v) return u;\n                for (int k = LOGM - 1; k >= 0; k --) {\n                        if (parent[k][u] != parent[k][v]) {\n                                u = parent[k][u];\n                                v = parent[k][v];\n                        }\n                }\n                return parent[0][u];\n        }\n        int dist(int u, int v) {\n                return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n        }\n        int getmax(int v, int ancestor) {\n                int res = 0;\n                int d = depth[v] - depth[ancestor];\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((d >> k) & 1) {\n                                res = max(res, parmax[k][v]);\n                                v = parent[k][v];\n                        }\n                }\n                return res;\n        }\n};\n\nstruct edge {\n    int a, b, c;\n};\n\nvi par;\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return true;\n    par[x] = y;\n    return false;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int n, m;\n    cin >> n >> m;\n    vector<edge> edges;\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.push_back({a - 1, b - 1, c});\n    }\n\n    sort(edges.begin(), edges.end(), [](edge a, edge b) {return a.c < b.c;});\n    par = vi(n);\n    iota(par.begin(), par.end(), 0);\n\n    unordered_set<int> ns;\n\n    vector<vector<pair<int, int>>> adj(n);\n    i64 sum = 0;\n    for (int i = 0; i < m && ns.size() < n; i++) {\n        int x = edges[i].a, y = edges[i].b;\n        if (!unite(x, y)) {\n            ns.insert(x);\n            ns.insert(y);\n            adj[x].push_back(make_pair(y, edges[i].c));\n            adj[y].push_back(make_pair(x, edges[i].c));\n            sum += edges[i].c;\n        }\n    }\n\n    LowestCommonAncestorTreeMax tree(0, adj);\n    auto maxw = [&](int s, int t) {\n        int lca = tree.lca(s, t);\n        return max(tree.getmax(s, lca), tree.getmax(t, lca));\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        cout << sum - maxw(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\nint n, m;\nint cost[4005][4005];\n\nclass UnionFind {\n    public:\n        vector<int> parent, rank;\n        vector<vector<int>> group;\n        UnionFind(int size) {\n            group.resize(size);\n            for (int i = 0; i < size; i++) {\n                parent.push_back(i);\n                rank.push_back(0);\n                group[i].push_back(i);\n            }\n        }\n\n        int findset(int x) {\n            return x == parent[x] ? x : parent[x] = findset(parent[x]);\n        }\n\n        void unite(int x, int y, int c) {\n            x = findset(x); y = findset(y);\n            if (x == y) return;\n            if (rank[x] > rank[y]) swap(x, y);\n            parent[x] = y;\n            for (auto nodey : group[y]) {\n                for (auto nodex : group[x]) {\n                    cost[nodey][nodex] = c;\n                    cost[nodex][nodey] = c;\n                }\n            }\n            for (auto ch : group[x]) {\n                group[y].push_back(ch);\n            }\n            if (rank[x] == rank[y]) rank[y] += 1;\n        }\n\n        bool same(int x, int y) {\n            return findset(x) == findset(y);\n        }\n};\n\nstruct edge {ll cost, u, v;};\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nvector<edge> es;\n\nll kruskal(int v, int e, vector<edge> es) {//vは頂点数,eは辺数\n    sort(all(es), comp);   //esは[辺の重み,辺の端点1,辺の端点2]\n    UnionFind node(v);\n    ll ret = 0;\n    for (int i = 0; i < e; i++) {\n        edge e = es[i];\n        if (!node.same(e.u, e.v)) {\n            ret += e.cost;\n            node.unite(e.u, e.v, e.cost);\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        es.push_back(edge{c, a, b});\n    }\n    int total = kruskal(n, m, es);\n    int q;\n    cin >> q;\n    rep(i, q) {\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        cout << total - cost[s][t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long i64;\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nstruct PartialPersistentUnionFind {\n\tstd::vector<std::vector<std::pair<int, int>>> history;\n\tstd::vector<int> data, time;\n\tint now = 0;\n\t\n\tPartialPersistentUnionFind(int n) {\n\t\thistory.assign(n, std::vector<std::pair<int, int>>(1, {0, -1}));\n\t\ttime.assign(n, 1 << 30);\n\t\tdata.assign(n, -1);\n\t\tnow = 0;\n\t}\n\t\n\tint unite(int x, int y) {\n\t\tx = find(++now, x);\n\t\ty = find(now, y);\n\t\tif(x == y) return now;\n\t\tif(data[x] > data[y]) std::swap(x, y);\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t\thistory[x].push_back({now, data[x]});\n\t\ttime[y] = now;\n\t\treturn now;\n\t}\n\t\n\tint find(int t, int k) {\n\t\tif(time[k] > t) return k;\n\t\treturn find(t, data[k]);\n\t}\n\t\n\tbool same(int t, int x, int y) {\n\t\treturn find(t, x) == find(t, y);\n\t}\n\t\n\tint size(int t, int x) {\n\t\tx = find(t, x);\n\t\treturn -std::prev(lower_bound(begin(history[x]), end(history[x]), std::make_pair(t, 0)))->second;\n\t}\n};\n\nint main(){\n\tint n, m; cin >> n >> m;\n\tstd::vector<std::pair<int, std::pair<int, int>>> vec(m);\n\tfor(int i = 0; i < m; i++) cin >> vec[i].second.first >> vec[i].second.second >> vec[i].first;\n\tsort(begin(vec), end(vec));\n\t\n\tint now = 1;\n\ti64 cost = 0;\n\tstd::vector<int> pos;\n\tPartialPersistentUnionFind uf(n);\n\tfor(int i = 0; i < m; i++) {\n\t\ti64 c = vec[i].first;\n\t\tauto p = vec[i].second;\n\t\tint x = p.first - 1, y = p.second - 1;\n\t\t\n\t\tif(uf.same(now, x, y)) continue;\n\t\tuf.unite(x, y); ++now;\n\t\tpos.push_back(c);\n\t\tcost += c;\n\t}\n\t\n\tint q; cin >> q;\n\twhile(q--) {\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\t\n\t\tint ok = 0, ng = now;\n\t\twhile(std::abs(ok - ng) > 1) {\n\t\t\tint mid = (ok + ng) / 2, sz = -1;\n\t\t\t\n\t\t\tif(!uf.same(mid, x, y)) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\t\n\t\tcout << cost - pos[ok] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<unordered_map>\nusing namespace std;\n#define MOD 1000000007\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//sortは初期で昇順 greater<hoge>()で降順\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(Graph & G, ll s, ll t)\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll Pow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nll dfs(Graph &graph, ll v, ll ma, ll obj,Array &used) {\n\tused[v] = 1;\n\tREP(i, graph[v].size()) {\n\t\tif (used[graph[v][i].to] == 0) {\n\t\t\tif (graph[v][i].to == obj) {\n\t\t\t\treturn max(ma, graph[v][i].cap);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll ret = dfs(graph, graph[v][i].to, max(ma, graph[v][i].cap), obj, used);\n\t\t\t\tif (ret) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main() {\n\tll n, m;\n\tcin >> n >> m;\n\tUnionFind uni(n);\n\tvector<pair<ll, P>> edge(m);\n\tll total = 0;\n\tREP(i, m) {\n\t\tcin >> edge[i].second.first >> edge[i].second.second >> edge[i].first;\n\t\tedge[i].second.first--; edge[i].second.second--;\n\t}\n\tsort(all(edge));\n\tGraph graph(n);\n\tREP(i, m) {\n\t\tif (uni.root(edge[i].second.first) != uni.root(edge[i].second.second)) {\n\t\t\tadd_edge(graph, edge[i].second.first, edge[i].second.second, edge[i].first, true, edge[i].first);\n\t\t\tuni.unionSet(edge[i].second.first, edge[i].second.second);\n\t\t\ttotal += edge[i].first;\n\t\t}\n\t}\n\tll q;\n\tcin >> q;\n\tREP(i, q) {\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tArray used(n, 0);\n\t\tcout << total- dfs(graph, s - 1, 0, t - 1, used) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[125252];             // グラフ\nint depth[125252];        // 根付き木の深さ\nint par[125252];\nint query[125252];\n\nint data[125252];\nint init(){\n  REP(i,125252)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n      }\n    }\n  }\n\n  queue<int> Q;\n\n  REP(i,n) depth[i]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      par[to] = pos;\n      Q.push(to);\n      query[to] = c;\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    while(depth[b]!=depth[a]){\n      CHMIN(x,(ll)query[b]);\n      b = par[b];\n      if(rand()%8==0)break;\n    }\n    while(par[a]!=par[b]){\n      CHMIN(x,(ll)query[a]);\n      CHMIN(x,(ll)query[b]);\n      a=par[a];b=par[b];\n    }\n    if(a!=b){\n      CHMIN(x,(ll)query[a]);\n      CHMIN(x,(ll)query[b]);\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a});\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  //int start = 0;\n  cost += g[0][0][0];\n  uf.unite(0, g[0][0][1]);\n  maxcost[0][g[0][0][1]] = maxcost[g[0][0][1]][0] = g[0][0][0];\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  cand.insert(all(g[g[0][0][1]]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    if (uf.same(edge[1], edge[2])) {\n      cand.erase(begin(cand));\n      continue;\n    }\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nGraph opt; //optimal edges for minimum-spanning\nvector<vector<int>> max_edge;\nWeight minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  priority_queue<Edge> Q;\n  for(int u=0;u<n;u++) for(auto &e: g[u]) /*if (u < e->dst)*/ Q.push(e);\n  UnionFind uf(n);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n      opt[e.src].emplace_back(e.src,e.dst,e.weight);\n      opt[e.dst].emplace_back(e.dst,e.src,e.weight);\n    }\n  }\n  return total; //pair<Weight, Edges>(total, F);\n}\n\nvoid dfs(int z,int c,long long k,vector<int>&v){\n\tmax_edge[z][c]=k;\n\tv[c]=1;\n\tfor(auto &e:opt[c])if(!v[e.dst])dfs(z,e.dst,max(k,e.weight),v);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\topt.resize(N);\n\tWeight w;\n\t{\n\t\tGraph g(N);\n\t\tfor(;M--;){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\t}\n\t\tw=minimumSpanningForest(g);\n\t}\n\tmax_edge.resize(N);\n\tfor(int i=0;i<N;i++)max_edge[i].resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tvector<int>v(N);\n\t\tdfs(i,i,0,v);\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tprintf(\"%lld\\n\",w-max_edge[a-1][b-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nll unipar[4010];\nll unilen[4010];\nvector<pll> vn[4010];\nstruct edge{\n  ll len,from,to;\n};\nbool cmp(edge& a,edge& b){\n  return a.len<b.len;\n}\nvoid uniinit(ll n){\n  for(ll i=1;i<=n;i++){\n    unipar[i]=i;\n    unilen[i]=0;\n  }\n}\nll root(ll n){\n  if(unipar[n]==n)return n;\n  return unipar[n]=root(unipar[n]);\n}\nvoid unit(ll a,ll b){\n  a=root(a);\n  b=root(b);\n  if(a==b)return;\n  if(unilen[a]<unilen[b]){\n    unipar[a]=b;\n  }\n  else{\n    unipar[b]=a;\n    if(unipar[b]==unipar[a])unilen[a]++;\n  }\n}\nll ne;\nll par[60][4010];\nll dep[60];\nvoid lcadfs(ll v,ll p,ll d){\n  par[0][v]=p;\n  dep[v]=d;\n  for(ll i=0;i<vn[v].size();i++){\n    if(vn[v][i].first!=p)lcadfs(vn[v][i].first,v,d+1);\n  }\n}\nvoid lcainit(ll n){\n  lcadfs(ne,-1,0);\n  for(ll i=0;i<59;i++){\n    for(ll j=1;j<=n;j++){\n      if(par[i][j]<0)par[i+1][j]=-1;\n      else par[i+1][j]=par[i][par[i][j]];\n    }\n  }\n}\nll lca(ll u,ll v){\n  if(dep[u]>dep[v])swap(u,v);\n  for(ll i=0;i<60;i++){\n    if((dep[v]-dep[u])>>i&1)v=par[i][v];\n  }\n  if(u==v)return u;\n  for(ll i=59;i>=0;i--){\n    if(par[i][u]!=par[i][v]){\n      u=par[i][u];\n      v=par[i][v];\n    }\n  }\n  return par[0][u];\n}\nll mae[60][4010];\nvoid maedfs(ll v,ll p,ll dis){\n  mae[0][v]=dis;\n  for(ll i=0;i<vn[v].size();i++){\n    if(vn[v][i].first!=p)maedfs(vn[v][i].first,v,vn[v][i].second);\n  }\n}\nvoid maeinit(ll n){\n  maedfs(ne,-1,-1);\n  for(ll i=0;i<59;i++){\n    for(ll j=1;j<=n;j++){\n      if(par[i][j]<0)mae[i+1][j]=-1;\n      else mae[i+1][j]=max(mae[i][j],mae[i][par[i][j]]);\n    }\n  }\n}\nll maxedge(ll u,ll v){\n  ll r=lca(u,v);\n  ll ret=0;\n  for(ll i=59;i>=0;i--){\n    if((dep[u]-dep[r])>>i&1){\n      ret=max(ret,mae[i][u]);\n      u=par[i][u];\n    }\n  }\n  for(ll i=59;i>=0;i--){\n    if((dep[v]-dep[r])>>i&1){\n      ret=max(ret,mae[i][v]);\n      v=par[i][v];\n    }\n  }\n  return ret;\n}\nint main(){\n  ll n,m;cin>>n>>m;\n  vector<edge> v;\n  for(ll i=0;i<m;i++){\n    ll a,b,c;cin>>a>>b>>c;\n    v.push_back((edge){c,a,b});\n  }\n  sort(v.begin(),v.end(),cmp);\n  uniinit(n);\n  ll now=0;\n  ll sum=0;\n  for(ll i=0;i<m;i++){\n    edge e=v[i];\n    ll a=e.from,b=e.to;\n    if(root(a)!=root(b)){\n      unit(a,b);\n      sum+=e.len;\n      vn[a].push_back(make_pair(b,e.len));\n      vn[b].push_back(make_pair(a,e.len));\n      now++;\n    }\n    if(now==n-1)break;\n  }\n  ne=1;\n  lcainit(n);\n  maeinit(n);\n  ll q;cin>>q;\n  for(ll i=0;i<q;i++){\n    ll s,t;cin>>s>>t;\n    ll dd=maxedge(s,t);\n    cout<<sum-dd<<endl;\n  }\n  //cout<<maxedge(5,7)<<endl;\n  for(ll i=0;i<10;i++){\n    //for(ll j=1;j<=7;j++)cout<<mae[i][j]<<\" \";\n    //cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n}\nMaiScanner scanner;\n\n\nclass Graph2d {\npublic:\n    typedef ll numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nvoid warshall_floyd(Graph2d& g) {\n    int i, j, k;\n    for (i = 0; i < g.n; i++) {\n        for (j = 0; j < g.n; j++) {\n            for (k = 0; k < g.n; k++) {\n                g(j, k) = min(g(j, k), g(j, i) + g(i, k));\n            }\n        }\n    }\n}\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nGraph graph(1);\nvector<vector<ll>> edges;\nunordered_map<ll,ll> ans;\n\ninline ll& answer(ll x, ll y) { return x > y ? answer(y, x) : ans[(x << 16) | y]; }\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer(start,idx) = total - wmax;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    graph_mat.resize(n);\n    graph.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        graph.connect(a, b);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n\n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        cout << answer(u, v) << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 998244353\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint n, m, Q;\nvector<E> vec;\nvector<edge> G[4005];\nUnionFind uf(4005);\nllint dist[4005][4005];\n\nvoid dfs(int v, int p, llint m, llint s)\n{\n\tdist[s][v] = m;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i].to == p) continue;\n\t\tdfs(G[v][i].to, v, max(m, G[v][i].cost), s);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tllint u, v, w;\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u >> v >> w;\n\t\tvec.push_back(E(w, P(u, v)));\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tw = vec[i].first, u = vec[i].second.first, v = vec[i].second.second;\n\t\tif(uf.same(u, v)) continue;\n\t\tuf.unite(u, v);\n\t\tans += w;\n\t\tG[u].push_back(edge(v, w));\n\t\tG[v].push_back(edge(u, w));\n\t}\n\t\n\tfor(int i = 1; i <= n; i++) dfs(i, -1, 0, i);\n\t\n\tcin >> Q;\n\tllint s, t;\n\tfor(int i = 1; i <= Q; i++){\n\t\tcin >> s >> t;\n\t\tcout << ans - dist[s][t] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[125252];             // グラフ\nint depth[125252];        // 根付き木の深さ\nint par[125252];\nint query[125252];\n\nint data[125252];\nint init(){\n  REP(i,125252)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n      }\n    }\n  }\n\n  queue<int> Q;\n\n  REP(i,n) depth[i]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      par[to] = pos;\n      Q.push(to);\n      query[to] = c;\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    while(depth[b]!=depth[a]){\n      CHMIN(x,(ll)query[b]);\n      b = par[b];\n    }\n    while(par[a]!=par[b]){\n      CHMIN(x,(ll)query[a]);\n      CHMIN(x,(ll)query[b]);\n      a=par[a];b=par[b];\n    }\n    if(a!=b){\n      CHMIN(x,(ll)query[a]);\n      CHMIN(x,(ll)query[b]);\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\n//{{{ Graph<Weight> g(size); addEdge(g,{src,dst},weight); matrix<Weight> A(n,m);\ntypedef int Node;\ntemplate<class Weight>\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tedge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev){ }\n};\ntemplate<class Weight>\nbool operator < (const edge<Weight> &e, const edge<Weight> &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n//typedef vector<edge> edges;\n//typedef vector<edges> Graph;\n \ntemplate<class Weight>\nstruct matrix:vector<vector<Weight> >{\n\tmatrix(const array<int,2> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[1],w)){}\n\tmatrix(const array<int,1> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[0],0)){}\n\tmatrix(){}\n};\n \ntemplate<class Weight>\nstruct graph:vector<vector<edge<Weight> > >{\n\tWeight inf{::inf<Weight>()};\n\tgraph(){}\n\tgraph(const int &n):vector<vector<edge<Weight> > >(n){}\n\tvoid _add_edge(int from, int to, Weight w, int rev=-1){\n\t\tif((int)this->size() < from + 1)this->resize(from + 1);\n\t\tthis->at(from).push_back(edge<Weight>(from,to,w,rev));\n\t}\n};\n//add bi-directional edge\ntemplate<class Weight>\nvoid addBiEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w,g[to].size());\n\tg._add_edge(to,from,w,g[from].size()-1);\n}\n//add directional edge\ntemplate<class Weight>\nvoid addEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w);\n}\n \n\n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\ntypedef Int Weight;\ntypedef edge<Weight> Edge;\ntypedef vector<edge<Weight> > Edges;\ntypedef graph<Weight> Graph;\ntypedef matrix<Weight> Matrix;\n\n//{{{ HLDecomposition\nstruct HLDecomposition {\n\tconst Graph &G;\n\tint n,pos;\n\tvector<int> vid, head, sub, hvy, par, dep, inv, type;\n\n//\tHLDecomposition(){}\n\tHLDecomposition(const Graph &G):\n\t\tG(G), n(G.size()),pos(0),\n\t\tvid(n,-1),head(n),sub(n,1),hvy(n,-1),\n\t\tpar(n),dep(n),inv(n),type(n){}\n\n\t/*\n\tvoid add_edge(int u, int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t*/\n\n\tvoid build(vector<int> rs=vector<int>(1,0)) {\n\t\tint c=0;\n\t\tfor(int r:rs){\n\t\t\tdfs(r);\n\t\t\tbfs(r, c++);\n\t\t}\n\t}\n\n\tvoid dfs(int rt) {\n\t\tusing T = pair<int,int>;\n\t\tstack<T> st;\n\t\tpar[rt]=-1;\n\t\tdep[rt]=0;\n\t\tst.emplace(rt,0);\n\t\twhile(!st.empty()){\n\t\t\tint v=st.top().first;\n\t\t\tint &i=st.top().second;\n\t\t\tif(i<(int)G[v].size()){\n\t\t\t\tint u = G[v][i++].dst;\n\t\t\t\tif(u==par[v]) continue;\n\t\t\t\tpar[u]=v;\n\t\t\t\tdep[u]=dep[v]+1;\n\t\t\t\tst.emplace(u,0);\n\t\t\t}else{\n\t\t\t\tst.pop();\n\t\t\t\tint res=0;\n\t\t\t\tfor(auto e:G[v]){\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\tif(u==par[v]) continue;\n\t\t\t\t\tsub[v]+=sub[u];\n\t\t\t\t\tif(res<sub[u]) res=sub[u],hvy[v]=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid bfs(int r,int c) {\n\t\tint &k=pos;\n\t\tqueue<int> q({r});\n\t\twhile(!q.empty()){\n\t\t\tint h=q.front();q.pop();\n\t\t\tfor(int i=h;i!=-1;i=hvy[i]) {\n\t\t\t\ttype[i]=c;\n\t\t\t\tvid[i]=k++;\n\t\t\t\tinv[vid[i]]=i;\n\t\t\t\thead[i]=h;\n\t\t\t\tfor(auto e:G[i]){\n\t\t\t\t\tint j = e.dst;\n\t\t\t\t\tif(j!=par[i]&&j!=hvy[i]) q.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// for_each(vertex)\n\t// [l,r] <- attention!!\n\tvoid for_each(int u, int v, const function<void(int, int)>& f) {\n\t\twhile(1){\n\t\t\tif(vid[u]>vid[v]) swap(u,v);\n\t\t\tf(max(vid[head[v]],vid[u]),vid[v]);\n\t\t\tif(head[u]!=head[v]) v=par[head[v]];\n\t\t\telse break;\n\t\t}\n\t}\n\n\t// for_each(edge)\n\t// [l,r] <- attention!!\n\tvoid for_each_edge(int u, int v, const function<void(int, int)>& f) {\n\t\twhile(1){\n\t\t\tif(vid[u]>vid[v]) swap(u,v);\n\t\t\tif(head[u]!=head[v]){\n\t\t\t\tf(vid[head[v]],vid[v]);\n\t\t\t\tv=par[head[v]];\n\t\t\t} else{\n\t\t\t\tif(u!=v) f(vid[u]+1,vid[v]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint lca(int u,int v){\n\t\twhile(1){\n\t\t\tif(vid[u]>vid[v]) swap(u,v);\n\t\t\tif(head[u]==head[v]) return u;\n\t\t\tv=par[head[v]];\n\t\t}\n\t}\n\n\tint distance(int u,int v){\n\t\treturn dep[u]+dep[v]-2*dep[lca(u,v)];\n\t}\n};\n//}}}\n\n//segment tree point update, range query\n//{{{ SegmentTree<T>(int n, T unit, function<T(T,T)> append)\ntemplate <typename T>\nstruct SegmentTree { // on monoid\n\tint n;\n\tvector<T> a;\n\tfunction<T (T,T)> append; // associative\n\tT unit; // unit\n\tSegmentTree() = default;\n\tSegmentTree(int a_n, T a_unit, function<T (T,T)> a_append) {\n\t\tn = pow(2,ceil(log2(a_n)));\n\t\ta.resize(2*n-1, a_unit);\n\t\tunit = a_unit;\n\t\tappend = a_append;\n\t}\n\tvoid point_update(int i, T z) {\n\t\ta[i+n-1] = append(a[i+n-1],z);\n\t\tfor (i = (i+n)/2; i > 0; i /= 2) {\n\t\t\ta[i-1] = append(a[2*i-1], a[2*i]);\n\t\t}\n\t}\n\tT range_concat(int l, int r) {\n\t\treturn range_concat(0, 0, n, l, r);\n\t}\n\tT range_concat(int i, int il, int ir, int l, int r) {\n\t\tif (l <= il and ir <= r) {\n\t\t\treturn a[i];\n\t\t} else if (ir <= l or r <= il) {\n\t\t\treturn unit;\n\t\t} else {\n\t\t\treturn append(\n\t\t\t\t\trange_concat(2*i+1, il, (il+ir)/2, l, r),\n\t\t\t\t\trange_concat(2*i+2, (il+ir)/2, ir, l, r));\n\t\t}\n\t}\n\tvoid build(int i, int il, int ir, const vector<T> &v){\n\t\tif(ir-il==1){\n\t\t\tif(il<n)a[i] = v[il];\n\t\t\telse a[i] = unit;\n\t\t}else{\n\t\t\tint im = (il+ir)/2;\n\t\t\tbuild(v,i*2+1,il,im);\n\t\t\tbuild(v,i*2+2,im,ir);\n\t\t\ta[i] = append(a[i*2+1],a[i*2+2]);\n\t\t}\n\t}\n\tvoid build(const vector<T> &v){\n\t\tbuild(0,0,n,v);\n\t}\n};\n//}}}\n\n//{{{ minimumSpanningTree(Graph g)\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tEdges T;\n\tWeight total = 0;\n\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push( Edge(-1, r, 0) );\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top(); Q.pop();\n\t\tif (visited[e.dst]) continue;\n\t\tif(e.src>=0)T.push_back(e);\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tFOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n\t}\n\treturn pair<Weight, Edges>(total, T);\n}\n//}}}\n\nint N;\nint M;\nvector<int> a;\nvector<int> b;\nvector<int> c;\nint Q;\nvector<int> S;\nvector<int> T;\n\nvoid solve(){\n\tGraph G(N), GT(N);\n\tREP(i,M)addBiEdge(G,{a[i],b[i]},(Int)c[i]);\n\tauto p = minimumSpanningTree(G);\n\tfor(auto e:p.second){\n\t\taddBiEdge(GT,{e.src,e.dst},e.weight);\n\t}\n\tHLDecomposition hl(GT);\n\thl.build();\n\tSegmentTree<Int> st(N,-inf<Int>(),\n\t\t\t[&](Int a,Int b){return max(a,b);}\n\t\t\t);\n\tfunction<void(int,int)> dfs = [&](int u, int p){\n\t\tfor(auto &&e:GT[u]){\n\t\t\tif(e.dst==p)continue;\n\t\t\tint v = hl.vid[e.dst];\n\t\t\tst.point_update(v,e.weight);\n\t\t\tdfs(e.dst,u);\n\t\t}\n\t};\n\tdfs(0,-1);\n\tREP(i,Q){\n\t\tInt ans = -inf<Int>();\n\t\thl.for_each_edge(S[i],T[i],[&](int l, int r){\n\t\t\t\tans = max(ans,st.range_concat(l,r+1));\n\t\t\t\t});\n\t\tans = p.first - ans;\n\t\tcout<<ans<<endl;\n\t}\n}\n\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n\tcin >> M;\n\ta.assign(M,Int());\n\tb.assign(M,Int());\n\tc.assign(M,Int());\n\tfor(int i = 0 ; i < M ; i++){\n\t\tcin >> a[i];\n\t\tcin >> b[i];\n\t\tcin >> c[i];\n\t\ta[i]--;b[i]--;\n\t}\n\tcin >> Q;\n\tS.assign(Q,Int());\n\tT.assign(Q,Int());\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tcin >> S[i];\n\t\tcin >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tsolve();\n\treturn 0;\n}\n\n//}}}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,M;\nvpint G[4444];\n\nint A[444444],B[444444],C[444444];\n\nint cost[4444][4444];\n\nvoid dfs(int v,int p,int c,int s){\n    cost[s][v]=c;\n    for(auto &e:G[v]){\n        if(e.fi==p)continue;\n        dfs(e.fi,v,max(c,e.se),s);\n    }\n}\n\nsigned main(){\n    cin>>N>>M;\n\n    vpint ord;\n    rep(i,M){\n        cin>>A[i]>>B[i]>>C[i];\n        A[i]--;B[i]--;\n        ord.pb({C[i],i});\n    }\n    sort(all(ord));\n\n    int sum=0;\n    UnionFindTree uf(N);\n    rep(i,M){\n        int w=ord[i].se;\n        if(uf.areSame(A[w],B[w]))continue;\n        uf.unite(A[w],B[w]);\n        G[A[w]].pb({B[w],C[w]});\n        G[B[w]].pb({A[w],C[w]});\n        sum+=C[w];\n    }\n\n    rep(i,N)dfs(i,-1,0,i);\n\n    int Q;cin>>Q;\n    while(Q--){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        cout<<sum-cost[a][b]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPP(i,m,n) for(long long i=m;i<n;++i)\n#define rep(i,n) for(long long i = n-1;i>=0;--i)\n#define repp(i,n,m) for(long long i = n-1; i >= m; --i)\n#define ALL(N) (N.begin(),N.end())\n#define de cout << \"line : \" << __LINE__ << \" debug\" << endl;\n#define pb push_back\n#define pq priority_queue\n#define Dcout(N) cout << setprecision(20) << N << endl\nconstexpr long long INF = 2147483647;\nconstexpr long long INFF = 9223372036854775807;\n\nstruct edge{long long u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n    return e1.cost < e2.cost;\n}\n\n\nstruct UnionFind{\n    vector<long long> par,r;\n\n    //はじめに全てが根であるとしておく\n    UnionFind(long long N):par(N),r(N,1){iota(par.begin(),par.end(),0);}\n\n    long long root(long long x){//根に当たるまで再帰で探す\n        if(par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n\n    bool same(long long x,long long y){//つながっているかどうか判定\n        return par[x] == par[y];\n    }\n\n    long long size(long long x){ //根の大きさを判定する\n        return r[root(x)];\n    }\n\n    void unite(long long x, long long y){//根が同じでなかったらつなげる\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(r[x] < r[y]) swap(x,y); //値を小さいほうを根にする\n        r[x] += r[y];\n        par[y] = x;\n        return;\n    }\n};\n\nedge es[400100];\nlong long V,E;\nvector<pair<long long,long long>> G[4100];\n\nlong long kruskal(){\n    sort (es,es + E,comp);\n    UnionFind UF(V);\n    long long res = 0;\n    REP(i,E){\n        edge e = es[i];\n        if(!UF.same(e.u,e.v)){\n            UF.unite(e.u,e.v);\n            res += e.cost;\n            G[e.u].pb({e.v,e.cost});\n            G[e.v].pb({e.u,e.cost});\n        }\n    }\n    return res;\n}\n\nbool seen[4100] = {};\nlong long mincost;\nvoid dfs(long long& st,long long& en,long long& co){\n    long long m = co;\n    REP(i,G[st].size()){\n        co = m;\n        if(!seen[G[st][i].first]) seen[G[st][i].first] = 1;\n        else continue;\n        if(G[st][i].second > co) co = G[st][i].second;\n        if(G[st][i].first == en){\n            cout << mincost - co << endl;\n            return;\n        }\n        dfs(G[st][i].first,en,co);\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n    cin >> V >> E;\n    REP(i,E){\n        cin >> es[i].u >> es[i].v >> es[i].cost;--es[i].u;--es[i].v;\n    }\n    mincost = kruskal();\n    long long Q;cin >> Q;\n    long long c,S,T;\n    REP(i,Q){\n        cin >> S >> T;--S;--T;seen[S] = 1;\n        c = 0; \n        dfs(S,T,c);\n        REP(j,V){seen[j] = 0;}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to;\n    T cost;\n\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n    explicit operator int() const {return to;}\n};\n\nclass UnionFind {\n    vector<int> uni;\n    int n;\npublic:\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n};\n\ntemplate<typename T>\nvector<edge<T>> kruskal(vector<edge<T>> &G, int V) {\n    sort(begin(G), end(G), [](const edge< T > &a, const edge< T > &b) { return (a.cost < b.cost); });\n    UnionFind tree(V);\n    vector<edge<T>> ret;\n    for(auto &e : G) {\n        if(tree.unite(e.from, e.to)) ret.emplace_back(e);\n    }\n    return (ret);\n}\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<edge<ll>> e;\n    for (int i = 0; i < m; ++i) {\n        int a, b; ll c;\n        scanf(\"%d %d %lli\", &a, &b ,&c);\n        a--; b--;\n        e.emplace_back(a, b, c);\n    }\n    auto v = kruskal(e, n);\n    auto cost = make_v(n, n, 0LL);\n    ll S = 0;\n    vector<vector<pair<int, ll>>> G(n);\n    for (auto &&i : v) {\n        S += i.cost;\n        G[i.from].emplace_back(i.to, i.cost);\n        G[i.to].emplace_back(i.from, i.cost);\n    }\n    for (int st = 0; st < n; ++st) {\n        stack<int> s;\n        vector<int> visited(n, 0);\n        s.emplace(st);\n        while(!s.empty()){\n            int a = s.top(); s.pop();\n            visited[a]++;\n            for (auto &&i : G[a]) {\n                if(!visited[i.first]) {\n                    s.emplace(i.first);\n                    cost[st][i.first]\n                        = max(cost[st][a], i.second);\n                }\n            }\n        }\n    }\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        cout << S-cost[s-1][t-1] << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 400010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct UF {\n\tvector<int> par, ran;\n\tvoid init(int n) {\n\t\tpar.resize(n); ran.resize(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tUF(int mx = 0) { init(mx); }\n\n\tint find(int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\n//////////////\n\nint N, M, E;\nstruct edge { int u, v, cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nedge es[400010];\nvector<pi> G[MAX_N];\nint depth[MAX_N];\nint par[MAX_N];\nint cost[MAX_N];\n\nint kruskal() {\n\tsort(es, es + E, comp);\n\tUF uf(N);//init union_find\n\tint res = 0;\n\tfor(int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif(!uf.same(e.u, e.v)) {\n\t\t\tuf.unite(e.u, e.v);\n\t\t\tG[e.u].pb(pi(e.v, e.cost));\n\t\t\tG[e.v].pb(pi(e.u, e.cost));\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid add_edge(int s, int t, int cost) {\n\tes[E++] = edge{s, t, cost};\n}\n\nvoid loop(int v, int p, int k) {\n\tdepth[v] = k;\n\tpar[v] = p;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst;\n\t\tif(n == p) continue;\n\t\tcost[n] = G[v][i].sec;\n\t\tloop(n, v, k + 1);\n\t}\n}\n\nvoid solve() {\n\tE = 0;\n\tcin >> N >> M;\n\trep(i, 0, M) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c; a--; b--;\n\t\tadd_edge(a, b, c);\n\t}\n\tll S = kruskal();\n\tloop(0, -1, 0);\n\tint Q; cin >> Q;\n\twhile(Q--) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tif(depth[a] < depth[b]) swap(a, b);\n\t\tint mv = -1;\n\t\twhile(depth[a] > depth[b]) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\ta = par[a];\n\t\t}\n\t\t// debug(depth[a], depth[b], a, b);\n\t\twhile(a != b) {\n\t\t\tMAX(mv, cost[a]);\n\t\t\tMAX(mv, cost[b]);\n\t\t\ta = par[a]; b = par[b];\n\t\t}\n\t\tcout << S - mv << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Graph = vector<vector<pair<int, int>>>;\ntemplate <class T>\nusing priority_queue_min = priority_queue<T, vector<T>, greater<T>>;\nGraph minimum_spanning_tree(const Graph &g) {\n    Graph ans(g.size());\n    priority_queue_min<tuple<int, int, int>> Q;\n    vector<bool> used(g.size());\n    int cnt = 0;\n    used[0] = true;\n    cnt++;\n    for (auto &e : g[0]) {\n        Q.emplace(e.second, 0, e.first);\n    }\n    while (cnt < g.size()) {\n        int cost, src, dst;\n        tie(cost, src, dst) = Q.top();\n        Q.pop();\n        if (!used[dst]) {\n            used[dst] = true;\n            cnt++;\n            ans[src].emplace_back(dst, cost);\n            ans[dst].emplace_back(src, cost);\n            for (auto &e : g[dst]) {\n                if (!used[e.first]) Q.emplace(e.second, dst, e.first);\n            }\n        }\n    }\n    return ans;\n}\nInt sum_edge(const Graph &g) {\n    Int ans = 0;\n    for (auto &es : g) for (auto &e : es) ans += e.second;\n    return ans / 2;\n}\nvector<vector<int>> max_edge(const Graph &g) {\n    vector<vector<int>> ans(g.size(), vector<int>(g.size()));\n    stack<pair<int, int>> S;\n    for (int i = 0; i < g.size(); i++) {\n        S.emplace(i, -1);\n        while (!S.empty()) {\n            int curr, prev;\n            tie(curr, prev) = S.top();\n            S.pop();\n            for (auto &e : g[curr]) if (prev != e.first) {\n                S.emplace(e.first, curr);\n                ans[i][e.first] = max(ans[i][curr], e.second);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    for (int i = 0; i < M; i++) {\n        int a, b, c; cin >> a >> b >> c; a--, b--;\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, c);\n    }\n    G = minimum_spanning_tree(G);\n    auto sum = sum_edge(G);\n    auto maxE = max_edge(G);\n    int Q; cin >> Q;\n    for (int i = 0; i < Q; i++) {\n        int s, t; cin >> s >> t; s--, t--;\n        cout << sum - maxE[s][t] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\nclass partially_persistent_union_find {\npublic:\n  using value_type = T;\n\nprivate:\n  int size;\n  value_type last_query;\n  const value_type inf;\n  std::vector<int> parent;\n  std::vector<value_type> updated;\n  std::vector<std::pair<value_type, int>> component;\n  std::vector<std::vector<std::pair<value_type, int>>> history;\n\npublic:\n  partially_persistent_union_find(): inf(std::numeric_limits<value_type>::max()) { }\n  partially_persistent_union_find(int size_): \n    inf(std::numeric_limits<value_type>::max())\n  { init(size_);}\n\n  void init(int size_) {\n    size = size_;\n    last_query = std::numeric_limits<value_type>::min();\n    parent.assign(size_, 1);\n    updated.assign(size_, inf);\n    component.assign(1, { last_query, size_ });\n    history.assign(size_, { { last_query, 1 } });\n  }\n\n  int find_parent(int i, const value_type &t) const {\n    if (updated[i] > t) {\n      return i;\n    }\n    else {\n      return find_parent(parent[i], t);\n    }\n  }\n\n  int count_components(const value_type &t) const {\n    return (--std::upper_bound(component.begin(), component.end(), std::make_pair(t, size))) -> second;\n  }\n  int component_size(int i, const value_type &t) const {\n    i = find_parent(i, t);\n    return (--std::upper_bound(history[i].begin(), history[i].end(), std::make_pair(t, size))) -> second;\n  }\n  bool same_component(int i, int j, const value_type &t) const {\n    return find_parent(i, t) == find_parent(j, t);\n  }\n\n  value_type united(int i, int j) const {\n    if (!same_component(i, j, last_query)) {\n      return inf;\n    }\n    int ok = last_query, ng = -1;\n    while (ok - ng > 1) {\n      int md = (ok + ng) / 2;\n      (same_component(i, j, md) ? ok : ng) = md;\n    }\n    return ok;\n  }\n\n  bool unite(int i, int j, const value_type &t) {\n    i = find_parent(i, last_query);\n    j = find_parent(j, last_query);\n    last_query = t;\n    if (i == j) {\n      return false;\n    }\n    if (parent[i] < parent[j]) {\n      std::swap(i, j);\n    }\n    parent[i] += parent[j];\n    parent[j] = i;\n    updated[j] = last_query;\n    int tmp = component.back().second;\n    component.emplace_back(last_query, tmp - 1);\n    history[i].emplace_back(last_query, parent[i]);\n    return true;\n  }\n\n};\n\nint main() {\n  int N, M;\n  int a, b, c;\n  scanf(\"%d %d\", &N, &M);\n  std::vector<std::tuple<int, int, int>> edges;\n  while (M--) {\n    scanf(\"%d %d %d\", &a, &b, &c);\n    edges.emplace_back(c, a - 1, b - 1);\n  }\n  std::sort(edges.begin(), edges.end());\n  partially_persistent_union_find<int> dsu(N);\n  long long sum = 0;\n  for (auto e: edges) {\n    std::tie(c, a, b) = e;\n    if (dsu.unite(a, b, c)) {\n      sum += c;\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while (Q--) {\n    scanf(\"%d %d\", &a, &b);\n    printf(\"%d\\n\", sum - dsu.united(a - 1, b - 1));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//\n//                            ▒█████▒▒\n//                             ██████████▒\n//                             ▒████████████▒\n//                            ██████████████████\n//                           ████████████████████▒\n//                          ▒██████████████████████▒\n//                          ▒███████████████████████\n//                      ▒████▒▒▒▒▒▒█████████████████▒\n//                    ███▒▒▒▒▒▒██████████████████████▒▒▒\n//                  ▒██▒▒███████████████████████▒▒▒▒▒██████\n//                 ▒█████████████████████████▒▒▒▒▒▒█████████▒\n//                 ▒█████████████████████▒▒▒▒▒▒██████████████\n//                  ▒████         ████▒▒▒▒▒████         ████▒\n//              ▒█████▒    ████    ▒▒▒▒███████    ████    ██████▒\n//            ▒██▒▒▒▒▒    ██████    █████████    ██████    ██▒▒▒██▒\n//           █████████   ████████   █████████   ████████   ▒▒▒▒█████\n//          ▒█████████    ██████    ████████▒    ██████    █████████\n//          ▒██████████    ████    █████▒▒▒▒▒▒    ████    ██████████\n//           ████████████        ▒▒▒▒▒▒▒████████        ███████████▒\n//       ▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒███████████████████████████████████▒\n//     ███▒▒▒▒▒▒▒▒▒▒▒▒█████████████████████████████████████████▒▒████████▒\n//   ▒▒▒▒▒▒▒▒▒██████████████                         ███████▒▒▒▒███████████\n//   █████████████████████████                     ███████▒▒▒██████████████▒\n//   █████████████████████████████             ███████▒▒▒██████████████████▒\n//   ██████████████████████████████████████████████████████████████████████\n//    ██████████████████████████████████████████████████████████████████▒\n//      ▒█████████████████▒▒▒▒▒▒▒██████████████████████████████████▒▒▒\n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nconst int N = 4000;\nvector<P> edge[N];\nvector<int> dist(N);\nint MAX_LOG_V = log2(N)+1;\nmat par(MAX_LOG_V,vec(N+1));\n\nvoid dfs(int no,int p,int d){\n  par[0][no]=p;\n  dist[no]=d;\n  for(auto to:edge[no]){\n    if(to.fs!=p) dfs(to.fs,no,d+1);\n  }\n}\n\nvoid init(int V, int root){\n  dfs(root,-1,0); //root,parent,dist\n  for(int k=0;k+1<MAX_LOG_V;++k){\n    for(int v=0;v<V;v++){\n      if(par[k][v]<0) par[k+1][v]=-1;\n      else par[k+1][v]=par[k][par[k][v]];\n    }\n  }\n}\n\nint lca(int u,int v){\n  if(dist[u]>dist[v]) swap(u,v);\n  for(int k=0;k<MAX_LOG_V;++k){\n    if((dist[v]-dist[u])>>k&1){\n      v=par[k][v];\n    }\n  }\n  if(u==v) return u;\n  for(int k=MAX_LOG_V-1;k>=0;--k){\n    if(par[k][u]!=par[k][v]){\n      u=par[k][u];\n      v=par[k][v];\n    }\n  }\n  return par[0][u];\n}\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree,sum;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    sum.resize(v);\n    REP(i,v) tree[i] = i, sum[i] = 1;\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return sum[root(i)];\n  }\n\n  bool unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x==y) return false;\n    sum[min(x,y)] += sum[max(x,y)];\n    tree[max(x,y)] = min(x,y);\n    return true;\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nmat dp(N,vec(N,0));\nint root;\nint dfs2(int no, int pare, int mx){\n  dp[root][no] = mx;\n  for(auto to:edge[no]){\n    if(to.fs == pare) continue;\n    dfs2(to.fs,no,max(mx,to.sc));\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  using T = tuple<int,int,int>;\n  vector<T> a(m);\n  REP(i,m){\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--; y--;\n    a[i] = T(z,x,y);\n  }\n\n  sort(a.begin(),a.end());\n\n  UnionFind uf(n); int sum = 0;\n  REP(i,m){\n    int x,y,z;\n    tie(z,x,y) = a[i];\n    if(uf.unit(x,y)){\n      edge[x].push_back(P(y,z));\n      edge[y].push_back(P(x,z));\n      sum += z;\n    }\n  }\n\n  init(n,0);\n\n  REP(i,n) root = i, dfs2(i,-1,0);\n\n  int q;\n  cin >> q;\n  REP(_,q){\n    int s,t;\n    cin >> s >> t;\n    s--; t--;\n    int no = lca(s,t);\n    cout << sum - max(dp[no][s],dp[no][t]) << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    vector<int> use;\n    int64_t sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        use.push_back(i);\n        sum_cost+=e.cost;\n    }\n\n    vector<vector<int>> children(n);\n    vector<int> parent(n,-1);\n    rep(i,0,n-1){\n        edge &e=edges[use[i]];\n        int a=e.from,b=e.to;\n        if(parent[a]==-1){\n            children[b].push_back(a);\n            parent[a]=b;\n        }else{\n            children[a].push_back(b);\n            parent[b]=a;\n        }\n    }\n    int root;\n    rep(i,0,n){\n        if(parent[i]==-1){\n            root=i;\n            break;\n        }\n    }\n\n    lca_solver ls(children,root);\n    vector<vector<int>> max_cost(20,vector<int>(n));\n    rep(i,0,n){\n        if(i==root) continue;\n        int j=ls.parent_pow2[0][i];\n        max_cost[0][i]=cost[i][j];\n    }\n    rep(i,1,20){\n        rep(j,0,n){\n            if(ls.depth[j]-(1<<i)<0) continue;\n            max_cost[i][j]=max(max_cost[i-1][j],max_cost[i-1][ls.parent_pow2[i-1][j]]);\n        }\n    }\n\n    auto f=[&](int u,int v){\n        int res=0;\n        rep(i,0,20){\n        //for(int i=19; i>=0; --i){\n            if(ls.depth[u]-ls.depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls.parent_pow2[i][u];\n            }\n        }\n        return res;\n    };\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        int u=ls.lca(s,t);\n        cout << sum_cost-max(f(s,u),f(t,u)) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e17;\nstruct UnionFind{\n    vector<ll> data;\n    UnionFind(ll size) : data(size, -1) {}\n    bool unionSet(ll x,ll y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(ll x,ll y){\n        return root(x)==root(y);\n    }\n    ll root(ll x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    ll size(ll x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tll from,to,cost;\n\t};\n\tvector<edge>G;\n\tvvp tG;\n\tvvi dp;\n\tvi used;\n\tll n;\n\tKRK(ll size){\n\t\tn=size;\n\t}\n\tvoid add_edge(ll a,ll b,ll c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tll krk(){\n\t\tll sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\ttG[e.from].pb(pii(e.to,e.cost));\n\t\t\t\ttG[e.to].pb(pii(e.from,e.cost));\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tvoid dfs(ll a,ll b){\n\t\trep(i,tG[a].size())if(used[tG[a][i].first]==0){\n\t\t\tused[tG[a][i].first]=true;\n\t\t\tll t=max<ll>(b,tG[a][i].second);\n\t\t\tdp[a][tG[a][i].first]=t;\n\t\t\tdfs(tG[a][i].first,t);\n\t\t}\n\t}\n\tvoid solve(){\n\t\ttG=vvp(n);\n\t\tll out=krk();\n\t\tdp=vvi(n,vi(n));\n\t\trep(i,n){\n\t\t\tused=vi(n);\n\t\t\tdfs(i,0);\n\t\t}\n\t\tll q;\n\t\tcin>>q;\n\t\twhile(q--){\n\t\t\tll a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tcout<<out-dp[a][b]<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tll n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\twhile(m--){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tkrk.add_edge(a,b,c);\n\t}\n\tkrk.solve();\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define show(x) cout << #x << \" = \" << (x) << endl;\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, nrank;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), nrank(sz, 0){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(nrank[x] < nrank[y]) swap(x,y);\n        par[y] = x;\n        if(nrank[x] == nrank[y]) nrank[x]++;\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\nstruct edge{\n    int from,to;\n    ll cost;\n    bool operator<(const edge&b) const{\n        return cost < b.cost;\n    }\n};\nvector<pair<int,ll>>g[4000];\nll dp[4000][4000];\nvoid dfs(const int t, int s, int p){\n    for(auto &x:g[s]){\n        if(x.first==p)continue;\n        int v = x.first;\n        dp[t][v] = max(dp[t][s], x.second);\n        dfs(t,v,s);\n    }\n}\nint main(){\n    int n, m;\n    cin >> n >> m;\n    vector<edge>vec;\n    while(m--){\n        int a,b;\n        ll c;\n        cin >> a >> b >> c;\n        a--,b--;\n        vec.push_back({a,b,c});\n    }\n    sort(vec.begin(),vec.end());\n    UnionFind uf(n);\n    ll sum = 0;\n    for(auto &e:vec){\n        if(!uf.same(e.from,e.to)){\n            sum += e.cost;\n            uf.unite(e.from,e.to);\n            g[e.from].emplace_back(e.to,e.cost);\n            g[e.to].emplace_back(e.from,e.cost);\n        }\n    }\n    rep(i,n){\n        dfs(i,i,-1);\n    }\n    int q;\n    cin >> q;\n    while(q--){\n        int s,t;\n        cin >> s >> t;\n        s--,t--;\n        cout << sum - dp[s][t] << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "    #include <string>\n    #include <vector>\n    #include <cstdio>\n    #include <cstdlib>\n    #include <cmath>\n    #include <algorithm>\n    #include <queue>\n    #include <map>\n    #include <set>\n    #include <iostream>\n    #include <sstream>\n    #include <cstring>\n    #include <numeric>\n    using namespace std;\n    typedef long long ll;\n    typedef pair<int,int> pii;\n    #define F0(i,n) for (int i = 0; i < n; i++)\n    #define F1(i,n) for (int i = 1; i <= n; i++)\n    #define CL(a,x) memset(x, a, sizeof(x));\n    #define SZ(x) ((int)x.size())\n    const double eps = 1e-10;\n    const int inf = 1000000009;\n    int i, j, k, m, n, l;\n    int ans;\n    string s;\n    const int N = 5000;\n    int a[N], b[N], id[N], p[N];\n    int c[N][N], u[N], best[N];\n     \n     \n    int main() {\n    \t//freopen(\"x.in\", \"r\", stdin);\n     \n    \tcin >> n >> m;\n    \tF0(i, m) {\n    \t\tcin >> a[i] >> b[i] >> j;\n    \t\tc[a[i]][b[i]] = c[b[i]][a[i]] = j;\n     \t}\n     \n    \tint Q, S, T;\n    \tcin >> Q;\n    \twhile (Q--) {\n    \t\tcin >> S >> T;\n     \n    \t\tset<pii> SE;\n    \t\tF1(i, n) if (i != S && i != T) {\n  best[i] = min(c[S][i], c[T][i]);\n    \t SE.insert(pii(best[i], i));\n    \t\t\tu[i] = 0;\n    \t\t}\nu[S] = u[T] = 1;\n     \n    \t\tll ans = 0;\n    \t\tF0(i, n - 2) {\n    \t\t\tpii p = *SE.begin(); SE.erase(SE.begin());\n    \t\t\tans += p.first;\n    \t\t\tu[p.second] = 1;\n    \t\t\tF1(i, n) if (!u[i]) {\n    \t\t\t\tif (c[p.second][i] < best[i]) {\nSE.erase(SE.find(pii(best[i], i)));\nbest[i] = c[p.second][i];\nSE.insert(pii(best[i], i));\n}\n    \t\t\t}\n     \n    \t\t}\n    \t\tcout << ans << endl;\n    \t}\n    \t\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\ntypedef long long ll;\ntemplate<int um> class UF { // from kmjp\npublic:\n\tvector<int> par;\n\tUF() { par = vector<int>(um, 0); rep(i, 0, um) par[i] = i; }\n\tint operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n\tvoid operator()(int x, int y)\n\t{\n\t\tx = operator[](x); y = operator[](y);\n\t\tif (x != y) par[x] = y;\n\t}\n};\n//-----------------------------------------------------------------\nint N, M;\ntuple<int, int, int> buf[404040];\nint D[4040][4040];\nUF<4040> uf;\nvector<pair<int, int>> E[4040];\n//-----------------------------------------------------------------\nvoid dfs(int st, int cur, int par, int ma) {\n\tD[st][cur] = ma;\n\n\tfor (auto p : E[cur]) if (p.first != par) dfs(st, p.first, cur, max(ma, p.second));\n}\n//-----------------------------------------------------------------\nint main() {\n\tcin >> N >> M;\n\trep(i, 0, M) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\tbuf[i] = make_tuple(c, a, b);\n\t}\n\tsort(buf, buf + M);\n\n\tll sm = 0;\n\trep(i, 0, M) {\n\t\tint a = get<1>(buf[i]);\n\t\tint b = get<2>(buf[i]);\n\t\tint c = get<0>(buf[i]);\n\n\t\tif (uf[a] != uf[b]) {\n\t\t\tuf(a, b);\n\t\t\tE[a].push_back(make_pair(b, c));\n\t\t\tE[b].push_back(make_pair(a, c));\n\t\t\tsm += c;\n\t\t}\n\t}\n\n\trep(i, 1, N + 1) dfs(i, i, -1, 0);\n\n\tint Q; cin >> Q;\n\trep(i, 0, Q) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\n\t\tll ans = sm - D[s][t];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-6;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nclass Union_find{\nprivate:\n\tvector<int32> par;\n\tint32 n;\n\npublic:\n\tUnion_find(int32 n):n(n){\n\t\tpar.resize(n, -1);\n\t}\n\n\tint32 find(int32 x){\n\t\treturn par[x] < 0 ? x : par[x] = find(par[x]);\n\t}\n\n\tint32 size(int32 x){\n\t\treturn -par[find(x)];\n\t}\n\n\tvoid unite(int32 x, int32 y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(size(x) < size(y)) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t}\n\n\tbool same(int32 x, int32 y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nconst int64 mod = 1e9+7;\n\nusing Edge = tuple<int64, int64, int64>;\nint64 N, M, Q;\nint64 sum = 0;\nvector<Edge> e;\nvector<PLL> G[4040];\nvector<int64> d;\nint64 table[13][4040], maxi[13][4040];\n\nvoid init(){\n\td.resize(N);\n\tmemset(table, -1, sizeof table);\n\tmemset(maxi, -1, sizeof maxi);\n\tfunction<void(int32, int32, int32)> idfs = [&](int32 v, int32 p, int32 dep){\n\t\td[v] = dep;\n\t\ttable[0][v] = p;\n\t\tREP(i, G[v].size()){\n\t\t\tif(G[v][i].sc == p) continue;\n\t\t\tmaxi[0][G[v][i].sc] = G[v][i].fs;\n\t\t\tidfs(G[v][i].sc, v, dep+1);\n\t\t}\n\t};\n\tidfs(0, -1, 0);\n\tREP(i, 12){\n\t\tREP(j, N){\n\t\t\tif(table[i][j] != -1){\n\t\t\t\ttable[i+1][j] = table[i][table[i][j]];\n\t\t\t\tmaxi[i+1][j] = max(maxi[i][j], maxi[i][table[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint64 lca(int32 u, int32 v){\n\tif(d[u] < d[v]) swap(u, v);\n\tint64 res = 0;\n\tfor(int32 i = 12;i >= 0;i--){\n\t\tif((d[u]-d[v]) >> i & 1){\n\t\t\tres = max(res, maxi[i][u]);\n\t\t\tu = table[i][u];\n\t\t}\n\t}\n\tif(u == v) return res;\n\tfor(int32 i = 12;i >= 0;i--){\n\t\tif(table[i][u] != table[i][v]){\n\t\t\tres = max({res, maxi[i][u], maxi[i][v]});\n\t\t\tu = table[i][u];\n\t\t\tv = table[i][v];\n\t\t}\n\t}\n\tres = max({res, maxi[0][u], maxi[0][v]});\n\treturn res;\n}\n\nint main(void){\n\tcin >> N >> M;\n\tREP(i, M){\n\t\tint64 a, b, c;\n\t\tcin >> a >> b >> c; a--; b--;\n\t\te.push_back(Edge(c, a, b));\n\t}\n\tUnion_find uf(N);\n\tsort(all(e));\n\tREP(i, e.size()){\n\t\tint64 u, v, c;\n\t\ttie(c, u, v) = e[i];\n\t\tif(uf.same(u, v)) continue;\n\t\tuf.unite(u, v);\n\t\tsum += c;\n\t\tG[u].push_back({c, v});\n\t\tG[v].push_back({c, u});\n\t}\n\tinit();\n\tcin >> Q;\n\tREP(i, Q){\n\t\tint32 u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tint64 res = lca(u, v);\n\t\tcout << sum-res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.assign(n, 1);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<pair<int, pair<int, int>>> es;\n        for (int i = 0; i < m; i ++) {\n                int a, b, c;\n                scanf(\"%d%d%d\", &a, &b, &c);\n                a --, b --;\n                es.push_back({c, {a, b}});\n        }\n        sort(es.begin(), es.end());\n        vector<pair<int, pair<int, int>>> use;\n        UnionFind uf(n);\n        long long tot = 0;\n        for (int i = 0; i < (int) es.size(); i ++) {\n                int a, b;\n                tie(a, b) = es[i].second;\n                if (uf.same(a, b)) continue;\n                uf.unite(a, b);\n                use.push_back(es[i]);\n                tot += es[i].first;\n        }\n        assert((int) use.size() == n - 1);\n        vector<vector<pair<int, int>>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int c = use[i].first;\n                int a = use[i].second.first;\n                int b = use[i].second.second;\n                g[a].push_back({b, c});\n                g[b].push_back({a, c});\n        }\n        int q;\n        scanf(\"%d\", &q);\n        while (q --) {\n                int s, t;\n                scanf(\"%d%d\", &s, &t);\n                s --, t --;\n                int maxval = 0;\n                function<void (int, int, int)> dfs = [&](int u, int prev, int ma) {\n                        if (u == t) {\n                                maxval = ma;\n                                return;\n                        }\n                        for (auto e : g[u]) if (e.first != prev) {\n                                dfs(e.first, u, max(ma, e.second));\n                        }\n                };\n                dfs(s, -1, 0);\n                printf(\"%lld\\n\", tot - maxval);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\ntypedef long long ll;\n\nvector<int> par,rk;\n\nvoid init(const int n){\n\tpar.resize(n);\n\trk.resize(n);\n\tfor(int i=0;i<n;++i) par[i]=i;\n\tfill(rk.begin(),rk.end(),0);\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y){\n\t\treturn;\n\t}else if(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rk[x]==rk[y]){\n\t\t\t++rk[x];\n\t\t}\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nstruct edge{\n\tint from,to;\n\tll cost;\n};\n\nbool cmp(edge e,edge f){\n\treturn e.cost<f.cost;\n}\n\n#define MAX_Q 100000\n\nvector<edge> es;\n\n#define MAX_N 4000\n\nvector<int> g[MAX_N];\nll d[MAX_N][MAX_N];\n\nvoid dfs(int v0,int v){\n\tfor(int j=0;j<g[v].size();++j){\n\t\tint e=g[v][j],w=es[e].from;\n\t\tif(v==w) w=es[e].to;\n\t\tif(d[v0][w]>=0) continue;\n\t\td[v0][w]=max(d[v0][v],es[e].cost);\n\t\tdfs(v0,w);\n\t}\n}\n\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(m-->0){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tes.pb((edge){--a,--b,c});\n\t}\n\tsort(es.begin(),es.end(),cmp);\n\tinit(n);\n\tll sc=0;\n\tfor(int j=0,e=0;e<n-1;++j){\n\t\tint v=es[j].from,w=es[j].to;\n\t\tif(same(v,w)) continue;\n\t\tunite(v,w);\n\t\tsc+=es[j].cost;\n\t\tg[v].pb(j);\n\t\tg[w].pb(j);\n\t\t++e;\n\t}\n\tfor(int v=0;v<n;++v){\n\t\tfill(d[v],d[v]+n,-1);\n\t\td[v][v]=0;\n\t\tdfs(v,v);\n\t}\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q-->0){\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tprintf(\"%d\\n\",sc-d[--s][--t]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\npair<Weight, Edges> minimumSpanningForest2(priority_queue<Edge> &Q, int n) {\n  UnionFind uf(n);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n  return minimumSpanningForest2(Q,n);\n}\npair<Weight, Edges> minimumSpanningForest(const Edges &g, int n) {\n  priority_queue<Edge> Q;\n  FOR(e, g) Q.push(*e);\n  return minimumSpanningForest2(Q,n);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\tGraph g(N);\n\tfor(;M--;){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\tg[b-1].emplace_back(b-1,a-1,c);\n\t}\n\tpair<Weight, Edges> v=minimumSpanningForest(g);\n\tscanf(\"%d\",&Q);\n\tif(Q>3000)return 1;\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tv.second.emplace_back(a-1,b-1,0);\n\t\tprintf(\"%lld\\n\",minimumSpanningForest(v.second,N).first);\n\t\tv.second.pop_back();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum;\n\t};\n\tvector<node> dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p == u) return u;\n\t\tdsu[u].p = rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tvoid merge(int u, int v)\n\t{\n\t\tu = rt(u); v = rt(v);\n\t\tif(u == v) return ;\n\t\tif(rand()&1) swap(u, v);\n\t\tdsu[v].p = u;\n\t\tdsu[u].sum += dsu[v].sum;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) == rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\nstruct Tree\n{\n\tstruct data\n\t{\n\t\tll w;\n\t};\n\t\n\tstruct node\n\t{\n\t\tint p; //parent\n\t\tll w; //modify for different problems\n\t};\n\t\n\tstruct edge\n\t{\n\t\tint v; data dat;\n\t};\n\t\n\tvector<vector<edge> > adj;\n\tint n;\n\t\n\tTree(int _n)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvi level;\n\tvi depth;\n\tvi h;\n\tvi euler;\n\tvi firstocc;\n\tvector<vi> rmqtable;\n\tvi subsize;\n\tvi start; vi en;\n\tvector<vector<node> > st;\n\t\n\tvoid addedge(int u, int v, int w)\n\t{\n\t\tedge tmp; tmp.v = v; tmp.dat.w = w;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset(int _n)\n\t{\n\t\tadj.clear();\n\t\tlevel.clear();\n\t\tdepth.clear();\n\t\teuler.clear();\n\t\trmqtable.clear();\n\t\tsubsize.clear();\n\t\tstart.clear();\n\t\ten.clear();\n\t\tst.clear();\n\t\tfirstocc.clear();\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid dfssub(int u, int p)\n\t{\n\t\tsubsize[u] = 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfssub(v, u);\n\t\t\tsubsize[u] += subsize[v];\n\t\t}\n\t}\n\t\n\tvoid calcsub()\n\t{\n\t\tsubsize.resize(n);\n\t\tdfssub(0, -1);\n\t}\n\t\n\tint timer;\n\t\n\tvoid dfsstartend(int u, int p)\n\t{\n\t\tstart[u] = ++timer;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfsstartend(v, u);\n\t\t}\n\t\ten[u] = ++timer;\n\t}\n\t\n\tvoid calcstartend()\n\t{\n\t\ttimer = 0;\n\t\tstart.resize(n); en.resize(n); h.resize(n);\n\t\tdfsstartend(0, -1);\n\t}\n\t\n\tint eulercnt;\n\t\n\tvoid dfseuler(int u, int p)\n\t{\n\t\teuler[eulercnt] = u; eulercnt++;\n\t\tif(p == -1) {depth[u] = 0;}\n\t\telse {depth[u] = depth[p] + 1;}\n\t\tfirstocc[u] = eulercnt-1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue ;\n\t\t\tdfseuler(v, u);\n\t\t\teuler[eulercnt] = u; eulercnt++;\n\t\t}\n\t}\n\t\n\tvoid calceuler()\n\t{\n\t\teulercnt = 0;\n\t\tlevel.assign(2*n+1, 0);\n\t\teuler.assign(2*n+1, 0);\n\t\tdepth.assign(n, 0);\n\t\tfirstocc.resize(n);\n\t\tdfseuler(0, -1);\n\t}\n\n\tvoid filllevel()\n\t{\n\t\tint LG = 0;\n\t\twhile((1<<LG) <= n*2) LG++;\n\t\trmqtable.resize(LG);\n\t\tfor(int i = 0; i < LG; i++) rmqtable[i].resize(eulercnt);\n\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t{\n\t\t\tlevel[i] = depth[euler[i]];\n\t\t}\n\t\tlevel[eulercnt] = 1000000000;\n\t\tfor(int j = 0; j < LG; j++)\n\t\t{\n\t\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t\t{\n\t\t\t\trmqtable[j][i] = eulercnt;\n\t\t\t\tif(i + (1<<j) - 1 < eulercnt)\n\t\t\t\t{\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trmqtable[j][i] = i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(level[rmqtable[j - 1][i]] < level[rmqtable[j-1][i + (1<<(j-1))]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i + (1<<(j-1))];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint rmq(int l, int r)\n\t{\n\t\tint k = 31 - __builtin_clz(r-l);\n\t\t//cout << l << ' ' << r << ' ' << rmqtable[l][k] << ' ' << rmqtable[r - (1<<k) + 1][k] << endl;\n\t\tif(level[rmqtable[k][l]] < level[rmqtable[k][r - (1<<k) + 1]])\n\t\t{\n\t\t\treturn rmqtable[k][l];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rmqtable[k][r - (1<<k) + 1];\n\t\t}\n\t}\n\n\tint lcaeuler(int u, int v)\n\t{\n\t\tif(firstocc[u] > firstocc[v]) swap(u, v);\n\t\t//cerr << firstocc[u] << ' ' << firstocc[v] << ' ' << rmq(firstocc[u], firstocc[v]) << ' ' << euler[rmq(firstocc[u], firstocc[v])] << endl;\n\t\treturn euler[rmq(firstocc[u], firstocc[v])];\n\t}\n\t\n\tbool insub(int u, int v) //is u in the subtree of v?\n\t{\n\t\tif(start[v] <= start[u] && en[u] <= en[v]) return true;\n\t\treturn false;\n\t}\n\t\n\tvoid dfspar(int u, int p)\n\t{\n\t\t//cerr << u << ' ' << p << '\\n';\n\t\tst[0][u].p = p;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tif(p==-1) st[0][u].w = 0;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tst[0][v].w = adj[u][i].dat.w;\n\t\t\t//cerr<<\"DATA : \"<<st[0][v].w<<'\\n';\n\t\t\tdfspar(v, u);\n\t\t}\n\t}\n\t\n\tint LOG;\n\t\n\tvoid calcpar()\n\t{\n\t\th.resize(n);\n\t\tint LG = 0; LOG = 0;\n\t\twhile((1<<LG) <= n) {LG++; LOG++;}\n\t\tst.resize(LG);\n\t\tfor(int i = 0; i < LG; i++)\n\t\t{\n\t\t\tst[i].resize(n);\n\t\t}\n\t\tdfspar(0, -1);\n\t\t//cerr << \"HER\" << ' ' << LG << endl;\n\t\tfor(int i = 1; i < LG; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tst[i][j].w = max(st[i-1][j].w,st[i-1][st[i-1][j].p].w);\n\t\t\t\tif(st[i-1][j].p == -1) st[i][j].p = -1;\n\t\t\t\telse st[i][j].p = st[i-1][st[i-1][j].p].p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getpar(int u, ll k)\n\t{\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(k&(1<<i))\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t}\n\t\t}\n\t\treturn u;\n\t}\n\t\n\tint lca(int u, int v)\n\t{\n\t\tif(h[u] > h[v]) swap(u, v);\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && h[st[i][v].p] >= h[u])\n\t\t\t{\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && st[i][v].p != st[i][u].p)\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\treturn st[0][u].p;\n\t}\n\n\tint distance(int u, int v)\n\t{\n\t\tint lc = lca(u, v);\n\t\treturn (h[u]+h[v]-2*h[lc]);\n\t}\n\t\n\tll maxpath(int u, int v)\n\t{\n\t\tif(h[u] > h[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && h[st[i][v].p] >= h[u])\n\t\t\t{\n\t\t\t\tans = max(st[i][v].w,ans);\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\t//cerr<<\"ANSWER : \"<<ans<<'\\n';\n\t\tif(u == v) return ans;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && st[i][v].p != st[i][u].p)\n\t\t\t{\n\t\t\t\tans = max(st[i][v].w,ans);\n\t\t\t\tans = max(st[i][u].w,ans);\n\t\t\t\tu = st[i][u].p;\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\treturn max(ans,max(st[0][v].w,st[0][u].w));\n\t}\n};\n\nTree t(100001);\n\nstruct Graph\n{\n\tstruct edge\n\t{\n\t\tint v; ll weight;\n\t};\n\tvector<vector<edge> > adj;\n\tint n;\n\t\n\tGraph(int _n)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid addedge(int u, int v, ll c)\n\t{\n\t\tedge tmp;\n\t\ttmp.v = v; tmp.weight = c;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset()\n\t{\n\t\tadj.clear();\n\t}\n\t\n\tvi dist;\n\tvi par;\n\t\n\tvoid bfs(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tqueue<int> q; q.push(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid bfs01(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tdeque<int> q; q.pb(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop_front();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tif(w == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u];\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_front(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tpriority_queue<ii, vector<ii>, greater<ii> > pq;\n\t\tpq.push(ii(0, s));\n\t\twhile(!pq.empty())\n\t\t{\n\t\t\tint u = pq.top().se; ll d = pq.top().fi; pq.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(d + w < dist[v])\n\t\t\t\t{\n\t\t\t\t\tdist[v] = d + w;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tpq.push(ii(dist[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<ll> > d;\n\t\n\tvoid Floyd()\n\t{\n\t\tll INFIN = ll(1e18);\n\t\td.resize(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\td[i].assign(n, INFIN);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\td[i][adj[i][j].v] = adj[i][j].weight;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor(int k = 0; k < n; k++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool BellmanFord(int s) //returns true if negative weight cycle exists\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0;\n\t\tfor(int step = 1; step <= n; step++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\t\tif(dist[v] > dist[u] + w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(step == n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist[v] = dist[u] + w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tll shortest(int s, int e) //returns the distance by Dijkstra\n\t{\n\t\treturn dist[e];\n\t}\n\t\n\tvector<pair<ll, ii> > edges;\n\t\n\tll Kruskal()\n\t{\n\t\tDSU dsu(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\tedges.pb(mp(w, mp(u, v)));\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tll ans = 0; int cnt = 0;\n\t\tfor(int i = 0; i < edges.size(); i++)\n\t\t{\n\t\t\tint u = edges[i].se.fi; int v = edges[i].se.se;\n\t\t\tif(dsu.sameset(u, v)) continue;\n\t\t\tdsu.merge(u, v);\n\t\t\tt.addedge(u,v,edges[i].fi);\n\t\t\tcnt++; ans += edges[i].fi;\n\t\t\tif(cnt >= n - 1) break;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nvector<pair<ii,int> > edges;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m;\n\tcin>>n>>m;\n\tGraph G(n);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u, v, c;\n\t\tcin>>u>>v>>c;\n\t\tu--; v--;\n\t\tedges.pb(mp(mp(u,v),c));\n\t\tG.addedge(u,v,c);\n\t}\n\tll ans = G.Kruskal();\n\t//cerr<<ans<<'\\n';\n\tt.calcpar();\n\tint q; cin>>q;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tcout<<ans-t.maxpath(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n;\nint m;\nstruct edge { int from, to, cost; };\nstruct edge2 { LL to, cost; };\ntypedef pair<int, int> PP;\n\nvector<edge> e;\nvector<edge2> G[4040];\n\nint Par[100000];\nint Rank[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\n// ソート時に比較するための関数 \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nLL kruskal() {\n\tinit(n);\n\tsort(e.begin(), e.end(), comp);\n\tLL ans = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tG[e[i].from].emplace_back(edge2{ e[i].to,e[i].cost });\n\t\t\tG[e[i].to].emplace_back(edge2{ e[i].from,e[i].cost });\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\n\nLL ans[4040][4040];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\te.emplace_back(edge{ a,b,c });\n\t}\n\tLL num = kruskal();\n\tREP(i, n) {\n\t\tstack<pair<int, int>> q;\n\t\tq.push(make_pair(i, -1));\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> cur = q.top();\n\t\t\tq.pop();\n\t\t\tREP(j, G[cur.first].size()) {\n\t\t\t\tif (G[cur.first][j].to != cur.second) {\n\t\t\t\t\tans[i][G[cur.first][j].to] = max(ans[i][cur.first], G[cur.first][j].cost);\n\t\t\t\t\tq.push(make_pair(G[cur.first][j].to, cur.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\tREP(qqq, q) {\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--, t--;\n\t\tcout << num - ans[s][t] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 09:10:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<tuple<int, int, int>> e(m);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    e[i] = make_tuple(z, x, y);\n  }\n  sort(e.begin(), e.end());\n  long long ans = 0;\n  vector<int> fi(n);\n  iota(fi.begin(), fi.end(), 0);\n  vector<int> ne(n, -1);\n  vector<int> nc(n, -1);\n  dsu d(n);\n  for (auto& ee : e) {\n    int x = get<1>(ee);\n    int y = get<2>(ee);\n    int z = get<0>(ee);\n    x = d.get(x);\n    y = d.get(y);\n    if (x != y) {\n      d.p[x] = y;\n      ne[x] = fi[y];\n      nc[x] = z;\n      fi[y] = fi[x];\n      ans += z;\n    }\n  }\n  int start = fi[d.get(0)];\n  vector<int> order(n);\n  vector<int> val(n - 1);\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    if (i < n - 1) {\n      val[i] = nc[start];\n    }\n    order[i] = start;\n    pos[start] = i;\n    start = ne[start];\n  }\n  SparseTable<int> st(val, [&](int i, int j) { return max(i, j); });\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    x = pos[x];\n    y = pos[y];\n    if (x > y) {\n      swap(x, y);\n    }\n    cout << ans - st.get(x, y - 1) << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) os << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <typename T> void print(T a, int n, const string& split = \" \") { for (int i = 0; i < n; i++) { cout << a[i]; if (i + 1 != n) cout << split; } cout << endl; }\ntemplate <typename T> void print2d(T a, int w, int h, int width = -1, int br = 0) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) { if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\ntemplate <typename T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n#define dump(v) (cerr << #v << \": \" << v << endl)\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nclass UnionFind\n{\nprivate:\n    vector<int> data;\n    int _groups;\npublic:\n    int n;\n    UnionFind(int n) : data(n, -1), _groups(n), n(n) { }\n\n    void unite(int x, int y)\n    {\n        x = root(x), y = root(y);\n        if (x != y)\n        {\n            --_groups;\n            if (data[x] > data[y])\n                swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n    int groups() const { return _groups; }\n};\n\nint main() {\n    fast_io();\n\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, pint>> es;\n    rep(i, m) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a, --b;\n        es.push_back(make_pair(c, pint(a, b)));\n    }\n    sort(all(es));\n\n    vector<pair<int, pint>> good_es;\n    {\n        UnionFind uf(n);\n        for (auto& e : es) {\n            int a, b;\n            tie(a, b) = e.second;\n            if (!uf.same(a, b)) {\n                uf.unite(a, b);\n                good_es.push_back(e);\n            }\n        }\n    }\n\n    int q;\n    cin >> q;\n    rep(qi, q) {\n        int s, t;\n        cin >> s >> t;\n        --s, --t;\n\n        UnionFind uf(n);\n        uf.unite(s, t);\n        ll cost = 0;\n        for (auto& e : good_es) {\n            int c = e.first;\n            int a, b;\n            tie(a, b) = e.second;\n            if (!uf.same(a, b)) {\n                uf.unite(a, b);\n                cost += c;\n            }\n        }\n        cout << cost << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define iREP(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\ntypedef long long ll;\n\nint maxcost[4010][4010];\nbool used[4010];\nvector<int> G[4010];\nmap< pair<int,int>,int> cost;\n\nclass UnionFindFixed{\n    vector<int> data;\npublic:\n    UnionFindFixed(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nvoid dfs(int v, int mcost,int ori){\n    stack< pair<int,int> > sta; sta.push(make_pair(v,mcost));\n    while(sta.size()!=0){\n        int vt=sta.top().first;\n        int costt=sta.top().second;\n        sta.pop();\n        used[vt]=true;\n        REP(i,G[vt].size()){\n            if(!used[G[vt][i]]){\n                costt=max(costt,cost[make_pair(vt,G[vt][i])]);\n                maxcost[ori][G[vt][i]]=costt;\n                maxcost[ori][G[vt][i]]=costt;\n                sta.push(make_pair(G[vt][i],costt));\n            }\n        }\n    }\n}\n\nint main(){\n    \n    int N,M; cin>>N>>M;\n    vector< pair<int,pair<int,int> > > v(M);\n    REP(i,M)cin>>v[i].second.first>>v[i].second.second>>v[i].first;\n    sort(v.begin(),v.end());\n    \n    ll totalcost=0;\n    UnionFindFixed inst(4010);\n    REP(i,M){\n        int a=v[i].second.first,b=v[i].second.second,c=v[i].first;\n        if(!inst.findSet(a,b)){\n            inst.unionSet(a,b);\n            G[a].push_back(b);\n            G[b].push_back(a);\n            cost[make_pair(a,b)]=c;\n            cost[make_pair(b,a)]=c;\n            totalcost+=c;\n        }\n    }\n    \n    for(int i=1;i<=N;i++){\n        REP(j,4010)used[j]=false;\n        dfs(i,0,i);\n    }\n    \n   /* for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++)cout<<maxcost[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    \n    int Q; cin>>Q;\n    REP(i,Q){\n        int S,T; cin>>S>>T;\n        cout<<totalcost-maxcost[S][T]<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >ttree[4005];\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < ttree[dst].size(); i++){\n\t\t\tlong long ncost = ttree[dst][i].first;\n\t\t\tlong long next = ttree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid prepare(){\n\tset<long long> done;\n\t//                     cost  ,      src\t,     dst\n\tpriority_queue<pair<long long, pair<long long, long long> >, vector<pair<long long, pair<long long, long long> > >, greater<pair<long long, pair<long long, long long> > > > Q;\n\tQ.push(make_pair(0, make_pair(-1, 0)));\n\twhile(done.size() < N){\n\t\tlong long cost, src, dst;\n\t\tcost = Q.top().first;\n\t\tsrc = Q.top().second.first;\n\t\tdst = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tdone.insert(dst);\n\t\tif(src != -1){\n\t\t\tttree[src].push_back(make_pair(cost, dst));\n\t\t\tttree[dst].push_back(make_pair(cost, src));\n\t\t}\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, make_pair(dst, next)));\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tprepare();\n\t//cout << \"hen = \" << hen <<endl;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing Graph = vector<vector<pair<int, int>>>;\ntemplate <class T>\nusing priority_queue_min = priority_queue<T, vector<T>, greater<T>>;\nGraph minimum_spanning_tree(const Graph &g) {\n    Graph ans(g.size());\n    priority_queue_min<tuple<int, int, int>> Q;\n    vector<bool> used(g.size());\n    int cnt = 0;\n    used[0] = true;\n    cnt++;\n    for (auto &e : g[0]) {\n        Q.emplace(e.second, 0, e.first);\n    }\n    while (cnt < g.size()) {\n        int cost, src, dst;\n        tie(cost, src, dst) = Q.top();\n        Q.pop();\n        if (!used[dst]) {\n            used[dst] = true;\n            cnt++;\n            ans[src].emplace_back(dst, cost);\n            ans[dst].emplace_back(src, cost);\n            for (auto &e : g[dst]) {\n                if (!used[e.first]) Q.emplace(e.second, dst, e.first);\n            }\n        }\n    }\n    return ans;\n}\nInt sum_edge(const Graph &g) {\n    Int ans = 0;\n    for (auto &es : g) for (auto &e : es) ans += e.second;\n    return ans / 2;\n}\nvector<vector<int>> max_edge(const Graph &g) {\n    vector<vector<int>> ans(g.size(), vector<int>(g.size()));\n    stack<pair<int, int>> S;\n    for (int i = 0; i < g.size(); i++) {\n        S.emplace(i, -1);\n        while (!S.empty()) {\n            int curr, prev;\n            tie(curr, prev) = S.top();\n            S.pop();\n            for (auto &e : g[curr]) if (prev != e.first) {\n                S.emplace(e.first, curr);\n                ans[i][e.first] = max(ans[i][curr], e.second);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    for (int i = 0; i < M; i++) {\n        int a, b, c; cin >> a >> b >> c; a--, b--;\n        G[a].emplace_back(b, c);\n        G[b].emplace_back(a, c);\n    }\n    G = minimum_spanning_tree(G);\n    auto sum = sum_edge(G);\n    auto maxE = max_edge(G);\n    int Q; cin >> Q;\n    for (int i = 0; i < Q; i++) {\n        int s, t; cin >> s >> t; s--, t--;\n        cout << sum - maxE[s][t] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nint A[404040],B[404040],C[404040];\nvector<pair<int,int>> E[4040];\nint Q;\nint S[404040],T[404040];\nll D[4040][4040];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<5000> uf;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tpriority_queue<pair<int,int>> EE;\n\tFOR(i,M) {\n\t\tcin>>A[i]>>B[i]>>C[i], A[i]--, B[i]--;\n\t\tE[A[i]].push_back({B[i],C[i]});\n\t\tE[B[i]].push_back({A[i],C[i]});\n\t\tEE.push({-C[i],i});\n\t}\n\tFOR(x,N) FOR(y,N) D[x][y]=(x==y)?0:(1LL<<60);\n\tcin>>Q;\n\tFOR(i,Q) cin>>S[i]>>T[i], S[i]--, T[i]--;\n\t\n\tif(Q>1) return;\n\t\n\tuf(S[0],T[0]);\n\tll tot=0;\n\twhile(EE.size()) {\n\t\tauto e=EE.top();\n\t\tEE.pop();\n\t\tif(uf[A[e.second]]!=uf[B[e.second]]) {\n\t\t\ttot+=-e.first;\n\t\t\tuf(A[e.second],B[e.second]);\n\t\t}\n\t}\n\tcout<<tot<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n  #include \"_DEBUG.hpp\"\n#endif\n#define int long long\nconst int INF = 1LL << 60;\n\nstruct UnionFind{\n  vector<int> par; //親\n  vector<int> size; //集合の大きさ\n\n  UnionFind(int n){\n    par.resize(n); size.resize(n, 1);\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n    }\n  }\n\n  //木の根を求める\n  int root(int x){\n    if(par[x] == x){\n      return x;\n    }else{\n      return par[x] = root(par[x]);\n    }\n  }\n\n  //xとyの属する集合を併合\n  void unite(int x,int y){\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(size[x] < size[y]) swap(x,y);\n    par[y] = x;\n    size[x] += size[y];\n  }\n\n  bool same(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nstruct edge{ \n  int from, to, cost;\n  bool operator<(const edge& p) const {\n    return cost < p.cost;\n  }\n  bool operator>(const edge& p) const {\n    return cost > p.cost;\n  }\n};\n\nvector<int> dikstra(vector<vector<edge>> G, int s){\n  using P = pair<int, int>;\n  priority_queue<P,vector<P>,greater<P>> q;\n  vector<int> d(G.size(), 1LL << 60); //sからの最短距離\n  d[s] = 0;\n  q.push({0, s}); //{最短距離,頂点}\n\n  while(!q.empty()){\n    auto p = q.top(); q.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(auto e : G[v]){\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        q.push(P(d[e.to], e.to));\n      }\n    }\n  }\n  return d;\n}\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v) {\n    for (auto &e : t) fill(e, v);\n}\n// auto v = make_vec<int>(h, w);\n// fill(v, 0);\n\nusing P = pair<int, int>;\n\nsigned main(){\n\n  int n, m; cin >> n >> m;\n  map<P, int> mp;\n  for(int i = 0; i < m; i++){\n    int a, b, c; cin >> a >> b >> c;\n    a--, b--;\n    if(mp.find(P(a, b)) == mp.end()){\n      mp[P(a, b)] = c;\n    }else{\n      mp[P(a, b)] = min(mp[P(a, b)], c);\n    }\n  }\n  vector<edge> es;\n  for(auto p : mp){\n    int a = p.first.first, b = p.first.second, c = p.second;\n    es.push_back({a, b, c});\n    es.push_back({b, a, c});\n  }\n\n  sort(es.begin(), es.end());\n  int total = 0;\n  struct E { int to, cost; };\n  vector<vector<E>> g(n);\n  UnionFind uf(n);\n  for(auto e : es){\n    int u = e.from, v = e.to, cost = e.cost;\n    if(!uf.same(u, v)){\n      total += cost;\n      uf.unite(u, v);\n      g[u].push_back({v, cost});\n      g[v].push_back({u, cost});\n    }\n  }\n\n  auto dp = make_vec<int>(n, n);\n  int start;\n  auto dfs = [&](auto&& dfs, int u, int par, int Max)->void{\n    dp[start][u] = Max;\n    for(auto e : g[u]){\n      if(!(par == e.to)){\n        dfs(dfs, e.to, u, max(Max, e.cost));\n      }\n    }\n  };\n  for(int i = 0; i < n; i++){\n    start = i;\n    dfs(dfs, i, -1, 0);\n  }\n\n  int q; cin >> q;\n  for(int i = 0; i < q; i++){\n    int u, v; cin >> u >> v;\n    u--, v--;\n    int ans = total - dp[u][v];\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <math.h>\n#include <bitset>\n#include <time.h>\n#include <set>\n#include <algorithm>\n#define MAXN 4444\n#define ll long long\nusing namespace std;\n\nint parent[MAXN+2];\nint rankk[MAXN+2];\n\n\nint Find(int x) {\n    if (parent[x] != x) {\n        parent[x]=Find(parent[x]);\n    }\n    return parent[x];\n}\nbool Union(int x,int y) {\n    int xRoot=Find(x);\n    int yRoot=Find(y);\n    if (xRoot==yRoot)\n        return false;\n    \n    \n    if (rankk[xRoot]<rankk[yRoot]) {\n        parent[xRoot]=yRoot;\n    } else if (rankk[xRoot]>rankk[yRoot]) {\n        parent[yRoot]=xRoot;\n    } else {\n        parent[yRoot]=xRoot;\n        rankk[xRoot]++;\n    }\n    return true;\n}\n\n\n\nint main() {\n    int N,M;\n    cin>>N>>M;\n    vector<pair<int,pair<int,int> > > edges;\n    for(int i=1;i<=M;i++) {\n        int u,v,w;\n        cin>>u>>v>>w;\n        edges.push_back(make_pair(w,make_pair(u,v)));\n    }\n    \n    sort(edges.begin(),edges.end());\n    \n    \n    \n    int Q;\n    cin>>Q;\n    \n    for(int q=1;q<=Q;q++) {\n        for(int i=1;i<=N;i++) {\n            parent[i]=i;\n            rankk[i]=0;\n        }\n        int s,t;\n        cin>>s>>t;\n        Union(s,t);\n        ll answer = 0;\n        \n        for(int i=0;i<edges.size();i++) {\n            int u=edges[i].second.first;\n            int v=edges[i].second.second;\n            \n            if (Union(u,v)) {\n                answer+=edges[i].first;\n            }\n        }\n        cout << answer << endl;\n    }\n    \n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\ntypedef std::pair<ll, int> PLI;\n\n/**\n * Lowest Common Ancestor. Call lca(x, y) to get the lca of them.\n * Header Requirement: vector, cassert\n * Verified by: AtCoder ABC014-D (http://abc014.contest.atcoder.jp/submissions/759125)\n */\nclass LowestCommonAncestor {\nprivate:\n  int n, bn;\n  std::vector<PLI> parent; // 0 is root, parent[0] = 0\n  std::vector<int> dep;\n  \n  // Lowest Common Ancestor\n  \n  std::vector<std::vector<PLI> > lca_tbl;\n  \n  void dfs(const std::vector<std::vector<PLI> > &edges, int v, int par, int d, ll x) {\n    parent[v].second = par;\n    parent[v].first = x;\n    dep[v] = d;\n    \n    for (int i = 0; i < edges[v].size(); ++i) {\n      int u = edges[v][i].second;\n      if (u != par) {\n\tdfs(edges, u, v, d + 1, edges[v][i].first);\n      }\n    }\n  }\n  \n  void lca_init(void) {\n    for (int v = 0; v < n; ++v) {\n      lca_tbl[v] = std::vector<PLI>(bn + 1, PLI(0, 0));\n      lca_tbl[v][0] = parent[v];\n    }\n    for (int i = 1; i <= bn; ++i) {\n      for (int v = 0; v < n; ++v) {\n\tPLI tmp = lca_tbl[v][i - 1];\n        PLI tmp2 = lca_tbl[tmp.second][i - 1];\n\tlca_tbl[v][i] = PLI(max(tmp.first, tmp2.first), tmp2.second);\n      }\n    }\n  }\npublic:\n  ll lca(int x, int y) const {\n    int dx = dep[x];\n    int dy = dep[y];\n    ll res = 0;\n    if (dx > dy) {\n      return lca(y, x);\n    }\n    // Go up from y to the depth of x\n    for (int l = bn; l >= 0; --l) {\n      if (dy - dx >= 1 << l) {\n        PLI ny = lca_tbl[y][l];\n\tres = max(res, ny.first);\n\ty = ny.second;\n\tdy -= 1 << l;\n      }\n    }\n\n    assert (dx == dy);\n\n    if (x == y) {\n      return res;\n    }\n  \n    for (int l = bn; l >= 0; --l) {\n      if (lca_tbl[x][l].second != lca_tbl[y][l].second) {\n\tPLI nx = lca_tbl[x][l];\n\tPLI ny = lca_tbl[y][l];\n\tres = max(res, max(nx.first, ny.first));\n\tx = nx.second;\n\ty = ny.second;\n      }\n    }\n    return max(res, lca_tbl[x][0].first);\n  }\n  int depth(int a) const {\n    return dep[a];\n  }\n  LowestCommonAncestor(int n, const std::vector<std::vector<PLI> > &edges)\n    : n(n), parent(n), dep(n), lca_tbl(n) {\n    bn = 0;\n    while (n > 1 << bn) {\n      bn++;\n    }\n    dfs(edges, 0, 0, 0, 0);\n    lca_init();\n  }\n};\n\n\n\nconst int M = 400010;\nint n, m;\nint a[M], b[M];\nll c[M];\n\nconst int N = 4010;\nvector<PLI> edges[N];\n\nll dfs(int v, int p, int t) {\n  if (v == t) {\n    return 0;\n  }\n  REP(i, 0, edges[v].size()) {\n    PLI e = edges[v][i];\n    int w = e.second;\n    if (p == w) continue;\n    ll res = dfs(w, v, t);\n    if (res == -1) continue;\n    return max(res, e.first);\n  }\n  return -1;\n}\n\nll solve(int s, int t) {\n  return dfs(s, -1, t);\n  \n}\n\nint main(void){\n  cin >> n >> m;\n  REP(i, 0, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n  }\n  int q;\n  cin >> q;\n  vector<PLI> pool;\n  ll tot = 0;\n  REP(i, 0, m) {\n    pool.push_back(PLI(c[i], i));\n  }\n  sort(pool.begin(), pool.end());\n  UnionFind uf(n);\n  vector<vector<PLI> > edges_i(n);\n  REP(i, 0, pool.size()) {\n    int idx = pool[i].second;\n    int u = a[idx];\n    int v = b[idx];\n    if (not uf.is_same_set(u, v)) {\n      uf.unite(u, v);\n      tot += pool[i].first;\n      edges[u].push_back(PLI(pool[i].first, v));\n      edges[v].push_back(PLI(pool[i].first, u));\n      edges_i[u].push_back(PLI(pool[i].first, v));\n      edges_i[v].push_back(PLI(pool[i].first, u));\n    }\n  }\n  LowestCommonAncestor lca(n, edges_i);\n  REP(i, 0, q) {\n    int s,t;\n    cin >> s >> t;\n    s--, t--;\n    // max edge in s-t path\n    ll tk = lca.lca(s, t);\n    cout << tot - tk << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 1010;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    tuple<ll, int, int> edges[M];\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = mt(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    vector<pair<int, int>> path[N];\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    // 0を親としたときの各ノードの深さ\n    int d[N];\n    fill(d, d + N, -1);\n    d[0] = 0;\n\n    // lca[x][v] = (vから2^xだけ遡った頂点,\n    //              そこに行くまでに辿った辺でのコストの最大値)\n    pair<int, ll> lca[15][N];\n    lca[0][0] = mp(0, 0);\n\n    // 幅優先探索でdとlca[0]を埋める\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto p : path[v]) {\n            int sv, cost;\n            tie(sv, cost) = p;\n            if (d[sv] >= 0) continue;\n\n            d[sv] = d[v] + 1;\n            lca[0][sv] = mp(v, cost);\n            que.push(sv);\n        }\n    }\n\n    // lcaを埋める\n    for (int x = 1; x < 15; ++x) {\n        for (int v = 0; v < N; ++v) {\n            int mid = lca[x - 1][v].first;\n            ll cost = max(lca[x - 1][v].second, lca[x - 1][mid].second);\n\n            lca[x][v] = mp(lca[x - 1][mid].first, cost);\n        }\n    }\n\n    // ようやくクエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        ll trim = 0;\n        if (d[s] > d[t]) swap(s, t);\n        // d[s] <= d[t]\n        // tの深さをsに合わせる\n\n        while (d[s] < d[t]) {\n            // sより浅くないtの祖先を漁る\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && d[s] > d[lca[x][t].first]) continue;\n                trim = max(trim, lca[x][t].second);\n                t = lca[x][t].first;\n            }\n        }\n\n        // LCAを探す\n        while (s != t) {\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && lca[x][s].first == lca[x][t].first) continue;\n                trim = max(trim, max(lca[x][s].second, lca[x][t].second));\n                s = lca[x][s].first;\n                t = lca[x][t].first;\n            }\n        }\n\n        cout << total - trim << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//\n//                            ▒█████▒▒\n//                             ██████████▒\n//                             ▒████████████▒\n//                            ██████████████████\n//                           ████████████████████▒\n//                          ▒██████████████████████▒\n//                          ▒███████████████████████\n//                      ▒████▒▒▒▒▒▒█████████████████▒\n//                    ███▒▒▒▒▒▒██████████████████████▒▒▒\n//                  ▒██▒▒███████████████████████▒▒▒▒▒██████\n//                 ▒█████████████████████████▒▒▒▒▒▒█████████▒\n//                 ▒█████████████████████▒▒▒▒▒▒██████████████\n//                  ▒████         ████▒▒▒▒▒████         ████▒\n//              ▒█████▒    ████    ▒▒▒▒███████    ████    ██████▒\n//            ▒██▒▒▒▒▒    ██████    █████████    ██████    ██▒▒▒██▒\n//           █████████   ████████   █████████   ████████   ▒▒▒▒█████\n//          ▒█████████    ██████    ████████▒    ██████    █████████\n//          ▒██████████    ████    █████▒▒▒▒▒▒    ████    ██████████\n//           ████████████        ▒▒▒▒▒▒▒████████        ███████████▒\n//       ▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒███████████████████████████████████▒\n//     ███▒▒▒▒▒▒▒▒▒▒▒▒█████████████████████████████████████████▒▒████████▒\n//   ▒▒▒▒▒▒▒▒▒██████████████                         ███████▒▒▒▒███████████\n//   █████████████████████████                     ███████▒▒▒██████████████▒\n//   █████████████████████████████             ███████▒▒▒██████████████████▒\n//   ██████████████████████████████████████████████████████████████████████\n//    ██████████████████████████████████████████████████████████████████▒\n//      ▒█████████████████▒▒▒▒▒▒▒██████████████████████████████████▒▒▒\n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nconst int N = 4000;\nvector<P> edge[N];\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree,sum;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    sum.resize(v);\n    REP(i,v) tree[i] = i, sum[i] = 1;\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return sum[root(i)];\n  }\n\n  bool unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x==y) return false;\n    sum[min(x,y)] += sum[max(x,y)];\n    tree[max(x,y)] = min(x,y);\n    return true;\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nmat dp(N,vec(N,0));\nint root;\nint dfs2(int no, int pare, int mx){\n  dp[root][no] = mx;\n  for(auto to:edge[no]){\n    if(to.fs == pare) continue;\n    dfs2(to.fs,no,max(mx,to.sc));\n  }\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  using T = tuple<int,int,int>;\n  vector<T> a(m);\n  REP(i,m){\n    int x,y,z;\n    cin >> x >> y >> z;\n    x--; y--;\n    a[i] = T(z,x,y);\n  }\n\n  sort(a.begin(),a.end());\n\n  UnionFind uf(n); int sum = 0;\n  REP(i,m){\n    int x,y,z;\n    tie(z,x,y) = a[i];\n    if(uf.unit(x,y)){\n      edge[x].push_back(P(y,z));\n      edge[y].push_back(P(x,z));\n      sum += z;\n    }\n  }\n\n  REP(i,n) root = i, dfs2(i,-1,0);\n\n  int q;\n  cin >> q;\n  REP(_,q){\n    int s,t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum - dp[s][t] << \"\\n\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cstdint>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\nstruct UnionFind {\n  vector<int> c, s;\n  UnionFind(size_t n) : c(n), s(n, 1) { iota(begin(c), end(c), 0); }\n  int root(int i) { return c[i] == i ? i : (c[i] = root(c[i])); }\n  bool same(int i, int j) { return root(i) == root(j); }\n  void unite(int i, int j) {\n    i = root(i); j = root(j);\n    if (i != j) {\n      if (s[i] > s[j]) { c[j] = i; s[i] += s[j]; }\n      else { c[i] = j; s[j] += s[i]; }\n    }\n  }\n  int size(int i) { return s[root(i)]; }\n};\n\ni64 n, m;\nusing P = pair<i64, i64>;\nvector<vector<P>> g;\nvector<vector<i64>> mw;\nvector<bool> vis;\n\nvoid dfs(i64 u, i64 b) {\n  for (auto p : g[u]) {\n    i64 v, c;\n    tie(v, c) = p;\n    if (v == b) continue;\n    dfs(v, u);\n    for (i64 i = 1; i <= n; ++i) {\n      if (vis[i]) {\n        mw[u][i] = mw[i][u] = max(c, mw[v][i]);\n      }\n    }\n  }\n  vis[u] = true;\n}\n\nint main() {\n  cin >> n >> m;\n  vector<tuple<i64, i64, i64>> es, tes;\n  for (i64 i = 0; i < m; ++i) {\n    i64 a, b, c;\n    cin >> a >> b >> c;\n    es.emplace_back(c, a, b);\n  }\n  sort(begin(es), end(es));\n  UnionFind uf(n + 1);\n  i64 csum = 0;\n  for (i64 i = 0; tes.size() < n - 1; ++i) {\n    auto t = es[i];\n    i64 a, b, c;\n    tie(c, a, b) = t;\n    if (!uf.same(a, b)) {\n      tes.emplace_back(c, a, b);\n      csum += c;\n      uf.unite(a, b);\n    }\n  }\n  \n  init_n(g, n + 1);\n  for (auto e : tes) {\n    i64 a, b, c;\n    tie(c, a, b) = e;\n    g[a].emplace_back(b, c);\n    g[b].emplace_back(a, c);\n  }\n\n  init_n(mw, n + 1, vector<i64>(n + 1));\n  init_n(vis, n + 1);\n  dfs(1, 0);\n\n  i64 q;\n  cin >> q;\n  while (q--) {\n    i64 s, t;\n    cin >> s >> t;\n    cout << csum - mw[s][t] << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(...) debug_func_mult(split_names(#__VA_ARGS__), __VA_ARGS__)\n#define DEBUG_ENDL endl << flush\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\") << flush;\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\nstring to_string(const string &s) { return s; }\n\ntemplate <typename T, typename U>\nstring to_string(const P<T, U> &p) {\n    string ret = \"(\";\n    ret += to_string(p.first);\n    ret += \", \";\n    ret += to_string(p.second);\n    ret += \")\";\n    return move(ret);\n}\n\ntemplate <typename T>\nstring to_string(const V<T> &v) {\n    string ret = \"{\";\n    for(const T &t : v) {\n        ret += to_string(t);\n        ret += \", \";\n    }\n    ret += \"}\";\n    return move(ret);\n}\n\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    if(s.size()) cout << s << \" = \";\n    cout << to_string(t) << DEBUG_ENDL_S(s);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(int idx, const V<string> &names, const T &t) {\n    debug_func(t, names[idx]);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(const V<string> &names, const T &t) {\n    debug_func(t, names[0]);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(int idx, const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[idx]);\n    debug_func_mult(idx + 1, names, args...);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[0]);\n    debug_func_mult(1, names, args...);\n}\n\nV<string> split_names(string &&s) {\n    replace(ALL(s), ' ', ',');\n    V<string> ret;\n    istringstream ss(s);\n    string t;\n    while(getline(ss, t, ',')) if(t.size()) ret.push_back(move(t));\n    return move(ret);\n}\n\nvoid init_io() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(30);\n}\n\nclass UnionFind{\n    using vec = vector<ll>;\n    public:\n        vec rank;\n        vec parent;\n\n        UnionFind(ll N){\n            rank = vec(N, 0);\n            parent = vec(N);\n            iota(parent.begin(), parent.end(), 0ll);\n        }\n\n        ~UnionFind(){\n        }\n\n        ll find(ll child){\n            return (child == parent[child] ? child : parent[child] = find(parent[child]));\n        }\n\n        void unit(ll x, ll y){\n            ll px = find(x);\n            ll py = find(y);\n            if(px == py){\n                return;\n            }\n            if(rank[px] < rank[py]){\n                swap(px, py);\n            }\n            parent[py] = px;\n            rank[px] += (rank[px] == rank[py]);\n        }\n\n        bool same(ll x, ll y){\n            return (find(x) == find(y));\n        }\n\n};\n\nusing TLL = tuple<ll, ll, ll>;\n\nint main() {\n    init_io();\n    ll N, M;\n    cin >> N >> M;\n    VV<PLL> edges(N);\n    V<TLL> elis;\n    for(ll i = 0; i < M; i++) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        edges[a].emplace_back(b, c);\n        edges[b].emplace_back(a, c);\n        elis.emplace_back(a, b, c);\n    }\n\n    ll cost = 0;\n    V<TLL> used_edges;\n\n    {\n        UnionFind uf(N);\n        sort(ALL(elis), [](TLL a, TLL b) { return get<2>(a) < get<2>(b); });\n        for(const auto &tup : elis) {\n            ll a, b, c;\n            tie(a, b, c) = tup;\n            if(uf.same(a, b)) continue;\n            uf.unit(a, b);\n            cost += c;\n            used_edges.push_back(tup);\n        }\n    }\n\n    ll Q;\n    cin >> Q;\n    V<PLL> st;\n    for(ll i = 0; i < Q; i++) {\n        ll s, t;\n        cin >> s >> t;\n        st.emplace_back(s - 1, t - 1);\n    }\n    V<ll> rcosts(Q, 0);\n\n    {\n        for(ll i = 0; i < N - 1; i++) {\n            UnionFind uf(N);\n            for(ll j = 0; j < N - 1; j++) {\n                if(i == j) continue;\n                ll a, b, c;\n                tie(a, b, c) = used_edges[j];\n                uf.unit(a, b);\n            }\n\n            ll unusedc = get<2>(used_edges[i]);\n\n            for(ll j = 0; j < Q; j++) {\n                ll s, t;\n                tie(s, t) = st[j];\n                if(uf.same(s, t)) continue;\n                chmax(rcosts[j], unusedc);\n            }\n        }\n    }\n\n    for(ll e : rcosts) cout << cost - e << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e17;\nstruct UnionFind{\n    vector<ll> data;\n    UnionFind(ll size) : data(size, -1) {}\n    bool unionSet(ll x,ll y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(ll x,ll y){\n        return root(x)==root(y);\n    }\n    ll root(ll x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    ll size(ll x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tll from,to,cost;\n\t};\n\tvector<edge>G,tG;\n\tll n;\n\tKRK(ll size){\n\t\tn=size;\n\t}\n\tvoid add_edge(ll a,ll b,ll c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tll krk(){\n\t\tll sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\ttG.pb(e);\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tvoid solve(){\n\t\tll out=krk();\n//\t\trep(i,tG.size())cout<<tG[i].from<<\" \"<<tG[i].to<<endl;\n\t\tll ma=0;\n\t\trep(i,tG.size())ma=max(ma,tG[i].cost);\n\t\tmap<pii,ll>m;\n\t\trep(i,tG.size())m[pii(tG[i].to,tG[i].from)]=m[pii(tG[i].from,tG[i].to)]=tG[i].cost;\n\t\tll q;\n\t\tcin>>q;\n\t\twhile(q--){\n\t\t\tll a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tif(m[pii(a,b)])cout<<out-m[pii(a,b)]<<endl;\n\t\t\telse cout<<out-ma<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tll n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\twhile(m--){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tkrk.add_edge(a,b,c);\n\t}\n\tkrk.solve();\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M, Q; \nlong long sum;\npair<long long, pair<int, int>> E[400010]; \nvector<pair<int, long long>> G[4010]; \nint par[4010]; \nint depth[4010]; \nint sz[4010]; \nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tpar[i] = i; depth[i] = 0; sz[i] = 1; \n\t}\n}\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}\n\telse{\n\t\treturn par[x] = find(par[x]); \n\t}\n}\nvoid unite(int x, int y){\n\tx = find(x); \n\ty = find(y); \n\tif(x == y) return;\n\telse if(depth[x] < depth[y]){\n\t\tpar[x] = y; \n\t\tsz[y] += sz[x]; \n\t}else{\n\t\tpar[y] = x; \n\t\tsz[x] += sz[y];  \n\t\tif(depth[x] == depth[y]) depth[x] ++; \n\t}\n}\nbool same(int x, int y){\n\treturn find(x) == find(y); \n}\nint siz(int x){\n\treturn sz[find(x)]; \n}\nlong long mx[4010][4010]; \nvoid dfs(int r, int v, int p, long long m){\n\tmx[r][v] = m; \n\tfor(auto a : G[v]){\n\t\tif(a.first == p) continue; \n\t\tlong long tmp = m; \n\t\tdfs(r, a.first, v, max(m, a.second)); \n\t\tm = tmp; \n\t}\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0); \n\tcin >> N >> M; \t\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> E[i].second.first >> E[i].second.second >> E[i].first; \n\t\tE[i].second.first --; E[i].second.second --; \n\t}\n\tsort(E, E+M); \n\tinit();  \n\tfor(int i = 0; i < M; i++){\n\t\tint a = E[i].second.first; int b = E[i].second.second; \n\t\tif(same(a, b)) continue; \n\t\tunite(a, b); \n\t\tG[a].emplace_back(b, E[i].first); \n\t\tG[b].emplace_back(a, E[i].first); \n\t\tsum += E[i].first; \n\t}\n\tfor(int i = 0; i < N; i++) dfs(i, i, -1, 0);\n\tcin >> Q; \n\twhile(Q--){\n\t\tint S, T; cin >> S >> T; \n\t\tS--; T--; \n\t\tcout << sum - mx[S][T] << \"\\n\"; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 4005 , M = 4e5 + 10;\nint n , m , cost[N][N] , a[M] , b[M] , c[M] , id[M];\nint Q;\nint fa[N];\nvi contain[N];\nint F(int x) {return fa[x] == x ? x : fa[x] = F(fa[x]);}\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  rep(i,0,m) scanf(\"%d%d%d\",a+i,b+i,c+i),id[i]=i;\n  rep(i,1,n+1) fa[i]=i,contain[i].pb(i);\n  sort(id,id+m,[&](int x,int y){return c[x]<c[y];});\n  ll sum = 0;\n  rep(i,0,m) {\n    int u=F(a[id[i]]) , v=F(b[id[i]]);\n    if(u != v) {\n      sum += c[id[i]];\n      if(sz(contain[u]) < sz(contain[v]))\n        swap(u , v);\n      for(auto e : contain[u])\n        for(auto f : contain[v])\n          cost[e][f] = cost[f][e] = c[id[i]];\n      contain[u].insert(contain[u].end(),all(contain[v]));\n      contain[v].clear();\n      fa[v] = u;\n    }\n  }\n  scanf(\"%d\",&Q);\n  rep(i,0,Q) {\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    printf(\"%lld\\n\",sum-cost[s][t]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 5000;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\ntuple<ll, int, int> edges[500000];\nvector<pair<int, ll>> path[5000];\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = mt(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    // d[v] = 0を親としたときのノードvの深さ\n    int d[N];\n    fill(d, d + N, -1);\n    d[0] = 0;\n\n    // lca[x][v] = (vから2^xだけ遡った頂点,\n    //              そこに行くまでに辿った辺でのコストの最大値)\n    pair<int, ll> lca[15][N];\n    lca[0][0] = mp(0, 0);\n\n    // 幅優先探索でdとlca[0]を埋める\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto p : path[v]) {\n            int sv;\n            ll cost;\n            tie(sv, cost) = p;\n            if (d[sv] >= 0) continue;\n\n            d[sv] = d[v] + 1;\n            lca[0][sv] = mp(v, cost);\n            que.push(sv);\n        }\n    }\n\n    // lcaを埋める\n    for (int x = 1; x < 15; ++x) {\n        for (int v = 0; v < N; ++v) {\n            int mid = lca[x - 1][v].first;\n            ll cost = max(lca[x - 1][v].second, lca[x - 1][mid].second);\n\n            lca[x][v] = mp(lca[x - 1][mid].first, cost);\n        }\n    }\n\n    // ようやくクエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        ll trim = 0;\n        if (d[s] > d[t]) swap(s, t);\n        // d[s] <= d[t]\n\n        // tの深さをsに合わせる\n        while (d[s] < d[t]) {\n            // sより浅くないtの祖先を漁る\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && d[s] > d[lca[x][t].first]) continue;\n                trim = max(trim, lca[x][t].second);\n                t = lca[x][t].first;\n                break;\n            }\n        }\n\n        // LCAを探す\n        while (s != t) {\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && lca[x][s].first == lca[x][t].first) continue;\n                trim = max(trim, max(lca[x][s].second, lca[x][t].second));\n                s = lca[x][s].first;\n                t = lca[x][t].first;\n                break;\n            }\n        }\n\n        cout << total - trim << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum;\n\t};\n\tvector<node> dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p == u) return u;\n\t\tdsu[u].p = rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tvoid merge(int u, int v)\n\t{\n\t\tu = rt(u); v = rt(v);\n\t\tif(u == v) return ;\n\t\tif(rand()&1) swap(u, v);\n\t\tdsu[v].p = u;\n\t\tdsu[u].sum += dsu[v].sum;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) == rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\n\nstruct Graph\n{\n\tstruct edge\n\t{\n\t\tint v; ll weight;\n\t};\n\tvector<vector<edge> > adj;\n\tint n;\n\t\n\tGraph(int _n)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid addedge(int u, int v, ll c)\n\t{\n\t\tedge tmp;\n\t\ttmp.v = v; tmp.weight = c;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset()\n\t{\n\t\tadj.clear();\n\t}\n\t\n\tvi dist;\n\tvi par;\n\t\n\tvoid bfs(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tqueue<int> q; q.push(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid bfs01(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tdeque<int> q; q.pb(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop_front();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tif(w == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u];\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_front(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tpriority_queue<ii, vector<ii>, greater<ii> > pq;\n\t\tpq.push(ii(0, s));\n\t\twhile(!pq.empty())\n\t\t{\n\t\t\tint u = pq.top().se; ll d = pq.top().fi; pq.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(d + w < dist[v])\n\t\t\t\t{\n\t\t\t\t\tdist[v] = d + w;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tpq.push(ii(dist[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<ll> > d;\n\t\n\tvoid Floyd()\n\t{\n\t\tll INFIN = ll(1e18);\n\t\td.resize(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\td[i].assign(n, INFIN);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\td[i][adj[i][j].v] = adj[i][j].weight;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor(int k = 0; k < n; k++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool BellmanFord(int s) //returns true if negative weight cycle exists\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0;\n\t\tfor(int step = 1; step <= n; step++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\t\tif(dist[v] > dist[u] + w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(step == n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist[v] = dist[u] + w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tll shortest(int s, int e) //returns the distance by Dijkstra\n\t{\n\t\treturn dist[e];\n\t}\n\t\n\tvector<pair<ll, ii> > edges;\n\t\n\tll Kruskal()\n\t{\n\t\tDSU dsu(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\tedges.pb(mp(w, mp(u, v)));\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tll ans = 0; int cnt = 0;\n\t\tfor(int i = 0; i < edges.size(); i++)\n\t\t{\n\t\t\tint u = edges[i].se.fi; int v = edges[i].se.se;\n\t\t\tif(dsu.sameset(u, v)) continue;\n\t\t\tdsu.merge(u, v);\n\t\t\tcnt++; ans += edges[i].fi;\n\t\t\tif(cnt >= n - 1) break;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nvector<pair<ii,int> > edges;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m;\n\tcin>>n>>m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u, v, c;\n\t\tcin>>u>>v>>c;\n\t\tu--; v--;\n\t\tedges.pb(mp(mp(u,v),c));\n\t}\n\tint q; cin>>q;\nif(q>3000) return 0;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tGraph G(n);\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tG.addedge(edges[j].fi.fi,edges[j].fi.se,edges[j].se);\n\t\t}\n\t\tG.addedge(u,v,0);\n\t\tcout<<G.Kruskal()<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >ttree[4005];\n\n\nint hen;\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < ttree[dst].size(); i++){\n\t\t\tlong long ncost = ttree[dst][i].first;\n\t\t\tlong long next = ttree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid prepare(){\n\tset<long long> done;\n\t//                     cost  ,      src\t,     dst\n\tpriority_queue<pair<long long, pair<long long, long long> >, vector<pair<long long, pair<long long, long long> > >, greater<pair<long long, pair<long long, long long> > > > Q;\n\tQ.push(make_pair(0, make_pair(-1, 0)));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, src, dst;\n\t\tcost = Q.top().first;\n\t\tsrc = Q.top().second.first;\n\t\tdst = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tdone.insert(dst);\n\t\tif(src != -1){\n\t\t\tttree[src].push_back(make_pair(cost, dst));\n\t\t\tttree[dst].push_back(make_pair(cost, src));\n\t\t\t//cout << \"connect \" << src << \" <-> \" << dst << endl;\n\t\t\t//hen++;\n\t\t}\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, make_pair(dst, next)));\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tprepare();\n\t//cout << \"hen = \" << hen <<endl;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "4 6\n1 3 5\n4 1 10\n2 4 6\n3 2 2\n3 4 5\n2 1 3\n1\n2 3\n"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<pair<int, int> > > adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b, c; cin >> a >> b >> c;\n        a--;  b--;\n        adj[a].push_back({b, c});\n        adj[b].push_back({a, c});\n    }\n    long long sum = 0;\n    // MST\n    vector<vector<pair<int, int> > > temp(n);\n    bool visited[n] = {};\n    visited[0] = true;\n    priority_queue<tuple<int, int, int> > pq; // cost, src, dst\n    int depth[n] = {};\n    for (auto e : adj[0]) pq.push(make_tuple(-e.second, 0, e.first));\n    while (!pq.empty()) {\n        auto e = pq.top(); pq.pop();\n        int cost = -get<0>(e), src = get<1>(e), dst = get<2>(e);\n        if (visited[dst]) continue;\n        visited[dst] = true;\n        depth[dst] = depth[src] + 1;\n        temp[src].push_back({dst, cost});\n        sum += cost;\n        for (auto e : adj[dst])\n            if (!visited[e.first]) pq.push(make_tuple(-e.second, dst, e.first));\n    }\n    temp.swap(adj);\n\n    pair<int, int> par[12][n] = {};\n    for (int k = 0; 1<<k < n; k++)\n        for (int i = 0; i < n; i++)\n            if (k == 0) \n                for (auto e : adj[i])\n                    par[0][e.first] = {i, e.second};\n            else if (depth[i] >= 1<<k) {\n                int a1 = par[k-1][i].first,\n                    a2 = par[k-1][a1].first,\n                    cost1 = par[k-1][i].second,\n                    cost2 = par[k-1][a1].second;\n                par[k][i] = {a2, max(cost1, cost2)};\n            } else\n                par[k][i] = {-1, -1};\n\n    // for (int k = 0; 1<<k < n; k++)\n    //     for (int i = 0; i < n; i++)\n    //         cout << i << ' ' << k << ' ' << par[k][i].second << endl;\n\n    int q; cin >> q;\n    while (q--) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        if (depth[s] < depth[t]) swap(s, t);\n        int mx = 0;\n        for (int d = depth[s] - depth[t], k = 0; d > 0; k++) {\n            if (d & 1<<k) {\n                mx = max(mx, par[k][s].second);\n                s = par[k][s].first;\n                d ^= (1<<k);\n            }\n            // cout << k << ' ' << mx << endl;\n        }\n        if (s != t) {\n            for (int k = 11; k >= 0; k--) {\n                if (1<<k <= depth[s] && par[k][s].first != par[k][t].first) {\n                    mx = max(mx, max(par[k][s].second, par[k][t].second));\n                    s = par[k][s].first;\n                    t = par[k][t].first;\n                }\n            }\n            mx = max(mx, max(par[0][s].second, par[0][t].second));\n        }\n        cout << sum - mx << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,30){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tif(r[i]-l[i]>1){\n\t\t\tif(r[i]==n-1)abort();\n\t\t}\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n  #include \"_DEBUG.hpp\"\n#endif\n#define int long long\nconst int INF = 1LL << 60;\n\nstruct UnionFind{\n  vector<int> par; //親\n  vector<int> size; //集合の大きさ\n\n  UnionFind(int n){\n    par.resize(n); size.resize(n, 1);\n    for(int i = 0; i < n; i++){\n      par[i] = i;\n    }\n  }\n\n  //木の根を求める\n  int root(int x){\n    if(par[x] == x){\n      return x;\n    }else{\n      return par[x] = root(par[x]);\n    }\n  }\n\n  //xとyの属する集合を併合\n  void unite(int x,int y){\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(size[x] < size[y]) swap(x,y);\n    par[y] = x;\n    size[x] += size[y];\n  }\n\n  bool same(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nstruct edge{ int to, cost; };\n\nstruct point{ \n  int v, c;\n  bool operator<(const point& p) const {\n    return c < p.c;\n  }\n  bool operator>(const point& p) const {\n    return c > p.c;\n  }\n };\n\nsigned main(){\n\n  int n, m; cin >> n >> m;\n  vector<vector<edge>> g(n);\n  for(int i = 0; i < m; i++){\n    int a, b, c; cin >> a >> b >> c;\n    a--, b--;\n    g[a].push_back({b, c});\n    g[b].push_back({a, c});\n  }\n\n  int q; cin >> q;\n  for(int i = 0; i < q; i++){\n    int u, v; cin >> u >> v;\n    u--, v--;\n    UnionFind uf(n);\n    uf.unite(u, v);\n    priority_queue<point,vector<point>,greater<point>> q; //最小値\n    for(edge e : g[u]){\n      q.push({e.to, e.cost});\n    }\n    for(edge e : g[v]){\n      q.push({e.to, e.cost});\n    }\n    int ans = 0;\n    while(!q.empty()){\n      auto p = q.top(); q.pop();\n      int from = p.v, cost = p.c;\n      if(!uf.same(u, from)){\n        uf.unite(u, from);\n        ans += cost;\n      }\n      for(auto e : g[from]){\n        if(!uf.same(from, e.to)){\n          q.push({e.to, e.cost});\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q != 1){\n\t\treturn 1;\n\t}\n\t\n\tset<long long> done;\n\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\n\tlong long ans = 0;\n\tQ.push(make_pair(0, S[0]));\n\tQ.push(make_pair(0, T[0]));\n\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\n\n\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a}); // 0:cost, 1:opponent, 2:self\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    cand.erase(begin(cand));\n    if (uf.same(edge[1], edge[2])) {\n      continue;\n    }\n    assert(uf.same(0, edge[2]));\n    assert(!uf.same(0, edge[1]));\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (i, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[i] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    union_find uf(n);\n    vector<bool> use(m);\n    int sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        use[i]=true;\n    }\n\n    vector<vector<pair<int,int>>> graph(n);\n    rep(i,0,m){\n        if(!use[i]) continue;\n        graph[edges[i].from].push_back(make_pair(edges[i].to,edges[i].cost));\n        graph[edges[i].to].push_back(make_pair(edges[i].from,edges[i].cost));\n    }\n\n    vector<vector<int>> max_cost(n,vector<int>(n));\n    vector<bool> done(n);\n    function<void(int,int,int)> dfs=[&](int s,int u,int ma){\n        done[u]=true;\n        max_cost[s][u]=ma;\n        for(auto &p:graph[u]){\n            if(done[p.first]) continue;\n            dfs(s,p.first,max(ma,p.second));\n        }\n        done[u]=false;\n    };\n    rep(i,0,n) dfs(i,i,0);\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-max_cost[s][t] << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1) {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return false;\n        if(par[x] < par[y]) std::swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\nprivate:\n    std::vector<int> par;\n};\n\nstruct edge {\n    int from, to;\n    ll cost;\n    edge(int f, int t, ll c) : from(f), to(t), cost(c) {}\n\n    bool operator<(const edge& that) const {\n        return cost < that.cost;\n    }\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nconstexpr int inf = 1e9;\n\nint main() {\n    int n, m; cin >> n >> m;\n    edges es;\n    for(int i = 0; i < m; ++i) {\n        int a, b, c; cin >> a >> b >> c;\n        es.emplace_back(a - 1, b - 1, c);\n    }\n    sort(begin(es), end(es));\n\n    union_find uf(n);\n    graph g(n);\n    ll ans = 0;\n    for(const auto& e : es) {\n        if(uf.unite(e.from, e.to)) {\n            ans += e.cost;\n            g[e.from].emplace_back(e.from, e.to, e.cost);\n            g[e.to].emplace_back(e.to, e.from, e.cost);\n        }\n    }\n\n    vector<vector<int>> ma(n, vector<int>(n, inf));\n    for(int s = 0; s < n; ++s) {\n        function<void(int, int, int)> dfs = [&] (int v, int p, int cur) {\n            ma[s][v] = cur;\n            for(auto const& e : g[v]) {\n                if(e.to == p) continue;\n                dfs(e.to, v, max(cur, (int)e.cost));\n            }\n        };\n        dfs(s, -1, 0);\n    }\n\n    int q; cin >> q;\n    while(q--) {\n        int s, t; cin >> s >> t;\n        cout << ans - ma[s - 1][t - 1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tvector<pair<ll,pii>>E0;\n\tfr(i,M){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\tE0<<pair<ll,pii>{c,{a,b}};\n\t}\n\tSort(E0);\n\tUnionFind uf;\n\tll mst=0;\n\tvector<vpil>E(N+1);\n\tfor(auto&p:E0){\n\t\tif(!uf.same(p.second)){\n\t\t\tuf.unite(p.second);\n\t\t\tmst+=p.first;\n\t\t\tE[p.second.first]<<pil{p.second.second,p.first};\n\t\t\tE[p.second.second]<<pil{p.second.first,p.first};\n\t\t}\n\t}\n\tvvl pmax(N+1,vl(N+1));\n\tfunction<void(int,int,int,ll)>f=[&](int s,int i,int p,ll m){\n\t\tfor(auto&j:E[i])if(j.first!=p){\n\t\t\tf(s,j.first,i,pmax[s][j.first]=max(m,j.second));\n\t\t}\n\t};\n\tfoor(i,1,N){\n\t\tf(i,i,i,0);\n\t}\n\tint Q;cin>>Q;\n\tfr(i,Q){\n\t\tint S,T;cin>>S>>T;\n\t\tprint(mst-pmax[S][T]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[4001];             // グラフ\nint depth[4001];        // 根付き木の深さ\nint anc[4001][12];      // anc[i][k] := iの2^k個上の祖先\nint query[4001][12];\n \nint data[4001];\nint init(){\n  REP(i,4001)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n        // DEBUG(a);\n        // DEBUG(b);\n      }\n    }\n  }\n \n  queue<int> Q;\n \n  // 根付き木にする\n  // そしてダブリングの準備\n  REP(i,n) depth[i]=INF;\n  REP(i,n)REP(k,12) anc[i][k]=query[i][k]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      Q.push(to);\n      // ダブリング準備\n      anc[to][0] = pos;\n      query[to][0] = c;\n      int id = 1;\n      int cur = pos;\n      while(anc[cur][id-1]!=INF){\n        int next = anc[cur][id-1];\n        anc[to][id] = next;\n        query[to][id] = min(query[to][id-1], query[cur][id-1]);\n        cur = next;\n        ++id;\n      }\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n    // LCAを取る\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    // 同じ高さにズラす\n    int diff = depth[b]-depth[a];\n    int k = 0;\n    while(diff){\n      if(diff&1){\n        CHMIN(x,(ll)query[b][k]);\n        b = anc[b][k];\n      }\n      diff>>=1;\n      ++k;\n    }\n    k = 11;\n    while(k>=0){\n      if(anc[a][k]!=INF && anc[a][k]!=anc[b][k]){\n        CHMIN(x,(ll)query[a][k]);\n        CHMIN(x,(ll)query[b][k]);\n        a = anc[a][k];\n        b = anc[b][k];\n      }\n      --k;\n    }\n    int lca = a;\n    if(a!=b){\n      CHMIN(x,(ll)query[a][0]);\n      CHMIN(x,(ll)query[b][0]);\n      lca = anc[a][0];\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.assign(n, 1);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nstruct LCA {\n        const int LOGM = 30;\n        vector<int> depth, par_w;\n        vector<vector<int>> parent, parmax;\n        LCA(int root, const vector<vector<pair<int, int>>> &g) {\n                int n = g.size();\n                depth.resize(n);\n                par_w.resize(n);\n                parent.resize(LOGM);\n                parmax.resize(LOGM);\n                for (int i = 0; i < LOGM; i ++) { \n                        parent[i].resize(n);\n                        parmax[i].resize(n);\n                }\n                function<void (int, int, int)> dfs = [&](int u, int prev, int d) {\n                        parent[0][u] = prev;\n                        parmax[0][u] = par_w[u];\n                        depth[u] = d;\n                        for (auto e : g[u]) { \n                                int v = e.first;\n                                if (v != prev) { \n                                        par_w[v] = e.second;\n                                        dfs(v, u, d + 1);\n                                }\n                        }\n                };\n                dfs(root, -1, 0);\n                for (int k = 0; k < LOGM - 1; k ++) {\n                        for (int i = 0; i < n; i ++) {\n                                if (parent[k][i] < 0) { \n                                        parent[k + 1][i] = -1;\n                                } else { \n                                        parent[k + 1][i] = parent[k][parent[k][i]];\n                                        if (parent[k + 1][i] >= 0) {\n                                                parmax[k + 1][i] = max(parmax[k][i], parmax[k][parent[k][i]]);\n                                        }\n                                }\n                        }\n                }\n        }\n        int lca(int u, int v) { \n                if (depth[u] > depth[v]) swap(u, v);\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((depth[v] - depth[u]) >> k & 1) { \n                                v = parent[k][v];\n                        }\n                }\n                if (u == v) return u;\n                for (int k = LOGM - 1; k >= 0; k --) {\n                        if (parent[k][u] != parent[k][v]) {\n                                u = parent[k][u];\n                                v = parent[k][v];\n                        }\n                }\n                return parent[0][u];\n        }\n        int dist(int u, int v) {\n                return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n        }\n        int getmax(int v, int ancestor) {\n                int res = 0;\n                int d = depth[v] - depth[ancestor];\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((d >> k) & 1) {\n                                res = max(res, parmax[k][v]);\n                                v = parent[k][v];\n                        }\n                }\n                return res;\n        }\n};\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<pair<int, pair<int, int>>> es;\n        for (int i = 0; i < m; i ++) {\n                int a, b, c;\n                scanf(\"%d%d%d\", &a, &b, &c);\n                a --, b --;\n                es.push_back({c, {a, b}});\n        }\n        sort(es.begin(), es.end());\n        vector<pair<int, pair<int, int>>> use;\n        UnionFind uf(n);\n        long long tot = 0;\n        for (int i = 0; i < (int) es.size(); i ++) {\n                int a, b;\n                tie(a, b) = es[i].second;\n                if (uf.same(a, b)) continue;\n                uf.unite(a, b);\n                use.push_back(es[i]);\n                tot += es[i].first;\n        }\n        assert((int) use.size() == n - 1);\n        vector<vector<pair<int, int>>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int c = use[i].first;\n                int a = use[i].second.first;\n                int b = use[i].second.second;\n                g[a].push_back({b, c});\n                g[b].push_back({a, c});\n        }\n        LCA lca(0, g);\n        int q;\n        scanf(\"%d\", &q);\n        while (q --) {\n                int s, t;\n                scanf(\"%d%d\", &s, &t);\n                s --, t --;\n                int l = lca.lca(s, t);\n                int maxval = max(lca.getmax(s, l), lca.getmax(t, l));\n                printf(\"%lld\\n\", tot - maxval);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef pair<long long, ii> iii;\n\nclass UnionFindDS{\nprivate:\n    vector<int> p, sz;   // parent, size\n    int num;\npublic:\n    UnionFindDS(int N){\n        p.assign(N,0); for (int i = 0; i < N; i++) p[i] = i;\n        sz.assign(N,1); num = N;\n    }\n    int numSets(){ return num; }\n    int findSet(int i){ return p[i] == i ? i : p[i] = findSet(p[i]); }\n    int sizeSet(int i){ return sz[findSet(i)]; }\n    bool isSameSet(int i, int j){ return findSet(i) == findSet(j); }\n    void unionSet(int i, int j){\n        if ((i = findSet(i)) == (j = findSet(j))) return;\n        \n        num--;\n        p[j] = i; sz[i] += sz[j];\n    }\n};\n\nint N, M, Q;\nvector<iii> edge;\n\nint main() {\n\n    scanf(\"%d%d\", &N, &M);\n    for (int i = 0, u, v; i < M; i++) {\n        long long w;\n        scanf(\"%d%d%lld\", &u, &v, &w);\n\n        edge.push_back(iii(w, ii(u, v)));\n    }\n\n    sort(edge.begin(), edge.end());\n\n    scanf(\"%d\", &Q);\n    for (int i = 0, u, v; i < Q; i++) {\n        scanf(\"%d%d\", &u, &v);\n\n        UnionFindDS uf(N+1);\n        uf.unionSet(u, v);\n\n        long long ans = 0;\n        for (int i = 0; i < edge.size(); i++) {\n            long long w = edge[i].first;\n            long long u = edge[i].second.first;\n            long long v = edge[i].second.second;\n\n            if (uf.isSameSet(u, v)) continue;\n\n            uf.unionSet(u, v); ans += w;\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    scanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n    a[i]--; b[i]--;\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<long long>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  int sz = 12;\n  \n  vector<vector<int>> p(n, vector<int>(sz, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(sz, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<sz; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n\n    long long sub = 0;\n\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<sz; k++){\n      if( ((depth[v] - depth[u]) >> k) & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=sz-1; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n    if(u!=v){\n      sub = max({sub, mx_e[u][0], mx_e[v][0]});\n    }\n\n    printf(\"%lld\\n\", mst_cost - sub);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define VI vector<int>\n\nvoid dfs(int node, int f, vector<VI> &G, vector<VI> &C, VI &d, int val) {\n    d[node] = val;\n    for(int i = 0; i < int(G[node].size()); ++i) {\n        int temp = G[node][i];\n        if(temp == f)\n            continue;\n        dfs(temp, node, G, C, d, max(val, C[node][i]));\n    }\n}\n\nint main() {\n    //ifstream cin(\"testA.in\");\n\n    int n, m; cin >> n >> m;\n    vector<int> a(m, 0), b(m, 0), c(m, 0);\n    vector<pair<int, int>> edges;\n\n    for(int i = 0; i < m; ++i) {\n        cin >> a[i] >> b[i] >> c[i];\n        a[i]--;\n        b[i]--;\n    }\n\n    for(int i = 0; i < m; ++i) {\n        edges.push_back({c[i], i});\n    }\n\n    sort(edges.begin(), edges.end());\n\n    vector<int> dad(n, 0), sz(n, 0);\n    for(int i = 0; i < n; ++i)\n        dad[i] = i;\n\n    auto f = [&] (int x) {\n        int root = x;\n        int steps = 0;\n        while(root != dad[root]) {\n            root = dad[root];\n            ++steps;\n        }\n        while(x != root) {\n            int temp = dad[x];\n            dad[x] = root;\n            x = temp;\n        }\n        return root;\n    };\n\n    auto unite = [&] (int a, int b) {\n        dad[a] = b;\n    };\n    \n    vector<vector<int>> G(n), C(n);\n    long long ans = 0;\n\n    for(auto edge : edges) {\n        int x = a[edge.second];\n        int y = b[edge.second];\n        if(f(x) != f(y)) {\n            ans += edge.first;\n            unite(f(x), f(y));\n            G[x].push_back(y);\n            G[y].push_back(x);\n            C[x].push_back(edge.first);\n            C[y].push_back(edge.first);\n        }\n    }\n        \n    vector<vector<int>> d(n, vector<int> (n, 0));\n    \n    for(int i = 0; i < n; ++i) {\n        int now = 0;\n        dfs(i, -1, G, C, d[i], now);\n    }\n\n    int q; cin >> q;\n    for(int i = 0; i < q; ++i) {\n        int x, y; cin >> x >> y;\n        x--;y--;\n        cout << ans - d[x][y] << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=4003,INF=1<<30;\nll dis[MAX][MAX];\nvector<pair<int,ll>> G[MAX];\nint V;\n\nstruct edge{int from,to;ll dis;};\n\nbool compare(edge a,edge b){\n    return a.dis<b.dis;\n}\n\nint par[MAX];\n\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n    }\n}\n\nint root(int a){\n    if(par[a]==a) return a;\n    else return par[a]=root(par[a]);\n}\n\nvoid unite(int a,int b){\n    if(root(a)!=root(b)) par[root(b)]=root(a);\n}\n\nbool check(int a,int b){\n    return root(a)==root(b);\n}\n\nvoid BFS(){\n    for(int i=0;i<V;i++){\n        for(int j=0;j<V;j++){\n            dis[i][j]=-1;\n        }\n        dis[i][i]=0;\n        queue<int> Q;\n        Q.push(i);\n        \n        while(!Q.empty()){\n            int a=Q.front();Q.pop();\n            for(int k=0;k<G[a].size();k++){\n                int b=G[a][k].first;\n                ll c=G[a][k].second;\n                \n                if(dis[i][b]!=-1) continue;\n                \n                dis[i][b]=max(dis[i][a],c);\n                Q.push(b);\n            }\n        }\n    }\n}\n\n\nint main(){\n    \n    int E;cin>>V>>E;\n    vector<edge> S(E);\n    for(int i=0;i<E;i++){\n        int a,b;\n        ll c;cin>>a>>b>>c;\n        a--;b--;\n        S[i]={a,b,c};\n    }\n    \n    sort(all(S),compare);\n    \n    init(V);\n    \n    ll sum=0;\n    \n    for(int i=0;i<E;i++){\n        int a=S[i].from,b=S[i].to;\n        ll c=S[i].dis;\n        if(check(a,b)) continue;\n        unite(a,b);\n        sum+=c;\n        G[a].push_back({b,c});\n        G[b].push_back({a,c});\n    }\n    \n    BFS();\n    \n    int Q;cin>>Q;\n    while(Q){\n        int a,b;cin>>a>>b;\n        a--;b--;\n        cout<<sum-dis[a][b]<<endl;\n        \n        Q--;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\n\nstruct uni {\n  vector<int> p;\n  uni(int n) :\n      p(n, -1) {}\n  int root(int a) {\n    return p[a] < 0 ? a : (p[a] = root(p[a]));\n  }\n  bool find(int a, int b) {\n    return root(a) == root(b);\n  }\n  bool merge(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return false;\n    p[a] = b;\n    return true;\n  }\n};\n\nstruct edge {\n  int f, t, c;\n  edge() {}\n  edge(int f, int t, int c) :\n      f(f), t(t), c(c) {}\n  bool operator<(const edge& e) const {\n    return c < e.c;\n  }\n};\n\nedge e[444444];\nvector<edge> g[4444];\nint res[4444][4444];\n\nint solve(int f, int t, int p) {\n  for (int i = 0; i < int(g[f].size()); i++) {\n    if (g[f][i].t == p) continue;\n    if (g[f][i].t == t) {\n      return g[f][i].c;\n    } else {\n      int r = solve(g[f][i].t, t, f);\n      if (r > 0) {\n        return max(g[f][i].c, r);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  uni u(n);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &e[i].f, &e[i].t, &e[i].c);\n    --e[i].f;\n    --e[i].t;\n  }\n  sort(e, e+m);\n  long long c = 0;\n  for (int i = 0; i < m; i++) {\n    if (u.merge(e[i].f, e[i].t)) {\n      c += e[i].c;\n      g[e[i].f].push_back(edge(e[i].f, e[i].t, e[i].c));\n      g[e[i].t].push_back(edge(e[i].t, e[i].f, e[i].c));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = i+1; j < n; j++) {\n      res[i][j] = res[j][i] = solve(i, j, -1);\n    }\n  }\n  int q; scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int s, t; scanf(\"%d%d\", &s, &t); --s; --t;\n    printf(\"%lld\\n\", c-res[s][t]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#ifdef DEBUG\n#define show(...) cerr << #__VA_ARGS__ << \" = \", debug(__VA_ARGS__);\n#else\n#define show(...) 42\n#endif\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> a) {\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n    for (auto x : v) os << x << ' ';\n    return os;\n}\nvoid debug() {\n    cerr << '\\n';\n}\ntemplate <typename H, typename... T>\nvoid debug(H a, T... b) {\n    cerr << a;\n    if (sizeof...(b)) cerr << \", \";\n    debug(b...);\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\nstruct edge{\n    int to;\n    ll cost;\n};\nvector<edge> g[5000];\nint dp[5000][5000];\nvoid dfs(const int s, int par,int t){\n    for(auto &x : g[t]){\n        if(x.to == par)continue;\n        dp[s][x.to] = max(dp[s][t], (int)x.cost);\n        dfs(s,t,x.to);\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<pair<ll,pii>>e;\n    while(m--){\n        int a,b;\n        ll c;\n        cin >> a >> b >> c;\n        a--,b--;\n        e.push_back({c,{a,b}});\n    }\n    sort(e.begin(),e.end());\n    UnionFind uf(n);\n    ll sum = 0;\n    for(auto &x: e){\n        if(!uf.same(x.second.first,x.second.second)){\n            uf.unite(x.second.first,x.second.second);\n            sum += x.first;\n            int a = x.second.first;\n            int b = x.second.second;\n            ll c = x.first;\n            g[a].push_back((edge){b,c});\n            g[b].push_back((edge){a,c});\n        }\n    }\n    show(sum);\n    rep(i,n)dfs(i,-1,i);\n    int q;\n    cin >> q;\n    while(q--){\n        int s,t;\n        cin >> s >> t;\n        s--,t--;\n        cout << sum - dp[s][t] << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nstruct edge{\n    ll a, b, c;\n    bool operator<(const edge &another) const{\n        return (c < another.c);\n    }\n};\n\nstruct UnionFind{\n    vector<int> par;\n\n    UnionFind(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nll ma[4040][4040];\nvector<pll> G[4040];\n\nvoid dfs(ll root, ll par, ll now, ll mx){\n    if(ma[root][now] != -1) return;\n    ma[root][now] = mx;\n    REP(i, G[now].size()){\n        ll next = G[now][i].first;\n        ll cost = G[now][i].second;\n        if(next == par) continue;\n        dfs(root, now, next, max(mx, cost));\n    }\n    return;\n}\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    vector<edge> edges(M);\n    REP(i, M){\n        ll a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        edges[i].a = a;\n        edges[i].b = b;\n        edges[i].c = c;\n    }\n    sort(edges.begin(), edges.end());\n    UnionFind uf(N);\n    ll total_weight = 0;\n    REP(i, M){\n        edge e = edges[i];\n        if(uf.merge(e.a, e.b)){\n            G[e.a].push_back({e.b, e.c});\n            G[e.b].push_back({e.a, e.c});\n            total_weight += e.c;\n        }\n    }\n\n    REP(i, 4040)REP(j, 4040){\n        ma[i][j] = -1;\n    }\n\n    REP(i, N) dfs(i, -1, i, 0);\n\n    ll Q;\n    cin >> Q;\n    while(Q--){\n        ll S, T;\n        cin >> S >> T;\n        S--, T--;\n        cout << total_weight - ma[S][T] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntypedef struct UnionFind_ {\n  vector<int> par;\n  vector<int> rank_;\n  UnionFind_(int n): rank_(n, 0) {\n    for(int i = 0; i < n; i++)par.push_back(i);\n  }\n  int find(int x) {\n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  bool same(int x, int y) {\n    if(find(x) == find(y))return true;\n    else return false;\n  }\n  bool unite(int x, int y){\n    int xp = find(x);\n    int yp = find(y);\n    if(xp == yp)return false;\n    if(rank_[xp] > rank_[yp])par[yp] = xp;\n    else if(rank_[xp] < rank_[yp])par[xp] = yp;\n    else {\n      par[yp] = xp;\n      rank_[xp]++;\n    }\n    return true;\n  }\n} UnionFind;\n\ntemplate <typename T>\nstruct edge{\n  int from;\n  int to;\n  T cost;\n};\n\ntemplate <typename T>\nbool comp(const edge<T> &a, const edge<T> &b){\n  return a.cost < b.cost;\n}\n\ntemplate <typename T>\nstruct Graph {\n  int n;\n  vector<edge<T>> es;\n  vector<vector<pair<int, ll>>> vv; \n  Graph(int n_){\n    n = n_;\n    vv.resize(n);\n  }\n  void adde(int from, int to, T cost){\n    es.push_back((edge<T>){from, to, cost});\n  }\n  T kruskal(){\n    T res = 0;\n    UnionFind uf(n);\n    sort(es.begin(), es.end(), comp<T>);\n    for(auto e: es){\n      int from = e.from;\n      int to = e.to;\n      T cost = e.cost;\n      if(uf.same(from, to))continue;\n      vv[from].pb(mk(to, cost));\n      vv[to].pb(mk(from, cost));\n      res += cost;\n      uf.unite(from, to);\n    }\n\n    return res;\n  }\n};\n\nusing GraphI = Graph<int>;\nusing GraphL = Graph<ll>;\n\nll mini[4001][4001];\nbool vis[4001];\nll maxi = 0;\nint at = 0;\nvector<vector<pair<int, ll>>> vv;\n\nvoid dfs(int i){\n  vis[i] = true;\n  ll tmp = maxi;\n  for(auto e: vv[i]){\n    if(vis[e.FI])continue;\n    maxi = max(maxi, e.SE);\n    mini[at][e.FI] = maxi;\n    dfs(e.FI);\n    maxi = tmp;\n  }\n}\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  GraphL graph(n);\n  rep(i, m){\n    int a, b;\n    ll c;\n    cin >> a >> b >> c, a--, b--;\n    graph.adde(a, b, c);\n    graph.adde(b, a, c);\n  }\n  ll res = graph.kruskal();\n  vv = graph.vv;\n  rep(i, n){\n    fill(vis, vis + n, false);\n    at = i;\n    maxi = 0;\n    dfs(i);\n  }\n  int q;\n  cin >> q;\n  rep(i, q){\n    int s, t;\n    cin >> s >> t, s--, t--;\n    cout << res - mini[s][t] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n//OK\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n//OK\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\t//ans[a][b] = res;\n\t\t\t//ans[b][a] = res;\n\t\t}\n\t}\n//RE\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ull INF = ULLONG_MAX;\nconst ll MOD = 998244353;\n\ntypedef ll Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> Prim(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tEdges T;\n\tWeight total = 0;\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-1, r, 0));\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif (visited[e.dst])\n\t\t\tcontinue;\n\t\tif(e.src!=-1)T.push_back(e);\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tfor (__typeof(g[e.dst].begin()) f = g[e.dst].begin();\n\t\t\t\tf != g[e.dst].end(); f++)\n\t\t\tif (!visited[f->dst])\n\t\t\t\tQ.push(*f);\n\t}\n\treturn pair<Weight, Edges>(total, T);\n}\n\nstruct HLDecomposition{\n  int V;\n  vector<vint> g;\n  vint dep,par,head,size,inv;\n  vint in,out;\n  int t;\n  HLDecomposition(int size_)\n  :V(size_),g(V),dep(V,0),par(V,-1),head(V),size(V),inv(V),in(V),out(V),t(0){}\n\n  void add_edge(int u,int v){\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  void dfs_size(int v=0){\n    size[v]=1;\n    for(int& u:g[v]){\n      if(par[u]>=0)continue;\n      par[u]=v;\n      dfs_size(u);\n      size[v]+=size[u];\n      if(size[u]>size[g[v][0]]){\n        swap(u,g[v][0]);\n      }\n    }\n  }\n  void dfs_hld(int v=0){\n    in[v] = t++;\n    inv[in[v]]=v;\n    for(int& u:g[v]){\n      if(par[u]!=v)continue;\n      head[u]=(u==g[v][0]?head[v]:u);\n      dfs_hld(u);\n    }\n    out[v]=t;\n  }\n\n  void build(int root=0){\n    par[root]=0;\n    dfs_size(root);\n    par[root]=-1;\n    dfs_hld(root);\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(in[u]>in[v])swap(u,v);\n      if(head[u]==head[v])return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\n\ninline int get_min2pow(int n) {\n\tint res = 1;\n\twhile (res < n)\n\t\tres *= 2;\n\treturn res;\n}\n\n///Segment Tree////////\n\ntemplate<typename T,T dval>\nstruct segtree {\n\tint N;\n\tvector<T> node;\n\t//例外値　ex)INF,0\n\tT default_value = dval;\n\tstatic inline T merge(const T& l, const T& r) {\n\t\t//RMQ\n\t\treturn max(l,r);\n\t\t//RSQ\n\t\t//return l+r;\n\t}\n\tsegtree(int n) {\n\t\tN = get_min2pow(n);\n\t\tnode.resize(2 * N, default_value);\n\t}\n\tsegtree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tN = get_min2pow(sz);\n\t\tnode.resize(2 * N, default_value);\n\t\tfor (int i = 0; i < sz; i++)\n\t\t\tnode[i + N - 1] = v[i];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t\tnode[i] = merge(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\t// update k th element\n\tvoid update(int k, T val) {\n\t\tk += N - 1; // leaf\n\t\tnode[k] = val;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l)\n\t\t\treturn default_value;\n\t\tif (a <= l and r <= b)\n\t\t\treturn node[k];\n\t\tint m = (l + r) / 2;\n\t\tT vl = query(a, b, k * 2 + 1, l, m);\n\t\tT vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn merge(vl, vr);\n\t}\n};\n\n\n\nint main(){\n  int N,M;cin>>N>>M;\n  Graph g(N);\n  repeat(i,M){\n    int a,b;Weight c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back({a,b,c});\n    g[b].push_back({b,a,c});\n  }\n  Weight total;\n  Edges tree;\n  tie(total,tree)=Prim(g);\n  HLDecomposition hld(N);\n  repeat(i,tree.size()){\n    hld.add_edge(tree[i].src,tree[i].dst);\n  }\n  hld.build();\n  segtree<ll,0> RMQ(N);\n  repeat(i,tree.size()){\n    if(hld.in[tree[i].src]>hld.in[tree[i].dst])swap(tree[i].src,tree[i].dst);\n    RMQ.update(hld.in[tree[i].dst],tree[i].weight);\n  }\n  int Q;cin>>Q;\n  repeat(q,Q){\n    int s,t;cin>>s>>t;s--;t--;\n    ll mx=0;\n    while(1){\n      if(hld.in[s]>hld.in[t])swap(s,t);\n      if(hld.head[s]!=hld.head[t]){\n        mx = max(mx,RMQ.query(hld.in[hld.head[t]],hld.in[t]+1));\n        t=hld.par[hld.head[t]];\n      }else{\n        if(s!=t)mx = max(mx,RMQ.query(hld.in[s]+1,hld.in[t]+1));\n        break;\n      }\n    }\n    cout << total-mx<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> P2;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N, M, Q;\nint U[4000], R[4000];\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n}\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvector<P> G[4000];\nint par[4000], dep[4000];\nint pare[4000];\nvoid dfs(int x, int p, int r, int pe) {\n  par[x] = p;\n  pare[x] = pe;\n  dep[x] = r;\n  for (P pp : G[x]) if (pp._1 != p) dfs(pp._1, x, r+1, pp._2);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  vector<P2> edges;\n  rep(i, M) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--, b--;\n    edges.pb(P2(c, P(a, b)));\n  }\n  rep(i, N) U[i] = i, R[i] = 1;\n  sort(all(edges));\n  long long sum = 0;\n  for (P2 p : edges) {\n    int c = p._1, a = p._2._1, b = p._2._2;\n    if (!same(a, b)) {\n      G[a].pb(P(b, c));\n      G[b].pb(P(a, c));\n      unite(a, b);\n      sum += c;\n    }\n  }\n  dfs(0, -1, 0, 0);\n  cin >> Q;\n  rep(i, Q) {\n    int s, t;\n    cin >> s >> t;\n    s--, t--;\n    int m = 0;\n    if (dep[s] < dep[t]) swap(s, t);\n    while (dep[s] > dep[t]) {\n      m = max(m, pare[s]), s = par[s];\n    }\n    while (s != t) {\n      m = max(m, pare[s]), s = par[s];\n      m = max(m, pare[t]), t = par[t];\n    }\n    cout << sum-m << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nclass UF {\n\tpublic:\n\tstatic const int ufmax=100052;\n\tint ufpar[ufmax],ufrank[ufmax],ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init(){int i; rep(i,ufmax) { ufpar[i]=i; ufrank[i]=0; ufcnt[i]=1; } }\n\tint find(int x) {\treturn (ufpar[x]==x)?(x):(ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x,int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x==y) return;\n\t\tif(ufrank[x]<ufrank[y]) ufpar[x]=y, ufcnt[y]+=ufcnt[x];\n\t\telse {ufpar[y]=x; ufcnt[x]+=ufcnt[y]; if(ufrank[x]==ufrank[y]) ufrank[x]++;}\n\t}\n};\nUF uf;\nVV(pii) vv;\nvint d;\nvector<pii> p;\n\n\nvoid dfs(int x, int dd = 0, int par = -1){\n\td[x] = dd;\n\tfor(pii y: vv[x]){\n\t\tif(par == y.fi) continue;\n\t\tdfs(y.fi, dd+1, x);\n\t\tp[y.fi] = pii(x,y.se);\n\t}\n}\n\nvoid mainmain(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<pair<int,pii>> v(m);\n\trep(i,m){\n\t\tcin>>v[i].se.fi>>v[i].se.se>>v[i].fi;\n\t}\n\tvv = VV(pii)(n);\n\tsort(ALL(v));\n\tll ans = 0;\n\trep(i,m){\n\t\tint a = v[i].se.fi;\n\t\tint b = v[i].se.se;\n\t\ta--,b--;\n\t\tif(uf[a] == uf[b]) continue;\n\t\tuf.unite(a,b);\n\t\tvv[a].PB(pii(b,v[i].fi));\n\t\tvv[b].PB(pii(a,v[i].fi));\n\t\tans += v[i].fi;\n\t}\n\td = vint(n);\n\tp = vector<pii>(n);\n\tdfs(0);\n\tint Q;\n\tcin>>Q;\n\trep(_,Q){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\ts--,t--;\n\t\tint tmp = 0;\n\t\twhile(s!=t){\n\t\t\tif(d[s]>d[t]){\n\t\t\t\tmaxs(tmp, p[s].se);\n\t\t\t\ts = p[s].fi;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmaxs(tmp, p[t].se);\n\t\t\t\tt = p[t].fi;\n\t\t\t}\n\t\t}\n\t\tcout<<ans-tmp<<endl;\n\t}\n\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\n#define mk make_pair\n#define pb push_back\n\nint N, M, Q;\nstruct edge\n{\n    ll cost;\n    int from;\n    int to;\n};\nedge E[400400];\n\nstruct branch\n{\n    int to;\n    ll cost;\n};\n\nvector<branch> G[4040];\n\nbool cmpc(const edge a, const edge b)\n{\n    return a.cost < b.cost;\n}\n\nint ufpar[4040], ufsize[4040];\n\nvoid init()\n{\n    for(int i = 0; i < N; i++){\n        ufpar[i] = i;\n        ufsize[i] = 1;\n    }\n    return;\n}\n\nint root(int x)\n{\n    if(ufpar[x] == x)return x;\n    return ufpar[x] = root(ufpar[x]);\n}\n\nbool same(int x, int y)\n{\n    return root(x) == root(y);\n}\n\nvoid unite(int x, int y)\n{\n    x = root(x);\n    y = root(y);\n    if(x == y)return;\n    if(ufsize[x] > ufsize[y])swap(x, y);\n    ufsize[y] += ufsize[x];\n    ufpar[x] = y;\n    return;\n}\n\nll dis[4040], mxe[4040][30];\nint dep[4040], par[4040], dpar[4040][30];\n\nvoid dfs(int v, int p, ll di, int de)\n{\n    dis[v] = di;\n    dep[v] = de;\n    par[v] = p;\n    for(int i = 0; i < (int)G[v].size(); i++){\n        branch e = G[v][i];\n        if(p == e.to)continue;\n        dfs(e.to, v, di + e.cost, de + 1);\n    }\n    return;\n}\n\nint LCA(int x, int y)\n{\n    if(dep[x] > dep[y])swap(x, y);\n    int dif = dep[y] - dep[x];\n    for(int i = 20; i >= 0; i--){\n        if((dif >> i) & 1){\n            y = dpar[y][i];///深いほうを深い分だけ浅くしていく\n        }\n    }\n    if(x == y)return x;\n    for(int i = 20; i >= 0; i--){\n        if(dpar[x][i] != dpar[y][i]){\n            x = dpar[x][i];\n            y = dpar[y][i];\n        }\n    }\n    return dpar[x][0];\n}\n\nll pathmax(int l, int x)\n{\n    int dif = dep[x] - dep[l];\n    ll ret = 0;\n    for(int i = 20; i >= 0; i--){\n        if((dif >> i) & 1){\n            ret = max(ret, mxe[x][i]);\n            x = dpar[x][i];\n        }\n    }\n    return ret;\n}\n\nsigned main()\n{\n    cin >> N >> M;\n    for(int i = 0; i < M; i++){\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        E[i] = {c, a, b};\n    }\n    sort(E, E + M, cmpc);\n    init();\n    ll csum = 0ll;\n    for(int i = 0; i < M; i++){\n        edge e = E[i];\n        if(!same(e.from, e.to)){///UF木\n            unite(e.from, e.to);\n            G[e.from].pb({e.to, e.cost});\n            csum += e.cost;\n            G[e.to].pb({e.from, e.cost});\n        }\n    }\n    dfs(0, -1, 0ll, 0);///各頂点の親と深さと根からの距離を保存\n    for(int i = 0; i < N; i++){///ダブリング\n        dpar[i][0] = par[i];\n        if(par[i] < 0) mxe[i][0] = 0ll;\n        else mxe[i][0] = dis[i] - dis[par[i]];\n    }\n    for(int k = 0; k < 20; k++){\n        for(int i = 0; i < N; i++){\n            if(dpar[i][k] < 0){\n                dpar[i][k + 1] = -1;\n                mxe[i][k + 1] = 0ll;\n            }\n            else {\n                dpar[i][k + 1] = dpar[dpar[i][k]][k];\n                mxe[i][k + 1] = max(mxe[i][k], mxe[dpar[i][k]][k]);\n            }\n        }\n    }\n    ///query & LCA\n    cin >> Q;\n    for(int i = 0; i < Q; i++){\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        int L = LCA(a, b);\n        //ll res = dis[a] - dis[L] + dis[b] - dis[L];\n        //printf(\"LCA:%d dis[a]:%lld dis[b]:%lld dis[LCA]:%lld\\n\", L, dis[a], dis[b], dis[L]);\n        ll res = max(pathmax(L, a), pathmax(L, b));\n        printf(\"%lld\\n\", csum - res);\n    }\n    /*\n    for(int i = 0; i < N; i++){\n        printf(\"dis[%d]:%lld dep[%d]:%d\\n\", i, dis[i], i, dep[i]);\n    }\n    for(int i = 0; i < N; i++){\n        printf(\"dpar[%d][0]:%d\\n\", i, dpar[i][0]);\n    }\n    */\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 4005;\nconst int M = 400005;\n\nint n, m, q;\nint lab[N];\nvector < pair<int, int> > g[N];\nint par[N][13], wei[N][13], dep[N];\nlong long tot;\n\nstruct edge {\n\tint u; int v; int w;\n\tbool operator < (const edge &other) const {\n\t\treturn w < other.w;\n\t}\n} ed[M];\n\nint anc(int p) { return p == lab[p] ? p : lab[p] = anc(lab[p]); }\nvoid join(int p, int q) { lab[p] = q; } // p = anc(p), q = anc(q)\n\nvoid dfs(int u) {\n\tfor (auto &e : g[u]) {\n\t\tint v = e.second, w = e.first;\n\t\tif (v == par[u][0]) continue;\n\n\t\tdep[v] = dep[u] + 1;\n\t\tpar[v][0] = u;\n\t\twei[v][0] = w;\n\t\tdfs(v);\n\t}\n}\n\nint lca(int u, int v) {\n\tif (dep[u] < dep[v]) swap(u, v);\n\tfor (int i = 12; i >= 0; --i) if (dep[par[u][i]] >= dep[v]) u = par[u][i];\n\tfor (int i = 12; i >= 0; --i) if (par[u][i] != par[v][i]) u = par[u][i], v = par[v][i];\n\treturn u == v ? u : par[u][0];\n}\n\nint get_max(int u, int x) {\n\tint ret = 0;\n\tfor (int i = 12; i >= 0; --i) {\n\t\tif (dep[par[u][i]] >= dep[x]) {\n\t\t\tret = max(ret, wei[u][i]);\n\t\t\tu = par[u][i];\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> ed[i].u >> ed[i].v >> ed[i].w;\n\t}\n\tsort(ed, ed + m);\n\n\tfor (int i = 1; i <= n; ++i) lab[i] = i;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u = anc(ed[i].u);\n\t\tint v = anc(ed[i].v);\n\t\tif (u == v) continue;\n\n\t\tjoin(u, v);\n\t\tg[ed[i].u].push_back(make_pair(ed[i].w, ed[i].v));\n\t\tg[ed[i].v].push_back(make_pair(ed[i].w, ed[i].u));\n\t\ttot += ed[i].w;\n\t}\n\n\tpar[1][0] = 1;\n\tdfs(1);\n\tfor (int j = 1; j <= 12; ++j) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tpar[i][j] = par[par[i][j - 1]][j - 1];\n\t\t\twei[i][j] = max(wei[i][j - 1], wei[par[i][j - 1]][j - 1]);\n\t\t}\n\t}\n\n\tcin >> q;\n\twhile(q--) {\n\t\tint u, v; cin >> u >> v;\n\t\tint x = lca(u, v);\n\n\t\tint mx = max(get_max(u, x), get_max(v, x));\n\n\t\tprintf(\"%lld\\n\", tot - mx);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename Cost = int> class Edge{\npublic:\n  int from,to;\n  Cost cost;\n  Edge() {}\n  Edge(int to, Cost cost): to(to), cost(cost){}\n  Edge(int from, int to, Cost cost): from(from), to(to), cost(cost){}\n\n  Edge rev() const {return Edge(to,from,cost);}\n  \n  friend ostream& operator<<(ostream &os, const Edge &e){\n    os << \"(FROM: \" << e.from << \",\" << \"TO: \" << e.to << \",\" << \"COST: \" << e.cost << \")\";\n    return os;\n  }\n};\n\ntemplate <typename T> using Graph = vector<vector<Edge<T>>>;\ntemplate <typename T> using Tree = vector<vector<Edge<T>>>;\n\ntemplate <typename C, typename T> void add_edge(C &g, int from, int to, T w){\n  g[from].push_back(Edge<T>(from, to, w));  \n}\n\ntemplate <typename C, typename T> void add_undirected(C &g, int a, int b, T w){\n  g[a].push_back(Edge<T>(a, b, w));\n  g[b].push_back(Edge<T>(b, a, w));\n}\n\nclass UnionFind{\n  vector<int> parent, depth, size;\n  int count;\npublic:\n  UnionFind(int n): parent(n), depth(n,1), size(n,1), count(n){\n    iota(ALL(parent),0);\n  }\n  int get_root(int i){\n    if(parent[i] == i) return i;\n    else return parent[i] = get_root(parent[i]);\n  }\n  bool is_same(int i, int j){return get_root(i) == get_root(j);}\n  int merge(int i, int j){\n    int ri = get_root(i), rj = get_root(j);\n    if(ri == rj) return ri;\n    else{\n      --count;\n      if(depth[ri] < depth[rj]){\n        parent[ri] = rj;\n        size[rj] += size[ri];\n        return rj;\n      }else{\n        parent[rj] = ri;\n        size[ri] += size[rj];\n        if(depth[ri] == depth[rj]) ++depth[ri];\n        return ri;\n      }\n    }\n  }\n  int get_size(int i){return size[get_root(i)];}\n  int count_group(){return count;}\n};\n\n\ntemplate <typename T>\nvector<tuple<int,int,T>> kruskal(int n, vector<tuple<int,int,T>> &graph){\n  sort(graph.begin(), graph.end(), [](tuple<int,int,T> &a, tuple<int,int,T> &b){return get<2>(a) < get<2>(b);});\n  UnionFind uf(n);\n  vector<tuple<int,int,T>> mst;\n  for(auto v : graph){\n    int s,t,d;\n    tie(s,t,d) = v;\n    if(!uf.is_same(s,t)){\n      uf.merge(s,t);\n      mst.push_back(v);\n    }\n  }\n  return mst;\n}\n\n\nLLI dp[5000];\nbool visited[5000];\n\nvoid dfs(const Tree<LLI> &tree, int cur){\n  if(visited[cur]) return;\n  visited[cur] = true;\n\n  for(auto &e : tree[cur]){\n    if(not visited[e.to]) chmax(dp[e.to], max(dp[cur], e.cost));\n    dfs(tree, e.to);\n  }\n}\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n,m;\n  while(cin >> n >> m){\n    vector<tuple<int,int,LLI>> edges;\n    REP(i,m){\n      int a,b; cin >> a >> b; --a, --b;\n      LLI c; cin >> c;\n      edges.push_back(make_tuple(a,b,c));\n    }\n\n    fill_array(dp, 0);\n    fill_array(visited, false);\n    \n\n    auto es = kruskal(n,edges);\n    LLI sum = 0;\n    for(auto &e : es) sum += get<2>(e);\n    \n    Tree<LLI> tree(n);\n    for(auto &e : es){\n      add_undirected(tree, get<0>(e), get<1>(e), get<2>(e));\n    }\n\n\n    int Q; cin >> Q;\n\n    assert(Q == 1);\n\n    REP(i,Q){\n      int s,t; cin >> s >> t; --s, --t;\n\n      LLI ans = sum;\n    \n      dfs(tree,s);\n      ans -= dp[t];\n    \n\n      cout << ans << endl;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a});\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  int start = 0;\n  cost += g[0][0][0];\n  uf.unite(0, g[0][0][1]);\n  maxcost[0][g[0][0][1]] = maxcost[g[0][0][1]][0] = g[0][0][0];\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  cand.insert(all(g[g[0][0][1]]));\n  while (uf.sizes[0] < n) {\n    vi edge = *begin(cand);\n    if (uf.same(edge[1], edge[2])) {\n      cand.erase(begin(cand));\n      continue;\n    }\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nll unipar[4010];\nll unilen[4010];\nstruct edge{\n  int len,from,to;\n};\nbool cmp(edge& a,edge& b){\n  return a.len<b.len;\n}\nvoid init(ll n){\n  for(ll i=1;i<=n;i++){\n    unipar[i]=i;\n    unilen[i]=0;\n  }\n}\nll root(ll n){\n  if(unipar[n]==n)return n;\n  return unipar[n]=root(unipar[n]);\n}\nvoid unit(ll a,ll b){\n  a=root(a);\n  b=root(b);\n  if(a==b)return;\n  if(unilen[a]<unilen[b]){\n    unipar[a]=b;\n  }\n  else{\n    unipar[b]=a;\n    if(unipar[b]==unipar[a])unilen[a]++;\n  }\n}\nint main(){\n  ll n,m;cin>>n>>m;\n  vector<edge> v;\n  for(ll i=0;i<m;i++){\n    ll a,b,c;cin>>a>>b>>c;\n    v.push_back((edge){c,a,b});\n  }\n  sort(v.begin(),v.end(),cmp);\n  init(n);\n  ll now=0;\n  ll sum=0;\n  vector<pll> vn[n+1];\n  for(ll i=0;i<m;i++){\n    edge e=v[i];\n    ll a=e.from,b=e.to;\n    if(root(a)!=root(b)){\n      unit(a,b);\n      sum+=e.len;\n      vn[a].push_back(make_pair(b,c));\n      vn[b].push_back(make_pair(a,c));\n      now++;\n    }\n    if(now==n-1)break;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "    #include <string>\n    #include <vector>\n    #include <cstdio>\n    #include <cstdlib>\n    #include <cmath>\n    #include <algorithm>\n    #include <queue>\n    #include <map>\n    #include <set>\n    #include <iostream>\n    #include <sstream>\n    #include <cstring>\n    #include <numeric>\n    using namespace std;\n    typedef long long ll;\n    typedef pair<int,int> pii;\n    #define F0(i,n) for (int i = 0; i < n; i++)\n    #define F1(i,n) for (int i = 1; i <= n; i++)\n    #define CL(a,x) memset(x, a, sizeof(x));\n    #define SZ(x) ((int)x.size())\n    const double eps = 1e-10;\n    const int inf = 1000000009;\n    int i, j, k, m, n, l;\n    int ans;\n    string s;\n    const int N = 500000;\n    int a[N], b[N], c[N], id[N], p[N];\n     \n    int cc(int x, int y) {\n    \treturn c[x] < c[y];\n    }\n     \n    int main() {\n    \t//freopen(\"x.in\", \"r\", stdin);\n     \n    \tcin >> n >> m;\n    \tF0(i, m) cin >> a[i] >> b[i] >> c[i];\n    \tF0(i, m) id[i] = i;\n    \tsort(id, id + m, cc);\n     \n    \tint Q, S, T;\n    \tcin >> Q;\n    \twhile (Q--) {\n    \t\tcin >> S >> T;\n    \t\tF1(i, n) p[i] = i;\n    \t\tp[T] = S;\n    \t\tint disc = n - 2;\n    \t\tll ans = 0;\n    \t\tF0(uu, m) {\n   int i = id[uu];\n    \t\t\tif (!disc) break;\n    \t\t\tint x = a[i];\n    \t\t\tint y = b[i];\n    \t\t\twhile (x != p[x]) x = p[x];\n    \t\t\twhile (y != p[y]) y = p[y];\n    \t\t\tif (x == y) continue;\n    \t\t\tans += c[i];\n    \t\t\tif (rand() & 1) p[x] = y; else p[y] = x;\n    \t\t}\n    \t\tcout << ans << endl;\n    \t}\n    \t\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "    #include <string>\n    #include <vector>\n    #include <cstdio>\n    #include <cstdlib>\n    #include <cmath>\n    #include <algorithm>\n    #include <queue>\n    #include <map>\n    #include <set>\n    #include <iostream>\n    #include <sstream>\n    #include <cstring>\n    #include <numeric>\n    using namespace std;\n    typedef long long ll;\n    typedef pair<int,int> pii;\n    #define F0(i,n) for (int i = 0; i < n; i++)\n    #define F1(i,n) for (int i = 1; i <= n; i++)\n    #define CL(a,x) memset(x, a, sizeof(x));\n    #define SZ(x) ((int)x.size())\n    const double eps = 1e-10;\n    const int inf = 1000000009;\n    int i, j, k, m, n, l;\n    int ans;\n    string s;\n    const int N = 5000;\n    int a[N], b[N], id[N], p[N];\n    int c[N][N], u[N], best[N];\n     \n     \n    int main() {\n    \t//freopen(\"x.in\", \"r\", stdin);\n     \n    \tcin >> n >> m;\n    \tF0(i, m) {\n    \t\tcin >> a[i] >> b[i] >> j;\n    \t\tc[a[i]][b[i]] = c[b[i]][a[i]] = j;\n     \t}\n     \n    \tint Q, S, T;\n    \tcin >> Q;\n    \twhile (Q--) {\n    \t\tcin >> S >> T;\n     \n    \t\tset<pii> SE;\n    \t\tF1(i, n) if (i != S && i != T) {\n  best[i] = min(c[S][i], c[T][i]);\n    \t SE.insert(pii(best[i], i));\n    \t\t\tu[i] = 0;\n    \t\t}\nu[S] = u[T] = 1;\n     \n    \t\tll ans = 0;\n    \t\tF0(i, n - 2) {\n    \t\t\tpii p = *SE.begin(); SE.erase(SE.begin());\n    \t\t\tans += p.first;\n    \t\t\tu[p.second] = 1;\n    \t\t\tF1(i, n) if (!u[i] && c[p.second][i]) {\n    \t\t\t\tif (c[p.second][i] < best[i]) {\nSE.erase(SE.find(pii(best[i], i)));\nbest[i] = c[p.second][i];\nSE.insert(pii(best[i], i));\n}\n    \t\t\t}\n     \n    \t\t}\n    \t\tcout << ans << endl;\n    \t}\n    \t\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a});\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  set<vi> cand;\n  //int start = 0;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    if (uf.same(edge[1], edge[2])) {\n      cand.erase(begin(cand));\n      continue;\n    }\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nmap<pair<int,int>,int> cost;//(i,j)の辺の重さ,無い時は0\n\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n//OK\n\tpair<int,int> edge;\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tedge.first = B;\n\t\tedge.second = OYA;\n\t\tif(edge.second<edge.first){swap(edge.first,edge.second);}\n\t\tret = max(ret,cost[edge]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tedge.first = A;\n\t\tedge.second = OYA;\n\t\tif(edge.second<edge.first){swap(edge.first,edge.second);}\n\t\tret = max(ret,cost[edge]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\n//OK\n\tint OYA;\n\twhile(A!=B){\n\t\tOYA = oya[A];\n\t\tedge.first = A;\n\t\tedge.second = oya[A];\n\t\tif(edge.second<edge.first){swap(edge.first,edge.second);}\n\t\tret = max(ret,cost[edge]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tedge.first = B;\n\t\tedge.second = oya[B];\n\t\tif(edge.second<edge.first){swap(edge.first,edge.second);}\n\t\tret = max(ret,cost[edge]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tpair<int,int> eee;\n\t\teee.first = a;eee.second=b;\n\t\tif(eee.second<eee.first){swap(eee.first,eee.second);}\n\t\tcost[eee] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n//OK\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n//OK\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\n//RE\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0;i < (int)(n);i++)\n#define RREP(i,n) for(int i = (int)n-1;i >= 0;i--)\n#define FOR(i,s,n) for(int i = s;i < (int)n;i++)\n#define RFOR(i,s,n) for(int i = (int)n-1;i >= s;i--)\n#define ALL(a) a.begin(),a.end()\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a = b;return true;}return false;}\nconstexpr long long INF = 1e18;\n\nstruct UF{\n\tvector<int>par,sz;\n\tvoid init(int n){\n\t\tpar.resize(n);\n\t\tsz.resize(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\tsz[i]=1;\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn x==par[x]?x:par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tsz[x]+=sz[y];\n\t\tpar[y]=x;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tint size(int x){\n\t\treturn sz[find(x)];\n\t}\n};\n\n#define P2 pair<int,pair<int,int>>\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n\tvector<int>a(M),b(M),c(M);\n\tpriority_queue<P2,vector<P2>,greater<P2>>que;\n\tREP(i,M){\n\t\tcin>>a[i]>>b[i]>>c[i];\n\t\ta[i]--;b[i]--;\n\t\tque.push({c[i],{a[i],b[i]}});\n\t}\n\tint weight = 0;\n\tUF uf;\n\tuf.init(N);\n\tvector<vector<pair<int,int>>>g(N);\n\twhile(que.size()){\n\t\tint cost = que.top().first;\n\t\tint from = que.top().second.first;\n\t\tint to = que.top().second.second;\n\t\tque.pop();\n\t\tif(uf.same(from,to))continue;\n\t\tuf.unite(from,to);\n\t\tg[from].push_back({to,cost});\n\t\tg[to].push_back({from,cost});\n\t\tweight += cost;\n\t}\n\n\tint root = -1;\n\tvector<vector<int>>dist(N,vector<int>(N,0));\n\tauto dfs = [&](auto &&f,int now,int par,int ma)->void{\n\t\tCHMAX(dist[root][now],ma);\n\t\tfor(auto e:g[now]){\n\t\t\tif(e.first == par)continue;\n\t\t\tf(f,e.first,now,max(ma,e.second));\n\t\t}\n\t};\n\tREP(i,N){\n\t\troot = i;\n\t\tdfs(dfs,i,-1,0);\n\t}\n\tint Q;\n\tcin>>Q;\n\tvector<int>ans;\n\twhile(Q--){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\ts--;t--;\n\t\tans.push_back(dist[s][t]);\n\t}\n\tfor(auto e:ans){\n\t\tcout<<weight - e<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to,cost;\n\t};\n\tvector<edge>G,tG;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tint krk(){\n\t\tint sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\ttG.pb(e);\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tvoid solve(){\n\t\tint out=krk();\n//\t\trep(i,tG.size())cout<<tG[i].from<<\" \"<<tG[i].to<<endl;\n\t\tint ma=0;\n\t\trep(i,tG.size())ma=max(ma,tG[i].cost);\n\t\tmap<pii,int>m;\n\t\trep(i,tG.size())m[pii(tG[i].to,tG[i].from)]=m[pii(tG[i].from,tG[i].to)]=tG[i].cost;\n\t\tint q;\n\t\tcin>>q;\n\t\twhile(q--){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tif(m[pii(a,b)])cout<<out-m[pii(a,b)]<<endl;\n\t\t\telse cout<<out-ma<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tkrk.add_edge(a,b,c);\n\t}\n\tkrk.solve();\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r1, int r2) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r1, 0) );\n  //Q.push( Edge(-1, r2, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\tGraph g(N);\n\tfor(;M--;){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\tg[b-1].emplace_back(b-1,a-1,c);\n\t}\n\tscanf(\"%d\",&Q);\n\tif(Q>1)return 1;\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a-1].emplace_back(a-1,b-1,0);\n\t\tg[b-1].emplace_back(b-1,a-1,0);\n\t\tprintf(\"%d\\n\",minimumSpanningForest(g).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n#include <assert.h>\n#include <unordered_set>\n\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\n\n\n\n\n\n\nclass unionfind {\nprivate:\n    vector<int> par;\n    vector<int> rank;\n    vector<int> counter;\npublic:\n    unionfind(int n) : rank(n), counter(n, 1){\n        for(int i = 0; i < n; i++){\n            par.push_back(i);\n        }\n    }\n    \n    int find(int x){\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            return par[x] = find(par[x]);\n        }\n    }\n    \n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        \n        if (rank[x] < rank[y]) {\n            counter[y] += counter[x];\n            counter[x] = counter[y];\n            par[x] = y;\n        }\n        else {\n            counter[y] += counter[x];\n            counter[x] = counter[y];\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n    \n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n    ll count(int x){\n        return counter[find(x)];\n    }\n};\n\n\ntemplate <typename T>\nclass kruskal {\nprivate:\n    struct edge{\n        T cost;\n        int u, v;\n        \n        bool operator<(const edge& e1) const {\n            return cost < e1.cost;\n        }\n    };\n    vector<edge> es;\n    int n;\npublic:\n    kruskal(int n) : n(n){}\n    \n    void add_edge(int u, int v, T cost){\n        es.push_back({cost, u, v});\n        es.push_back({cost, v, u});\n    }\n    \n    pair<vector<pair<pair<ll, ll>, ll>>, T> run(){\n        sort(es.begin(), es.end());\n    \n        unionfind uni(n);\n        T res = 0;\n        vector<pair<pair<ll, ll>, ll>> edges;\n        \n        for(auto& e : es){\n            if(!uni.same(e.u, e.v)){\n                uni.unite(e.u, e.v);\n                res += e.cost;\n                edges.push_back({{e.u, e.v}, e.cost});\n            }\n        }\n        \n        return {edges, res};\n    }\n};\n\nclass LCA {\n    ll n, log_n;\n    vector<vector<pair<ll, ll>>> parent;\n    vector<ll> depth;\n    vector<bool> used;\n    \nprivate:\n    void dfs(const vector<vector<pair<ll, ll>>> &g, ll now, ll par, ll d, ll cost){\n        parent[0][now].first = par;\n        parent[0][now].second = cost;\n        depth[now] = d;\n        used[now] = true;\n        \n        for(auto &edge : g[now]){\n            ll child = edge.first, c = edge.second;\n            if(child != par){\n                dfs(g, child, now, d + 1, c);\n            }\n        }\n    }\n    \npublic:\n    LCA(const vector<vector<pair<ll, ll>>> &g) : n(g.size()), log_n(0), depth(n), used(n) {\n        for(ll v = n; v > 0; v /= 2){\n            log_n++;\n        }\n        parent.resize(log_n, vector<pair<ll, ll>>(n));\n        for(ll i = 0; i < n; i++){\n            if(!used[i]){\n                dfs(g, i, -1, 0, 0);\n            }\n        }\n        for(ll k = 0; k < log_n - 1; k++){\n            for(ll v = 0; v < n; v++){\n                if(parent[k][v].first < 0){\n                    parent[k + 1][v] = parent[k][v];\n                }\n                else{\n                    parent[k + 1][v].first = parent[k][parent[k][v].first].first;\n                    parent[k + 1][v].second = max(parent[k][v].second, parent[k][parent[k][v].first].second);\n                }\n            }\n        }\n    }\n    \n    ll query(ll u, ll v){\n        if(depth[u] > depth[v]){\n            swap(u, v);\n        }\n        ll res = 0;\n        for(ll k = 0; k < log_n; k++){\n            if(((depth[v] - depth[u]) >> k) & 1){\n                res = max(res, parent[k][v].second);\n                v = parent[k][v].first;\n            }\n        }\n        if(u == v){\n            return res;\n        }\n        for(ll k = log_n - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                res = max(res, parent[k][u].second);\n                res = max(res, parent[k][v].second);\n                u = parent[k][u].first;\n                v = parent[k][v].first;\n            }\n        }\n        return res;\n    }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\ntemplate <class T>\nclass segtree\n{\npublic:\n    lli n;\n    vector<T> dat;\n    function<T(T, T)> func;\n    T dummy;\n    segtree<T>(lli _n, function<T(T, T)> f, T dummy) : func(f), dummy(dummy)\n    {\n        n = 1;\n        while (n < _n) {\n            n = n * 2;\n        }\n        dat.assign(2 * n - 1, dummy);\n    }\n    void update(lli k, T a)\n    {\n        k += n - 1;\n        dat[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = func(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b)\n    {\n        return query(a, b, 0, 0, n);\n    }\n    // [a,b)の何かを求める.\n    T query(int a, int b, int k, int l, int r)\n    {\n        //交差しないときはダミー\n        if (r <= a || b <= l)\n            return dummy;\n        if (a <= l && r <= b)\n            return dat[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return func(vl, vr);\n        }\n    }\n    T get(int a)\n    {\n        return query(a, a + 1, 0, 0, n);\n    }\n};\n\ntemplate <class T>\nstruct hldec {\n    int n;\n    int col = 0;\n    vector<vector<int>> e;\n    vector<vector<int>> heavy;\n    vector<vector<int>> light;\n    vector<vector<T>> cls;\n    vector<T> vers;\n    vector<pair<int, int>> pos;\n    vector<pair<int, int>> par;\n    function<T(T, T)> f;\n    T unit;\n    vector<segtree<T>> vec_seg;\n    int root = 0;\n    vector<int> size;\n    hldec(int n, vector<T> vers, function<T(T, T)> f, T unit, int root = 0) : n(n), root(root), vers(vers), unit(unit), f(f)\n    {\n        e.assign(n, {});\n        par.assign(n, make_pair(-1, -1));\n        heavy.assign(n, {});\n        light.assign(n, {});\n        size.assign(n, 0);\n        pos.assign(n, make_pair(-1, -1));\n        cls.assign(n, {});\n    }\n    void add(int u, int v)\n    {\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    int sub_tree_size(int cur, int par)\n    {\n        int tmp = 1;\n        for (auto s : e[cur]) {\n            if (par != s) {\n                tmp += sub_tree_size(s, cur);\n            }\n        }\n        size[cur] = tmp;\n        return tmp;\n    }\n    void dfs_label(int cur, int par)\n    {\n        lli idx = -1;\n        lli mem = 0;\n        rep(i, e[cur].size())\n        {\n            auto s = e[cur][i];\n            if (s != par) {\n                if (size[s] > mem) {\n                    mem = size[s];\n                    idx = i;\n                }\n            }\n        }\n        if (idx == -1)\n            return;\n        rep(i, e[cur].size())\n        {\n            auto s = e[cur][i];\n            if (s != par) {\n                if (idx == i) {\n                    heavy[cur].push_back(s);\n                } else {\n                    light[cur].push_back(s);\n                }\n                dfs_label(s, cur);\n            }\n        }\n    }\n    void edge_labeling()\n    {\n        sub_tree_size(root, -1);\n        dfs_label(root, -1);\n    }\n    void dfs_arrays(int cur, int c)\n    {\n        cls[c].push_back(vers[cur]);\n        int idx = cls[c].size() - 1;\n        pos[cur] = make_pair(c, cls[c].size() - 1);\n        for (auto s : light[cur]) {\n            col++;\n            par[col] = make_pair(c, idx);\n            dfs_arrays(s, col);\n        }\n        for (auto s : heavy[cur]) {\n            dfs_arrays(s, c);\n        }\n    }\n    void make_arrays()\n    {\n        dfs_arrays(root, 0);\n    }\n    void build_segtree()\n    {\n        rep(j, cls.size())\n        {\n            auto& s = cls[j];\n            int size = s.size();\n            segtree<T> seg(size, f, unit);\n            rep(i, size)\n            {\n                seg.update(i, s[i]);\n            }\n            vec_seg.push_back(seg);\n        }\n    }\n    void build(bool opt = false)\n    {\n        edge_labeling();\n        if (opt) {\n            e.clear();\n        }\n        make_arrays();\n        if (opt) {\n            heavy.clear();\n            light.clear();\n        }\n\n        build_segtree();\n    }\n    T query(int u, int v)\n    {\n        vector<pair<int, int>> hist_u;\n        vector<pair<int, int>> hist_v;\n        rep(j, 2)\n        {\n            int tmp = j == 1 ? u : v;\n            while (true) {\n                int cur_col = pos[tmp].first;\n                if (j)\n                    hist_u.push_back(pos[tmp]);\n                else\n                    hist_v.push_back(pos[tmp]);\n                tmp = par[cur_col].second;\n                if (tmp == -1)\n                    break;\n            }\n        }\n        int cnt = 0;\n        T ans = unit;\n        while (true) {\n            int idx_u = hist_u.size() - cnt - 1;\n            int idx_v = hist_v.size() - cnt - 1;\n            if (hist_u[idx_u].first == hist_v[idx_v].first) {\n                int r = max(hist_u[idx_u].second, hist_v[idx_v].second) + 1;\n                int l = min(hist_u[idx_u].second, hist_v[idx_v].second);\n                ans = f(vec_seg[hist_u[idx_u].first].query(l, r), ans);\n                break;\n            }\n            cnt++;\n        }\n        rep(i, hist_u.size() - cnt - 1)\n        {\n            ans = f(vec_seg[hist_u[i].first].query(0, hist_u[i].second + 1), ans);\n        }\n        rep(i, hist_v.size() - cnt - 1)\n        {\n            ans = f(vec_seg[hist_v[i].first].query(0, hist_v[i].second + 1), ans);\n        }\n        return ans;\n    }\n};\nvector<pair<lli, lli>> e[4005];\nvector<pair<lli, lli>> ne[4005];\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    int a, b;\n    lli c;\n    rep(i, m)\n    {\n        cin >> a >> b >> c;\n        a--, b--;\n        e[a].push_back(make_pair(b, c));\n        e[b].push_back(make_pair(a, c));\n    }\n    using p = pair<lli, pair<lli, lli>>;\n    priority_queue<p, vector<p>, greater<p>> que;\n    bool used[4005] = {};\n    que.push(make_pair(0, make_pair(0, -1)));\n    lli ans = 0;\n    int hoge = n;\n    vector<pair<int, int>> edge;\n    vector<lli> v(2 * n, 0);\n    while (!que.empty()) {\n        auto cur = que.top().second;\n        auto cost = que.top().first;\n        que.pop();\n        if (used[cur.first])\n            continue;\n        used[cur.first] = true;\n        ans += cost;\n        if (cur.second != -1) {\n            edge.push_back(make_pair(cur.first, hoge));\n            edge.push_back(make_pair(cur.second, hoge));\n            v[hoge] = cost;\n            hoge++;\n        }\n        for (auto s : e[cur.first]) {\n            que.push(make_pair(s.second, make_pair(s.first, cur.first)));\n        }\n    }\n\n\n    auto f = [](lli u, lli v) -> lli { return max(u, v); };\n    hldec<lli> tr(2 * n, v, f, 0);\n    for(auto s:edge){\n        tr.add(s.first,s.second);\n    }\n    // tr.add(0, 1);\n    // tr.add(0, 2);\n    // tr.add(1, 3);\n    // tr.add(1, 4);\n    tr.build(true);\n    int s, t, q;\n    cin >> q;\n    rep(i, q)\n    {\n        cin >> s >> t;\n        cout << ans -tr.query(s - 1, t - 1) << endl;\n    }\n    // //cout << tr.query(0,1)<<endl;\n    // cout << tr.query(3, 4) << endl;\n};\n;\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint union_tree[10000];\nint union_find(int now) {\n\tif (union_tree[now] == now) return now;\n\treturn union_tree[now] = union_find(union_tree[now]);\n}\nint union_merge(int a, int b) {\n\ta = union_find(a);\n\tb = union_find(b);\n\tunion_tree[a] = b;\n\treturn 0;\n}\nlong long winning[4001][4001];\nvector<pair<long long, long long>> vertexs[4000];\nvoid dfs(int now, int back,int itr) {\n\tfor (int q = 0; q < vertexs[now].size(); ++q) {\n\t\tif (vertexs[now][q].first == back) continue;\n\t\tint go = vertexs[now][q].first;\n\t\twinning[itr][go] = max(winning[itr][now], vertexs[now][q].second);\n\t\tdfs(go, now, itr);\n\t}\n}\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<tuple<long long, long long, long long>> edges;\n\tREP(i, m) {\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tb--;\n\t\tedges.push_back(make_tuple(c, a, b));\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor (int i = 0; i < n; ++i) {\n\t\tunion_tree[i] = i;\n\t}\n\tlong long ans = 0;\n\tREP(i, m) {\n\t\tif (union_find(get<1>(edges[i])) != union_find(get<2>(edges[i]))) {\n\t\t\tans += get<0>(edges[i]);\n\t\t\tunion_merge(get<1>(edges[i]), get<2>(edges[i]));\n\t\t\tvertexs[get<1>(edges[i])].push_back(make_pair(get<2>(edges[i]), get<0>(edges[i])));\n\t\t\tvertexs[get<2>(edges[i])].push_back(make_pair(get<1>(edges[i]), get<0>(edges[i])));\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tdfs(i, -1, i);\n\t}\n\tint query;\n\tcin >> query;\n\tREP(i, query) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tcout << ans - winning[a][b] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n/*\n * Union-Find tree\n * header requirement: vector\n */\nclass UnionFind {\nprivate:\n  std::vector<int> disj;\n  std::vector<int> rank;\npublic:\n  UnionFind(int n) : disj(n), rank(n) {\n    for (int i = 0; i < n; ++i) {\n      disj[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int root(int x) {\n    if (disj[x] == x) {\n      return x;\n    }\n    return disj[x] = root(disj[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (rank[x] < rank[y]) {\n      disj[x] = y;\n    } else {\n      disj[y] = x;\n      if (rank[x] == rank[y]) {\n\t++rank[x];\n      }\n    }\n  }\n  bool is_same_set(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\ntypedef std::pair<ll, int> PLI;\n\n/**\n * Lowest Common Ancestor. Call lca(x, y) to get the lca of them.\n * Header Requirement: vector, cassert\n * Verified by: AtCoder ABC014-D (http://abc014.contest.atcoder.jp/submissions/759125)\n */\nclass LowestCommonAncestor {\nprivate:\n  int n, bn;\n  std::vector<PLI> parent; // 0 is root, parent[0] = 0\n  std::vector<int> dep;\n  \n  // Lowest Common Ancestor\n  \n  std::vector<std::vector<PLI> > lca_tbl;\n  \n  void dfs(const std::vector<std::vector<PLI> > &edges, int v, int par, int d, ll x) {\n    parent[v].second = par;\n    parent[v].first = x;\n    dep[v] = d;\n    \n    for (int i = 0; i < edges[v].size(); ++i) {\n      int u = edges[v][i].second;\n      if (u != par) {\n\tdfs(edges, u, v, d + 1, edges[v][i].first);\n      }\n    }\n  }\n  \n  void lca_init(void) {\n    for (int v = 0; v < n; ++v) {\n      lca_tbl[v] = std::vector<PLI>(bn + 1, PLI(0, 0));\n      lca_tbl[v][0] = parent[v];\n    }\n    for (int i = 1; i <= bn; ++i) {\n      for (int v = 0; v < n; ++v) {\n\tPLI tmp = lca_tbl[v][i - 1];\n        PLI tmp2 = lca_tbl[tmp.second][i - 1];\n\tlca_tbl[v][i] = PLI(max(tmp.first, tmp2.first), tmp2.second);\n      }\n    }\n  }\npublic:\n  ll lca(int x, int y) const {\n    int dx = dep[x];\n    int dy = dep[y];\n    ll res = 0;\n    if (dx > dy) {\n      return lca(y, x);\n    }\n    // Go up from y to the depth of x\n    for (int l = bn; l >= 0; --l) {\n      if (dy - dx >= 1 << l) {\n        PLI ny = lca_tbl[y][l];\n\tres = max(res, ny.first);\n\ty = ny.second;\n\tdy -= 1 << l;\n      }\n    }\n\n    assert (dx == dy);\n\n    if (x == y) {\n      return res;\n    }\n  \n    for (int l = bn; l >= 0; --l) {\n      if (lca_tbl[x][l].second != lca_tbl[y][l].second) {\n\tPLI nx = lca_tbl[x][l];\n\tPLI ny = lca_tbl[y][l];\n\tres = max(res, max(nx.first, ny.first));\n\tx = nx.second;\n\ty = ny.second;\n      }\n    }\n    return res;\n  }\n  int depth(int a) const {\n    return dep[a];\n  }\n  LowestCommonAncestor(int n, const std::vector<std::vector<PLI> > &edges)\n    : n(n), parent(n), dep(n), lca_tbl(n) {\n    bn = 0;\n    while (n > 1 << bn) {\n      bn++;\n    }\n    dfs(edges, 0, 0, 0, 0);\n    lca_init();\n  }\n};\n\n\n\nconst int M = 400010;\nint n, m;\nint a[M], b[M];\nll c[M];\n\nconst int N = 4010;\nvector<PLI> edges[N];\n\nll dfs(int v, int p, int t) {\n  if (v == t) {\n    return 0;\n  }\n  REP(i, 0, edges[v].size()) {\n    PLI e = edges[v][i];\n    int w = e.second;\n    if (p == w) continue;\n    ll res = dfs(w, v, t);\n    if (res == -1) continue;\n    return max(res, e.first);\n  }\n  return -1;\n}\n\nll solve(int s, int t) {\n  return dfs(s, -1, t);\n  \n}\n\nint main(void){\n  cin >> n >> m;\n  REP(i, 0, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n  }\n  int q;\n  cin >> q;\n  vector<PLI> pool;\n  ll tot = 0;\n  REP(i, 0, m) {\n    pool.push_back(PLI(c[i], i));\n  }\n  sort(pool.begin(), pool.end());\n  UnionFind uf(n);\n  vector<vector<PLI> > edges_i(n);\n  REP(i, 0, pool.size()) {\n    int idx = pool[i].second;\n    int u = a[idx];\n    int v = b[idx];\n    if (not uf.is_same_set(u, v)) {\n      uf.unite(u, v);\n      tot += pool[i].first;\n      edges[u].push_back(PLI(pool[i].first, v));\n      edges[v].push_back(PLI(pool[i].first, u));\n      edges_i[u].push_back(PLI(pool[i].first, v));\n      edges_i[v].push_back(PLI(pool[i].first, u));\n    }\n  }\n  LowestCommonAncestor lca(n, edges_i);\n  REP(i, 0, q) {\n    int s,t;\n    cin >> s >> t;\n    s--, t--;\n    // max edge in s-t path\n    ll tk = lca.lca(s, t);\n    cout << tot - tk << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\ntemplate<class T=int>\nclass SparseTable{\n public:\n  SparseTable(int len, T default_value_ = 100000000, function<T(T,T)> eval = default_evaluate)\n   : col(len), default_value(default_value_) \n  {\n    evaluate = eval;\n    row = 1;\n    while((1<<row) < col) row += 1;\n    row++;\n    table = vector<vector<T>>(row, vector<T>(col, default_value));\n  }\n\n  SparseTable(vector<T>& vec, T default_value_ = 0, function<T(T,T)> eval = default_evaluate)\n   : col(vec.size()), default_value(default_value_)\n  {\n    evaluate = eval;\n\n    row = 1;\n    while((1<<row) < col) row += 1;\n    row++;\n    table = vector<vector<T>>(row, vector<T>(col, default_value));\n\n    set(vec);\n  }\n\n  void set(vector<T>& vec){\n    //assert(col == vec.size());\n\n    values = &vec;\n    vector<T>& val = vec;\n\n    iota(table[0].begin(), table[0].end(), 0);\n    for(int k=1; k<row; k++){\n      for(int i=0; i + (1<<k)-1 < col; i++){\n        T left = val[table[k-1][i]];\n        T right = val[table[k-1][i+(1<<(k-1))]];\n        if(left == evaluate(left,right)){\n          table[k][i] = table[k-1][i];\n        }else{\n          table[k][i] = table[k-1][i+(1<<(k-1))];\n        }\n      }\n    }\n  }\n\n  //[l,r)\n  T get(int l, int r){\n    if(l>=r) return default_value;\n    vector<T>& val = *values;\n\n    T ret = default_value;\n\n    int k = 0;\n    while((1<<(k+1)) < (r-l)) k++;\n\n    T left = val[ table[k][l] ];\n    T right = val[ table[k][r-(1<<k)] ];\n\n    ret = evaluate(left, right);\n    return ret;\n  }\n\n private:\n  int col;\n  int row;\n  T default_value;\n  vector<T>* values;\n  vector<vector<T>> table;\n\n  static T default_evaluate(T a, T b){\n    return max(a,b);\n  }\n  function<T(T,T)> evaluate;\n};\n\n\nclass HeavyLightDecomposition{\n public:\n  struct heavy_set{\n    vector<int> element;\n    int depth;\n    int parent_vertex;\n    heavy_set(int v, int d, int par) : element(1,v), depth(d), parent_vertex(par){}\n  };\n\n  vector<vector<int>>& G;\n  vector<heavy_set> S;\n  vector<int> subtree_size;\n  vector<int> set_index;\n  vector<int> ele_index;\n\n private:\n  int get_subtree_size(int pos, int par){\n    int sz = 1;\n    for(int ch : G[pos]){\n      if(ch == par) continue;\n      sz += get_subtree_size(ch, pos);\n    }\n    return subtree_size[pos] = sz;\n  }\n\n  void make_path(int pos, int par, int set_id){\n    set_index[pos] = set_id;\n    ele_index[pos] = S[set_id].element.size()-1;\n\n    int largest_child = -1;\n    int value = 0;\n\n    for(int ch : G[pos]){\n      if(ch == par) continue;\n      if(value < subtree_size[ch]){\n        value = subtree_size[ch];\n        largest_child = ch;\n      }\n    }\n\n    for(int ch : G[pos]){\n      if(ch == par) continue;\n      if(largest_child == ch){\n        S[set_id].element.push_back(ch);\n        make_path(ch, pos, set_id);\n      }else{\n        S.emplace_back( ch, S[set_id].depth+1, pos );\n        make_path(ch, pos, S.size()-1);\n      }\n    }\n  }\n\n  void init(int root){\n    subtree_size.resize(G.size(), 0);\n    get_subtree_size(root,root);\n\n    set_index.resize(G.size(), 0);\n    ele_index.resize(G.size(), 0);\n\n    S.emplace_back( root,0,root );\n\n    make_path( root, root, 0 );\n\n    subtree_size.clear();\n  }\n\n public:\n  HeavyLightDecomposition(vector<vector<int>>& G_, int root = 0) : G(G_){\n    init(root);\n  }\n\n  //set_index, element_index\n  //S[set_index].element[element_index] == v\n  pair<int,int> get_position(int v){\n    return {set_index[v], ele_index[v]};\n  }\n};\n\n//Lowest Common Ancestor with HL-decomposition tree\n//O(log n) / query\nlong long LCA(HeavyLightDecomposition& T, vector<SparseTable<long long>*>& st, vector<vector<long long>>& edge, int u, int v){\n  long long ret = 0;\n  auto pu = T.get_position(u);\n  auto pv = T.get_position(v);\n  if(pu.first == pv.first){\n    return st[pu.first]->get(min(pu.second, pv.second), max(pu.second, pv.second));\n  }\n\n  if(T.S[pu.first].depth > T.S[pv.first].depth){\n    swap(pu, pv);\n    swap(u,v);\n  }\n\n  while(T.S[pu.first].depth != T.S[pv.first].depth){\n    ret = max(ret, st[pv.first]->get(0, pv.second));\n    ret = max(ret, edge[v][T.S[pv.first].parent_vertex]);\n    v = T.S[pv.first].parent_vertex;\n    pv = T.get_position( v );\n  }\n\n  while(pu.first != pv.first){\n    ret = max(ret, st[pv.first]->get(0, pv.second));\n    ret = max(ret, edge[v][T.S[pv.first].parent_vertex]);\n    ret = max(ret, st[pu.first]->get(0, pu.second));\n    ret = max(ret, edge[u][T.S[pu.first].parent_vertex]);\n\n    u = T.S[pu.first].parent_vertex;\n    v = T.S[pv.first].parent_vertex;\n    pu = T.get_position(u);\n    pv = T.get_position(v);\n    if(T.S[pv.first].depth == 0) break;\n    if(T.S[pv.first].depth == 0) break;\n  }\n\n  if(pu.first == pv.first){\n    return st[pu.first]->get(min(pu.second, pv.second), max(pu.second, pv.second));\n  }else{\n    abort();\n  }\n  return -1;\n}\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    cin >> a[i],b[i],c[i];\n    a[i]--; b[i]--;\n  }\n\n  UnionFindTree uft(n);\n  vector<tuple<int,int,int>> e(m);\n  vector<vector<long long>> edge(n, vector<long long>(n, 1ll<<50));\n  for(auto i : range(m) ){\n    e[i] = tuple<int,int,int>{c[i],a[i],b[i]};\n    edge[a[i]][b[i]] = edge[b[i]][a[i]] = c[i];\n  }\n  sort(e.begin(), e.end());\n\n  long long cost = 0;\n  vector<vector<int>> G(n);\n  for(int i=0; i<m; i++){\n    if( uft.same(get<1>(e[i]), get<2>(e[i])) ) continue;\n    cost += get<0>(e[i]);\n    uft.unite(get<1>(e[i]), get<2>(e[i]));\n    G[get<1>(e[i])].push_back(get<2>(e[i]));\n    G[get<2>(e[i])].push_back(get<1>(e[i]));\n  }\n\n  eprintln(\"cost of MST: \" , cost );\n\n  HeavyLightDecomposition hl(G);\n  vector<vector<long long>> tmp(hl.S.size());\n  vector<SparseTable<long long>*> st(hl.S.size());\n  for(int i : range(hl.S.size())){\n    auto& e = hl.S[i].element;\n    tmp[i] = vector<long long>(e.size());\n    for(int j : range(e.size()-1)){\n      tmp[i][j] = edge[e[j]][e[j+1]];\n    }\n    st[i] = new SparseTable<long long>(tmp[i]);\n  }\n\n  int q;\n  cin >> q;\n  for(auto i : range(q) ){\n    int s,t;\n    cin >> s,t;\n    s--; t--;\n\n    long long p = LCA(hl,st, edge, s,t);\n    println(cost - p);\n\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> par;\n    vector<int> dep;\n    \n    UnionFind(int siz){\n        par.assign(siz,0);\n        dep.assign(siz,0);\n        for(int i=0;i<siz;i++){\n            par[i]=i;\n        }\n    };\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y){\n            return;\n        }\n        if(dep[x]<dep[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(dep[x]==dep[y]){\n                dep[x]++;\n            }\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\nstruct edge{int from,to;ll cost;};\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost<e2.cost;\n}\nstruct edge2{int to;ll cost;};\nvector<edge2> G[4010];\nedge es[4010];\nll s[4010][4010];\nvoid dfs(int now,int p,int st,ll ma){\n\tfor(auto e:G[now]){\n\t\tif(e.to==p)continue;\n\t\ts[st][e.to]=max(ma,e.cost);\n\t\tdfs(e.to,now,st,max(ma,e.cost));\n\t}\n}\n\t\nint main(){\n\tint n,m,q;cin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;a--;b--;\n\t\tes[i]={a,b,c};\n\t}\n\tsort(es,es+m,comp);\n\tUnionFind uf(n);\n\tll ans=0;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=es[i];\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tG[e.from].push_back({e.to,e.cost});\n\t\t\tG[e.to].push_back({e.from,e.cost});\n\t\t\tans+=e.cost;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs(i,-1,i,0);\n\t}\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tcout<<ans-s[a][b]<<endl;\n\t}\n\t\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM];\nedge et[MAXN+1];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      es[i] = edge{a, b, c};\n    }\n    {\n      sort(es, es+M, comp);\n      UnionFind uf(N);\n      uf.initialize();\n      ll cnt = 1;\n      rep(i, M){\n        edge& e = es[i];\n        if(!uf.isSame(e.u, e.v)){\n          uf.merge(e.u, e.v);\n          et[cnt] = edge{e.u, e.v, e.cost};\n          cnt++;\n        }\n      }\n\n    }\n    ll Q;\n    cin >> Q;\n    if(Q > 3000) return 0;\n    rep(q, Q){\n      ll s, t;\n      cin >> s >> t;\n      s--; t--;\n      et[0] = edge{s, t, 0};\n      ll ans = 0;\n      UnionFind uf(N);\n      uf.initialize();\n      rep(i, N+1){\n        edge& e = et[i];\n        if(!uf.isSame(e.u, e.v)){\n          uf.merge(e.u, e.v);\n          ans += e.cost;\n        }\n      }\n      cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst ll inf=1e17;\nstruct UnionFind{\n    vector<ll> data;\n    UnionFind(ll size) : data(size, -1) {}\n    bool unionSet(ll x,ll y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(ll x,ll y){\n        return root(x)==root(y);\n    }\n    ll root(ll x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    ll size(ll x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tll from,to,cost;\n\t};\n\tvector<edge>G;\n\tvvp tG;\n\tvvi dp;\n\tvi used;\n\tll n;\n\tKRK(ll size){\n\t\tn=size;\n\t}\n\tvoid add_edge(ll a,ll b,ll c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tll krk(){\n\t\tll sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\ttG[e.from].pb(pii(e.to,e.cost));\n\t\t\t\ttG[e.to].pb(pii(e.from,e.cost));\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tvoid dfs(ll a,ll b,ll c){\n\t\trep(i,tG[a].size())if(used[tG[a][i].first]==0){\n\t\t\tused[tG[a][i].first]=true;\n\t\t\tll t=max<ll>(b,tG[a][i].second);\n\t\t\tdp[c][tG[a][i].first]=t;\n\t\t\tdfs(tG[a][i].first,t,c);\n\t\t}\n\t}\n\tvoid solve(){\n\t\ttG=vvp(n);\n\t\tll out=krk();\n\t\tdp=vvi(n,vi(n));\n\t\trep(i,n){\n\t\t\tused=vi(n);\n\t\t\tused[i]=1;\n\t\t\tdfs(i,0,i);\n\t\t}\n//\t\trep(i,n){rep(j,n)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\t\n\t\tll q;\n\t\tcin>>q;\n\t\twhile(q--){\n\t\t\tll a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tcout<<out-dp[a][b]<<endl;\n\t\t}\n\t}\n};\nint main(){\n\tll n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\twhile(m--){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tkrk.add_edge(a,b,c);\n\t}\n\tkrk.solve();\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nclass union_find {\nprivate:\n  unordered_map<lli,lli> par;\n  unordered_map<lli,lli> rnk;\npublic:\n  // union_find (lli n){\n  //   par = new vll(n);\n  //   iota(par->begin(),par->end(),0);\n  //   rnk = new vll(n,0);\n  // }\n  lli parent(lli x){\n    if(par[x]) return par[x];\n    else return par[x] = x;\n  }\n  lli find(lli x){\n    if(parent(x) == x) return x;\n    else return par[x] = find(parent(x));\n  }\n  void unite(lli x,lli y){\n    x = find(x);y = find(y);\n    if(x == y)return;\n    if(rnk[x] < rnk[y]) par[x] = y;\n    else {\n      par[y] = x;\n      if(rnk[x] == rnk[y]) rnk[x]++;\n    }\n  }\n  bool same(lli x,lli y){\n    return find(x) == find(y);\n  }\n};\n\nlli n,m;\ngraph g;\ngraph t;\nlli q;\nunion_find uf;\nmat edge;\nmat ans;\nlli mst = 0;\n\nvoid dfs(lli x, lli c, lli p, lli from){\n  ans[from][x] = c;\n  for(auto y : t[x]){\n    if(y.first == p) continue;\n    dfs(y.first, max(y.second, c), x, from);\n  }\n}\n\n\nint main(){\n  cin >> n >> m;\n  edge = mat(m, vll(3));\n  for(lli i=0;i < m;i++){\n    cin >> edge[i][1] >> edge[i][2] >> edge[i][0];\n  }\n  sort(edge.begin(), edge.end());\n  for(lli i = 0;i < m;i++){\n    if(uf.same(edge[i][1], edge[i][2])) continue;\n    uf.unite(edge[i][1], edge[i][2]);\n    t[edge[i][1]][edge[i][2]] = t[edge[i][2]][edge[i][1]] = edge[i][0];\n    mst += edge[i][0];\n  }\n  ans = mat(n+1,vll(n+1));\n  for(lli i = 1;i <= n;i++){\n    dfs(i, 0, 0, i);\n  }\n  cin >> q;\n  for(lli i = 0;i <  q;i++){\n    lli s,t;\n    cin >> s >> t;\n    cout << mst-ans[s][t] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\nint n, m, q, a[400000], b[400000], c[400000], dist[5000];\nvector<pair<int, int>>vec; vector<pair<int, int>>x[5000];\nint query(int r1, int r2) {\n\tfill(dist + 1, dist + n + 1, 1299999999);\n\tqueue<int>Q; Q.push(r1); dist[r1] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tif (a1 == r2)return dist[a1];\n\t\tfor (int i = 0; i < x[a1].size(); i++) {\n\t\t\tif (dist[x[a1][i].first] == 1299999999) {\n\t\t\t\tdist[x[a1][i].first] = max(dist[a1], x[a1][i].second);\n\t\t\t\tQ.push(x[a1][i].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[r2];\n}\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; vec.push_back(make_pair(c[i], i));\n\t}\n\tsort(vec.begin(), vec.end());\n\tUnionFind UF(n + 1); long long sum = 0;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tint to = vec[i].second;\n\t\tif (UF.same(a[to], b[to]) == false) {\n\t\t\tUF.unite(a[to], b[to]); sum += c[to];\n\t\t\tx[a[to]].push_back(make_pair(b[to], c[to]));\n\t\t\tx[b[to]].push_back(make_pair(a[to], c[to]));\n\t\t}\n\t}\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tint p1, p2; cin >> p1 >> p2;\n\t\tcout << sum - query(p1, p2) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, q;\nlong long cost;\nint l[100010], h[100010];\n\nstruct edge\n{\n    int u, v;\n    long long w;\n    bool operator < (const edge& other) const\n    {\n        return w < other.w;\n    }\n} e[400010];\n\nint Find(int x)\n{\n    return x == l[x] ? x : l[x] = Find(l[x]);\n}\n\nint Union(int u, int v)\n{\n    if ((u = Find(u)) == (v = Find(v))) return 0;\n    if (h[u] < h[v]) swap(u, v);\n    l[v] = u;\n    h[u] += h[v];\n    return 1;\n}\n\nint in[100010], out[100010], par[100010][15], times;\nlong long rmq[100010][15], c[100010];\nvector <pair <int, long long> > adj[100010];\n\nvoid dfs(int u, int p)\n{\n    in[u] = ++times;\n    par[u][0] = p;\n    for (int i = 1; i < 15; ++i)\n        par[u][i] = par[par[u][i - 1]][i - 1];\n    rmq[u][0] = c[u];\n    for (int i = 1; i < 15; ++i)\n        rmq[u][i] = max(rmq[u][i - 1], rmq[par[u][i - 1]][i - 1]);\n    for (int i = 0; i < adj[u].size(); ++i)\n    {\n        int v = adj[u][i].first;\n        long long w = adj[u][i].second;\n        if (v == p) continue;\n        c[v] = w;\n        dfs(v, u);\n    }\n    out[u] = times;\n}\n\nint check(int u, int v)\n{\n    return (in[u] <= in[v] && out[v] <= out[u]);\n}\n\nint LCA(int u, int v)\n{\n    if (check(u, v)) return u;\n    for (int i = 14; i + 1; --i)\n        if (par[u][i] && !check(par[u][i], v)) u = par[u][i];\n    return par[u][0];\n}\n\nlong long calc(int u, int w)\n{\n    long long res = 0;\n    for (int i = 14; i + 1; --i)\n        if (par[u][i] && check(w, par[u][i]))\n        {\n            res = max(res, rmq[u][i]);\n            u = par[u][i];\n        }\n    return res;\n}\n\nvoid Kruskal()\n{\n    for (int i = 1; i <= n; ++i) l[i] = i, h[i] = 1;\n    sort(e + 1, e + m + 1);\n    for (int i = 1; i <= m; ++i)\n        if (Union(e[i].u, e[i].v))\n        {\n            adj[e[i].u].push_back({e[i].v, e[i].w});\n            adj[e[i].v].push_back({e[i].u, e[i].w});\n            cost += e[i].w;\n        }\n}\n\nint main()\n{\n//    freopen(\"ELECTRIC.inp\", \"r\", stdin);\n//    freopen(\"ELECTRIC.out\", \"w\", stdout);\n\n    ios_base :: sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n >> m;\n\n    for (int i = 1; i <= m; ++i)\n        cin >> e[i].u >> e[i].v >> e[i].w;\n    Kruskal();\n    dfs(1, 0);\n\n    cin >> q;\n    while (q--)\n    {\n        int u, v;\n        cin >> u >> v;\n        int w = LCA(u, v);\n        cout << cost - max(calc(u, w), calc(v, w)) << \"\\n\";\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].to==p))< ve.size() && (f = ve[gi].from,t=ve[gi].to, c = ve[gi].cost,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> vector<T> rev(vector<T> &a) {\n    vector<T> ret = a;\n    reverse(all(ret));\n    return ret;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    fora(e, g.edges) chmin(dis[e.from][e.to], e.cost);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].to;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        fora(e, edges)if (e.cost != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, cost, eid++, ty);\n        g[t].emplace_back(t, f, cost, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T cost = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, cost, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, cost, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    if (g.edges.size() == 0)return true;\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.from, e.to + g.n), uf.unite(e.from + g.n, e.to);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\n\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.to] == 0)st.push(e.to);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.to]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.to] == 0)q.push(e.to);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\nvoid solve() {\n    cin >> n >> m;\n    digraph<> g(2 * k5);\n    rep(i, m) {\n        int f, t, c;\n        cin >> f >> t >> c;\n        --f, --t;\n        g.add(f, t, c);\n    }\n    sort(g.edges);\n    UnionFind uf(k5);\n    digraph<> sg(4040);\n    fora(e, g.edges) {\n        if (uf.same(e.from, e.to))con;\n        uf.unite(e.from, e.to);\n        sg.add(e.from, e.to, e.cost);\n    }\n\n    cin >> q;\n    if(q> 3000)return ;\n    while (q--) {\n        din(s, tt);\n        s--, tt--;\n        UnionFind uf(4040);\n        uf.unite(s, tt);\n        cou=0;\n        fora(e, sg.edges) {\n            if (uf.same(e.from, e.to))con;\n            uf.unite(e.from, e.to);\n            cou += e.cost;\n        }\n        cout << cou << endl;\n    }\n\n}\nint my(int n, vi a) {\n    return 0;\n}\nint sister(int n, vi a) {\n    return 0;\n}\n\nsigned main() {\n    solve();\n\n#define _arg n,a\n    //cin>>n;\n    //na(a,n);\n    //my(_arg);\n    //cout << my(_arg) << endl;\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 3);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            cout << n << endl;\n            cout << a << endl;\n            cout << \"正解 : \" << res << endl;\n            cout << \"出力 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\n// write [ LCA lca(g, root); ] when using this snippet.\nclass LCA {\nprivate:\n\tconst std::vector<std::vector<int>>& graph; // graph's list expression\n\tint root;\n\tint n; // the number of nodes\n\tint log2n; // = floor(log2(n)) + 1\n\tstd::vector<std::vector<int>> parent; // parent[x][v] = a parent(above 2^x) of v (nonexistence -> -1)\n\tstd::vector<int> depth; // the depth of each node\n\npublic:\n\tLCA(const std::vector<std::vector<int>>& graph, int root) :\n\t\tgraph(graph), root(root), n(graph.size()),\n\t\tlog2n(std::floor(std::log2(n) + 1)),\n\t\tparent(log2n, std::vector<int>(n, 0)), depth(n, 0)\n\t{\n\t\tinit();\n\t}\n\n\t// Check the depth of each node(node \"v\" -> parent is \"p\", depth is \"d\")\n\tvoid dfs(int v, int p, int d) {\n\t\tstd::stack<int> stack;\n\t\tstack.push(v);\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\twhile (!stack.empty()) {\n\t\t\tint now = stack.top(); stack.pop();\n\t\t\tfor (int i = 0; i < graph[now].size(); ++i) {\n\t\t\t\tint to = graph[now][i];\n\t\t\t\tif (to == parent[0][now]) continue;\n\t\t\t\tparent[0][to] = now;\n\t\t\t\tdepth[to] = depth[now] + 1;\n\t\t\t\tstack.push(to); // Check each child of v\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initialize\n\tvoid init() {\n\t\t// Initialize \"parent[0]\" and \"depth\"\n\t\tdfs(root, -1, 0);\n\n\t\t// Initialize \"parent\"\n\t\tfor (int k = 0; k < log2n - 1; ++k) {\n\t\t\tfor (int v = 0; v < n; ++v) {\n\t\t\t\tif (parent[k][v] < 0) { // If parent above 2^k of v is nonexistence\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find LCA of (u, v)\n\tint lca(int u, int v) {\n\t\t// go up parent while depth of u and v is same\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2n; ++k) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v]; // go up to 2^k if k-th binary is 1\n\t\t\t}\n\t\t}\n\n\t\tif (u == v) return u; // this case is that v is in u's subtree\n\n\t\t// Find LCA by binary searching\n\t\tfor (int k = log2n - 1; k >= 0; --k) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, m, a, b, c);\n\tstd::vector<std::vector<PAIR>> g(n);\n\tstd::vector<PAIR> edge(m);\n\tREP(i, m) {\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].emplace_back(b[i], c[i]);\n\t\tg[b[i]].emplace_back(a[i], c[i]);\n\t\tedge[i] = PAIR(c[i], i);\n\t}\n\tstd::sort(ALL(edge));\n\n\t// 最小全域木\n\tstd::vector<std::vector<PAIR>> G(n); // (to, cost)\n\tstd::vector<std::vector<int>> G_(n); // 辺情報のみ(LCAで使う)\n\tUnionFind uf(n);\n\tint sum = 0;\n\tfor (auto& p : edge) {\n\t\tauto ei = p.second;\n\t\tint A = a[ei], B = b[ei], C = c[ei];\n\t\tif (uf.same(A, B)) continue;\n\t\tuf.unite(A, B);\n\t\tG[A].emplace_back(B, C);\n\t\tG[B].emplace_back(A, C);\n\t\tG_[B].emplace_back(A);\n\t\tG_[A].emplace_back(B);\n\t\tsum += C;\n\t}\n\n\t// LCA構成，根を0とする\n\tLCA lca(G_, 0);\n\n\t// 親を調べる\n\tstd::vector<PAIR> par(n, PAIR(-1, 0)); // (親, 親へのコスト)\n\tstd::function<void(int, int)> dfs = [&](int v, int pa) {\n\t\tfor (auto& e : G[v]) if (e.first != pa) {\n\t\t\tpar[e.first] = PAIR(v, e.second);\n\t\t\tdfs(e.first, v);\n\t\t}\n\t};\n\tdfs(0, -1);\n\n\t// クエリ\n\tVAR(int, Q);\n\tREP(_, Q) {\n\t\tVAR(int, s, t);\n\t\t--s; --t;\n\n\t\tint u = lca.lca(s, t);\n\t\tint ma = 0;\n\t\twhile (s != u) {\n\t\t\tCHMAX(ma, par[s].second);\n\t\t\ts = par[s].first;\n\t\t}\n\t\twhile (t != u) {\n\t\t\tCHMAX(ma, par[t].second);\n\t\t\tt = par[t].first;\n\t\t}\n\t\tOUT(sum - ma)BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM+1];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      es[i] = edge{a, b, c};\n    }\n    ll Q;\n    cin >> Q;\n    if(Q > 3000) return 0;\n    ll index = M;\n    rep(q, Q){\n      ll s, t;\n      cin >> s >> t;\n      s--; t--;\n      es[index] = edge{s, t, 0};\n      ll ans = 0;\n      sort(es, es+M+1, comp);\n      UnionFind uf(N);\n      uf.initialize();\n      rep(i, M+1){\n        edge& e = es[i];\n        if(e.cost == 0) index = i;\n        if(!uf.isSame(e.u, e.v)){\n          uf.merge(e.u, e.v);\n          ans += e.cost;\n        }\n      }\n      cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, ll> P;\n\nvector< vector<P> > G;\n\nstruct Union_Find {\n    //各要素が属する集合の代表(根)を管理する\n    //もし、要素xが根であればdata[x]は負の値を取り、-data[x]はxが属する集合の大きさに等しい\n    vector<int> data;\n    \n    Union_Find(int size) : data(size, -1) {}\n    bool Union(int x, int y) {\n        x = Find(x);\n        y = Find(y);\n        bool is_union = (x != y);\n        if (is_union) {\n            if (data[x] > data[y]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return is_union;\n    }\n    int Find(int x) {\n        if (data[x] < 0) { //要素xが根である\n            return x;\n        } else {\n            data[x] = Find(data[x]); //data[x]がxの属する集合の根でない場合、根になるよう更新される\n            return data[x];\n        }\n    }\n    bool same(int x, int y) {\n        return Find(x) == Find(y);\n    }\n    int size(int x) {\n        return -data[Find(x)];\n    }\n};\n\nstruct Edge {\n    int u, v;\n    ll cost;\n    bool operator<(const Edge& e) const {\n        return cost < e.cost;\n    }\n}; \n\nstruct Graph {\n    int n; //頂点数\n    vector<Edge> es; //辺集合\n    \n    ll kruskal() {\n        sort(es.begin(), es.end());\n        Union_Find uf(n);\n        ll min_cost = 0;\n        for(int i = 0; i < (int)es.size(); i++) {\n            Edge e = es[i];\n            if (!uf.same(e.u, e.v)) {\n                min_cost += e.cost;\n                uf.Union(e.u, e.v);\n                G[e.u].emplace_back(e.v, e.cost);\n                G[e.v].emplace_back(e.u, e.cost);\n            }\n        }\n        return min_cost;\n    }\n};\n\nGraph input() {\n   Graph g;\n   int m;\n   cin >> g.n >> m;\n   g.es = vector<Edge>(m);\n   for(int i = 0; i < m; i++) {\n        cin >> g.es[i].u >> g.es[i].v >> g.es[i].cost;\n        g.es[i].u--;\n        g.es[i].v--;\n   }\n   return g;\n}\n\nvoid dfs(int cur, int par, vector<ll>& d) {\n    for (P nex : G[cur]) {\n        if (nex.first == par) continue;\n        d[nex.first] = max(d[cur], nex.second);\n        dfs(nex.first, cur, d);\n    }\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tGraph g = input();\n    G.resize(g.n);\n    ll sum = g.kruskal();\n    vector< vector<ll> > maxc(g.n, vector<ll>(g.n, 0));\n    for (int i = 0; i < g.n; i++) {\n        dfs(i, -1, maxc[i]);\n    }\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        cout << sum - maxc[s][t] << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,q){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nstruct Edge{\n  int to;\n  LL cost;\n\n  Edge(int t, LL c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\n// 無向グラフのとき\nvoid add_edge(Graph& graph, int u, int v, LL cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\nvector<pair<Edge,int>> edges;\nLL kruskal(const Graph& G, Graph& G_){\n  int N = SZ(G);\n  UnionFind uf(N);\n\n  LL res = 0, i, n = 0;\n  for(i=0;i<SZ(edges);++i){\n\tauto& e = edges[i].first;\n\tint v = edges[i].second;\n\tif(!uf.same(e.to,v)){\n\t  uf.unite(e.to, v);\n\t  res += e.cost;\n\t  add_edge(G_, e.to, v, e.cost);\n\t}\n  }\n  return res;\n}\n\nLL dist[4010][4010];\nvoid dfs(int s, int p, int u, LL mx, Graph& G){\n  dist[s][u] = dist[u][s] = max(dist[s][u], mx);\n  for(auto& e: G[u]){\n\tif(e.to == p) continue;\n\tdfs(s, u, e.to, max(mx,e.cost), G);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  Graph G(N), G_(N);\n  REP(i,M){\n\tint a, b, c; cin >> a >> b >> c;\n\t--a; --b;\n\tadd_edge(G, a, b, c);\n\tedges.push_back(MP(G[a].back(), a));\n\tedges.push_back(MP(G[b].back(), b));\n  }\n  sort(ALL(edges));\n\n  LL mx = kruskal(G,G_);\n  REP(i,N) dfs(i,-1,i,0,G_);\n  int Q; cin >> Q;\n  while(Q--){\n\tLL s,t; cin >> s >> t;\n\t--s, --t;\n\n\tcout << mx - dist[s][t] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nGraph opt; //optimal edges for minimum-spanning\nvector<vector<int>> max_edge;\nWeight minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  priority_queue<Edge> Q;\n  for(int u=0;u<n;u++) for(auto &e: g[u]) /*if (u < e->dst)*/ Q.push(*e);\n  UnionFind uf(n);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n      opt[e.src].emplace_back(e.src,e.dst,e.weight);\n      opt[e.dst].emplace_back(e.dst,e.src,e.weight);\n    }\n  }\n  return total; //pair<Weight, Edges>(total, F);\n}\n\nvoid dfs(int z,int c,long long k,vector<int>&v){\n\tmax_edge[z][c]=k;\n\tv[c]=1;\n\tfor(auto &e:opt[c])if(!v[e.dst])dfs(z,e.dst,max(k,e.weight),v);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\topt.resize(N);\n\tWeight w;\n\t{\n\t\tGraph g(N);\n\t\tfor(;M--;){\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\t}\n\t\tw=minimumSpanningForest(g);\n\t}\n\tmax_edge.resize(N);\n\tfor(int i=0;i<N;i++)max_edge[i].resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tvector<int>v(N);\n\t\tdfs(i,i,0,v);\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tprintf(\"%lld\\n\",w-max_edge[a-1][b-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint root[4000];\nint getRoot(int v){ return root[v] == -1 ? v : root[v] = getRoot(root[v]); }\n\nvector<vector<int>> solve(int N, const vector<pair<int, pair<int,int>>>& edge){\n\tfill(root, root+N, -1);\n\tvector<vector<pair<int,int>>> g(N);\n\tint sum = 0;\n\tfor(auto& e : edge){\n\t\tint src = e.second.first;\n\t\tint dst = e.second.second;\n\t\tint p = getRoot(src);\n\t\tint q = getRoot(dst);\n\t\tif(p != q){\n\t\t\tsum += e.first;\n\t\t\troot[q] = p;\n\t\t\tg[src].emplace_back(dst, e.first);\n\t\t\tg[dst].emplace_back(src, e.first);\n\t\t}\n\t}\n\tvector<vector<int>> res(N, vector<int>(N, -1));\n\tfor(int i=0;i<N;i++){\n\t\tres[i][i] = 0;\n\t\tqueue<int> qu; qu.push(i);\n\t\twhile(!qu.empty()){\n\t\t\tint pos = qu.front(); qu.pop();\n\t\t\tfor(auto& e : g[pos]){\n\t\t\t\tint dst = e.first;\n\t\t\t\tif(res[i][dst] >= 0) continue;\n\t\t\t\tres[i][dst] = max(res[i][pos], e.second);\n\t\t\t\tqu.push(dst);\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto& v : res){\n\t\tfor(auto& t : v) t = sum - t;\n\t}\n\treturn res;\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M){\n\t\tvector<pair<int, pair<int, int>>> edge(M);\n\t\tfor(auto& p : edge){\n\t\t\tcin >> p.second.first >> p.second.second >> p.first;\n\t\t\t--p.second.first;\n\t\t\t--p.second.second;\n\t\t}\n\t\tsort(edge.begin(), edge.end());\n\t\tauto res = solve(N, edge);\n\t\tint Q; cin >> Q;\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << res[s-1][t-1] << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    scanf(\"%d%d%d\", &a[i], &b[i], &c[i]);\n    a[i]--; b[i]--;\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<long long>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  int sz = 13;\n  \n  vector<vector<int>> p(n, vector<int>(sz, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(sz, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<sz; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n\n    long long sub = 0;\n\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<sz; k++){\n      if( ((depth[v] - depth[u]) >> k) & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=sz-1; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n    if(u!=v){\n      sub = max({sub, mx_e[u][0], mx_e[v][0]});\n    }\n\n    //println( mst_cost - sub );\n    printf(\"%lld\\n\", mst_cost - sub);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nstruct cww{cww(){\n    ios::sync_with_stdio(false);cin.tie(0);\n}}star;\n#define fin \"\\n\"\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define fi first\n#define se second\n#define pb push_back\n#define DEBUG if(0)\ntemplate <typename T>inline void chmin(T &l,T r){l=min(l,r);}\ntemplate <typename T>inline void chmax(T &l,T r){l=max(l,r);}\ntemplate <typename T>\nistream& operator>>(istream &is,vector<T> &v){\n    for(auto &it:v)is>>it;\n    return is;\n}\n\nnamespace _DSU{\n    int cnt=0;\n    int mem[2][212345];\n    int* get(){\n        return mem[cnt++];\n    }\n}\nLL res[112345];\nint S[112345];\nint T[112345];\nset<int> query[41234];\nint task[112345];\nclass UnionFind{\nprivate:\n    int *par,*rank;\n    int find(int x){\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\npublic:\n    UnionFind(int n,int *par,int *rank) :par(par),rank(rank){\n        for(int i = 0; i < n; i++)par[i] = i,rank[i] = 0;\n    }\n    UnionFind(int n):UnionFind(n,_DSU::get(),_DSU::get()){}\n    int unite(int x, int y){\n        x = find(x);y = find(y);\n        if (x == y)return -1;\n        int sz=0;\n        if(query[x].size()>query[y].size())swap(x,y);\n        for(auto &it:query[x]){\n            if(query[y].count(it)){\n                task[sz++]=it;\n                query[y].erase(it);\n            }\n            else query[y].insert(it);\n        }\n        query[x].clear();\n        if (rank[x] < rank[y])swap(x,y);\n        if(query[x].size()==0)swap(query[x],query[y]);\n        par[y] = x;\n        if (rank[x] == rank[y])rank[x]++;\n        return sz;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\ntypedef tuple<LL,int,int> E;\nint main(){\n    int N,M,Q;\n    cin>>N>>M;\n    vector<E> e(M);\n    REP(i,M){\n        int s,t;LL c;\n        cin>>s>>t>>c;\n        e[i]=E(c,s,t);\n    }\n    sort(e.begin(),e.end());\n    \n    cin>>Q;\n    REP(i,Q){\n        cin>>S[i]>>T[i];\n        query[S[i]].insert(i);\n        query[T[i]].insert(i);\n    }\n    LL cost=0;\n    UnionFind uf(N+1);\n    REP(i,M){\n        int a,b;LL c;\n        tie(c,a,b)=(e[i]);\n        int k=uf.unite(a,b);\n        if(k==-1)continue;\n        REP(i,k){\n            res[task[i]]=c;\n        }\n        cost+=c;\n    }\n    REP(i,Q)cout<<cost-res[i]<<fin;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[4001];             // グラフ\nint depth[4001];        // 根付き木の深さ\nint anc[4001][12];      // anc[i][k] := iの2^k個上の祖先\nint query[4001][12];\n \nint data[4001];\nint init(){\n  REP(i,4001)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n        // DEBUG(a);\n        // DEBUG(b);\n      }\n    }\n  }\n \n  queue<int> Q;\n \n  // 根付き木にする\n  // そしてダブリングの準備\n  REP(i,n) depth[i]=INF;\n  REP(i,n)REP(k,20) anc[i][k]=query[i][k]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      Q.push(to);\n      // ダブリング準備\n      anc[to][0] = pos;\n      query[to][0] = c;\n      int id = 1;\n      int cur = pos;\n      while(anc[cur][id-1]!=INF){\n        int next = anc[cur][id-1];\n        anc[to][id] = next;\n        query[to][id] = min(query[to][id-1], query[cur][id-1]);\n        cur = next;\n        ++id;\n      }\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n    // LCAを取る\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    // 同じ高さにズラす\n    int diff = depth[b]-depth[a];\n    int k = 0;\n    while(diff){\n      if(diff&1){\n        CHMIN(x,(ll)query[b][k]);\n        b = anc[b][k];\n      }\n      diff>>=1;\n      ++k;\n    }\n    k = 19;\n    while(k>=0){\n      if(anc[a][k]!=INF && anc[a][k]!=anc[b][k]){\n        CHMIN(x,(ll)query[a][k]);\n        CHMIN(x,(ll)query[b][k]);\n        a = anc[a][k];\n        b = anc[b][k];\n      }\n      --k;\n    }\n    int lca = a;\n    if(a!=b){\n      CHMIN(x,(ll)query[a][0]);\n      CHMIN(x,(ll)query[b][0]);\n      lca = anc[a][0];\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define iREP(i,Itr) for(auto (i)=(Itr).begin();(i)!=(Itr).end();(i)++)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\ntypedef long long ll;\n\nint maxcost[4010][4010];\nbool used[4010];\nvector<int> G[4010];\nmap< pair<int,int>,int> cost;\n\nclass UnionFindFixed{\n    vector<int> data;\npublic:\n    UnionFindFixed(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nvoid dfs(int v, int mcost,int ori){\n    used[v]=true;\n    REP(i,G[v].size()){\n        if(!used[G[v][i]]){\n            mcost=max(mcost,cost[make_pair(v,G[v][i])]);\n            maxcost[ori][G[v][i]]=mcost;\n            maxcost[ori][G[v][i]]=mcost;\n            dfs(G[v][i],mcost,ori);\n        }\n    }\n}\n\nint main(){\n    \n    int N,M; cin>>N>>M;\n    vector< pair<int,pair<int,int> > > v(M);\n    REP(i,M)cin>>v[i].second.first>>v[i].second.second>>v[i].first;\n    sort(v.begin(),v.end());\n    \n    ll totalcost=0;\n    UnionFindFixed inst(4010);\n    REP(i,M){\n        int a=v[i].second.first,b=v[i].second.second,c=v[i].first;\n        if(!inst.findSet(a,b)){\n            inst.unionSet(a,b);\n            G[a].push_back(b);\n            G[b].push_back(a);\n            cost[make_pair(a,b)]=c;\n            cost[make_pair(b,a)]=c;\n            totalcost+=c;\n        }\n    }\n    \n    for(int i=1;i<=N;i++){\n        REP(j,4010)used[j]=false;\n        dfs(i,0,i);\n    }\n    \n   /* for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++)cout<<maxcost[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    \n    int Q; cin>>Q;\n    REP(i,Q){\n        int S,T; cin>>S>>T;\n        cout<<totalcost-maxcost[S][T]<<endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nvoid YN(bool b){print(b?\"YES\":\"NO\");}void PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");}\nvoid Yn(bool b){print(b?\"Yes\":\"No\");}void Pi(bool b){print(b?\"Possible\":\"Impossible\");}\nvoid yn(bool b){print(b?\"yes\":\"no\");}void pi(bool b){print(b?\"possible\":\"impossible\");}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vi B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\nclass UnionFind{vi p,r,s;public:UnionFind(int N){p=r=vi(N);s=vi(N,1);fr(i,N){p[i]=i;}}int find(int i){return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){if(r[a=find(a)]>r[b=find(b)]){swap(a,b);}s[b]+=s[a];r[p[a]=b]+=r[a]==r[b];}bool same(int a,int b){return find(a)==find(b);}int size(int x){return s[find(x)];}};\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\nll segsum(vl&s,int l,int r){l|=s.size()>>1;r|=s.size()>>1;if(l>r){return 0;}if(l==r){return s[l];}ll z=s[l]+s[r];for(;l>>1<r>>1;l>>=1,r>>=1){l&1||(z+=s[l^1]);r&1&&(z+=s[r^1]);}return z;}\nvoid segadd(vl&s,int i,ll x){s[i|=s.size()>>1]+=x;for(;i>>1>=1;i>>=1){s[i>>1]=s[i]+s[i^1];}}\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n// (int) * (int) => (int)\n// (int) / (int) => (int)\n\nll dfs(vector<vpli>&E,int i,int p,int T){\n\tif(i!=p&&E[i].size()==1)return 0;\n\tll m=0;\n\tfor(pli v:E[i])if(v.second!=p){\n\t\tif(v.second==T)return v.first;\n\t\tll d=dfs(E,v.second,i,T);\n\t\tif(d)return max(d,v.first);\n\t}\n\treturn 0;\n}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tusing P=pair<ll,pii>;\n\tvector<P>E;\n\tfr(i,M){\n\t\tint a,b;ll c;cin>>a>>b>>c;\n\t\tE<<P{c,{a-1,b-1}};\n\t}\n\tSort(E);\n\tUnionFind uf(N);\n\tll z=0;\n\tvector<vpli>EE(N);\n\tfor(P e:E){\n\t\tint a=e.second.first,b=e.second.second,c=e.first;\n\t\tif(!uf.same(a,b)){\n\t\t\tuf.unite(a,b);\n\t\t\tz+=c;\n\t\t\tEE[a]<<pli{c,b};\n\t\t\tEE[b]<<pli{c,a};\n\t\t}\n\t}\n\tint Q;cin>>Q;\n\tfr(q,Q){\n\t\tint S,T;cin>>S>>T;\n\t\tprintf(\"%lld\\n\",z-dfs(EE,S-1,S-1,T-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint n, m;\nint q;\n\n/// --- Union Find Library {{{ ///\n\nstruct UF {\n  int n;\n  vector<int> par, rank;\n  UF(int n): n(n), par(n, -1), rank(n, 0) {}\n  int find(int x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n  int size(int x) {\n    return -par[find(x)];\n  }\n  bool same(int a, int b) {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b) return;\n    if(rank[a] > rank[b]) swap(a, b);\n    par[b] += par[a];\n    par[a] = b;\n    if(rank[a] == rank[b]) rank[b]++;\n  }\n};\n\n/// }}}--- ///\n\nusing P = tuple<int, int, int>;\nconst int N = 4000;\nvector<int> tree[N];\nvector<pair<int, int>> treetwo[N];\n\nint g[N][N];\nint par[N][13];\nint dist[N][13];\nint dep[N];\n\nvoid dfs(int i, int p = -1, int d = 0) {\n  par[i][0] = p;\n  dep[i] = d;\n  if(p != -1) dist[i][0] = g[i][p];\n  for(int j : tree[i]) if(j != p) {\n    dfs(j, i, d + 1);\n  }\n}\n\nvoid build() {\n  dfs(0);\n  for(int i = 1; i < 13; i++) {\n    for(int j = 0; j < n; j++) {\n      int p = par[j][i - 1];\n      int d = dist[j][i - 1];\n      if(p != -1) {\n        par[j][i] = par[p][i - 1];\n        dist[j][i] = max(d, dist[p][i - 1]);\n      } else par[j][i] = -1;\n    }\n  }\n}\n\nint lca(int a, int b) {\n  if(dep[a] > dep[b]) swap(a, b);\n  // cerr << \"dep ab = \"<< dep[a] << \" , \" << dep[b] << endl;\n  for(int i = 12; i >= 0; i--) {\n    int p = par[b][i];\n    if(p != -1 && dep[p] >= dep[a]) b = p;\n  }\n  if(a == b) return a;\n  // cerr << \"dep ab = \"<< dep[a] << \" , \" << dep[b] << endl;\n  // cerr << \"ab = \"<< a << \" , \" << b << endl;\n  for(int i = 12; i >= 0; i--) {\n    int pa = par[a][i];\n    int pb = par[b][i];\n    if(pa != pb) a = pa, b = pb;\n  }\n  return par[a][0];\n}\n\nint calc(int top, int a) {\n  int res = 0;\n  for(int i = 12; i >= 0; i--) {\n    int p = par[a][i];\n    if(p != -1 && dep[p] >= dep[top]) res = max(res, dist[a][i]), a = p;\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> m;\n\n  vector<P> es;\n  for(int i = 0; i < m; i++) {\n    int a, b, c; cin >> a >> b >> c;\n    a--; b--;\n    es.emplace_back(c, a, b);\n  }\n  sort(begin(es), end(es));\n\n  UF treeone(n);\n  ll cost = 0;\n\n  // kruskal\n  for(int i = 0; i < m; i++) {\n    int a = get<1>(es[i]), b = get<2>(es[i]), c = get<0>(es[i]);\n    if(!treeone.same(a, b)) {\n      treeone.unite(a, b);\n      tree[a].emplace_back(b);\n      tree[b].emplace_back(a);\n      treetwo[a].emplace_back(b, c);\n      treetwo[b].emplace_back(a, c);\n      g[a][b] = c;\n      g[b][a] = c;\n      cost += c;\n    }\n  }\n  // doubling\n  build();\n\n  cin >> q;\n  for(int i = 0; i < q; i++) {\n    int s, t; cin >> s >> t;\n    s--; t--;\n    int l = lca(s, t);\n    // cerr << \"s = \" << s + 1 << \" , t = \" << t + 1 << \" , lca = \" << l + 1 << endl;\n    ll ans = cost;\n    if(s == l) ans -= calc(s, t);\n    else if(t == l) ans -= calc(t, s);\n    else ans -= max(calc(l, s), calc(l, t));\n    cout << ans << endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define MOD 1000000007LL\n#define endl \"\\n\"\n#define snd second\n#define fst first\nconst ll UNDEF = -1;\nconst ll INF=1e18;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;\n\n#ifdef DEBUG\n     #define debug(args...)            {dbg,args; cerr<<endl;}\n#else\n    #define debug(args...)              // Just strip off all debug tokens\n#endif\n\nstruct debugger\n{\n    template<typename T> debugger& operator , (const T& v)\n    {    \n        cerr<<v<<\" \";    \n        return *this;    \n    }\n} dbg;\n\nclass HeavyLight2NoRecursion {\n\n\t// true - values on vertices, false - values on edges\n\tbool VALUES_ON_VERTICES = false;\n\n\t// Modify the following 6 methods to implement your custom operations on the tree.\n\t// This example implements Add/Max operations. Operations like Add/Sum, Set/Max can also be implemented.\n\tint modifyOperation(int x, int y) {\n\t\treturn x + y;\n\t}\n\n\t// query (or combine) operation\n\tint queryOperation(int leftValue, int rightValue) {\n\t\treturn max(leftValue, rightValue);\n\t}\n\n\tint deltaEffectOnSegment(int delta, int segmentLength) {\n\t\tif (delta == getNeutralDelta()) return getNeutralDelta();\n\t\t// Here you must write a fast equivalent of following slow code:\n\t\t// int result = delta;\n\t\t// for (int i = 1; i < segmentLength; i++) result = queryOperation(result, delta);\n\t\t// return result;\n\t\treturn delta;\n\t}\n\n\tint getNeutralDelta() {\n\t\treturn 0;\n\t}\n\n\tint getInitValue() {\n\t\treturn 0;\n\t}\n\n\tint getNeutralValue() {\n\t\treturn INT_MIN;\n\t}\n\n\t// generic code\n\tint joinValueWithDelta(int value, int delta) {\n\t\tif (delta == getNeutralDelta()) return value;\n\t\treturn modifyOperation(value, delta);\n\t}\n\n\tint joinDeltas(int delta1, int delta2) {\n\t\tif (delta1 == getNeutralDelta()) return delta2;\n\t\tif (delta2 == getNeutralDelta()) return delta1;\n\t\treturn modifyOperation(delta1, delta2);\n\t}\n\n\tvector<vector<int> > value;\n\tint** delta; // delta[i] affects value[i], delta[2*i+1] and delta[2*i+2]\n\tint** len;\n\n\tvector<vector<int> > tree;\n\tint* size;\n\tint* parent;\n\tint* tin;\n\tint* tout;\n\tint time=0;\n\tint* path;\n\tint* pathSize;\n\tint* pathPos;\n\tint* pathRoot;\n\tint pathCount=0;\npublic:\n\tHeavyLight2NoRecursion(vector<vector<int> > tree) {\n\t\tthis->tree = tree;\n\t\tint n = tree.size();\n\n\t\tsize = new int[n];\n\t\tparent = new int[n];\n\t\ttin = new int[n]; \n\t\ttout = new int[n]; \n\t\tcalcSizeParentTinTout(0);\n\n\t\tpath = new int[n]; \n\t\tpathSize = new int[n]; fill(pathSize,pathSize+n,0);\n\t\tpathPos = new int[n]; \n\t\tpathRoot = new int[n]; \n\t\tbuildPaths(0);\n\n\t\tvalue.resize(pathCount);\n\t\tdelta = new int*[pathCount];\n\t\tlen = new int*[pathCount];\n\n\t\tfor (int i = 0; i < pathCount; i++) {\n\t\t\tint m = pathSize[i];\n\n\t\t\tvalue[i].resize(2*m);\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tvalue[i][j + m] = getInitValue();\n\t\t\tfor (int j = 2 * m - 1; j > 1; j -= 2)\n\t\t\t\tvalue[i][j >> 1] = queryOperation(value[i][j], value[i][j ^ 1]);\n\n\t\t\tdelta[i] = new int[2 * m];\n\t\t\tfill(delta[i], delta[i]+(2*m), getNeutralDelta());\n\n\t\t\tlen[i] = new int[2 * m];\n\t\t\tfill(len[i]+m, len[i]+(2*m), 1);\n\t\t\tfor (int j = 2 * m - 1; j > 1; j -= 2)\n\t\t\t\tlen[i][j >> 1] = len[i][j] + len[i][j ^ 1];\n\t\t}\n\t}\n\n\tvoid calcSizeParentTinTout(int root) {\n\t\tint n = tree.size();\n\t\tint* curEdge = new int[n]; fill(curEdge,curEdge+n,0);\n\t\tint* _stack = new int[n];\n\t\t_stack[0] = root;\n\t\tparent[root] = -1;\n\t\tfor (int top = 0; top >= 0; ) {\n\t\t\tint u = _stack[top];\n\t\t\tif (curEdge[u] == 0) {\n\t\t\t\ttin[u] = time++;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (curEdge[u] < tree[u].size()) {\n\t\t\t\tint v = tree[u][curEdge[u]++];\n\t\t\t\tif (curEdge[v] == 0) {\n\t\t\t\t\t_stack[++top] = v;\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t--top;\n\t\t\t\tif (parent[u] != -1)\n\t\t\t\t\tsize[parent[u]] += size[u];\n\t\t\t\ttout[u] = time++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint newPath(int u) {\n\t\tpathRoot[pathCount] = u;\n\t\treturn pathCount++;\n\t}\n\n\tvoid buildPaths(int root) {\n\t\tint n = tree.size();\n\t\tint* curEdge = new int[n]; fill(curEdge,curEdge+n,0);\n\t\tint* _stackPath = new int[n];\n\t\tint* _stack = new int[n];\n\t\t_stack[0] = root;\n\t\t_stackPath[0] = newPath(root);\n\t\tfor (int top = 0; top >= 0; ) {\n\t\t\tint u = _stack[top];\n\t\t\tint path = _stackPath[top];\n\t\t\tif (curEdge[u] == 0) {\n\t\t\t\tthis->path[u] = path;\n\t\t\t\tpathPos[u] = pathSize[path]++;\n\t\t\t}\n\t\t\tif (curEdge[u] < tree[u].size()) {\n\t\t\t\tint v = tree[u][curEdge[u]++];\n\t\t\t\tif (curEdge[v] == 0) {\n\t\t\t\t\t_stack[++top] = v;\n\t\t\t\t\t_stackPath[top] = 2 * size[v] >= size[u] ? path : newPath(v);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t--top;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid buildPaths(int u, int path) {\n\t\tthis->path[u] = path;\n\t\tpathPos[u] = pathSize[path]++;\n\t\tfor (int v : tree[u]) {\n\t\t\tif (v != parent[u])\n\t\t\t\tbuildPaths(v, 2 * size[v] >= size[u] ? path : newPath(v));\n\t\t}\n\t}\n\n\tvoid pushDelta(int path, int i) {\n\t\tint d = 0;\n\t\tfor (; (i >> d) > 0; d++)\n\t\t\t;\n\t\tfor (d -= 2; d >= 0; d--) {\n\t\t\tint x = i >> d;\n\t\t\tvalue[path][x >> 1] = joinValueWithDelta0(path, x >> 1);\n\t\t\tdelta[path][x] = joinDeltas(delta[path][x], delta[path][x >> 1]);\n\t\t\tdelta[path][x ^ 1] = joinDeltas(delta[path][x ^ 1], delta[path][x >> 1]);\n\t\t\tdelta[path][x >> 1] = getNeutralDelta();\n\t\t}\n\t}\n\n\tint joinValueWithDelta0(int path, int i) {\n\t\treturn joinValueWithDelta(value[path][i], deltaEffectOnSegment(delta[path][i], len[path][i]));\n\t}\n\n\tint queryPath(int path, int from, int to) {\n\t\tfrom += value[path].size() >> 1;\n\t\tto += value[path].size() >> 1;\n\t\tpushDelta(path, from);\n\t\tpushDelta(path, to);\n\t\tint res = getNeutralValue();\n\t\tfor (; from <= to; from = (from + 1) >> 1, to = (to - 1) >> 1) {\n\t\t\tif ((from & 1) != 0)\n\t\t\t\tres = queryOperation(res, joinValueWithDelta0(path, from));\n\t\t\tif ((to & 1) == 0)\n\t\t\t\tres = queryOperation(res, joinValueWithDelta0(path, to));\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid modifyPath(int path, int from, int to, int delta) {\n\t\tfrom += value[path].size() >> 1;\n\t\tto += value[path].size() >> 1;\n\t\tpushDelta(path, from);\n\t\tpushDelta(path, to);\n\t\tint ta = -1;\n\t\tint tb = -1;\n\t\tfor (; from <= to; from = (from + 1) >> 1, to = (to - 1) >> 1) {\n\t\t\tif ((from & 1) != 0) {\n\t\t\t\tthis->delta[path][from] = joinDeltas(this->delta[path][from], delta);\n\t\t\t\tif (ta == -1)\n\t\t\t\t\tta = from;\n\t\t\t}\n\t\t\tif ((to & 1) == 0) {\n\t\t\t\tthis->delta[path][to] = joinDeltas(this->delta[path][to], delta);\n\t\t\t\tif (tb == -1)\n\t\t\t\t\ttb = to;\n\t\t\t}\n\t\t}\n\t\tfor (int i = ta; i > 1; i >>= 1)\n\t\t\tvalue[path][i >> 1] = queryOperation(joinValueWithDelta0(path, i), joinValueWithDelta0(path, i ^ 1));\n\t\tfor (int i = tb; i > 1; i >>= 1)\n\t\t\tvalue[path][i >> 1] = queryOperation(joinValueWithDelta0(path, i), joinValueWithDelta0(path, i ^ 1));\n\t}\n\n\tbool isAncestor(int p, int ch) {\n\t\treturn tin[p] <= tin[ch] && tout[ch] <= tout[p];\n\t}\n\n\tint query(int a, int b) {\n\t\tint res = getNeutralValue();\n\t\tfor (int root; !isAncestor(root = pathRoot[path[a]], b); a = parent[root])\n\t\t\tres = queryOperation(res, queryPath(path[a], 0, pathPos[a]));\n\t\tfor (int root; !isAncestor(root = pathRoot[path[b]], a); b = parent[root])\n\t\t\tres = queryOperation(res, queryPath(path[b], 0, pathPos[b]));\n\t\tif (!VALUES_ON_VERTICES && a == b)\n\t\t\treturn res;\n\t\treturn queryOperation(\n\t\t\t\tres,\n\t\t\t\tqueryPath(path[a], min(pathPos[a], pathPos[b]) + (VALUES_ON_VERTICES ? 0 : 1),\n\t\t\t\t\t\tmax(pathPos[a], pathPos[b])));\n\t}\n\n\tvoid modify(int a, int b, int delta) {\n\t\tfor (int root; !isAncestor(root = pathRoot[path[a]], b); a = parent[root])\n\t\t\tmodifyPath(path[a], 0, pathPos[a], delta);\n\t\tfor (int root; !isAncestor(root = pathRoot[path[b]], a); b = parent[root])\n\t\t\tmodifyPath(path[b], 0, pathPos[b], delta);\n\t\tif (!VALUES_ON_VERTICES && a == b)\n\t\t\treturn;\n\t\tmodifyPath(path[a], min(pathPos[a], pathPos[b]) + (VALUES_ON_VERTICES ? 0 : 1),\n\t\t\t\tmax(pathPos[a], pathPos[b]), delta);\n\t}\n};\n\n\n\nconst ll mn=4000+4;\nll p[mn];\nll ffind(ll x) {\n\tif(p[x]!=x) {\n\t\tp[x]=ffind(p[x]);\n\t}\n\treturn p[x];\n}\nvoid funion(ll x, ll y) {\n\tif (rand()&1) swap(x,y);\n\tll xr=ffind(x),yr=ffind(y);\n\tp[yr]=xr;\n}\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tsrand(time(0));\n\tll n,m; scanf(\"%lld%lld\",&n,&m);\n\tfor (ll x=0;x<n;x++) p[x]=x;\n\tvector<pair<ll,pll> > ve;\n\tfor (ll i=0;i<m;i++) {\n\t\tll a,b,c; scanf(\"%lld%lld%lld\",&a,&b,&c);\n\t\t--a; --b;\n\t\tve.PB(MP(c,MP(a,b)));\n\t}\n\tsort(ve.begin(),ve.end());\n\tvector<ll> eidxv;\n\tll total_cost=0;\n\tvector<vector<int> > tree;\n\ttree.resize(n);\n\tfor (ll ei=0;ei<ve.size();ei++) {\n\t\tauto edge=ve[ei];\n\t\tll a=edge.snd.fst,b=edge.snd.snd,c=edge.fst;\n\t\tif (ffind(a)!=ffind(b)) {\n\t\t\tfunion(a,b);\n\t\t\ttree[a].PB(b);\n\t\t\ttree[b].PB(a);\n\t\t\ttotal_cost+=c;\n\t\t\teidxv.PB(ei);\n\t\t}\n\t}\n\tHeavyLight2NoRecursion hl = HeavyLight2NoRecursion(tree);\n\tfor (auto &ei:eidxv) {\n\t\tauto edge=ve[ei];\n\t\tll a=edge.snd.fst,b=edge.snd.snd,c=edge.fst;\n\t\thl.modify(a,b,c);\n\t}\n\tll q; scanf(\"%lld\",&q);\n\tfor (ll i=0;i<q;i++) {\n\t\tll s,t; scanf(\"%lld%lld\",&s,&t);\n\t\t--s; --t;\n\t\tll high=hl.query(s,t);\n\t\tll ans=total_cost-high;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nstruct unionFind {\n    vector<int> data;\n    unionFind(int size) : data(size, -1) {}\n    \n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x != y) {\n            if(data[y] < data[x]) {\n                swap(x, y);\n            }\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int root(int x) {\n        return (data[x] < 0) ? x : data[x] = root(data[x]);\n    }\n\n    int rank(int x) {\n        return -data[root(x)];\n    }\n};\n\n//cost,from,toの順\nvector<tlglglg> T;\nvector<tlglglg> Krusans;\n\nll Kruskal(int n) {\n    sort(T.begin(), T.end());\n    ll ans = 0;\n    ll num = 0;\n    unionFind u(n);\n    int size = T.size();\n    for (int i = 0; i < size; i++) {\n        ll cost = get<0>(T[i]);\n        ll from = get<1>(T[i]);\n        ll to = get<2>(T[i]);\n        if (!u.same(from, to)) {\n            u.unite(from, to);\n            ans += cost;\n            num++;\n            tlglglg t = make_tuple(cost, from, to);\n            Krusans.push_back(t);\n        }\n        if (num == n - 1) {\n            break;\n        }\n    }\n    if (num == n - 1) {\n        return ans;\n    } else {\n        return llmax;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> G[1000000];\nll d[1000000];\n\nvoid addedge(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nll dif[4010][4010];\n\nvoid dfs(int n) {\n    fill(dif[n], dif[n] + V, -1);\n    dif[n][n] = 0;\n    queue<ll> que;\n    que.push(n);\n    while(!que.empty()) {\n        ll q = que.front();\n        que.pop();\n        REP(i, 0, G[q].size()) {\n            edge e = G[q][i];\n            if (dif[n][e.to] != -1) {\n                continue;\n            }\n            dif[n][e.to] = max(dif[n][q], e.cost);\n            que.push(e.to);\n        }\n    }\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    REP(i, 0, M) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        tlglglg t = tlglglg(c, a - 1, b - 1);\n        T.push_back(t);\n    }\n    ll sum = Kruskal(N);\n    V = N;\n    REP(i, 0, N - 1) {\n        tlglglg t = Krusans[i];\n        addedge(get<1>(t), get<2>(t), get<0>(t));\n        addedge(get<2>(t), get<1>(t), get<0>(t));\n    }\n    REP(i, 0, N) {\n        dfs(i);\n    }\n    // REP(i, 0, N) {\n    //     REP(j, 0, N) {\n    //         cout << dif[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    ll Q;\n    cin >> Q;\n    REP(i, 0, Q) {\n        ll s, t;\n        cin >> s >> t;\n        cout << sum - dif[s - 1][t - 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nll unipar[4010];\nll unilen[4010];\nvector<pll> vn[4010];\nstruct edge{\n  ll len,from,to;\n};\nbool cmp(edge& a,edge& b){\n  return a.len<b.len;\n}\nvoid uniinit(ll n){\n  for(ll i=1;i<=n;i++){\n    unipar[i]=i;\n    unilen[i]=0;\n  }\n}\nll root(ll n){\n  if(unipar[n]==n)return n;\n  return unipar[n]=root(unipar[n]);\n}\nvoid unit(ll a,ll b){\n  a=root(a);\n  b=root(b);\n  if(a==b)return;\n  if(unilen[a]<unilen[b]){\n    unipar[a]=b;\n  }\n  else{\n    unipar[b]=a;\n    if(unipar[b]==unipar[a])unilen[a]++;\n  }\n}\nll ne;\nll par[60][4010];\nll dep[60];\nvoid lcadfs(ll v,ll p,ll d){\n  par[0][v]=p;\n  dep[v]=d;\n  for(ll i=0;i<vn[v].size();i++){\n    if(vn[v][i].first!=p)lcadfs(vn[v][i].first,v,d+1);\n  }\n}\nvoid lcainit(ll n){\n  lcadfs(ne,-1,0);\n  for(ll i=0;i<59;i++){\n    for(ll j=1;j<=n;j++){\n      if(par[i][j]<0)par[i+1][j]=-1;\n      else par[i+1][j]=par[i][par[i][j]];\n    }\n  }\n}\nll lca(ll u,ll v){\n  if(dep[u]>dep[v])swap(u,v);\n  for(ll i=0;i<60;i++){\n    if((dep[v]-dep[u])>>i&1)v=par[i][v];\n  }\n  if(u==v)return u;\n  for(ll i=59;i>=0;i--){\n    if(par[i][u]!=par[i][v]){\n      u=par[i][u];\n      v=par[i][v];\n    }\n  }\n  return par[0][u];\n}\nll mae[60][4010];\nvoid maedfs(ll v,ll p,ll dis){\n  mae[0][v]=dis;\n  for(ll i=0;i<vn[v].size();i++){\n    if(vn[v][i].first!=p)maedfs(vn[v][i].first,v,vn[v][i].second);\n  }\n}\nvoid maeinit(ll n){\n  maedfs(ne,-1,-1);\n  for(ll i=0;i<59;i++){\n    for(ll j=1;j<=n;j++){\n      mae[i+1][j]=max(mae[i][j],mae[i][par[i][j]]);\n    }\n  }\n}\nll maxedge(ll u,ll v){\n  ll r=lca(u,v);\n  ll ret=0;\n  for(ll i=59;i>=0;i--){\n    if((dep[u]-dep[r])>>i&1){\n      ret=max(ret,mae[i][u]);\n      u=par[i][u];\n    }\n  }\n  for(ll i=59;i>=0;i--){\n    if((dep[v]-dep[r])>>i&1){\n      ret=max(ret,mae[i][v]);\n      v=par[i][v];\n    }\n  }\n  return ret;\n}\nint main(){\n  ll n,m;cin>>n>>m;\n  vector<edge> v;\n  for(ll i=0;i<m;i++){\n    ll a,b,c;cin>>a>>b>>c;\n    v.push_back((edge){c,a,b});\n  }\n  sort(v.begin(),v.end(),cmp);\n  uniinit(n);\n  ll now=0;\n  ll sum=0;\n  for(ll i=0;i<m;i++){\n    edge e=v[i];\n    ll a=e.from,b=e.to;\n    if(root(a)!=root(b)){\n      unit(a,b);\n      sum+=e.len;\n      vn[a].push_back(make_pair(b,e.len));\n      vn[b].push_back(make_pair(a,e.len));\n      now++;\n    }\n    if(now==n-1)break;\n  }\n  ne=1;\n  lcainit(n);\n  maeinit(n);\n  ll q;cin>>q;\n  for(ll i=0;i<q;i++){\n    ll s,t;cin>>s>>t;\n    ll dd=maxedge(s,t);\n    cout<<sum-dd<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  UF(int n) : par(n), sizes(n, 1) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n    }\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vvi edge(m+1, vi(3));\n  rep (i, m) {\n    cin >> edge[i][1] >> edge[i][2] >> edge[i][0];\n    edge[i][1] -= 1; edge[i][2] -= 1;\n  }\n  edge[m][0] = 0;\n  sort(all(edge));\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  vvi edge_ = edge;\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    edge_[0][1] = s;\n    edge_[0][2] = t;\n    UF uf(n);\n    rep (i, m+1) {\n      if (!(uf.same(edge_[i][1], edge_[i][2]))) {\n        ans[j] += edge_[i][0];\n        uf.unite(edge_[i][1], edge_[i][2]);\n      }\n      if (uf.size(s) == n) {\n        break;\n      }\n    }\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a}); // 0:cost, 1:opponent, 2:self\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    cand.erase(begin(cand));\n    if (uf.same(edge[1], edge[2])) {\n      continue;\n    }\n    assert(uf.same(0, edge[2]));\n    assert(!uf.same(0, edge[1]));\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      assert(!uf.same(i, edge[1]));\n      assert(uf.same(0, i));\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (i, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[i] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mk(a,b) make_pair(a,b)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, pll> plpll;\ntypedef pair<pll, pll> llll;\n\nint N, M;\nvector<pll> G[4010];\nvector<pll> cost;\nvector<plpll> E;\nbool is_tree[400010];\nint par[4010];\nll sum;\nint current_root;\nll max_cost[4010][4010];\n\nvoid init(int N)\n{\n    for(int i = 0; i < N; i++)par[i] = i;\n    return;\n}\n\nint root(int x)\n{\n    if(par[x] == x)return x;\n    return par[x] = root(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n    x = root(x);\n    y = root(y);\n\n    if(x == y)return;\n\n    par[x] = y;\n    return;\n}\n\nbool same(int x, int y)\n{\n    return root(x) == root(y);\n}\n\nvoid DFS(int v, int p = -1, ll d = 0)\n{\n    max_cost[current_root][v] = d;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int next = G[v][i].fi, id = G[v][i].se;\n        ll cost = E[id].fi;\n        if(p == next || !is_tree[id])continue;\n        DFS(next, v, max(d, cost));\n    }\n    return;\n}\n\nint main()\n{\n    cin >> N >> M;\n    for(int i = 0; i < M; i++)\n    {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        cost.push_back(mk(c, i));\n        E.push_back(mk(c, mk(a, b)));\n        G[a].push_back(mk(b, i));\n        G[b].push_back(mk(a, i));\n    }\n\n    init(N);\n    sort(cost.begin(), cost.end());\n    for(int i = 0; i < M; i++)\n    {\n        int now = cost[i].se;\n        int a = E[now].se.fi, b = E[now].se.se;\n        if(!same(a, b))\n        {\n            sum += cost[i].fi;\n            is_tree[now] = true;\n            unite(a, b);\n        }\n    }\n\n    for(int i = 1; i <= N; i++)\n    {\n        current_root = i;\n        DFS(i);\n    }\n\n    int Q;\n    cin >> Q;\n    for(int i = 0; i < Q; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        cout << sum - max_cost[a][b] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\nlong long origin;\n\nvector<pair<long long , long long> >tree[4005];\n\nlong long memo[4005][4005];\n\nvector<pair<long long, pair<long long, long long> > >fvec;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n\t  // 最初は全てのデータiがグループiに存在するものとして初期化\n\t  for(int i = 0; i < n; i++){\n\t\t  par[i] = i;\n\t  }\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n\nvoid prepare(){\n\tUnionFind uf(N + 1);\t\n\n\tset<long> done;\n\tlong long ans = 0;\n\tfor(int i = 0; i < fvec.size(); i++){\n\t\tlong long src = fvec[i].second.first;\n\t\tlong long dst = fvec[i].second.second;\n\t\tlong long cost = fvec[i].first;\n\t\tif(uf.same(src, dst) == false){\n\t\t\tuf.unite(src, dst);\n\t\t\ttree[src].push_back(make_pair(cost, dst));\n\t\t\ttree[dst].push_back(make_pair(cost, src));\n\t\t\torigin += cost;\n\t\t}\n\t\tif(uf.size(0) == N){\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid dfs(long long root, long long pa, long long cur, long long maxi){\n\t//cout << \" root \" << root << \" pa \" << pa << \" cur \" << cur << endl;\n\tmemo[root][cur] = maxi;\n\tfor(int i = 0; i < tree[cur].size(); i++){\n\t\tlong long cost = tree[cur][i].first;\n\t\tlong long next = tree[cur][i].second;\n\t\tif(pa != next){\n\t\t\tdfs(root, cur, next, max(maxi, cost));\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\tfvec.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(fvec.begin(), fvec.end());\n\n\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tprepare();\n\tfor(int i = 0; i < N; i++){\n\t\tdfs(i, -1, i, 0);\n\t}\n\t/*\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tcout << i << \" -> \" << j << \":\" << memo[i][j] << endl;\n\t\t}\n\t}\n\t*/\n\n\tfor(int i = 0; i < Q; i++){\n\t\tcout << origin - memo[S[i]][T[i]] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst int MOD = 1000000007;\n\nstruct UnionFind {\n  vector<int> par, s;\n  UnionFind(int n=2e5) { init(n); }\n  void init(int n) { \n    s.assign(n, 1); par.resize(n); \n    iota(par.begin(), par.end(), 0);\n  }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return s[find(x)]; }\n};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll n, m;\n  cin >> n >> m;\n  auto e = make_v<ll>(m, 3);\n  REP(i, m) {\n    cin >> e[i][1] >> e[i][2] >> e[i][0];\n    e[i][1]--, e[i][2]--;\n  }\n\n  ll sum = 0;\n  UnionFind uf(n);\n  vector<vector<PII>> g(n);\n  sort(ALL(e));\n  REP(i, m) {\n    if(uf.same(e[i][1], e[i][2])) continue;\n    uf.unite(e[i][1], e[i][2]);\n    g[e[i][1]].push_back({e[i][2], e[i][0]});\n    g[e[i][2]].push_back({e[i][1], e[i][0]});\n    sum += e[i][0];\n  }\n\n  auto d = make_v<ll>(n, n);\n  fill_v(d, 0);\n  function<void(ll,ll,ll,ll)> dfs = [&](ll v, ll p, ll s, ll dist) {\n    d[s][v] = dist;\n    ll ret = 0;\n    for(auto to: g[v]) {\n      if(to.first == p) continue;\n      dfs(to.first, v, s, max(dist,to.second));\n    }\n  };\n  REP(i, n) dfs(i, -1, i, 0);\n\n  // REP(i, n) cout << d[i] << endl;\n\n  ll q;\n  cin >> q;\n  REP(i, q) {\n    ll s, t;\n    cin >> s >> t;\n    s--, t--;\n    cout << sum - d[s][t] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass Graph2d {\npublic:\n    typedef ll numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nvoid warshall_floyd(Graph2d& g) {\n    int i, j, k;\n    for (i = 0; i < g.n; i++) {\n        for (j = 0; j < g.n; j++) {\n            for (k = 0; k < g.n; k++) {\n                g(j, k) = min(g(j, k), g(j, i) + g(i, k));\n            }\n        }\n    }\n}\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nvector<vector<ll>> edges;\nll answer[4040][4040];\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    vector<int> cycle_detector(n);\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer[start][idx] = total - wmax;\n        answer[idx][start] = total - wmax;\n        assert(!cycle_detector[idx]);\n        cycle_detector[idx] = 1;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        fill(ALL(cycle_detector), 0);\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    graph_mat.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n\n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        printer << answer[u][v] << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n    Edge(int f, int t, int c) : from(f), to(t), cost(c) {}\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nconst int MAXN = 4010;\nstruct UnionFind {\n    int node[MAXN];\n    UnionFind() {\n        memset(node, -1, sizeof(node));\n    }\n    int find(int x) {\n        return node[x] < 0 ? x : node[x] = find(node[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        node[x] += node[y];\n        node[y] = x;\n        return true;\n    }\n};\n\nusing Graph = vector< vector<Edge> >;\nint max_edge[MAXN][MAXN];\n\nvoid dfs(Graph &G, int cur, int par, int orig) {\n    int prev_max = max_edge[orig][cur];\n    for(auto e : G[cur]) {\n        if(e.to == par) continue;\n        chmax(max_edge[orig][e.to], max(prev_max, e.cost));\n        dfs(G, e.to, cur, orig);\n    }\n}\n \nUnionFind uf;\nsigned main() {\n    int N, M; cin >> N >> M;\n    \n    vector<Edge> edges;\n    for(int i=0; i<M; i++) {\n        int u, v, cost; cin >> u >> v >> cost;\n        u--; v--;\n        edges.emplace_back(u, v, cost);\n    }\n    sort(edges.begin(), edges.end());\n\n    int sum = 0;\n    Graph MST(N);\n    for(int i=0; i<M; i++) {\n        Edge e = edges[i];\n        if(uf.unite(e.from, e.to)) {\n            MST[e.from].emplace_back(e.from, e.to  , e.cost);\n            MST[e.to  ].emplace_back(e.to,   e.from, e.cost);\n            sum += e.cost;\n        }\n    }\n\n    for(int i=0; i<N; i++) dfs(MST, i, -1, i);\n\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            printf(\"max_edge[%lld][%lld] = %lld\\n\", i+1, j+1, max_edge[i][j]);\n        }\n    }\n    */\n\n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        // printf(\"max_edge = %lld\\n\", max_edge[s][t]);\n        cout << sum - max_edge[s][t] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\nconst ll MOD=1000000007;\nconst ll INF=1000000010;\nconst ll LINF=4000000000000000010LL;\nconst int MAX=310;\nconst double EPS=1e-9;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> par;\n    vector<int> dep;\n    \n    UnionFind(int siz){\n        par.assign(siz,0);\n        dep.assign(siz,0);\n        for(int i=0;i<siz;i++){\n            par[i]=i;\n        }\n    };\n\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x]=find(par[x]);\n        }\n    }\n\n    void unite(int x,int y){\n        x=find(x);\n        y=find(y);\n        if(x==y){\n            return;\n        }\n        if(dep[x]<dep[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(dep[x]==dep[y]){\n                dep[x]++;\n            }\n        }\n    }\n\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\nstruct edge{int from,to;ll cost;};\n\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost<e2.cost;\n}\n\nstruct edge2{int to;ll cost;};\nvector<edge2> G[4010];\n\nedge es[400010];\nll s[4010][4010];\nvoid dfs(int now,int p,int st,ll ma){\n\tfor(auto e:G[now]){\n\t\tif(e.to==p)continue;\n\t\ts[st][e.to]=max(ma,e.cost);\n\t\tdfs(e.to,now,st,max(ma,e.cost));\n\t}\n}\n\t\nint main(){\n\tint n,m,q;cin>>n>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;cin>>a>>b>>c;a--;b--;\n\t\tes[i]={a,b,c};\n\t}\n\tsort(es,es+m,comp);\n\tUnionFind uf(n+1);\n\tll ans=0;\n\tfor(int i=0;i<m;i++){\n\t\tedge e=es[i];\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tG[e.from].push_back({e.to,e.cost});\n\t\t\tG[e.to].push_back({e.from,e.cost});\n\t\t\tans+=e.cost;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdfs(i,-1,i,0);\n\t}\n\tcin>>q;\n\twhile(q--){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tcout<<ans-s[a][b]<<endl;\n\t}\n\t\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[125252];             // グラフ\nint depth[125252];        // 根付き木の深さ\nint anc[125252][20];      // anc[i][k] := iの2^k個上の祖先\nint query[125252][20];\n \nint data[125252];\nint init(){\n  REP(i,125252)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n        // DEBUG(a);\n        // DEBUG(b);\n      }\n    }\n  }\n \n  queue<int> Q;\n \n  // 根付き木にする\n  // そしてダブリングの準備\n  REP(i,n) depth[i]=INF;\n  REP(i,n)REP(k,20) anc[i][k]=query[i][k]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      Q.push(to);\n      // ダブリング準備\n      anc[to][0] = pos;\n      query[to][0] = c;\n      int id = 1;\n      int cur = pos;\n      while(anc[cur][id-1]!=INF){\n        int next = anc[cur][id-1];\n        anc[to][id] = next;\n        query[to][id] = min(query[to][id-1], query[cur][id-1]);\n        cur = next;\n        ++id;\n      }\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n    // LCAを取る\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    // 同じ高さにズラす\n    int diff = depth[b]-depth[a];\n    int k = 0;\n    while(diff){\n      if(diff&1){\n        CHMIN(x,(ll)query[b][k]);\n        b = anc[b][k];\n      }\n      diff>>=1;\n      ++k;\n    }\n    k = 19;\n    while(k>=0){\n      if(anc[a][k]!=INF && anc[a][k]!=anc[b][k]){\n        CHMIN(x,(ll)query[a][k]);\n        CHMIN(x,(ll)query[b][k]);\n        a = anc[a][k];\n        b = anc[b][k];\n      }\n      --k;\n    }\n    int lca = a;\n    if(a!=b){\n      CHMIN(x,(ll)query[a][0]);\n      CHMIN(x,(ll)query[b][0]);\n      lca = anc[a][0];\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ull INF = ULLONG_MAX;\nconst ll MOD = 998244353;\n\ntypedef ll Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Graph> Prim(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tGraph T(n);\n\tWeight total = 0;\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-1, r, 0));\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif (visited[e.dst])\n\t\t\tcontinue;\n    if(e.src>=0){\n  \t\tT[e.src].push_back(e);\n      T[e.dst].push_back({e.dst,e.src,e.weight});\n    }\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tfor (Edge f:g[e.dst])\n\t\t\tif (!visited[f.dst])\n\t\t\t\tQ.push(f);\n\t}\n\treturn pair<Weight, Graph>(total, T);\n}\n\n\n\ninline int get_min2pow(int n) {\n\tint res = 1;\n\twhile (res < n)\n\t\tres *= 2;\n\treturn res;\n}\n\n///Segment Tree////////\n\ntemplate<typename T,T dval>\nstruct segtree {\n\tint N;\n\tvector<T> node;\n\t//例外値　ex)INF,0\n\tT default_value = dval;\n\tstatic inline T merge(const T& l, const T& r) {\n\t\t//RMQ\n\t\treturn max(l,r);\n\t\t//RSQ\n\t\t//return l+r;\n\t}\n\tsegtree(int n) {\n\t\tN = get_min2pow(n);\n\t\tnode.resize(2 * N, default_value);\n\t}\n\tsegtree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tN = get_min2pow(sz);\n\t\tnode.resize(2 * N, default_value);\n\t\tfor (int i = 0; i < sz; i++)\n\t\t\tnode[i + N - 1] = v[i];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t\tnode[i] = merge(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\t// update k th element\n\tvoid update(int k, T val) {\n\t\tk += N - 1; // leaf\n\t\tnode[k] = val;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l)\n\t\t\treturn default_value;\n\t\tif (a <= l and r <= b)\n\t\t\treturn node[k];\n\t\tint m = (l + r) / 2;\n\t\tT vl = query(a, b, k * 2 + 1, l, m);\n\t\tT vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn merge(vl, vr);\n\t}\n};\n\n\nstruct HLDecomposition{\n  int V;\n  vint dep,par,heavy,head,id,size,dat;\n  segtree<ll,0> RMQ;\n  HLDecomposition(const Graph &g,int root=0)\n  :V(g.size()),dep(V,0),par(V,-1),heavy(V,-1),head(V),id(V),size(V,1),dat(V,-1),RMQ(V){\n    //make par\n    par[root]=0;\n    queue<int> Q;\n    Q.push(root);\n    while(!Q.empty()){\n      int v=Q.front();\n      Q.pop();\n      for(const Edge &w:g[v])\n      if(par[w.dst]<0){\n        Q.push(w.dst);\n        par[w.dst]=v;\n        dat[w.dst]=w.weight;\n      }\n    }\n    par[root]=-1;\n    //calculate heavy\n    Q.push(root);\n    while(!Q.empty()){\n      int v=Q.front();\n      Q.pop();\n      for(const Edge &w:g[v]){\n        if(w.dst==par[v])continue;\n        dep[w.dst]=dep[v]+1;\n        Q.push(w.dst);\n      }\n    }\n    repeat(v,V){\n      if(par[v]<0)continue;\n      size[par[v]]+=size[v];\n      if(heavy[par[v]]<0||size[v]>size[heavy[par[v]]])heavy[par[v]]=v;\n    }\n    //calculate id\n    int idx=0;\n    repeat(v,V){\n      if(par[v]<0||heavy[par[v]]!=v){\n        for(int w=v;w!=-1;w=heavy[w]){\n          head[w]=v;\n          id[w]=idx++;\n          RMQ.update(id[w],dat[w]);\n        }\n      }\n    }\n  }\n  // [u,v]\n  ll query(int u,int v){\n    ll ret=0;\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]!=head[v]){\n        ret = max(ret,RMQ.query(id[head[v]]+1,id[v]+1));\n        v=par[head[v]];\n      }else{\n        if(u!=v)ret = max(ret,RMQ.query(id[u]+1,id[v]+1));\n        return ret;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]==head[v])return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\nint main(){\n  int N,M;cin>>N>>M;\n  Graph g(N);\n  repeat(i,M){\n    int a,b;\n    Weight c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back({a,b,c});\n    g[b].push_back({b,a,c});\n  }\n  pair<Weight, Graph> tree=Prim(g,0);\n  HLDecomposition hld(tree.second,0);\n  int Q;cin>>Q;\n  repeat(q,Q){\n    int s,t;cin>>s>>t;\n    s--;t--;\n    ll ans=tree.first-hld.query(s,t);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\nstruct edge{\n  Int from,to,cost,used;\n  edge(){}\n  edge(Int from,Int to,Int cost):from(from),to(to),cost(cost),used(0){}\n  bool operator<(const edge& e) const{\n    return cost<e.cost;\n  }\n};\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  void add_edge(Int u,Int v,Int c){\n    edges.push_back(edge(u,v,c));\n  }\n\n  void input(Int m,Int offset=0){\n    Int a,b,c;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      add_edge(a+offset,b+offset,c);\n    }\n  }\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\te.used=1;\n      }\n    }\n    return res;\n  }\n};\n\n\nstruct HLDecomposition {\n  Int n,pos;\n  vector<vector<Int> > G;\n  vector<Int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(Int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(Int u, Int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<Int> rs={0}) {\n    Int c=0;\n    for(Int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(Int rt) {\n    using T = pair<Int,int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      Int v=st.top().first;\n      Int &i=st.top().second;\n      if(i<(Int)G[v].size()){\n\tInt u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tInt res=0;\n\tfor(Int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(Int r,Int c) {\n    Int &k=pos;\n    queue<Int> q({r});\n    while(!q.empty()){\n      Int h=q.front();q.pop();\n      for(Int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(Int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  Int lca(Int u,Int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  Int distance(Int u,Int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  Int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(Int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(Int)v.size()) build(n_,v);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(Int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(Int a,Int b){\n    T vl=d1,vr=d1;\n    for(Int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\n\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  Kruskal k(n);\n  k.input(m,-1);\n  Int val=k.build();\n  auto es=k.edges;\n  es.erase(remove_if(es.begin(),es.end(),[](edge e){return !e.used;}),es.end());\n  //cout<<es.size()<<endl;\n  //for(auto e:es) cout<<e.used<<endl;\n  HLDecomposition hld(n);\n  for(auto e:es) hld.add_edge(e.from, e.to);\n  hld.build();\n  \n  SegmentTree<Int, Int> seg(n,\n\t\t\t    [](Int a,Int b){return max(a,b);},\n\t\t\t    [](Int a,Int b){return b;},\n\t\t\t    0);\n  for(auto e:es){\n    Int u=e.from,v=e.to,c=e.cost;\n    if(hld.dep[u]>hld.dep[v]) swap(u,v);\n    seg.update(hld.vid[v],c);\n  }\n  \n  Int q;\n  cin>>q;\n  //if(q>3000) exit(1);\n  for(Int i=0;i<q;i++){\n    Int s,t;\n    cin>>s>>t;\n    s--;t--;\n    Int x=0;\n    hld.for_each_edge(s,t,[&](Int l,Int r){\n\tx=max(x,seg.query(l,r+1));\n      });\n    cout<<val-x<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN -2147483648\n#define INF 100000000\n#define _INF -100000000\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef pair<int,int> P;\n\nclass Prim {\n\tstruct node {\n\t\tbool done;\n\t\tvi to, dist;\n\t\tint id, from;\n\t\tll d;\n\t\tint depth;\n\t\tbool operator<(const node & another) const {\n\t\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t\t}\n\t};\npublic:\n\tvector<node> nodes;\n\tint n;\n\tPrim(int N) {\n\t\tn = N;\n\t\tnodes.resize(n);\n\t}\n\tvoid mainfunc(){\n\t\tpriority_queue<node> pq;\n\t\tnodes[0].d = 0;\n\t\tpq.push(nodes[0]);\n\t\twhile (pq.size()) {\n\t\t\tnode focus = pq.top(); pq.pop();\n\t\t\tif (nodes[focus.id].done) continue;\n\t\t\tLoop(i, focus.to.size()) {\n\t\t\t\tint b = focus.to[i];\n\t\t\t\tif (!nodes[b].done && focus.dist[i] < nodes[b].d) {\n\t\t\t\t\tnodes[b].d = focus.dist[i];\n\t\t\t\t\tnodes[b].from = focus.id;\n\t\t\t\t\tnodes[b].depth = focus.depth + 1;\n\t\t\t\t\tpq.push(nodes[focus.to[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodes[focus.id].done = true;\n\t\t}\n\t\treturn;\n\t}\n\t//sとtをつなぐパスの中で最もコストの大きい辺のコストを返す\n\tll max_path_between(int s, int t) {\n\t\tll ret = 0;\n\t\twhile (nodes[s].depth > nodes[t].depth) {\n\t\t\tret = max(ret, nodes[s].d);\n\t\t\ts = nodes[s].from;\n\t\t}\n\t\twhile (nodes[s].depth < nodes[t].depth) {\n\t\t\tret = max(ret, nodes[t].d);\n\t\t\tt = nodes[t].from;\n\t\t}\n\t\twhile (s != t) {\n\t\t\tret = max(ret, max(nodes[s].d, nodes[t].d));\n\t\t\ts = nodes[s].from;\n\t\t\tt = nodes[t].from;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tPrim prim(n);\n\tLoop(i, n) prim.nodes[i] = { false,{},{}, i, -1, INFLL, 0 };\n\tLoop(i, m) {\n\t\tint s, t, d; cin >> s >> t >> d;\n\t\ts--; t--;\n\t\tprim.nodes[s].to.push_back(t);\n\t\tprim.nodes[s].dist.push_back(d);\n\t\tprim.nodes[t].to.push_back(s);\n\t\tprim.nodes[t].dist.push_back(d);\n\t}\n\tprim.mainfunc();\n\tll sum = 0;\n\tLoop(i, n) sum += prim.nodes[i].d;\n\tint q; cin >> q;\n\tLoop(i, q) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--; t--;\n\t\tcout << sum - prim.max_path_between(s, t) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nclass UnionFind {\npublic:\n  int n;\n  vi par; //親\n  vi ran; //木の深さ\n  vi num; //要素数\n\n  UnionFind(int _n) {\n    n = _n;\n    par.resize(n); ran.resize(n); num.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i; ran[i] = 0; num[i] = 1;\n    }\n  }\n\n  //木の根を求める\n  int find(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = find(par[x]);\n    }\n  }\n\n  //xとyの属する集合を併合\n  void unite(int x, int y) {\n    x = find(x); y = find(y);\n    int numsum = num[x] + num[y];\n    if (x == y) {\n      return;\n    }\n    if (ran[x]<ran[y]) {\n      par[x] = y;\n    }\n    else {\n      par[y] = x;\n      if (ran[x] == ran[y]) {\n        ran[x]++;\n      }\n    }\n    num[x] = num[y] = numsum;\n  }\n\n  //xとyが同じ集合に属するか否か\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n};\n\nvector< pair<ll, pll> > edges;\nconst int N = 4010;\nvector<vector<pll> > G(N), G2(N);\nbitset<N> used;\nvii max_c(N, vi(N));\n\nll kruskal(int n) {\n  sort(edges.begin(), edges.end());\n  UnionFind uf(n);\n  ll res = 0;\n  for (int i = 0; i < edges.size(); i++) {\n    if (!uf.same(edges[i].second.first, edges[i].second.second)) {\n      uf.unite(edges[i].second.first, edges[i].second.second);\n      res += edges[i].first;\n      int u = edges[i].second.first, v = edges[i].second.second;\n      ll c = edges[i].first;\n      G2[u].push_back(pll(c, v));\n      G2[v].push_back(pll(c, u));\n    }\n  }\n  return res;\n}\n\n\n\nvoid dfs(int s, int now, int ma) {\n  used[now] = true;\n  max_c[s][now] = ma;\n  rep (i, G2[now].size()) {\n    int v = G2[now][i].second;\n    if (used[v]) continue;\n    dfs(s, v, max(ma, (int)G2[now][i].first));\n  }\n}\n\n\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  rep (i, m) {\n    ll u, v, c;\n    cin >> u >> v >> c;\n    u--; v--;\n    G[u].push_back(pll(c, v));\n    G[v].push_back(pll(c, u));\n    edges.push_back({c, pll(u, v)});\n  }\n  sort(all(edges));\n  ll sum = kruskal(n);\n  rep (i, n) {\n    used.reset();\n    dfs(i, i, 0);\n  }\n  int q;\n  cin >> q;\n  while (q--) {\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum - max_c[s][t] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\n\nstruct uni {\n  vector<int> p;\n  uni(int n) :\n      p(n, -1) {}\n  int root(int a) {\n    return p[a] < 0 ? a : (p[a] = root(p[a]));\n  }\n  bool find(int a, int b) {\n    return root(a) == root(b);\n  }\n  bool merge(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return false;\n    p[a] = b;\n    return true;\n  }\n};\n\nstruct edge {\n  int f, t, c;\n  edge() {}\n  edge(int f, int t, int c) :\n      f(f), t(t), c(c) {}\n  bool operator<(const edge& e) const {\n    return c < e.c;\n  }\n};\n\nedge e[444444];\nvector<edge> g[4444];\nint res[4444][4444];\n\nint solve(int f, int t, int p) {\n  for (int i = 0; i < int(g[f].size()); i++) {\n    if (g[f][i].t == p) continue;\n    if (g[f][i].t == t) {\n      return g[f][i].c;\n    } else {\n      int r = solve(g[f][i].t, t, f);\n      if (r > 0) {\n        return max(g[f][i].c, r);\n      }\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  uni u(n);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &e[i].f, &e[i].t, &e[i].c);\n    --e[i].f;\n    --e[i].t;\n  }\n  sort(e, e+m);\n  long long c = 0;\n  for (int i = 0; i < m; i++) {\n    if (u.merge(e[i].f, e[i].t)) {\n      c += e[i].c;\n      g[e[i].f].push_back(edge(e[i].f, e[i].t, e[i].c));\n      g[e[i].t].push_back(edge(e[i].t, e[i].f, e[i].c));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      res[i][j] = res[j][i] = solve(i, j, -1);\n    }\n  }\n  int q; scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int s, t; scanf(\"%d%d\", &s, &t); --s; --t;\n    printf(\"%lld\\n\", c-res[s][t]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nstruct DisjointSet {\n\t// ２つのグループを１つにまとめる　と　2つの要素が同じグループに所属しているかどうかを判定する\n\tvector<int> rank, p, S; // p->parent  S[findSet(v)] ->連結成分の大きさ\n\tDisjointSet() {}\n\tDisjointSet(int size) {\n\t\tS.resize(size, 1);\n\t\trank.resize(size, 0);\n\t\tp.resize(size, 0);\n\t\trep(i, 0, size) makeSet(i);\n\t}\n\tvoid makeSet(int x) {\n\t\tp[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y) { // 判定する\n\t\treturn findSet(x) == findSet(y);\n\t}\n\tvoid unite(int x, int y) { // 連結するときにはこれを使う\n\t\tif (same(x, y))\n\t\t\treturn;\n\t\tlink(findSet(x), findSet(y));\n\t}\n\tvoid link(int x, int y) {\n\t\tif (rank[x] > rank[y]) {\n\t\t\tp[y] = x;\n\t\t}\n\t\telse {\n\t\t\tp[x] = y;\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\n\t\tS[x] = S[y] = S[x] + S[y];\n\t}\n\tint findSet(int x) {\n\t\tif (x != p[x]) {\n\t\t\tp[x] = findSet(p[x]); // path compression\n\t\t}\n\t\treturn p[x];\n\t}\n\tint connectedComponentSize(int x) { return S[findSet(x)]; }\n};\n\n\n\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<Edge> kruskal(int N, vector<Edge> &edges) {\n\tint totalCost = 0;\n\tsort(all(edges));\n\tDisjointSet dset(N);\n\tvector<Edge>mst;\n\trep(i, 0, edges.size()) {\n\t\tEdge e = edges[i];\n\t\tif (!dset.same(e.s, e.d)) {\n\t\t\tmst.push_back(e);\n\t\t\ttotalCost += e.w;\n\t\t\tdset.unite(e.s, e.d);\n\t\t}\n\t}\n\treturn mst;\n}\n\nstruct Tree { // rooted tree\n\tvector<vector<int>>parent,weight;\n\tGraph g;\n\tint root, V, log2_n;\n\tvector<int> depth;\n\tint get_depth(int x) { return depth[x]; }\n\tvoid dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\trep(i, 0, g[v].size()) {\n\t\t\tif (g[v][i].d != p) {\n\t\t\t\tweight[0][g[v][i].d] = g[v][i].w;\n\t\t\t\tdfs(g[v][i].d, v, d + 1);\n\t\t\t}\n\t\t}\n\t}\n\tTree(Graph G, int root)\n\t\t: root(root), V(G.size()), g(G), depth(V), log2_n(1 + (int)log2(V)) {\n\t\tparent.resize(log2_n, vector<int>(V));\n\t\tweight.resize(log2_n, vector<int>(V));\n\t\tdfs(root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\tif (parent[k][v] < 0) {\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t\tweight[k + 1][v] = max(weight[k][parent[k][v]], weight[k][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\tint w = -1;\n\t\tif (depth[u] > depth[v])\n\t\t\tswap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tchmax(w, weight[k][v]);\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)\n\t\t\treturn w;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tchmax(w, weight[k][u]);\n\t\t\t\tchmax(w, weight[k][v]);\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n};\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, M; cin >> N >> M;\n\tvector<Edge>edges;\n\trep(i, 0, M) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--, b--;\n\t\tedges.eb(a, b, c);\n\t}\n\tauto mst = kruskal(N,edges);\n\tint sum = 0;\n\tGraph g(N);\n\tfor (auto &e : mst) {\n\t\taddEdge(g, e.s, e.d, e.w);\n\t\tsum += e.w;\n\t}\n\tTree tree(g, 0);\n\n\tint Q; cin >> Q;\n\tloop(Q) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tint u = tree.lca(s, t);\n\t\tcout << sum - u << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "w#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\n\nstruct uni {\n  vector<int> p;\n  uni(int n) :\n      p(n, -1) {}\n  int root(int a) {\n    return p[a] < 0 ? a : (p[a] = root(p[a]));\n  }\n  bool find(int a, int b) {\n    return root(a) == root(b);\n  }\n  bool merge(int a, int b) {\n    a = root(a);\n    b = root(b);\n    if (a == b) return false;\n    p[a] = b;\n    return true;\n  }\n};\n\nstruct edge {\n  int f, t, c;\n  edge() {}\n  edge(int f, int t, int c) :\n      f(f), t(t), c(c) {}\n  bool operator<(const edge& e) const {\n    return c < e.c;\n  }\n};\n\nedge e[444444];\nvector<edge> g[4444];\nint res[4444][4444];\n\nvoid solve(int f, int v, int p, int c) {\n  res[f][v] = c;\n  for (int i = 0; i < int(g[v].size()); i++) {\n    if (g[v][i].t == p) continue;\n    solve(f, g[v][i].t, v, max(c, g[v][i].c));\n  }\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  uni u(n);\n  for (int i = 0; i < m; i++) {\n    scanf(\"%d%d%d\", &e[i].f, &e[i].t, &e[i].c);\n    --e[i].f;\n    --e[i].t;\n  }\n  sort(e, e+m);\n  long long c = 0;\n  for (int i = 0; i < m; i++) {\n    if (u.merge(e[i].f, e[i].t)) {\n      c += e[i].c;\n      g[e[i].f].push_back(edge(e[i].f, e[i].t, e[i].c));\n      g[e[i].t].push_back(edge(e[i].t, e[i].f, e[i].c));\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    solve(i, i, -1, 0);\n  }\n  int q; scanf(\"%d\", &q);\n  for (int i = 0; i < q; i++) {\n    int s, t; scanf(\"%d%d\", &s, &t); --s; --t;\n    printf(\"%lld\\n\", c-res[s][t]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[4010],rank[4010];\n\tvoid init(){\n\t\tfor(int i=0;i<4010;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\trank[y]++;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to;\n\tll cost;\n\tedge(){}\n\tedge(int from,int to,ll cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge &a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint N,M,Q;\nvector<edge> es;\nvector<edge> g[4010];\nint par[15][4010];\nll cost[15][4010];\nint depth[4010];\nvoid add_edge(edge e){\n\tg[e.from].pb(e);\n\tswap(e.from,e.to);\n\tg[e.from].pb(e);\n}\nvoid dfs(int v,int p,int c,int d){\n\tdepth[v]=d;\n\tpar[0][v]=p;\n\tcost[0][v]=c;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tedge e = g[v][i];\n\t\tif(e.to==p)continue;\n\t\tdfs(e.to,v,e.cost,d+1);\n\t}\n}\nll query(int u,int v){\n\t//cout << u << ' ' << v << endl;\n\tif(depth[u]>depth[v])swap(u,v);\n\tll res = 0ll;\n\tfor(int i=14;i>=0;i--){\n\t\tif(((depth[v]-depth[u])>>i)&1){\n\t\t\tres = max(res,cost[i][v]);\n\t\t\tv = par[i][v];\n\t\t}\n\t}\n\tif(u==v)return res;\n\tfor(int i=14;i>=0;i--){\n\t\tif(par[i][u]!=par[i][v]){\n\t\t\tres = max(res,cost[i][u]);\n\t\t\tres = max(res,cost[i][v]);\n\t\t\tu = par[i][u];\n\t\t\tv = par[i][v];\n\t\t}\n\t}\n\tres = max(res,cost[0][u]);\n\tres = max(res,cost[0][v]);\n\tassert(par[0][u]==par[0][v]);\n\treturn res;\n}\nint main(){\n\tcin >> N >> M;\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tll c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\tes.pb(edge(a,b,c));\n\t}\n\tsort(all(es));\n\tuf.init();\n\tll base = 0ll;\n\tfor(int i=0;i<es.size();i++){\n\t\tif(uf.same(es[i].from,es[i].to))continue;\n\t\tbase += es[i].cost;\n\t\tuf.unite(es[i].from,es[i].to);\n\t\t//cout << es[i].from << ' ' << es[i].to << ' ' << es[i].cost << endl;\n\t\tadd_edge(es[i]);\n\t}\n\tdfs(0,-1,-1,0);\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d %d %lld\\n\",i,par[0][i],cost[0][i]);\n\t}\n\tfor(int i=0;i<14;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(par[i][j]==-1){\n\t\t\t\tpar[i+1][j]=-1;\n\t\t\t\tcost[i+1][j]=cost[i][j];\n\t\t\t}else{\n\t\t\t\tpar[i+1][j]=par[i][par[i][j]];\n\t\t\t\tcost[i+1][j]=max(cost[i][j],cost[i][par[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> Q;\n\tfor(int i=0;i<Q;i++){\n\t\tint S,T;\n\t\tcin >> S >> T;\n\t\tS--;T--;\n\t\tcout << base-query(S,T) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, auto& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct QU {\n  V<> par, rank, _size;\n\n  QU(int n) { \n    par.resize(n);\n    iota(par.begin(), par.end(), 0);\n    rank.resize(n);\n    _size.assign(n, 1);\n  }\n\n  int find(int a) {\n    if (par[a] == a) return a;\n    return par[a] = find(par[a]);\n  }\n\n  bool same(int a, int b) { return find(a) == find(b); }\n\n  int size(int a) { return _size[find(a)]; }\n\n  void unite(int a, int b) {\n    a = find(a), b = find(b);\n    if (a == b) return;\n    if (rank[a] < rank[b]) {\n      par[a] = b;\n      _size[b] += _size[a];\n    } else {\n      par[b] = a;\n      _size[a] += _size[b];\n    }\n    if (rank[a] == rank[b]) rank[a]++;\n  }\n};\n\ntemplate<class T> struct edge { int id, from, to; T w; };\n\ntemplate<class T> T kruskal(V< edge<T> >& g, int n, V<bool>& used) {\n  T res = 0;\n  QU qu(n);\n  sort(g.begin(), g.end(), [](auto a, auto b) { return a.w < b.w; });\n  for (auto&& e : g) {\n    if (!qu.same(e.from, e.to)) {\n      qu.unite(e.from, e.to);\n      res += e.w;\n      used[e.id] = true;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V< edge<lint> > es(m);\n  for (int i = 0; i < m; i++) {\n    int a, b, c; cin >> a >> b >> c, a--, b--;\n    es[i] = {i, a, b, c};\n  }\n  V<bool> used(m);\n  lint sm = kruskal<lint>(es, n, used);\n  struct edge2 { int to; lint w; };\n  VV<edge2> g(n);\n  for (int i = 0; i < m; i++) if (used[es[i].id]) {\n    g[es[i].from].push_back({es[i].to, es[i].w});\n    g[es[i].to].push_back({es[i].from, es[i].w});\n  }\n  VV<lint> res; assign(res, n, n, -1e18);\n  for (int i = 0; i < n; i++) {\n    queue<int> q;\n    V<bool> vis(n);\n    vis[i] = true; q.push(i);\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      for (auto&& e : g[v]) if (!vis[e.to]) {\n        vis[e.to] = true;\n        res[i][e.to] = max(res[i][e.to], e.w);\n        q.push(e.to);\n      }\n    }\n  }\n  int q; cin >> q;\n  for (int iq = 0; iq < q; iq++) {\n    int s, t; cin >> s >> t, s--, t--;\n    cout << sm - res[s][t] << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<tuple<int, int, int>> es;\n  vector<vector<pair<int, int>>> G(N);\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es.emplace_back(c, a, b);\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es.begin(), es.end());\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  static int dist[4444][4444];\n  std::function<void(int, int, int, int)> dfs = [&](int curr, int par, int start, int max) {\n    dist[curr][start] = max;\n    for(auto const& e: G[curr]) {\n      if(e.first != par) dfs(e.first, curr, start, std::max(max, e.second));\n    }\n  };\n\n  rep(i, N) {\n    dfs(i, -1, i, 0);\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; scanf(\"%d%d\", &s, &t); s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vvi edge(m, vi(3));\n  rep (i, m) {\n    cin >> edge[i][1] >> edge[i][2] >> edge[i][0];\n    edge[i][1] -= 1; edge[i][2] -= 1;\n  }\n  sort(all(edge));\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  cost += edge[0][0];\n  uf.unite(edge[0][1], edge[0][2]);\n  maxcost[edge[0][1]][edge[0][2]] = maxcost[edge[0][2]][edge[0][1]] = edge[0][0];\n  FOR (i, 1, m) {\n    int x = edge[i][1];\n    int y = edge[i][2];\n    if (!(uf.same(x, y))) {\n      cost += edge[i][0];\n      for (int j = uf.root(x); j != -1; j = uf.next[j]) {\n        for (int k = uf.root(y); k != -1; k = uf.next[k]) {\n          maxcost[j][k] = maxcost[k][j] = edge[i][0];\n        }\n      }\n      uf.unite(x, y);\n    }\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N,M; cin >> N >> M;\n\tTree<treeOperator<ll>> tree(N);\n\tUnionFindTree uf(N);\n\tif(!N){\n\t\tint Q; cin >> Q;\n\t\tfor (int i = 0; i < Q; ++i) cout << 0 << endl;\n\t\treturn 0;\n\t}\n\tusing t = pair<ll,pair<int,int>>;\n\tpriority_queue<t,vector<t>,greater<>> pq;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tpq.push({c,{a,b}});\n\t}\n\tll sum = 0;\n\twhile (pq.size()) {\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\tint a = p.second.first;\n\t\tint b = p.second.second;\n\t\tint c = p.first;\n\t\tif(uf.same(a,b)) continue;\n\t\tsum += c;\n\t\tuf.unite(a, b);\n\t\ttree.makeEdge(a, b, c);\n\t\ttree.makeEdge(b, a, c);\n\t}\n\ttree.makeDepth();\n\ttree.makeParent();\n\ttree.makeAncestor();\n\tint Q; cin >> Q;\n\tvector<int> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint x, y; cin >> x >> y;\n\t\tx--, y--;\n\t\tans[i] = sum - tree.lca(x,y).second;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\nlong long hen;\n\n//           cost,   ,            src, dst\nvector<pair<long long, pair<long long, long long> > >vec;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n\t  // 最初は全てのデータiがグループiに存在するものとして初期化\n\t  for(int i = 0; i < n; i++){\n\t\t  par[i] = i;\n\t  }\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n\nvoid solve(int s, int t){\n\tUnionFind uf(N + 1);\t\n\tuf.unite(s, t);\n\n\tset<long> done;\n\tlong long ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tlong long src = vec[i].second.first;\n\t\tlong long dst = vec[i].second.second;\n\t\tlong long cost = vec[i].first;\n\t\tif(uf.same(src, dst) == false){\n\t\t\tuf.unite(src, dst);\n\t\t\tans += cost;\n\t\t}\n\t\tif(uf.size(s) == N){\n\t\t\tcout << ans << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\tvec.push_back(make_pair(c, make_pair(a, b)));\n\t}\n\n\tsort(vec.begin(), vec.end());\n\n\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 4000;\n\nstruct eda\n{\n    int to, cost;\n};\n\nvector<eda> G[MAX_N];\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz); rep(i,sz){ par[i] = i; nrank[i] = 0; } }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]){ par[x] = y; }else{ par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; } }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\ntemplate<typename T> class Kruskal{\npublic:\n\tstruct edge{\n\t\tint u,v;\n\t\tT cost;\n\t\tbool operator<(const edge& another) const {\n\t\t\treturn cost < another.cost;\n\t\t}\n\t};\n\tvector<edge> es;\n\tint V;\n    Kruskal(int node_size) : V(node_size){}\n\tvoid add_edge(int u,int v,T cost){\n\t\tes.push_back((edge){u,v,cost});\n\t}\n\tT solve(){\n\t\tUF uf(V);\n\t\tT res = 0;\n\t\tint cnt = 0;\n        sort(es.begin(),es.end());\n\t\trep(i,(int)es.size()){\n\t\t\tedge e = es[i];\n\t\t\tif(!uf.same(e.u,e.v)){\n                G[e.u].pb((eda){e.v,e.cost});\n                G[e.v].pb((eda){e.u,e.cost});\n\t\t\t\tuf.unite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t\tcnt++;\n\t\t\t\tif(cnt == V-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint mx[MAX_N][MAX_N];\n\nvoid dfs(const int st, int u, int p, int val)\n{\n    mx[st][u] = val;\n    each(e,G[u]){\n        if(e.to != p){\n            dfs(st, e.to, u, max(val, e.cost));\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    Kruskal<ll> kr(n);\n    rep(i,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        kr.add_edge(a-1,b-1,c);\n    }\n    ll ans = kr.solve();\n    rep(i,n){\n        dfs(i, i, -1, 0);\n    }\n    int q;\n    cin >> q;\n    rep(i,q){\n        int s,t;\n        cin >> s >> t;\n        cout << ans - mx[s-1][t-1] << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.assign(n, 1);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nstruct LCA {\n        const int LOGM = 30;\n        vector<int> depth;\n        vector<vector<int>> parent;\n        vector<pair<int, long long>> pare;\n        vector<vector<long long>> parmax;\n        LCA(int root, const vector<vector<int>> &g, const vector<pair<int, long long>> &pare) : pare(pare) {\n                int n = g.size();\n                depth.resize(n);\n                parent.resize(LOGM);\n                parmax.resize(LOGM);\n                for (int i = 0; i < LOGM; i ++) { \n                        parent[i].resize(n);\n                        parmax[i].resize(n);\n                }\n                function<void (int, int, int)> dfs = [&](int u, int prev, int d) {\n                        parent[0][u] = prev;\n                        parmax[0][u] = pare[u].second;\n                        depth[u] = d;\n                        for (auto v : g[u]) if (v != prev) dfs(v, u, d + 1);\n                };\n                dfs(root, -1, 0);\n                for (int k = 0; k < LOGM - 1; k ++) {\n                        for (int i = 0; i < n; i ++) {\n                                if (parent[k][i] < 0) { \n                                        parent[k + 1][i] = -1;\n                                } else { \n                                        parent[k + 1][i] = parent[k][parent[k][i]];\n                                        if (parent[k + 1][i] >= 0) {\n                                                parmax[k + 1][i] = max(parmax[k][i], parmax[k][parent[k][i]]);\n                                        }\n                                }\n                        }\n                }\n        }\n        int lca(int u, int v) { \n                if (depth[u] > depth[v]) swap(u, v);\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((depth[v] - depth[u]) >> k & 1) { \n                                v = parent[k][v];\n                        }\n                }\n                if (u == v) return u;\n                for (int k = LOGM - 1; k >= 0; k --) {\n                        if (parent[k][u] != parent[k][v]) {\n                                u = parent[k][u];\n                                v = parent[k][v];\n                        }\n                }\n                return parent[0][u];\n        }\n        long long get(int a, int l) {\n                long long res = 0;\n                int d = depth[a] - depth[l];\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((d >> k) & 1) {\n                                res = max(res, parmax[k][a]);\n                                a = parent[k][a];\n                        }\n                }\n                return res;\n        }\n        int dist(int u, int v) {\n                return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n        }\n};\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<pair<int, pair<int, int>>> es;\n        for (int i = 0; i < m; i ++) {\n                int a, b, c;\n                scanf(\"%d%d%d\", &a, &b, &c);\n                a --, b --;\n                es.push_back({c, {a, b}});\n        }\n        sort(es.begin(), es.end());\n        vector<pair<int, pair<int, int>>> use;\n        UnionFind uf(n);\n        long long tot = 0;\n        for (int i = 0; i < (int) es.size(); i ++) {\n                int a, b;\n                tie(a, b) = es[i].second;\n                if (uf.same(a, b)) continue;\n                uf.unite(a, b);\n                use.push_back(es[i]);\n                tot += es[i].first;\n        }\n        assert((int) use.size() == n - 1);\n        vector<vector<pair<int, int>>> g(n);\n        vector<vector<int>> gg(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int c = use[i].first;\n                int a = use[i].second.first;\n                int b = use[i].second.second;\n                g[a].push_back({b, c});\n                g[b].push_back({a, c});\n                gg[a].push_back(b);\n                gg[b].push_back(a);\n        }\n        vector<pair<int, long long>> pare(n);\n        function<void (int, int)> get_pare = [&](int u, int prev) {\n                for (auto e : g[u]) if (e.first != prev) {\n                        pare[e.first] = { u, e.second };\n                        get_pare(e.first, u);\n                }\n        };\n        get_pare(0, -1);\n        LCA lca(0, gg, pare);\n        int q;\n        scanf(\"%d\", &q);\n        while (q --) {\n                int s, t;\n                scanf(\"%d%d\", &s, &t);\n                s --, t --;\n                int l = lca.lca(s, t);\n                int maxval = max(lca.get(s, l), lca.get(t, l));\n                printf(\"%lld\\n\", tot - maxval);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//「何らかの全域木からS--Tパス上の辺を取り除いたもの」を考えればよく、実は「MST - (S--Tパス上の最大コストの辺)」が答えになりそう。\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct UF {\n\tint par[4000];\n\tUF() { for (int i = 0; i < 4000; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; par[x] = root(par[x]); }\n\tvoid unit(int x, int y) { par[root(x)] = root(y); }\n\tbool isSame(int x, int y) { return root(x) == root(y); }\n};\n\nstruct Edge {\n\tint from, to, cost;\n\tEdge(int from, int to, int cost) { this->from = from; this->to = to; this->cost = cost; }\n\tEdge() {}\n\tbool operator<(const Edge &r) const { return cost < r.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint n, m, q;\nEdges edges;\nUF uf;\nGraph mst;\nint parents[20][4000];\nint depth[4000];\nint maxScores[20][4000];\n\nvoid dfs(int p, int v, int ecost, int dep) {\n\tparents[0][v] = p;\n\tdepth[v] = dep;\n\tmaxScores[0][v] = ecost;\n\t\n\tfor (int i = 0; i < mst[v].size(); i++) {\n\t\tint nv = mst[v][i].to;\n\t\tif (nv == p) continue;\n\t\tdfs(v, nv, mst[v][i].cost, dep + 1);\n\t}\n}\n\nint maxPath(int u, int v) {\n\tint ret = 0, i;\n\t\n\tif (depth[u] > depth[v]) swap(u, v);\n\tif (depth[v] > depth[u]) {\n\t\tint d = depth[v] - depth[u];\n\t\tfor (i = 0; i < 20; i++) {\n\t\t\tif ((d >> i) & 1) {\n\t\t\t\tret = max(ret, maxScores[i][v]);\n\t\t\t\tv = parents[i][v];\n\t\t\t}\n\t\t}\n\t}\n\tif (u == v) { return ret; }\n\tif (parents[0][u] == parents[0][v]) {\n\t\tint res = max(maxScores[0][u], maxScores[0][v]);\n\t\treturn max(ret, res);\n\t}\n\t\n\tfor (i = 19; i > 0; i--) {\n\t\tif (parents[i][u] != parents[i][v]) break;\n\t}\n\tint res1 = maxPath(parents[i][u], parents[i][v]);\n\tint res2 = max(maxScores[i][u], maxScores[i][v]);\n\tint res = max(res1, res2);\n\treturn max(ret, res);\n}\n\nint main() {\n\tint i, j;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedges.push_back(Edge(a, b, c));\n\t}\n\tsort(edges.begin(), edges.end());\n\t\n\tint mstCost = 0;\n\tmst.resize(n);\n\tfor (i = 0; i < edges.size(); i++) {\n\t\tint u = edges[i].from;\n\t\tint v = edges[i].to;\n\t\t\n\t\tif (!uf.isSame(u, v)) {\n\t\t\tuf.unit(u, v);\n\t\t\tmstCost += edges[i].cost;\n\t\t\tmst[u].push_back(Edge(u, v, edges[i].cost));\n\t\t\tmst[v].push_back(Edge(v, u, edges[i].cost));\n\t\t}\n\t}\n\t\n\tdfs(0, 0, 0, 0);\n\tfor (i = 1; i < 20; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tparents[i][j] = parents[i - 1][parents[i - 1][j]];\n\t\t\tmaxScores[i][j] = max(maxScores[i - 1][j], maxScores[i - 1][parents[i - 1][j]]);\n\t\t}\n\t}\n\t\n\tcin >> q;\n\tfor (i = 0; i < q; i++) {\n\t\tint s, t;\n\t\tcin >> s >> t; s--; t--;\n\t\tif (n <= 2) { cout << 0 << endl; continue; }\n\t\tint res = maxPath(s, t);\n\t\tcout << mstCost - res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r1) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r1, 0) );\n  //Q.push( Edge(-1, r2, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\tGraph g(N);\n\tfor(;M--;){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\tg[b-1].emplace_back(b-1,a-1,c);\n\t}\n\tscanf(\"%d\",&Q);\n\tif(Q>1)return 1;\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a-1].emplace_back(a-1,b-1,0);\n\t\tprintf(\"%d\\n\",minimumSpanningTree(g,a-1).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum;\n\t};\n\tvector<node> dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p == u) return u;\n\t\tdsu[u].p = rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tvoid merge(int u, int v)\n\t{\n\t\tu = rt(u); v = rt(v);\n\t\tif(u == v) return ;\n\t\tif(rand()&1) swap(u, v);\n\t\tdsu[v].p = u;\n\t\tdsu[u].sum += dsu[v].sum;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) == rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\nstruct Tree\n{\n\tstruct data\n\t{\n\t\tll w;\n\t};\n\t\n\tstruct node\n\t{\n\t\tint p; //parent\n\t\tll w; //modify for different problems\n\t};\n\t\n\tstruct edge\n\t{\n\t\tint v; data dat;\n\t};\n\t\n\tvector<vector<edge> > adj;\n\tint n;\n\t\n\tTree(int _n)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvi level;\n\tvi depth;\n\tvi h;\n\tvi euler;\n\tvi firstocc;\n\tvector<vi> rmqtable;\n\tvi subsize;\n\tvi start; vi en;\n\tvector<vector<node> > st;\n\t\n\tvoid addedge(int u, int v, int w)\n\t{\n\t\tedge tmp; tmp.v = v; tmp.dat.w = w;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset(int _n)\n\t{\n\t\tadj.clear();\n\t\tlevel.clear();\n\t\tdepth.clear();\n\t\teuler.clear();\n\t\trmqtable.clear();\n\t\tsubsize.clear();\n\t\tstart.clear();\n\t\ten.clear();\n\t\tst.clear();\n\t\tfirstocc.clear();\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid dfssub(int u, int p)\n\t{\n\t\tsubsize[u] = 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfssub(v, u);\n\t\t\tsubsize[u] += subsize[v];\n\t\t}\n\t}\n\t\n\tvoid calcsub()\n\t{\n\t\tsubsize.resize(n);\n\t\tdfssub(0, -1);\n\t}\n\t\n\tint timer;\n\t\n\tvoid dfsstartend(int u, int p)\n\t{\n\t\tstart[u] = ++timer;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tdfsstartend(v, u);\n\t\t}\n\t\ten[u] = ++timer;\n\t}\n\t\n\tvoid calcstartend()\n\t{\n\t\ttimer = 0;\n\t\tstart.resize(n); en.resize(n); h.resize(n);\n\t\tdfsstartend(0, -1);\n\t}\n\t\n\tint eulercnt;\n\t\n\tvoid dfseuler(int u, int p)\n\t{\n\t\teuler[eulercnt] = u; eulercnt++;\n\t\tif(p == -1) {depth[u] = 0;}\n\t\telse {depth[u] = depth[p] + 1;}\n\t\tfirstocc[u] = eulercnt-1;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue ;\n\t\t\tdfseuler(v, u);\n\t\t\teuler[eulercnt] = u; eulercnt++;\n\t\t}\n\t}\n\t\n\tvoid calceuler()\n\t{\n\t\teulercnt = 0;\n\t\tlevel.assign(2*n+1, 0);\n\t\teuler.assign(2*n+1, 0);\n\t\tdepth.assign(n, 0);\n\t\tfirstocc.resize(n);\n\t\tdfseuler(0, -1);\n\t}\n\n\tvoid filllevel()\n\t{\n\t\tint LG = 0;\n\t\twhile((1<<LG) <= n*2) LG++;\n\t\trmqtable.resize(LG);\n\t\tfor(int i = 0; i < LG; i++) rmqtable[i].resize(eulercnt);\n\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t{\n\t\t\tlevel[i] = depth[euler[i]];\n\t\t}\n\t\tlevel[eulercnt] = 1000000000;\n\t\tfor(int j = 0; j < LG; j++)\n\t\t{\n\t\t\tfor(int i = 0; i < eulercnt; i++)\n\t\t\t{\n\t\t\t\trmqtable[j][i] = eulercnt;\n\t\t\t\tif(i + (1<<j) - 1 < eulercnt)\n\t\t\t\t{\n\t\t\t\t\tif(j == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trmqtable[j][i] = i;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(level[rmqtable[j - 1][i]] < level[rmqtable[j-1][i + (1<<(j-1))]])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trmqtable[j][i] = rmqtable[j-1][i + (1<<(j-1))];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint rmq(int l, int r)\n\t{\n\t\tint k = 31 - __builtin_clz(r-l);\n\t\t//cout << l << ' ' << r << ' ' << rmqtable[l][k] << ' ' << rmqtable[r - (1<<k) + 1][k] << endl;\n\t\tif(level[rmqtable[k][l]] < level[rmqtable[k][r - (1<<k) + 1]])\n\t\t{\n\t\t\treturn rmqtable[k][l];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn rmqtable[k][r - (1<<k) + 1];\n\t\t}\n\t}\n\n\tint lcaeuler(int u, int v)\n\t{\n\t\tif(firstocc[u] > firstocc[v]) swap(u, v);\n\t\t//cerr << firstocc[u] << ' ' << firstocc[v] << ' ' << rmq(firstocc[u], firstocc[v]) << ' ' << euler[rmq(firstocc[u], firstocc[v])] << endl;\n\t\treturn euler[rmq(firstocc[u], firstocc[v])];\n\t}\n\t\n\tbool insub(int u, int v) //is u in the subtree of v?\n\t{\n\t\tif(start[v] <= start[u] && en[u] <= en[v]) return true;\n\t\treturn false;\n\t}\n\t\n\tvoid dfspar(int u, int p)\n\t{\n\t\t//cerr << u << ' ' << p << '\\n';\n\t\tst[0][u].p = p;\n\t\tif(p == -1) h[u] = 0;\n\t\telse h[u] = h[p] + 1;\n\t\tif(p==-1) st[0][u].w = 0;\n\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t{\n\t\t\tint v = adj[u][i].v;\n\t\t\tif(v == p) continue;\n\t\t\tst[0][v].w = adj[u][i].dat.w;\n\t\t\t//cerr<<\"DATA : \"<<st[0][v].w<<'\\n';\n\t\t\tdfspar(v, u);\n\t\t}\n\t}\n\t\n\tint LOG;\n\t\n\tvoid calcpar()\n\t{\n\t\th.resize(n);\n\t\tint LG = 0; LOG = 0;\n\t\twhile((1<<LG) <= n) {LG++; LOG++;}\n\t\tst.resize(LG);\n\t\tfor(int i = 0; i < LG; i++)\n\t\t{\n\t\t\tst[i].resize(n);\n\t\t}\n\t\tdfspar(0, -1);\n\t\t//cerr << \"HER\" << ' ' << LG << endl;\n\t\tfor(int i = 1; i < LG; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tst[i][j].w = max(st[i-1][j].w,st[i-1][st[i-1][j].p].w);\n\t\t\t\tif(st[i-1][j].p == -1) st[i][j].p = -1;\n\t\t\t\telse st[i][j].p = st[i-1][st[i-1][j].p].p;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint getpar(int u, ll k)\n\t{\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(k&(1<<i))\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t}\n\t\t}\n\t\treturn u;\n\t}\n\t\n\tint lca(int u, int v)\n\t{\n\t\tif(h[u] > h[v]) swap(u, v);\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && h[st[i][v].p] >= h[u])\n\t\t\t{\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\tif(u == v) return u;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && st[i][v].p != st[i][u].p)\n\t\t\t{\n\t\t\t\tu = st[i][u].p;\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\treturn st[0][u].p;\n\t}\n\n\tint distance(int u, int v)\n\t{\n\t\tint lc = lca(u, v);\n\t\treturn (h[u]+h[v]-2*h[lc]);\n\t}\n\t\n\tll maxpath(int u, int v)\n\t{\n\t\tif(h[u] > h[v]) swap(u, v);\n\t\tll ans = 0;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && h[st[i][v].p] >= h[u])\n\t\t\t{\n\t\t\t\tans = max(st[i][v].w,ans);\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\t//cerr<<\"ANSWER : \"<<ans<<'\\n';\n\t\tif(u == v) return ans;\n\t\tfor(int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tif(st[i][v].p != -1 && st[i][v].p != st[i][u].p)\n\t\t\t{\n\t\t\t\tans = max(st[i][v].w,ans);\n\t\t\t\tans = max(st[i][u].w,ans);\n\t\t\t\tu = st[i][u].p;\n\t\t\t\tv = st[i][v].p;\n\t\t\t}\n\t\t}\n\t\treturn max(ans,max(st[0][v].w,st[0][u].w));\n\t}\n};\n\nTree t(100001);\n\nstruct Graph\n{\n\tstruct edge\n\t{\n\t\tint v; ll weight;\n\t};\n\tvector<vector<edge> > adj;\n\tint n;\n\t\n\tGraph(int _n)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid addedge(int u, int v, ll c)\n\t{\n\t\tedge tmp;\n\t\ttmp.v = v; tmp.weight = c;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset()\n\t{\n\t\tadj.clear();\n\t}\n\t\n\tvi dist;\n\tvi par;\n\t\n\tvoid bfs(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tqueue<int> q; q.push(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid bfs01(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tdeque<int> q; q.pb(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop_front();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tif(w == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u];\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_front(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tpriority_queue<ii, vector<ii>, greater<ii> > pq;\n\t\tpq.push(ii(0, s));\n\t\twhile(!pq.empty())\n\t\t{\n\t\t\tint u = pq.top().se; ll d = pq.top().fi; pq.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(d + w < dist[v])\n\t\t\t\t{\n\t\t\t\t\tdist[v] = d + w;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tpq.push(ii(dist[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<ll> > d;\n\t\n\tvoid Floyd()\n\t{\n\t\tll INFIN = ll(1e18);\n\t\td.resize(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\td[i].assign(n, INFIN);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\td[i][adj[i][j].v] = adj[i][j].weight;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor(int k = 0; k < n; k++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool BellmanFord(int s) //returns true if negative weight cycle exists\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0;\n\t\tfor(int step = 1; step <= n; step++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\t\tif(dist[v] > dist[u] + w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(step == n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist[v] = dist[u] + w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tll shortest(int s, int e) //returns the distance by Dijkstra\n\t{\n\t\treturn dist[e];\n\t}\n\t\n\tvector<pair<ll, ii> > edges;\n\t\n\tll Kruskal()\n\t{\n\t\tDSU dsu(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\tedges.pb(mp(w, mp(u, v)));\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tll ans = 0; int cnt = 0;\n\t\tfor(int i = 0; i < edges.size(); i++)\n\t\t{\n\t\t\tint u = edges[i].se.fi; int v = edges[i].se.se;\n\t\t\tif(dsu.sameset(u, v)) continue;\n\t\t\tdsu.merge(u, v);\n\t\t\tt.addedge(u,v,edges[i].fi);\n\t\t\tcnt++; ans += edges[i].fi;\n\t\t\tif(cnt >= n - 1) break;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nvector<pair<ii,int> > edges;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m;\n\tcin>>n>>m;\n\tGraph G(n);\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u, v, c;\n\t\tcin>>u>>v>>c;\n\t\tu--; v--;\n\t\tedges.pb(mp(mp(u,v),c));\n\t\tG.addedge(u,v,c);\n\t}\n\tll ans = G.Kruskal();\n\t//cerr<<ans<<'\\n';\n\tt.calcpar();\n\tint q; cin>>q;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tcout<<ans-t.maxpath(u,v)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass Graph2d {\npublic:\n    typedef ll numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nvoid warshall_floyd(Graph2d& g) {\n    int i, j, k;\n    for (i = 0; i < g.n; i++) {\n        for (j = 0; j < g.n; j++) {\n            for (k = 0; k < g.n; k++) {\n                g(j, k) = min(g(j, k), g(j, i) + g(i, k));\n            }\n        }\n    }\n}\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nvector<vector<ll>> edges;\nunordered_map<ll,ll> ans;\n\ninline ll& answer(ll x, ll y) { return x > y ? answer(y, x) : ans[(x << 16) | y]; }\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer(start,idx) = total - wmax;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    graph_mat.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n\n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        printer << answer(u, v) << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\n//Union Find Tree\nclass UnionFindTree {\npublic:\n\tvector<int> parent;\n    vector<int> rank;\n\n    UnionFindTree(int N) : parent(N), rank(N,0){\n\t\tfor (int i = 0; i < N; ++i) parent[i] = i;\n\t}\n \n\tint root(int n) {\n\t\treturn (parent[n] == n ? n : parent[n] = root(parent[n]));\n\t}\n\n    int same(int n, int m) {\n\t\treturn root(n) == root(m);\n\t}\n \n\tvoid unite(int n, int m) {\n\t\tn = root(n);\n\t\tm = root(m);\n\t\tif (n == m) return;\n\t\tif(rank[n]<rank[m]) {\n            parent[n] = m;\n        }\n        else{\n            parent[m] = n;\n            if(rank[n] == rank[m]) rank[n]++;\n        }\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc097/tasks/arc097_b\n\ntemplate<class Operator> class Tree {\n\tOperator Op;                            \n\tusing typeDist = decltype(Op.unitDist); \n\tsize_t num;\n\tsize_t ord;\npublic:\n\tvector<vector<pair<size_t,typeDist>>> edge;\n\tvector<size_t> depth;\n\tvector<size_t> order;\n\tvector<typeDist> dist;\n\tvector<pair<size_t,typeDist>> parent;\n\tvector<vector<pair<size_t,typeDist>>> child;\n\tvector<array<pair<size_t,typeDist>,Operator::bit>> ancestor;\n\tvector<size_t> size;\n\tTree(const int num):num(num),edge(num),depth(num,-1),order(num),dist(num){}\n\t//O(1) anytime\n\tvoid makeEdge(const int& from, const int& to, const typeDist w = 1) {\n\t\tedge[from].push_back({to,w});\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(const int root) {\n\t\tdepth[root] = 0;\n\t\tdist[root] = Op.unitDist;\n\t\tord = 0;\n\t\tdfs1(root);\n\t\torder[ord++] = root;\n\t}\n\t//O(N) anytime\n\tvoid makeDepth(void) {\n\t\tord = 0;\n\t\tfor(size_t root = 0; root < num; ++root) {\n\t\t\tif(depth[root] != -1) continue;\n\t\t\tdepth[root] = 0;\n\t\t\tdist[root] = Op.unitDist;\n\t\t\tdfs1(root);\n\t\t\torder[ord++] = root;\n\t\t}\n\t}\n\t//for makeDepth\n\tvoid dfs1(int curr, int prev = -1){\n\t\tfor(auto& e:edge[curr]){\n\t\t\tint next = e.first;\n\t\t\tif(next==prev) continue;\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tdist[next]  = Op.funcDist(dist[curr],e.second);\n\t\t\tdfs1(next,curr);\n\t\t\torder[ord++] = next;\n\t\t}\n\t}\n\t//O(N) after makeDepth\n\tvoid makeParent(void) {\n\t\tparent.resize(num,make_pair(num,Op.unitDist));\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] > depth[e.first]) parent[i] = e;\n\t}\n\t//O(N) after makeDepth\n\tvoid makeChild(void) {\n\t\tchild.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) for (auto& e : edge[i]) if (depth[i] < depth[e.first]) child[i].push_back(e);\n\t}\n\t//O(NlogN) after makeDepth and makeParent\n\tvoid makeAncestor(void) {\n\t\tancestor.resize(num);\n\t\tfor (size_t i = 0; i < num; ++i) ancestor[i][0] = (parent[i].first!=num?parent[i]:make_pair(i,Op.unitLca));\n\t\tfor (size_t j = 1; j < Operator::bit; ++j) {\n\t\t\tfor (size_t i = 0; i < num; ++i) {\n\t\t\t\tsize_t k = ancestor[i][j - 1].first;\n\t\t\t\tancestor[i][j] = Op.funcLca(ancestor[k][j - 1],ancestor[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\t//O(logN) after makeAncestor\n\t//return {lca,lca_dist} l and r must be connected\n\tpair<size_t,typeDist> lca(size_t l, size_t r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tauto ancl = make_pair(l,Op.unitLca);\n\t\tauto ancr = make_pair(r,Op.unitLca);\n\t\tfor (int j = 0; j < Operator::bit; ++j) {\n\t\t\tif (diff & (1 << j)) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t}\n\t\t}\n\t\tif(ancl.first==ancr.first) return ancl;\n\t\tfor (int j = Operator::bit - 1; 0 <= j; --j) {\n\t\t\tif(ancestor[ancl.first][j].first!=ancestor[ancr.first][j].first) {\n\t\t\t\tancl = Op.funcLca(ancestor[ancl.first][j],ancl);\n\t\t\t\tancr = Op.funcLca(ancestor[ancr.first][j],ancr);\n\t\t\t}\n\t\t}\n\t\tancl = Op.funcLca(ancestor[ancl.first][0],ancl);\n\t\tancr = Op.funcLca(ancestor[ancr.first][0],ancr);\n\t\treturn Op.funcLca(ancl,ancr);\n\t}\n\t//O(N) anytime\n\tint diameter(void){\n\t\tmakeDepth(0);\n\t\tint tmp = max_element(depth.begin(), depth.end()) - depth.begin();\n\t\tmakeDepth(tmp);\n\t\treturn *max_element(depth.begin(), depth.end());\n\t}\n};\ntemplate<class typeDist> struct treeOperator{\n\tstatic const size_t bit = 20;\n\ttypeDist unitDist = 0;\n\ttypeDist unitLca = 0;\n\ttypeDist funcDist(const typeDist& parent,const typeDist& w){return parent+w;}\n\tpair<size_t,typeDist> funcLca(const pair<size_t,typeDist>& l,const pair<size_t,typeDist>& r){return make_pair(l.first,max(l.second,r.second));}\n};\n \n//depth,dist\n//https://atcoder.jp/contests/abc126/tasks/abc126_d\n//child\n//https://atcoder.jp/contests/abc133/tasks/abc133_e\n//lca\n//https://atcoder.jp/contests/abc014/tasks/abc014_4\n//weighted lca\n//diameter\n//https://atcoder.jp/contests/agc033/tasks/agc033_c\n//eulerTour\n//https://yukicoder.me/problems/no/900\n\n// Tree<treeOperator<int>> tree(N);\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tUnionFindTree uf(N);\n\tvector<int> a(M), b(M);\n\tvector<ll> c(M);\n\tvector<pair<ll, int>> ord(M);\n\tfor(int i = 0; i < M; ++i){\n\t\tcin >> a[i] >> b[i] >> c[i];\n\t\ta[i]--, b[i]--;\n\t\tord[i] = { c[i],i };\n\t}\n\tsort(ALL(ord));\n \n\tTree<treeOperator<ll>> tree(N);\n\tll sum = 0;\n\tfor (int i = 0; i < M; ++i){\n\t\tint j = ord[i].second;\n\t\tif (uf.same(a[j], b[j])) {\n\t\t\ta[j] = b[j] = -1;\n\t\t}\n\t\telse {\n\t\t\tuf.unite(a[j], b[j]);\n\t\t\tsum += c[j];\n\t\t\ttree.makeEdge(a[j], b[j], c[j]);\n\t\t\ttree.makeEdge(b[j], a[j], c[j]);\n\t\t}\n\t}\n\ttree.makeDepth(0);\n\tvector<vector<int>> edge(N, vector<int>(20,0));\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (a[i] == -1 || b[i] == -1) continue;\n\t\tif (tree.depth[a[i]] < tree.depth[b[i]]) swap(a[i], b[i]);\n\t\tedge[a[i]][0] = c[i];\n\t}\n \n\ttree.makeParent();\n\ttree.makeAncestor();\n\tfor (int bit = 1; bit < 20; ++bit) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tedge[i][bit] = max(edge[tree.ancestor[i][bit - 1].first][bit - 1], edge[i][bit - 1]);\n\t\t}\n\t}\n\tint Q; cin >> Q;\n\tvector<ll> ans(Q);\n\tfor(int i = 0; i < Q; ++i){\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tif (tree.depth[s] < tree.depth[t]) swap(s, t);\n\t\tauto lca = tree.lca(s, t);\n\t\tint u = lca.first;\n\t\tll w = lca.second;\n\t\tint ds = tree.depth[s] - tree.depth[u];\n\t\tint dt = tree.depth[t] - tree.depth[u];\n\t\tint es = 0;\n\t\tint et = 0;\n\t\tfor (int bit = 0; bit < 20; ++bit) if (ds & (1 << bit)) {\n\t\t\tes = max(es, edge[s][bit]);\n\t\t\ts = tree.ancestor[s][bit].first;\n\t\t}\n\t\tfor (int bit = 0; bit < 20; ++bit) if (dt & (1 << bit)) {\n\t\t\tet = max(et, edge[t][bit]);\n\t\t\tt = tree.ancestor[t][bit].first;\n\t\t}\n\t\tans[i] = sum - w;\n\t}\n\tfor (int i = 0; i < Q; ++i) cout << ans[i] << endl;\n\treturn 0;\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAX_V = 5000;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    tuple<ll, int, int> edges[M];\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = make_tuple(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    vector<pair<int, ll>> path[N];\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(make_pair(b, c));\n        path[b].push_back(make_pair(a, c));\n    }\n\n    ll emax[N][N];\n    // emax[i][j] = iからjのパス上で最大コストの辺のコスト\n\n    // 各頂点始点のBFS\n    for (int r = 0; r < N; ++r) {\n        fill(emax[r], emax[r] + N, -1);\n        emax[r][r] = 0;\n        queue<int> que;\n        que.push(r);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n\n            for (auto p : path[v]) {\n                int sv;\n                ll cost;\n                tie(sv, cost) = p;\n\n                if (emax[r][sv] >= 0) continue;\n                emax[r][sv] = max(emax[r][v], cost);\n                que.push(sv);\n            }\n        }\n    }\n\n    // クエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        cout << total - emax[--s][--t] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 4005;\nconst int MAXM = 400005;\n\nstruct Edge {\n    int u, v, w;\n\n    bool inline operator < (const Edge &rhs) const {\n        return w < rhs.w;\n    }\n};\n\nclass DSU {\nprivate:\n    vector<int> pset;\n\npublic:\n    DSU(int n) {\n        pset.resize(n);\n        for(int i = 0; i < n; ++i)\n            pset[i] = i;\n    }\n\n    int findSet(int i) {\n        return (pset[i] == i) ? i : (pset[i] = findSet(pset[i]));\n    }\n\n    bool unionSet(int i, int j) {\n        int p = findSet(i), q = findSet(j);\n        if (p == q)\n            return false;\n\n        pset[p] = q;\n        return true;\n    }\n};\n\nint n, m, q, maxW[MAXN][MAXN], root;\nEdge e[MAXM];\nvector<int> g[MAXN];\n\nvoid DFS(int u, int par) {\n    for(int i: g[u]) {\n        int v = e[i].u + e[i].v - u;\n        if (v == par)\n            continue;\n\n        maxW[root][v] = max(maxW[root][u], e[i].w);\n        DFS(v, u);\n    }\n}\n\nint main () {\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 0; i < m; ++i) {\n        scanf(\"%d%d%d\", &e[i].u, &e[i].v, &e[i].w);\n        --e[i].u;\n        --e[i].v;\n    }\n\n    sort(e, e+m);\n    DSU s(n);\n\n    ll mstWeight = 0;\n    for(int i = 0; i < m; ++i) {\n        int u = e[i].u, v = e[i].v;\n        if (s.unionSet(u, v)) {\n            g[u].push_back(i);\n            g[v].push_back(i);\n            mstWeight += e[i].w;\n        }\n    }\n\n    for(int u = 0; u < n; ++u) {\n        root = u;\n        DFS(u, -1);\n    }\n\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; ++i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        --u; --v;\n\n        ll ans = mstWeight - maxW[u][v];\n        printf(\"%lld\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=1e9+7;\n#define N 1055050\n\nstruct edge{\n    int from,to;\n    ll cost;\n    bool operator<(const edge& e)const{\n        return cost<e.cost;\n    };\n};\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    bool unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return false;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n        return true;\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nvector<vector<pll>> G(N);\nll kruskal(vector<edge> &edges,int v){\n    sort(ALL(edges),[](edge a,edge b){\n        return a.cost<b.cost;\n    });\n    UnionFind u(v+1);\n    ll ret=0;\n    for(auto e:edges){\n        if(u.unite(e.from,e.to)){\n            ret+=e.cost;\n            G[e.from].pb({e.to,e.cost});\n            G[e.to].pb({e.from,e.cost});\n        }\n    }\n    return ret;\n}\nll n,m;\nll d[5000][5000];\nvoid dfs(int from,int now,int par,ll MAX){\n    d[from][now]=MAX;\n    for(auto e:G[now]){\n        if(e.first!=par){\n            dfs(from,e.first,now,max(MAX,e.second));\n        }\n    }\n    return ;\n}\nmain(){\n    n=in();\n    m=lin();\n    vector<edge> ed;\n    rep(i,m){\n        int a=in(),b=in(),c=lin();\n        ed.pb(edge{a,b,c});\n    }\n    ll MST=kruskal(ed,n);\n    rep2(i,1,n){\n        dfs(i,i,0,0);\n    }\n    int q=in();\n    rep(iii,q){\n        int s=in(),t=in();\n        cout<<MST-d[s][t]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nstruct LowestCommonAncestorTreeMax {\n        const int LOGM = 30;\n        vector<int> depth, par_w;\n        vector<vector<int>> parent, parmax;\n        LowestCommonAncestorTreeMax(int root, const vector<vector<pair<int, int>>> &g) {\n                int n = g.size();\n                depth.resize(n);\n                par_w.resize(n);\n                parent.resize(LOGM);\n                parmax.resize(LOGM);\n                for (int i = 0; i < LOGM; i ++) { \n                        parent[i].resize(n);\n                        parmax[i].resize(n);\n                }\n                function<void (int, int, int)> dfs = [&](int u, int prev, int d) {\n                        parent[0][u] = prev;\n                        parmax[0][u] = par_w[u];\n                        depth[u] = d;\n                        for (auto e : g[u]) { \n                                int v = e.first;\n                                if (v != prev) { \n                                        par_w[v] = e.second;\n                                        dfs(v, u, d + 1);\n                                }\n                        }\n                };\n                dfs(root, -1, 0);\n                for (int k = 0; k < LOGM - 1; k ++) {\n                        for (int i = 0; i < n; i ++) {\n                                if (parent[k][i] < 0) { \n                                        parent[k + 1][i] = -1;\n                                } else { \n                                        parent[k + 1][i] = parent[k][parent[k][i]];\n                                        if (parent[k + 1][i] >= 0) {\n                                                parmax[k + 1][i] = max(parmax[k][i], parmax[k][parent[k][i]]);\n                                        }\n                                }\n                        }\n                }\n        }\n        int lca(int u, int v) { \n                if (depth[u] > depth[v]) swap(u, v);\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((depth[v] - depth[u]) >> k & 1) { \n                                v = parent[k][v];\n                        }\n                }\n                if (u == v) return u;\n                for (int k = LOGM - 1; k >= 0; k --) {\n                        if (parent[k][u] != parent[k][v]) {\n                                u = parent[k][u];\n                                v = parent[k][v];\n                        }\n                }\n                return parent[0][u];\n        }\n        int dist(int u, int v) {\n                return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n        }\n        int getmax(int v, int ancestor) {\n                int res = 0;\n                int d = depth[v] - depth[ancestor];\n                for (int k = 0; k < LOGM; k ++) {\n                        if ((d >> k) & 1) {\n                                res = max(res, parmax[k][v]);\n                                v = parent[k][v];\n                        }\n                }\n                return res;\n        }\n};\n\nstruct edge {\n    int a, b, c;\n};\n\nvi par;\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\nbool unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return true;\n    par[x] = y;\n    return false;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int n, m;\n    cin >> n >> m;\n    vector<edge> edges;\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.push_back({a - 1, b - 1, c});\n    }\n\n    sort(edges.begin(), edges.end(), [](edge a, edge b) {return a.c < b.c;});\n    par = vi(n);\n    iota(par.begin(), par.end(), 0);\n\n    unordered_set<int> ns;\n\n    vector<vector<pair<int, int>>> adj(n);\n    i64 sum = 0;\n    for (int i = 0; i < m && ns.size() < n; i++) {\n        int x = edges[i].a, y = edges[i].b;\n        if (!unite(x, y)) {\n            ns.insert(x);\n            ns.insert(y);\n            adj[x].push_back(make_pair(y, edges[i].c));\n            adj[y].push_back(make_pair(x, edges[i].c));\n            sum += edges[i].c;\n        }\n    }\n\n    LowestCommonAncestorTreeMax tree(0, adj);\n    auto maxw = [&](int s, int t) {\n        int lca = tree.lca(s, t);\n        return max(tree.getmax(s, lca), tree.getmax(t, lca));\n    };\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        cout << sum - maxw(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >ttree[4005];\n\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < ttree[dst].size(); i++){\n\t\t\tlong long ncost = ttree[dst][i].first;\n\t\t\tlong long next = ttree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid prepare(){\n\tset<long long> done;\n\t//                     cost  ,      src\t,     dst\n\tpriority_queue<pair<long long, pair<long long, long long> >, vector<pair<long long, pair<long long, long long> > >, greater<pair<long long, pair<long long, long long> > > > Q;\n\tQ.push(make_pair(0, make_pair(-1, 0)));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, src, dst;\n\t\tcost = Q.top().first;\n\t\tsrc = Q.top().second.first;\n\t\tdst = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tdone.insert(dst);\n\t\tif(src != -1){\n\t\t\tttree[src].push_back(make_pair(cost, dst));\n\t\t\tttree[dst].push_back(make_pair(cost, src));\n\t\t}\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, make_pair(dst, next)));\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tprepare();\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r1, int r2) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r1, 0) );\n  Q.push( Edge(-1, r2, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\tGraph g(N);\n\tfor(;M--;){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\tg[b-1].emplace_back(b-1,a-1,c);\n\t}\n\tscanf(\"%d\",&Q);\n\tif(Q>1)return 1;\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tprintf(\"%d\\n\",minimumSpanningTree(g,a-1,b-1).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long from; long long to; long long cost; \n\tbool operator<(const edge& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\npriority_queue<edge> pq;\n\nll const MAX = 4006;\nll dep[MAX];\nll parent_uf[MAX];\nll rk[MAX];\n\nvoid init(ll n) {\n\tfor (ll i = 1; i <= n; i++) {\n\t\tparent_uf[i] = i;\n\t\trk[i] = 1;\n\t}\n}\n\nll find(ll x) {\n\tif (parent_uf[x] == x) {\n\t\treturn x;\n\t}\n\tparent_uf[x] = find(parent_uf[x]);\n\treturn parent_uf[x];\n}\n\nbool same(ll x, ll y) {\n\treturn find(x) == find(y);\n}\n\nvoid unite(ll x, ll y) {\n\tif (!same(x, y)) {\n\t\tx = parent_uf[x];\n\t\ty = parent_uf[y];\n\t\tif (rk[x] < rk[y]) {\n\t\t\tparent_uf[x] = y;\n\t\t}\n\t\telse {\n\t\t\tparent_uf[y] = x;\n\t\t\tif (rk[x] == rk[y]) {\n\t\t\t\trk[x]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll n, m, q;\nvector<edge> G[MAX];\n\nll make_tree() {\n\tll cnt = n - 1;\t\n\tll ttl = 0;\n\n\twhile (cnt > 0) {\n\t\tedge cur = pq.top();\n\t\tpq.pop();\n\t\tll cf = cur.from; ll ct = cur.to; ll cc = cur.cost;\n\t\tif (!same(cf, ct)) {\n\t\t\tunite(cf, ct);\n\t\t\tttl += cur.cost;\n\t\t\tG[cf].push_back({ cf,ct,cc });\n\t\t\tG[ct].push_back({ ct,cf,cc });\n\t\t\tcnt--;\n\t\t}\n\t}\n\treturn ttl;\n}\n\nll parent[MAX];\nll costing[MAX];\n\nvoid dfs() {\n\tparent[1] = 1;\n\tstack<ll> st;\n\tst.push(1);\n\tdep[1] = 0;\n\twhile (!st.empty()) {\n\t\tll cur = st.top();\n\t\tst.pop();\n\t\tfor (ll i = 0; i < SIZE(G[cur]); i++) {\n\t\t\t\n\t\t\tll next = G[cur][i].to;\n\t\t\tif (next == parent[cur]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout << cur << \" \" << next << endl;\n\t\t\tparent[next] = cur;\n\t\t\tdep[next] = dep[cur] + 1;\n\t\t\tcosting[next] = G[cur][i].cost;\n\t\t\t//cout << costing[next] << endl;\n\t\t\tst.push(next);\n\t\t}\n\t}\n}\n\nll dp[MAX][MAX] = {};\n\nll query(ll s, ll t, ll u) {\n\tif (s == t) {\n\t\treturn u;\n\t}\t\n\tif (dep[s] < dep[t]) {\n\t\tswap(s, t);\n\t}\n\n\tif (dp[s][t] != 0) {\n\t\treturn max(dp[s][t],u);\n\t}\n\tll v = max(u, costing[s]);\n\t//cout << v << \" ?\" << endl;\n\tdp[s][t] = query(parent[s], t, v);\n\treturn dp[s][t];\n}\n\nint main() {\n\tcin >> n >> m;\n\tinit(n);\n\tREP(i, 1, m) {\n\t\tll a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tpq.push({ a,b,c });\n\t}\n\tll ttl = make_tree();\n\tdfs();\n\tcin >> q;\n\tREP(i, 1, q) {\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tcout << ttl - query(s, t, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a}); // 0:cost, 1:opponent, 2:self\n    g[b].pb({c, a, b});\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n, 0));\n  ll cost = 0;\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    cand.erase(begin(cand));\n    if (uf.same(edge[1], edge[2])) {\n      continue;\n    }\n    //assert(uf.same(0, edge[2]));\n    //assert(!uf.same(0, edge[1]));\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      //assert(!uf.same(i, edge[1]));\n      //assert(uf.same(0, i));\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) {\n        continue;\n      }\n      assert(maxcost[i][j] > 0);\n    }\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (i, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[i] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF      1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nint n, m, q;\nint s, t;\nvector<P> e[200000];\nvector<PP> ee;\n\nstruct UF{\n\tint par[200000];\n\tint rank[200000];\n\tint si[200000];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\nUF uf;\nvector<P> hoge;\nbool ok[200000];\n\nint main(){\n    cin >> n >> m;\n    rep(i,m){\n        ll a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        e[a].push_back(P(c,b));\n        e[b].push_back(P(c,b));\n        ee.push_back(PP(c,P(a,b)));\n    }\n    uf.init(n);\n    cin >> q;\n    rep(i,q){\n        cin >> s >> t;\n        s--;\n        t--;\n        hoge.clear();\n        memset(ok,0,sizeof(ok));\n        ok[s] = true;\n        ok[t] = true;\n        hoge.clear();\n        rep(j,n) rep(k,e[j].size()) hoge.push_back(e[s][i]);\n        sort(hoge.begin(),hoge.end());\n        sort(ee.begin(),ee.end());\n        ll ans = 0;\n        uf.init(n);\n        uf.unite(s,t);\n        rep(j,ee.size()){\n            if(!uf.same(ee[j].second.first,ee[j].second.second)){\n                ans += ee[j].first;\n                uf.unite(ee[j].second.first,ee[j].second.second);\n            }\n        }\n        cout << ans << endl;\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourth; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, p, q, last, first, cnt, sum, ans, dp[200000];\nPll a[300000], b[300000];\nstring str, ss;\nbool f[200];\nchar c, ch[100][100];\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nstruct edge { LL from, to, cost; };\nvector<Edge>vec[200000];\nvector<edge>v;\nmap<Pll,LL>ma;\nmultiset<LL>st;\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Seg {\n\tLL n;\n\tvector<LL>node;\n\tSeg(LL n_) {\n\t\tn = 1; while (n < n_)n *= 2;\n\t\tnode.resize(n * 2 - 1);\n\t\trep(i, n)node[n + i - 1] = 0;\n\t\tMfor(i, n - 2)node[i] = max(node[i * 2 + 1], node[i * 2 + 2]);\n\t}\n\tvoid update(LL i, LL x) {\n\t\ti = i + n - 1;\n\t\tnode[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tnode[i] = max(node[i * 2 + 1], node[i * 2 + 2]);\n\t\t}\n\t}\n\tLL find(LL i, LL a, LL b, LL l, LL r) {\n\t\tif (b< l || r < a)return 0;\n\t\tif (l <= a && b <= r)return node[i];\n\t\treturn max(find(i * 2 + 1, a, (a + b) / 2, l, r), find(i * 2 + 2, (a + b + 1) / 2, b, l, r));\n\t}\n\n};\n\n\nint  par[100000];  // リーダーの値を格納 \nint find(int x) { if (par[x] == x)return x; par[x] = find(par[x]); return par[x]; }\nvoid unite(int x, int y) { x = find(x); y = find(y); if (x == y)return; par[x] = y; }\nbool same(int x, int y) { return find(x) == find(y); }\nSeg seg(100000);\nstruct HLD {\n\tLL n, pos;\n\tvector<vector<Edge> > G;\n\tvector<LL> vid, head, sub, hvy, par, dep, inv, type;\n\n\tHLD() {}\n\tHLD(LL sz) :\n\t\tn(sz), pos(0), G(n),\n\t\tvid(n, -1), head(n), sub(n, 1), hvy(n, -1),\n\t\tpar(n), dep(n), inv(n), type(n) {}\n\n\tvoid add_edge(LL u, LL v, LL cos) {\n\t\tG[u].push_back(Edge{ v ,cos });\n\t\tG[v].push_back(Edge{ u,cos });\n\t}\n\n\tvoid build(vector<LL> rs = vector<LL>(1, 0)) {\n\t\tLL c = 0;\n\t\tfor (LL r : rs) {\n\t\t\tdfs(r);\n\t\t\tbfs(r, c++);\n\t\t}\n\t\tupdate(0,-1);\n\t}\n\n\tvoid update(LL cur,LL par) {\n\t\trep(i,G[cur].size()) {\n\t\t\tif (G[cur][i].to != par) {\n\t\t\t\tseg.update(vid[G[cur][i].to], G[cur][i].cost);\n\t\t\t\tupdate(G[cur][i].to, cur);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(LL rt) {\n\t\tusing T = pair<LL, LL>;\n\t\tstack<T> st;\n\t\tpar[rt] = -1;\n\t\tdep[rt] = 0;\n\t\tst.emplace(rt, 0);\n\t\twhile (!st.empty()) {\n\t\t\tLL v = st.top().first;\n\t\t\tLL &i = st.top().second;\n\t\t\tif (i<(LL)G[v].size()) {\n\t\t\t\tLL u = G[v][i++].to;\n\t\t\t\tif (u == par[v]) continue;\n\t\t\t\tpar[u] = v;\n\t\t\t\tdep[u] = dep[v] + 1;\n\t\t\t\tst.emplace(u, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.pop();\n\t\t\t\tLL res = 0;\n\t\t\t\tfor (Edge u : G[v]) {\n\t\t\t\t\tif (u.to == par[v]) continue;\n\t\t\t\t\tsub[v] += sub[u.to];\n\t\t\t\t\tif (res<sub[u.to]) res = sub[u.to], hvy[v] = u.to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid bfs(LL r, LL c) {\n\t\tLL &k = pos;\n\t\tqueue<LL> q({ r });\n\t\twhile (!q.empty()) {\n\t\t\tLL h = q.front(); q.pop();\n\t\t\tfor (LL i = h; i != -1; i = hvy[i]) {\n\t\t\t\ttype[i] = c;\n\t\t\t\tvid[i] = k++;\n\t\t\t\tinv[vid[i]] = i;\n\t\t\t\thead[i] = h;\n\t\t\t\tfor (Edge j : G[i])\n\t\t\t\t\tif (j .to!= par[i] && j.to != hvy[i]) q.push(j.to);\n\t\t\t}\n\t\t}\n\t}\n\n\t// for_each(vertex)\n\t// [l,r] <- attention!!\n\tvoid for_each(LL u, LL v, LL x, const function<void(LL, LL)>& f) {\n\t\twhile (1) {\n\t\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\t\tf(max(vid[head[v]], vid[u]), vid[v]);\n\t\t\tif (head[u] != head[v]) v = par[head[v]];\n\t\t\telse break;\n\t\t}\n\t}\n\n\t// for_each(edge)\n\t// [l,r] <- attention!!\n\tLL for_each_edge(LL u, LL v, const function<LL(LL, LL)>& f) {\n\t\tLL ret = 0;\n\t\twhile (1) {\n\t\t\tif (vid[u]>vid[v]) swap(u, v);\n\t\t\tif (head[u] != head[v]) {\n\t\t\t\tret=max(ret,f(vid[head[v]], vid[v]));\n\t\t\t\tv = par[head[v]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (u != v) ret = max(ret, f(vid[u] + 1, vid[v]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tLL lca(LL u, LL v) {\n\t\twhile (1) {\n\t\t\tif (vid[u]>vid[v]) swap(u, v);\n\t\t\tif (head[u] == head[v]) return u;\n\t\t\tv = par[head[v]];\n\t\t}\n\t}\n\n\tLL distance(LL u, LL v) {\n\t\treturn dep[u] + dep[v] - 2 * dep[lca(u, v)];\n\t}\n};\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i<n; i++)par[i] = i;  // このように初期化\n\trep(i,m) {\n\t\tLL x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tx--, y--;\n\t\tv.push_back(edge{ x,y,z });\n\t}\n\tsort(v.begin(), v.end(), [](edge x, edge y) {return x.cost < y.cost; });\n\tHLD hld(n);\n\trep(i, m) {\n\t\tif (!same(v[i].to, v[i].from)) {\n\t\t\tunite(v[i].to, v[i].from);\n\t\t\tsum += v[i].cost;\n\t\t\thld.add_edge(v[i].to, v[i].from, v[i].cost);\n\t\t}\n\t}\n\thld.build();\n\tcin >> q;\n\trep(i, q) {\n\t\tLL x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tcout << sum - hld.for_each_edge(x, y, [&](LL s, LL t) {\n\t\t\treturn seg.find(0, 0, seg.n - 1, s, t);\n\t\t}) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CApITAL\nvoid yes(bool ex=true){\n\t#ifdef CApITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CApITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CApITAL\n\tcout<<\"pOSSIBLE\"<<endl;\n\t#else\n\tcout<<\"possible\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CApITAL\n\tcout<<\"IMpOSSIBLE\"<<endl;\n\t#else\n\tcout<<\"Impossible\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class N>\nstruct linkcut{\n\tstruct Node{\n\t\tusing np=Node*;\n\t\tnp l,r,p;\n\t\tbool rev;\n\t\tN x;\n\t\tNode():l(0),r(0),p(0),rev(false),x(){}\n\t\tvoid reverse(){\n\t\t\trev^=true;\n\t\t\tx.reverse();\n\t\t}\n\t\tvoid propagate(){\n\t\t\tif(rev){\n\t\t\t\tswap(l,r);\n\t\t\t\tif(l)l->reverse();\n\t\t\t\tif(r)r->reverse();\n\t\t\t\trev=false;\n\t\t\t}\n\t\t\tif(l)x.push(l->x);\n\t\t\tif(r)x.push(r->x);\n\t\t\tx.clear();\n\t\t}\n\t\tvoid update(){\n\t\t\tx.single();\n\t\t\tif(l)\n\t\t\t\tx.update(l->x);\n\t\t\tif(r)\n\t\t\t\tx.update(r->x);\n\t\t}\n\t\tint pos(){\n\t\t\tif(p&&p->l==this) return -1;\n\t\t\tif(p&&p->r==this) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\tvoid prepare(){\n\t\t\tif(pos())\n\t\t\t\tp->prepare();\n\t\t\tpropagate();\n\t\t}\n\t\tvoid rotate(){\n\t\t\tnp q=p,c;\n\t\t\tif(pos()==1){\n\t\t\t\tc=l;\n\t\t\t\tl=p;\n\t\t\t\tp->r=c;\n\t\t\t}else{\n\t\t\t\tc=r;\n\t\t\t\tr=p;\n\t\t\t\tp->l=c;\n\t\t\t}\n\t\t\tif(c)c->p=p;\n\t\t\tp=p->p;\n\t\t\tq->p=this;\n\t\t\tif(p&&p->l==q)p->l=this;\n\t\t\tif(p&&p->r==q)p->r=this;\n\t\t\tq->update();\n\t\t}\n\t\tvoid splay(){\n\t\t\tprepare();\n\t\t\twhile(pos()){\n\t\t\t\tint a=pos(),b=p->pos();\n\t\t\t\tif(b&&a==b)p->rotate();\n\t\t\t\tif(b&&a!=b)rotate();\n\t\t\t\trotate();\n\t\t\t}\n\t\t\tupdate();\n\t\t}\n\t\tvoid expose(){\n\t\t\tfor(np a=this;a;a=a->p)a->splay();\n\t\t\tfor(np a=this;a->p;a=a->p){\n\t\t\t\ta->p->r=a;\n\t\t\t\ta->p->update();\n\t\t\t}\n\t\t\tsplay();\n\t\t}\n\t\tvoid evert(){\n\t\t\texpose();\n\t\t\tif(l){\n\t\t\t\tl->reverse();\n\t\t\t\tl=0;\n\t\t\t\tupdate();\n\t\t\t}\n\t\t}\n\t\tvoid link(np a){\n\t\t\tevert();\n\t\t\tp=a;\n\t\t}\n\t\tvoid cutchild(){\n\t\t\texpose();\n\t\t\tr=0;\n\t\t\tupdate();\n\t\t}\n\t\tvoid cutpar() {\n\t\t\texpose();\n\t\t\tassert(l);\n\t\t\tl->p=0;\n\t\t\tl=0;\n\t\t\tupdate();\n\t\t}\n\t}*x;\n\tlinkcut(int n){\n\t\tx=new Node[n];\n\t}\n\t~linkcut(){delete[] x;}\n\t\n\tusing np=typename Node::np;\n\tint lca(int aa,int bb){\n\t\tnp a=x+aa,b=x+bb;\n\t\ta->expose();\n\t\tb->expose();\n\t\tif(!a->p)return -1;\n\t\t\n\t\tnp d=a;\n\t\twhile(a->p!=b){\n\t\t\tif(a->pos()==0)\n\t\t\t\td=a->p;\n\t\t\ta=a->p;\n\t\t}\n\t\tif(a==b->l)return d-x;\n\t\telse return b-x;\n\t}\n\tvoid link(int a,int b){\n\t\tx[a].link(x+b);\n\t}\n\tvoid cutpar(int a){\n\t\tx[a].cutpar();\n\t}\n\tvoid expose(int a){\n\t\tx[a].expose();\n\t}\n\tvoid expose_path(int a,int b){\n\t\tx[a].evert();\n\t\tx[b].cutchild();\n\t}\n\tN&operator[](int i){\n\t\treturn x[i].x;\n\t}\n};\n//N::reverse\n//N::push\n//N::clear\n//N::single\n//N::update\n\nstruct N{\n\tint v,mx;\n\tN(int vv=0):v(vv),mx(v){}\n\tvoid reverse(){\n\t}\n\tvoid push(N&){\n\t}\n\tvoid clear(){\n\t}\n\tvoid single(){\n\t\tmx=v;\n\t}\n\tvoid update(const N&x){\n\t\tchmax(mx,x.mx);\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tvc<tuple<int,int,int>> es;\n\trep(_,m){\n\t\tint a,b,c;cin>>a>>b>>c;\n\t\ta--;b--;\n\t\tes.eb(c,a,b);\n\t}\n\tsort(all(es));\n\tlinkcut<N> t(n*2);\n\tint z=n,ans=0;\n\tfor(auto e:es){\n\t\tint c,a,b;tie(c,a,b)=e;\n\t\tif(t.lca(a,b)==-1){\n\t\t\tt[z]=N(c);\n\t\t\tt.link(a,z);\n\t\t\tt.link(b,z);\n\t\t\tz++;\n\t\t\tans+=c;\n\t\t}\n\t}\n\tint q;cin>>q;\n\trep(_,q){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt.expose_path(a,b);\n\t\tprint(ans-t[b].mx);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nconst int INF = 1 << 30;\n\nstruct SegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  SegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, -INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = max(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (-INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (max(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n\n  void update(int k, int x)\n  {\n    k += sz - 1;\n    seg[k] = x;\n    while(k > 0) {\n      k = (k - 1) >> 1;\n      seg[k] = max(seg[2 * k + 1], seg[2 * k + 2]);\n    }\n  }\n\n};\n\nvector< vector< int > > graph;\n\nstruct CentroidPathDecomposition\n{\n  struct Centroid\n  {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    inline int size()\n    {\n      return (node.size());\n    }\n\n    inline int &operator[](int k)\n    {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up()\n    {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth;\n  vector< Centroid > Centroids;\n\n  void BuildSubTreeSize()\n  {\n    stack< pair< int, int > > s;\n    s.push({0, -1});\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      if(~SubTreeSize[p.first]) {\n        NextPath[p.first] = -1;\n        for(auto &to : graph[p.first]) {\n          if(p.second == to) continue;\n          SubTreeSize[p.first] += SubTreeSize[to];\n          if(NextPath[p.first] == -1 || SubTreeSize[NextPath[p.first]] < SubTreeSize[to]) {\n            NextPath[p.first] = to;\n          }\n        }\n      } else {\n        s.push(p);\n        SubTreeSize[p.first] = 1;\n        for(auto &to : graph[p.first]) {\n          if(p.second != to) s.push({to, p.first});\n        }\n      }\n    }\n  }\n\n  void BuildPath()\n  {\n    stack< pair< int, int > > s;\n    Centroids.push_back((Centroid) {-1, -1, 0});\n    s.push({0, -1});\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = Centroids[TreeIndex[p.first]].size();\n      for(auto &to : graph[p.first]) {\n        if(p.second != to) {\n          if(to == NextPath[p.first]) { // Centroid-Path\n            TreeIndex[to] = TreeIndex[p.first];\n          } else {                  // Not Centroid-Path\n            TreeIndex[to] = Centroids.size();\n            Centroids.push_back((Centroid) {TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1});\n          }\n          s.push({to, p.first});\n        }\n      }\n      Centroids[TreeIndex[p.first]].node.push_back(p.first);\n    }\n  }\n\n  void AddEdge(int x, int y)\n  {\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n\n  void Build()\n  {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline int size()\n  {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx)\n  {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid &operator[](int k)\n  {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b)\n  {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  CentroidPathDecomposition(int SZ)\n  {\n    graph.resize(SZ);\n    SubTreeSize.assign(SZ, -1);\n    NextPath.resize(SZ);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n  }\n\n  inline int getPathMax(int a, int b);\n};\n\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz) : data(sz, -1) {}\n\n  void unite(int x, int y)\n  {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n};\n\nstruct edge\n{\n  int u, v, cost;\n\n  bool operator<(const edge &e) const\n  {\n    return (cost < e.cost);\n  }\n};\n\n\nvector< SegmentTree > segs;\n\nint CentroidPathDecomposition::getPathMax(int a, int b)\n{\n  int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n  tie(TreeIdxA, TreeDepthA) = Information(a);\n  tie(TreeIdxB, TreeDepthB) = Information(b);\n  int ret = 0;\n  while(TreeIdxA != TreeIdxB) {\n    if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n      ret = max(ret, segs[TreeIdxA].rmq(0, TreeDepthA + 1));\n      tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n    } else {\n      ret = max(ret, segs[TreeIdxB].rmq(0, TreeDepthB + 1));\n      tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n    }\n  }\n  if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n  return (max(ret, segs[TreeIdxA].rmq(TreeDepthA + 1, TreeDepthB + 1)));\n}\n\nint main()\n{\n  int N, M;\n  cin >> N >> M;\n  vector< edge > edges(M);\n  for(auto &e : edges) cin >> e.u >> e.v >> e.cost;\n  sort(begin(edges), end(edges));\n  int64 cost = 0LL;\n  UnionFind tree(N);\n  CentroidPathDecomposition cpd(N);\n  map< pair< int, int >, int > vs;\n  for(auto &e : edges) {\n    e.u--, e.v--;\n    if(tree.find(e.u) == tree.find(e.v)) continue;\n    cost += e.cost;\n    tree.unite(e.u, e.v);\n    cpd.AddEdge(e.u, e.v);\n    vs[{e.u, e.v}] = e.cost;\n  }\n  cpd.Build();\n  for(int i = 0; i < cpd.size(); i++) {\n    segs.push_back(SegmentTree(cpd[i].size()));\n  }\n  for(auto &v : vs) {\n    auto a = cpd.Information(v.first.first);\n    auto b = cpd.Information(v.first.second);\n    if(a.first > b.first || (a.first == b.first) && a.second > b.second) swap(a, b);\n    segs[b.first].update(b.second, v.second);\n  }\n  int Q;\n  cin >> Q;\n  while(Q--) {\n    int s, t;\n    cin >> s >> t;\n    cout << cost - cpd.getPathMax(--s, --t) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n#define int long long\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nsigned main(){\n\tint n,m;scanf(\"%lld%lld\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%lld%lld%lld\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%lld\",&q);\n\trep(i,q){\n\t\tscanf(\"%lld%lld\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    cin >> a[i],b[i],c[i];\n    a[i]--; b[i]--;\n\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<int>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n  \n  vector<vector<int>> p(n, vector<int>(14, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(14, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<14; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u,v;\n    u--; v--;\n\n    long long sub = 0;\n/*\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<14; k++){\n      if( (depth[v] - depth[u]) >> k & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=13; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n*/\n\n    while(u!=v){\n      if(depth[u] < depth[v]){\n        sub = max(sub, mx_e[v][0]);\n        v = p[v][0];\n      }else{\n        sub = max(sub, mx_e[u][0]);\n        u = p[v][0];\n      }\n    }\n    println( mst_cost - sub );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\ntypedef long long ll;\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nstruct disjoint_sets {\n    vector<int> xs;\n    disjoint_sets() = default;\n    explicit disjoint_sets(size_t n) : xs(n, -1) {}\n    bool is_root(int i) { return xs[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (xs[i] = find_root(xs[i])); }\n    int set_size(int i) { return - xs[find_root(i)]; }\n    int union_sets(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (set_size(i) < set_size(j)) swap(i,j);\n            xs[i] += xs[j];\n            xs[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\ntemplate <typename T> struct weighted_edge_t { int u, v; T w; };\ntemplate <typename T> bool operator < (weighted_edge_t<T> const & a, weighted_edge_t<T> const & b) { return make_tuple(a.w, a.u, a.v) < make_tuple(b.w, b.u, b.v); }\ntemplate <typename T>\nvector<vector<weighted_edge_t<T> > > minimum_spanning_tree(int n, vector<weighted_edge_t<T> > edges) { // Kruskal's method, O(E \\log E)\n    vector<vector<weighted_edge_t<T> > > tree(n);\n    disjoint_sets sets(n);\n    whole(sort, edges);\n    for (auto e : edges) {\n        if (not sets.is_same(e.u, e.v)) {\n            sets.union_sets(e.u, e.v);\n            tree[e.u].push_back( (weighted_edge_t<T>) { e.u, e.v, e.w } );\n            tree[e.v].push_back( (weighted_edge_t<T>) { e.v, e.u, e.w } );\n        }\n    }\n    return tree;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<weighted_edge_t<int> > es(m);\n    repeat (i,m) {\n        int a, b, c; cin >> a >> b >> c; -- a; -- b;\n        es[i] = { a, b, c };\n    }\n    auto mst = minimum_spanning_tree(n, es);\n    ll total = 0;\n    repeat (i,n) for (auto e : mst[i]) {\n        if (e.u < e.v) total += e.w;\n    }\n    vector<vector<int> > drop = vectors(n, n, int()); {\n        repeat (i,n) {\n            function<void (int, int)> dfs = [&](int j, int parent) {\n                for (auto e : mst[j]) if (e.v != parent) {\n                    drop[i][e.v] = max(drop[i][j], e.w);\n                    dfs(e.v, j);\n                }\n            };\n            drop[i][i] = 0;\n            dfs(i, i);\n        }\n    }\n    int q; cin >> q;\n    while (q --) {\n        int s, t; cin >> s >> t; -- s; -- t;\n        cout << total - drop[s][t] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    int q;\n    cin >> q;\n    if(int64_t(m)*q>10000000) return;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        union_find uf(n);\n        int64_t sum=0;\n        for(edge &edge:edges){\n            int a=edge.from,b=edge.to;\n            if(uf.is_same_group(a,b) or (uf.is_same_group(a,s) and uf.is_same_group(b,t)) or (uf.is_same_group(b,s) and uf.is_same_group(a,t))) continue;\n            uf.unite(a,b);\n            sum+=edge.cost;\n        }\n        cout << sum << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nstring s;\nconst int N = 5000;\nint a[N], b[N], id[N], p[N];\nint c[N][N], u[N];\n\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n >> m;\n\tF0(i, m) {\n\t\tcin >> a[i] >> b[i] >> j;\n\t\tc[a[i]][b[i]] = c[b[i]][a[i]] = j;\n \t}\n\n\tint Q, S, T;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> S >> T;\n\n\t\tset<pii> SE;\n\t\tF1(i, n) if (i != S && i != T) {\n\t\t\tif (c[S][i]) SE.insert(pii(c[S][i], i));\n\t\t\tif (c[T][i]) SE.insert(pii(c[T][i], i));\n\t\t\tu[i] = 0;\n\t\t}\n\n\t\tll ans = 0;\n\t\tF0(i, n - 2) {\n\t\t\tpii p = *SE.begin(); SE.erase(SE.begin());\n\t\t\twhile (u[p.second]) {\n\t\t\t\tp = *SE.begin(); SE.erase(SE.begin());\n\t\t\t}\n\t\t\tans += p.first;\n\t\t\tu[p.second] = 1;\n\t\t\tF1(i, n) if (i != S && i != T) {\n\t\t\t\tif (c[p.second][i]) SE.insert(pii(c[p.second][i], i));\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v)const{\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\ntemplate<class T> class max_cost_on_path{\npublic:\n    const int max_pow=20;\n    vector<vector<T>> max_cost;\n    const lca_solver const* ls;\n    max_cost_on_path(const lca_solver &ls_,std::vector<std::unordered_map<int,T>> &cost):ls(&ls_),max_cost(max_pow){\n        const int n=ls->children.size();\n        for(int i=0; i<n; ++i) max_cost[i].resize(n);\n        for(int i=0; i<n; ++i){\n            if(i==ls->root) continue;\n            int j=ls->parent_pow2[0][i];\n            max_cost[0][i]=cost[i][j];\n        }\n        for(int i=1; i<max_pow; ++i){\n            for(int j=0; j<n; ++j){\n                if(ls->depth[j]-(1<<i)<0) continue;\n                max_cost[i][j]=std::max(max_cost[i-1][j],max_cost[i-1][ls->parent_pow2[i-1][j]]);\n            }\n        }\n    }\n\n    T sub(int u,int v)const{\n        T res=0;\n        for(int i=max_pow-1; i>=0; --i){\n            if(ls->depth[u]-ls->depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls->parent_pow2[i][u];\n            }\n        }\n        return res;\n    }\n\n    T calc(int u,int v)const{\n        int lca=ls->lca(u,v);\n        return max(sub(u,lca),sub(v,lca));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    int64_t sum_cost=0;\n    vector<vector<int>> mst(n);\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        mst[e.from].push_back(e.to);\n        mst[e.to].push_back(e.from);\n    }\n\n    int root=0;\n    vector<vector<int>> children(n);\n    function<void(int,int)> dfs=[&](int u,int p){\n        for(int v:mst[u]){\n            if(v==p) continue;\n            children[u].push_back(v);\n            dfs(v,u);\n        }\n    };\n    dfs(root,-1);\n    lca_solver ls(children,root);\n    max_cost_on_path<int> mcop(ls,cost);\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-mcop.calc(s,t) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define len(val) static_cast<ll>(val.size())\n#define rep(i, n) for(ll i=0; i<(n); i++)\n\nconst ll MAXN = 4000;\nconst ll MAXM = 400000;\nconst ll INF = 1e18;\nll N, M;\n\nstruct UnionFind\n{\n    std::vector<ll> data;\n    UnionFind(ll size) : data(size, -1){}\n    void initialize(void){\n        for(ll i=0; i<(ll)data.size(); i++) data[i] = i;\n    }\n    bool merge(ll x, ll y){\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        else{ data[x] = y; return true; }\n    }\n    ll find(ll x){ //根っこを見つける関数\n        if(data[x] == x) return x;\n        else return data[x] = find(data[x]); //経路圧縮\n    }\n    bool isSame(ll x, ll y){\n        return find(x) == find(y);\n    }\n};\n\nstruct edge{\n  ll u, v, cost;\n};\n\nbool comp(const edge& r, const edge& l){\n  return r.cost < l.cost;\n}\n\nedge es[MAXM];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    rep(i, M){\n      ll a, b, c;\n      cin >> a >> b >> c;\n      a--; b--;\n      es[i] = edge{a, b, c};\n    }\n    ll Q;\n    cin >> Q;\n    if(Q != 1) return 0;\n    ll s, t;\n    cin >> s >> t;\n    s--; t--;\n    es[M] = edge{s, t, 0};\n    ll ans = 0;\n    sort(es, es+M+1, comp);\n    UnionFind uf(N);\n    uf.initialize();\n    rep(i, M+1){\n      edge& e = es[i];\n      if(!uf.isSame(e.u, e.v)){\n        uf.merge(e.u, e.v);\n        ans += e.cost;\n      }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, q;\nint d[4010];\n\nstruct edge{\n   int to, cost;\n//    edge(int to, int cost):to(to), cost(cost){}\n};\nvector<edge> G[4010]; \n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       rep(i, 0, n) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nvector<pair<int, P> > es; \n// vector<int> path;\nint pMAX[4010][4010];\n// int cost[4010][4010];\n\nvoid dfs(int now, int pre, int MAX, int root){\n    // cout << \" \" << now << \" \" << pre << endl;\n    // path[now] = pre;\n    pMAX[root][now] = MAX;\n    // if(now == dest) return;\n    rep(i, 0, G[now].size()){\n        int next = G[now][i].to;\n        if(next == pre) continue;\n        // path[next] = now;       \n        dfs(next, now, max(MAX, G[now][i].cost), root);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    rep(i, 0, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        // G[a].push_back(edge{b, c});\n        // G[b].push_back(edge{a, c});\n        es.push_back(pair<int, P>(c, P(a, b)));\n        // cost[a][b] = c;\n        // cost[b][a] = c;\n    }\n    sort(all(es));\n    UF uf(n);\n    int sum = 0, cnt = 0;\n    rep(i, 0, es.size()){\n        int from = es[i].second.first;\n        int to = es[i].second.second;\n        if(uf.same(from, to) == false){\n            uf.unite(from, to);\n            sum += es[i].first;\n            G[from]. push_back(edge{to, es[i].first});\n            G[to]. push_back(edge{from, es[i].first});\n        }\n    }\n    // cout << sum << endl;\n    rep(i, 0, n){\n        // path.clear(); path.resize(n, -1);\n        dfs(i, -1, 0, i);\n    }\n    cin >> q;\n    rep(i, 0, q){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        // path.clear(); path.resize(n, -1);\n        // dfs(s, -1, t);\n        cout << sum - pMAX[s][t] << endl;\n        // int MAX = 0;\n        // int now = t;\n        // while(now != s){\n        //     int next = path[now];\n        //     chmax(MAX, cost[now][next]);\n        //     now = next;\n        // }\n        // cout << sum - MAX << endl;\n        // rep(j, 0, path.size()){\n        //     cout << path[j] << \" \";\n        // }\n        // cout << endl;\n        // dijkstra(s);\n        // cout << d[t] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing pii=pair<int,int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n#define all(c) begin(c),end(c)\n#define rall(c) rbegin(c),rend(c)\n#define fore(x,c) for(auto &&x:c)\n#define rep(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define rrep(i, a, n) for(int i=(int)(n-1);i>=a;--i)\n#define sz(c) ((int)c.size())\n#define contains(c,x) (c.find(x)!=end(c))\n#define inseg(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    for (auto i = begin(v); i != end(v); i++) os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    for (auto i = begin(v); i != end(v); i++) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void psum(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstruct UnionFind {\n    vector<int> data;\n    int comp;\n    UnionFind(int size) : data(size, -1), comp(size) {}\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y) {\n            if(data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n            comp--;\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : (data[x] = root(data[x]));\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n    int components() { return comp; }\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vector<tuple<int, int, int>> edge(M);\n    rep(i, 0, M) {\n        int vs, vt, cost;\n        cin >> vs >> vt >> cost;\n        vs--, vt--;\n        edge[i] = make_tuple(cost, vs, vt);\n    }\n    sort(all(edge));\n    \n    vector<vector<pii>> T(N);\n    UnionFind uf(N);\n    int MST_cost = 0;\n    rep(i, 0, M) {\n        int cost, vs, vt;\n        tie(cost, vs, vt) = edge[i];\n        if (!uf.same(vs, vt)) {\n            uf.unite(vs, vt);\n            T[vs].pb({vt, cost});\n            T[vt].pb({vs, cost});\n            MST_cost += cost;\n        }\n    }\n    vector<vector<int>> max_edge(N, vector<int>(N, 0));\n    int start = 0;\n    auto dfs = [&](auto f, int ver, int par, int mx) -> void {\n        max_edge[start][ver] = mx;\n        for (pii ed : T[ver]) {\n            int w, cost;\n            tie(w, cost) = ed;\n            if (w == par) continue;\n            f(f, w, ver, max(mx, cost));\n        }\n    };\n    rep(s, 0, N) {\n        start = s;\n        dfs(dfs, s, -1, 0);\n    }\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int S, T;\n        cin >> S >> T;\n        S--, T--;\n        dump(max_edge[S][T]);\n        cout << MST_cost - max_edge[S][T] << endl;\n    }\n    return (0^_^0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r1, int r2) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r1, 0) );\n  //Q.push( Edge(-1, r2, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\nint main(){\n\tint N,M,Q,a,b,c;\n\tscanf(\"%d%d\",&N,&M);\n\tGraph g(N);\n\tfor(;M--;){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tg[a-1].emplace_back(a-1,b-1,c);\n\t\tg[b-1].emplace_back(b-1,a-1,c);\n\t}\n\tscanf(\"%d\",&Q);\n\tif(Q>1)return 1;\n\tfor(;Q--;){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a-1].emplace_back(a-1,b-1,0);\n\t\tprintf(\"%d\\n\",minimumSpanningForest(g).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, s, t, a[400009], b[400009], c[400009], p[400009], par[4009], d[4009][4009]; vector<pair<int, int> > g[4009];\nint root(int x) { return x == par[x] ? x : par[x] = root(par[x]); }\nvoid dfs(int pos, int pre, int st, int val) {\n\td[st][pos] = val;\n\tfor (pair<int, int> i : g[pos]) {\n\t\tif (i.first == pre) continue;\n\t\tdfs(i.first, pos, st, max(val, i.second));\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < M; i++) scanf(\"%d %d %d\", &a[i], &b[i], &c[i]), a[i]--, b[i]--, p[i] = i;\n\tsort(p, p + M, [](int i, int j) { return c[i] < c[j]; });\n\tfor (int i = 0; i < N; i++) par[i] = i;\n\tlong long sum = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint pa = root(a[p[i]]), pb = root(b[p[i]]);\n\t\tif (pa != pb) {\n\t\t\tpar[pa] = pb; sum += c[p[i]];\n\t\t\tg[a[p[i]]].push_back(make_pair(b[p[i]], c[p[i]]));\n\t\t\tg[b[p[i]]].push_back(make_pair(a[p[i]], c[p[i]]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) dfs(i, -1, i, 0);\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tscanf(\"%d %d\", &s, &t); s--, t--;\n\t\tprintf(\"%lld\\n\", sum - d[s][t]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define MAX 10000\n#define INFTY (1<<29)\n\nvector<pair<int,ll>> g[4040];\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n\n  DisjointSet() {}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++) makeSet(i);\n  }\n\n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n  }\n\n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n\n  void unite(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n\n  void link(int x,int y){\n    if(rank[x]<rank[y]){\n      p[y]=x;\n    }else{\n      p[x]=y;\n      if(rank[x]==rank[y]){\n        rank[y]++;\n      }\n    }\n  }\n\n  int findSet(int x){\n    if(x!=p[x]){\n      p[x]=findSet(p[x]);\n    }\n    return p[x];\n  }\n};\n\nclass Edge{\npublic:\n  ll source,target,cost;\n  Edge(int source=0,int target=0,ll cost=0):\n  source(source),target(target),cost(cost){}\n  bool operator < (const Edge &e) const{\n    return cost < e.cost;\n  }\n};\n\nll kruskal(int N,vector<Edge> edges){//long long?\n  ll totalCost=0;\n  sort(edges.begin(),edges.end());\n  DisjointSet dset=DisjointSet(N+1);\n\n  for(int i=0;i<N;i++) dset.makeSet(i);\n\n  int source,target;\n  for(int i=0;i<edges.size();i++){\n    Edge e=edges[i];\n    if(!dset.same(e.source,e.target)){\n      // MST.push_back(e);\n      g[e.source].push_back(make_pair(e.target,e.cost));\n      g[e.target].push_back(make_pair(e.source,e.cost));\n      totalCost+=e.cost;\n      dset.unite(e.source,e.target);\n    }\n  }\n  return totalCost;\n}\n\nint N,M;\nint Q;\n\nbool used[4040];\nint ma[4040][4040];\n\nvector<int> dfs(int now){\n    used[now]=true;\n    vector<int> v[g[now].size()];\n    vector<int> res;\n    for(int i=0;i<g[now].size();i++){\n        int next=g[now][i].first;\n        if(used[next]) continue;\n        vector<int> child=dfs(next);\n        for(int j=0;j<child.size();j++){\n            v[i].push_back(child[j]);\n            res.push_back(child[j]);\n        }\n    }\n\n    for(int i=0;i<g[now].size();i++){\n        if(v[i].size()==0) continue;\n        int next=g[now][i].first;\n        int cost=g[now][i].second;\n        for(int j=0;j<v[i].size();j++){\n            int target=v[i][j];\n            ma[now][target]=max(cost,ma[next][target]);\n            ma[target][now]=max(cost,ma[next][target]);\n        }\n    }\n    \n    for(int i=0;i<g[now].size();i++){\n        if(v[i].size()==0) continue;\n        for(int j=i+1;j<g[now].size();j++){\n            if(v[j].size()==0) continue;\n            for(int k=0;k<v[i].size();k++){\n                for(int l=0;l<v[j].size();l++){\n                    ma[v[i][k]][v[j][l]]=max(ma[v[i][k]][now],ma[v[j][l]][now]);\n                    ma[v[j][l]][v[i][k]]=max(ma[v[i][k]][now],ma[v[j][l]][now]);\n                }\n            }\n        }\n    }\n    res.push_back(now);\n    return res;\n}\n\nint main(){\n  cin>>N>>M;\n  vector<Edge> edges;\n  for(int i=0;i<M;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;\n      b--;\n      edges.push_back(Edge(a,b,c));\n  }\n\n  ll ans=kruskal(N,edges);\n  vector<int> x=dfs(0);\n\n  cin>>Q;\n  for(int i=0;i<Q;i++){\n      int s,t;\n      cin>>s>>t;\n      s--;\n      t--;\n      cout<<ans-ma[s][t]<<endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v)const{\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\ntemplate<class T> class max_cost_on_path{\npublic:\n    const int max_pow=20;\n    vector<vector<T>> max_cost;\n    const lca_solver* const ls;\n    max_cost_on_path(const lca_solver &ls_,std::vector<std::unordered_map<int,T>> &cost):ls(&ls_),max_cost(max_pow){\n        const int n=ls->children.size();\n        for(int i=0; i<n; ++i) max_cost[i].resize(n);\n        for(int i=0; i<n; ++i){\n            if(i==ls->root) continue;\n            int j=ls->parent_pow2[0][i];\n            max_cost[0][i]=cost[i][j];\n        }\n        for(int i=1; i<max_pow; ++i){\n            for(int j=0; j<n; ++j){\n                if(ls->depth[j]-(1<<i)<0) continue;\n                max_cost[i][j]=std::max(max_cost[i-1][j],max_cost[i-1][ls->parent_pow2[i-1][j]]);\n            }\n        }\n    }\n\n    T sub(int u,int v)const{\n        T res=0;\n        for(int i=max_pow-1; i>=0; --i){\n            if(ls->depth[u]-ls->depth[v]>=(1<<i)){\n                res=max(res,max_cost[i][u]);\n                u=ls->parent_pow2[i][u];\n            }\n        }\n        return res;\n    }\n\n    T calc(int u,int v)const{\n        int lca=ls->lca(u,v);\n        return max(sub(u,lca),sub(v,lca));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    vector<unordered_map<int,int>> cost(n);\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n        cost[a][b]=cost[b][a]=c;\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    int64_t sum_cost=0;\n    vector<vector<int>> mst(n);\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        mst[e.from].push_back(e.to);\n        mst[e.to].push_back(e.from);\n    }\n\n    int root=0;\n    vector<vector<int>> children(n);\n    function<void(int,int)> dfs=[&](int u,int p){\n        for(int v:mst[u]){\n            if(v==p) continue;\n            children[u].push_back(v);\n            dfs(v,u);\n        }\n    };\n    dfs(root,-1);\n    lca_solver ls(children,root);\n    max_cost_on_path<int> mcop(ls,cost);\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-mcop.calc(s,t) << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\n\nclass lca_solver{\n\tpublic:\n    vector<vector<int>> children;\n    int root;\n    // if root,parent is -1.\n    vector<int> parent;\n    vector<int> depth;\n    vector<vector<int>> parent_pow2;\n    lca_solver(vector<vector<int>> &children_,int root_)\n        : children(children_),root(root_){\n        calc_parent_and_depth();\n        calc_parent_pow2();\n    };\n    int lca(int u,int v){\n        // make sure depth(u) > depth(v).\n        if(depth[u] < depth[v]) swap(u,v);\n        for(size_t k=0;k<parent_pow2.size();k++){\n            if(((depth[u] - depth[v]) >> k) & 1){\n                u = parent_pow2[k][u];\n            }\n        }\n        if(u == v) return u;\n        for(int k=(int)parent_pow2.size()-1;k>=0;k--){\n            if(parent_pow2[k][u] != parent_pow2[k][v]){\n                u = parent_pow2[k][u];\n                v = parent_pow2[k][v];\n            }\n        }\n        return parent_pow2[0][u];\n    }\n\tprivate:\n    void calc_parent_and_depth(){\n        parent = vector<int>(children.size(),-1);\n        depth = vector<int>(children.size(),-1);\n        sub_calc_parent_and_depth(root,-1,0);\n    }\n    void sub_calc_parent_and_depth(int cur,int par,int dep){\n        parent[cur] = par;\n        depth[cur] = dep;\n        for(int child : children[cur]){\n            if(child != par){\n                sub_calc_parent_and_depth(child,cur,dep+1);\n            }\n        }\n    }\n    void calc_parent_pow2(){\n        // parent_pow2[k][i] = 2^k parent of node i.\n        parent_pow2 = vector<vector<int>>(ceil(log(children.size())/log(2)+1),\n                                          vector<int>(children.size(),-1));\n        parent_pow2[0] = parent;\n        for(size_t k=0;k+1<parent_pow2.size();k++){\n            for(size_t v=0;v<children.size();v++){\n                if(parent_pow2[k][v] >= 0){\n                    parent_pow2[k+1][v] = parent_pow2[k][parent_pow2[k][v]];\n                }\n            }\n        }\n    }\n};\n\ntemplate<class T> class segtree{\npublic:\n    int n,size_;\n    vector<T> dat;\n    function<T(T,T)> fun_;\n    T id_;\n    segtree()=default;\n    segtree(int size,function<T(T,T)> fun,T id,T initial_value){ init(size,fun,id,initial_value); }\n    void init(int size,function<T(T,T)> fun,T id,T initial_value){\n        size_=size;\n        fun_=fun;\n        id_=id;\n        n=1;\n        while(n<size) n*=2;\n        dat.assign(2*n-1,id);\n        for(int i=0; i<size; ++i) update(i,initial_value);\n    }\n    int size()const{ return size_; }\n    void update(int k, T a) {\n        k+=n-1; // leaf\n        dat[k]=a;\n        while(k>0) {\n            k=(k-1)/2;\n            dat[k]=fun_(dat[k*2+1],dat[k*2+2]);\n        }\n    }\n    T at(int index){ return dat[index+n-1]; }\n    void add(int k,T a){ update(k,at(k)+a); }\n    T query(int a,int b) { return query(a,b,0,0,n); }\n    T query(int a,int b,int k,int l,int r) {\n        if(r<=a or b<=l) return id_;\n        if(a<=l and r<=b) return dat[k];\n        int m=(l+r)/2;\n        return fun_(query(a,b,k*2+1,l,m),query(a,b,k*2+2,m,r));\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n    union_find uf(n);\n    vector<bool> use(m);\n    int sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        use[i]=true;\n    }\n\n    vector<vector<pair<int,int>>> graph(n);\n    rep(i,0,m){\n        if(!use[i]) continue;\n        graph[edges[i].from].push_back(make_pair(edges[i].to,edges[i].cost));\n        graph[edges[i].to].push_back(make_pair(edges[i].from,edges[i].cost));\n    }\n\n    vector<vector<int>> max_cost(n,vector<int>(n));\n    vector<bool> done(n);\n    function<void(int,int,int)> dfs=[&](int s,int u,int ma){\n        done[u]=true;\n        max_cost[s][u]=ma;\n        for(auto &p:graph[u]){\n            if(done[p.first]) continue;\n            dfs(s,p.first,max(ma,p.second));\n        }\n    };\n    rep(i,0,n){\n        fill(done.begin(),done.end(),false);\n        dfs(i,i,0);\n    }\n\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-max_cost[s][t] << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b)  for(int i=(a),i##formax=(b);i< i##formax;i++)\n#define FORR(i,a,b) for(int i=(a),i##formin=(b);i>=i##formin;i--)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x=max((x),(y))\n#define mins(x,y) x=min((x),(y))\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define all(a) ((a).begin()),((a).end())\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define bit(n) (1LL<<(n))\ntypedef long long ll;\ntypedef __int128_t lll;\ntemplate<class T>using V=vector<T>;\ntemplate<class T>using VV=V<V<T>>;\ntemplate<class T,class Y>using P=pair<T,Y>;\ntemplate<class T,class Y>ostream& operator<<(ostream&o,P<T,Y>&p){return o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";}\ntemplate<class T>ostream& operator<<(ostream&o,V<T>&v){for(T&t:v)o<<t<<\",\";return o;}\ntemplate<class T>void uniq(V<T>&v){sort(all(v));v.erase(unique(all(v)), v.end());}\n\nlll gcd(lll a,lll b,lll&x,lll&y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll modInv(ll a,ll m){lll x,y;gcd(a,m,x,y);return(x%m+m)%m;}\nll modPow(lll a,lll n,ll m){lll p=1;for(;n;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return p;}\n//V<ll>Fac,Rac;void setF(int n,int mod){Fac=Rac=V<ll>(++n);Fac[0]=1;FOR(i,1,n)Fac[i]=Fac[i-1]*i%mod;Rac[n-1]=modInv(Fac[n-1],mod);FORR(i,n-1,1)Rac[i-1]=Rac[i]*i%mod;}\n//ll comb(int a,int b,int m){return a<b||b<0?0:Fac[a]*Rac[b]%m*Rac[a-b]%m;}\n\nconst int IINF = 1e9+6;\nconst ll LINF = 1e18;\nconst int MOD = 1e9+7; //998244353;\nconst int N = 1e5;\nstruct UnionFind{\n  vector<int> p;\n  void init(int n){\n    p.assign(n, -1);\n  }\n  int find(int a){\n    return p[a] < 0 ? a : p[a] = find(p[a]);\n  }\n  void merge(int a, int b){\n    p[a] = b;\n  }\n} uf;\nstruct LCA{\n  int ln;\n  vector<vector<int>> p;\n  vector<int> d;\n  int root(int a, int b){\n    if(d[a] > d[b]) swap(a, b);\n    int s = d[b] - d[a];\n    for(int i=0; i<ln; i++) if((1<<i)&s) b = p[i][b];\n    if(a==b) return a;\n    for(int i=ln-1; i>=0; i--) if(p[i][a] != p[i][b]) a = p[i][a], b = p[i][b];\n    return p[0][a];\n  }\n  void build(const vector<vector<int>>&G, int r){\n    int n = G.size();\n    for(ln=1; (1<<ln)<n; ln++);\n    p.assign(ln, vector<int>(n));\n    d.resize(n);\n    function<void (int, int, int)> dfs = [&](int a, int z, int f){\n      p[0][a] = z;\n      d[a] = f;\n      for(int b:G[a]) if(z!=b) dfs(b, a, f+1);\n    };\n    dfs(r, r, 0);\n    for(int i=1; i<ln; i++)for(int j=0; j<n; j++) p[i][j] = p[i-1][p[i-1][j]];\n  }\n} lca;\n\nint n, m, q;\nV<P<int, P<int, int>>> v;\nVV<int> e;\nV<int> d;\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  uf.init(n*2-1);\n  FOR(_, 0, m){\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    v.eb(c, mp(a, b));\n  }\n  e.assign(n*2-1, V<int>());\n  sort(all(v));\n  int c = n;\n  ll ans = 0;\n  for(auto p:v){\n    int a = uf.find(p.se.fi);\n    int b = uf.find(p.se.se);\n    if(a!=b){\n      uf.merge(a, c);\n      uf.merge(b, c);\n      e[c].pb(a);\n      e[c].pb(b);\n      d.pb(p.fi);\n      ans += p.fi;\n      c++;\n    }\n  }\n  lca.build(e, n*2-2);\n  cin >> q;\n  FOR(_, 0, q){\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int r = lca.root(s, t);\n    cout << ans-d[r-n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<unordered_map>\nusing namespace std;\n#define MOD 1000000007\n#define REP(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//sortは初期で昇順 greater<hoge>()で降順\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll max_flow(Graph & G, ll s, ll t)\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll Pow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\nll cost[4001][4001];\n\nvoid dfs(Graph &graph, ll v, ll ma, Array &used, ll s) {\n\tused[v] = 1;\n\tREP(i, graph[v].size()) {\n\t\tif (used[graph[v][i].to] == 0) {\n\t\t\tcost[s][graph[v][i].to] = max(ma, graph[v][i].cap);\n\t\t\tdfs(graph, graph[v][i].to, max(ma, graph[v][i].cap), used, s);\n\t\t}\n\t}\n}\n\n\nint main() {\n\tll n, m;\n\tcin >> n >> m;\n\tUnionFind uni(n);\n\tvector<pair<ll, P>> edge(m);\n\tll total = 0;\n\tREP(i, m) {\n\t\tcin >> edge[i].second.first >> edge[i].second.second >> edge[i].first;\n\t\tedge[i].second.first--; edge[i].second.second--;\n\t}\n\tsort(all(edge));\n\tGraph graph(n);\n\tREP(i, m) {\n\t\tif (uni.root(edge[i].second.first) != uni.root(edge[i].second.second)) {\n\t\t\tadd_edge(graph, edge[i].second.first, edge[i].second.second, edge[i].first, true, edge[i].first);\n\t\t\tuni.unionSet(edge[i].second.first, edge[i].second.second);\n\t\t\ttotal += edge[i].first;\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tArray used(n, 0);\n\t\tdfs(graph, i, 0, used, i);\n\t}\n\tll q;\n\tcin >> q;\n\tREP(i, q) {\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\tcout << total- cost[s][t] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ull INF = ULLONG_MAX;\nconst ll MOD = 998244353;\n\ntypedef ll Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Graph> Prim(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tGraph T(n);\n\tWeight total = 0;\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-1, r, 0));\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif (visited[e.dst])\n\t\t\tcontinue;\n    if(e.src>=0){\n  \t\tT[e.src].push_back(e);\n      T[e.dst].push_back({e.dst,e.src,e.weight});\n    }\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tfor (Edge f:g[e.dst])\n\t\t\tif (!visited[f.dst])\n\t\t\t\tQ.push(f);\n\t}\n\treturn pair<Weight, Graph>(total, T);\n}\n\n\n\ninline int get_min2pow(int n) {\n\tint res = 1;\n\twhile (res < n)\n\t\tres *= 2;\n\treturn res;\n}\n\n///Segment Tree////////\n\ntemplate<typename T,T dval>\nstruct segtree {\n\tint N;\n\tvector<T> node;\n\t//例外値　ex)INF,0\n\tT default_value = dval;\n\tstatic inline T merge(const T& l, const T& r) {\n\t\t//RMQ\n\t\treturn max(l,r);\n\t\t//RSQ\n\t\t//return l+r;\n\t}\n\tsegtree(int n) {\n\t\tN = get_min2pow(n);\n\t\tnode.resize(2 * N, default_value);\n\t}\n\tsegtree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tN = get_min2pow(sz);\n\t\tnode.resize(2 * N, default_value);\n\t\tfor (int i = 0; i < sz; i++)\n\t\t\tnode[i + N - 1] = v[i];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t\tnode[i] = merge(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\t// update k th element\n\tvoid update(int k, T val) {\n\t\tk += N - 1; // leaf\n\t\tnode[k] = val;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l)\n\t\t\treturn default_value;\n\t\tif (a <= l and r <= b)\n\t\t\treturn node[k];\n\t\tint m = (l + r) / 2;\n\t\tT vl = query(a, b, k * 2 + 1, l, m);\n\t\tT vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn merge(vl, vr);\n\t}\n};\n\n\nstruct HLDecomposition{\n  int V;\n  vint dep,par,heavy,head,id,size,dat;\n  segtree<ll,0> RMQ;\n  HLDecomposition(const Graph &g,int root=0)\n  :V(g.size()),dep(V,0),par(V,-1),heavy(V,-1),head(V),id(V),size(V,1),dat(V,-1),RMQ(V){\n    //make par\n    par[root]=0;\n    queue<int> Q;\n    Q.push(root);\n    while(!Q.empty()){\n      int v=Q.front();\n      Q.pop();\n      for(const Edge &w:g[v])if(par[w.dst]<0){\n        Q.push(w.dst);\n        par[w.dst]=v;\n        dat[w.dst]=w.weight;\n      }\n    }\n    par[root]=-1;\n    //calculate heavy\n    Q.push(root);\n    while(!Q.empty()){\n      int v=Q.front();\n      Q.pop();\n      for(const Edge &w:g[v]){\n        if(w.dst==par[v])continue;\n        dep[w.dst]=dep[v]+1;\n        Q.push(w.dst);\n      }\n    }\n    repeat(v,V){\n      if(par[v]<0)continue;\n      size[par[v]]+=size[v];\n      if(heavy[par[v]]<0||size[v]>size[heavy[par[v]]])heavy[par[v]]=v;\n    }\n    //calculate id\n    int idx=0;\n    repeat(v,V){\n      if(par[v]<0||heavy[par[v]]!=v){\n        for(int w=v;w!=-1;w=heavy[w]){\n          head[w]=v;\n          id[w]=idx++;\n          RMQ.update(id[w],dat[w]);\n        }\n      }\n    }\n  }\n  // [u,v]\n  ll query(int u,int v){\n    ll ret=0;\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]!=head[v]){\n        ret = max(ret,RMQ.query(id[u],id[v]+1));\n        v=par[head[v]];\n      }else{\n        if(u!=v)ret = max(ret,RMQ.query(id[u]+1,id[v]+1));\n        return ret;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]==head[v])return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\nint main(){\n  int N,M;cin>>N>>M;\n  Graph g(N);\n  repeat(i,M){\n    int a,b;\n    Weight c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back({a,b,c});\n    g[b].push_back({b,a,c});\n  }\n  pair<Weight, Graph> tree=Prim(g,0);\n  HLDecomposition hld(tree.second,0);\n  int Q;cin>>Q;\n  repeat(q,Q){\n    int s,t;cin>>s>>t;\n    s--;t--;\n    ll ans=tree.first-hld.query(s,t);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n/*\ntemplate<typename T>\nstruct Treap {\n\tdouble drand() { // random number in [0, 1]\n\t\tstatic random_device rd;\n\t\tstatic mt19937 mt(rd());\n\t\treturn (unsigned)mt() / (double)numeric_limits<unsigned>::max();\n\t}\n\tT v;\n\tdouble p;\n\tint cnt;\n\tTreap* lch;\n\tTreap* rch;\n\tTreap(T v) : v(v), p(drand()), cnt(1), lch(NULL), rch(NULL) { }\n\tTreap* update() {\n\t\tthis->size = size(this->lch) + size(this->rch) + 1;\n\t\treturn this;\n\t}\n\tstatic int size(Treap* t) {\n\t\tif(!t) return 0;\n\t\telse return t->cnt;\n\t}\n\tstatic Treap* merge(Treap* l, Treap* r) {\n\t\tif(!l || !r) {\n\t\t\tif(!l) return r;\n\t\t\telse return l;\n\t\t}\n\t\tif(l->p >= r->p) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn l->update();\n\t\t} else {\n\t\t\tr->lch = merge(r->lch, l);\n\t\t\treturn r->update();\n\t\t}\n\t}\n\tstatic pair<Treap*, Treap*> split(Treap* t, int k) {\n\t\t// split [0, k) and [k, n)\n\t\tif(k == 0) return {NULL, t};\n\t\tif(!(t->l)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else if(!(t->r)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else {\n\n\t\t}\n\t}\n\tTreap* insert() {\n\t}\n\tTreap* erase() {\n\t}\n\tT operator[](int k) {\n\t}\n};\n*/\n\nclass union_find {\npublic:\n\tunion_find(int n)\n\t: par_(n, -1)\n\t{}\n\tvoid init(int n) {\n\t\tpar_.assign(n, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn par_[x] < 0 ? x : par_[x] = root(par_[x]);\n\t}\n\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif(x == y) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif(par_[x] < par_[y]) {\n\t\t\t\tpar_[x] += par_[y];\n\t\t\t\tpar_[y] = x;\n\t\t\t} else {\n\t\t\t\tpar_[y] += par_[x];\n\t\t\t\tpar_[x] = y;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn -par_[root(x)];\n\t}\n\nprivate:\n\tstd::vector<int> par_;\n};\n\nvoid dfs(int v, int par, int c, vector<vector<P>>& g, vector<P>& p, vector<int>& d, int dpt) {\n\tp[v] = {par, c};\n\td[v] = dpt;\n\tfor(auto adj: g[v]) {\n\t\tif(adj.first == par) continue;\n\t\tdfs(adj.first, v, adj.second, g, p, d, dpt + 1);\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<vector<P>> g(n);\n\tvector<pair<ll, P>> e(m);\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tg[a].pb({b, c});\n\t\tg[b].pb({a, c});\n\t\te[i] = {c, {a, b}};\n\t}\n\tsort(ALL(e));\n\tunion_find uf(n);\n\tvector<vector<P>> mst(n);\n\tll sum = 0;\n\tfor(auto edge: e) {\n\t\tif(uf.same(edge.second.first, edge.second.second)) continue;\n\t\tuf.unite(edge.second.first, edge.second.second);\n\t\tsum += edge.first;\n\t\tmst[edge.second.first].pb({edge.second.second, edge.first});\n\t\tmst[edge.second.second].pb({edge.second.first, edge.first});\n\t}\n\tvector<P> p(n, {-1, 0});\n\tvector<int> d(n, 0);\n\tdfs(0, -1, 0, mst, p, d, 0);\n\tint q;\n\tcin >> q;\n\tREP(i, q) {\n\t\tll mx = 0;\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\twhile(s != t) {\n\t\t\tif(d[s] >= d[t]) {\n\t\t\t\tmx = max(mx, p[s].second);\n\t\t\t\ts = p[s].first;\n\t\t\t} else {\n\t\t\t\tmx = max(mx, p[t].second);\n\t\t\t\tt = p[t].first;\n\t\t\t}\n\t\t}\n\t\tcout << sum - mx << endl;\n\t}\n\treturn 0;\n}\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<endl;}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\nvoid print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\nvoid YN(bool b){print(b?\"YES\":\"NO\");}void PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");}\nvoid Yn(bool b){print(b?\"Yes\":\"No\");}void Pi(bool b){print(b?\"Possible\":\"Impossible\");}\nvoid yn(bool b){print(b?\"yes\":\"no\");}void pi(bool b){print(b?\"possible\":\"impossible\");}\nconst int MD=1e9+7;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vi B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\nclass UnionFind{vi p,r,s;public:UnionFind(int N){p=r=vi(N);s=vi(N,1);fr(i,N){p[i]=i;}}int find(int i){return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){if(r[a=find(a)]>r[b=find(b)]){swap(a,b);}s[b]+=s[a];r[p[a]=b]+=r[a]==r[b];}bool same(int a,int b){return find(a)==find(b);}int size(int x){return s[find(x)];}};\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){return pow(x,p-2,p);}\nvpll fact(const int n,const int p){vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\nll segsum(vl&s,int l,int r){l|=s.size()>>1;r|=s.size()>>1;if(l>r){return 0;}if(l==r){return s[l];}ll z=s[l]+s[r];for(;l>>1<r>>1;l>>=1,r>>=1){l&1||(z+=s[l^1]);r&1&&(z+=s[r^1]);}return z;}\nvoid segadd(vl&s,int i,ll x){s[i|=s.size()>>1]+=x;for(;i>>1>=1;i>>=1){s[i>>1]=s[i]+s[i^1];}}\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\n// (int) * (int) => (int)\n// (int) / (int) => (int)\n\nll dfs(vector<vpli>&E,int i,int p,int T){\n\tif(i!=p&&E[i].size()==1)return 0;\n\tll m=0;\n\tfor(pli v:E[i])if(v.second!=p){\n\t\tif(v.second==T)return v.first;\n\t\tll d=dfs(E,v.second,i,T);\n\t\tif(d)return max(d,v.first);\n\t}\n\treturn 0;\n}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tusing P=pair<ll,pii>;\n\tvector<P>E;\n\tfr(i,M){\n\t\tint a,b;ll c;cin>>a>>b>>c;\n\t\tE<<P{c,{a-1,b-1}};\n\t}\n\tSort(E);\n\tUnionFind uf(N);\n\tll z=0;\n\tvector<vpli>EE(N);\n\tfor(P e:E){\n\t\tint a=e.second.first,b=e.second.second,c=e.first;\n\t\tif(!uf.same(a,b)){\n\t\t\tuf.unite(a,b);\n\t\t\tz+=c;\n\t\t\tEE[a]<<pli{c,b};\n\t\t\tEE[b]<<pli{c,a};\n\t\t}\n\t}\n\tint Q;cin>>Q;\n\tfr(q,Q){\n\t\tint S,T;cin>>S>>T;\n\t\tprint(z-dfs(EE,S-1,S-1,T-1));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// mt19937 mert(LL(time(0)));\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(b * b /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\nconst int MAX_V = 1010;\n\nclass UnionFind {\npublic:\n    // コンストラクタ\n    explicit UnionFind(int N) : V_NUM(N) {\n        for (int i = 0; i < V_NUM; ++i) {\n            par[i] = i;\n        }\n        fill(rank, rank + V_NUM, 0);\n    }\n\n    // xの親を返す+更新\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n\n    // xとyを含むグループを統合する\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y) return;\n\n        // rank[x] >= rank[y]にする\n        if (rank[x] < rank[y]) swap(x, y);\n        par[y] = x;\n        if (rank[x] == rank[y]) ++rank[x];\n    }\n\n    // xとyが同じグループに属するか判定\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int V_NUM;\n    int par[MAX_V], rank[MAX_V];\n};\n\ntuple<ll, int, int> edges[500000];\nvector<pair<int, ll>> path[5000];\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        cin >> a >> b >> c;\n        edges[i] = mt(c, --a, --b);\n    }\n\n    sort(edges, edges + M);\n    UnionFind uf(N);\n\n    // 最小全域木の辺とコスト\n    ll total = 0;\n\n    // Kruskalで最小全域木を構築\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        ll c;\n        tie(c, a, b) = edges[i];\n\n        if (uf.same(a, b)) continue;\n        uf.unite(a, b);\n        total += c;\n        path[a].push_back(mp(b, c));\n        path[b].push_back(mp(a, c));\n    }\n\n    // d[v] = 0を親としたときのノードvの深さ\n    int d[N];\n    fill(d, d + N, -1);\n    d[0] = 0;\n\n    // lca[x][v] = (vから2^xだけ遡った頂点,\n    //              そこに行くまでに辿った辺でのコストの最大値)\n    pair<int, ll> lca[15][N];\n    lca[0][0] = mp(0, 0);\n\n    // 幅優先探索でdとlca[0]を埋める\n    queue<int> que;\n    que.push(0);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto p : path[v]) {\n            int sv;\n            ll cost;\n            tie(sv, cost) = p;\n            if (d[sv] >= 0) continue;\n\n            d[sv] = d[v] + 1;\n            lca[0][sv] = mp(v, cost);\n            que.push(sv);\n        }\n    }\n\n    // lcaを埋める\n    for (int x = 1; x < 15; ++x) {\n        for (int v = 0; v < N; ++v) {\n            int mid = lca[x - 1][v].first;\n            ll cost = max(lca[x - 1][v].second, lca[x - 1][mid].second);\n\n            lca[x][v] = mp(lca[x - 1][mid].first, cost);\n        }\n    }\n\n    // ようやくクエリ処理\n    int Q;\n    cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int s, t;\n        cin >> s >> t;\n        --s;\n        --t;\n\n        ll trim = 0;\n        if (d[s] > d[t]) swap(s, t);\n        // d[s] <= d[t]\n        // tの深さをsに合わせる\n\n        while (d[s] < d[t]) {\n            // sより浅くないtの祖先を漁る\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && d[s] > d[lca[x][t].first]) continue;\n                trim = max(trim, lca[x][t].second);\n                t = lca[x][t].first;\n                break;\n            }\n        }\n\n        // LCAを探す\n        while (s != t) {\n            for (int x = 14; x >= 0; --x) {\n                // 祖先が浅すぎる\n                if (x > 0 && lca[x][s].first == lca[x][t].first) continue;\n                trim = max(trim, max(lca[x][s].second, lca[x][t].second));\n                s = lca[x][s].first;\n                t = lca[x][t].first;\n                break;\n            }\n        }\n\n        cout << total - trim << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\n    public:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> parent;\n\n    //-1で初期化。最初はすべてバラバラ\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n    }\n\n    //Aがどのグループに属しているか(Aの根)を調べる\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A){\n        return -parent[root(A)];\n    }\n\n    //AとBをくっつける\n    bool unite(int A, int B) {\n    //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        //既にくっついているからくっつけない\n        if(A == B) return false; \n\n        //大きいほう(A)に小さいほう(B)をくっつける\n        //大小が逆ならひっくり返す\n        if(size(A) < size(B)) swap(A,B);\n\n        //Aのサイズを更新する\n        parent[A] += parent[B];\n        //Bの親をAに変更する\n        parent[B] = A;\n\n        return true;\n    }\n\n    //AとBが同じグループならtrueを返す\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n\nvector<vector<array<ll,2>>> v(4444);\nll sum = 0;\nbool used[4444];\nll ans[4040][4040];\n\nvoid dfs(int r,int p, ll dist){\n    used[p]=1;\n    ans[r][p] = dist;\n    for(auto i:v[p]){\n        if(!used[i[0]]){\n            dfs(r,i[0],max(dist,i[1]));\n        }\n    }\n}\n\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n    \n    ll n,m;\n    cin>>n>>m;\n    UnionFind uni(n);\n    array<ll,3> a[m];\n    for(int i=0;i<m;i++){\n        ll e,b,c;\n        cin>>e>>b>>c;\n        e--,b--;\n        a[i] = {c,e,b};\n    }\n    sort(a,a+m);\n\n    for(int i=0;i<m;i++){\n        if(!uni.same(a[i][1],a[i][2])){\n            sum += a[i][0];\n            uni.unite(a[i][1],a[i][2]);\n            v[a[i][1]].push_back({a[i][2],a[i][0]});\n            v[a[i][2]].push_back({a[i][1],a[i][0]});\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++) used[j]=0;\n        dfs(i,i,0);\n    }\n    int q;\n    cin>>q;\n    while(q--){\n        int s,t;\n        cin>>s>>t;\n        s--,t--;\n        cout << sum - ans[s][t] << \"\\n\";\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <fstream>\n\n#define DIV 1000000007\n\nusing namespace std;\n\nlong long N, M, Q;\nlong long S[100005];\nlong long T[100005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >tree[4005];\n\n//           cost,   ,  dst\nvector<pair<long long, long long> >ttree[4005];\n\nvoid solve(long long s, long long t){\n\tset<long long> done;\n\t//                     cost  ,   dst\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long> >, greater<pair<long long, long long> > > Q;\n\tlong long ans = 0;\n\tQ.push(make_pair(0, s));\n\tQ.push(make_pair(0, t));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, dst;\n\t\tcost = Q.top().first;\n\t\tdst = Q.top().second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tans += cost;\n\t\tdone.insert(dst);\n\n\t\tfor(int i = 0; i < ttree[dst].size(); i++){\n\t\t\tlong long ncost = ttree[dst][i].first;\n\t\t\tlong long next = ttree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, next));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nvoid prepare(){\n\tset<long long> done;\n\t//                     cost  ,      src\t,     dst\n\tpriority_queue<pair<long long, pair<long long, long long> >, vector<pair<long long, pair<long long, long long> > >, greater<pair<long long, pair<long long, long long> > > > Q;\n\tQ.push(make_pair(0, make_pair(-1, 0)));\n\twhile(!Q.empty() && done.size() < N){\n\t\tlong long cost, src, dst;\n\t\tcost = Q.top().first;\n\t\tsrc = Q.top().second.first;\n\t\tdst = Q.top().second.second;\n\t\tQ.pop();\n\t\tif(done.count(dst) != 0){\n\t\t\tcontinue;\n\t\t}\n\t\tdone.insert(dst);\n\t\tif(src != -1){\n\t\t\tttree[src].push_back(make_pair(cost, dst));\n\t\t\tttree[dst].push_back(make_pair(cost, src));\n\t\t}\n\t\tfor(int i = 0; i < tree[dst].size(); i++){\n\t\t\tlong long ncost = tree[dst][i].first;\n\t\t\tlong long next = tree[dst][i].second;\n\t\t\tif(done.count(next) != 0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQ.push(make_pair(ncost, make_pair(dst, next)));\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin >> N >> M;\n\tfor(int i = 0; i < M; i++){\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\ttree[a].push_back(make_pair(c, b));\n\t\ttree[b].push_back(make_pair(c, a));\n\t}\n\tcin >> Q;\n\tfor(int i = 0; i < Q; i++){\n\t\tcin >> S[i] >> T[i];\n\t\tS[i]--;T[i]--;\n\t}\n\tif(Q > 3000){\n\t\treturn 1;\n\t}\n\t\n\tprepare();\n\n\treturn 0;\n\n\tfor(int i = 0; i < Q; i++){\n\t\tsolve(S[i], T[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<chrono>\n#include<stack>\n#include<fstream>\n#include<list>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,x) unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\n\nstruct edge\n{\n\tlong long from; long long to; long long cost; \n\tbool operator<(const edge& rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\npriority_queue<edge> pq;\n\nll const MAX = 4006;\nll dep[MAX];\nll parent_uf[MAX];\nll rk[MAX];\n\nvoid init(ll n) {\n\tfor (ll i = 1; i <= n; i++) {\n\t\tparent_uf[i] = i;\n\t\trk[i] = 1;\n\t}\n}\n\nll find(ll x) {\n\tif (parent_uf[x] == x) {\n\t\treturn x;\n\t}\n\tparent_uf[x] = find(parent_uf[x]);\n\treturn parent_uf[x];\n}\n\nbool same(ll x, ll y) {\n\treturn find(x) == find(y);\n}\n\nvoid unite(ll x, ll y) {\n\tif (!same(x, y)) {\n\t\tx = parent_uf[x];\n\t\ty = parent_uf[y];\n\t\tif (rk[x] < rk[y]) {\n\t\t\tparent_uf[x] = y;\n\t\t}\n\t\telse {\n\t\t\tparent_uf[y] = x;\n\t\t\tif (rk[x] == rk[y]) {\n\t\t\t\trk[x]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nll n, m, q;\nvector<edge> G[MAX];\n\nll make_tree() {\n\tll cnt = n - 1;\t\n\tll ttl = 0;\n\n\twhile (cnt > 0) {\n\t\tedge cur = pq.top();\n\t\tpq.pop();\n\t\tll cf = cur.from; ll ct = cur.to; ll cc = cur.cost;\n\t\tif (!same(cf, ct)) {\n\t\t\tunite(cf, ct);\n\t\t\tttl += cur.cost;\n\t\t\tG[cf].push_back({ cf,ct,cc });\n\t\t\tG[ct].push_back({ ct,cf,cc });\n\t\t\tcnt--;\n\t\t}\n\t}\n\treturn ttl;\n}\n\nll parent[MAX];\nll costing[MAX];\n\nvoid dfs() {\n\tparent[1] = 1;\n\tstack<ll> st;\n\tst.push(1);\n\tdep[1] = 0;\n\twhile (!st.empty()) {\n\t\tll cur = st.top();\n\t\tst.pop();\n\t\tfor (ll i = 0; i < SIZE(G[cur]); i++) {\n\t\t\t\n\t\t\tll next = G[cur][i].to;\n\t\t\tif (next == parent[cur]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//cout << cur << \" \" << next << endl;\n\t\t\tparent[next] = cur;\n\t\t\tdep[next] = dep[cur] + 1;\n\t\t\tcosting[next] = G[cur][i].cost;\n\t\t\t//cout << costing[next] << endl;\n\t\t\tst.push(next);\n\t\t}\n\t}\n}\n\nll dp[MAX][MAX] = {};\n\nll query(ll s, ll t, ll u) {\n\tif (s == t) {\n\t\treturn u;\n\t}\t\n\tif (dep[s] < dep[t]) {\n\t\tswap(s, t);\n\t}\n\n\tif (dp[s][t] != 0) {\n\t\treturn dp[s][t];\n\t}\n\tll v = max(u, costing[s]);\n\t//cout << v << \" ?\" << endl;\n\tdp[s][t] = query(parent[s], t, v);\n\treturn dp[s][t];\n}\n\nint main() {\n\tcin >> n >> m;\n\tinit(n);\n\tREP(i, 1, m) {\n\t\tll a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tpq.push({ a,b,c });\n\t}\n\tll ttl = make_tree();\n\tdfs();\n\tcin >> q;\n\tREP(i, 1, q) {\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tcout << ttl - query(s, t, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, q;\nint d[5010];\n\nstruct edge{\n   int to, cost;\n//    edge(int to, int cost):to(to), cost(cost){}\n};\nvector<edge> G[5010]; \n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       rep(i, 0, n) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nvector<pair<int, P> > es; \nvector<int> path;\nint pMAX[4010][4010];\nint cost[4010][4010];\n\nvoid dfs(int now, int pre, int MAX, int root){\n    // cout << \" \" << now << \" \" << pre << endl;\n    path[now] = pre;\n    pMAX[root][now] = MAX;\n    // if(now == dest) return;\n    rep(i, 0, G[now].size()){\n        int next = G[now][i].to;\n        if(next == pre) continue;\n        // path[next] = now;       \n        dfs(next, now, max(MAX, cost[now][next]), root);\n    }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    rep(i, 0, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        // G[a].push_back(edge{b, c});\n        // G[b].push_back(edge{a, c});\n        es.push_back(pair<int, P>(c, P(a, b)));\n        cost[a][b] = c;\n        cost[b][a] = c;\n    }\n    sort(all(es));\n    UF uf(n);\n    int sum = 0, cnt = 0;\n    rep(i, 0, es.size()){\n        int from = es[i].second.first;\n        int to = es[i].second.second;\n        if(uf.same(from, to) == false){\n            uf.unite(from, to);\n            sum += es[i].first;\n            G[from]. push_back(edge{to, es[i].first});\n            G[to]. push_back(edge{from, es[i].first});\n        }\n    }\n    // cout << sum << endl;\n    rep(i, 0, n){\n        path.clear(); path.resize(n, -1);\n        dfs(i, -1, 0, i);\n    }\n    cin >> q;\n    rep(i, 0, q){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        // path.clear(); path.resize(n, -1);\n        // dfs(s, -1, t);\n        cout << sum - pMAX[s][t] << endl;\n        // int MAX = 0;\n        // int now = t;\n        // while(now != s){\n        //     int next = path[now];\n        //     chmax(MAX, cost[now][next]);\n        //     now = next;\n        // }\n        // cout << sum - MAX << endl;\n        // rep(j, 0, path.size()){\n        //     cout << path[j] << \" \";\n        // }\n        // cout << endl;\n        // dijkstra(s);\n        // cout << d[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> vector<T> rev(vector<T> &a) {\n    vector<T> ret = a;\n    reverse(all(ret));\n    return ret;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int f, t;\n    T c;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return c < b.c; }\n    bool operator>(const edge &b) const { return c > b.c; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, c, id, ty);\n        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n        edges.emplace_back(f, t, c, id, ty);\n        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.f, t = e.t, ty = e.type;\n        T c = e.c;\n        add(f, t, c, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            T c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    fora(e, g.edges) chmin(dis[e.f][e.t], e.c);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].t;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        fora(e, edges)if (e.c != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n        g[t].emplace_back(t, f, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    if (g.edges.size() == 0)return true;\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\n\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\nvoid solve() {\n    cin >> n >> m;\n    digraph<> g(2 * k5);\n    rep(i, m) {\n        int f, t, c;\n        cin >> f >> t >> c;\n        --f, --t;\n        g.add(f, t, c);\n    }\n    sort(g.edges);\n    UnionFind uf(k5);\n    undigraph<> sg(4040);\n    fora(e, g.edges) {\n        if (uf.same(e.f, e.t))con;\n        uf.unite(e.f, e.t);\n        sg.add(e.f, e.t, e.c);\n        cou += e.c;\n    }\n\n    vvi(emi, 4040, 4040);\n    function<void(int, int, int, int)> ds = [&](int s, int i, int p, int ma) {\n        emi[s][i] = ma;\n        fort(gi, sg[i]) {\n            ds(s, t, i, max(ma, c));\n        }\n    };\n    rep(i, n){\n        ds(i, i, -1, -0);\n    }\n\n    cin >> q;\n    while (q--) {\n        dind(s, t);\n        cout << cou - emi[s][t] << endl;\n    }\n\n}\nint my(int n, vi a) {\n    return 0;\n}\nint sister(int n, vi a) {\n    return 0;\n}\n\nsigned main() {\n    solve();\n\n#define _arg n,a\n    //cin>>n;\n    //na(a,n);\n    //my(_arg);\n    //cout << my(_arg) << endl;\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 3);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            cout << n << endl;\n            cout << a << endl;\n            cout << \"正解 : \" << res << endl;\n            cout << \"出力 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#define llint long long\n\nusing namespace std;\n\nstruct edge{\n\tllint to, cost;\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint parent[4005];\nllint N, M, Q;\nvector< pair<llint, pair<llint, llint> > > vec;\nvector<edge> G[4005];\nllint dist[4005][4005];\n\nvoid init(){\n\tfor(llint i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t}\n}\n\nllint root(llint i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(llint i, llint j)\n{\n\treturn root(i) == root(j);\n}\n\nvoid unite(llint i, llint j)\n{\n\tllint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(llint v, llint prev, llint s, llint val)\n{\n\tdist[s][v] = val;\n\tfor(llint i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i].to == prev) continue;\n\t\tdfs(G[v][i].to, v, s, max(val, G[v][i].cost));\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\tllint a, b, c;\n\tfor(llint i = 0; i < M; i++){\n\t\tcin >> a >> b >> c;\n\t\tvec.push_back( make_pair(c, make_pair(a, b) ) );\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tinit();\n\tllint cost = 0;\n\tfor(llint i = 0; i < vec.size(); i++){\n\t\ta = vec[i].second.first, b = vec[i].second.second;\n\t\tif(same(a, b)) continue;\n\t\tunite(a, b);\n\t\tcost += vec[i].first;\n\t\tG[a].push_back(edge(b, vec[i].first));\n\t\tG[b].push_back(edge(a, vec[i].first));\n\t}\n\t\n\tfor(llint i = 1; i <= N; i++){\n\t\tdfs(i, -1, i, 0);\n\t}\n\t\n\tcin >> Q;\n\tllint S, T;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> S >> T;\n\t\tcout << cost - dist[S][T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define MAX_V 5000\n#define ll long long\nusing namespace std;\n\nll par[MAX_V],ran[MAX_V];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\tran[i] = i;\n\t}\n}\n\nll find(ll x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(ll x, ll y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(ran[x]<ran[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(ran[x]==ran[y]) ran[x]++;\n\t}\n}\n\nbool same(ll x, ll y){\n\treturn find(x)==find(y);\n}\n\nstruct edge{ll u,v,cost;};\nll n,m;\nvector<edge> E;\nvector<edge> G[MAX_V];\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost<e2.cost;\n}\n\nll kruscal(){\n\tsort(E.begin(),E.end(),comp);\n\tinit(n);\n\tlong long res = 0;\n\tfor(int i=0;i<E.size();i++){\n\t\tedge e = E[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t\tG[e.u].push_back({e.u,e.v,e.cost});\n\t\t\tG[e.v].push_back({e.v,e.u,e.cost});\n\t\t}\n\t}\n\treturn res;\n}\n\nbool used[MAX_V];\nll d[MAX_V];\nll x[MAX_V][MAX_V];\nvoid dfs(int s){\n\tused[s] = true;\n\tfor(int i=0;i<G[s].size();i++){\n\t\tedge e = G[s][i];\n\t\tif(!used[e.v]){\n\t\t\td[e.v] = max(d[s],e.cost);\n\t\t\tdfs(e.v);\n\t\t}\n\t}\n}\n\nint main(){\n\tint i,j;\n\tcin >> n >> m;\n\tfor(i=0;i<m;i++){\n\t\tll a,b,c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedge e;\n\t\te.u = a; e.v = b; e.cost = c;\n\t\tE.push_back(e);\n\t}\n\t\n\tll res = kruscal();\n\t\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tused[j] = false;\n\t\t\td[j] = 0;\n\t\t}\n\t\tdfs(i);\n\t\tfor(j=0;j<n;j++){\n\t\t\tx[i][j] = d[j];\n\t\t}\n\t}\n\tint q;\n\tcin >> q;\n\tfor(i=0;i<q;i++){\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\ts--; t--;\n\t\tcout << res - x[s][t] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#ifndef ___Rank_Union_Find\n#define ___Rank_Union_Find\n\n#include <vector>\n\n// ------ Class ------ //\nclass UnionFind {\nprivate:\n\tunsigned size_; std::vector<unsigned> par, rank;\npublic:\n\tUnionFind() : size_(0), par(std::vector<unsigned>()), rank(std::vector<unsigned>()) {};\n\tUnionFind(unsigned size__) : size_(size__) {\n\t\tpar.resize(size_); rank.resize(size_);\n\t\tfor (unsigned i = 0; i < size_; i++) par[i] = i, rank[i] = 0;\n\t}\n\tunsigned size() { return size_; }\n\tunsigned root(unsigned x) { return par[x] == x ? x : par[x] = root(par[x]); }\n\tbool same(unsigned x, unsigned y) { return root(x) == root(y); }\n\tvoid unite(unsigned x, unsigned y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) par[x] = y;\n\t\telse if (rank[x] == rank[y]) par[y] = x, rank[x]++;\n\t\telse par[y] = x;\n\t}\n\tbool operator==(const UnionFind &u) { return par == u.par; }\n\tbool operator!=(const UnionFind &u) { return par != u.par; }\n};\n\n#endif\n\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct edge { int a, b, cost; };\nbool operator<(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint N, M, Q, s, t;\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tvector<edge> e(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d%d\", &e[i].a, &e[i].b, &e[i].cost);\n\t\te[i].a--; e[i].b--;\n\t}\n\tsort(e.begin(), e.end());\n\tscanf(\"%d\", &Q);\n\twhile (Q--) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tUnionFind uf(N); uf.unite(s, t);\n\t\tlong long sum = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tif (!uf.same(e[i].a, e[i].b)) {\n\t\t\t\tsum += e[i].cost;\n\t\t\t\tuf.unite(e[i].a, e[i].b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nstruct edge{\n    int from, to, cost;\n    bool operator<(const edge &another) const\n    {\n        return cost < another.cost;\n    };\n};\n\n//vector<edge> G[4000];\nvector<edge> MST[4000];\nvector<edge> es;\nbool used[4000];\nint max_edge[4000][4000];\n\nint N, M;\n\nvoid clear_used(){\n    for(int i = 0; i < N; i++) used[i] = false;\n}\n\nvoid dfs(int root, int cur, int max_e){\n    used[cur] = true;\n    max_edge[root][cur] = max_e;\n    for(int i = 0; i < MST[cur].size(); i++){\n        if(!used[MST[cur][i].to]){\n            dfs(root, MST[cur][i].to, max(max_e, MST[cur][i].cost));\n        }\n    }\n}\n\nint main(){\n    cin >> N >> M;\n    for(int i = 0; i < M ; i++){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        es.push_back(edge{a, b, c});\n    }\n    UnionFind uf(N);\n    sort(es.begin(), es.end());\n    long sum = 0;\n    for(int i = 0; i < M; i++){\n        int from = es[i].from;\n        int to = es[i].to;\n        int cost = es[i].cost;\n        if(uf.root(from) != uf.root(to)){\n            //cout << \"MST\" << endl;\n            MST[from].push_back(es[i]);\n            MST[to].push_back((edge){to, from, cost});\n            uf.unionSet(from, to);\n            sum += (long)cost;\n        }\n    }\n    for(int i = 0; i < N; i++){\n        clear_used();\n        dfs(i, i, 0);\n    }\n    int Q;\n    cin >> Q;\n    for(int i = 0; i < Q; i++){\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        //cout << max_edge[s][t] << endl;\n        cout << sum-max_edge[s][t] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPP(i,m,n) for(long long i=m;i<n;++i)\n#define rep(i,n) for(long long i = n-1;i>=0;--i)\n#define repp(i,n,m) for(long long i = n-1; i >= m; --i)\n#define ALL(N) (N.begin(),N.end())\n#define de cout << \"line : \" << __LINE__ << \" debug\" << endl;\n#define pb push_back\n#define pq priority_queue\n#define Dcout(N) cout << setprecision(20) << N << endl\nconstexpr long long INF = 2147483647;\nconstexpr long long INFF = 9223372036854775807;\n\nstruct edge{long long u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n    return e1.cost < e2.cost;\n}\n\n\nstruct UnionFind{\n    vector<long long> par,r;\n\n    //はじめに全てが根であるとしておく\n    UnionFind(long long N):par(N),r(N,1){iota(par.begin(),par.end(),0);}\n\n    long long root(long long x){//根に当たるまで再帰で探す\n        if(par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n\n    bool same(long long x,long long y){//つながっているかどうか判定\n        return par[x] == par[y];\n    }\n\n    long long size(long long x){ //根の大きさを判定する\n        return r[root(x)];\n    }\n\n    void unite(long long x, long long y){//根が同じでなかったらつなげる\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(r[x] < r[y]) swap(x,y); //値を小さいほうを根にする\n        r[x] += r[y];\n        par[y] = x;\n        return;\n    }\n};\n\nedge es[400100];\nlong long V,E;\nvector<pair<long long,long long>> G[4100];\n\nlong long kruskal(){\n    sort (es,es + E,comp);\n    UnionFind UF(V);\n    long long res = 0;\n    REP(i,E){\n        edge e = es[i];\n        if(!UF.same(e.u,e.v)){\n            UF.unite(e.u,e.v);\n            res += e.cost;\n            G[e.u].pb({e.v,e.cost});\n            G[e.v].pb({e.u,e.cost});\n        }\n    }\n    return res;\n}\n\nlong long dis[4100][4100];\nbool seen[4100][4100];\n\nvoid dfs(long long X,long long st,long long co){\n    long long m = co;\n    REP(i,G[X].size()){\n        co = m;\n        if(!seen[st][G[X][i].first]){\n            seen[st][G[X][i].first] = 1;\n        }\n        else continue;\n        if(co < G[X][i].second) co = G[X][i].second;\n        dis[st][G[X][i].first] = max(co,dis[st][G[X][i].first]);\n        dis[G[X][i].first][st] = max(co,dis[G[X][i].first][st]);\n        dfs(G[X][i].first,st,co);\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n    cin >> V >> E;\n    REP(i,E){\n        cin >> es[i].u >> es[i].v >> es[i].cost;--es[i].u;--es[i].v;\n    }\n    long long mincost = kruskal();\n    long long Q;cin >> Q;\n    long long c,S,T;\n    REP(i,V){\n        dfs(i,i,0);\n        REP(j,V) seen[i][j] = 0;\n    }\n    REP(i,Q){\n        cin >> S >> T;--S;--T;\n        cout << mincost - dis[S][T] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nclass UnionFind {\npublic:\n  int n;\n  vi par; //親\n  vi ran; //木の深さ\n  vi num; //要素数\n\n  UnionFind(int _n) {\n    n = _n;\n    par.resize(n); ran.resize(n); num.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i; ran[i] = 0; num[i] = 1;\n    }\n  }\n\n  //木の根を求める\n  int find(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = find(par[x]);\n    }\n  }\n\n  //xとyの属する集合を併合\n  void unite(int x, int y) {\n    x = find(x); y = find(y);\n    int numsum = num[x] + num[y];\n    if (x == y) {\n      return;\n    }\n    if (ran[x]<ran[y]) {\n      par[x] = y;\n    }\n    else {\n      par[y] = x;\n      if (ran[x] == ran[y]) {\n        ran[x]++;\n      }\n    }\n    num[x] = num[y] = numsum;\n  }\n\n  //xとyが同じ集合に属するか否か\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n};\n\nvector< pair<ll, pll> > edges;\nconst int N = 4010;\nvector<vector<pll> > G(N), G2(N);\nbitset<N> used;\n\nll kruskal(int n) {\n  sort(edges.begin(), edges.end());\n  UnionFind uf(n);\n  ll res = 0;\n  for (int i = 0; i < edges.size(); i++) {\n    if (!uf.same(edges[i].second.first, edges[i].second.second)) {\n      uf.unite(edges[i].second.first, edges[i].second.second);\n      res += edges[i].first;\n      int u = edges[i].second.first, v = edges[i].second.second;\n      ll c = edges[i].first;\n      G2[u].push_back(pll(c, v));\n      G2[v].push_back(pll(c, u));\n    }\n  }\n  return res;\n}\n\n\nll dfs(int now, int t) {\n  used[now] = true;\n  if (now == t) {\n    return 0;\n  }\n  rep (i, G2[now].size()) {\n    int v = G2[now][i].second;\n    if (used[v]) continue;\n    ll res = dfs(v, t);\n    if (res >= 0) {\n      return max(res, G2[now][i].first);\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  rep (i, m) {\n    ll u, v, c;\n    cin >> u >> v >> c;\n    u--; v--;\n    G[u].push_back(pll(c, v));\n    G[v].push_back(pll(c, u));\n    edges.push_back({c, pll(u, v)});\n  }\n  sort(all(edges));\n  ll sum = kruskal(n);\n  int q;\n  cin >> q;\n  assert(q == 1);\n  while (q--) {\n    used.reset();\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    cout << sum - dfs(s, t) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\ntypedef pair<int,pii> edge;\n\nconst int N = 4005;\nint uf[N];\n\nint id(int v) {\n\tif(uf[v] == v) return v;\n\treturn uf[v] = id(uf[v]);\n}\n\nvoid merge(int u, int v) {\n\tuf[id(u)] = id(v);\n}\n\nvector<edge> v;\n\nvvi T;\nvvi W;\nint d[4005][4005],n,m,q;\n\nvoid find(int f, int s, int t, int ds) {\n\td[s][t] = ds;\n\tfor(int i = 0; i < T[t].size(); ++i) {\n\t\tint v = T[t][i];\n\t\tif(v == f) continue;\n\t\tfind(t,s,v,max(W[t][i],ds));\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie();\n\tcin >> n >> m;\n\tfor(int i = 0; i < n; ++i)\n\t\tuf[i] = i;\n\tfor(int i = 0;i < m; ++i) {\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tv.push_back(edge(c,pii(a-1,b-1)));\n\t}\n\tsort(v.begin(),v.end());\n\tll wt = 0;\n\tT = vvi(n,vi());\n\tW = vvi(n,vi());\n\tfor(int i = 0; i < v.size(); ++i) {\n\t\tint a = v[i].second.first,b=v[i].second.second;\n\t\tif(id(a) == id(b))\n\t\t\tcontinue;\n\t\tmerge(a,b);\n\t\twt += v[i].first;\n\t\tT[a].push_back(b);\n\t\tT[b].push_back(a);\n\t\tW[a].push_back(v[i].first);\n\t\tW[b].push_back(v[i].first);\n\t}\n\tfor(int i = 0; i < n; ++i)\n\t\tfind(-1,i,i,0);\n\tcin >> q;\n\twhile(q--) {\n\t\tint s,t;\n\t\tcin >> s >> t;\n\t\t--s; --t;\n\t\tcout << wt - d[s][t] << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nstruct DisjointSet {\n\t// ２つのグループを１つにまとめる　と　2つの要素が同じグループに所属しているかどうかを判定する\n\tvector<int> rank, p, S; // p->parent  S[findSet(v)] ->連結成分の大きさ\n\tDisjointSet() {}\n\tDisjointSet(int size) {\n\t\tS.resize(size, 1);\n\t\trank.resize(size, 0);\n\t\tp.resize(size, 0);\n\t\trep(i, 0, size) makeSet(i);\n\t}\n\tvoid makeSet(int x) {\n\t\tp[x] = x;\n\t\trank[x] = 0;\n\t}\n\tbool same(int x, int y) { // 判定する\n\t\treturn findSet(x) == findSet(y);\n\t}\n\tvoid unite(int x, int y) { // 連結するときにはこれを使う\n\t\tif (same(x, y))\n\t\t\treturn;\n\t\tlink(findSet(x), findSet(y));\n\t}\n\tvoid link(int x, int y) {\n\t\tif (rank[x] > rank[y]) {\n\t\t\tp[y] = x;\n\t\t}\n\t\telse {\n\t\t\tp[x] = y;\n\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\n\t\tS[x] = S[y] = S[x] + S[y];\n\t}\n\tint findSet(int x) {\n\t\tif (x != p[x]) {\n\t\t\tp[x] = findSet(p[x]); // path compression\n\t\t}\n\t\treturn p[x];\n\t}\n\tint connectedComponentSize(int x) { return S[findSet(x)]; }\n};\n\n\n\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint s, d; Weight w; Flow c;\n\tEdge() {};\n\tEdge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n\tg[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n\taddArc(g, a, b, w);\n\taddArc(g, b, a, w);\n}\n\nvector<Edge> kruskal(int N, vector<Edge> &edges) {\n\tint totalCost = 0;\n\tsort(all(edges));\n\tDisjointSet dset(N);\n\tvector<Edge>mst;\n\trep(i, 0, edges.size()) {\n\t\tEdge e = edges[i];\n\t\tif (!dset.same(e.s, e.d)) {\n\t\t\tmst.push_back(e);\n\t\t\ttotalCost += e.w;\n\t\t\tdset.unite(e.s, e.d);\n\t\t}\n\t}\n\treturn mst;\n}\n\nstruct Tree { // rooted tree\n\tvector<vector<int>>parent,weight;\n\tGraph g;\n\tint root, V, log2_n;\n\tvector<int> depth;\n\tint get_depth(int x) { return depth[x]; }\n\tvoid dfs(int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\trep(i, 0, g[v].size()) {\n\t\t\tif (g[v][i].d != p) {\n\t\t\t\tweight[0][g[v][i].d] = g[v][i].w;\n\t\t\t\tdfs(g[v][i].d, v, d + 1);\n\t\t\t}\n\t\t}\n\t}\n\tTree(Graph G, int root)\n\t\t: root(root), V(G.size()), g(G), depth(V), log2_n(1 + (int)log2(V)) {\n\t\tparent.resize(log2_n, vector<int>(V));\n\t\tweight.resize(log2_n, vector<int>(V));\n\t\tdfs(root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\tif (parent[k][v] < 0) {\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t\tweight[k + 1][v] = weight[k][v];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t\tweight[k + 1][v] = max(weight[k][parent[k][v]], weight[k][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\tint w = -1;\n\t\tif (depth[u] > depth[v])\n\t\t\tswap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tchmax(w, weight[k][v]);\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v)\n\t\t\treturn w;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tchmax(w, weight[k][u]);\n\t\t\t\tchmax(w, weight[k][v]);\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tchmax(w, weight[0][u]);\n\t\tchmax(w, weight[0][v]);\n\t\treturn w;\n\t}\n};\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, M; cin >> N >> M;\n\tvector<Edge>edges;\n\trep(i, 0, M) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--, b--;\n\t\tedges.eb(a, b, c);\n\t}\n\tauto mst = kruskal(N,edges);\n\tint sum = 0;\n\tGraph g(N);\n\tfor (auto &e : mst) {\n\t\taddEdge(g, e.s, e.d, e.w);\n\t\tsum += e.w;\n\t}\n\tTree tree(g, 0);\n\n\tint Q; cin >> Q;\n\tloop(Q) {\n\t\tint s, t; cin >> s >> t;\n\t\ts--, t--;\n\t\tint u = tree.lca(s, t);\n\t\tcout << sum - u << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define F first\n#define S second\n\nconst int MAXN = 4e5 + 10;\n\nint n, m, from[MAXN], to[MAXN], w[MAXN], sec[MAXN], q;\nint par[MAXN], ss[4010][4010];\nll sm;\nvector<pair<int, int>>\tadj[MAXN];\nbool vis[4010];\n\nbool cmp(int u, int v){return w[u] < w[v];}\n\nint getPar(int v){return par[v]==v?v:par[v]=getPar(par[v]);}\n\nvoid dfs(int v, int p, int z = -1){\n\tss[p][v] = z;\n\tvis[v] = 1;\n\tfor (auto e:adj[v])\n\t\tif (!vis[e.F])\n\t\t\tdfs(e.F, p, max(z, e.S));\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < m; i++)\n\t\tcin >> from[i] >> to[i] >> w[i], from[i]--, to[i]--;\n\tiota(sec, sec + m, 0);\n\tsort(sec, sec + m, cmp);\n\tiota(par, par + n, 0);\n\tfor (int i = 0; i < m; i++){\n\t\tint e = sec[i];\n\t\tint u = from[e], v = to[e];\n\t\tint pu = getPar(u), pv = getPar(v);\n\t\tif (pu == pv)\tcontinue;\n\t\tadj[u].push_back({v, w[e]});\n\t\tadj[v].push_back({u, w[e]});\n\t\tpar[pu] = pv;\n\t\tsm += w[e];\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tdfs(i, i);\n\t}\n\tcin >> q;\n\twhile (q--){\n\t\tint u, v;\tcin >> u >> v, u--, v--;\n\t\tprintf(\"%lld\\n\", sm - ss[u][v]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    cin >> a[i],b[i],c[i];\n    a[i]--; b[i]--;\n\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<long long>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  int sz = 13;\n  \n  vector<vector<int>> p(n, vector<int>(sz, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(sz, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<sz; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u,v;\n    u--; v--;\n\n    long long sub = 0;\n\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<sz; k++){\n      if( ((depth[v] - depth[u]) >> k) & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=sz-1; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n    if(u!=v){\n      sub = max({sub, mx_e[u][0], mx_e[v][0]});\n    }\n\n    /*\n    while(u!=v){\n      if(depth[u] < depth[v]){\n        sub = max(sub, mx_e[v][0]);\n        v = p[v][0];\n      }else{\n        sub = max(sub, mx_e[u][0]);\n        u = p[v][0];\n      }\n    }\n    */\n    println( mst_cost - sub );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <bitset>\n\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <ctime>\n////\n//#include <random>//\n#pragma endregion //#include\n/////////\n\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)4e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n/////////\n#pragma region Math\n#pragma region\nlong long ext_gcd(long long a,long long b,long long& x,long long& y){\n\tif(b==0){\n\t\tx=1;y=0;return a;\n\t}\n\tlong long q = a/b;\n\tlong long g = ext_gcd(b,a-q*b,x,y);\n\tx = x - q*y;\n\tswap(x,y);\n\treturn g;\n}\ntemplate<class T>\ninline T gcd(T a, T b){return b ? gcd(b, a % b) : a;}\n\n#pragma endregion // 最大公約数 gcd\n#pragma region\ntemplate<class T>\ninline T lcm(T a, T b){return a / gcd(a, b) * b;}\n#pragma endregion // 最小公倍数 lcm\n#pragma region\nlong long invMod(long long a,long long m=MOD){\n\tlong long x,y;\n\text_gcd(a,m,x,y);\n\tx %= m;\n\tif(x<0) x += m;\n\treturn x;\n}\n\n/*\nLL powMod(LL x,LL e,LL mod=MOD){\n\tLL prod = 1%mod;\n\tfor(int i=63;i>=0;--i){\n\t\tprod = prod*prod % mod;\n\t\tif(e&1LL<<i)prod=prod*x%mod;\n\t}\n\treturn prod;\n}*/\n\nLL powMod(LL num,LL n,LL mod=(LL)MOD){//(num**n)%mod\n\tnum %= mod;//\n\tif( n == 0 ){\n\t\treturn (LL)1;\n\t}\n\tLL mul = num;\n\tLL ans = (LL)1;\n\twhile(n){\n\t\tif( n&1 ){\n\t\t\tans = (ans*mul)%mod;\n\t\t}\n\t\tmul = (mul*mul)%mod;\n\t\tn >>= 1;\n\t}\n\treturn ans;\n}\n/*\nLL mod_inverse(LL num,LL mod=MOD){\n\treturn powMod(num,MOD-2,MOD);\n}*/\n#pragma endregion //繰り返し二乗法 powMod\n#pragma region\ntemplate<class T>\nvector<T> getDivisor(T n){\n\tvector<T> v;\n\tfor(int i=1;i*i<=n;++i){\n\t\tif( n%i == 0 ){\n\t\t\tv.push_back(i);\n\t\t\tif( i != n/i ){//平方数で重複して数えないように\n\t\t\t\tv.push_back(n/i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\treturn v;\n}\n#pragma endregion //約数列挙 getDivisor(n):O(√n)\n#pragma endregion //math\n//Utility:便利な奴\n#pragma region\ntemplate<class T>\nvoid UNIQUE(vector<T>& vec){\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end() );\n}\n#pragma endregion // sort erase unique\n////////////////////////////////\n#pragma region \nlong long  bitcount64(long long bits)\n{\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >>16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >>32 & 0x00000000ffffffff);\n}\n#pragma endregion //その他\n////////////////////////////////\nstruct edge_base{int to;LL cost;};\nedge_base make_edge_base(int to,LL cost){\n\tedge_base ret = {to,cost};\n\treturn ret;\n}\n#pragma region GRL\n#pragma region //グラフ\ntemplate<class T,class EDGE>\nvoid dijkstra(int root,int V,vector<T>& dist,vector<int>& prev,\n\tvector< vector<EDGE> > G\t){\n\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > > que;\n\t\n\tdist.assign(V,LINF);\n\tprev.assign(V,-1);\n\n\tdist[root] = 0;\n\tque.push(pair<T,int>(0,root));//距離、頂点番号\n\n\twhile( !que.empty() ){\n\t\tpair<T,int> p = que.top();que.pop();\n\t\tint v = p.second;\n\t\tif( dist[v] < p.first ) continue;\n\t\tfor(int i=0;i < (int)G[v].size();++i){\n\t\t\tEDGE e = G[v][i];\n\t\t\tif( dist[e.to] > dist[v] + e.cost ){\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(pair<T,int>(dist[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n//経路復元,dijkstraにprev入れた\n//http://ronly.hatenablog.com/entry/2017/06/17/161641\nvector<int> get_path(vector<int>& prev,int t){\n\tvector<int> path;\n\twhile(t!=-1){\n\t\tpath.push_back( t );\n\t\tt = prev[t];\n\t}\n\treverse(path.begin(),path.end());\n\treturn path;\n}\n#pragma endregion //ダイクストラ法:O(|E|log|V|)\n#pragma region //グラフ\nvoid warshall_floyd(vector<vector<LL> >& dist,int V,const LL inf=LINF){\n\tfor(int k=0;k<V;++k){\n\t\tfor(int i=0;i<V;++i){\n\t\t\tif( dist[i][k] >= inf ) continue;\n\t\t\tfor(int j=0;j<V;++j){\n\t\t\t\tif( dist[k][j] >= inf )continue;\n\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma endregion //ワーシャルフロイド:O(|V|**3)\n#pragma region\nnamespace FLOW{\n//vector< vector<FLOW:edge> > G;\n\nstruct edge_flow : public edge_base{\n\tLL cap;//LD cap;//\n\tint rev;\n};\nedge_flow make_edge_flow(int to,LL cap,int rev,LL cost=1){\n//edge_flow make_edge_flow(int to,LD cap,int rev,LL cost=1){\n\tedge_flow ret;\n\t\n\tret.to = to;\n\tret.cost = cost;\n\tret.cap = cap;\n\tret.rev = rev;\n\treturn ret;\n}\n\n//*\nclass Graph{\npublic:\n\tint V;\n\tvector< vector<FLOW::edge_flow> > G;\n\tvector< LL > dist;\n\tvector< int > iter;\n\tvector< bool > used;\n\tvoid init(int v){\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\tvoid reset(){\n\t\titer.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\t//directed graph\n\tvoid add_edge(int from,int to,LL cap){\n\t\tG[from].push_back( FLOW::make_edge_flow(to,cap,G[to].size()) );\n\t\tG[to].push_back( FLOW::make_edge_flow(from,0,G[from].size()-1) );\n\t}\n\t\nprivate:\n\t//sから最短距離をBFSで計算する\n\tvoid bfs(int s){//許容量もチェックしている\n\t\tqueue<int> que;\n\t\tdist = vector<LL>(V,-1);\n\t\tdist[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();++i){\n\t\t\t\tedge_flow &e = G[v][i];\n\t\t\t\tif( e.cap > 0 && dist[e.to] < 0 ){\n\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nprivate:\n\t//増加パスをDFSで探す\n\tLL dfs(int v,int t,LL f){\n\t\tif( v==t ) return f;\n\t\tfor(int &i = iter[v];i<(int)G[v].size();++i){//?\n\t\t\tFLOW::edge_flow &e = G[v][i];\n\t\t\tif( e.cap>0 && dist[v] < dist[e.to]){\n\t\t\t\tLL d = this->dfs(e.to, t, min(f,e.cap) );\n\t\t\t\tif( d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\t//sからtへの最大流量を求める\n\tLL max_flow(int s,int t){\n\t\tLL flow = 0;\n\t\tfor(;;){\n\t\t\tthis->bfs(s);\n\t\t\tif( dist[t] < 0 ) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tLL f = this->dfs(s,t,LINF);\n\t\t\tdo{\n\t\t\t\tflow += f;\n\t\t\t\tf = this->dfs(s,t,LINF);\n\t\t\t}while( f > 0 );\n\t\t}\n\t}\n};\n//*/\n}\n#pragma endregion //dinic :O(|E||V|^2)\n#pragma region //グラフ\nbool is_bipartite(int v,int c,vector< vector<int> >& G,vector<int>& Color){\n\tColor[v] = c;\n\tfor(int i=0;i < (int)G[v].size();++i){//隣接グラフ\n\t\tif(Color[ G[v][i] ] == c ) return false;\n\t\tif(Color[ G[v][i] ] == 0 && \n\t\t\t!is_bipartite(G[v][i],-c,G,Color)\n\t\t\t){\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nbool is_bipartite(int Root,vector< vector<int> >& Graph){\n\tint GraphSize = Graph.size();\n\tvector<int> Color(GraphSize,0);\n\tconst int ColorNo = 1;\n\treturn is_bipartite(Root,ColorNo,Graph,Color);\n}\n#pragma endregion //二部グラフチェック is_bipartite(root,GraphList)\n#pragma region\nnamespace matching{\n//https://beta.atcoder.jp/contests/soundhound2018/tasks/soundhound2018_c\nint V;\t\t//頂点数\nvector< vector<int> > G;//グラフ\nvector<int> match;//match[i]:頂点[i]がどことマッチされているか\nvector<bool > used;//\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n \nbool dfs(int v){\n\t/*\n\thttps://mathtrain.jp/bipartitematching\n\t未マッチ辺・マッチ辺・未マッチ辺\n\tこれを\n\tマッチ辺・未マッチ辺・マッチ辺\n\tに変えると\n\t1マッチが2マッチになる。\n\t未[済未]\n\t増加路を求めている。\n\t*/\n\tused[v] = true;//dfsのroot前に初期化される\n\tint size = G[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint u = G[v][i];//\n\t\tint w = match[u];//\n\t\tif( w<0 || ((used[w]==false) && dfs(w)) ){\n\t\t\t/*\n\t\t\tマッチングされていない||\n\t\t\t使われてない&&\n\t\t\t*/\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n \nint bipartite_matching(){\n\tint res = 0;\n\tmatch = vector<int>(V,-1);//未マッチ状態に初期化\n\tfor(int v=0;v<V;++v){\n\t\tif( match[v] < 0 ){\n\t\t\tused = vector<bool>(V,false);\n\t\t\tif( dfs(v) ){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n}\n#pragma endregion //二部グラフの最大マッチング bipartite_matching()\n#pragma endregion //\n#pragma region \nvector< vector<LL> > NCK;//初期値:0\n//http://sugarknri.hatenablog.com/entry/2016/07/16/165715\nvoid makeinv(vector<LL>& inv,const LL P){\n\tint i;\n\t//const int varMAX = max(100000,(int)inv.size());\n\tconst int varMAX = max(300010,(int)inv.size());\n\t\n\tinv = vector<LL>( varMAX+1,0);\n\tinv[1]=1;\n\tfor(i=2;i<=varMAX;i++){\n\t\tinv[i] = (inv[P%i] * (P-P/i)%P ) % P;//OVF\n\t\t//inv[i] = powMod(i,P-2,P);\n\t}\n}\n\nLL nCk(LL N,LL k,LL mod = MOD){\n\tstatic vector<LL> inv;//modの逆元\n\tif( inv.size() == 0 ){\n\t\tmakeinv(inv,mod);//modは素数を入れる\n\t}\n\tk = min(k,N-k);\n\tif( k < 0 || k > N){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tfor(int i=1;i<=k;++i){\n\t\tret = (ret * ((N+1-i)%mod) )%mod;//ret*N:OVF\n\t\tret = (ret * inv[i] )%mod;\n\t}\n\treturn ret;\n}\nLL nCk_once(LL N,LL k,LL mod = MOD){//modは素数\n\tk = min(k,N-k);\n\tif( k < 0 || k > N ){return 0;}\n\tif( k == 0 ){return 1;}\n\tif( k == 1 ){return N%mod;}\n\tLL ret = 1;\n\tLL A=1;\n\tfor(LL i=0;i<k;++i){\n\t\tA = (A * ((N-i)%mod) ) % mod;\n\t}\n\tLL B=1;\n\tfor(LL i=2;i<=k;++i){\n\t\tB = (B * (i%mod) ) % mod;\n\t}\n\tret = ( A * powMod(B,mod-2,mod) ) % mod;\n\treturn ret;\n}\n#pragma endregion //組み合わせnCk(,10^5)\n#pragma region\nLL nCk_base(int N,int K,LL mod=MOD){\n\tif( K<0 || N < K ) return 0;//多く取り過ぎ\n\tK = min(K,N-K);\n\tif( K==0 ){return 1%mod;}\n\tif( K==1 ){return N%mod;}//%MOD;\n\tif( N<=10000 && NCK[N][K] ){\n\t\treturn NCK[N][K];\n\t}\n\t//N個目を使わない:nCk(N-1,k)\n\t//N個目を使う\t:nCk(N-1,k-1)\n\tLL ans = (nCk_base(N-1,K)+nCk_base(N-1,K-1) )%mod;//%MOD;\n\tif( N<=10000 ){\n\t\tNCK[N][K] = ans;\n\t}\n\treturn ans;\n}\n\n#pragma endregion //組み合わせ メモ?\n\n#pragma region DSL\nclass UnionFind{\npublic:\n\tint cNum;//要素数\n\tvector<int> parent;\n\tvector<int> count;\n\tvector< vector<int> > GList;\n\tUnionFind(int n){\n\t\tcNum = n;\n\t\tparent = vector<int>(n);\n\t\tcount = vector<int>(n,1);\n\t\tGList.resize(n);\n\t\tfor(int i=0;i<n;++i){\n\t\t\tparent[i] = i;\n\t\t\tGList[i].push_back(i);\n\t\t}\n\t}\n\tint find(int x){\n\t\tif( parent[x] == x ){return x;}\n\t\treturn parent[x] = find( parent[x] );\n\t}\n\tbool same(int x,int y){return find(x) == find(y);}\n\tint Count(int x){return count[find(x)];}\n\tvoid add(int x,int y){//union\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif( x==y )return;\n\t\tparent[x] = y;\n\t\t\n\t\tcount[y] += count[x];\n\t\tif( GList[y].size() < GList[x].size() ){\n\t\t\tswap(GList[x],GList[y]);\n\t\t}\n\t\tGList[y].insert( GList[y].end(),\n\t\t\tGList[x].begin(),GList[x].end() );\n\t}\n};\n#pragma endregion //UnionFind\n#pragma region DSL\nclass BITree{//1-index\n\tint N;\n\tvector<LL> bit;\npublic:\n\tBITree(int n){\n\t\tN = n;\n\t\tbit = vector<LL>(N+1,0);//1-index\n\t}\n\tvoid add(int a,LL w){//aにwを足す\n\t\tif( a <= 0 || N < a) return;//a:[1,N]\n\t\tfor(int i=a;i<=N;i += i & -i){\n\t\t\tbit[i] += w;\n\t\t}\n\t}\n\tLL sum(int a){//[1,a]の和,a:[1,N]\n\t\t/*\n\t\t1番目からa番目までの和、1-index\n\t\t*/\n\t\tLL ret = 0;\n\t\tif( a > N ) a = N;\n\t\tfor(int i=a; i > 0; i -= i & -i){\n\t\t\tret += bit[i];\n\t\t}\n\t\treturn ret;\n\t}\n};\n#pragma endregion //BIndexTree\n#pragma region\ntemplate <typename T>\nclass segmentTree{\n\tint N;//要素数\n\tvector< T > dat1;\n\tT VAL_E;//初期値\n\tT VAL_NULL;//空の値\npublic:\n\tsegmentTree(){};\n\t/*segmentTree(int n,T val_E ):N(n),VAL_E(val_E){\n\t\tdat1.resize(2*n);\n\t\tdat1.assign(2*n,val_E);//初期化\n\t}*/\n\tvoid init(int n,T val_E,T val_N){\n\t\tN = n;\n\t\tVAL_E = val_E;\n\t\tVAL_NULL = val_N;\n\t\tint size = 2;\n\t\twhile(size<N){\n\t\t\tsize <<= 1;\n\t\t}\n\t\tN = size;\n\t\tdat1.resize(2*N);\n\t\tdat1.assign(2*N,val_E);\n\t}\n\tT SELECT(T L,T R){//扱う演算子\n\t\tT ans;\n\t\tans = max(L,R);//\n\t\treturn ans;\n\t}\n\n\t//index番目の値をvalに変更,indexは\"0-index\"\n\tvoid update(int i,T val){\n\t\ti += N-1;\n\t\tdat1[i] = val;\n\t\twhile(i>0){\n\t\t\ti = (i-1)/2;\n\t\t\tdat1[i] = SELECT(dat1[i*2+1],dat1[i*2+2]);\n\t\t}\n\t}\n\n\t//区間[L,R)のSELECT\n\t/*\n\t調べている範囲[a,b),階数k,見る場所[L,R)\n\t*/\n\tT query(int a,int b,int k,int L,int R){\n\t\tif( R<=a || b<=L ){\n\t\t\treturn VAL_E;//交差しない\n\t\t}\n\t\tif( a<=L && R<=b && dat1[k] != VAL_NULL ){\n\t\t\treturn dat1[k];\n\t\t}\n\n\t\tT res = VAL_E;\n\t\tint mid = (L+R)/2;\n\t\tif( a < mid ) res = SELECT(res,query(a,b,k*2+1,L,mid) );\n\t\tif( mid < b ) res = SELECT(res,query(a,b,k*2+2,mid,R) );\n\t\treturn res;\n\t}\n\tT query(int L,int R){\n\t\treturn query(L,R,0,0,N);\n\t}\n};\n#pragma endregion //segment_tree\n\n#pragma region \n//行列の積\nnamespace mymat{\n\tLL matMOD = MOD;//初期値10^9 + 7\n};\ntemplate<class T>\nvector< vector<T> > operator*( vector<vector<T> >& A,vector< vector<T> >& B){\n\tLL mod = mymat::matMOD;\n\tint R = A.size();\n\tint cen = A[0].size();\n\tint C = B[0].size();\n\tvector< vector<T> > ans(R,vector<T>(C,0) );\n\tfor(int row=0;row<R;++row){\n\t\tfor(int col=0;col<C;++col){\n\t\t\tfor(int inner=0;inner< cen;++inner){\n\t\t\t\t/*ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t\t//ans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col]);\n\t\t\t\tans[row][col] = (ans[row][col] + mod) % mod;\n\t\t\t\t//負になるときの処理\n\t\t\t\t*/\n\t\t\t\tans[row][col] = (ans[row][col] + A[row][inner]*B[inner][col])%mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<class T>\nvector< vector<T> > powMod(const vector< vector<T> >& mat,LL N,LL mod=MOD){\n\tmymat::matMOD = mod;\n\tint R = mat.size();\n\tint C = mat[0].size();\n\t//R==C\n\tvector< vector<T> > I(R,vector<T>(C,0));//単位元\n\tfor(int i=0;i<R && i<C;++i){\n\t\tI[i][i] = 1;\n\t}\n\tif( N == 0 ){\n\t\treturn I;\n\t}\n\tvector< vector<T> > mul(R,vector<T>(C)),ans(R,vector<T>(C));\n\tans = I;\n\tmul = mat;\n\twhile(N){\n\t\tif( N & 1 ){\n\t\t\tans = ans*mul;\n\t\t}\n\t\tN >>= 1;\n\t\tmul = mul*mul;\n\t}\n\treturn ans;\n}\n#pragma endregion //行列\n\n#pragma region\n#include<time.h>\nnamespace TIME{\n\nclock_t start,end;\nvoid time_start(){\n\tstart = clock();\n}\nvoid time_set(int t){\n\tend = start + t;\n}\nbool check(){\n\treturn clock() < end;\n}\n\n/*\nunsigned long long get_cycle(){\n\treturn __rdtsc();\n}\nunsigned long long start,limit;\nvoid time_start(){\n\tstart = get_cycle();\n}\n//あたいをーさぐらないとーだめー\nvoid time_set(unsigned long long num){limit = num;}\nbool check(){return (get_cycle() < start+limit);}\n*/\n}\n#pragma endregion //時間計測\n\n#pragma region\n\nnamespace RAND{\nunsigned long xor128(){ \n\tstatic unsigned long x=123456789,y=362436069,z=521288629,w=88675123; \n\tunsigned long t; \n\tt=(x^(x<<11));x=y;y=z;z=w;\n\treturn( w=(w^(w>>19))^(t^(t>>8)) ); \n}\nLL getRAND(LL P){\n\treturn ((xor128()%P)+P)%P;\n}\n}\n\n#pragma endregion //乱数\n\n#pragma region\n#pragma endregion //\n////////////////////////\n//各頂点に深さを割り当てる。\nvector< vector<int> > cost;//(i,j)の辺の重さ,無い時は0\nvector< vector< vector<int> > > MIST;\nvector<int> dep;\nvector<int> oya;//rootは-1\nvoid serDep(int v,int d,int OYA){\n\tdep[v] = d;\n\toya[v] = OYA;\n\tint size = MIST[v].size();\n\tfor(int i=0;i<size;++i){\n\t\tint to = MIST[v][i][0];\n\t\tif(dep[to] == -1 ){//未設定\n\t\t\tserDep(to,d+1,v);\n\t\t}\n\t}\n}\nint cal(int A,int B){\n\t//v-uパス上の最大の辺の重さを得る\n\tint ret = 0;\n\tint depA,depB;\n\tdepA = dep[A];\n\tdepB = dep[B];\n\n//OK\n\n\twhile(depA<depB){//Bを上に移動させる\n\t\tint OYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t\tdepB--;\n\t}\n\n\twhile(depA>depB){//Aを上に移動させる\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\t\tdepA--;\n\t}\nreturn ret;\n\twhile(A!=B){\n\t\tint OYA = oya[A];\n\t\tret = max(ret,cost[A][OYA]);\n\t\tA = OYA;\n\n\t\tOYA = oya[B];\n\t\tret = max(ret,cost[B][OYA]);\n\t\tB = OYA;\n\t}\n\treturn ret;\n}\nvoid solve(){\n\tint N,M;\n\tcin>>N>>M;\n\tcost = vector< vector<int> >(N,vector<int>(N,0));\n\tvector<vector< vector<int> > > gra(N);//元のグラフ\n\tvector<int> dat(2);//相手の頂点,重さ\n\tvector<vector<int> > edge(M,vector<int>(3));\n\tvector<int> Edat(3);\n\tfor(int i=0;i<M;++i){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t--a;--b;\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\n\t\tdat[0] = b;dat[1] = c;\n\t\tgra[a].push_back( dat );\n\t\tdat[0] = a;\n\t\tgra[b].push_back( dat );\n\n\t\tEdat[0] = c;\n\t\tEdat[1] = a;\n\t\tEdat[2] = b;\n\t\tedge[i] = Edat;\n\t}\n\tsort(edge.begin(),edge.end());//重さ順に辺をソート\n\tvector<bool> use(N,false);//\n\tMIST = vector< vector<vector<int> > >(N);\n\tint MISTcost = 0;//MISTの重さ\n\tfor(int i=0;i<M;++i){\n\t\tEdat = edge[i];\n\t\tint a = Edat[1];\n\t\tint b = Edat[2];\n\t\tint c = Edat[0];\n\t\tif(use[a]==false || use[b]==false){\n\t\t\tuse[a] = true;\n\t\t\tuse[b] = true;\n\t\t\tdat[1] = c;\n\t\t\tdat[0] = b;\n\t\t\tMIST[a].push_back( dat );\n\t\t\tdat[0] = a;\n\t\t\tMIST[b].push_back( dat );\n\t\t\t\n\t\t\tMISTcost += c;\n\t\t}\n\t}\n//OK\n\tdep = vector<int>(N,-1);\n\toya = vector<int>(N,-1);\n\tint root = 0;\n\tserDep(root,0,-1);\n\tvector<vector<int> > ans(N,vector<int>(N,INF));\n//OK\n\tfor(int a=0;a<N;++a){\n\t\tfor(int b=a+1;b<N;++b){\n\t\t\tint res = cal(a,b);\n\t\t\tans[a][b] = res;\n\t\t\tans[b][a] = res;\n\t\t}\n\t}\n//RE\n\tint Q;\n\tcin>>Q;\n\twhile(Q--){\n\t\tint S,T;\n\t\tcin>>S>>T;\n\t\t--S;--T;\n\t\tcout << MISTcost-ans[S][T] << \"\\n\";\n\t}\n\tcout << flush;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, M, Q, s, t, a[400009], b[400009], c[400009], p[400009], par[4009], d[4009][4009]; vector<pair<int, int> > g[4009];\nint root(int x) { return x == par[x] ? x : par[x] = root(par[x]); }\nvoid dfs(int pos, int pre, int st, int val) {\n\td[st][pos] = val;\n\tfor (pair<int, int> i : g[pos]) {\n\t\tif (i.first == pre) continue;\n\t\tdfs(i.first, pos, st, max(val, i.second));\n\t}\n}\nint main() {\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < M; i++) scanf(\"%d %d %d\", &a[i], &b[i], &c[i]), a[i]--, b[i]--, p[i] = i;\n\tsort(p, p + M, [](int i, int j) { return c[i] < c[j]; });\n\tfor (int i = 0; i < N; i++) par[i] = i;\n\tlong long sum = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint pa = root(a[p[i]]), pb = root(b[p[i]]);\n\t\tif (pa != pb) {\n\t\t\tpar[pa] = pb; sum += c[p[i]];\n\t\t\tg[a[p[i]]].push_back(make_pair(b[p[i]], c[p[i]]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) dfs(i, -1, i, 0);\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++) {\n\t\tscanf(\"%d %d\", &s, &t); s--, t--;\n\t\tprintf(\"%lld\\n\", sum - d[s][t]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a});\n    g[b].pb({c, a, b});\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    cand.erase(begin(cand));\n    if (uf.same(edge[1], edge[2])) {\n      continue;\n    }\n    for (int i = uf.root(edge[2]); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[200000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[200000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#ifdef DEBUG\n#define show(...) cerr << #__VA_ARGS__ << \" = \", debug(__VA_ARGS__);\n#else\n#define show(...) 42\n#endif\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> a) {\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n    for (auto x : v) os << x << ' ';\n    return os;\n}\nvoid debug() {\n    cerr << '\\n';\n}\ntemplate <typename H, typename... T>\nvoid debug(H a, T... b) {\n    cerr << a;\n    if (sizeof...(b)) cerr << \", \";\n    debug(b...);\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\nstruct edge{\n    int to;\n    ll cost;\n};\nvector<edge> g[5000];\nint dp[5000][5000];\nvoid dfs(const int s, int par,int t){\n    for(auto &x : g[t]){\n        if(x.to == par)continue;\n        dp[s][x.to] = max(dp[s][t], (int)x.cost);\n        dfs(s,t,x.to);\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<pair<ll,pii>>e;\n    while(m--){\n        int a,b;\n        ll c;\n        cin >> a >> b >> c;\n        a--,b--;\n        e.push_back({c,{a,b}});\n    }\n    sort(e.begin(),e.end());\n    UnionFind uf(n);\n    ll sum = 0;\n    for(auto &x: e){\n        if(!uf.same(x.second.first,x.second.second)){\n            uf.unite(x.second.first,x.second.second);\n            sum += x.first;\n            int a = x.second.first;\n            int b = x.second.second;\n            ll c = x.first;\n            g[a].push_back((edge){b,c});\n            g[b].push_back((edge){a,c});\n        }\n    }\n    show(sum);\n    rep(i,n)dfs(i,-1,i);\n    int q;\n    cin >> q;\n    while(q--){\n        int s,t;\n        cin >> s >> t;\n        s--,t--;\n        cout << sum - dp[s][t] << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\ntemplate <typename Cost = int> class Edge{\npublic:\n  int from,to;\n  Cost cost;\n  Edge() {}\n  Edge(int to, Cost cost): to(to), cost(cost){}\n  Edge(int from, int to, Cost cost): from(from), to(to), cost(cost){}\n\n  Edge rev() const {return Edge(to,from,cost);}\n  \n  friend ostream& operator<<(ostream &os, const Edge &e){\n    os << \"(FROM: \" << e.from << \",\" << \"TO: \" << e.to << \",\" << \"COST: \" << e.cost << \")\";\n    return os;\n  }\n};\n\ntemplate <typename T> using Graph = vector<vector<Edge<T>>>;\ntemplate <typename T> using Tree = vector<vector<Edge<T>>>;\n\ntemplate <typename C, typename T> void add_edge(C &g, int from, int to, T w){\n  g[from].push_back(Edge<T>(from, to, w));  \n}\n\ntemplate <typename C, typename T> void add_undirected(C &g, int a, int b, T w){\n  g[a].push_back(Edge<T>(a, b, w));\n  g[b].push_back(Edge<T>(b, a, w));\n}\n\nclass UnionFind{\n  vector<int> parent, depth, size;\n  int count;\npublic:\n  UnionFind(int n): parent(n), depth(n,1), size(n,1), count(n){\n    iota(ALL(parent),0);\n  }\n  int get_root(int i){\n    if(parent[i] == i) return i;\n    else return parent[i] = get_root(parent[i]);\n  }\n  bool is_same(int i, int j){return get_root(i) == get_root(j);}\n  int merge(int i, int j){\n    int ri = get_root(i), rj = get_root(j);\n    if(ri == rj) return ri;\n    else{\n      --count;\n      if(depth[ri] < depth[rj]){\n        parent[ri] = rj;\n        size[rj] += size[ri];\n        return rj;\n      }else{\n        parent[rj] = ri;\n        size[ri] += size[rj];\n        if(depth[ri] == depth[rj]) ++depth[ri];\n        return ri;\n      }\n    }\n  }\n  int get_size(int i){return size[get_root(i)];}\n  int count_group(){return count;}\n};\n\n\ntemplate <typename T>\nvector<tuple<int,int,T>> kruskal(int n, vector<tuple<int,int,T>> &graph){\n  sort(graph.begin(), graph.end(), [](tuple<int,int,T> &a, tuple<int,int,T> &b){return get<2>(a) < get<2>(b);});\n  UnionFind uf(n);\n  vector<tuple<int,int,T>> mst;\n  for(auto v : graph){\n    int s,t,d;\n    tie(s,t,d) = v;\n    if(!uf.is_same(s,t)){\n      uf.merge(s,t);\n      mst.push_back(v);\n    }\n  }\n  return mst;\n}\n\ntemplate <typename T> class HLDecomposition{\n  Tree<T> tree;\n  int n;\n\n  vector<int> sub, par, head, id, rid, next, end;\n\n  int dfs_sub(int cur, int p){\n    par[cur] = p;\n    int t = 0;\n    for(auto &e : tree[cur]){\n      if(e.to == p) continue;\n      sub[cur] += dfs_sub(e.to, cur);\n      if(sub[e.to] > t){\n        t = sub[e.to];\n        next[cur] = e.to;\n        swap(e, tree[cur][0]);\n      }\n    }\n    return sub[cur];\n  }\n\n  void dfs_build(int cur, int &i){\n    id[cur] = i;\n    rid[i] = cur;\n    ++i;\n\n    for(auto &e : tree[cur]){\n      if(e.to == par[cur]) continue;\n      head[e.to] = (e.to == tree[cur][0].to ? head[cur] : e.to);\n      dfs_build(e.to, i);\n    }\n\n    end[cur] = i;\n  }\n  \n\npublic:\n  HLDecomposition(const Tree<T> &tree):\n    tree(tree), n(tree.size()), sub(n,1), par(n,-1), head(n), id(n), rid(n), next(n,-1), end(n, -1){\n    dfs_sub(0, -1);\n    int i=0;\n    dfs_build(0, i);\n  }\n\n  void path_query_vertex(int x, int y, const function<void(int,int)> &f){\n    while(1){\n      if(id[x] > id[y]) swap(x, y);\n      f(max(id[head[y]], id[x]), id[y]+1);\n      if(head[x] == head[y]) return;\n      y = par[head[y]];\n    }\n  }\n\n  void path_query_edge(int x, int y, const function<void(int,int)> &f){\n    while(1){\n      if(id[x] > id[y]) swap(x, y);\n      if(head[x] == head[y]){\n        if(x != y) f(id[x]+1, id[y]+1);\n        return;\n      }\n      f(id[head[y]], id[y]+1);\n      y = par[head[y]];\n    }\n  }\n\n  int parent(int x){return par[x];};\n\n  void subtree_query_edge(int x, const function<void(int,int)> &f){\n    f(id[x]+1, end[x]);\n  }\n};\n\ntemplate <typename T, typename U> class SegmentTreeRangeUpdateQueryRangeMaximumQuery{\n  int size;\n  vector<T> vec1;\n  vector<U> vec2;\n  vector<bool> is_updated;\n  T e1;\n\n  inline void propagate(int i, int l){\n    if(is_updated[i]) return;\n    if(i < size/2){\n      if(not is_updated[i]){\n        vec2[i*2+1] = vec2[i];\n        vec2[i*2+2] = vec2[i];\n\n        is_updated[i*2+1] = false;\n        is_updated[i*2+2] = false;\n      }\n    }\n    if(not is_updated[i]) vec1[i] = vec2[i];\n    is_updated[i] = true;\n  }\n\n  inline T update_aux(int i, int l, int r, int s, int t, const U &x){\n    propagate(i,r-l);\n    if(r <= s || t <= l) return vec1[i];\n    else if(s <= l && r <= t){\n      vec2[i] = x;\n      is_updated[i] = false;\n      propagate(i,r-l);\n      return vec1[i];\n    }\n    else return vec1[i] = max(update_aux(i*2+1,l,(l+r)/2,s,t,x), update_aux(i*2+2,(l+r)/2,r,s,t,x));\n  }\n  \n  inline T query_aux(int i, int l, int r, int x, int y){\n    propagate(i,r-l);\n    if(r <= x || y <= l) return e1;\n    else if(x <= l && r <= y) return vec1[i];\n    else return max(query_aux(i*2+1,l,(l+r)/2,x,y), query_aux(i*2+2,(l+r)/2,r,x,y));\n  }\n  \npublic:\n  SegmentTreeRangeUpdateQueryRangeMaximumQuery(int n, const T &e1, const U &init): e1(e1){\n    size = 1;\n    while(size<n) size*=2;\n    size = size*2-1;\n\n    vec1 = vector<T>(size, init);\n    vec2 = vector<U>(size, init);\n    is_updated = vector<bool>(size, true);\n  }\n\n  inline void update(int s, int t, const U &x){\n    update_aux(0,0,size/2+1,s,t,x);\n  }\n  \n  inline T get(int x, int y){\n    return query_aux(0,0,size/2+1,x,y);\n  }\n};\n\n\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n,m;\n  while(cin >> n >> m){\n    vector<tuple<int,int,LLI>> edges;\n    REP(i,m){\n      int a,b; cin >> a >> b; --a, --b;\n      LLI c; cin >> c;\n      edges.push_back(make_tuple(a,b,c));\n    }\n\n    \n\n    auto es = kruskal(n,edges);\n    LLI sum = 0;\n    for(auto &e : es) sum += get<2>(e);\n    \n    Tree<LLI> tree(n);\n    for(auto &e : es){\n      add_undirected(tree, get<0>(e), get<1>(e), get<2>(e));\n    }\n\n    HLDecomposition<LLI> hld(tree);\n    SegmentTreeRangeUpdateQueryRangeMaximumQuery<LLI,LLI> seg(n, 0, 0);\n\n    for(auto &e : es){\n      hld.path_query_edge(get<0>(e), get<1>(e), [&](int x, int y){seg.update(x,y,get<2>(e));});\n    }\n\n\n    int Q; cin >> Q;\n    \n    REP(i,Q){\n      int s,t; cin >> s >> t; --s, --t;\n\n      LLI ans = sum;\n\n      LLI temp = 0;\n      \n      auto f = [&](int x, int y){chmax(temp, seg.get(x,y));};\n      hld.path_query_edge(s,t,f);\n    \n      ans -= temp;\n      \n      cout << ans << endl;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct union_find{\n    VI par;\n\n    void init(int n){\n        par.resize(n);\n        REP(i,n) par[i] = i;\n    }\n\n    int find(int x){\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void merge(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        par[x] = y;\n    }\n};\n\nstruct edge{ int u, v, cost; };\nVL em[4000], um[4000];\nint ma[4000][4000];\n\nbool comp(const edge &e1, const edge &e2){\n    return e1.cost < e2.cost;\n}\n\nll kruskal(vector<edge> &es, int n){\n    sort(es.begin(), es.end(), comp);\n    union_find uf;\n    uf.init(n);\n    ll res = 0;\n    REP(i,es.size()){\n        edge e = es[i];\n        if (!uf.same(e.u, e.v)){\n            uf.merge(e.u, e.v);\n            res += e.cost;\n            em[e.u].push_back(e.v);\n            um[e.u].push_back(e.cost);\n            em[e.v].push_back(e.u);\n            um[e.v].push_back(e.cost);\n        }\n    }\n    return res;\n}\n\nvoid dfs(int now, int past, ll x, int s){\n    ma[s][now] = x;\n    REP(i,em[now].size()){\n        if (em[now][i] == past) continue;\n        dfs(em[now][i], now, max(x, um[now][i]), s);\n    }\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    vector<edge> es;\n    while(m--){\n        edge eg;\n        scanf(\"%d %d %d\", &eg.u, &eg.v, &eg.cost);\n        eg.u--;\n        eg.v--;\n        es.push_back(eg);\n    }\n\n    ll sum = kruskal(es, n);\n\n    REP(i,n) dfs(i, -1, 0, i);\n\n    int q;\n    cin >> q;\n    while (q--){\n        int s, t;\n        scanf(\"%d %d\", &s, &t);\n        s--;\n        t--;\n        printf(\"%lld\\n\", sum - ma[s][t]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nstring s;\nconst int N = 500000;\nint a[N], b[N], c[N], id[N], p[N];\n\nint cc(int x, int y) {\n\treturn c[x] < c[y];\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n >> m;\n\tF0(i, m) cin >> a[i] >> b[i] >> c[i];\n\tF0(i, m) id[i] = i;\n\tsort(id, id + m, cc);\n\n\tint Q, S, T;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tcin >> S >> T;\n\t\tF1(i, n) p[i] = i;\n\t\tp[T] = S;\n\t\tint disc = n - 2;\n\t\tll ans = 0;\n\t\tF0(i, m) {\n\t\t\tif (!disc) break;\n\t\t\tint x = a[i];\n\t\t\tint y = b[i];\n\t\t\twhile (x != p[x]) x = p[x];\n\t\t\twhile (y != p[y]) y = p[y];\n\t\t\tif (x == y) continue;\n\t\t\tans += c[i];\n\t\t\tif (rand() & 1) p[x] = y; else p[y] = x;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n \n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n \n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n \n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n \nconst int INF = MOD;\n \nint n,m,q;\nvector<pii> g[4001];             // グラフ\nint depth[4001];        // 根付き木の深さ\nint par[4001];\nint query[4001];\n\nint data[4001];\nint init(){\n  REP(i,4001)data[i]=-1;\n}\nint root(int x){\n  return data[x]<0?x:data[x]=root(data[x]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]>data[b])swap(a,b);\n    data[a] += data[b];\n    data[b] = a;\n  }\n}\nint size(int x){\n  return -data[root(x)];\n}\n \nint main(){\n  scanf(\"%d%d\",&n,&m);\n  ll ans = 0;\n  {\n    set< pair<int,pii> > S;\n    init();\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      --a;\n      --b;\n      S.insert(make_pair(c,pii(a,b)));\n    }\n    while(size(0)!=n){\n      pair<int,pii> P = *S.begin(); S.erase(S.begin());\n      int c = P.first;\n      int a = P.second.first;\n      int b = P.second.second;\n      if(root(a)!=root(b)){\n        unite(a,b);\n        g[a].push_back(pii(b,c));\n        g[b].push_back(pii(a,c));\n        ans += c;\n      }\n    }\n  }\n\n  queue<int> Q;\n\n  REP(i,n) depth[i]=INF;\n  depth[0] = 0;\n  Q.push(0);\n  while(!Q.empty()){\n    int pos = Q.front(); Q.pop();\n    int d = depth[pos];\n    REP(i,g[pos].size()){\n      int to = g[pos][i].first;\n      int c = -g[pos][i].second;\n      if(depth[to]!=INF)continue;\n      depth[to] = d+1;\n      par[to] = pos;\n      Q.push(to);\n      query[to] = c;\n    }\n  }\n  scanf(\"%d\",&q);\n \n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s; --t;\n    ll x = INF;\n\n    int a,b;\n    a = s;\n    b = t;\n    if(depth[a]>depth[b])swap(a,b);\n    while(depth[b]!=depth[a]){\n      CHMIN(x,(ll)query[b]);\n      b = par[b];\n    }\n    while(par[a]!=par[b]){\n      CHMIN(x,(ll)query[a]);\n      CHMIN(x,(ll)query[b]);\n      a=par[a];b=par[b];\n    }\n    if(a!=b){\n      CHMIN(x,(ll)query[a]);\n      CHMIN(x,(ll)query[b]);\n    }\n    printf(\"%lld\\n\",ans+x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\" // define macro \"/D__MAI\"\n\nusing namespace std;\ntypedef long long int ll;\n\n#define xprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:v){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(auto cnt=0ll;cnt<(l);++cnt)\n#define iterate(cnt,b,e) for(auto cnt=(b);cnt!=(e);++cnt)\n#define MD 1000000007ll\n#define PI 3.1415926535897932384626433832795\ntemplate<typename T1, typename T2> ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << \"(\" << p.first << \":\" << p.second << \")\"; return o; }\ntemplate<typename iterator> inline size_t argmin(iterator begin, iterator end) {\n    return distance(begin, min_element(begin, end));\n}\ntemplate<typename iterator> inline size_t argmax(iterator begin, iterator end) {\n    return distance(begin, max_element(begin, end));\n}\ntemplate<typename T> T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> T& minset(T& to, const T& val) { return to = min(to, val); }\n\nmt19937_64 randdev(8901016);\ninline ll rand_range(ll l, ll h) {\n    return uniform_int_distribution<ll>(l, h)(randdev);\n}\n\n#ifdef __MAI\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\n#ifdef __VSCC\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0;\n            T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc&&cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var*sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) {\n            input_integer<int>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(long long& var) {\n            input_integer<long long>(var);\n            return *this;\n        }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n        }\n        template<typename IT> void in(IT begin, IT end) {\n            for (auto it = begin; it != end; ++it) *this >> *it;\n        }\n    };\n    class MaiPrinter {\n        int stack_p;\n        char stack[32];\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) {\n                putchar_unlocked('0');\n                return;\n            }\n            if (var < 0) {\n                putchar_unlocked('-');\n                var = -var;\n            }\n            stack_p = 0;\n            while (var) {\n                stack[stack_p++] = '0' + (var % 10);\n                var /= 10;\n            }\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        MaiPrinter& operator<<(char c) {\n            putchar_unlocked(c);\n            return *this;\n        }\n        MaiPrinter& operator<<(int var) {\n            output_integer<int>(var);\n            return *this;\n        }\n        MaiPrinter& operator<<(long long var) {\n            output_integer<long long>(var);\n            return *this;\n        }\n        MaiPrinter& operator<(int var) {\n            output_integer<int>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<(long long var) {\n            output_integer<long long>(var);\n            putchar_unlocked(' ');\n            return *this;\n        }\n        MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass Graph2d {\npublic:\n    typedef int numeric;\n    size_t n;\n    vector<numeric> matrix;\n\n    Graph2d(size_t size) :n(size), matrix(size*size) {};\n\n    void resize(size_t s) {\n        n = s;\n        matrix.resize(n*n);\n    }\n\n    inline numeric& at(int y, int x) { return matrix[y*n + x]; }\n    inline numeric& operator()(int y, int x) { return matrix[y*n + x]; }\n    inline numeric at(int y, int x) const { return matrix[y*n + x]; }\n    inline numeric operator()(int y, int x) const { return matrix[y*n + x]; }\n\n    inline void connect(int u, int v, int dist = 1) {\n        at(u, v) = at(v, u) = dist;\n    }\n    inline void connect_d(int from, int to, int dist = 1) { // directedEdge u->v\n        at(from, to) = dist;\n    }\n};\n\n\nclass Graph {\npublic:\n    size_t n;\n    vector<vector<int>> vertex_to;\n\n    Graph(size_t n) :n(n), vertex_to(n) {}\n\n    void connect(int from, int to) {\n        vertex_to[from].emplace_back(to);\n        vertex_to[to].emplace_back(from);\n    }\n    void resize(size_t _n) {\n        n = _n;\n        vertex_to.resize(_n);\n    }\n};\n\n\nvoid warshall_floyd(Graph2d& g) {\n    int i, j, k;\n    for (i = 0; i < g.n; i++) {\n        for (j = 0; j < g.n; j++) {\n            for (k = 0; k < g.n; k++) {\n                g(j, k) = min(g(j, k), g(j, i) + g(i, k));\n            }\n        }\n    }\n}\n\n\nclass unionfind {\npublic:\n    vector<int> data;\n    unionfind(int size) : data(size, -1) { }\n    bool union_set(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    inline bool find_set(int x, int y) {\n        return root(x) == root(y);\n    }\n    inline int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    inline int size(int x) {\n        return -data[root(x)];\n    }\n};\n\n\nint m, n, kei;\nGraph2d graph_mat(1);\nvector<array<int,3>> edges;\nll answer[4040][4040];\n\nvoid build() {\n    Graph tree(n);\n    unionfind uf(n);\n    ll total = 0;\n    for (int i = 0, cnt = 0; cnt < n - 1; ++i) {\n        auto& v = edges[i];\n        if (uf.union_set(v[1], v[2])) {\n            tree.connect(v[1], v[2]);\n            ++cnt;\n            total += v[0];\n        }\n    }\n    vector<int> cycle_detector(n);\n    function<void(int, int, int, ll)> dfs = [&](int start, int idx,int from, ll wmax) {\n        answer[start][idx] = total - wmax;\n        answer[idx][start] = total - wmax;\n        assert(!cycle_detector[idx]);\n        cycle_detector[idx] = 1;\n\n        for (int to : tree.vertex_to[idx]) {\n            if (from == to) continue;\n            dfs(start, to, idx, max(wmax, (ll)graph_mat(idx, to)));\n        }\n    };\n\n    for (int i = 0; i < n; ++i) {\n        fill(ALL(cycle_detector), 0);\n        dfs(i, i, 4010, 0);\n    }\n}\n\nint main() {\n\n    scanner >> n >> m;\n\n    graph_mat.resize(n);\n    fill(ALL(graph_mat.matrix), 5e15);\n\n    repeat(i, m) {\n        ll a, b, c;\n        scanner >> a >> b >> c;\n        --a; --b;\n        graph_mat.connect(a, b, c);\n        edges.push_back({ c,a,b });\n    }\n    sort(ALL(edges));\n\n    build();\n\n    ll nq;\n    scanner >> nq;\n\n    repeat(qi, nq) {\n        ll u, v;\n        scanner >> u >> v;\n        --u; --v;\n        printer << answer[u][v] << '\\n';\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef int long long;\n//typedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to,cost;\n\t};\n\tvector<edge>G,tG;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tint krk(){\n\t\tint sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost<b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\ttG.pb(e);\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tvoid solve(){\n\t\tint out=krk();\n//\t\trep(i,tG.size())cout<<tG[i].from<<\" \"<<tG[i].to<<endl;\n\t\tint ma=0;\n\t\trep(i,tG.size())ma=max(ma,tG[i].cost);\n\t\tmap<pii,int>m;\n\t\trep(i,tG.size())m[pii(tG[i].to,tG[i].from)]=m[pii(tG[i].from,tG[i].to)]=tG[i].cost;\n\t\tint q;\n\t\tcin>>q;\n\t\twhile(q--){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tif(m[pii(a,b)])cout<<out-m[pii(a,b)]<<endl;\n\t\t\telse cout<<out-ma<<endl;\n\t\t}\n\t}\n};\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tkrk.add_edge(a,b,c);\n\t}\n\tkrk.solve();\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\n// write [ LCA lca(g, root); ] when using this snippet.\nclass LCA {\nprivate:\n\tconst std::vector<std::vector<int>>& graph; // graph's list expression\n\tint root;\n\tint n; // the number of nodes\n\tint log2n; // = floor(log2(n)) + 1\n\tstd::vector<std::vector<int>> parent; // parent[x][v] = a parent(above 2^x) of v (nonexistence -> -1)\n\tstd::vector<int> depth; // the depth of each node\n\npublic:\n\tLCA(const std::vector<std::vector<int>>& graph, int root) :\n\t\tgraph(graph), root(root), n(graph.size()),\n\t\tlog2n(std::floor(std::log2(n) + 1)),\n\t\tparent(log2n, std::vector<int>(n, 0)), depth(n, 0)\n\t{\n\t\tinit();\n\t}\n\n\t// Check the depth of each node(node \"v\" -> parent is \"p\", depth is \"d\")\n\tvoid dfs(int v, int p, int d) {\n\t\tstd::stack<int> stack;\n\t\tstack.push(v);\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\twhile (!stack.empty()) {\n\t\t\tint now = stack.top(); stack.pop();\n\t\t\tfor (int i = 0; i < graph[now].size(); ++i) {\n\t\t\t\tint to = graph[now][i];\n\t\t\t\tif (to == parent[0][now]) continue;\n\t\t\t\tparent[0][to] = now;\n\t\t\t\tdepth[to] = depth[now] + 1;\n\t\t\t\tstack.push(to); // Check each child of v\n\t\t\t}\n\t\t}\n\t}\n\n\t// Initialize\n\tvoid init() {\n\t\t// Initialize \"parent[0]\" and \"depth\"\n\t\tdfs(root, -1, 0);\n\n\t\t// Initialize \"parent\"\n\t\tfor (int k = 0; k < log2n - 1; ++k) {\n\t\t\tfor (int v = 0; v < n; ++v) {\n\t\t\t\tif (parent[k][v] < 0) { // If parent above 2^k of v is nonexistence\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Find LCA of (u, v)\n\tint lca(int u, int v) {\n\t\t// go up parent while depth of u and v is same\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2n; ++k) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v]; // go up to 2^k if k-th binary is 1\n\t\t\t}\n\t\t}\n\n\t\tif (u == v) return u; // this case is that v is in u's subtree\n\n\t\t// Find LCA by binary searching\n\t\tfor (int k = log2n - 1; k >= 0; --k) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, m, a, b, c);\n\tstd::vector<std::vector<PAIR>> g(n);\n\tstd::vector<PAIR> edge(m);\n\tREP(i, m) {\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].emplace_back(b[i], c[i]);\n\t\tg[b[i]].emplace_back(a[i], c[i]);\n\t\tedge[i] = PAIR(c[i], i);\n\t}\n\tstd::sort(ALL(edge));\n\n\t// 最小全域木\n\tstd::vector<std::vector<PAIR>> G(n); // (to, cost)\n\tstd::vector<std::vector<int>> G_(n); // 辺情報のみ(LCAで使う)\n\tUnionFind uf(n);\n\tint sum = 0;\n\tfor (auto& p : edge) {\n\t\tauto ei = p.second;\n\t\tint A = a[ei], B = b[ei], C = c[ei];\n\t\tif (uf.same(A, B)) continue;\n\t\tuf.unite(A, B);\n\t\tG[A].emplace_back(B, C);\n\t\tG[B].emplace_back(A, C);\n\t\tG_[B].emplace_back(A);\n\t\tG_[A].emplace_back(B);\n\t\tsum += C;\n\t}\n\n\t// LCA構成，根を0とする\n\tLCA lca(G_, 0);\n\n\t// 親を調べる\n\tstd::vector<PAIR> par(n, PAIR(-1, 0)); // (親, 親へのコスト)\n\tstd::function<void(int, int)> dfs = [&](int v, int pa) {\n\t\tfor (auto& e : G[v]) if (e.first != pa) {\n\t\t\tpar[e.first] = PAIR(v, e.second);\n\t\t\tdfs(e.first, v);\n\t\t}\n\t};\n\tdfs(0, -1);\n\n\t// クエリ\n\tVAR(int, Q);\n\tREP(_, Q) {\n\t\tVAR(int, s, t);\n\t\t--s; --t;\n\n\t\tint u = lca.lca(s, t);\n\t\tint ma = 0;\n\t\twhile (s != u) {\n\t\t\tCHMAX(ma, par[s].second);\n\t\t\ts = par[s].first;\n\t\t}\n\t\twhile (t != u) {\n\t\t\tCHMAX(ma, par[t].second);\n\t\t\tt = par[t].first;\n\t\t}\n\t\tOUT(sum - ma)BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, auto& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct QU {\n  V<> par, rank, _size;\n\n  QU(int n) { \n    par.resize(n);\n    iota(par.begin(), par.end(), 0);\n    rank.resize(n);\n    _size.assign(n, 1);\n  }\n\n  int find(int a) {\n    if (par[a] == a) return a;\n    return par[a] = find(par[a]);\n  }\n\n  bool same(int a, int b) { return find(a) == find(b); }\n\n  int size(int a) { return _size[find(a)]; }\n\n  void unite(int a, int b) {\n    a = find(a), b = find(b);\n    if (a == b) return;\n    if (rank[a] < rank[b]) {\n      par[a] = b;\n      _size[b] += _size[a];\n    } else {\n      par[b] = a;\n      _size[a] += _size[b];\n    }\n    if (rank[a] == rank[b]) rank[a]++;\n  }\n};\n\ntemplate<class T> struct edge { int id, from, to; T w; };\n\ntemplate<class T> T kruskal(V< edge<T> >& g, int n, V<bool>& used) {\n  T res = 0;\n  QU qu(n);\n  sort(g.begin(), g.end(), [](auto a, auto b) { return a.w < b.w; });\n  for (auto&& e : g) {\n    if (!qu.same(e.from, e.to)) {\n      qu.unite(e.from, e.to);\n      res += e.w;\n      used[e.id] = true;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  V< edge<lint> > es(m);\n  for (int i = 0; i < m; i++) {\n    int a, b, c; cin >> a >> b >> c, a--, b--;\n    es[i] = {i, a, b, c};\n  }\n  V<bool> used(m);\n  lint sm = kruskal<lint>(es, n, used);\n  struct edge2 { int to; lint w; };\n  VV<edge2> g(n);\n  for (int i = 0; i < m; i++) if (used[es[i].id]) {\n    g[es[i].from].push_back({es[i].to, es[i].w});\n    g[es[i].to].push_back({es[i].from, es[i].w});\n  }\n  VV<lint> res; assign(res, n, n, -1e18);\n  for (int i = 0; i < n; i++) {\n    queue<int> q;\n    V<bool> vis(n);\n    vis[i] = true; q.push(i);\n    lint t = -1e18;\n    while (!q.empty()) {\n      int v = q.front(); q.pop();\n      for (auto&& e : g[v]) if (!vis[e.to]) {\n        vis[e.to] = true;\n        res[i][e.to] = t = max(t, e.w);\n        q.push(e.to);\n      }\n    }\n  }\n  int q; cin >> q;\n  for (int iq = 0; iq < q; iq++) {\n    int s, t; cin >> s >> t, s--, t--;\n    cout << sm - res[s][t] << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n  vector<int> a(m),b(m),c(m);\n\n  for(auto i : range(m) ){\n    cin >> a[i],b[i],c[i];\n    a[i]--; b[i]--;\n\n  }\n\n  UnionFindTree uft(n);\n  vector<pair<int,pair<int,int>>> edge(m);\n  for(auto i : range(m) ){\n    edge[i] = {c[i], {a[i],b[i]}};\n  }\n  sort(edge.begin(), edge.end());\n\n  vector<vector<int>> G(n);\n  vector<vector<long long>> dd(n);\n  long long mst_cost = 0;\n  for(auto e : edge){\n    if(uft.same(e.second.first, e.second.second)) continue;\n    uft.unite(e.second.first, e.second.second);\n    mst_cost += e.first;\n\n    G[e.second.first].push_back(e.second.second);\n    G[e.second.second].push_back(e.second.first);\n\n    dd[e.second.first].push_back(e.first);\n    dd[e.second.second].push_back(e.first);\n  }\n\n  int sz = 15;\n  \n  vector<vector<int>> p(n, vector<int>(sz, -1));\n  vector<int> depth(n, -1);\n  vector<vector<long long>> mx_e(n, vector<long long>(sz, 0));\n\n  function<void(int,int,int)> set_p = [&](int pos, int par, int d){\n    depth[pos] = d;\n    p[pos][0] = par;\n    for(auto i : range(G[pos].size())){\n      int nx = G[pos][i];\n      if(nx == par) continue;\n      mx_e[nx][0] = dd[pos][i];\n      set_p(nx, pos, d+1);\n    }\n  };\n\n  set_p(0,0,0);\n\n  for(int k=1; k<sz; k++){\n    for(int i=0; i<n; i++){\n      p[i][k] = p[p[i][k-1]][k-1];\n      mx_e[i][k] = max(mx_e[i][k-1], mx_e[p[i][k-1]][k-1]);\n    }\n  }\n\n\n  \n\n  int q;\n  cin >> q;\n  while(q--){\n    int u,v;\n    cin >> u,v;\n    u--; v--;\n\n    long long sub = 0;\n    function<long long(int,int,long long)> dfs = [&](int pos, int last, long long mx){\n      if(pos == v){\n        return mx;\n      }\n      for(int i : range(G[pos].size())){\n        int nx = G[pos][i];\n        if(last == nx) continue;\n        long long val = dfs(nx, pos, max(mx, dd[pos][i]));\n        if(val != -1) return val;\n      }\n      return -1ll;\n    };\n\n/*\n    if(depth[u] > depth[v]) swap(u,v);\n    for(int k=0; k<sz; k++){\n      if( (depth[v] - depth[u]) >> k & 1){\n        sub = max(sub, mx_e[v][k]);\n        v = p[v][k];\n      }\n    }\n    for(int k=sz-1; k>=0; k--){\n      if(p[u][k] != p[v][k]) {\n        sub = max(sub, mx_e[u][k]);\n        sub = max(sub, mx_e[v][k]);\n        u = p[u][k];\n        v = p[v][k];\n      }\n    }\n*/\n    /*\n    while(u!=v){\n      if(depth[u] < depth[v]){\n        sub = max(sub, mx_e[v][0]);\n        v = p[v][0];\n      }else{\n        sub = max(sub, mx_e[u][0]);\n        u = p[v][0];\n      }\n    }\n    */\n    println( mst_cost - dfs(u,u,0) );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\ntemplate <typename T>\nstruct Edge {\n  int src, dst; T weight;\n\n  Edge(int src, int dst, T weight) : src(src), dst(dst), weight(weight) { }\n\n  bool operator < (const Edge<T> &e) const {\n    return weight < e.weight;\n  }\n};\n\ntemplate <typename T>\nstruct Graph {\n  int V;\n  vector<Edge<T>> E;\n\n  Graph(int V) : V(V) { }\n\n  void add_edge(int src, int dst, T weight) {\n    E.emplace_back(src, dst, weight);\n  }\n};\n\nstruct DisjointSet {\n  vector<int> parent, rank;\n\n  DisjointSet(int N) {\n    parent.resize(N), rank.resize(N, 0);\n    for (int i = 0; i < N; i++) parent[i] = i;\n  }\n\n  int find(int x) {\n    if (parent[x] == x) {\n      return x;\n    } else {\n      return parent[x] = find(parent[x]);\n    }\n  }\n\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return ;\n    if (rank[x] < rank[y]) {\n      parent[x] = y;\n    } else {\n      parent[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n\n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\ntemplate <typename T>\nstruct MinimumSpanningTree {\n  Graph<T> g;\n  vector<Edge<T>> mst;\n  T mincost;\n\n  MinimumSpanningTree(const Graph<T> &g) : g(g) { }\n\n  T run() {\n    mincost = 0;\n    sort(g.E.begin(), g.E.end());\n\n    DisjointSet uf(g.V);\n\n    for (int i = 0, edge_count = g.V - 1; edge_count; i++) {\n      assert(i < (int)g.E.size());\n      Edge<T> e = g.E[i];\n      if (!uf.same(e.src, e.dst)) {\n        uf.unite(e.src, e.dst);\n        mst.emplace_back(e);\n        mincost += e.weight;\n        edge_count--;\n      }\n    }\n    return mincost;\n  }\n};\n\nll max_cost[4010][4010];\nvector<pair<int, ll>> edge[4010];\n\nvoid dfs(int v, int p, int s, ll cost) {\n  max_cost[s][v] = cost;\n  for (auto e : edge[v]) {\n    int n; ll c; tie(n, c) = e;\n    if (n != p) dfs(n, v, s, max(cost, c));\n  }\n}\n\n\nint main() {\n\n  int N, M; scanf(\"%d %d\", &N, &M);\n  Graph<ll> g(N);\n  REP(i, M) {\n    int a, b, c; scanf(\"%d %d %d\", &a, &b, &c); a--, b--;\n    g.add_edge(a, b, c);\n    g.add_edge(b, a, c);\n  }\n  MinimumSpanningTree<ll> mst(g);\n  mst.run();\n\n  for (auto e : mst.mst) {\n    edge[e.src].emplace_back(e.dst, e.weight);\n    edge[e.dst].emplace_back(e.src, e.weight);\n  }\n\n  REP(i, N) dfs(i, -1, i, 0);\n\n  int Q; scanf(\"%d\", &Q);\n\n  REP(i, Q) {\n    int s, t; scanf(\"%d %d\", &s, &t); s--, t--;\n    printf(\"%lld\\n\", mst.mincost - max_cost[s][t]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ull INF = ULLONG_MAX;\nconst ll MOD = 998244353;\n\ntypedef ll Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Graph> Prim(const Graph &g, int r = 0) {\n\tint n = g.size();\n\tGraph T(n);\n\tWeight total = 0;\n\tvector<bool> visited(n);\n\tpriority_queue<Edge> Q;\n\tQ.push(Edge(-1, r, 0));\n\twhile (!Q.empty()) {\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif (visited[e.dst])\n\t\t\tcontinue;\n    if(e.src>=0){\n  \t\tT[e.src].push_back(e);\n      T[e.dst].push_back({e.dst,e.src,e.weight});\n    }\n\t\ttotal += e.weight;\n\t\tvisited[e.dst] = true;\n\t\tfor (Edge f:g[e.dst])\n\t\t\tif (!visited[f.dst])\n\t\t\t\tQ.push(f);\n\t}\n\treturn pair<Weight, Graph>(total, T);\n}\n\n\n\ninline int get_min2pow(int n) {\n\tint res = 1;\n\twhile (res < n)\n\t\tres *= 2;\n\treturn res;\n}\n\n///Segment Tree////////\n\ntemplate<typename T,T dval>\nstruct segtree {\n\tint N;\n\tvector<T> node;\n\t//例外値　ex)INF,0\n\tT default_value = dval;\n\tstatic inline T merge(const T& l, const T& r) {\n\t\t//RMQ\n\t\treturn max(l,r);\n\t\t//RSQ\n\t\t//return l+r;\n\t}\n\tsegtree(int n) {\n\t\tN = get_min2pow(n);\n\t\tnode.resize(2 * N, default_value);\n\t}\n\tsegtree(vector<int> v) {\n\t\tint sz = v.size();\n\t\tN = get_min2pow(sz);\n\t\tnode.resize(2 * N, default_value);\n\t\tfor (int i = 0; i < sz; i++)\n\t\t\tnode[i + N - 1] = v[i];\n\t\tfor (int i = N - 2; i >= 0; i--)\n\t\t\tnode[i] = merge(node[2 * i + 1], node[2 * i + 2]);\n\t}\n\t// update k th element\n\tvoid update(int k, T val) {\n\t\tk += N - 1; // leaf\n\t\tnode[k] = val;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = merge(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\t// [a, b)\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, N);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l)\n\t\t\treturn default_value;\n\t\tif (a <= l and r <= b)\n\t\t\treturn node[k];\n\t\tint m = (l + r) / 2;\n\t\tT vl = query(a, b, k * 2 + 1, l, m);\n\t\tT vr = query(a, b, k * 2 + 2, m, r);\n\t\treturn merge(vl, vr);\n\t}\n};\n\n\nstruct HLDecomposition{\n  int V;\n  vint dep,par,heavy,head,id,size,dat;\n  segtree<ll,0> RMQ;\n  HLDecomposition(const Graph &g,int root=0)\n  :V(g.size()),dep(V,0),par(V,-1),heavy(V,-1),head(V),id(V),size(V,1),dat(V,-1),RMQ(V){\n    //make par\n    par[root]=0;\n    queue<int> Q;\n    Q.push(root);\n    while(!Q.empty()){\n      int v=Q.front();\n      Q.pop();\n      for(const Edge &w:g[v])\n      if(par[w.dst]<0){\n        Q.push(w.dst);\n        par[w.dst]=v;\n        dat[w.dst]=w.weight;\n      }\n    }\n    par[root]=-1;\n    //calculate heavy\n    Q.push(root);\n    while(!Q.empty()){\n      int v=Q.front();\n      Q.pop();\n      for(const Edge &w:g[v]){\n        if(w.dst==par[v])continue;\n        dep[w.dst]=dep[v]+1;\n        Q.push(w.dst);\n      }\n    }\n    repeat(v,V){\n      if(par[v]<0)continue;\n      size[par[v]]+=size[v];\n      if(heavy[par[v]]<0||size[v]>size[heavy[par[v]]])heavy[par[v]]=v;\n    }\n    //calculate id\n    int idx=0;\n    repeat(v,V){\n      if(par[v]<0||heavy[par[v]]!=v){\n        for(int w=v;w!=-1;w=heavy[w]){\n          head[w]=v;\n          id[w]=idx++;\n          RMQ.update(id[w],dat[w]);\n        }\n      }\n    }\n  }\n  // [u,v]\n  ll query(int u,int v){\n    ll ret=0;\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]!=head[v]){\n        ret = max(ret,RMQ.query(id[u]+1,id[v]+1));\n        v=par[head[v]];\n      }else{\n        if(u!=v)ret = max(ret,RMQ.query(id[u]+1,id[v]+1));\n        return ret;\n      }\n    }\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(id[u]>id[v])swap(u,v);\n      if(head[u]==head[v])return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\nint main(){\n  int N,M;cin>>N>>M;\n  Graph g(N);\n  repeat(i,M){\n    int a,b;\n    Weight c;\n    cin>>a>>b>>c;\n    a--;b--;\n    g[a].push_back({a,b,c});\n    g[b].push_back({b,a,c});\n  }\n  pair<Weight, Graph> tree=Prim(g,0);\n  HLDecomposition hld(tree.second,0);\n  int Q;cin>>Q;\n  repeat(q,Q){\n    int s,t;cin>>s>>t;\n    s--;t--;\n    ll ans=tree.first-hld.query(s,t);\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nclass U {\npublic:\n  int n;\n  vector<int> p, s;\n\n  U(int _) {\n    n = _;\n    p.resize(n);\n    s.resize(n);\n    for (int i = 0; i < n; i++) {\n      p[i] = i;\n      s[i] = 1;\n    }\n  }\n\n  bool connect(int a, int b) {\n    int ap, bp;\n    for (ap = p[a]; ap != p[ap]; ap = p[ap]);\n    for (bp = p[b]; bp != p[bp]; bp = p[bp]);\n    if (ap == bp)\n      return true;\n    int mi = min(ap, bp), ma = max(ap, bp);\n    p[ma] = mi;\n    s[mi] += s[ma];\n    s[ma] = 0;\n    for (int pp = a; pp != mi;) {\n      int next = p[pp];\n      p[pp] = mi;\n      pp = next;\n    }\n    for (int pp = b; pp != mi;) {\n      int next = p[pp];\n      p[pp] = mi;\n      pp = next;\n    }\n    return false;\n  }\n\n  int q(int a) {\n    int ap;\n    for (ap = a; ap != p[ap]; ap = p[ap]);\n    return s[ap];\n  }\n\n  int parent(int a) {\n    int ap;\n    for (ap = a; ap != p[ap]; ap = p[ap]);\n    return p[ap];\n  }\n\n  bool query(int a, int b) { return parent(a) == parent(b); }\n};\n\nvector<vector<pair<int, ll>>> ps;\n\nvoid dfs(vector<vector<ll>> &dist, int i, int from, int base, ll maxp) {\n  dist[base][i] = maxp;\n  for (auto &v : ps[i]) {\n    if (v.first == from) continue;\n    dfs(dist, v.first, i, base, max(v.second, maxp));\n  }\n}\n\nstruct N {\n  int a, b;\n  ll c;\n};\n\nbool operator<(const N &l, const N &r) {\n  return l.c < r.c;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  ps.resize(n);\n  U u(n);\n  ll sum = 0;\n  vector<N> ns(m);\n  for (int i = 0; i < m; i++) {\n    cin >> ns[i].a >> ns[i].b >> ns[i].c;\n    ns[i].a--;\n    ns[i].b--;\n  }\n  sort(ns.begin(), ns.end());\n  for (int i = 0; i < m; i++) {\n    if (!u.connect(ns[i].a, ns[i].b)) {\n      ps[ns[i].a].emplace_back(ns[i].b, ns[i].c);\n      ps[ns[i].b].emplace_back(ns[i].a, ns[i].c);\n      sum += ns[i].c;\n    }\n  }\n  vector<vector<ll>> dist(n, vector<ll>(n, -1));\n\n  for (int i = 0; i < n; i++) {\n    dfs(dist, i, -1, i, 0);\n  }\n\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    int s, t;\n    cin >> s >> t;\n    s--;\n    t--;\n    cout << sum - dist[s][t] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[500000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[500000],t[500000];\nint l[500000],r[500000];\nvector<int>query[500000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,15){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nstruct edge{\n    int from,to,cost;\n    bool operator<(const edge& other)const{\n        return cost<other.cost;\n    }\n};\n\nvoid solve(){\n    int n,m;\n    cin >> n >> m;\n    vector<edge> edges;\n    rep(i,0,m){\n        int a,b,c;\n        cin >> a >> b >> c;\n        --a;\n        --b;\n        edges.push_back(edge({a,b,c}));\n    }\n    sort(edges.begin(),edges.end());\n\n    union_find uf(n);\n    vector<bool> use(m);\n    int64_t sum_cost=0;\n    rep(i,0,m){\n        edge &e=edges[i];\n        if(uf.is_same_group(e.to,e.from)) continue;\n        uf.unite(e.to,e.from);\n        sum_cost+=e.cost;\n        use[i]=true;\n    }\n\n    vector<vector<pair<int,int>>> graph(n);\n    rep(i,0,m){\n        if(!use[i]) continue;\n        print(edges[i].from+1);\n        print(edges[i].to+1);\n        graph[edges[i].from].push_back(make_pair(edges[i].to,edges[i].cost));\n        graph[edges[i].to].push_back(make_pair(edges[i].from,edges[i].cost));\n    }\n\n    vector<vector<int>> max_cost(n,vector<int>(n));\n    vector<bool> done(n);\n    function<void(int,int,int)> dfs=[&](int s,int u,int ma){\n        done[u]=true;\n        max_cost[s][u]=ma;\n        for(auto &p:graph[u]){\n            if(done[p.first]) continue;\n            dfs(s,p.first,max(ma,p.second));\n        }\n        done[u]=false;\n    };\n    rep(i,0,n) dfs(i,i,0);\n    rep(i,0,n){\n        print(i+1);\n        rep(j,0,n){\n            print(j+1);\n            print(max_cost[i][j]);\n        }\n    }\n    int q;\n    cin >> q;\n    rep(i,0,q){\n        int s,t;\n        cin >> s >> t;\n        --s;\n        --t;\n        cout << sum_cost-max_cost[s][t] << endl;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.assign(n, 1);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        vector<pair<int, pair<int, int>>> es;\n        for (int i = 0; i < m; i ++) {\n                int a, b, c;\n                scanf(\"%d%d%d\", &a, &b, &c);\n                a --, b --;\n                es.push_back({c, {a, b}});\n        }\n        sort(es.begin(), es.end());\n        vector<pair<int, pair<int, int>>> use;\n        UnionFind uf(n);\n        long long tot = 0;\n        for (int i = 0; i < (int) es.size(); i ++) {\n                int a, b;\n                tie(a, b) = es[i].second;\n                if (uf.same(a, b)) continue;\n                uf.unite(a, b);\n                use.push_back(es[i]);\n                tot += es[i].first;\n        }\n        assert((int) use.size() == n - 1);\n        vector<vector<pair<int, int>>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int c = use[i].first;\n                int a = use[i].second.first;\n                int b = use[i].second.second;\n                g[a].push_back({b, c});\n                g[b].push_back({a, c});\n        }\n        int q;\n        scanf(\"%d\", &q);\n        assert(q <= 3000);\n        while (q --) {\n                int s, t;\n                scanf(\"%d%d\", &s, &t);\n                s --, t --;\n                int maxval = 0;\n                function<void (int, int, int)> dfs = [&](int u, int prev, int ma) {\n                        if (u == t) {\n                                maxval = ma;\n                                return;\n                        }\n                        for (auto e : g[u]) if (e.first != prev) {\n                                dfs(e.first, u, max(ma, e.second));\n                        }\n                };\n                dfs(s, -1, 0);\n                printf(\"%lld\\n\", tot - maxval);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  vector<int> next;\n  vector<int> last;\n  UF(int n) : par(n), sizes(n, 1), next(n, -1), last(n) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      last[i] = i;\n    }\n  }\n  int root(int x) {\n    if (x == par[x]) return x;\n    return par[x] = root(par[x]);\n  }\n  void unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n    next[last[x]] = y;\n    last[x] = last[y];\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  int size(int x) {\n    return sizes[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vv<vi> g(n);\n  rep (i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a -= 1; b -= 1;\n    g[a].pb({c, b, a});\n    g[b].pb({c, a, b});\n  }\n\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  ll cost = 0;\n  set<vi> cand;\n  cand.insert(all(g[0]));\n  while (uf.size(0) < n) {\n    vi edge = *begin(cand);\n    cand.erase(begin(cand));\n    if (uf.same(edge[1], edge[2])) {\n      continue;\n    }\n    for (int i = uf.root(0); i != -1; i = uf.next[i]) {\n      maxcost[i][edge[1]] = maxcost[edge[1]][i] = edge[0];\n    }\n    cost += edge[0];\n    uf.unite(edge[1], edge[2]);\n    cand.insert(all(g[edge[1]]));\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum;\n\t};\n\tvector<node> dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p == u) return u;\n\t\tdsu[u].p = rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tvoid merge(int u, int v)\n\t{\n\t\tu = rt(u); v = rt(v);\n\t\tif(u == v) return ;\n\t\tif(rand()&1) swap(u, v);\n\t\tdsu[v].p = u;\n\t\tdsu[u].sum += dsu[v].sum;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) == rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\n\nstruct Graph\n{\n\tstruct edge\n\t{\n\t\tint v; ll weight;\n\t};\n\tvector<vector<edge> > adj;\n\tint n;\n\t\n\tGraph(int _n)\n\t{\n\t\tadj.resize(_n);\n\t\tn = _n;\n\t}\n\t\n\tvoid addedge(int u, int v, ll c)\n\t{\n\t\tedge tmp;\n\t\ttmp.v = v; tmp.weight = c;\n\t\tadj[u].pb(tmp);\n\t\ttmp.v = u;\n\t\tadj[v].pb(tmp);\n\t}\n\t\n\tvoid reset()\n\t{\n\t\tadj.clear();\n\t}\n\t\n\tvi dist;\n\tvi par;\n\t\n\tvoid bfs(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tqueue<int> q; q.push(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid bfs01(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tdeque<int> q; q.pb(s);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front(); q.pop_front();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(dist[v] >= INFI)\n\t\t\t\t{\n\t\t\t\t\tif(w == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[v] = dist[u];\n\t\t\t\t\t\tpar[v] = u;\n\t\t\t\t\t\tq.push_front(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int s)\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0; par[s] = -1;\n\t\tpriority_queue<ii, vector<ii>, greater<ii> > pq;\n\t\tpq.push(ii(0, s));\n\t\twhile(!pq.empty())\n\t\t{\n\t\t\tint u = pq.top().se; ll d = pq.top().fi; pq.pop();\n\t\t\tfor(int i = 0; i < adj[u].size(); i++)\n\t\t\t{\n\t\t\t\tint v = adj[u][i].v; ll w = adj[u][i].weight;\n\t\t\t\tif(d + w < dist[v])\n\t\t\t\t{\n\t\t\t\t\tdist[v] = d + w;\n\t\t\t\t\tpar[v] = u;\n\t\t\t\t\tpq.push(ii(dist[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<ll> > d;\n\t\n\tvoid Floyd()\n\t{\n\t\tll INFIN = ll(1e18);\n\t\td.resize(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\td[i].assign(n, INFIN);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\td[i][adj[i][j].v] = adj[i][j].weight;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor(int k = 0; k < n; k++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool BellmanFord(int s) //returns true if negative weight cycle exists\n\t{\n\t\tll INFI = ll(1e18);\n\t\tdist.assign(n, INFI);\n\t\tpar.assign(n, -1);\n\t\tdist[s] = 0;\n\t\tfor(int step = 1; step <= n; step++)\n\t\t{\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\t\tif(dist[v] > dist[u] + w)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(step == n)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdist[v] = dist[u] + w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tll shortest(int s, int e) //returns the distance by Dijkstra\n\t{\n\t\treturn dist[e];\n\t}\n\t\n\tvector<pair<ll, ii> > edges;\n\t\n\tll Kruskal()\n\t{\n\t\tDSU dsu(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < adj[i].size(); j++)\n\t\t\t{\n\t\t\t\tint u = i; int v = adj[i][j].v; ll w = adj[i][j].weight;\n\t\t\t\tedges.pb(mp(w, mp(u, v)));\n\t\t\t}\n\t\t}\n\t\tsort(edges.begin(), edges.end());\n\t\tll ans = 0; int cnt = 0;\n\t\tfor(int i = 0; i < edges.size(); i++)\n\t\t{\n\t\t\tint u = edges[i].se.fi; int v = edges[i].se.se;\n\t\t\tif(dsu.sameset(u, v)) continue;\n\t\t\tdsu.merge(u, v);\n\t\t\tcnt++; ans += edges[i].fi;\n\t\t\tif(cnt >= n - 1) break;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nvector<pair<ii,int> > edges;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n, m;\n\tcin>>n>>m;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tint u, v, c;\n\t\tcin>>u>>v>>c;\n\t\tu--; v--;\n\t\tedges.pb(mp(mp(u,v),c));\n\t}\n\tint q; cin>>q;\n\tfor(int i = 0; i < q; i++)\n\t{\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tGraph G(n);\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tG.addedge(edges[j].fi.fi,edges[j].fi.se,edges[j].se);\n\t\t}\n\t\tG.addedge(u,v,0);\n\t\tcout<<G.Kruskal()<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<char> vc;\ntypedef vector<vector<char> > vvc;\ntypedef vector<double> vd;\ntypedef vector<vector<double> > vvd;\ntemplate<class T> using vv=vector<vector< T > >;\ntypedef deque<int> di;\ntypedef deque<deque<int> > ddi;\ntypedef deque<bool> db;\ntypedef deque<deque<bool> > ddb;\n\n// cout pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n  s << p.first << \" \" << p.second << \"\\n\"; return s;\n}\n\n// cout vector<pair>\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const vector<pair<T1, T2> >& vp) {\n  int len = vp.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) { s << vp[i]; }\n    s << \"\\n\"; return s;\n}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len = v.size(); s << \"\\n\";\n  for (int i = 0; i < len; ++i) {\n    s << v[i]; if (i < len - 1) s << \"\\t\";\n  }\n  s << \"\\n\"; return s;\n}\n\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len = vv.size();\n  for (int i = 0; i < len; ++i) { s << vv[i]; }\n  return s;\n}\n\nstruct UF {\n  vector<int> par; // parent\n  vector<int> sizes;\n  UF(int n) : par(n), sizes(n, 1) {\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n    }\n  }\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n      return;\n    }\n    if (sizes[x] < sizes[y]) {\n      swap(x, y);\n    }\n    par[y] = x;\n    sizes[x] += sizes[y];\n    sizes[y] = 0;\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vvi edge(m, vi(3));\n  rep (i, m) {\n    cin >> edge[i][1] >> edge[i][2] >> edge[i][0];\n    edge[i][1] -= 1; edge[i][2] -= 1;\n  }\n  sort(all(edge));\n  UF uf(n);\n  vvi maxcost(n, vi(n));\n  set<int> si;\n  ll cost = 0;\n  cost += edge[0][0];\n  uf.unite(edge[0][1], edge[0][2]);\n  maxcost[edge[0][1]][edge[0][2]] = maxcost[edge[0][2]][edge[0][1]] = edge[0][0];\n  si.insert(edge[0][1]);\n  si.insert(edge[0][2]);\n  FOR (i, 1, m) {\n    if (!(uf.same(edge[i][1], edge[i][2]))) {\n      cost += edge[i][0];\n      uf.unite(edge[i][1], edge[i][2]);\n      int append;\n      if (si.find(edge[i][1]) == end(si)) {\n        append = edge[i][1];\n      } else {\n        append = edge[i][2];\n      }\n      for (int x : si) {\n        maxcost[append][x] = maxcost[x][append] = edge[i][0];\n      }\n      si.insert(append);\n    }\n    if (uf.size(edge[0][1]) == n) {\n      break;\n    }\n  }\n\n  int q;\n  cin >> q;\n  vll ans(q, 0);\n  rep (j, q) {\n    int s, t;\n    cin >> s >> t;\n    s -= 1; t -= 1;\n    ans[j] = cost - maxcost[s][t];\n  }\n  rep (i, q) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> vector<T> rev(vector<T> &a) {\n    vector<T> ret = a;\n    reverse(all(ret));\n    return ret;\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    UNIQUE(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int f, t;\n    T c;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return c < b.c; }\n    bool operator>(const edge &b) const { return c > b.c; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, c, id, ty);\n        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = edges.size();\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n        edges.emplace_back(f, t, c, id, ty);\n        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.f, t = e.t, ty = e.type;\n        T c = e.c;\n        add(f, t, c, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            T c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    fora(e, g.edges) chmin(dis[e.f][e.t], e.c);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].t;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        fora(e, edges)if (e.c != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n        g[t].emplace_back(t, f, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    if (g.edges.size() == 0)return true;\n    UnionFind uf(g.n * 2);\n    for (auto &&e :g.edges)uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\n\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\nvoid solve() {\n    cin >> n >> m;\n    digraph<> g(2 * k5);\n    rep(i, m) {\n        int f, t, c;\n        cin >> f >> t >> c;\n        --f, --t;\n        g.add(f, t, c);\n    }\n    sort(g.edges);\n    UnionFind uf(k5);\n    digraph<> sg(4040);\n    fora(e, g.edges) {\n        if (uf.same(e.f, e.t))con;\n        uf.unite(e.f, e.t);\n        sg.add(e.f, e.t, e.c);\n    }\n\n    cin >> q;\n    if(q> 3000)return ;\n    while (q--) {\n        din(s, tt);\n        s--, tt--;\n        UnionFind uf(4040);\n        uf.unite(s, tt);\n        cou=0;\n        fora(e, sg.edges) {\n            if (uf.same(e.f, e.t))con;\n            uf.unite(e.f, e.t);\n            cou += e.c;\n        }\n        cout << cou << endl;\n    }\n\n\n}\nint my(int n, vi a) {\n    return 0;\n}\nint sister(int n, vi a) {\n    return 0;\n}\n\nsigned main() {\n    solve();\n\n#define _arg n,a\n    //cin>>n;\n    //na(a,n);\n    //my(_arg);\n    //cout << my(_arg) << endl;\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 3);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            cout << n << endl;\n            cout << a << endl;\n            cout << \"正解 : \" << res << endl;\n            cout << \"出力 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct edge{ int from,to,cost; };\n\nint par[4010],rnk[4010];\n\nint find(int x){\n\tif(x == par[x]) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rnk[x] < rnk[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int a,int b){\n\treturn find(a) == find(b);\n}\n\nint ma[4000][4000];\nvector<edge> G[4000],vec;\n\nvoid dfs(int v,int par,int r){\n\tfor(edge e : G[v]){\n\t\tif(e.to != par){\n\t\t\tma[e.to][r] = max(ma[v][r],e.cost);\n\t\t\tdfs(e.to,v,r);\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint n,m,q,sum = 0;\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c; a--;b--;\n\t\tvec.push_back({a,b,c});\n\t}\n\tsort(vec.begin(),vec.end(),[](const edge a,const edge b){ return a.cost < b.cost; });\n\tfor(edge e : vec){\n\t\tif(!same(e.from,e.to)){\n\t\t\tunite(e.from,e.to);\n\t\t\tsum += e.cost;\n\t\t\tG[e.from].push_back(e);\n\t\t\tG[e.to].push_back({e.to,e.from,e.cost});\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++) dfs(i,-1,i);\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tint s,t;\n\t\tcin >> s >> t; s--;t--;\n\t\tcout << sum - ma[s][t] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\n\nint par[5000];\nint find(int x){\n\tif(par[x]==-1)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{int a,b,c;};\n\nint s[200000],t[200000];\nint l[200000],r[200000];\nvector<int>query[5000];\n\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tvector<st>v,u;\n\trep(i,m){\n\t\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);a--;b--;\n\t\tv.push_back({a,b,c});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){return a.c<b.c;});\n\tmemset(par,-1,sizeof(par));\n\tll cnt=0;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tcnt+=p.c;unite(p.a,p.b);\n\t\tu.push_back(p);\n\t}\n\tint q;scanf(\"%d\",&q);\n\trep(i,q){\n\t\tscanf(\"%d%d\",&s[i],&t[i]);s[i]--;t[i]--;\n\t\tl[i]=0;r[i]=n-1;\n\t}\n\trep(i,20){\n\t\trep(j,n-1)query[j].clear();\n\t\trep(j,n){\n\t\t\tif(r[j]-l[j]>1)query[(l[j]+r[j])/2].push_back(j);\n\t\t}\n\t\tmemset(par,-1,sizeof(par));\n\t\trep(j,n-1){\n\t\t\tfor(int k:query[j]){\n\t\t\t\tif(find(s[k])!=find(t[k]))l[k]=j;\n\t\t\t\telse r[k]=j;\n\t\t\t}\n\t\t\tunite(u[j].a,u[j].b);\n\t\t}\n\t}\n\trep(i,q){\n\t\tprintf(\"%lld\\n\",cnt-u[l[i]].c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, m;\nint q;\n\nstruct edge{int cost, u, v;};\nvector<edge> edges;\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nstruct edge1{int to, cost;};\nvector<vector<edge1>> g(4000);\n\nstruct UnionFind {\n  vector<int> par, rank;\n  UnionFind(int size) : par(size), rank(size)\n  {\n    rep(i, size) par[i] = i;\n  }\n\n  int find_root(int x) {\n    if (par[x] != x) return par[x] = find_root(par[x]);\n    else return x;\n  }\n\n  bool same(int x, int y) {\n    return find_root(x) == find_root(y);\n  }\n\n  void unite(int x, int y) {\n    int u = find_root(x);\n    int v = find_root(y);\n    if (rank[u] > rank[v]) swap(u, v);\n    par[u] = v;\n    if (rank[u] == rank[v]) rank[v]++;\n  }\n};\n\nbool dfs(int now, int par, int t, int &ans) {\n  if (now == t) return true;\n  for (auto nx : g[now]) {\n    if (nx.to == par) continue;\n    if (dfs(nx.to, now, t, ans)) {\n      ans = max(ans, nx.cost);\n      return true;\n    }\n  }\n  return false;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> m;\n  rep(i, m) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    edges.push_back({c, a, b});\n  }\n  sort(all(edges), comp);\n  int sum_cost = 0;\n  UnionFind uf(n);\n  rep(i, m) {\n    edge e = edges[i];\n    if (uf.same(e.u, e.v)) continue;\n    uf.unite(e.u, e.v);\n    g[e.u].push_back({e.v, e.cost});\n    g[e.v].push_back({e.u, e.cost});\n    sum_cost += e.cost;\n  }\n\n  cin >> q;\n  rep(i, q) {\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    int ans = 0;\n    dfs(s, -1, t, ans);\n    cout << sum_cost - ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> void operator>> (istream& ist, vector<T>& vs) { for(auto& e: vs) cin >> e; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint dist[4000][4000];\nvector<pair<int, int>> G[4000];\ntuple<int, int, int> es[4000];\n\nvoid dfs(int curr, int par, int start, int max) {\n  dist[curr][start] = max;\n  for(auto const& e: G[curr]) {\n    if(e.first != par) dfs(e.first, curr, start, std::max(max, e.second));\n  }\n};\n\nint main() {\n\n  int N, M; cin >> N >> M;\n\n  rep(i, M) {\n    int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n    a--, b--;\n    es[i] = make_tuple(c, a, b);\n    G[a].push_back({b, c});\n    G[b].push_back({a, c});\n  }\n\n  sort(es, es+N);\n\n  tree::union_find uf(N);\n\n  ll rawMSTWeight = 0;\n\n  rep(i, M) {\n    int a, b, c; tie(c, a, b) = es[i];\n    if(!uf.same(a, b)) {\n      uf.unite(a, b);\n      rawMSTWeight += c;\n    }\n  }\n\n  rep(i, N) {\n    dfs(i, -1, i, 0);\n  }\n\n  int Q; cin >> Q;\n  rep(i, Q) {\n    int s, t; scanf(\"%d%d\", &s, &t); s--, t--;\n    cout << rawMSTWeight - dist[s][t] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, q;\nint d[5010];\n\nstruct edge{\n   int to, cost;\n//    edge(int to, int cost):to(to), cost(cost){}\n};\nvector<edge> G[5010]; \n\nstruct UF{\n   vector<int> par;\n   vector<int> sz;\n   UF(){}\n   UF(int n){\n       par.resize(n);\n       sz.resize(n, 1);\n       rep(i, 0, n) par[i] = i;\n   }\n   int find(int x){\n       if(x == par[x]) return x;\n       return par[x] = find(par[x]);\n   }\n   void unite(int x, int y){\n       x = find(x); y = find(y);\n       if(x == y) return;\n       if(sz[x] < sz[y]) swap(x, y);\n       sz[x] += sz[y];\n       par[y] = x;\n   }\n   bool same(int x, int y){\n       return find(x) == find(y);\n   }\n};\n\nvector<pair<int, P> > es; \nvector<int> path;\n\nvoid dfs(int now, int pre, int dest){\n    // cout << \" \" << now << \" \" << pre << endl;\n    path[now] = pre;\n    if(now == dest) return;\n    rep(i, 0, G[now].size()){\n        int next = G[now][i].to;\n        if(next == pre) continue;\n        // path[next] = now;       \n        dfs(next, now, dest);\n    }\n}\n\nint cost[4010][4010];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    rep(i, 0, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--; b--;\n        // G[a].push_back(edge{b, c});\n        // G[b].push_back(edge{a, c});\n        es.push_back(pair<int, P>(c, P(a, b)));\n        cost[a][b] = c;\n        cost[b][a] = c;\n    }\n    sort(all(es));\n    UF uf(n);\n    int sum = 0, cnt = 0;\n    rep(i, 0, es.size()){\n        int from = es[i].second.first;\n        int to = es[i].second.second;\n        if(uf.same(from, to) == false){\n            uf.unite(from, to);\n            sum += es[i].first;\n            G[from]. push_back(edge{to, es[i].first});\n            G[to]. push_back(edge{from, es[i].first});\n        }\n    }\n    // cout << sum << endl;\n    cin >> q;\n    rep(i, 0, q){\n        int s, t;\n        cin >> s >> t;\n        s--; t--;\n        path.clear(); path.resize(n, -1);\n        dfs(s, -1, t);\n        int MAX = 0;\n        int now = t;\n        while(now != s){\n            int next = path[now];\n            chmax(MAX, cost[now][next]);\n            now = next;\n        }\n        cout << sum - MAX << endl;\n        // rep(j, 0, path.size()){\n        //     cout << path[j] << \" \";\n        // }\n        // cout << endl;\n        // dijkstra(s);\n        // cout << d[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nstruct edge{\n\tint to, cost;\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint parent[4005];\nint N, M, Q;\nvector< pair<int, pair<int, int> > > vec;\nvector<edge> G[4005];\nint dist[4005][4005];\n\nvoid init(){\n\tfor(int i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t}\n}\n\nint root(int i){\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nbool same(int i, int j)\n{\n\treturn root(i) == root(j);\n}\n\nvoid unite(int i, int j)\n{\n\tint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n}\n\nvoid dfs(int v, int prev, int s, int val)\n{\n\tdist[s][v] = val;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i].to == prev) continue;\n\t\tdfs(G[v][i].to, v, s, max(val, G[v][i].cost));\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\tint a, b, c;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> a >> b >> c;\n\t\tvec.push_back( make_pair(c, make_pair(a, b) ) );\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tinit();\n\tint cost = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\ta = vec[i].second.first, b = vec[i].second.second;\n\t\tif(same(a, b)) continue;\n\t\tunite(a, b);\n\t\tcost += vec[i].first;\n\t\tG[a].push_back(edge(b, vec[i].first));\n\t\tG[b].push_back(edge(a, vec[i].first));\n\t}\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tdfs(i, -1, i, 0);\n\t}\n\t\n\tcin >> Q;\n\tint S, T;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> S >> T;\n\t\tcout << cost - dist[S][T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// ここまで\n\nuse std::io::Write;\n\nfn root(p: &Vec<i32>, mut x: usize) -> usize {\n    while p[x] >= 0 {\n        x = p[x] as usize;\n    }\n    x\n}\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        m: usize,\n        e: [(usize1, usize1, u64); m],\n        q: usize,\n        p: [(usize1, usize1); q],\n    }\n    let mut e = e;\n    e.sort_by(|a, b| a.2.cmp(&b.2));\n    let mut parent = vec![-1; n];\n    let mut cost = vec![1000000000 + 1; n];\n    let mut sum = 0;\n    for (a, b, c) in e {\n        let mut a = root(&parent, a);\n        let mut b = root(&parent, b);\n        if a == b {\n            continue;\n        }\n        sum += c;\n        if parent[a] > parent[b] {\n            std::mem::swap(&mut a, &mut b);\n        }\n        parent[a] += parent[b];\n        parent[b] = a as i32;\n        cost[b] = c;\n    }\n    for (mut s, mut t) in p {\n        let mut ans = 0;\n        while s != t {\n            if cost[s] < cost[t] {\n                ans = cost[s];\n                s = parent[s] as usize;\n            } else {\n                ans = cost[t];\n                t = parent[t] as usize;\n            }\n        }\n        writeln!(out, \"{}\", sum - ans).unwrap();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\ntypedef struct quick_find {\n  i32 *id;\n  i32 **elem;\n  i32 *size;\n  i32 *max_size;\n  i32 num;\n} quick_find;\n\nquick_find* new_quick_find (const i32 n) {\n  quick_find *q = (quick_find *) calloc (1, sizeof (quick_find));\n  q->id = (i32 *) calloc (n, sizeof (i32));\n  q->elem = (i32 **) calloc (n, sizeof (i32 *));\n  q->size = (i32 *) calloc (n, sizeof (i32));\n  q->max_size = (i32 *) calloc (n, sizeof (i32));\n  q->num = n;\n  for (i32 i = 0; i < n; ++i) {\n    q->id[i] = i;\n    q->elem[i] = (i32 *) calloc (1, sizeof (i32));\n    q->elem[i][0] = i;\n    q->size[i] = 1;\n    q->max_size[i] = 1;\n  }\n  return q;\n}\n\ni32 get_id (quick_find *q, i32 x) {\n  return q->id[x];\n}\n\ni32 get_size (quick_find *q, i32 x) {\n  return q->size[get_id (q, x)];\n}\n\nint same (quick_find *q, i32 x, i32 y) {\n  return get_id (q, x) == get_id (q, y);\n}\n\nvoid unite (quick_find *q, i32 x, i32 y) {\n  x = get_id (q, x);\n  y = get_id (q, y);\n  if (x == y) {\n    return;\n  }\n  if (q->size[x] < q->size[y]) {\n    i32 s = x;\n    x = y;\n    y = s;\n  }\n  if (q->max_size[x] < q->size[x] + q->size[y]) {\n    q->max_size[x] *= 2;\n    q->elem[x] = realloc (q->elem[x], sizeof (i32) * q->max_size[x]);\n  }\n  for (i32 i = 0; i < q->size[y]; ++i) {\n    i32 v = q->elem[y][i];\n    q->id[v] = x;\n    q->elem[x][q->size[x]++] = v;\n  }\n  free (q->elem[y]);\n  q->elem[y] = NULL;\n  q->size[y] = 0;\n}\n\nstatic void print_int(i64 n){if(n<0){putchar('-');n=-n;}if(n==0){putchar('0');return;}int s[20],len=0;while(n>0){s[len++]=n%10+'0';n/=10;}while(len>0){putchar(s[--len]);}}\nstatic i64 read_int(void){int prev='\\0';int c=getchar();while(!('0'<=c && c<='9')){prev=c;c=getchar();}i64 res=0;while('0'<=c && c<='9'){res=10*res+c-'0';c=getchar();}return prev=='-'?-res:res;}\n\nint cmp (const void *a, const void *b) {\n  i64 d = *(const i64 *)a - *(const i64 *)b;\n  return d == 0 ? 0 : d < 0 ? -1 : 1;\n}\n\nvoid run (void) {\n  i32 n = read_int();\n  i32 m = read_int();\n  i64 *e = (i64 *) calloc (m, sizeof (i64));\n  for (i32 i = 0; i < m; ++i) {\n    i32 a = read_int() - 1;\n    i32 b = read_int() - 1;\n    i32 c = read_int();\n    e[i] = ((i64)c << 30) + a * n + b;\n  }\n  qsort (e, m, sizeof (i64), cmp);\n  i32 *ans = (i32 *) calloc (n * n, sizeof (i32));\n  i64 sum = 0;\n  quick_find *q = new_quick_find (n);\n  for (i32 i = 0; i < m; ++i) {\n    i32 a = (e[i] & ((1 << 30) - 1)) / n;\n    i32 b = (e[i] & ((1 << 30) - 1)) % n;\n    if (same (q, a, b)) continue;\n    a = get_id (q, a);\n    b = get_id (q, b);\n    i32 c = e[i] >> 30;\n    sum += c;\n    for (i32 j = 0; j < q->size[a]; ++j) {\n      i32 s = q->elem[a][j];\n      for (i32 k = 0; k < q->size[b]; ++k) {\n        i32 t = q->elem[b][k];\n        ans[s * n + t] = ans[t * n + s] = c;\n      }\n    }\n    unite (q, a, b);\n  }\n  i32 iter = read_int();\n  while (iter--) {\n    i32 s = read_int() - 1;\n    i32 t = read_int() - 1;\n    print_int (sum - ans[s * n + t]);\n    putchar ('\\n');\n  }\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \ntemplate<class T>\nstruct SparseTable{\n\tvector<T> st[21];\n\tvoid Init(int N,vector<T> data){\n\t\tif(N<=0)\n\t\t\treturn;\n\t\tint h = 1;\n\t\twhile ((1 << h) < N) h++;\n\t\tfor(int i=0;i<N;i++) st[0].push_back(data[i]);\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tfor(int i=0;i<N-(1<<j)+1;i++){\n\t\t\t\tst[j].push_back(min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]));\n\t\t\t}\n\t\t}\n\t}\n\tinline int TopBit(int t){\n\t\treturn 31-__builtin_clz(t);\n\t}\n\tT GetMin(int b,int e){\n\t\tint diff = TopBit(e-b);\n\t\treturn min(st[diff][b], st[diff][e - (1 << diff)]);\n\t}\n};\nstruct LowestCommonAncestor{\n    int N;\n    vector<int> path, depth, in_order, out_order;\n    std::vector<pair<int,int>> dat;\n\tSparseTable<pair<int,int>> table;\n\n    LowestCommonAncestor(const vector<vector<int>> G,int root)\n        : N(G.size()),\n          path(N * 2 - 1),\n          depth(N * 2 - 1),\n          in_order(N),\n          out_order(N) {\n        int k = 0;\n        dfs(G, root, -1, 0, k);\n        for (int i = 0; i < (int)depth.size(); ++i){\n            dat.push_back(make_pair(depth[i],i));\n\t\t}\n\t\ttable.Init(dat.size(),dat);\n    }\n\n    int Querry(int u,int v) {\n        int l = min(in_order[u], in_order[v]);\n        int r = max(in_order[u], in_order[v]) + 1;\n        auto res = table.GetMin(l,r);\n        return path[res.second];\n    }\n\n    void dfs(const vector<vector<int>> G,int v,int f,int d,int &k) {\n        in_order[v] = k;\n        path[k] = v;\n        depth[k++] = d;\n        for (auto &e : G[v]){\n            if (e != f) {\n                dfs(G,e,v,d+1,k);\n                path[k] = v;\n                depth[k++] = d;\n            }\n        }\n        out_order[v] = k-1;\n    }\n};\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\npair<long,pair<int,int>> Edge[400000];\nlong cost[3999];\nint leader[4000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tfor(int i=0;i<M;i++){\n\t\tint f = rei()-1;\n\t\tint t = rei()-1;\n\t\tEdge[i] = {rel(),{f,t}};\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tleader[i] = i+N-1;\n\t}\n\tsort(Edge,Edge+M);\n\tvector<vector<int>> G(2*N-1);\n\tUnionFind U(N);\n\tint c = N-2;\n\tlong ans = 0;\n\tfor(int i=0;i<M;i++){\n\t\tint f = Edge[i].second.first;\n\t\tint t = Edge[i].second.second;\n\t\tif(!U.Same(f,t)){\n\t\t\tcost[c] = Edge[i].first;\n\t\t\tans += Edge[i].first;\n\t\t\tG[c].push_back(leader[U.Get(f)]);\n\t\t\tG[c].push_back(leader[U.Get(t)]);\n\t\t\tU.Union(f,t);\n\t\t\tleader[U.Get(f)] = c--;\n\t\t}\n\t}\n\tLowestCommonAncestor LCA(G,0);\n\tint Q = rei();\n\tfor(int i=0;i<Q;i++){\n\t\tint s = rei()-1;\n\t\tint t = rei()-1;\n\t\tcout << ans - cost[LCA.Querry(s+N-1,t+N-1)] << endl;;\n\t}\n\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\ntypedef ull mat[100][100];\n\null parent[5000];\null rank[5000];\n\nvoid uf_init(ull n) {\n\tfor (ull i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\trank[i] = 0;\n\t}\n}\null uf_find(ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = uf_find(parent[x]);\n}\nbool uf_union(ull a, ull b) {\n\ta = uf_find(a);\n\tb = uf_find(b);\n\tif (a == b) return false;\n\n\tif (rank[b] > rank[a]) {\n\t\tb ^= a;\n\t\ta ^= b;\n\t\tb ^= a;\n\t}\n\tparent[b] = a;\n\tif (rank[a] == rank[b]) {\n\t\trank[a]++;\n\t}\n\treturn true;\n}\n\nhwll sorted[N_MAX];\nhwllc g[N_MAX];\null gin[5000];\n\null dpar[20][5000];\null dmax[20][5000];\n\nbool iswatched[N_MAX];\null dep[N_MAX];\null dfs (ull v) {\n\tiswatched[v] = true;\n\tfor (ull i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = g[i].b;\n\t\tif (iswatched[u]) continue;\n\n\t\tdpar[0][u] = v;\n\t\tdmax[0][u] = g[i].c;\n\t\tdep[u] = dep[v] + 1;\n\t\tdfs(u);\n\t}\n\n\treturn v;\n}\n\nvoid d_init() {\n\tfor (ull i = 1; i < 20; i++) {\n\t\tfor (ull j = 0; j < n; j++) {\n\t\t\tull halfpar = dpar[i - 1][j];\n\t\t\tdpar[i][j] = dpar[i - 1][halfpar];\n\t\t\tdmax[i][j] = umax(dmax[i - 1][j], dmax[i - 1][halfpar]);\n\t\t}\n\t}\n}\n\null d_mcost(ull s, ull t) {\n\tsll i;\n\tif (dep[s] > dep[t]) {\n\t\ts ^= t;\n\t\tt ^= s;\n\t\ts ^= t;\n\t}\n\n\tull ddif = dep[t] - dep[s];\n\tull r = 0;\n\tfor (i = 19; i >= 0; i--) {\n\t\tif (ddif & (1LL << i)) {\n\t\t\tr = umax(r, dmax[i][t]);\n\t\t\tt = dpar[i][t];\n\t\t}\n\t}\n\n\tif (s == t) return r;\n\n\tfor (i = 19; i >= 0; i--) {\n\t\tif (dpar[i][s] != dpar[i][t]) {\n\t\t\tr = umax(r, umax(dmax[i][s], dmax[i][t]));\n\t\t\ts = dpar[i][s];\n\t\t\tt = dpar[i][t];\n\t\t}\n\t}\n\tr = umax(r, umax(dmax[0][s], dmax[0][t]));\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < m; i++) {\n\t\tsorted[i].a = c[i];\n\t\tsorted[i].b = i;\n\t}\n\tqsort(sorted, m, sizeof(hwll), phwllABcomp);\n\n\tuf_init(n);\n\tsum = 0;\n\tull glen = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tull v = sorted[i].b;\n\t\tif (uf_union(a[v], b[v])) {\n\t\t\tsum += c[v];\n\t\t\t\n\t\t\tg[glen].a = g[glen + 1].b = a[v];\n\t\t\tg[glen].b = g[glen + 1].a = b[v];\n\t\t\tg[glen].c = g[glen + 1].c = c[v];\n\t\t\tglen += 2;\n\t\t}\n\t}\n\tqsort(g, glen, sizeof(hwllc), ptriplecomp);\n\n\ti = 0;\n\tj = 0;\n\twhile (i < n) {\n\t\tgin[i] = j;\n\t\twhile (j < glen && g[j].a == i) j++;\n\t\ti++;\n\t}\n\tgin[n] = glen;\n\n\tdpar[0][0] = 0;\n\tdmax[0][0] = 0;\n\tdep[0] = 0;\n\tdfs(0);\n\n\td_init();\n\n\twhile (q--) {\n\t\tull s, t;\n\t\tscanf(\"%llu%llu\", &s, &t);\n\t\ts--;\n\t\tt--;\n\n\t\tprintf(\"%llu\\n\", sum - d_mcost(s, t));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < m; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\tscanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\tscanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nlong long val;\nlong long st;\nlong long fi;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    long long par;\n    long long dep;\n    long long size;\n}node;\n\nnode uft[4096];\n\nvoid resuf(){\n    long long i;\n    for(i=0;i<4096;i++){\n        uft[i].par=i;uft[i].dep=0;uft[i].size=1;\n    }\n    return;\n}\n\nlong long find(long long x){\n    if(uft[x].par==x){return x;}\n    else{uft[x].par=find(uft[x].par);return uft[x].par;}\n}\n\nvoid uni(long long x,long long y){\n    long long xp,yp;\n    xp=find(x);yp=find(y);\n    if(xp==yp){return;}\n    if(uft[xp].dep>uft[yp].dep){\n        uft[yp].par=xp;\n        uft[xp].size+=uft[yp].size;\n    }\n    else{\n        uft[xp].par=yp;\n        uft[yp].size+=uft[xp].size;\n        if(uft[xp].dep==uft[yp].dep){uft[yp].dep++;}\n    }\n    return;\n}\n\nlong long size(long long x){\n    x=find(x);\n    return uft[x].size;\n}\n\nint main(void){\n  resuf();\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t,q;\n  long long fm[4096][4096];\n  long long st,fi,te;\n  sd dat[524288];\n  sd pd[524288];\n  scanf(\"%lld%lld\",&n,&m);\n  for(i=1;i<=n;i++){\n    fm[0][i]=i;\n  }\n  for(i=0;i<m;i++){\n    scanf(\"%lld%lld%lld\",&dat[i].st,&dat[i].fi,&dat[i].val);\n  }\n  qsort(dat,m,sizeof(dat[0]),sdsortfnc);\n  c=1;r=0;\n  for(i=0;i<m;i++){\n    if(find(dat[i].st)==find(dat[i].fi)){continue;}\n    uni(dat[i].st,dat[i].fi);\n    r+=dat[i].val;\n    pd[c]=dat[i];\n    for(j=1;j<=n;j++){fm[c][j]=find(j);}\n    c++;\n  }\n  scanf(\"%lld\",&q);\n  for(i=0;i<q;i++){\n    scanf(\"%lld%lld\",&a,&b);\n    st=0;fi=c-1;\n    while(st<=fi){\n      te=(st+fi)/2;\n      if(fm[te][a]==fm[te][b]){fi=te-1;}\n      else{st=te+1;}\n    }\n    printf(\"%lld\\n\",r-pd[st].val);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct UnionFind{\n  int *parent;\n  int n;\n} UnionFind;\n\nUnionFind* newUnionFind(int n){\n  UnionFind *u=(UnionFind *)calloc(1,sizeof(UnionFind));\n  u->parent=(int *)calloc(n,sizeof(int));\n  u->n=n;\n  for(int i=0;i<n;i++) u->parent[i]=-1;\n  return u;\n}\n\nint root(UnionFind *u,int x){\n  if(u->parent[x]<0) return x;\n  return u->parent[x]=root(u,u->parent[x]);\n}\n\nint same(UnionFind *u,int x,int y){\n  return root(u,x)==root(u,y);\n}\n\nint getSize(UnionFind *u,int x){\n  return -u->parent[root(u,x)];\n}\n\nvoid unite(UnionFind *u,int x,int y){\n  x=root(u,x);\n  y=root(u,y);\n  if(x==y) return;\n  if(u->parent[x]>u->parent[y]){\n    int swap=x;\n    x=y;\n    y=swap;\n  }\n  u->parent[x]+=u->parent[y];\n  u->parent[y]=x;\n}\n\ntypedef long long int int64;\n\ntypedef struct edge{\n  int a,b,c;\n} edge;\n\nint cmp(const void *a,const void *b){\n  return ((edge *)a)->c-((edge *)b)->c;\n}\n\nvoid run(void){\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  edge *e=(edge *)calloc(m,sizeof(edge));\n  int i;\n  for(i=0;i<m;i++){\n    int a,b,c;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    a--;b--;\n    e[i]=(edge){a,b,c};\n  }\n  qsort(e,m,sizeof(edge),cmp);\n  UnionFind *u=newUnionFind(n);\n  int *sub=(int *)calloc(n*n,sizeof(int));\n  int *a=(int *)calloc(n,sizeof(int));\n  int *b=(int *)calloc(n,sizeof(int));\n  int64 sum=0;\n  for(i=0;i<m;i++){\n    if(same(u,e[i].a,e[i].b)) continue;\n    int alen=0;\n    int blen=0;\n    for(int j=0;j<n;j++){\n      if(same(u,e[i].a,j)) a[alen++]=j;\n      if(same(u,e[i].b,j)) b[blen++]=j;\n    }\n    for(int j=0;j<alen;j++){\n      for(int k=0;k<blen;k++){\n\tint v=a[j];\n\tint u=b[k];\n\tsub[v*n+u]=e[i].c;\n\tsub[u*n+v]=e[i].c;\n      }\n    }\n    sum+=e[i].c;\n    unite(u,e[i].a,e[i].b);\n  }\n  int q;\n  scanf(\"%d\",&q);\n  while(q--){\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    s--;t--;\n    printf(\"%lld\\n\",sum-sub[s*n+t]);\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nlong long val;\nlong long st;\nlong long fi;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    long long par;\n    long long dep;\n    long long size;\n}node;\n\nnode uft[4096];\n\nvoid resuf(){\n    long long i;\n    for(i=0;i<4096;i++){\n        uft[i].par=i;uft[i].dep=0;uft[i].size=1;\n    }\n    return;\n}\n\nlong long find(long long x){\n    if(uft[x].par==x){return x;}\n    else{uft[x].par=find(uft[x].par);return uft[x].par;}\n}\n\nvoid uni(long long x,long long y){\n    long long xp,yp;\n    xp=find(x);yp=find(y);\n    if(xp==yp){return;}\n    if(uft[xp].dep>uft[yp].dep){\n        uft[yp].par=xp;\n        uft[xp].size+=uft[yp].size;\n    }\n    else{\n        uft[xp].par=yp;\n        uft[yp].size+=uft[xp].size;\n        if(uft[xp].dep==uft[yp].dep){uft[yp].dep++;}\n    }\n    return;\n}\n\nlong long size(long long x){\n    x=find(x);\n    return uft[x].size;\n}\n\nint main(void){\n  resuf();\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t,q;\n  sd dat[524288];\n  sd pd[524288];\n  scanf(\"%lld%lld\",&n,&m);\n  for(i=0;i<m;i++){\n    scanf(\"%lld%lld%lld\",&dat[i].st,&dat[i].fi,&dat[i].val);\n  }\n  qsort(dat,m,sizeof(dat[0]),sdsortfnc);\n  c=1;\n  for(i=0;i<m;i++){\n    if(find(dat[i].st)==find(dat[i].fi)){continue;}\n    uni(dat[i].st,dat[i].fi);\n    pd[c]=dat[i];\n    c++;\n  }\n  qsort(&pd[1],c-1,sizeof(pd[0]),sdsortfnc);\n  scanf(\"%lld\",&q);\n  pd[0].val=0;\n  for(i=0;i<q;i++){\n    resuf();r=0;\n    scanf(\"%lld%lld\",&a,&b);\n    pd[0].st=a;pd[0].fi=b;\n    for(j=0;j<c;j++){\n      if(find(pd[j].st)==find(pd[j].fi)){continue;}\n      r+=pd[j].val;\n      uni(pd[j].st,pd[j].fi);\n    }\n    printf(\"%lld\\n\",r);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\n\nfun main(args: Array<String>) {\n  val (N, M) = readLine()!!.split(\" \").map(String::toInt)\n\n  val queue = PriorityQueue<Edge>()\n  for (i in 0..M - 1) {\n    var (a, b, c) = readLine()!!.split(\" \").map(String::toInt)\n    a -= 1\n    b -= 1\n\n    queue.add(Edge(a, b, c))\n  }\n\n  val uf = UnionFind(N)\n  val tree = arrayOfNulls<ArrayList<Edge>>(N)\n  for (i in 0..N - 1) {\n    tree[i] = ArrayList<Edge>()\n  }\n\n  var total = 0\n  while (!queue.isEmpty()) {\n    val edge = queue.poll()\n    if (uf.isSame(edge.from, edge.to)) continue\n    total += edge.weight\n    tree[edge.from]!!.add(Edge(edge.from, edge.to, edge.weight))\n    tree[edge.to]!!.add(Edge(edge.to, edge.from, edge.weight))\n    uf.unite(edge.from, edge.to)\n  }\n\n\n  val queries = arrayOfNulls<ArrayList<IntArray>>(N)\n  for (i in 0..N - 1) {\n    queries[i] = ArrayList<IntArray>()\n  }\n  val (Q) = readLine()!!.split(\" \").map(String::toInt)\n  for (i in 0..Q - 1) {\n    var (s, t) = readLine()!!.split(\" \").map(String::toInt)\n    s -= 1\n    t -= 1\n    queries[s]!!.add(intArrayOf(t, i))\n  }\n\n  val ans = LongArray(Q)\n  val max = IntArray(N)\n  for (i in 0..N - 1) {\n    Arrays.fill(max, 0)\n    dfs(i, -1, i, 0, max, tree)\n    for (q in queries[i]!!) {\n      val t = q[0]\n      val n = q[1]\n      ans[n] = (total - max[t]).toLong()\n    }\n  }\n\n  for (a in ans)\n    println(a)\n\n}\n\nfun dfs(v: Int, p: Int, start: Int, curMax: Int, max: IntArray, tree: Array<ArrayList<Edge>?>) {\n  for (edge in tree[v]!!) {\n    if (edge.to == p) continue\n    val nextMax = Math.max(curMax, edge.weight)\n    max[edge.to] = nextMax\n    dfs(edge.to, v, start, nextMax, max, tree)\n  }\n}\n\n\nclass Edge(val from: Int, val to: Int, val weight: Int) : Comparable<Edge> {\n  override fun compareTo(other: Edge): Int {\n    return this.weight - other.weight\n  }\n}\n\n\nclass UnionFind(private var size: Int) {\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  private val par: IntArray\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  private val sizes: IntArray\n\n  init {\n    par = IntArray(size)\n    sizes = IntArray(size)\n    Arrays.fill(sizes, 1)\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    for (i in 0..size - 1) par[i] = i\n  }\n\n  /**\n   * データxが属する木の根を得る\n\n   * @param x\n   * *\n   * @return\n   */\n  fun find(x: Int): Int {\n    if (x == par[x]) return x\n    par[x] = find(par[x])  // 根を張り替えながら再帰的に根ノードを探す\n    return par[x]\n  }\n\n  /**\n   * 2つのデータx, yが属する木をマージする。\n   * マージが必要なら true を返す\n\n   * @param x\n   * *\n   * @param y\n   * *\n   * @return\n   */\n  fun unite(x: Int, y: Int): Boolean {\n    var x = x\n    var y = y\n    // データの根ノードを得る\n    x = find(x)\n    y = find(y)\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return false\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) {\n      val tx = x\n      x = y\n      y = tx\n    }\n\n    // xがyの親になるように連結する\n    par[y] = x\n    sizes[x] += sizes[y]\n    sizes[y] = 0  // sizes[y]は無意味な値となるので0を入れておいてもよい\n\n    size--\n    return true\n  }\n\n  /**\n   * 2つのデータx, yが属する木が同じならtrueを返す\n\n   * @param x\n   * *\n   * @param y\n   * *\n   * @return\n   */\n  fun isSame(x: Int, y: Int): Boolean {\n    return find(x) == find(y)\n  }\n\n  /**\n   * データxが含まれる木の大きさを返す\n\n   * @param x\n   * *\n   * @return\n   */\n  fun partialSizeOf(x: Int): Int {\n    return sizes[find(x)]\n  }\n\n  /**\n   * 木の数を返す\n\n   * @return\n   */\n  fun size(): Int {\n    return size\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tfor(short i=0; i<n; i++){\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tshort a, b, s, t;\n\t\tint c;\n\t\tfor(int i=0; i<m; i++){\n\t\t\ta = (short)(in.nextInt()-1);\n\t\t\tb = (short)(in.nextInt()-1);\n\t\t\tc = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\ts = (short)(in.nextInt()-1);\n\t\t\tt = (short)(in.nextInt()-1);\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[][] query = new int[n][];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new int[vs[i].a];\n\t\t\tvs[i].a = 0;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\ts = (short)(st[i]>>30);\n\t\t\tt = (short)(st[i]&mask);\n\t\t\tquery[s][vs[s].a++] = i;\n\t\t\tquery[t][vs[t].a++] = i;\n\t\t}\n\t\tshort[] table = new short[n];\n\t\tArrays.sort(vs);\n\t\tfor(short i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\ts = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(s, (short)-1, 0);\n\t\t\tfor(int qid: query[s]){\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tt = (short)((st[qid]&mask)==s ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(short cur, short par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tshort to;\n\tint c;\n\tEdge rev;\n\tEdge(short to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass Pair implements Comparable<Pair>{\n\tint a; short b;final int hash;Pair(int a,short b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[cur] = Math.max(max[cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[M][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\tlong base = 0;\n\t\t{\n\t\t\tDJSet ds = new DJSet(N);\n\t\t\tfor (int[] e : es) {\n\t\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\t\tbase += e[2];\n\t\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\t\tds.union(e[0], e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<int[]>[] qs = new ArrayList[N];\n\t\tfor (int i = 0; i < qs.length; ++i)\n\t\t\tqs[i] = new ArrayList();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tif (s > d) {\n\t\t\t\ts ^= d;\n\t\t\t\td ^= s;\n\t\t\t\ts ^= d;\n\t\t\t}\n\t\t\tqs[s].add(new int[] { d, i });\n\t\t}\n\t\tSystem.gc();\n\t\tmax = new int[N];\n\t\tlong[] ans = new long[Q];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(max, 0);\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t\tfor (int[] a : qs[i]) {\n\t\t\t\tans[a[1]] = base - max[a[0]];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ans.length; ++i)\n\t\t\tpw.println(ans[i]);\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tlong cost;\n\n\t\tpublic Edge(int u_, int v_, long cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tlong[][] max;\n\n\tvoid dfs(int cur, int par, int src, ArrayList<Edge>[] g) {\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tmax[src][e.v] = Math.max(max[src][e.v], e.cost);\n\t\t\tdfs(e.v, cur, src, g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmax = new long[N][N];\n\t\tfor (int i = 0; i < max.length; ++i)\n\t\t\tfor (int j = 0; j < max[i].length; ++j)\n\t\t\t\tmax[i][j] = -Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tlong c = sc.nextLong();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, g);\n\t\t}\n\t\tint Q = sc.nextInt();\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tSystem.out.println(ans-max[s][d]);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[N][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (int[] e : es) {\n\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\tans += e[2];\n\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\tds.union(e[0], e[1]);\n\t\t\t}\n\t\t}\n\n\t\tSystem.gc();\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tlong cost;\n\n\t\tpublic Edge(int u_, int v_, long cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tlong[][] min;\n\n\tvoid dfs(int cur, int par, int src, ArrayList<Edge>[] g) {\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tmin[src][e.v] = Math.min(min[src][e.v], e.cost);\n\t\t\tdfs(e.v, cur, src, g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmin = new long[N][N];\n\t\tfor (int i = 0; i < min.length; ++i)\n\t\t\tfor (int j = 0; j < min[i].length; ++j)\n\t\t\t\tmin[i][j] = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tlong c = sc.nextLong();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, g);\n\t\t}\n\t\tint Q = sc.nextInt();\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tSystem.out.println(ans-min[s][d]);\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.gc();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tfor(short i=0; i<n; i++){\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tshort a, b, s, t;\n\t\tint c;\n\t\tfor(int i=0; i<m; i++){\n\t\t\ta = (short)(in.nextInt()-1);\n\t\t\tb = (short)(in.nextInt()-1);\n\t\t\tc = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\ts = (short)(in.nextInt()-1);\n\t\t\tt = (short)(in.nextInt()-1);\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[][] query = new int[n][];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new int[vs[i].a];\n\t\t\tvs[i].a = 0;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\ts = (short)(st[i]>>30);\n\t\t\tt = (short)(st[i]&mask);\n\t\t\tquery[s][vs[s].a++] = i;\n\t\t\tquery[t][vs[t].a++] = i;\n\t\t}\n\t\tshort[] table = new short[n];\n\t\tArrays.sort(vs);\n\t\tfor(short i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\ts = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(s, (short)-1, 0);\n\t\t\tfor(int qid: query[s]){\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tt = (short)((st[qid]&mask)==s ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(short cur, short par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tshort to;\n\tint c;\n\tEdge rev;\n\tEdge(short to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass Pair implements Comparable<Pair>{\n\tint a; short b;final int hash;Pair(int a,short b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tlong cost = Prim.cost;\n\t\tint q = in.nextInt();\n\t\tint[] qs = new int[q];\n\t\tint[] qt = new int[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tqs[i] = s;\n\t\t\tqt[i] = t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tArrays.sort(vs);\n\t\tbest = new int[n];\n\t\tboolean[] used = new boolean[q];\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used[qid]) continue;\n\t\t\t\tused[qid] = true;\n\t\t\t\tint t;\n\t\t\t\tif(v == qs[qid]){\n\t\t\t\t\tt = qt[qid];\n\t\t\t\t}else{\n\t\t\t\t\tt = qs[qid];\n\t\t\t\t}\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tans[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*; \n \n\nclass Main{ \n\tstatic class Edge{\n\t\tint from, to;\n\t\tlong cost;\n\t\tEdge(int f, int t, long c){from=f;to=t;cost=c;}\n\t}\n\tstatic class UF{\n\t\tint pare[];\n\t\tUF(int n){\n\t\t\tpare=new int[n];\n\t\t\tArrays.fill(pare, -1);\n\t\t}\n\t\tint root(int v){\n\t\t\tif(pare[v]<0)return v;\n\t\t\treturn pare[v]=root(pare[v]);\n\t\t}\n\t\tboolean unite(int u, int v){\n\t\t\tu=root(u);v=root(v);\n\t\t\tif(u==v)return false;\n\t\t\tif(pare[u]<pare[v]){\n\t\t\t\tint tmp=u;u=v;v=tmp;\n\t\t\t}\n\t\t\tpare[v]+=pare[u];\n\t\t\tpare[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tstatic List<Edge> edges[];\n\tstatic int[][] max;\n\tstatic void dfs(int s, int v, int maxdis){\n\t\tmax[s][v]=maxdis;\n\t\tfor(Edge e: edges[v])if(e.to!=s && max[s][e.to]==0)dfs(s, e.to, Math.max(maxdis, (int)e.cost));\n\t}\n\n\tstatic void solve(){\n\n\t\tint n = ni(), m=ni();\n\t\tPriorityQueue<Edge> que = new PriorityQueue<>((a,b)->a.cost-b.cost<0 ? -1:1);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint a=ni()-1, b=ni()-1;\n\t\t\tlong c = nl();\n\t\t\tque.add(new Edge(a,b,c));\n\t\t}\n\t\tedges = new List[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tUF uf = new UF(n);\n\t\tlong sum = 0;\n\t\twhile(!que.isEmpty()){\n\t\t\tEdge e = que.poll();\n\t\t\tif(uf.unite(e.from, e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tedges[e.from].add(e);\n\t\t\t\tedges[e.to].add(new Edge(e.to, e.from, e.cost));\n\t\t\t}\n\t\t}\n\t\tint q = ni();\n\t\tmax = new int[n][n];\n\t\tfor(int i=0;i<n;++i)dfs(i, i, 0);\n\t\twhile(q-->0){\n\t\t\tint s = ni()-1, t=ni()-1;\n\t\t\tout.println(sum-max[s][t]);\n\t\t}\n\n\n \n\t} \n \n \n \n \n\t public static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t static boolean inrange(int y, int x, int h, int w){ \n\t\t return y>=0 && y<h && x>=0 && x<w; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static<T extends Comparable> int lower_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper - lower>1){ \n\t\t int center =(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>=0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> int upper_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper-lower >1){ \n\t\t int center=(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> boolean next_permutation(List<T> list){ \n\t\t int lastIndex = list.size()-2; \n\t\t while(lastIndex>=0 && list.get(lastIndex).compareTo(list.get(lastIndex+1))>=0)--lastIndex; \n\t\t if(lastIndex<0)return false; \n\t\t int swapIndex = list.size()-1; \n\t\t while(list.get(lastIndex).compareTo(list.get(swapIndex))>=0)swapIndex--; \n\t\t T tmp = list.get(lastIndex); \n\t\t list.set(lastIndex++, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t swapIndex = list.size()-1; \n\t\t while(lastIndex<swapIndex){ \n\t\t tmp = list.get(lastIndex); \n\t\t list.set(lastIndex, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t ++lastIndex;--swapIndex; \n\t\t } \n\t\t return true; \n\t } \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint[] from = new int[M];\n\t\tint[] to = new int[M];\n\t\tint[] cost = new int[M];\n\t\tMap<Integer, Integer> costMap = new HashMap<>();\n\t\tfor (int i = 0; i < M; i ++) {\n\t\t\tfrom[i] = sc.nextInt() - 1;\n\t\t\tto[i] = sc.nextInt() - 1;\n\t\t\tcost[i] = sc.nextInt();\n\t\t\tcostMap.put(from[i] + to[i] * 4000, cost[i]);\n\t\t\tcostMap.put(to[i] + from[i] * 4000, cost[i]);\n\t\t}\n\t\tint Q = sc.nextInt();\n\t\tint[][][] g = packWU(N, from, to, cost);\n\t\tint[] p = prim(g, 0);\n\t\tint[][] g2 = parentToG(p);\n\t\t\n\t\tint[][] len = new int[N][N];\n\t\tfor (int i = 0; i < N; i ++) {\n\t\t\tdfs(i, -1, g2, len[i], costMap, 0);\n\t\t}\n\t\tlong total = 0;\n\t\tfor (int i = 0; i < N; i ++) {\n\t\t\tif (p[i] >= 0) {\n\t\t\t\ttotal += costMap.get(p[i] + i * 4000);\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < Q; i ++) {\n\t\t\tint S = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\t\n\t\t\tsb.append(total - len[S][T]);\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tprivate static void dfs(int i, int prev, int[][] g, int[] len, Map<Integer, Integer> costMap, int max) {\n\t\tlen[i] = max;\n\t\tfor (int to : g[i]) {\n\t\t\tif (to != prev) {\n\t\t\t\tdfs(to, i, g, len, costMap, Math.max(max, costMap.get(i + to * 4000)));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static int[] prim(int[][][] d, int from)\n\t{\n\t\tint n = d.length;\n\t\tfinal int[] td = new int[n];\n\t\tint[] prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tArrays.fill(td, Integer.MAX_VALUE / 3);\n\t\tBitSet visited = new BitSet();\n\t\tTreeSet<Integer> q = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif(td[a] - td[b] != 0)return td[a] - td[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\t\tq.add(from);\n\t\ttd[from] = 0;\n\t\t\n\t\twhile(q.size() > 0){\n\t\t\tint cur = q.pollFirst();\n\t\t\tvisited.set(cur);\n\t\t\t\n\t\t\tfor(int[] tar : d[cur]) {\n\t\t\t\tint nex = tar[0];\n\t\t\t\tint nd = tar[1];\n\t\t\t\tif(!visited.get(nex)){\n\t\t\t\t\tif(nd < td[nex]){\n\t\t\t\t\t\tq.remove(nex);\n\t\t\t\t\t\ttd[nex] = nd;\n\t\t\t\t\t\tprev[nex] = cur;\n\t\t\t\t\t\tq.add(nex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn prev;\n\t}\n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w)\n\t{\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]++;\n\t\tfor(int t : to)p[t]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n}\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static int n,m;\n    static int[][] vmax;\n    static List<Edge>[] mst;\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        int inf = (int)1e9;\n        \n        n = Integer.parseInt(sc.next());\n        m = Integer.parseInt(sc.next());\n        \n        Kruskal kr = new Kruskal(n);\n        for(int i=0; i<m; i++){\n            int a = Integer.parseInt(sc.next())-1;\n            int b = Integer.parseInt(sc.next())-1;\n            int c = Integer.parseInt(sc.next());\n            kr.addEdge(a, b, c);\n        }\n        \n        long sum = kr.kruskal();\n        mst = kr.getMST();\n        \n        vmax = new int[n][n];\n        for(int i=0; i<n; i++){\n            maxv(i);\n        }\n        \n        int q = Integer.parseInt(sc.next());\n        for(int i=0; i<q; i++){\n            int s = Integer.parseInt(sc.next())-1;\n            int t = Integer.parseInt(sc.next())-1;\n            System.out.println(sum - vmax[s][t]);\n        }\n    }\n    \n    public static void maxv(int s){\n        ArrayDeque<Integer> q = new ArrayDeque<>();\n        q.addLast(s);\n        boolean[] used = new boolean[n];\n        while(q.size() != 0){\n            int now = q.pollFirst();\n            used[now] = true;\n            for(int i=0; i<mst[now].size(); i++){\n                Edge e = mst[now].get(i);\n                if(!used[e.to]){\n                    int tmp = Math.max(vmax[s][now], e.cost);\n                    vmax[s][e.to] = Math.max(vmax[s][e.to], tmp);\n                    q.add(e.to);\n                }\n            }\n        }\n    }\n}\n\nclass Kruskal{\n    private int n;\n    private List<Edge> edge;\n    private List<Edge>[] mst;\n    private UnionFind uf;\n    \n    public Kruskal(int n){\n        this.n = n;\n        edge = new ArrayList<>();\n        mst = new List[n];\n        for(int i=0; i<n; i++){\n            mst[i] = new ArrayList<>();\n        }\n        uf = new UnionFind(n);\n    }\n    \n    public void addEdge(int from, int to, int cost){\n        edge.add(new Edge(from, to, cost));\n    }\n    \n    public long kruskal(){\n        long sum = 0;\n        Collections.sort(edge);\n        for(int i=0; i<edge.size(); i++){\n            Edge e = edge.get(i);\n            if(uf.unite(e.from, e.to)){\n                mst[e.from].add(new Edge(e.from, e.to, e.cost));\n                mst[e.to].add(new Edge(e.to, e.from, e.cost));\n                sum += e.cost;\n            }\n        }\n        return sum;\n    }\n    \n    public List<Edge>[] getMST(){\n        return mst;\n    }\n}\n\nclass UnionFind{\n    static int[] par;\n    static int[] rank;\n    \n    public UnionFind(int n){\n        par = new int[n];\n        Arrays.fill(par, -1);\n        rank = new int[n];\n    }\n    \n    public static int find(int x){\n        if(par[x] < 0){\n            return x;\n        }else{\n            par[x] = find(par[x]);\n            return par[x];\n        }\n    }\n    \n    public static boolean unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return false;\n        \n        if(rank[x]<rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n        \n        return true;\n    }\n    \n    public static boolean same(int x, int y){\n        return find(x)==find(y);\n    }\n}\n\n \nclass Edge implements Comparable<Edge>{\n    public int from = 0;\n    public int to = 0;\n    public int cost = 0;\n    \n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    \n    @Override\n    public int compareTo(Edge o) {\n        return this.cost - o.cost;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tlong cost = Prim.cost;\n\t\tint q = in.nextInt();\n\t\tint[] qs = new int[q];\n\t\tint[] qt = new int[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tqs[i] = s;\n\t\t\tqt[i] = t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tboolean[] used = new boolean[q];\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used[qid]) continue;\n\t\t\t\tused[qid] = true;\n\t\t\t\tint t;\n\t\t\t\tif(v == qs[qid]){\n\t\t\t\t\tt = qt[qid];\n\t\t\t\t}else{\n\t\t\t\t\tt = qs[qid];\n\t\t\t\t}\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tans[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\nclass DisjointSet {\n  public int[] upper;\n\n  public DisjointSet(int n) {\n    upper = new int[n];\n    Arrays.fill(upper, -1);\n  }\n\n  public DisjointSet(DisjointSet ds) {\n    this.upper = Arrays.copyOf(ds.upper, ds.upper.length);\n  }\n\n  public int root(int x) {\n    return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n  }\n\n  public boolean equiv(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  public boolean union(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (upper[y] < upper[x]) {\n        int d = x;\n        x = y;\n        y = d;\n      }\n      upper[x] += upper[y];\n      upper[y] = x;\n    }\n    return x == y;\n  }\n\n  public int count() {\n    int ct = 0;\n    for (int u : upper) {\n      if (u < 0)\n        ct++;\n    }\n    return ct;\n  }\n\n  public int[][] toBucket() {\n    int n = upper.length;\n    int[][] ret = new int[n][];\n    int[] rp = new int[n];\n    for (int i = 0; i < n; i++) {\n      if (upper[i] < 0)\n        ret[i] = new int[-upper[i]];\n    }\n    for (int i = 0; i < n; i++) {\n      int r = root(i);\n      ret[r][rp[r]++] = i;\n    }\n    return ret;\n  }\n}\n\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int[] from = new int[m];\n    int[] to = new int[m];\n    int[] w = new int[m];\n    for (int i = 0; i < m; i++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n      w[i] = ni();\n    }\n    int[][] k = kruskal(from, to, w, n);\n    from = k[0];\n    to = k[1];\n    w = k[2];\n    m = k.length;\n    long total = 0;\n    for (int i = 0; i < m; i ++) {\n      total += w[i];\n    }\n\n    int[][][] g = packWU(n, from, to, w);\n    int[][] max = new int[n][n];\n    for (int i = 0; i < n; i ++) {\n      dfs(i, -1, g, max, i);\n    }\n    \n    int q = ni();\n    for (int i = 0; i < q; i ++) {\n      int s = ni() - 1;\n      int t = ni() - 1;\n      \n      out.println(total - max[s][t]);\n    }\n  }\n\n\n\n  private static void dfs(int v, int pre, int[][][] g, int[][] max, int start) {\n    for (int[] u : g[v]) {\n      if (u[0] == pre) {\n        continue;\n      }\n      max[start][u[0]] = Math.max(max[start][v], u[1]);\n      dfs(u[0], v, g, max, start);\n    }\n  }\n\n\n  public static int[][][] packWU(int n, int[] from, int[] to, int[] w){ return packWU(n, from, to, w, from.length); }\n  public static int[][][] packWU(int n, int[] from, int[] to, int[] w, int sup)\n  {\n      int[][][] g = new int[n][][];\n      int[] p = new int[n];\n      for(int i = 0;i < sup;i++)p[from[i]]++;\n      for(int i = 0;i < sup;i++)p[to[i]]++;\n      for(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n      for(int i = 0;i < sup;i++){\n          --p[from[i]];\n          g[from[i]][p[from[i]]][0] = to[i];\n          g[from[i]][p[from[i]]][1] = w[i];\n          --p[to[i]];\n          g[to[i]][p[to[i]]][0] = from[i];\n          g[to[i]][p[to[i]]][1] = w[i];\n      }\n      return g;\n  }\n\n  public static int[][] kruskal(int[] one, int[] other, int[] w, int n) {\n    DisjointSet ds = new DisjointSet(n);\n    int p = one.length;\n    long[] ord = new long[p];\n    for (int i = 0; i < p; i++)\n      ord[i] = (long) w[i] << 32 | i;\n    Arrays.sort(ord);\n\n    int[] none = new int[p];\n    int[] nother = new int[p];\n    int[] nw = new int[p];\n    int q = 0;\n    for (int i = 0; i < ord.length; i++) {\n      int cur = (int) ord[i];\n      if (!ds.equiv(one[cur], other[cur])) {\n        ds.union(one[cur], other[cur]);\n\n        none[q] = one[cur];\n        nother[q] = other[cur];\n        nw[q] = w[cur];\n        q ++;\n      }\n    }\n    none = Arrays.copyOf(none, q);\n    nother = Arrays.copyOf(nother, q);\n    nw = Arrays.copyOf(nw, q);\n\n    return new int[][] {none, nother, nw};\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static List<Edge>[] edge;\n    static int[][] vmax;\n    static int n,m;\n    \n    static ArrayDeque<Integer> q = new ArrayDeque<>();\n    static boolean[] used;\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        int inf = (int)1e9;\n        \n        n = Integer.parseInt(sc.next());\n        m = Integer.parseInt(sc.next());\n        \n        Prim pr = new Prim(n);\n        for(int i=0; i<m; i++){\n            int a = Integer.parseInt(sc.next())-1;\n            int b = Integer.parseInt(sc.next())-1;\n            int c = Integer.parseInt(sc.next());\n            pr.addEdge(a, b, c);\n        }\n        \n        //ここから引く\n        long all = pr.prim();\n        //System.out.println(all);\n        \n        edge = pr.getNewEdge();\n        vmax = new int[n][n];\n        for(int i=0; i<n; i++){\n            Arrays.fill(vmax[i], -1);\n        }\n        used = new boolean[n];\n        \n        int q = Integer.parseInt(sc.next());\n        for(int i=0; i<q; i++){\n            int s = Integer.parseInt(sc.next())-1;\n            int t = Integer.parseInt(sc.next())-1;\n            System.out.println(all - maxv(s,t));\n        }\n    }\n    \n    public static int maxv(int s, int t){\n        int max = 0;\n        q.clear();\n        q.add(s);\n        Arrays.fill(used, false);\n        while(q.size() != 0){\n            int now = q.pollFirst();\n            used[now] = true;\n            for(int i=0; i<edge[now].size(); i++){\n                Edge e = edge[now].get(i);\n                vmax[s][e.to] = Math.max(vmax[s][now], e.cost);\n                \n                if(vmax[s][e.to] == -1){\n                    vmax[s][e.to] = max;\n                    vmax[e.to][s] = max;\n                }\n                if(vmax[s][t] != -1){\n                    return vmax[s][t];\n                }\n                if(!used[e.to]){\n                    q.add(e.to);\n                }\n            }\n        }\n        \n        return vmax[s][t];\n    }\n}\n\n\nclass Prim{\n    \n    public static int n;\n    private static PriorityQueue<Edge>[] edge;\n    private static List<Edge>[] newEdge;\n    \n    public static final int inf = (int)10e9;\n    \n    public Prim(int n){\n        this.n = n;\n        \n        edge = new PriorityQueue[n];\n        newEdge = new List[n];\n        for(int i=0; i<n; i++){\n            edge[i] = new PriorityQueue<>();\n            newEdge[i] = new ArrayList<>();\n        }\n    }\n    \n    public long prim(){\n        boolean[] check = new boolean[n];\n        Queue<Edge> q = new PriorityQueue<>();\n        q.add(new Edge(0,0,0));//だみー\n        \n        long res = 0;\n        \n        while(!q.isEmpty()){\n            Edge e = q.poll();\n            if(check[e.to]){\n                continue;\n            }\n            \n            check[e.to] = true;\n            res += e.cost;\n            \n            //newEdgeに追加\n            addNewEdge(e.from, e.to, e.cost);\n            \n            q.addAll(edge[e.to]);\n        }\n        \n        return res;\n    }\n    \n    public void addEdge(int from, int to, int cost){\n        //if(edge[from].size()!=0)   System.out.println(\"kizon:\" + edge[from].peek().cost + \", new:\" + cost);\n        if(edge[from].size()==0 || edge[to].size()==0 ||\n           edge[from].peek().cost > cost || edge[to].peek().cost > cost){\n            \n            edge[from].add(new Edge(from, to, cost));\n            edge[to].add(new Edge(to, from, cost));\n        }\n    }\n    \n    private void addNewEdge(int from, int to, int cost){\n        newEdge[from].add(new Edge(from, to, cost));\n        newEdge[to].add(new Edge(to, from, cost));\n    }\n    \n    public List<Edge>[] getNewEdge(){\n        edge = null;\n        return newEdge;\n    }\n}\n\n\nclass Edge implements Comparable<Edge>{\n    public int from = 0;\n    public int to = 0;\n    public int cost = 0;\n    \n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    \n    @Override\n    public int compareTo(Edge o) {\n        return this.cost - o.cost;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tlong cost = Prim.cost;\n\t\tint q = in.nextInt();\n\t\tint[] qs = new int[q];\n\t\tint[] qt = new int[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tqs[i] = s;\n\t\t\tqt[i] = t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tArrays.sort(vs);\n\t\tbest = new int[n];\n\t\tboolean[] used = new boolean[n];\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[v].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qn = query[v].poll();\n\t\t\t\tif(used[qn]) continue;\n\t\t\t\tused[qn] = true;\n\t\t\t\tint t;\n\t\t\t\tif(v == qs[qn]){\n\t\t\t\t\tt = qt[qn];\n\t\t\t\t}else{\n\t\t\t\t\tt = qs[qn];\n\t\t\t\t}\n\t\t\t\tvs[t].a--;\n\t\t\t\tans[qn] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n//\t\t\tSystem.out.printf(\"%d -> %d [%d]\", from, e.to, e.c);\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal int a = in.nextInt()-1;\n\t\t\tfinal int b = in.nextInt()-1;\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tans[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\nclass DisjointSet {\n  public int[] upper;\n\n  public DisjointSet(int n) {\n    upper = new int[n];\n    Arrays.fill(upper, -1);\n  }\n\n  public DisjointSet(DisjointSet ds) {\n    this.upper = Arrays.copyOf(ds.upper, ds.upper.length);\n  }\n\n  public int root(int x) {\n    return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n  }\n\n  public boolean equiv(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  public boolean union(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (upper[y] < upper[x]) {\n        int d = x;\n        x = y;\n        y = d;\n      }\n      upper[x] += upper[y];\n      upper[y] = x;\n    }\n    return x == y;\n  }\n\n  public int count() {\n    int ct = 0;\n    for (int u : upper) {\n      if (u < 0)\n        ct++;\n    }\n    return ct;\n  }\n\n  public int[][] toBucket() {\n    int n = upper.length;\n    int[][] ret = new int[n][];\n    int[] rp = new int[n];\n    for (int i = 0; i < n; i++) {\n      if (upper[i] < 0)\n        ret[i] = new int[-upper[i]];\n    }\n    for (int i = 0; i < n; i++) {\n      int r = root(i);\n      ret[r][rp[r]++] = i;\n    }\n    return ret;\n  }\n}\n\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int[] from = new int[m];\n    int[] to = new int[m];\n    int[] w = new int[m];\n    for (int i = 0; i < m; i++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n      w[i] = ni();\n    }\n    int[][] k = kruskal(from, to, w, n);\n    from = k[0];\n    to = k[1];\n    w = k[2];\n    m = k[0].length;\n    long total = 0;\n    for (int i = 0; i < m; i ++) {\n      total += w[i];\n    }\n\n    int[][][] g = packWU(n, from, to, w);\n    int[][] max = new int[n][n];\n    for (int i = 0; i < n; i ++) {\n      dfs(i, -1, g, max, i);\n    }\n    \n    int q = ni();\n    for (int i = 0; i < q; i ++) {\n      int s = ni() - 1;\n      int t = ni() - 1;\n      \n      out.println(total - max[s][t]);\n    }\n  }\n\n\n\n  private static void dfs(int v, int pre, int[][][] g, int[][] max, int start) {\n    for (int[] u : g[v]) {\n      if (u[0] == pre) {\n        continue;\n      }\n      max[start][u[0]] = Math.max(max[start][v], u[1]);\n      dfs(u[0], v, g, max, start);\n    }\n  }\n\n\n  public static int[][][] packWU(int n, int[] from, int[] to, int[] w){ return packWU(n, from, to, w, from.length); }\n  public static int[][][] packWU(int n, int[] from, int[] to, int[] w, int sup)\n  {\n      int[][][] g = new int[n][][];\n      int[] p = new int[n];\n      for(int i = 0;i < sup;i++)p[from[i]]++;\n      for(int i = 0;i < sup;i++)p[to[i]]++;\n      for(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n      for(int i = 0;i < sup;i++){\n          --p[from[i]];\n          g[from[i]][p[from[i]]][0] = to[i];\n          g[from[i]][p[from[i]]][1] = w[i];\n          --p[to[i]];\n          g[to[i]][p[to[i]]][0] = from[i];\n          g[to[i]][p[to[i]]][1] = w[i];\n      }\n      return g;\n  }\n\n  public static int[][] kruskal(int[] one, int[] other, int[] w, int n) {\n    DisjointSet ds = new DisjointSet(n);\n    int p = one.length;\n    long[] ord = new long[p];\n    for (int i = 0; i < p; i++)\n      ord[i] = (long) w[i] << 32 | i;\n    Arrays.sort(ord);\n\n    int[] none = new int[p];\n    int[] nother = new int[p];\n    int[] nw = new int[p];\n    int q = 0;\n    for (int i = 0; i < ord.length; i++) {\n      int cur = (int) ord[i];\n      if (!ds.equiv(one[cur], other[cur])) {\n        ds.union(one[cur], other[cur]);\n\n        none[q] = one[cur];\n        nother[q] = other[cur];\n        nw[q] = w[cur];\n        q ++;\n      }\n    }\n    none = Arrays.copyOf(none, q);\n    nother = Arrays.copyOf(nother, q);\n    nw = Arrays.copyOf(nw, q);\n\n    return new int[][] {none, nother, nw};\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal int a = in.nextInt()-1;\n\t\t\tfinal int b = in.nextInt()-1;\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    ArrayList<Edge>[] tree;\n    int[][] max;\n\n    void dfs(int v, int p, int start, int curMax) {\n      for (Edge edge : tree[v]) {\n        if (edge.to == p) continue;\n        int nextMax = Math.max(curMax, edge.weight);\n        max[start][edge.to] = nextMax;\n        dfs(edge.to, v, start, nextMax);\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n\n      PriorityQueue<Edge> queue = new PriorityQueue<>();\n      for (int i = 0; i < M; i++) {\n        int a = in.nextInt() - 1;\n        int b = in.nextInt() - 1;\n        int c = in.nextInt();\n\n        queue.add(new Edge(a, b, c));\n      }\n\n      UnionFind uf = new UnionFind(N);\n      tree = new ArrayList[N];\n      for (int i = 0; i < N; i++) {\n        tree[i] = new ArrayList<>();\n      }\n      long total = 0;\n      while (!queue.isEmpty()) {\n        Edge edge = queue.poll();\n        if (uf.isSame(edge.from, edge.to)) continue;\n        total += edge.weight;\n        tree[edge.from].add(edge);\n        tree[edge.to].add(new Edge(edge.to, edge.from, edge.weight));\n        uf.unite(edge.from, edge.to);\n      }\n\n      max = new int[N][N];\n      for (int i = 0; i < N; i++) {\n        dfs(i, -1, i, 0);\n      }\n\n      int Q = in.nextInt();\n      for (int i = 0; i < Q; i++) {\n        int s = in.nextInt() - 1;\n        int t = in.nextInt() - 1;\n        out.println(total - max[s][t]);\n      }\n\n    }\n\n    class Edge implements Comparable<Edge> {\n      int from, to, weight;\n      Edge(int from, int to, int weight) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n      }\n      @Override\n      public int compareTo(Edge o) {\n        return this.weight - o.weight;\n      }\n    }\n\n    class UnionFind {\n      // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n      private int[] par;\n      // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n      private int[] sizes;\n\n      // 木の数\n      private int size;\n\n      UnionFind(int n) {\n        par = new int[n];\n        sizes = new int[n];\n        size = n;\n        Arrays.fill(sizes, 1);\n        // 最初は全てのデータiがグループiに存在するものとして初期化\n        for (int i = 0; i < n; i++) par[i] = i;\n      }\n\n      /**\n       * データxが属する木の根を得る\n       *\n       * @param x\n       * @return\n       */\n      int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n      }\n\n      /**\n       * 2つのデータx, yが属する木をマージする。\n       * マージが必要なら true を返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean unite(int x, int y) {\n        // データの根ノードを得る\n        x = find(x);\n        y = find(y);\n\n        // 既に同じ木に属しているならマージしない\n        if (x == y) return false;\n\n        // xの木がyの木より大きくなるようにする\n        if (sizes[x] < sizes[y]) {\n          int tx = x;\n          x = y;\n          y = tx;\n        }\n\n        // xがyの親になるように連結する\n        par[y] = x;\n        sizes[x] += sizes[y];\n        sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n\n        size--;\n        return true;\n      }\n\n      /**\n       * 2つのデータx, yが属する木が同じならtrueを返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean isSame(int x, int y) {\n        return find(x) == find(y);\n      }\n\n      /**\n       * データxが含まれる木の大きさを返す\n       *\n       * @param x\n       * @return\n       */\n      int partialSizeOf(int x) {\n        return sizes[find(x)];\n      }\n\n      /**\n       * 木の数を返す\n       *\n       * @return\n       */\n      int size() {\n        return size;\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint[] from = new int[M];\n\t\tint[] to = new int[M];\n\t\tint[] cost = new int[M];\n\t\tfor (int i = 0; i < M; i ++) {\n\t\t\tfrom[i] = sc.nextInt() - 1;\n\t\t\tto[i] = sc.nextInt() - 1;\n\t\t\tcost[i] = sc.nextInt();\n\t\t}\n\t\tint Q = sc.nextInt();\n\t\tint[][][] g = packWU(N, from, to, cost);\n\t\tint[] p = prim(g, 0);\n\t\t\n\t\tint[] from2 = new int[N - 1];\n\t\tint[] to2 = new int[N - 1];\n\t\tint[] cost2 = new int[N - 1];\n\t\tint ptr = 0;\n\t\tlong total = 0;\n\t\tfor (int i = 0; i < M; i ++) {\n\t\t\tif (p[from[i]] == to[i] || p[to[i]] == from[i] ) {\n\t\t\t\tfrom2[ptr] = from[i];\n\t\t\t\tto2[ptr] = to[i];\n\t\t\t\tcost2[ptr] = cost[i];\n\t\t\t\ttotal += cost[i];\n\t\t\t\tptr ++;\n\t\t\t}\n\t\t}\n\t\tint[][][] g2 = packWU(N, from2, to2, cost2);\n\t\t\n\t\tint[][] len = new int[N][N];\n\t\tfor (int i = 0; i < N; i ++) {\n\t\t\tdfs(i, -1, g2, len[i], 0);\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < Q; i ++) {\n\t\t\tint S = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt() - 1;\n\t\t\t\n\t\t\tsb.append(total - len[S][T]);\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tprivate static void dfs(int i, int prev, int[][][] g, int[] len, int max) {\n\t\tlen[i] = max;\n\t\tfor (int[] to : g[i]) {\n\t\t\tif (to[0] != prev) {\n\t\t\t\tdfs(to[0], i, g, len, Math.max(max, to[1]));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static int[] prim(int[][][] d, int from)\n\t{\n\t\tint n = d.length;\n\t\tfinal int[] td = new int[n];\n\t\tint[] prev = new int[n];\n\t\tArrays.fill(prev, -1);\n\t\tArrays.fill(td, Integer.MAX_VALUE / 3);\n\t\tBitSet visited = new BitSet();\n\t\tTreeSet<Integer> q = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif(td[a] - td[b] != 0)return td[a] - td[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\t\tq.add(from);\n\t\ttd[from] = 0;\n\t\t\n\t\twhile(q.size() > 0){\n\t\t\tint cur = q.pollFirst();\n\t\t\tvisited.set(cur);\n\t\t\t\n\t\t\tfor(int[] tar : d[cur]) {\n\t\t\t\tint nex = tar[0];\n\t\t\t\tint nd = tar[1];\n\t\t\t\tif(!visited.get(nex)){\n\t\t\t\t\tif(nd < td[nex]){\n\t\t\t\t\t\tq.remove(nex);\n\t\t\t\t\t\ttd[nex] = nd;\n\t\t\t\t\t\tprev[nex] = cur;\n\t\t\t\t\t\tq.add(nex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn prev;\n\t}\n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w)\n\t{\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]++;\n\t\tfor(int t : to)p[t]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]][2];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n}\n\n\n\nclass FastScanner {\n\tpublic static String debug = null;\n\n\tprivate final InputStream in = System.in;\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate byte[] buffer = new byte[1024];\n\tprivate boolean eos = false;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tif (debug != null) {\n\t\t\t\t\tbuflen = debug.length();\n\t\t\t\t\tbuffer = debug.getBytes();\n\t\t\t\t\tdebug = \"\";\n\t\t\t\t\teos = true;\n\t\t\t\t} else {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen < 0) {\n\t\t\t\teos = true;\n\t\t\t\treturn false;\n\t\t\t} else if (buflen == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t}\n\n\tpublic boolean isEOS() {\n\t\treturn this.eos;\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\treturn (int) nextLong();\n\t}\n\n\tpublic long[] nextLongList(int n) {\n\t\treturn nextLongTable(1, n)[0];\n\t}\n\n\tpublic int[] nextIntList(int n) {\n\t\treturn nextIntTable(1, n)[0];\n\t}\n\n\tpublic long[][] nextLongTable(int n, int m) {\n\t\tlong[][] ret = new long[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextLong();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic int[][] nextIntTable(int n, int m) {\n\t\tint[][] ret = new int[n][m];\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tfor (int j = 0; j < m; j ++) {\n\t\t\t\tret[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal int a = in.nextInt()-1;\n\t\t\tfinal int b = in.nextInt()-1;\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, ArrayList<Edge>[] g) {\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tmax[src][e.v] = Math.max(max[src][e.v], e.cost);\n\t\t\tdfs(e.v, cur, src, g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < max.length; ++i)\n\t\t\tfor (int j = 0; j < max[i].length; ++j)\n\t\t\t\tmax[i][j] = -Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n//\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(short i=0; i<n; i++){\n//\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal short a = (short)(in.nextInt()-1);\n\t\t\tfinal short b = (short)(in.nextInt()-1);\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int s = in.nextInt()-1;\n\t\t\tfinal int t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n//\t\t\tquery[s].add(i);\n//\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[][] query = new int[n][];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new int[vs[i].a];\n\t\t\tvs[i].a = 0;\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal short s = (short)(st[i]>>30);\n\t\t\tfinal short t = (short)(st[i]&mask);\n\t\t\tquery[s][vs[s].a++] = i;\n\t\t\tquery[t][vs[t].a++] = i;\n\t\t}\n\t\tshort[] table = new short[n];\n\t\tArrays.sort(vs);\n\t\tfor(short i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal short v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, (short)-1, 0);\n\t\t\tfor(int qid: query[v]){\n//\t\t\twhile(!query[v].isEmpty()){\n//\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(short cur, short par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tshort to;\n\tint c;\n\tEdge rev;\n\tEdge(short to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass Pair implements Comparable<Pair>{\n\tint a; short b;final int hash;Pair(int a,short b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static int[][] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new int[M][3];\n        for (int i = 0; i < M; i++) {\n            E[i][0] = sc.nextInt()-1;\n            E[i][1] = sc.nextInt()-1;\n            E[i][2] = sc.nextInt();\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n        int[][] maxEdges = buildMaxEdge();\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = mstCost - maxEdges[S[i]][T[i]];\n        }\n        return ans;\n    }\n\n    static int[][] buildMaxEdge() {\n        int[][] maxEdges = new int[N][N];\n        boolean[][] used = new boolean[N][N];\n        int[] q = new int[N];\n        for (int i = 0; i < N; i++) {\n            int u = 0, v = 0;\n            q[v++] = i;\n            used[i][i] = true;\n            maxEdges[i][i] = -1;\n\n            while(u != v) {\n                int a = q[u++];\n                for (int[] e : mst[a]) {\n                    int b = e[0] == a ? e[1] : e[0];\n                    if( !used[i][b] ) {\n                        int m = Math.max(maxEdges[i][a], e[2]);\n                        q[v++] = b;\n                        maxEdges[i][b] = m;\n                        used[i][b] = true;\n                    }\n                }\n            }\n        }\n        return maxEdges;\n    }\n\n    static List<int[]>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, int[][] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e[2]));\n        List<int[]>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        UnionFind uf = new UnionFind(N);\n        for (int[] e : E) {\n            if( uf.isSame(e[0], e[1]) ) continue;\n\n            T[e[0]].add(e);\n            T[e[1]].add(e);\n            uf.unite(e[0], e[1]);\n            cost += e[2];\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    ArrayList<Edge>[] tree;\n    int[][] max;\n\n    void dfs(int v, int p, int start, int curMax) {\n      for (Edge edge : tree[v]) {\n        if (edge.to == p) continue;\n        int nextMax = Math.max(curMax, edge.weight);\n        max[start][edge.to] = nextMax;\n        dfs(edge.to, v, start, nextMax);\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n\n      long total = 0;\n      {\n        PriorityQueue<Edge> queue = new PriorityQueue<>();\n        for (int i = 0; i < M; i++) {\n          int a = in.nextInt() - 1;\n          int b = in.nextInt() - 1;\n          int c = in.nextInt();\n\n          queue.add(new Edge(a, b, c));\n        }\n\n        UnionFind uf = new UnionFind(N);\n        tree = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n          tree[i] = new ArrayList<>();\n        }\n        while (!queue.isEmpty()) {\n          Edge edge = queue.poll();\n          if (uf.isSame(edge.from, edge.to)) continue;\n          total += edge.weight;\n          tree[edge.from].add(edge);\n          tree[edge.to].add(new Edge(edge.to, edge.from, edge.weight));\n          uf.unite(edge.from, edge.to);\n        }\n      }\n\n      max = new int[N][N];\n      for (int i = 0; i < N; i++) {\n        dfs(i, -1, i, 0);\n      }\n\n      int Q = in.nextInt();\n      for (int i = 0; i < Q; i++) {\n        int s = in.nextInt() - 1;\n        int t = in.nextInt() - 1;\n        out.println(total - max[s][t]);\n      }\n\n    }\n\n    class Edge implements Comparable<Edge> {\n      int from, to, weight;\n      Edge(int from, int to, int weight) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n      }\n      @Override\n      public int compareTo(Edge o) {\n        return this.weight - o.weight;\n      }\n    }\n\n    class UnionFind {\n      // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n      private int[] par;\n      // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n      private int[] sizes;\n\n      // 木の数\n      private int size;\n\n      UnionFind(int n) {\n        par = new int[n];\n        sizes = new int[n];\n        size = n;\n        Arrays.fill(sizes, 1);\n        // 最初は全てのデータiがグループiに存在するものとして初期化\n        for (int i = 0; i < n; i++) par[i] = i;\n      }\n\n      /**\n       * データxが属する木の根を得る\n       *\n       * @param x\n       * @return\n       */\n      int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n      }\n\n      /**\n       * 2つのデータx, yが属する木をマージする。\n       * マージが必要なら true を返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean unite(int x, int y) {\n        // データの根ノードを得る\n        x = find(x);\n        y = find(y);\n\n        // 既に同じ木に属しているならマージしない\n        if (x == y) return false;\n\n        // xの木がyの木より大きくなるようにする\n        if (sizes[x] < sizes[y]) {\n          int tx = x;\n          x = y;\n          y = tx;\n        }\n\n        // xがyの親になるように連結する\n        par[y] = x;\n        sizes[x] += sizes[y];\n        sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n\n        size--;\n        return true;\n      }\n\n      /**\n       * 2つのデータx, yが属する木が同じならtrueを返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean isSame(int x, int y) {\n        return find(x) == find(y);\n      }\n\n      /**\n       * データxが含まれる木の大きさを返す\n       *\n       * @param x\n       * @return\n       */\n      int partialSizeOf(int x) {\n        return sizes[find(x)];\n      }\n\n      /**\n       * 木の数を返す\n       *\n       * @return\n       */\n      int size() {\n        return size;\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static List<Edge>[] edge;\n    static int[][] vmax;\n    static int n,m;\n    \n    static ArrayDeque<Integer> q = new ArrayDeque<>();\n    static boolean[] used;\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        int inf = (int)1e9;\n        \n        n = Integer.parseInt(sc.next());\n        m = Integer.parseInt(sc.next());\n        \n        Prim pr = new Prim(n);\n        for(int i=0; i<m; i++){\n            int a = Integer.parseInt(sc.next())-1;\n            int b = Integer.parseInt(sc.next())-1;\n            int c = Integer.parseInt(sc.next());\n            pr.addEdge(a, b, c);\n        }\n        \n        //ここから引く\n        long all = pr.prim();\n        //System.out.println(all);\n        \n        edge = pr.getNewEdge();\n        vmax = new int[n][n];\n        for(int i=0; i<n; i++){\n            Arrays.fill(vmax[i], -1);\n        }\n        used = new boolean[n];\n        \n        int q = Integer.parseInt(sc.next());\n        for(int i=0; i<q; i++){\n            int s = Integer.parseInt(sc.next())-1;\n            int t = Integer.parseInt(sc.next())-1;\n            System.out.println(all - maxv(s,t));\n        }\n    }\n    \n    public static int maxv(int s, int t){\n        int max = 0;\n        q.clear();\n        q.add(s);\n        Arrays.fill(used, false);\n        while(q.size() != 0){\n            int now = q.pollFirst();\n            used[now] = true;\n            for(int i=0; i<edge[now].size(); i++){\n                Edge e = edge[now].get(i);\n                vmax[s][e.to] = Math.max(vmax[s][now], e.cost);\n                \n                if(vmax[s][e.to] == -1){\n                    vmax[s][e.to] = max;\n                    vmax[e.to][s] = max;\n                }\n                if(vmax[s][t] != -1){\n                    return vmax[s][t];\n                }\n                if(!used[e.to]){\n                    q.add(e.to);\n                }\n            }\n        }\n        \n        return vmax[s][t];\n    }\n}\n\n\nclass Prim{\n    \n    public static int n;\n    private static List<Edge>[] edge;\n    private static List<Edge>[] newEdge;\n    \n    public static final int inf = (int)10e9;\n    \n    public Prim(int n){\n        this.n = n;\n        \n        edge = new List[n];\n        newEdge = new List[n];\n        for(int i=0; i<n; i++){\n            edge[i] = new ArrayList<>();\n            newEdge[i] = new ArrayList<>();\n        }\n    }\n    \n    public long prim(){\n        boolean[] check = new boolean[n];\n        Queue<Edge> q = new PriorityQueue<>();\n        q.add(new Edge(0,0,0));//だみー\n        \n        long res = 0;\n        \n        while(!q.isEmpty()){\n            Edge e = q.poll();\n            if(check[e.to]){\n                continue;\n            }\n            \n            check[e.to] = true;\n            res += e.cost;\n            \n            //newEdgeに追加\n            addNewEdge(e.from, e.to, e.cost);\n            \n            q.addAll(edge[e.to]);\n        }\n        \n        return res;\n    }\n    \n    public void addEdge(int from, int to, int cost){\n        edge[from].add(new Edge(from, to, cost));\n        edge[to].add(new Edge(to, from, cost));\n    }\n    \n    private void addNewEdge(int from, int to, int cost){\n        newEdge[from].add(new Edge(from, to, cost));\n        newEdge[to].add(new Edge(to, from, cost));\n    }\n    \n    public List<Edge>[] getNewEdge(){\n        for(int i=0; i<n; i++){\n            edge[i].clear();\n        }\n        edge = null;\n        return newEdge;\n    }\n}\n\n\nclass Edge implements Comparable<Edge>{\n    public int from = 0;\n    public int to = 0;\n    public int cost = 0;\n    \n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    \n    @Override\n    public int compareTo(Edge o) {\n        return this.cost - o.cost;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    ArrayList<Edge>[] tree;\n\n    void dfs(int v, int p, int start, int curMax, int[] max) {\n      for (Edge edge : tree[v]) {\n        if (edge.to == p) continue;\n        int nextMax = Math.max(curMax, edge.weight);\n        max[edge.to] = nextMax;\n        dfs(edge.to, v, start, nextMax, max);\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n\n      PriorityQueue<Edge> queue = new PriorityQueue<>();\n      for (int i = 0; i < M; i++) {\n        int a = in.nextInt() - 1;\n        int b = in.nextInt() - 1;\n        int c = in.nextInt();\n\n        queue.add(new Edge(a, b, c));\n      }\n\n      UnionFind uf = new UnionFind(N);\n      tree = new ArrayList[N];\n      for (int i = 0; i < N; i++) {\n        tree[i] = new ArrayList<>();\n      }\n\n      long total = 0;\n      while (!queue.isEmpty()) {\n        Edge edge = queue.poll();\n        if (uf.isSame(edge.from, edge.to)) continue;\n        total += edge.weight;\n        tree[edge.from].add(new Edge(edge.from, edge.to, edge.weight));\n        tree[edge.to].add(new Edge(edge.to, edge.from, edge.weight));\n        uf.unite(edge.from, edge.to);\n      }\n\n      ArrayList<int[]>[] queries = new ArrayList[N];\n      for (int i = 0; i < N; i++) {\n        queries[i] = new ArrayList<>();\n      }\n      int Q = in.nextInt();\n      for (int i = 0; i < Q; i++) {\n        int s = in.nextInt() - 1;\n        int t = in.nextInt() - 1;\n        queries[s].add(new int[]{t, i});\n      }\n\n      long[] ans = new long[N];\n      int[] max = new int[N];\n      for (int i = 0; i < N; i++) {\n        Arrays.fill(max, 0);\n        dfs(i, -1, i, 0, max);\n        for (int[] q : queries[i]) {\n          int t = q[0];\n          int n = q[1];\n          ans[n] = total - max[t];\n        }\n      }\n\n      for (long a : ans) out.println(a);\n\n    }\n\n    class Edge implements Comparable<Edge> {\n      int from, to, weight;\n      Edge(int from, int to, int weight) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n      }\n      @Override\n      public int compareTo(Edge o) {\n        return this.weight - o.weight;\n      }\n    }\n\n    class UnionFind {\n      // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n      private int[] par;\n      // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n      private int[] sizes;\n\n      // 木の数\n      private int size;\n\n      UnionFind(int n) {\n        par = new int[n];\n        sizes = new int[n];\n        size = n;\n        Arrays.fill(sizes, 1);\n        // 最初は全てのデータiがグループiに存在するものとして初期化\n        for (int i = 0; i < n; i++) par[i] = i;\n      }\n\n      /**\n       * データxが属する木の根を得る\n       *\n       * @param x\n       * @return\n       */\n      int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n      }\n\n      /**\n       * 2つのデータx, yが属する木をマージする。\n       * マージが必要なら true を返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean unite(int x, int y) {\n        // データの根ノードを得る\n        x = find(x);\n        y = find(y);\n\n        // 既に同じ木に属しているならマージしない\n        if (x == y) return false;\n\n        // xの木がyの木より大きくなるようにする\n        if (sizes[x] < sizes[y]) {\n          int tx = x;\n          x = y;\n          y = tx;\n        }\n\n        // xがyの親になるように連結する\n        par[y] = x;\n        sizes[x] += sizes[y];\n        sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n\n        size--;\n        return true;\n      }\n\n      /**\n       * 2つのデータx, yが属する木が同じならtrueを返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean isSame(int x, int y) {\n        return find(x) == find(y);\n      }\n\n      /**\n       * データxが含まれる木の大きさを返す\n       *\n       * @param x\n       * @return\n       */\n      int partialSizeOf(int x) {\n        return sizes[find(x)];\n      }\n\n      /**\n       * 木の数を返す\n       *\n       * @return\n       */\n      int size() {\n        return size;\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static int n,m;\n    static List<Edge>[] mst;\n    static int[][] vmax;\n    static boolean[] used;\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        int inf = (int)1e9;\n        \n        n = Integer.parseInt(sc.next());\n        m = Integer.parseInt(sc.next());\n        \n        Kruskal kr = new Kruskal(n);\n        for(int i=0; i<m; i++){\n            int a = Integer.parseInt(sc.next())-1;\n            int b = Integer.parseInt(sc.next())-1;\n            int c = Integer.parseInt(sc.next());\n            kr.addEdge(a, b, c);\n        }\n        \n        long sum = kr.kruskal();\n        mst = kr.getMST();\n        \n        vmax = new int[n][n];\n        used = new boolean[n];\n        for(int i=0; i<n; i++){\n            Arrays.fill(used, false);\n            dfs(i, i);\n        }\n        \n        int q = Integer.parseInt(sc.next());\n        for(int i=0; i<q; i++){\n            int s = Integer.parseInt(sc.next())-1;\n            int t = Integer.parseInt(sc.next())-1;\n            System.out.println(sum - vmax[s][t]);\n        }\n    }\n    \n    public static void dfs(int s, int now){\n        used[now] = true;\n        for(int i=0; i<mst[now].size(); i++){\n            Edge e = mst[now].get(i);\n            if(!used[e.to]){\n                int tmp = Math.max(vmax[s][now], e.cost);\n                vmax[s][e.to] = Math.max(vmax[s][e.to], tmp);\n                dfs(s, e.to);\n            }\n        }\n    }\n}\n\nclass Kruskal{\n    private int n;\n    private List<Edge> edge;\n    private List<Edge>[] mst;\n    private UnionFind uf;\n    \n    public Kruskal(int n){\n        this.n = n;\n        edge = new ArrayList<>();\n        mst = new List[n];\n        for(int i=0; i<n; i++){\n            mst[i] = new ArrayList<>();\n        }\n        uf = new UnionFind(n);\n    }\n    \n    public void addEdge(int from, int to, int cost){\n        edge.add(new Edge(from, to, cost));\n    }\n    \n    public long kruskal(){\n        long sum = 0;\n        Collections.sort(edge);\n        for(int i=0; i<edge.size(); i++){\n            Edge e = edge.get(i);\n            if(uf.unite(e.from, e.to)){\n                mst[e.from].add(new Edge(e.from, e.to, e.cost));\n                mst[e.to].add(new Edge(e.to, e.from, e.cost));\n                sum += e.cost;\n            }\n        }\n        return sum;\n    }\n    \n    public List<Edge>[] getMST(){\n        return mst;\n    }\n}\n\nclass UnionFind{\n    static int[] par;\n    static int[] rank;\n    \n    public UnionFind(int n){\n        par = new int[n];\n        Arrays.fill(par, -1);\n        rank = new int[n];\n    }\n    \n    public static int find(int x){\n        if(par[x] < 0){\n            return x;\n        }else{\n            par[x] = find(par[x]);\n            return par[x];\n        }\n    }\n    \n    public static boolean unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return false;\n        \n        if(rank[x]<rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n        \n        return true;\n    }\n    \n    public static boolean same(int x, int y){\n        return find(x)==find(y);\n    }\n}\n\n \nclass Edge implements Comparable<Edge>{\n    public int from = 0;\n    public int to = 0;\n    public int cost = 0;\n    \n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    \n    @Override\n    public int compareTo(Edge o) {\n        return this.cost - o.cost;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[M][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (int[] e : es) {\n\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\tans += e[2];\n\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\tds.union(e[0], e[1]);\n\t\t\t}\n\t\t}\n\n\t\tSystem.gc();\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static Edge[] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = calc(S[i], T[i]);\n        }\n        return ans;\n    }\n\n    static long calc(int s, int t) {\n        long maxEdge = dfs(-1, s, t, -1);\n        return mstCost - maxEdge;\n    }\n\n    static long dfs(int p, int a, int t, int maxEdge) {\n        if( a == t ) return maxEdge;\n\n        for (Edge e : mst[a]) {\n            int b = e.opposite(a);\n            if( b == p ) continue;\n\n            long ret = dfs(a, b, t, Math.max(e.c, maxEdge));\n            if( ret > 0 ) return ret;\n        }\n        return -1;\n    }\n\n    static List<Edge>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, Edge[] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e.c));\n        List<Edge>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        UnionFind uf = new UnionFind(N);\n        for (Edge e : E) {\n            if( uf.isSame(e.a, e.b) ) continue;\n\n            T[e.a].add(e);\n            T[e.b].add(e);\n            uf.unite(e.a, e.b);\n            cost += e.c;\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class Edge {\n        final int a, b, c;\n\n        public Edge(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        int opposite(int x) {\n            return a == x ? b : a;\n        }\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal short a = (short)(in.nextInt()-1);\n\t\t\tfinal short b = (short)(in.nextInt()-1);\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int s = in.nextInt()-1;\n\t\t\tfinal int t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tshort[] table = new short[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = (short)i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal short v = (short)vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, (short)-1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(short cur, short par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tshort to;\n\tint c;\n\tEdge rev;\n\tEdge(short to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n \npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] es = new int[m][];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tes[i] = new int[]{ni()-1, ni()-1, ni()};\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[2] - b[2];\n\t\t\t}\n\t\t});\n \n\t\tDJSet ds = new DJSet(n);\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tint[] w = new int[n-1];\n\t\tlong wsum = 0;\n\t\tint p = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(!ds.union(es[i][0], es[i][1])){\n\t\t\t\tfrom[p] = es[i][0];\n\t\t\t\tto[p] = es[i][1];\n\t\t\t\tw[p] = -es[i][2];\n\t\t\t\tp++;\n\t\t\t\twsum += es[i][2];\n\t\t\t}\n\t\t}\n\t\tassert p == n-1;\n\t\tint[][][] g = packWU(n, from, to, w);\n\t\tint[][] pars = parents(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2], pw = pars[4];\n\t\tint[][] spar = logstepParents(par);\n\t\tint[][] sargmins = logstepArgmins(spar, pw);\n\t\tfor(int Q = ni();Q > 0;Q--){\n\t\t\tint s = ni()-1, t = ni()-1;\n\t\t\tint arg = argmin(s, t, spar, sargmins, pw, dep);\n\t\t\tout.println(wsum+pw[arg]);\n\t\t}\n\t}\n\t\n\tpublic static int[][] logstepArgmins(int[][] sp, int[] pw)\n\t{\n\t\tint m = sp.length;\n\t\tint n = sp[0].length;\n\t\tint[][] mins = new int[m][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tmins[0][i] = i;\n\t\t}\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(sp[j-1][i] != -1){\n\t\t\t\t\tint lower = mins[j-1][i];\n\t\t\t\t\tint upper = mins[j-1][sp[j-1][i]];\n\t\t\t\t\tif(upper == -1 || pw[lower] < pw[upper]){\n\t\t\t\t\t\tmins[j][i] = lower;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmins[j][i] = upper;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tmins[j][i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mins;\n\t}\n\t\n\tpublic static int argmin(int a, int b, int[][] spar, int[][] sargmin, int[] vs, int[] dep)\n\t{\n\t\tint lca = lca2(a, b, spar, dep);\n\t\tint a0 = argminAnc(a, lca, spar, sargmin, vs, dep);\n\t\tint a1 = argminAnc(b, lca, spar, sargmin, vs, dep);\n\t\tint min = Integer.MAX_VALUE;\n\t\tint arg = -1;\n\t\tif(a0 != -1 && vs[a0] < min){\n\t\t\tmin = vs[a0];\n\t\t\targ = a0;\n\t\t}\n\t\tif(a1 != -1 && vs[a1] < min){\n\t\t\tmin = vs[a1];\n\t\t\targ = a1;\n\t\t}\n\t\treturn arg; // or min\n\t}\n\t\n\tpublic static int argminAnc(int a, int anc, int[][] spar, int[][] sargmin, int[] vs, int[] dep)\n\t{\n\t\tif(a == anc)return -1;\n\t\tint cur = a;\n\t\tint min = vs[a];\n\t\tint arg = a;\n\t\tfor(int i = dep[a] - dep[anc], k = 0;i > 0;i /= 2, k++){\n\t\t\tif((i&1)==1){\n\t\t\t\tint lv = vs[sargmin[k][cur]];\n\t\t\t\tif(lv < min){\n\t\t\t\t\tmin = lv;\n\t\t\t\t\targ = sargmin[k][cur];\n\t\t\t\t}\n\t\t\t\tcur = spar[k][cur];\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}\n \n \n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n \n\t\tif (a == b)\n\t\t\treturn a;\n\t\tint sa = a, sb = b;\n\t\tfor (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer\n\t\t\t\t.numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {\n\t\t\tif ((low ^ high) >= t) {\n\t\t\t\tif (spar[k][sa] != spar[k][sb]) {\n\t\t\t\t\tlow |= t;\n\t\t\t\t\tsa = spar[k][sa];\n\t\t\t\t\tsb = spar[k][sb];\n\t\t\t\t} else {\n\t\t\t\t\thigh = low | t - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn spar[0][sa];\n\t}\n \n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {\n\t\t\tif ((m & 1) == 1)\n\t\t\t\ta = spar[i][a];\n\t\t}\n\t\treturn a;\n\t}\n \n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n \n\t\n\tpublic static int[][] parents(int[][][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\t\tint[] dw = new int[n];\n\t\tint[] pw = new int[n];\n\t\tint[] dep = new int[n];\n \n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int[] nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex[0]) {\n\t\t\t\t\tq[r++] = nex[0];\n\t\t\t\t\tpar[nex[0]] = cur;\n\t\t\t\t\tdep[nex[0]] = dep[cur] + 1;\n\t\t\t\t\tdw[nex[0]] = dw[cur] + nex[1];\n\t\t\t\t\tpw[nex[0]] = nex[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, dep, dw, pw };\n\t}\n \n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n \n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n \n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n \n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n \n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n \n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n \n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n \n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tlong cost = Prim.cost;\n\t\tint q = in.nextInt();\n\t\tint[] qs = new int[q];\n\t\tint[] qt = new int[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tqs[i] = s;\n\t\t\tqt[i] = t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tint t;\n\t\t\t\tif(v == qs[qid]){\n\t\t\t\t\tt = qt[qid];\n\t\t\t\t}else{\n\t\t\t\t\tt = qs[qid];\n\t\t\t\t}\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tans[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tif (src > cur)\n\t\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[M][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\tlong ans = 0;\n\t\t{\n\t\t\tDJSet ds = new DJSet(N);\n\t\t\tfor (int[] e : es) {\n\t\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\t\tans += e[2];\n\t\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\t\tds.union(e[0], e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.gc();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmax[i] = new int[i + 1];\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tif (s < d) {\n\t\t\t\ts ^= d;\n\t\t\t\td ^= s;\n\t\t\t\ts ^= d;\n\t\t\t}\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[M][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\t{\n\t\t\tDJSet ds = new DJSet(N);\n\t\t\tlong ans = 0;\n\t\t\tfor (int[] e : es) {\n\t\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\t\tans += e[2];\n\t\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\t\tds.union(e[0], e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.gc();\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static int[][] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new int[M][3];\n        for (int i = 0; i < M; i++) {\n            E[i][0] = sc.nextInt()-1;\n            E[i][1] = sc.nextInt()-1;\n            E[i][2] = sc.nextInt();\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n        int[][] maxEdges = buildMaxEdge();\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = mstCost - maxEdges[S[i]][T[i]];\n        }\n        return ans;\n    }\n\n    static int[][] buildMaxEdge() {\n        int[][] maxEdges = new int[N][N];\n        boolean[][] used = new boolean[N][N];\n        int[] q = new int[N];\n        for (int i = 0; i < N; i++) {\n            int u = 0, v = 0;\n            q[v++] = i;\n            used[i][i] = true;\n            maxEdges[i][i] = -1;\n\n            while(u != v) {\n                int a = q[u++];\n\n                for (int j = 0; j < mst[a].size(); j++) {\n                    int[] e = mst[a].get(j);\n                    int b = e[0] == a ? e[1] : e[0];\n                    if( !used[i][b] ) {\n                        int m = Math.max(maxEdges[i][a], e[2]);\n                        q[v++] = b;\n                        maxEdges[i][b] = m;\n                        used[i][b] = true;\n                    }\n                }\n            }\n        }\n        return maxEdges;\n    }\n\n    static List<int[]>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, int[][] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e[2]));\n        List<int[]>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        UnionFind uf = new UnionFind(N);\n        for (int[] e : E) {\n            if( uf.isSame(e[0], e[1]) ) continue;\n\n            T[e[0]].add(e);\n            T[e[1]].add(e);\n            uf.unite(e[0], e[1]);\n            cost += e[2];\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static List<Edge>[] edge;\n    static int[][] vmax;\n    static int n,m;\n    \n    static ArrayDeque<Integer> q = new ArrayDeque<>();\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        int inf = (int)1e9;\n        \n        n = Integer.parseInt(sc.next());\n        m = Integer.parseInt(sc.next());\n        \n        Prim pr = new Prim(n);\n        for(int i=0; i<m; i++){\n            int a = Integer.parseInt(sc.next())-1;\n            int b = Integer.parseInt(sc.next())-1;\n            int c = Integer.parseInt(sc.next());\n            pr.addEdge(a, b, c);\n        }\n        \n        //ここから引く\n        long all = pr.prim();\n        //System.out.println(all);\n        \n        edge = pr.getNewEdge();\n        vmax = new int[n][n];\n        for(int i=0; i<n; i++){\n            Arrays.fill(vmax[i], -1);\n        }\n        \n        int q = Integer.parseInt(sc.next());\n        for(int i=0; i<q; i++){\n            int s = Integer.parseInt(sc.next())-1;\n            int t = Integer.parseInt(sc.next())-1;\n            System.out.println(all - maxv(s,t));\n        }\n    }\n    \n    public static int maxv(int s, int t){\n        int max = 0;\n        q.clear();\n        q.add(s);\n        boolean[] used = new boolean[n];\n        while(q.size() != 0){\n            int now = q.pollFirst();\n            used[now] = true;\n            for(int i=0; i<edge[now].size(); i++){\n                Edge e = edge[now].get(i);\n                vmax[s][e.to] = Math.max(vmax[s][now], e.cost);\n                \n                if(vmax[s][e.to] == -1){\n                    vmax[s][e.to] = max;\n                    vmax[e.to][s] = max;\n                }\n                if(vmax[s][t] != -1){\n                    return vmax[s][t];\n                }\n                if(!used[e.to]){\n                    q.add(e.to);\n                }\n            }\n        }\n        \n        return vmax[s][t];\n    }\n}\n\n\nclass Prim{\n    \n    public static int n;\n    private static List<Edge>[] edge;\n    private static List<Edge>[] newEdge;\n    \n    public static final int inf = (int)10e9;\n    \n    public Prim(int n){\n        this.n = n;\n        \n        edge = new List[n];\n        newEdge = new List[n];\n        for(int i=0; i<n; i++){\n            edge[i] = new ArrayList<>();\n            newEdge[i] = new ArrayList<>();\n        }\n    }\n    \n    public long prim(){\n        boolean[] check = new boolean[n];\n        Queue<Edge> q = new PriorityQueue<>();\n        q.add(new Edge(0,0,0));//だみー\n        \n        long res = 0;\n        \n        while(!q.isEmpty()){\n            Edge e = q.poll();\n            if(check[e.to]){\n                continue;\n            }\n            \n            check[e.to] = true;\n            res += e.cost;\n            \n            //newEdgeに追加\n            addNewEdge(e.from, e.to, e.cost);\n            \n            q.addAll(edge[e.to]);\n        }\n        \n        return res;\n    }\n    \n    public void addEdge(int from, int to, int cost){\n        edge[from].add(new Edge(from, to, cost));\n        edge[to].add(new Edge(to, from, cost));\n    }\n    \n    private void addNewEdge(int from, int to, int cost){\n        newEdge[from].add(new Edge(from, to, cost));\n        newEdge[to].add(new Edge(to, from, cost));\n    }\n    \n    public List<Edge>[] getNewEdge(){\n        edge = null;\n        return newEdge;\n    }\n}\n\n\nclass Edge implements Comparable<Edge>{\n    public int from = 0;\n    public int to = 0;\n    public int cost = 0;\n    \n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    \n    @Override\n    public int compareTo(Edge o) {\n        return this.cost - o.cost;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static Edge[] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n        int[][] maxEdges = buildMaxEdge();\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = mstCost - maxEdges[S[i]][T[i]];\n        }\n        return ans;\n    }\n\n    static int[][] buildMaxEdge() {\n        int[][] maxEdges = new int[N][N];\n        boolean[][] used = new boolean[N][N];\n        ArrayDeque<State> q = new ArrayDeque<>();\n        for (int i = 0; i < N; i++) {\n            q.add(new State(i, -1));\n            used[i][i] = true;\n            maxEdges[i][i] = -1;\n\n            while(!q.isEmpty()) {\n                State s = q.poll();\n                for (Edge e : mst[s.a]) {\n                    int b = e.opposite(s.a);\n                    if( !used[i][b] ) {\n                        int m = Math.max(s.max, e.c);\n                        q.add( new State(b, m) );\n                        maxEdges[i][b] = m;\n                        used[i][b] = true;\n                    }\n                }\n            }\n        }\n        return maxEdges;\n    }\n\n    static class State {\n        int a, max;\n\n        public State(int a, int max) {\n            this.a = a;\n            this.max = max;\n        }\n    }\n\n    static List<Edge>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, Edge[] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e.c));\n        List<Edge>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        UnionFind uf = new UnionFind(N);\n        for (Edge e : E) {\n            if( uf.isSame(e.a, e.b) ) continue;\n\n            T[e.a].add(e);\n            T[e.b].add(e);\n            uf.unite(e.a, e.b);\n            cost += e.c;\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class Edge {\n        final int a, b, c;\n\n        public Edge(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        int opposite(int x) {\n            return a == x ? b : a;\n        }\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[cur] = Math.max(max[cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[M][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\tlong base = 0;\n\t\t{\n\t\t\tDJSet ds = new DJSet(N);\n\t\t\tfor (int[] e : es) {\n\t\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\t\tbase += e[2];\n\t\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\t\tds.union(e[0], e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrayList<int[]>[] qs = new ArrayList[N];\n\t\tfor (int i = 0; i < qs.length; ++i)\n\t\t\tqs[i] = new ArrayList();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tif (s > d) {\n\t\t\t\ts ^= d;\n\t\t\t\td ^= s;\n\t\t\t\ts ^= d;\n\t\t\t}\n\t\t\tqs[s].add(new int[] { d, i });\n\t\t}\n\t\tmax = new int[N];\n\t\tlong[] ans = new long[Q];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tArrays.fill(max, 0);\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t\tfor (int[] a : qs[i]) {\n\t\t\t\tans[a[1]] = base - max[a[0]];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ans.length; ++i)\n\t\t\tpw.println(ans[i]);\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*; \n \n\nclass Main{ \n\tstatic class Edge{\n\t\tint from, to;\n\t\tlong cost;\n\t\tEdge(int f, int t, long c){from=f;to=t;cost=c;}\n\t}\n\tstatic class UF{\n\t\tint pare[];\n\t\tUF(int n){\n\t\t\tpare=new int[n];\n\t\t\tArrays.fill(pare, -1);\n\t\t}\n\t\tint root(int v){\n\t\t\tif(pare[v]<0)return v;\n\t\t\treturn pare[v]=root(pare[v]);\n\t\t}\n\t\tboolean unite(int u, int v){\n\t\t\tu=root(u);v=root(v);\n\t\t\tif(u==v)return false;\n\t\t\tif(pare[u]<pare[v]){\n\t\t\t\tint tmp=u;u=v;v=tmp;\n\t\t\t}\n\t\t\tpare[v]+=pare[u];\n\t\t\tpare[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tstatic List<Edge> edges[];\n\tstatic int[][] max = new int[4000][4000];\n\tstatic void dfs(int s, int v, int maxdis){\n\t\tmax[s][v]=maxdis;\n\t\tfor(Edge e: edges[v])if(e.to!=s && max[s][e.to]==0)dfs(s, e.to, Math.max(maxdis, (int)e.cost));\n\t}\n\n\tstatic void solve(){\n\n\t\tint n = ni(), m=ni();\n\t\tPriorityQueue<Edge> que = new PriorityQueue<>((a,b)->a.cost-b.cost<0 ? -1:1);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tint a=ni()-1, b=ni()-1;\n\t\t\tlong c = nl();\n\t\t\tque.add(new Edge(a,b,c));\n\t\t}\n\t\tedges = new List[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tUF uf = new UF(n);\n\t\tlong sum = 0;\n\t\twhile(!que.isEmpty()){\n\t\t\tEdge e = que.poll();\n\t\t\tif(uf.unite(e.from, e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tedges[e.from].add(e);\n\t\t\t\tedges[e.to].add(new Edge(e.to, e.from, e.cost));\n\t\t\t}\n\t\t}\n\t\tint q = ni();\n\t\tfor(int i=0;i<n;++i)dfs(i, i, 0);\n\t\twhile(q-->0){\n\t\t\tint s = ni()-1, t=ni()-1;\n\t\t\tout.println(sum-max[s][t]);\n\t\t}\n\n\n \n\t} \n \n \n \n \n\t public static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t static boolean inrange(int y, int x, int h, int w){ \n\t\t return y>=0 && y<h && x>=0 && x<w; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static<T extends Comparable> int lower_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper - lower>1){ \n\t\t int center =(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>=0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> int upper_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper-lower >1){ \n\t\t int center=(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> boolean next_permutation(List<T> list){ \n\t\t int lastIndex = list.size()-2; \n\t\t while(lastIndex>=0 && list.get(lastIndex).compareTo(list.get(lastIndex+1))>=0)--lastIndex; \n\t\t if(lastIndex<0)return false; \n\t\t int swapIndex = list.size()-1; \n\t\t while(list.get(lastIndex).compareTo(list.get(swapIndex))>=0)swapIndex--; \n\t\t T tmp = list.get(lastIndex); \n\t\t list.set(lastIndex++, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t swapIndex = list.size()-1; \n\t\t while(lastIndex<swapIndex){ \n\t\t tmp = list.get(lastIndex); \n\t\t list.set(lastIndex, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t ++lastIndex;--swapIndex; \n\t\t } \n\t\t return true; \n\t } \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tstatic void dump(int[]a){sb.setLength(0);for(int i=0;i<a.length;i++)\n\tsb.append(a[i]).append(\" \");out.println(sb.toString().trim());}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tlong cost = Prim.cost;\n\t\tint q = in.nextInt();\n\t\tint[] qs = new int[q];\n\t\tint[] qt = new int[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tqs[i] = s;\n\t\t\tqt[i] = t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tArrays.sort(vs);\n\t\tbest = new int[n];\n\t\tboolean[] used = new boolean[q];\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[v].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qn = query[v].poll();\n\t\t\t\tif(used[qn]) continue;\n\t\t\t\tused[qn] = true;\n\t\t\t\tint t;\n\t\t\t\tif(v == qs[qn]){\n\t\t\t\t\tt = qt[qn];\n\t\t\t\t}else{\n\t\t\t\t\tt = qs[qn];\n\t\t\t\t}\n\t\t\t\tvs[t].a--;\n\t\t\t\tans[qn] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\nclass DisjointSet {\n  public int[] upper;\n\n  public DisjointSet(int n) {\n    upper = new int[n];\n    Arrays.fill(upper, -1);\n  }\n\n  public DisjointSet(DisjointSet ds) {\n    this.upper = Arrays.copyOf(ds.upper, ds.upper.length);\n  }\n\n  public int root(int x) {\n    return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n  }\n\n  public boolean equiv(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  public boolean union(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (upper[y] < upper[x]) {\n        int d = x;\n        x = y;\n        y = d;\n      }\n      upper[x] += upper[y];\n      upper[y] = x;\n    }\n    return x == y;\n  }\n\n  public int count() {\n    int ct = 0;\n    for (int u : upper) {\n      if (u < 0)\n        ct++;\n    }\n    return ct;\n  }\n\n  public int[][] toBucket() {\n    int n = upper.length;\n    int[][] ret = new int[n][];\n    int[] rp = new int[n];\n    for (int i = 0; i < n; i++) {\n      if (upper[i] < 0)\n        ret[i] = new int[-upper[i]];\n    }\n    for (int i = 0; i < n; i++) {\n      int r = root(i);\n      ret[r][rp[r]++] = i;\n    }\n    return ret;\n  }\n}\n\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int[] from = new int[m];\n    int[] to = new int[m];\n    int[] w = new int[m];\n    for (int i = 0; i < m; i++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n      w[i] = ni();\n    }\n    int[][] k = kruskal(from, to, w, n);\n    from = k[0];\n    to = k[1];\n    w = k[2];\n    m = k.length;\n    long total = 0;\n    for (int i = 0; i < m; i ++) {\n      total += w[i];\n    }\n\n    int[][] d = new int[n][n];\n    for (int[] v : d)\n      Arrays.fill(v, Integer.MAX_VALUE / 2);\n    for (int i = 0; i < m; i++) {\n      d[from[i]][to[i]] = d[to[i]][from[i]] = w[i];\n    }\n\n    int[][] g = packU(n, from, to);\n    int[][] p3 = parents(g, 0);\n    int[] par = p3[0];\n    int[] depth = p3[2];\n    int[][] spar = logstepParents(par);\n    int[][] max = new int[n][n];\n    dfs(0, -1, g, d, max, par);\n    \n    int q = ni();\n    for (int i = 0; i < q; i ++) {\n      int s = ni() - 1;\n      int t = ni() - 1;\n      int c = lca(s, t, spar, depth);\n      \n      out.println(total - Math.max(max[c][t], max[c][s]));\n    }\n  }\n\n  public static int lca(int a, int b, int[][] spar, int[] depth) {\n    if (depth[a] < depth[b]) {\n      b = ancestor(b, depth[b] - depth[a], spar);\n    } else if (depth[a] > depth[b]) {\n      a = ancestor(a, depth[a] - depth[b], spar);\n    }\n\n    int low = -1;\n    int high = depth[a];\n    while (high - low > 1) {\n      int x = (low + high) / 2;\n      if (ancestor(a, x, spar) == ancestor(b, x, spar)) {\n        high = x;\n      } else {\n        low = x;\n      }\n    }\n    return ancestor(a, high, spar);\n  }\n\n  protected static int ancestor(int a, int m, int[][] spar) {\n    for (; m > 0 && a != -1; m &= m - 1)\n      a = spar[Integer.numberOfTrailingZeros(m)][a];\n    return a;\n  }\n\n  private static void dfs(int v, int pre, int[][] g, int[][] d, int[][] max, int[] pars) {\n    int par = v;\n    while ((par = pars[par]) >= 0) {\n      max[par][v] = Math.max(d[pre][v], max[par][v]);\n    }\n\n    for (int u : g[v]) {\n      if (u == pre) {\n        continue;\n      }\n      dfs(u, v, g, d, max, pars);\n    }\n  }\n\n  public static int[][] logstepParents(int[] par) {\n    int n = par.length;\n    int m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n    int[][] pars = new int[m][n];\n    pars[0] = par;\n    for (int j = 1; j < m; j++) {\n      for (int i = 0; i < n; i++) {\n        pars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n      }\n    }\n    return pars;\n  }\n\n  public static int[][] packU(int n, int[] from, int[] to) {\n    return packU(n, from, to, from.length);\n  }\n\n  public static int[][] packU(int n, int[] from, int[] to, int sup) {\n    int[][] g = new int[n][];\n    int[] p = new int[n];\n    for (int i = 0; i < sup; i++)\n      p[from[i]]++;\n    for (int i = 0; i < sup; i++)\n      p[to[i]]++;\n    for (int i = 0; i < n; i++)\n      g[i] = new int[p[i]];\n    for (int i = 0; i < sup; i++) {\n      g[from[i]][--p[from[i]]] = to[i];\n      g[to[i]][--p[to[i]]] = from[i];\n    }\n    return g;\n  }\n\n  public static int[][] parents(int[][] g, int root) {\n    int n = g.length;\n    int[] par = new int[n];\n    Arrays.fill(par, -1);\n\n    int[] depth = new int[n];\n    depth[0] = 0;\n\n    int[] q = new int[n];\n    q[0] = root;\n    for (int p = 0, r = 1; p < r; p++) {\n      int cur = q[p];\n      for (int nex : g[cur]) {\n        if (par[cur] != nex) {\n          q[r++] = nex;\n          par[nex] = cur;\n          depth[nex] = depth[cur] + 1;\n        }\n      }\n    }\n    return new int[][] {par, q, depth};\n  }\n\n  public static int[][] kruskal(int[] one, int[] other, int[] w, int n) {\n    DisjointSet ds = new DisjointSet(n);\n    int p = one.length;\n    long[] ord = new long[p];\n    for (int i = 0; i < p; i++)\n      ord[i] = (long) w[i] << 32 | i;\n    Arrays.sort(ord);\n\n    int[] none = new int[p];\n    int[] nother = new int[p];\n    int[] nw = new int[p];\n    int q = 0;\n    for (int i = 0; i < ord.length; i++) {\n      int cur = (int) ord[i];\n      if (!ds.equiv(one[cur], other[cur])) {\n        ds.union(one[cur], other[cur]);\n\n        none[q] = one[cur];\n        nother[q] = other[cur];\n        nw[q] = w[cur];\n        q ++;\n      }\n    }\n    none = Arrays.copyOf(none, q);\n    nother = Arrays.copyOf(nother, q);\n    nw = Arrays.copyOf(nw, q);\n\n    return new int[][] {none, nother, nw};\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint m = io.nextInt();\n\t\t\tint[][] es = io.nextIntArray2D(m, 3);\n\t\t\tint Q = io.nextInt();\n\t\t\tArrays.sort(es, (a,b)->a[2]-b[2]);\n\t\t\tUnionFind uf = new UnionFind(n+1);\n\t\t\twhile (Q-- > 0) {\n\t\t\t\tint s = io.nextInt();\n\t\t\t\tint t = io.nextInt();\n\t\t\t\tuf.clear();\n\t\t\t\tlong ans = 0;\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tif (uf.same(es[i][0], es[i][1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (s == es[i][1]) continue;\n\t\t\t\t\tif (t == es[i][1]) continue;\n\t\t\t\t\tuf.union(es[i][0], es[i][1]);\n\t\t\t\t\tans += es[i][2];\n\t\t\t\t}\n\t\t\t\tio.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tlong cost;\n\n\t\tpublic Edge(int u_, int v_, long cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tlong[][] max;\n\n\tvoid dfs(int cur, int par, int src, ArrayList<Edge>[] g) {\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tmax[src][e.v] = Math.max(max[src][e.v], e.cost);\n\t\t\tdfs(e.v, cur, src, g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmax = new long[N][N];\n\t\tfor (int i = 0; i < max.length; ++i)\n\t\t\tfor (int j = 0; j < max[i].length; ++j)\n\t\t\t\tmax[i][j] = -Long.MAX_VALUE / 3;\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tlong c = sc.nextLong();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.TreeMap;\n\npublic class Main implements Runnable{\n\tstatic ContestScanner in;static Writer out;\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n\t}\n\tpublic void run() {\n\t\ttry {\n//\t\t\tin = new ContestScanner(\"in.txt\");\n//\t\t\tout = new Writer(\"out.txt\");\n\t\t\tin = new ContestScanner();\n\t\t\tout = new Writer();\n\t\t\tMain solve = new Main();\n\t\t\tsolve.solve();\n\t\t\tin.close();\n\t\t\tout.flush();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tstatic void dump(int[]a,int n){for(int i=0;i<a.length;i++)out.printf(\"%\"+n+\"d \",a[i]);out.println();}\n\tstatic void dump(long[]a){for(int i=0;i<a.length;i++)out.print(a[i]+\" \");out.println();}\n\tstatic long pow(long a,int n){long r=1;while(n>0){if((n&1)==1)r*=a;a*=a;n>>=1;}return r;}\n\tstatic String itob(int a,int l){return String.format(\"%\"+l+\"s\",Integer.toBinaryString(a)).replace(' ','0');}\n\tstatic void sort(int[]a){m_sort(a,0,a.length,new int[a.length]);}\n\tstatic void sort(int[]a,int l){m_sort(a,0,l,new int[l]);}\n\tstatic void sort(int[]a,int l,int[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(int[]a,int s,int l,int[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(int[]a,int s,int sz,int[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];\n\t} /* qsort(3.5s)<<msort(9.5s)<<<shuffle+qsort(17s)<Arrays.sort(Integer)(20s) */\n\tstatic void sort(long[]a){m_sort(a,0,a.length,new long[a.length]);}\n\tstatic void sort(long[]a,int l){m_sort(a,0,l,new long[l]);}\n\tstatic void sort(long[]a,int l,long[]buf){m_sort(a,0,l,buf);}\n\tstatic void sort(long[]a,int s,int l,long[]buf){m_sort(a,s,l,buf);}\n\tstatic void m_sort(long[]a,int s,int sz,long[]b)\n\t{if(sz<7){for(int i=s;i<s+sz;i++)for(int j=i;j>s&&a[j-1]>a[j];j--)swap(a, j, j-1);return;}\n\tm_sort(a,s,sz/2,b);m_sort(a,s+sz/2,sz-sz/2,b);int x=s;int l=s,r=s+sz/2;final int le=s+sz/2,re=s+sz;\n\twhile(l<le&&r<re){if(a[l]>a[r])b[x++]=a[r++];else b[x++]=a[l++];}\n\twhile(r<re)b[x++]=a[r++];while(l<le)b[x++]=a[l++];for(int i=s;i<s+sz;i++)a[i]=b[i];}\n\tstatic void swap(long[]a,int i,int j){final long t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic void swap(int[]a,int i,int j){final int t=a[i];a[i]=a[j];a[j]=t;}\n\tstatic int binarySearchSmallerMax(int[]a,int v)// get maximum index which a[idx]<=v\n\t{int l=-1,r=a.length-1,s=0;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic int binarySearchSmallerMax(int[]a,int v,int l,int r)\n\t{int s=-1;while(l<=r){int m=(l+r)/2;if(a[m]>v)r=m-1;else{l=m+1;s=m;}}return s;}\n\tstatic List<Integer>[]graph(int n){List<Integer>[]g=new List[n];\n\tfor(int i=0;i<n;i++)g[i]=new ArrayList<>();return g;}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tlong cost = Prim.cost;\n\t\tint q = in.nextInt();\n\t\tint[] qs = new int[q];\n\t\tint[] qt = new int[q];\n\t\tfor(int i=0; i<q; i++){\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint t = in.nextInt()-1;\n\t\t\tqs[i] = s;\n\t\t\tqt[i] = t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tint[] table = new int[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tboolean[] used = new boolean[q];\n\t\tlong[] ans = new long[q];\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal int v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, -1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used[qid]) continue;\n\t\t\t\tused[qid] = true;\n\t\t\t\tint t;\n\t\t\t\tif(v == qs[qid]){\n\t\t\t\t\tt = qt[qid];\n\t\t\t\t}else{\n\t\t\t\t\tt = qs[qid];\n\t\t\t\t}\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tans[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(int cur, int par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, c;\n\tEdge rev;\n\tEdge(int to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic MultiSet<T> merge(MultiSet<T> set)\n\t{MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\tfor(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\nclass OrderedMultiSet<T> extends TreeMap<T, Integer>{\n\t@Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n\tpublic OrderedMultiSet<T> merge(OrderedMultiSet<T> set)\n\t{OrderedMultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n\twhile(!s.isEmpty()){l.add(s.firstEntry().getKey(),s.pollFirstEntry().getValue());}return l;}\n}\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Timer{\n\tlong time;public void set(){time=System.currentTimeMillis();}\n\tpublic long stop(){return time=System.currentTimeMillis()-time;}\n\tpublic void print(){System.out.println(\"Time: \"+(System.currentTimeMillis()-time)+\"ms\");}\n\t@Override public String toString(){return\"Time: \"+time+\"ms\";}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Integer.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tif (src > cur)\n\t\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tint[][] es = new int[M][3];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new int[] { u, v, c };\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] arg0, int[] arg1) {\n\t\t\t\treturn Integer.compare(arg0[2], arg1[2]);\n\t\t\t}\n\t\t});\n\t\tlong ans = 0;\n\t\t{\n\t\t\tDJSet ds = new DJSet(N);\n\t\t\tfor (int[] e : es) {\n\t\t\t\tif (!ds.equiv(e[0], e[1])) {\n\t\t\t\t\tans += e[2];\n\t\t\t\t\tg[e[0]].add(new Edge(e[0], e[1], e[2]));\n\t\t\t\t\tg[e[1]].add(new Edge(e[1], e[0], e[2]));\n\t\t\t\t\tds.union(e[0], e[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmax = new int[N][];\n\t\tSystem.gc();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmax[i] = new int[i + 1];\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tif (s < d) {\n\t\t\t\ts ^= d;\n\t\t\t\td ^= s;\n\t\t\t\ts ^= d;\n\t\t\t}\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(short i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal short a = (short)(in.nextInt()-1);\n\t\t\tfinal short b = (short)(in.nextInt()-1);\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int s = in.nextInt()-1;\n\t\t\tfinal int t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tshort[] table = new short[n];\n\t\tArrays.sort(vs);\n\t\tfor(short i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal short v = vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, (short)-1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(short cur, short par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tshort to;\n\tint c;\n\tEdge rev;\n\tEdge(short to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass Pair implements Comparable<Pair>{\n\tint a; short b;final int hash;Pair(int a,short b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    \n    static List<Edge>[] edge;\n    static int[][] vmax;\n    static int n,m;\n    \n    static ArrayDeque<Integer> q = new ArrayDeque<>();\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        \n        int inf = (int)1e9;\n        \n        n = Integer.parseInt(sc.next());\n        m = Integer.parseInt(sc.next());\n        \n        Prim pr = new Prim(n);\n        for(int i=0; i<m; i++){\n            int a = Integer.parseInt(sc.next())-1;\n            int b = Integer.parseInt(sc.next())-1;\n            int c = Integer.parseInt(sc.next());\n            pr.addEdge(a, b, c);\n        }\n        \n        //ここから引く\n        long all = pr.prim();\n        //System.out.println(all);\n        \n        edge = pr.newEdge;\n        vmax = new int[n][n];\n        for(int i=0; i<n; i++){\n            Arrays.fill(vmax[i], -1);\n        }\n        \n        vmax = new int[n][n];\n        for(int i=0; i<n; i++){\n            Arrays.fill(vmax[i],-1);\n        }\n        \n        int q = Integer.parseInt(sc.next());\n        for(int i=0; i<q; i++){\n            int s = Integer.parseInt(sc.next())-1;\n            int t = Integer.parseInt(sc.next())-1;\n            System.out.println(all - maxv(s,t));\n        }\n    }\n    \n    public static int maxv(int s, int t){\n        int max = 0;\n        q.clear();\n        q.add(s);\n        boolean[] used = new boolean[n];\n        while(q.size() != 0){\n            int now = q.pollFirst();\n            used[now] = true;\n            for(int i=0; i<edge[now].size(); i++){\n                Edge e = edge[now].get(i);\n                vmax[s][e.to] = Math.max(vmax[s][now], e.cost);\n                \n                if(vmax[s][e.to] == -1){\n                    vmax[s][e.to] = max;\n                    vmax[e.to][s] = max;\n                }\n                if(vmax[s][t] != -1){\n                    return vmax[s][t];\n                }\n                if(!used[e.to]){\n                    q.add(e.to);\n                }\n            }\n        }\n        \n        return vmax[s][t];\n    }\n}\n\n\nclass Prim{\n    \n    public static int n;\n    private static List<Edge>[] edge;\n    public static List<Edge>[] newEdge;\n    \n    public static final int inf = (int)10e9;\n    \n    public Prim(int n){\n        this.n = n;\n        \n        edge = new List[n];\n        newEdge = new List[n];\n        for(int i=0; i<n; i++){\n            edge[i] = new ArrayList<>();\n            newEdge[i] = new ArrayList<>();\n        }\n    }\n    \n    public long prim(){\n        boolean[] check = new boolean[n];\n        Queue<Edge> q = new PriorityQueue<>();\n        q.add(new Edge(0,0,0));//だみー\n        \n        long res = 0;\n        \n        while(!q.isEmpty()){\n            Edge e = q.poll();\n            if(check[e.to]){\n                continue;\n            }\n            \n            check[e.to] = true;\n            res += e.cost;\n            \n            //newEdgeに追加\n            addNewEdge(e.from, e.to, e.cost);\n            \n            q.addAll(edge[e.to]);\n        }\n        \n        return res;\n    }\n    \n    public void addEdge(int from, int to, int cost){\n        edge[from].add(new Edge(from, to, cost));\n        edge[to].add(new Edge(to, from, cost));\n    }\n    \n    private void addNewEdge(int from, int to, int cost){\n        newEdge[from].add(new Edge(from, to, cost));\n        newEdge[to].add(new Edge(to, from, cost));\n    }\n}\n\n\nclass Edge implements Comparable<Edge>{\n    public int from = 0;\n    public int to = 0;\n    public int cost = 0;\n    \n    public Edge(int from, int to, int cost) {\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    \n    @Override\n    public int compareTo(Edge o) {\n        return this.cost - o.cost;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint m = io.nextInt();\n\t\t\tint[][] es = io.nextIntArray2D(m, 3);\n\t\t\tint Q = io.nextInt();\n\t\t\tArrays.sort(es, (a,b)->a[2]-b[2]);\n\t\t\tUnionFind uf = new UnionFind(n+1);\n\t\t\twhile (Q-- > 0) {\n\t\t\t\tint s = io.nextInt();\n\t\t\t\tint t = io.nextInt();\n\t\t\t\tuf.clear();\n\t\t\t\tlong ans = 0;\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tif (uf.same(es[i][0], es[i][1])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (s == es[i][1]) continue;\n\t\t\t\t\tif (t == es[i][1]) continue;\n\t\t\t\t\tuf.union(es[i][0], es[i][1]);\n\t\t\t\t}\n\t\t\t\tio.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic\n\tclass UnionFind {\n\t\tprivate int[] data;\n\t\t\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tclear();\n\t\t}\n\t\t\n\t\tpublic void clear() {\n\t\t\tArrays.fill(data, -1);\n\t\t}\n\t\t\n\t\tpublic int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n\t\t\n\t\tpublic void union(int x, int y) {\n\t\t\tif((x = root(x)) != (y = root(y))) {\n\t\t\t\tif(data[y] < data[x]) { final int t = x; x = y; y = t; }\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) { return root(x) == root(y); }\n\t\tpublic int size(int x) { return -data[root(x)]; }\n\t}\n\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable{\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\t\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tlong cost;\n\n\t\tpublic Edge(int u_, int v_, long cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tlong[][] max;\n\n\tvoid dfs(int cur, int par, int src, ArrayList<Edge>[] g) {\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tmax[src][e.v] = Math.max(max[src][e.v], e.cost);\n\t\t\tdfs(e.v, cur, src, g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmax = new long[N][N];\n\t\tfor (int i = 0; i < max.length; ++i)\n\t\t\tfor (int j = 0; j < max[i].length; ++j)\n\t\t\t\tmax[i][j] = -Long.MAX_VALUE / 3;\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tlong c = sc.nextLong();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic ContestScanner in;static Writer out;static StringBuilder sb=new StringBuilder();\n\tpublic static void main(String[] args)\n\t{try{in=new ContestScanner();out=new Writer();Main solve=new Main();solve.solve();\n\tin.close();out.flush();out.close();}catch(IOException e){e.printStackTrace();}}\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tfinal int n = in.nextInt();\n\t\tfinal int m = in.nextInt();\n\t\tList<Edge>[] node = new List[n];\n\t\tPair[] vs = new Pair[n];\n\t\tQueue<Integer>[] query = new Queue[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tquery[i] = new ArrayDeque<>();\n\t\t\tvs[i] = new Pair(0, i);\n\t\t\tnode[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfinal short a = (short)(in.nextInt()-1);\n\t\t\tfinal short b = (short)(in.nextInt()-1);\n\t\t\tfinal int c = in.nextInt();\n\t\t\tEdge ea = new Edge(b, c);\n\t\t\tEdge eb = new Edge(a, c);\n\t\t\tea.rev = eb;\n\t\t\teb.rev = ea;\n\t\t\tnode[a].add(ea);\n\t\t\tnode[b].add(eb);\n\t\t}\n\t\tmst = Prim.getMst(node);\n\t\tfinal long cost = Prim.cost;\n\t\tfinal int q = in.nextInt();\n\t\tlong[] st = new long[q];\n\t\tfinal long mask = (1L<<30)-1;\n\t\tfor(int i=0; i<q; i++){\n\t\t\tfinal int s = in.nextInt()-1;\n\t\t\tfinal int t = in.nextInt()-1;\n\t\t\tst[i] = (long)s<<30 | t;\n\t\t\tquery[s].add(i);\n\t\t\tquery[t].add(i);\n\t\t\tvs[s].a++;\n\t\t\tvs[t].a++;\n\t\t}\n\t\tshort[] table = new short[n];\n\t\tArrays.sort(vs);\n\t\tfor(int i=0; i<n; i++){\n\t\t\ttable[vs[i].b] = (short)i;\n\t\t}\n\t\tbest = new int[n];\n\t\tBitSet used = new BitSet(q);\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tfinal short v = (short)vs[i].b;\n\t\t\tif(vs[i].a == 0) continue;\n\t\t\tdfs(v, (short)-1, 0);\n\t\t\twhile(!query[v].isEmpty()){\n\t\t\t\tfinal int qid = query[v].poll();\n\t\t\t\tif(used.get(qid)) continue;\n\t\t\t\tused.set(qid);\n\t\t\t\tfinal int t = (int)((st[qid]&mask)==v ? st[qid]>>30 : st[qid]&mask);\n\t\t\t\tvs[table[t]].a--;\n\t\t\t\tst[qid] = cost-best[t];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<q; i++){\n\t\t\tout.println(st[i]);\n\t\t}\n\t}\n\t\n\tint[] best;\n\tList<Edge>[] mst;\n\tvoid dfs(short cur, short par, int max){\n\t\tbest[cur] = max;\n\t\tfor(Edge e: mst[cur]){\n\t\t\tif(e.to == par) continue;\n\t\t\tdfs(e.to, cur, Math.max(max, e.c));\n\t\t}\n\t}\n}\n\nclass Prim{\n\tstatic long cost;\n\tstatic List<Edge>[] getMst(List<Edge>[] node){\n\t\tfinal int n = node.length;\n\t\tQueue<Edge> qu = new PriorityQueue<>();\n\t\tList<Edge>[] res = new List[n];\n\t\tfor(int i=0; i<n; i++) res[i] = new ArrayList<>();\n\t\tfor(Edge e: node[0]) qu.add(e);\n\t\tboolean[] used = new boolean[n];\n\t\tused[0] = true;\n\t\tcost = 0;\n\t\twhile(!qu.isEmpty()){\n\t\t\tEdge e = qu.poll();\n\t\t\tif(used[e.to]) continue;\n\t\t\tused[e.to] = true;\n\t\t\tfinal int from = e.rev.to;\n\t\t\tres[from].add(e);\n\t\t\tres[e.to].add(e.rev);\n\t\t\tcost += e.c;\n\t\t\tfor(Edge ne: node[e.to]){\n\t\t\t\tqu.add(ne);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tshort to;\n\tint c;\n\tEdge rev;\n\tEdge(short to, int c){\n\t\tthis.to = to;\n\t\tthis.c = c;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn Integer.compare(c, o.c);\n\t}\n}\n\nclass Pair implements Comparable<Pair>{\n\tint a,b;final int hash;Pair(int a,int b){this.a=a;this.b=b;hash=(a<<16|a>>16)^b;}\n\tpublic boolean equals(Object obj){Pair o=(Pair)(obj);return a==o.a&&b==o.b;}\n\tpublic int hashCode(){return hash;}\n\tpublic int compareTo(Pair o){if(a!=o.a)return a<o.a?-1:1;else if(b!=o.b)return b<o.b?-1:1;return 0;}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename)throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n\tprivate BufferedReader in;private int c=-2;\n\tpublic ContestScanner()throws IOException \n\t{in=new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename)throws IOException\n\t{in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken()throws IOException {\n\t\tStringBuilder sb=new StringBuilder();\n\t\twhile((c=in.read())!=-1&&Character.isWhitespace(c));\n\t\twhile(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic String readLine()throws IOException{\n\t\tStringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n\t\twhile(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong()throws IOException,NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt()throws NumberFormatException,IOException\n\t{return(int)nextLong();}\n\tpublic double nextDouble()throws NumberFormatException,IOException \n\t{return Double.parseDouble(nextToken());}\n\tpublic void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "// package atcoder.other2016.codefestival2016.round1;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[][] edges = in.nextIntTable(m, 3);\n        for (int i = 0; i < m ; i++) {\n            edges[i][0]--;\n            edges[i][1]--;\n        }\n\n        Arrays.sort(edges, (e0, e1) -> e0[2] - e1[2]);\n\n        long treeCost = 0;\n        UnionFind uf = new UnionFind(n);\n        int[][] subEdges = new int[n-1][3];\n        int si = 0;\n        for (int i = 0; i < m ; i++) {\n            if (!uf.issame(edges[i][0], edges[i][1])) {\n                treeCost += edges[i][2];\n                subEdges[si++] = edges[i];\n                uf.unite(edges[i][0], edges[i][1]);\n            }\n        }\n\n        tree = buildWeightedGraph(n, subEdges);\n        depth = new int[n];\n        parent = new int[15][n];\n        maxEdge = new int[15][n];\n        Arrays.fill(parent[0], -1);\n        dfs(0, -1);\n\n        for (int k = 1 ; k < 15 ; k++) {\n            for (int i = 0 ; i < n ; i++) {\n                int par = (parent[k-1][i] == -1) ? i : parent[k-1][i];\n                parent[k][i] = parent[k-1][par];\n                maxEdge[k][i] = Math.max(maxEdge[k-1][i], maxEdge[k-1][par]);\n            }\n        }\n\n        int q = in.nextInt();\n        while (--q >= 0) {\n            int s = in.nextInt()-1;\n            int t = in.nextInt()-1;\n            long max = 0;\n\n            if (depth[s] < depth[t]) {\n                int tmp = t;\n                t = s;\n                s = tmp;\n            }\n            for (int k = 14 ; k >= 0 ; k--) {\n                if (depth[s] - (1<<k) >= depth[t]) {\n                    max = Math.max(max, maxEdge[k][s]);\n                    s = parent[k][s];\n                }\n            }\n            if (s != t) {\n                for (int k = 14; k >= 0; k--) {\n                    if (parent[k][s] == parent[k][t]) {\n                        continue;\n                    }\n                    max = Math.max(max, maxEdge[k][s]);\n                    max = Math.max(max, maxEdge[k][t]);\n                    s = parent[k][s];\n                    t = parent[k][t];\n                }\n                if (s != t) {\n                    max = Math.max(max, maxEdge[0][s]);\n                    max = Math.max(max, maxEdge[0][t]);\n                }\n            }\n            out.println(treeCost-max);\n        }\n\n        out.flush();\n    }\n\n    static int[][][] tree;\n\n    static int[] depth;\n    static int[][] parent;\n    static int[][] maxEdge;\n\n    static void dfs(int now, int par) {\n        for (int[] e : tree[now]) {\n            int to = e[0];\n            if (to == par) {\n                continue;\n            }\n            depth[to] = depth[now]+1;\n            parent[0][to] = now;\n            maxEdge[0][to] = e[1];\n            dfs(to, now);\n        }\n    }\n\n\n    static int[][][] buildWeightedGraph(int n, int[][] edges) {\n        int m = edges.length;\n        int[][][] graph = new int[n][][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            deg[a]++;\n            deg[b]++;\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]][2];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            int w = edges[i][2];\n            graph[a][--deg[a]][0] = b;\n            graph[b][--deg[b]][0] = a;\n            graph[a][deg[a]][1] = w;\n            graph[b][deg[b]][1] = w;\n        }\n        return graph;\n    }\n\n    static class UnionFind {\n        int[] rank;\n        int[] parent;\n        int[] cnt;\n\n        public UnionFind(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            cnt = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                cnt[i] = 1;\n            }\n        }\n\n        public int find(int a) {\n            if (parent[a] == a) {\n                return a;\n            }\n            parent[a] = find(parent[a]);\n            return parent[a];\n        }\n\n        public void unite(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n            if (rank[a] < rank[b]) {\n                parent[a] = b;\n                cnt[b] += cnt[a];\n                cnt[a] = cnt[b];\n            } else {\n                parent[b] = a;\n                cnt[a] += cnt[b];\n                cnt[b] = cnt[a];\n                if (rank[a] == rank[b]) {\n                    rank[a]++;\n                }\n            }\n        }\n\n        public int groupCount(int a) {\n            return cnt[find(a)];\n        }\n\n        private boolean issame(int a, int b) {\n            return find(a) == find(b);\n        }\n    }\n\n\n    static int[][][] buildWeightedGraph(InputReader in, int n, int m) {\n        int[][] edges = new int[m][];\n        int[][][] graph = new int[n][][];\n        int[] deg = new int[n];\n        for (int i = 0 ; i < m ; i++) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            int w = in.nextInt();\n            deg[a]++;\n            deg[b]++;\n            edges[i] = new int[]{a, b, w};\n        }\n        for (int i = 0 ; i < n ; i++) {\n            graph[i] = new int[deg[i]][2];\n        }\n        for (int i = 0 ; i < m ; i++) {\n            int a = edges[i][0];\n            int b = edges[i][1];\n            int w = edges[i][2];\n            graph[a][--deg[a]][0] = b;\n            graph[b][--deg[b]][0] = a;\n            graph[a][deg[a]][1] = w;\n            graph[b][deg[b]][1] = w;\n        }\n        return graph;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int[] nextInts(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n        private int[][] nextIntTable(int n, int m) {\n            int[][] ret = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextInt();\n                }\n            }\n            return ret;\n        }\n\n        private long[] nextLongs(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextLong();\n            }\n            return ret;\n        }\n\n        private long[][] nextLongTable(int n, int m) {\n            long[][] ret = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ret[i][j] = nextLong();\n                }\n            }\n            return ret;\n        }\n\n        private double[] nextDoubles(int n) {\n            double[] ret = new double[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextDouble();\n            }\n            return ret;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res*sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static Edge[] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n        int[][] maxEdges = buildMaxEdge();\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = mstCost - maxEdges[S[i]][T[i]];\n        }\n        return ans;\n    }\n\n    static int[][] buildMaxEdge() {\n        int[][] maxEdges = new int[N][N];\n        boolean[][] used = new boolean[N][N];\n        int[] q = new int[N];\n        for (int i = 0; i < N; i++) {\n            int u = 0, v = 0;\n            q[v++] = i;\n            used[i][i] = true;\n            maxEdges[i][i] = -1;\n\n            while(u != v) {\n                int a = q[u++];\n                for (Edge e : mst[a]) {\n                    int b = e.opposite(a);\n                    if( !used[i][b] ) {\n                        int m = Math.max(maxEdges[i][a], e.c);\n                        q[v++] = b;\n                        maxEdges[i][b] = m;\n                        used[i][b] = true;\n                    }\n                }\n            }\n        }\n        return maxEdges;\n    }\n\n    static List<Edge>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, Edge[] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e.c));\n        List<Edge>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        UnionFind uf = new UnionFind(N);\n        for (Edge e : E) {\n            if( uf.isSame(e.a, e.b) ) continue;\n\n            T[e.a].add(e);\n            T[e.b].add(e);\n            uf.unite(e.a, e.b);\n            cost += e.c;\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class Edge {\n        final int a, b, c;\n\n        public Edge(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        int opposite(int x) {\n            return a == x ? b : a;\n        }\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\npublic class Main {\n  private static class Task {\n    ArrayList<Edge>[] tree;\n\n    void dfs(int v, int p, int start, int curMax, int[] max) {\n      for (Edge edge : tree[v]) {\n        if (edge.to == p) continue;\n        int nextMax = Math.max(curMax, edge.weight);\n        max[edge.to] = nextMax;\n        dfs(edge.to, v, start, nextMax, max);\n      }\n    }\n\n    void solve(FastScanner in, PrintWriter out) throws Exception {\n      int N = in.nextInt();\n      int M = in.nextInt();\n\n      PriorityQueue<Edge> queue = new PriorityQueue<>();\n      for (int i = 0; i < M; i++) {\n        int a = in.nextInt() - 1;\n        int b = in.nextInt() - 1;\n        int c = in.nextInt();\n\n        queue.add(new Edge(a, b, c));\n      }\n\n      UnionFind uf = new UnionFind(N);\n      tree = new ArrayList[N];\n      for (int i = 0; i < N; i++) {\n        tree[i] = new ArrayList<>();\n      }\n\n      long total = 0;\n      while (!queue.isEmpty()) {\n        Edge edge = queue.poll();\n        if (uf.isSame(edge.from, edge.to)) continue;\n        total += edge.weight;\n        tree[edge.from].add(new Edge(edge.from, edge.to, edge.weight));\n        tree[edge.to].add(new Edge(edge.to, edge.from, edge.weight));\n        uf.unite(edge.from, edge.to);\n      }\n\n      ArrayList<int[]>[] queries = new ArrayList[N];\n      for (int i = 0; i < N; i++) {\n        queries[i] = new ArrayList<>();\n      }\n      int Q = in.nextInt();\n      for (int i = 0; i < Q; i++) {\n        int s = in.nextInt() - 1;\n        int t = in.nextInt() - 1;\n        queries[s].add(new int[]{t, i});\n      }\n\n      long[] ans = new long[Q];\n      int[] max = new int[N];\n      for (int i = 0; i < N; i++) {\n        Arrays.fill(max, 0);\n        dfs(i, -1, i, 0, max);\n        for (int[] q : queries[i]) {\n          int t = q[0];\n          int n = q[1];\n          ans[n] = total - max[t];\n        }\n      }\n\n      for (long a : ans) out.println(a);\n\n    }\n\n    class Edge implements Comparable<Edge> {\n      int from, to, weight;\n      Edge(int from, int to, int weight) {\n        this.from = from;\n        this.to = to;\n        this.weight = weight;\n      }\n      @Override\n      public int compareTo(Edge o) {\n        return this.weight - o.weight;\n      }\n    }\n\n    class UnionFind {\n      // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n      private int[] par;\n      // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n      private int[] sizes;\n\n      // 木の数\n      private int size;\n\n      UnionFind(int n) {\n        par = new int[n];\n        sizes = new int[n];\n        size = n;\n        Arrays.fill(sizes, 1);\n        // 最初は全てのデータiがグループiに存在するものとして初期化\n        for (int i = 0; i < n; i++) par[i] = i;\n      }\n\n      /**\n       * データxが属する木の根を得る\n       *\n       * @param x\n       * @return\n       */\n      int find(int x) {\n        if (x == par[x]) return x;\n        return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n      }\n\n      /**\n       * 2つのデータx, yが属する木をマージする。\n       * マージが必要なら true を返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean unite(int x, int y) {\n        // データの根ノードを得る\n        x = find(x);\n        y = find(y);\n\n        // 既に同じ木に属しているならマージしない\n        if (x == y) return false;\n\n        // xの木がyの木より大きくなるようにする\n        if (sizes[x] < sizes[y]) {\n          int tx = x;\n          x = y;\n          y = tx;\n        }\n\n        // xがyの親になるように連結する\n        par[y] = x;\n        sizes[x] += sizes[y];\n        sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n\n        size--;\n        return true;\n      }\n\n      /**\n       * 2つのデータx, yが属する木が同じならtrueを返す\n       *\n       * @param x\n       * @param y\n       * @return\n       */\n      boolean isSame(int x, int y) {\n        return find(x) == find(y);\n      }\n\n      /**\n       * データxが含まれる木の大きさを返す\n       *\n       * @param x\n       * @return\n       */\n      int partialSizeOf(int x) {\n        return sizes[find(x)];\n      }\n\n      /**\n       * 木の数を返す\n       *\n       * @return\n       */\n      int size() {\n        return size;\n      }\n    }\n  }\n\n  /**\n   * ここから下はテンプレートです。\n   */\n  public static void main(String[] args) throws Exception {\n    OutputStream outputStream = System.out;\n    FastScanner in = new FastScanner();\n    PrintWriter out = new PrintWriter(outputStream);\n    Task solver = new Task();\n    solver.solve(in, out);\n    out.close();\n  }\n  private static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) array[i] = nextInt();\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) array[i] = nextLong();\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) array[i] = next();\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) array[i] = next().toCharArray();\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tpublic void run() {\n\t\tsolver();\n\t}\n\n\tclass DJSet {\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u, v;\n\t\tint cost;\n\n\t\tpublic Edge(int u_, int v_, int cost_) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = cost_;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge arg0) {\n\t\t\treturn Long.compare(cost, arg0.cost);\n\t\t}\n\t}\n\n\tint[][] max;\n\n\tvoid dfs(int cur, int par, int src, int ma, ArrayList<Edge>[] g) {\n\t\tmax[src][cur] = Math.max(max[src][cur], ma);\n\t\tfor (Edge e : g[cur]) {\n\t\t\tif (e.v == par)\n\t\t\t\tcontinue;\n\t\t\tdfs(e.v, cur, src, Math.max(ma, e.cost), g);\n\t\t}\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = Integer.parseInt(sc.next());\n\t\tint M = Integer.parseInt(sc.next());\n\t\tEdge[] es = new Edge[M];\n\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\tfor (int i = 0; i < g.length; ++i)\n\t\t\tg[i] = new ArrayList();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint u = Integer.parseInt(sc.next());\n\t\t\tint v = Integer.parseInt(sc.next());\n\t\t\tint c = Integer.parseInt(sc.next());\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tes[i] = new Edge(u, v, c);\n\t\t}\n\t\tArrays.sort(es);\n\t\tDJSet ds = new DJSet(N);\n\t\tlong ans = 0;\n\t\tfor (Edge e : es) {\n\t\t\tif (!ds.equiv(e.u, e.v)) {\n\t\t\t\tans += e.cost;\n\t\t\t\tg[e.u].add(new Edge(e.u, e.v, e.cost));\n\t\t\t\tg[e.v].add(new Edge(e.v, e.u, e.cost));\n\t\t\t\tds.union(e.u, e.v);\n\t\t\t}\n\t\t}\n\n\t\tSystem.gc();\n\t\tmax = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdfs(i, -1, i, 0, g);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint Q = Integer.parseInt(sc.next());\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint s = Integer.parseInt(sc.next());\n\t\t\tint d = Integer.parseInt(sc.next());\n\t\t\t--s;\n\t\t\t--d;\n\t\t\tpw.println(ans - max[s][d]);\n\t\t}\n\t\tpw.close();\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static Edge[] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = calc(S[i], T[i]);\n        }\n        return ans;\n    }\n\n    static long calc(int s, int t) {\n        long maxEdge = dfs(-1, s, t, -1);\n        return mstCost - maxEdge;\n    }\n\n    static long dfs(int p, int a, int t, int maxEdge) {\n        if( a == t ) return maxEdge;\n\n        for (Edge e : mst[a]) {\n            int b = e.opposite(a);\n            if( b == p ) continue;\n\n            long ret = dfs(a, b, t, Math.max(e.c, maxEdge));\n            if( ret > 0 ) return ret;\n        }\n        return -1;\n    }\n\n    static List<Edge>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, Edge[] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e.c));\n        List<Edge>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        Set<Integer> set = new HashSet<>();\n        for (Edge e : E) {\n            if( set.contains(e.a) && set.contains(e.b) ) continue;\n\n            T[e.a].add(e);\n            T[e.b].add(e);\n            set.add(e.a);\n            set.add(e.b);\n            cost += e.c;\n\n            if( set.size() == N ) break;\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class Edge {\n        final int a, b, c;\n\n        public Edge(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        int opposite(int x) {\n            return a == x ? b : a;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int N, M;\n    static Edge[] E;\n    static int Q;\n    static int[] S, T;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        M = sc.nextInt();\n        E = new Edge[M];\n        for (int i = 0; i < M; i++) {\n            E[i] = new Edge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());\n        }\n        Q = sc.nextInt();\n        S = new int[Q];\n        T = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            S[i] = sc.nextInt()-1;\n            T[i] = sc.nextInt()-1;\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        kruskal(N, E);\n        int[][] maxEdges = buildMaxEdge();\n\n        long[] ans = new long[Q];\n        for (int i = 0; i < Q; i++) {\n            ans[i] = mstCost - maxEdges[S[i]][T[i]];\n        }\n        return ans;\n    }\n\n    static int[][] buildMaxEdge() {\n        int[][] maxEdges = new int[N][N];\n        boolean[][] used = new boolean[N][N];\n        ArrayDeque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < N; i++) {\n            q.add(i);\n            used[i][i] = true;\n            maxEdges[i][i] = -1;\n\n            while(!q.isEmpty()) {\n                int a = q.poll();\n                for (Edge e : mst[a]) {\n                    int b = e.opposite(a);\n                    if( !used[i][b] ) {\n                        int m = Math.max(maxEdges[i][a], e.c);\n                        q.add( b );\n                        maxEdges[i][b] = m;\n                        used[i][b] = true;\n                    }\n                }\n            }\n        }\n        return maxEdges;\n    }\n\n    static List<Edge>[] mst;\n    static long mstCost;\n\n    static void kruskal(int N, Edge[] E) {\n        Arrays.sort(E, Comparator.comparingInt(e -> e.c));\n        List<Edge>[] T = new List[N];\n        for (int i = 0; i < N; i++) {\n            T[i] = new ArrayList<>();\n        }\n\n        long cost = 0;\n        UnionFind uf = new UnionFind(N);\n        for (Edge e : E) {\n            if( uf.isSame(e.a, e.b) ) continue;\n\n            T[e.a].add(e);\n            T[e.b].add(e);\n            uf.unite(e.a, e.b);\n            cost += e.c;\n        }\n\n        mst = T;\n        mstCost = cost;\n    }\n\n    static class Edge {\n        final int a, b, c;\n\n        public Edge(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        int opposite(int x) {\n            return a == x ? b : a;\n        }\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int root(int i) {\n            if( parent[i] == i ) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public void unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if( ri == rj ) return;\n\n            if( rank[ri] < rank[rj] ) {\n                parent[ri] = rj;\n\n            } else {\n                parent[rj] = ri;\n                if( rank[ri] == rank[rj] ) {\n                    rank[ri]++;\n                }\n            }\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[][] es = new int[m][];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tes[i] = new int[]{ni()-1, ni()-1, ni()};\n\t\t}\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[2] - b[2];\n\t\t\t}\n\t\t});\n\n\t\tDJSet ds = new DJSet(n);\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tint[] w = new int[n-1];\n\t\tlong wsum = 0;\n\t\tint p = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(!ds.union(es[i][0], es[i][1])){\n\t\t\t\tfrom[p] = es[i][0];\n\t\t\t\tto[p] = es[i][1];\n\t\t\t\tw[p] = -es[i][2];\n\t\t\t\tp++;\n\t\t\t\twsum += es[i][2];\n\t\t\t}\n\t\t}\n\t\tassert p == n-1;\n\t\tint[][][] g = packWU(n, from, to, w);\n\t\tint[][] pars = parents(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2], pw = pars[4];\n\t\tint[][] spar = logstepParents(par);\n\t\tint[][] sargmins = logstepArgmins(spar, pw);\n\t\tfor(int Q = ni();Q > 0;Q--){\n\t\t\tint s = ni()-1, t = ni()-1;\n\t\t\tint arg = argmin(s, t, spar, sargmins, pw, dep);\n\t\t\tout.println(wsum+pw[arg]);\n\t\t}\n\t}\n\t\n\tpublic static int[][] logstepArgmins(int[][] sp, int[] pw)\n\t{\n\t\tint m = sp.length;\n\t\tint n = sp[0].length;\n\t\tint[][] mins = new int[m][n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tmins[0][i] = i;\n\t\t}\n\t\tfor(int j = 1;j < m;j++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(sp[j-1][i] != -1){\n\t\t\t\t\tint lower = mins[j-1][i];\n\t\t\t\t\tint upper = mins[j-1][sp[j-1][i]];\n\t\t\t\t\tif(upper == -1 || pw[lower] < pw[upper]){\n\t\t\t\t\t\tmins[j][i] = lower;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmins[j][i] = upper;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tmins[j][i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mins;\n\t}\n\t\n\tpublic static int argmin(int a, int b, int[][] spar, int[][] sargmin, int[] vs, int[] dep)\n\t{\n\t\tint lca = lca2(a, b, spar, dep);\n\t\tint a0 = argminAnc(a, lca, spar, sargmin, vs, dep);\n\t\tint a1 = argminAnc(b, lca, spar, sargmin, vs, dep);\n\t\tint min = Integer.MAX_VALUE;\n\t\tint arg = -1;\n\t\tif(a0 != -1 && vs[a0] < min){\n\t\t\tmin = vs[a0];\n\t\t\targ = a0;\n\t\t}\n\t\tif(a1 != -1 && vs[a1] < min){\n\t\t\tmin = vs[a1];\n\t\t\targ = a1;\n\t\t}\n\t\treturn arg; // or min\n\t}\n\t\n\tpublic static int argminAnc(int a, int anc, int[][] spar, int[][] sargmin, int[] vs, int[] dep)\n\t{\n\t\tif(a == anc)return -1;\n\t\tint cur = a;\n\t\tint min = vs[a];\n\t\tint arg = a;\n\t\tfor(int i = dep[a] - dep[anc], k = 0;i > 0;i /= 2, k++){\n\t\t\tif((i&1)==1){\n\t\t\t\tint lv = vs[sargmin[k][cur]];\n\t\t\t\tif(lv < min){\n\t\t\t\t\tmin = lv;\n\t\t\t\t\targ = sargmin[k][cur];\n\t\t\t\t}\n\t\t\t\tcur = spar[k][cur];\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}\n\n\n\t\n\tpublic static int lca2(int a, int b, int[][] spar, int[] depth) {\n\t\tif (depth[a] < depth[b]) {\n\t\t\tb = ancestor(b, depth[b] - depth[a], spar);\n\t\t} else if (depth[a] > depth[b]) {\n\t\t\ta = ancestor(a, depth[a] - depth[b], spar);\n\t\t}\n\n\t\tif (a == b)\n\t\t\treturn a;\n\t\tint sa = a, sb = b;\n\t\tfor (int low = 0, high = depth[a], t = Integer.highestOneBit(high), k = Integer\n\t\t\t\t.numberOfTrailingZeros(t); t > 0; t >>>= 1, k--) {\n\t\t\tif ((low ^ high) >= t) {\n\t\t\t\tif (spar[k][sa] != spar[k][sb]) {\n\t\t\t\t\tlow |= t;\n\t\t\t\t\tsa = spar[k][sa];\n\t\t\t\t\tsb = spar[k][sb];\n\t\t\t\t} else {\n\t\t\t\t\thigh = low | t - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn spar[0][sa];\n\t}\n\n\tprotected static int ancestor(int a, int m, int[][] spar) {\n\t\tfor (int i = 0; m > 0 && a != -1; m >>>= 1, i++) {\n\t\t\tif ((m & 1) == 1)\n\t\t\t\ta = spar[i][a];\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static int[][] logstepParents(int[] par) {\n\t\tint n = par.length;\n\t\tint m = Integer.numberOfTrailingZeros(Integer.highestOneBit(n - 1)) + 1;\n\t\tint[][] pars = new int[m][n];\n\t\tpars[0] = par;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tpars[j][i] = pars[j - 1][i] == -1 ? -1 : pars[j - 1][pars[j - 1][i]];\n\t\t\t}\n\t\t}\n\t\treturn pars;\n\t}\n\n\t\n\tpublic static int[][] parents(int[][][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\t\tint[] dw = new int[n];\n\t\tint[] pw = new int[n];\n\t\tint[] dep = new int[n];\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int[] nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex[0]) {\n\t\t\t\t\tq[r++] = nex[0];\n\t\t\t\t\tpar[nex[0]] = cur;\n\t\t\t\t\tdep[nex[0]] = dep[cur] + 1;\n\t\t\t\t\tdw[nex[0]] = dw[cur] + nex[1];\n\t\t\t\t\tpw[nex[0]] = nex[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, dep, dw, pw };\n\t}\n\n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<Tuple<int,int>>[] li;\n\tstatic bool[] b;\n\tstatic int[][] h;\n\tstatic int[][] z;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint[] s=sc.Ia;\n\t\tint n=s[0],m=s[1];\n\t\tli=new List<Tuple<int,int>>[n+1];\n\t\th=new int[m][];\n\t\tz=new int[n+1][];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<Tuple<int,int>>();\n\t\t\tz[i]=new int[n+1];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\th[i]=sc.Ia;\n\t\t}\n\t\tArray.Sort(h,(u,v)=>u[2]-v[2]);\n\t\tUf uf=new Uf(n+1);\n\t\tlong c=0;\n\t\tfor(int i = 0;uf.all!=2;i++) {\n\t\t\tif(!uf.Same(h[i][0],h[i][1])){\n\t\t\t\tuf.Union(h[i][0],h[i][1]);\n\t\t\t\tli[h[i][0]].Add(Tuple.Create(h[i][1],h[i][2]));\n\t\t\t\tli[h[i][1]].Add(Tuple.Create(h[i][0],h[i][2]));\n\t\t\t\tc+=h[i][2];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tb=new bool[n+1];\n\t\t\tFu(i,i,0);\n\t\t}\n\t\tint q=sc.I;\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 0;i<q;i++) {\n\t\t\tvar e=sc.Ia;\n\t\t\tsb.Append((c-z[e[0]][e[1]])+\"\\n\");\n\t\t}\n\t\tConsole.Write(sb);\n\t}\n\tstatic void Fu(int a,int g,int p){\n\t\tb[a]=true;\n\t\tz[a][g]=z[g][a]=p;\n\t\tfor(int i=0;i<li[a].Count;i++){\n\t\t\tif(!b[li[a][i].Item1]){Fu(li[a][i].Item1,g,Max(p,li[a][i].Item2));}\n\t\t}\n\t}\n}\npublic class Uf{\n\tprivate int[] arr,hi;\n\tpublic int all;\n\tpublic Uf(int n){\n\t\tarr=new int[n];\n\t\thi=new int[n];\n\t\tall=n;\n\t\tfor(int i=0;i<n;i++){arr[i]=-1;}\n\t}\n\tpublic void Union(int a,int b){\n\t\ta=Root(a);\n\t\tb=Root(b);\n\t\tif(a!=b){\n\t\t\tif(hi[a]<hi[b]){\n\t\t\t\tint v=b;\n\t\t\t\tb=a;\n\t\t\t\ta=v;\n\t\t\t}\n\t\t\tarr[a]+=arr[b];\n\t\t\thi[a]=Math.Max(hi[a],hi[b]+1);\n\t\t\tarr[b]=a;\n\t\t\tall--;\n\t\t}\n\t}\n\tpublic bool Same(int a,int b){return Root(a)==Root(b);}\n\tpublic int Total(int a){return -arr[Root(a)];}\n\tpublic int Root(int a){return arr[a]<0?a:arr[a]=Root(arr[a]);}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N, M, Q;\n\t\tTuple<int, int, int>[] rs;\n\t\tTuple<int, int>[] qs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N, out M);\n\t\t\trs = sc.ReadManyLines<int, int, int>(M);\n\t\t\tQ = sc.Int;\n\t\t\tqs = sc.ReadManyLines<int, int>(Q);\n\t\t}\n\t\tDictionary<int, int>[] es;\n\t\tint[,] dp;\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tes = new Dictionary<int, int>[N];\n\t\t\tfor (var i = 0; i < N; i++) es[i] = new Dictionary<int, int>();\n\t\t\tArray.Sort(rs, (x, y) => x.Item3.CompareTo(y.Item3));\n\t\t\tvar uf = new UnionFindTree(N);\n\t\t\tvar sum = 0L;\n\t\t\tforeach (var r in rs)\n\t\t\t{\n\t\t\t\tint a = r.Item1 - 1, b = r.Item2 - 1, c = r.Item3;\n\t\t\t\tif (!uf.IsSameCategory(a, b))\n\t\t\t\t{\n\t\t\t\t\tuf.UniteCategory(a, b);\n\t\t\t\t\tes[a].Add(b, c);\n\t\t\t\t\tes[b].Add(a, c);\n\t\t\t\t\tsum += c;\n\t\t\t\t}\n\t\t\t\tif (uf.GetSize(0) == N) break;\n\t\t\t}\n\t\t\tdp = new int[N, N];\n\t\t\tfor (var i = 0; i < N; i++) DFS(i, -1, i, 0);\n\t\t\tforeach (var q in qs) pr.WriteLine(sum - dp[q.Item1 - 1, q.Item2 - 1]);\n\t\t}\n\t\tvoid DFS(int u, int p, int r, int m)\n\t\t{\n\t\t\tdp[r, u] = dp[u, r] = m;\n\t\t\tforeach (var v in es[u]) if (v.Key != p) DFS(v.Key, u, r, Max(m, v.Value));\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length <= 1) return; QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (int i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int n, m;\n        sc.Multi(out n, out m);\n        var edges = new pair<long, P>[m];\n        for (int i = 0; i < m; i++)\n        {\n            int u, v, c;\n            sc.Multi(out u, out v, out c);\n            --u;\n            --v;\n            edges[i] = new pair<long, P>(c, new P(u, v));\n        }\n        Array.Sort(edges);\n        var uf = new UnionFind(n);\n        var edge = new List<pair<long, int>>[n];\n        for (int i = 0; i < n; i++)\n        {\n            edge[i] = new List<pair<long, int>>();\n        }\n        long mst = 0;\n        foreach (var item in edges)\n        {\n            if (uf.unite(item.v2.v1, item.v2.v2)) {\n                mst += item.v1;\n                edge[item.v2.v1].Add(new pair<long, int>(item.v1, item.v2.v2));\n                edge[item.v2.v2].Add(new pair<long, int>(item.v1, item.v2.v1));\n            }\n        }\n        var lca = new LCATree<long>(edge, Math.Max, 0);\n        int q = sc.Int;\n        for (int i = 0; i < q; i++)\n        {\n            int u, v;\n            sc.Multi(out u, out v);\n            --u;\n            --v;\n            var p = lca.lca(u, v);\n            Prt(mst - p.v1);\n        }\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        if (conds.Any(x => !x)) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\nclass LCATree<T> {\n    int m;\n    int[][] parents;\n    T[][] values;\n    Func<T, T, T> func;\n    T identity;\n    int[] depth;\n\n    public LCATree(List<pair<T, int>>[] g, Func<T, T, T> func, T identity, int root = 0) {\n        int n = g.Length;\n        parents = new int[n][];\n        values = new T[n][];\n        depth = new int[n];\n        this.func = func;\n        this.identity = identity;\n        m = 1;\n        while ((1 << m - 1) < n) ++m;\n        for (int i = 0; i < n; i++) {\n            parents[i] = new int[m];\n            values[i] = new T[m];\n            depth[i] = -1;\n            for (int j = 0; j < m; j++) {\n                parents[i][j] = -1;\n                values[i][j] = identity;\n            }\n        }\n        depth[root] = 0;\n        var q = new Queue<int>();\n        q.Enqueue(root);\n        while (q.Count > 0) {\n            var p = q.Dequeue();\n            foreach (var item in g[p]) {\n                if (depth[item.v2] == -1) {\n                    depth[item.v2] = depth[p] + 1;\n                    parents[item.v2][0] = p;\n                    values[item.v2][0] = item.v1;\n                    for (int i = 1; i < m && parents[item.v2][i - 1] != -1; i++) {\n                        parents[item.v2][i] = parents[parents[item.v2][i - 1]][i - 1];\n                        values[item.v2][i] = func(values[item.v2][i - 1], values[parents[item.v2][i - 1]][i - 1]);\n                    }\n                    q.Enqueue(item.v2);\n                }\n            }\n        }\n    }\n    T climb(ref int p, int cnt) {\n        T val = identity;\n        for (int i = m - 1; i >= 0 ; i--) {\n            if (((cnt >> i) & 1) == 1) {\n                val = func(val, values[p][i]);\n                p = parents[p][i];\n            }\n        }\n        return val;\n    }\n    public pair<T, int> lca(int p, int q) {\n        T val = identity;\n        if (depth[p] > depth[q]) val = climb(ref p, depth[p] - depth[q]);\n        if (depth[p] < depth[q]) val = climb(ref q, depth[q] - depth[p]);\n        if (p == q) return new pair<T, int>(val, p);\n\n        for (int i = m - 1; i >= 0 ; i--) {\n            if (parents[p][i] != parents[q][i]) {\n                val = func(val, values[p][i]);\n                val = func(val, values[q][i]);\n                p = parents[p][i];\n                q = parents[q][i];\n            }\n        }\n        {\n            val = func(val, values[p][0]);\n            val = func(val, values[q][0]);\n            p = parents[p][0];\n            q = parents[q][0];\n        }\n        return new pair<T, int>(val, p);\n    }\n}\nclass UnionFind {\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n;\n        par = new int[n];\n        sz = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; ++i) {\n            par[i] = i;\n            sz[i] = 1;\n            rank[i] = 0;\n        }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) => find(x) == find(y);\n    public int unionsize(int x) => sz[find(x)];\n    public int unioncount => num;\n    public bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) => x == find(x);\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<int>[] E = new List<int>[N];\n\t\tfor(int i=0;i<N;i++) E[i] = new List<int>();\n\t\t\n\t\tPair[] P = new Pair[M];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tP[i] = new Pair(i, C[i]);\n\t\t}\n\t\t\n\t\tArray.Sort(P, (p, q) => p.Cost.CompareTo(q.Cost));\n\t\t\n\t\tvar UF = new UnionFind(N);\n\t\tlong totalCost = 0;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = A[P[i].Idx];\n\t\t\tint b = B[P[i].Idx];\n\t\t\tif(UF.IsUnited(a, b)) continue;\n\t\t\tUF.Unite(a, b);\n\t\t\tE[a].Add(P[i].Idx);\n\t\t\tE[b].Add(P[i].Idx);\n\t\t\ttotalCost += C[P[i].Idx];\n\t\t}\n\t\t\n\t\tlong[][] maxBottle = new long[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tmaxBottle[i] = new long[N];\n\t\t\tfor(int j=0;j<N;j++) maxBottle[i][j] = -1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar q = new Queue<int>();\n\t\t\tq.Enqueue(i);\n\t\t\tmaxBottle[i][i] = 0;\n\t\t\twhile(q.Count > 0){\n\t\t\t\tvar now = q.Dequeue();\n\t\t\t\tforeach(var nidx in E[now]){\n\t\t\t\t\tint nxt = A[nidx] == now ? B[nidx] : A[nidx];\n\t\t\t\t\tlong cost = C[nidx];\n\t\t\t\t\tif(maxBottle[i][nxt] != -1) continue;\n\t\t\t\t\tmaxBottle[i][nxt] = Math.Max(maxBottle[i][now], cost);\n\t\t\t\t\tq.Enqueue(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar sb = new StringBuilder();\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tsb.AppendLine((totalCost - maxBottle[S[i]][T[i]]).ToString());\n\t\t}\n\t\tConsole.Write(sb.ToString());\n\t\t\n\t}\n\tint N,M;\n\tint[] A,B;\n\tlong[] C;\n\t\n\tint Q;\n\tint[] S,T;\n\tpublic Sol(){\n\t\t\n\t\tusing(var r = new FastIn()){\n\t\tN = r.ReadInt(); M = r.ReadInt();\n\t\tA = new int[M];\n\t\tB = new int[M];\n\t\tC = new long[M];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tA[i] = r.ReadInt() - 1;\n\t\t\tB[i] = r.ReadInt() - 1;\n\t\t\tC[i] = r.ReadInt();\n\t\t}\n\t\t\n\t\tQ = r.ReadInt();\n\t\t\n\t\tS = new int[Q];\n\t\tT = new int[Q];\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tS[i] = r.ReadInt() - 1;\n\t\t\tT[i] = r.ReadInt() - 1;\n\t\t}\n\t\t\n\t\t\n\t\t}\n\t\t\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n\nclass Pair{\n\tpublic int Idx;\n\tpublic long Cost;\n\tpublic Pair (int idx, long cost){\n\t\tIdx = idx; Cost = cost;\n\t}\n}\nclass UnionFind{\n\t\n\tint[] parent;\n\tint[] mem;\n\tint compo;\n\tint N;\n\tpublic UnionFind(int n_){\n\t\tInitialize(n_);\n\t}\n\t\n\tpublic void Initialize(int n_){\n\t\tN=n_;\n\t\tparent=new int[N];\n\t\tmem=new int[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tparent[i]=i;\n\t\t\tmem[i]=1;\n\t\t}\n\t\tcompo=N;\n\t}\n\t\n\tpublic int Parent(int a){\n\t\tif(parent[a]==a)return a;\n\t\treturn parent[a]=Parent(parent[a]);\n\t}\n\t\n\tpublic bool IsUnited(int a,int b){\n\t\treturn Parent(a) == Parent(b);\n\t}\n\t\n\tpublic void Unite(int a,int b){\n\t\ta=Parent(a);b=Parent(b);\n\t\tif(a==b)return;\n\t\tparent[a]=b;\n\t\tmem[b]+=mem[a];\n\t\tcompo-=1;\n\t}\n\t\n\tpublic bool IsRoot(int x){\n\t\treturn x==parent[x];\n\t}\n\tpublic int MemCnt(int x){\n\t\treturn mem[Parent(x)];\n\t}\n\t\n\tpublic void Dump(){\n\t\tfor(int i=0;i<parent.Length;i++){\n\t\t\tConsole.Write(i==0?\"{0}\":\" {0}\",parent[i]);\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n\t\n\tpublic int Compo{\n\t\tget{\n\t\t\treturn compo;\n\t\t}\n\t}\n\t\n}\n\n\n\nclass FastIn:IDisposable {\n\tint Size;\n\tbyte[] Mem;\n\tint ptr;\n\tint rsize;\n\tbool unfinished;\n\tStream stdin;\n\tvoid Init(int n) {\n\t\tSize = n;\n\t\tMem = new byte[Size];\n\t\trsize=(stdin=Console.OpenStandardInput()).Read(Mem, 0, Size);\n\t\tptr = 0;\n\t\tunfinished=(rsize == Size);\n\t}\n\tvoid Next() {\n\t\tif (unfinished == false) return;\n\t\trsize=stdin.Read(Mem, 0, Size);\n\t\tptr = 0;\n\t\tunfinished = (rsize == Size);\n\t}\n\t\n\t~FastIn(){\n\t\tstdin.Dispose();\n\t}\n\tvoid IDisposable.Dispose(){\n\t\tstdin.Dispose();\n\t}\n\tpublic void Dispose(){\n\t\tstdin.Dispose();\n\t}\n\t\n\tpublic FastIn() {\n\t\tInit(100000);\n\t}\n\tpublic FastIn(int n) {\n\t\tInit(n);\n\t}\n\tpublic int ReadInt() {\n\t\tint ret = 0;\n\t\tint sig = 1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tif(ret==0 && Mem[ptr] == '-'){\n\t\t\t\tsig *= -1; ptr++; continue;\n\t\t\t}\n\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\twhile (ptr < rsize && (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\tpublic uint ReadUint() {\n\t\tuint ret = 0;\n\t\tuint sig = 1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\twhile (ptr < rsize && (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\tpublic long ReadLong() {\n\t\tlong ret = 0;\n\t\tlong sig = 1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tif(ret==0 && Mem[ptr] == '-'){\n\t\t\t\tsig *= -1; ptr++; continue;\n\t\t\t}\n\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\twhile (ptr < rsize &&  (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r')  ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\t\n\tpublic double ReadDouble() {\n\t\tdouble ret = 0;\n\t\tdouble sig = 1;\n\t\tbool dot = false;\n\t\tdouble keta = 0.1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tif(ret==0 && Mem[ptr] == '-'){\n\t\t\t\tsig *= -1; ptr++;\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(Mem[ptr] == '.'){\n\t\t\t\tdot = true;\n\t\t\t\tptr++;\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!dot){\n\t\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t}else{\n\t\t\t\tret = ret + (Mem[ptr++] - '0')*keta;\n\t\t\t\tketa /= 10.0;\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t}\n\t\t}\n\t\twhile (ptr < rsize && (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\n\tpublic String ReadStr() {\n\t\t//2byte文字はNG\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r') {\n\t\t\tsb.Append((char)Mem[ptr++]);\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\twhile (ptr < rsize &&  (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\treturn sb.ToString();\n\t}\n\tpublic String ReadLine() {\n\t\t//極力使わない(split/parseするくらいなら上をつかう）\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (ptr < rsize && Mem[ptr] != '\\n' && Mem[ptr] != '\\r') {\n\t\t\tsb.Append((char)Mem[ptr++]);\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\twhile (ptr < rsize &&  (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r')) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\treturn sb.ToString();\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing Problem = Tmp.Problem;\nnamespace Tmp\n{\n\tusing static Func;\n\tusing static Math;\n\tusing static Console;\n\t//using GeometryLong;\n\tclass Problem : IDisposable\n\t{\n\t\tbool IsGCJ;\n\t\tint Repeat;\n\t\tScanner sc;\n\t\tPrinter pr;\n\t\tpublic Problem(bool isGCJ, Scanner scanner, Printer printer)\n\t\t{\n\t\t\tsc = scanner;\n\t\t\tpr = printer;\n\t\t\tIsGCJ = isGCJ;\n\t\t\tif (isGCJ) Repeat = sc.Get<int>();\n\t\t\telse Read();\n\t\t}\n\t\tpublic Problem(bool isGCJ) : this(isGCJ, new Scanner(), new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Scanner scanner) : this(isGCJ, scanner, new Printer()) { }\n\t\tpublic Problem(bool isGCJ, Printer printer) : this(isGCJ, new Scanner(), printer) { }\n\t\tpublic void Solve()\n\t\t{\n\t\t\tif (IsGCJ) for (var i = 0; i < Repeat; i++) { Read(); pr.Write(\"Case #\" + (i + 1) + \": \"); SolveOne(); }\n\t\t\telse SolveOne();\n\t\t}\n\t\tpublic void Dispose()\n\t\t{\n\t\t\tsc.Dispose();\n\t\t\tpr.Dispose();\n\t\t}\n\t\tpublic int Size { get { return 1; } }\n\t\tpublic const long Mod = 1000000007;\n\t\t//public const long Mod = 924844033;\n\t\tRandomSFMT rand = Program.rand;\n\t\tint N, M, Q;\n\t\tTuple<int, int, int>[] rs;\n\t\tTuple<int, int>[] qs;\n\t\tvoid Read()\n\t\t{\n\t\t\tsc.Read(out N, out M);\n\t\t\trs = sc.ReadManyLines<int, int, int>(M);\n\t\t\tQ = sc.Int;\n\t\t\tqs = sc.ReadManyLines<int, int>(Q);\n\t\t}\n\t\tDictionary<int, int>[] es;\n\t\tint[,] dp;\n\t\tvoid SolveOne()\n\t\t{\n\t\t\tes = new Dictionary<int, int>[N];\n\t\t\tfor (var i = 0; i < N; i++) es[i] = new Dictionary<int, int>();\n\t\t\tArray.Sort(rs, (x, y) => x.Item3.CompareTo(y.Item3));\n\t\t\tvar uf = new UnionFindTree(N);\n\t\t\tvar sum = 0L;\n\t\t\tforeach (var r in rs)\n\t\t\t{\n\t\t\t\tint a = r.Item1 - 1, b = r.Item2 - 1, c = r.Item3;\n\t\t\t\tif (!uf.IsSameCategory(a, b))\n\t\t\t\t{\n\t\t\t\t\tuf.UniteCategory(a, b);\n\t\t\t\t\tes[a].Add(b, c);\n\t\t\t\t\tes[b].Add(a, c);\n\t\t\t\t\tsum += c;\n\t\t\t\t}\n\t\t\t\tif (uf.GetSize(0) == N) break;\n\t\t\t}\n\t\t\tdp = new int[N, N];\n\t\t\tDFS(0, -1);\n\t\t\tforeach (var q in qs) pr.WriteLine(sum - dp[q.Item1 - 1, q.Item2 - 1]);\n\t\t}\n\t\tvoid DFS(int u, int p)\n\t\t{\n\t\t\tDFS2(u, p, u, 0);\n\t\t\tforeach (var v in es[u]) if (v.Key != p) DFS(v.Key, u);\n\t\t}\n\t\tvoid DFS2(int u, int p, int r, int m)\n\t\t{\n\t\t\tdp[r, u] = dp[u, r] = m;\n\t\t\tforeach (var v in es[u]) if (v.Key != p) DFS2(v.Key, u, r, Max(m, v.Value));\n\t\t}\n\t}\n\tclass SlideMaximum\n\t{\n\t\tlong[] a;\n\t\tDeque<int> deq;\n\t\tpublic SlideMaximum(long[] x) { a = x; deq = new Deque<int>(); }\n\t\tpublic void Add(int index)\n\t\t{\n\t\t\twhile (deq.Count > 0 && a[deq.PeekBack()] <= a[index]) deq.PopBack();\n\t\t\tdeq.PushBack(index);\n\t\t}\n\t\tpublic void Remove(int index)\n\t\t{\n\t\t\tif (deq.Count > 0 && deq.PeekFront() == index) deq.PopFront();\n\t\t}\n\t\tpublic long Maximum => a[deq.PeekFront()];\n\t}\n\tclass SegmentTreeX\n\t{\n\t\tpublic const long Unit = -InfL;\n\t\tint N2;\n\t\tlong[] seg, unif;\n\t\tpublic SegmentTreeX(int N)\n\t\t{\n\t\t\tN2 = 1;\n\t\t\twhile (N2 < N) N2 <<= 1;\n\t\t\tseg = new long[2 * N2 - 1];\n\t\t\tunif = new long[2 * N2 - 1];\n\t\t\tfor (var i = 0; i < 2 * N2 - 1; i++) seg[i] = unif[i] = Unit;\n\t\t}\n\t\tvoid LazyEvaluate(int node)\n\t\t{\n\t\t\tif (unif[node] != Unit)\n\t\t\t{\n\t\t\t\tseg[node] = Math.Max(seg[node], unif[node]);\n\t\t\t\tif (node < N2 - 1)\n\t\t\t\t{\n\t\t\t\t\tunif[2 * node + 1] = Math.Max(unif[2 * node + 1], unif[node]);\n\t\t\t\t\tunif[2 * node + 2] = Math.Max(unif[2 * node + 2], unif[node]);\n\t\t\t\t}\n\t\t\t\tunif[node] = Unit;\n\t\t\t}\n\t\t}\n\t\tvoid Update(int node) => seg[node] = Math.Max(seg[2 * node + 1], seg[2 * node + 2]);\n\t\tpublic void Maximize(int from, int to, long value) => Maximize(from, to, value, 0, 0, N2);\n\t\tvoid Maximize(int from, int to, long value, int node, int l, int r)\n\t\t{\n\t\t\tif (from <= l && r <= to) unif[node] = Math.Max(unif[node], value);\n\t\t\telse if (l < to && from < r)\n\t\t\t{\n\t\t\t\tMaximize(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\t\tMaximize(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\t\tUpdate(node);\n\t\t\t}\n\t\t\tLazyEvaluate(node);\n\t\t}\n\t\tpublic long this[int n] { get { return Max(n, n + 1); } set { Maximize(n, n + 1, value); } }\n\t\tpublic long Max(int from, int to) => Max(from, to, 0, 0, N2);\n\t\tlong Max(int from, int to, int node, int l, int r)\n\t\t{\n\t\t\tLazyEvaluate(node);\n\t\t\tif (to <= l || r <= from) return Unit;\n\t\t\telse if (from <= l && r <= to) return seg[node];\n\t\t\telse return Math.Max(Max(from, to, 2 * node + 1, l, (l + r) >> 1), Max(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t\t}\n\t}\n}\nclass RMQI\n{\n\tint N2;\n\tint[] segtree;\n\tint[] position;\n\tpublic RMQI(int N) : this(new int[N]) { }\n\tpublic RMQI(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tposition = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) { segtree[i + N2 - 1] = array[i]; position[i + N2 - 1] = i; }\n\t\tfor (var i = N2 - 2; i >= 0; i--) SetMin(i);\n\t}\n\tvoid SetMin(int i)\n\t{\n\t\tint l = 2 * i + 1, r = 2 * i + 2;\n\t\tint a = segtree[l], b = segtree[r];\n\t\tif (a <= b) { segtree[i] = a; position[i] = position[l]; }\n\t\telse { segtree[i] = b; position[i] = position[r]; }\n\t}\n\tTuple<int, int> Merge(Tuple<int, int> a, Tuple<int, int> b) => a.Item1 <= b.Item1 ? a : b;\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0) SetMin(index = (index - 1) / 2);\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1).Item1; } set { Update(n, value); } }\n\t// min, pos\n\tpublic Tuple<int, int> Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tTuple<int, int> Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return new Tuple<int, int>(Func.Inf, N2);\n\t\telse if (from <= l && r <= to) return new Tuple<int, int>(segtree[node], position[node]);\n\t\telse return Merge(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nstatic class Hoge\n{\n\tpublic static T Peek<T>(this IEnumerable<T> set)\n\t{\n\t\tforeach (var x in set) return x;\n\t\treturn default(T);\n\t}\n}\ninterface ISegmentTree\n{\n\tvoid Add(int from, int to, long value);\n\tlong Min(int from, int to);\n}\nclass SegmentTree2 : ISegmentTree\n{\n\tint N;\n\tlong[] a;\n\tpublic SegmentTree2(int N) : this(new long[N]) { }\n\tpublic SegmentTree2(long[] a) { N = a.Length; this.a = a.ToArray(); }\n\tpublic void Add(int from, int to, long value) { for (var i = from; i < to; i++) a[i] += value; }\n\tpublic long Min(int from, int to) { var s = Func.InfL; for (var i = from; i < to; i++) s = Math.Min(s, a[i]); return s; }\n}\nclass SegmentTree3 : ISegmentTree\n{\n\tpublic const long Unit = Func.InfL;\n\tpublic readonly Func<long, long, long> Operator = Math.Min;\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree3(int N) : this(new long[N]) { }\n\tpublic SegmentTree3(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Unit;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) Update(i);\n\t}\n\tvoid LazyEvaluate(int node)\n\t{\n\t\tif (unif[node] != 0)\n\t\t{\n\t\t\tseg[node] += unif[node];\n\t\t\tif (node < N2 - 1) { unif[2 * node + 1] += unif[node]; unif[2 * node + 2] += unif[node]; }\n\t\t\tunif[node] = 0;\n\t\t}\n\t}\n\tvoid Update(int node) => seg[node] = Operator(seg[2 * node + 1], seg[2 * node + 2]);\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (from <= l && r <= to) unif[node] += value;\n\t\telse if (l < to && from < r)\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tUpdate(node);\n\t\t}\n\t\tLazyEvaluate(node);\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tLazyEvaluate(node);\n\t\tif (to <= l || r <= from) return Unit;\n\t\telse if (from <= l && r <= to) return seg[node];\n\t\telse return Operator(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass SegmentTree : ISegmentTree\n{\n\tint N2;\n\tlong[] seg, unif;\n\tpublic SegmentTree(int N) : this(new long[N]) { }\n\tpublic SegmentTree(long[] a)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < a.Length) N2 <<= 1;\n\t\tseg = new long[2 * N2 - 1];\n\t\tunif = new long[2 * N2 - 1];\n\t\tfor (var i = a.Length + N2 - 1; i < 2 * N2 - 1; i++) seg[i] = Func.InfL;\n\t\tfor (var i = 0; i < a.Length; i++) seg[i + N2 - 1] = a[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) seg[i] = Math.Min(seg[2 * i + 1], seg[2 * i + 2]);\n\t}\n\tpublic void Add(int from, int to, long value) => Add(from, to, value, 0, 0, N2);\n\tvoid Add(int from, int to, long value, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return;\n\t\telse if (from <= l && r <= to) unif[node] += value;\n\t\telse\n\t\t{\n\t\t\tAdd(from, to, value, 2 * node + 1, l, (l + r) >> 1);\n\t\t\tAdd(from, to, value, 2 * node + 2, (l + r) >> 1, r);\n\t\t\tseg[node] = Math.Min(seg[2 * node + 1] + unif[2 * node + 1], seg[2 * node + 2] + unif[2 * node + 2]);\n\t\t}\n\t}\n\tpublic long this[int n] { get { return Min(n, n + 1); } set { Add(n, n + 1, value - this[n]); } }\n\tpublic long Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tlong Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.InfL;\n\t\telse if (from <= l && r <= to) return seg[node] + unif[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r)) + unif[node];\n\t}\n}\nclass Eq : IEqualityComparer<List<int>>\n{\n\tpublic bool Equals(List<int> x, List<int> y)\n\t{\n\t\tif (x == null || y == null) return x == y;\n\t\tif (x.Count != y.Count) return false;\n\t\tfor (var i = 0; i < x.Count; i++) if (x[i] != y[i]) return false;\n\t\treturn true;\n\t}\n\tpublic int GetHashCode(List<int> obj)\n\t{\n\t\tvar x = obj.Count.GetHashCode();\n\t\tforeach (var i in obj) x ^= i.GetHashCode();\n\t\treturn x;\n\t}\n}\n/*class MultiSortedSet<T> : IEnumerable<T>, ICollection<T>\n{\n\tpublic IComparer<T> Comparer { get; private set; }\n\tprivate SortedSet<T> keys;\n\tprivate Dictionary<T, int> mult;\n\tpublic int Multiplicity(T item) { return mult[item]; }\n\tpublic int Count { get; private set; }\n\tpublic MultiSortedSet(IComparer<T> comp)\n\t{\n\t\tkeys = new SortedSet<T>(Comparer = comp);\n\t\tmult = new Dictionary<T, int>();\n\t}\n\tpublic MultiSortedSet(Comparison<T> comp) : this(Comparer<T>.Create(comp)) { }\n\tpublic MultiSortedSet() : this(Func.DefaultComparison<T>()) { }\n\tpublic void Add(T item) { Add(item, 1); }\n\tprivate void Add(T item, int num)\n\t{\n\t\tCount += num;\n\t\tif (!keys.Contains(item)) { keys.Add(item); mult.Add(item, num); }\n\t\telse mult[item] += num;\n\t}\n\tpublic void AddRange(IEnumerable<T> list) { foreach (var x in list) Add(x); }\n\tpublic bool Remove(T item)\n\t{\n\t\tif (!keys.Contains(item)) return false;\n\t\tCount--;\n\t\tif (mult[item] == 1) { keys.Remove(item); mult.Remove(item); }\n\t\telse mult[item]--;\n\t\treturn true;\n\t}\n\tpublic bool Overlaps(IEnumerable<T> other) { return keys.Overlaps(other); }\n\tpublic bool IsSupersetOf(IEnumerable<T> other) { return keys.IsSupersetOf(other); }\n\tpublic bool IsSubsetOf(IEnumerable<T> other) { return keys.IsSubsetOf(other); }\n\tpublic bool IsProperSubsetOf(IEnumerable<T> other) { return keys.IsProperSubsetOf(other); }\n\tpublic bool IsProperSupersetOf(IEnumerable<T> other) { return keys.IsProperSupersetOf(other); }\n\tpublic void ExceptWith(IEnumerable<T> other) { foreach (var x in other) if (Contains(x)) Remove(x); }\n\tpublic void IntersectWith(IEnumerable<T> other)\n\t{\n\t\tvar next = new MultiSortedSet<T>(Comparer);\n\t\tforeach (var x in other) if (Contains(x) && !next.Contains(x)) next.Add(x, mult[x]);\n\t\tkeys = next.keys; mult = next.mult;\n\t}\n\tpublic void CopyTo(T[] array) { CopyTo(array, 0); }\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in array) array[index++] = item; }\n\tpublic void CopyTo(T[] array, int index, int count) { var i = 0; foreach (var item in array) { if (i++ >= count) return; array[index++] = item; } }\n\tpublic bool Contains(T item) { return keys.Contains(item); }\n\tpublic void Clear() { keys.Clear(); mult.Clear(); Count = 0; }\n\tpublic IEnumerator<T> Reverse() { foreach (var x in keys.Reverse()) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tpublic IEnumerator<T> GetEnumerator() { foreach (var x in keys) for (var i = 0; i < mult[x]; i++) yield return x; }\n\tIEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }\n\tpublic T Max { get { return keys.Max; } }\n\tpublic T Min { get { return keys.Min; } }\n\tpublic bool IsReadOnly { get { return false; } }\n}*/\nclass SkewHeap<T> : IEnumerable<T>\n{\n\tclass Node : IEnumerable<T>\n\t{\n\t\tpublic Node l, r;\n\t\tpublic T val;\n\t\tpublic Node(T x) { l = r = null; val = x; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (l != null) foreach (var x in l) yield return x;\n\t\t\tyield return val;\n\t\t\tif (r != null) foreach (var x in r) yield return x;\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tpublic int Count { get; private set; }\n\tNode head;\n\tComparison<T> comp;\n\tpublic bool IsEmpty => head != null;\n\tpublic SkewHeap(Comparison<T> c) { comp = c; Count = 0; }\n\tpublic SkewHeap() : this(Func.DefaultComparison<T>()) { }\n\tpublic SkewHeap(IComparer<T> c) : this(Func.ToComparison(c)) { }\n\tprivate SkewHeap(Comparison<T> c, Node h) : this(c) { head = h; }\n\tpublic void Push(T x) { var n = new Node(x); head = Meld(head, n); Count++; }\n\tpublic T Peek() => head.val;\n\tpublic T Pop() { var x = head.val; head = Meld(head.l, head.r); Count--; return x; }\n\t// a.comp must be equivalent to b.comp\n\t// a, b will be destroyed\n\tpublic static SkewHeap<T> Meld(SkewHeap<T> a, SkewHeap<T> b) => new SkewHeap<T>(a.comp, a.Meld(a.head, b.head));\n\tpublic void MeldWith(SkewHeap<T> a) => head = Meld(head, a.head);\n\tNode Meld(Node a, Node b)\n\t{\n\t\tif (a == null) return b;\n\t\telse if (b == null) return a;\n\t\tif (comp(a.val, b.val) > 0) Func.Swap(ref a, ref b);\n\t\ta.r = Meld(a.r, b);\n\t\tFunc.Swap(ref a.l, ref a.r);\n\t\treturn a;\n\t}\n\tpublic IEnumerator<T> GetEnumerator() => head.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => (IEnumerator)GetEnumerator();\n}\n// [0, Size) の整数の集合を表す\nclass BITSet : BinaryIndexedTree\n{\n\tpublic BITSet(int size) : base(size) { }\n\tpublic void Add(int item) => Add(item, 1);\n\tpublic bool Contains(int item) => Sum(item, item + 1) > 0;\n\tpublic int Count(int item) => Sum(item, item + 1);\n\t// 順位 = item が小さい方から何番目か(0-indexed)\n\tpublic int GetRank(int item) => Sum(0, item);\n\tpublic void Remove(int item) => Add(item, -1);\n\tpublic void RemoveAll(int item) => Add(item, -Count(item));\n\t// 0-indexed で順位が rank のものを求める\n\t// ない場合は Size が返る\n\tpublic int GetValue(int rank) => Func.FirstBinary(0, Size, t => Sum(0, t + 1) >= rank + 1);\n}\nclass RangeBIT\n{\n\tpublic int N { get; private set; }\n\tlong[,] bit;\n\tpublic RangeBIT(int N) { bit = new long[2, this.N = N + 1]; }\n\tpublic RangeBIT(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic RangeBIT(long[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 1; i < N; i++) bit[0, i] = array[i - 1];\n\t\tfor (var i = 1; i < N - 1; i++) if (i + (i & (-i)) < N) bit[0, i + (i & (-i))] += bit[0, i];\n\t}\n\tpublic void Add(int from, int to, long value)\n\t{\n\t\tAdd2(0, from + 1, -value * from);\n\t\tAdd2(1, from + 1, value);\n\t\tAdd2(0, to + 1, value * to);\n\t\tAdd2(1, to + 1, -value);\n\t}\n\tvoid Add2(int which, int i, long value) { while (i < N) { bit[which, i] += value; i += i & (-i); } }\n\tlong Sum(int to) => Sum2(0, to) + Sum2(1, to) * to;\n\tpublic long Sum(int from, int to) => Sum(to) - Sum(from);\n\tlong Sum2(int which, int i) { var sum = 0L; while (i > 0) { sum += bit[which, i]; i -= i & (-i); } return sum; }\n}\nclass RMQ\n{\n\tint N2;\n\tint[] segtree;\n\tpublic RMQ(int N) : this(new int[N]) { }\n\tpublic RMQ(int[] array)\n\t{\n\t\tN2 = 1;\n\t\twhile (N2 < array.Length) N2 <<= 1;\n\t\tsegtree = new int[2 * N2 - 1];\n\t\tfor (var i = 0; i < 2 * N2 - 1; i++) segtree[i] = Func.Inf;\n\t\tfor (var i = 0; i < array.Length; i++) segtree[i + N2 - 1] = array[i];\n\t\tfor (var i = N2 - 2; i >= 0; i--) segtree[i] = Math.Min(segtree[2 * i + 1], segtree[2 * i + 2]);\n\t}\n\tpublic void Update(int index, int value)\n\t{\n\t\tindex += N2 - 1;\n\t\tsegtree[index] = value;\n\t\twhile (index > 0)\n\t\t{\n\t\t\tindex = (index - 1) / 2;\n\t\t\tsegtree[index] = Math.Min(segtree[index * 2 + 1], segtree[index * 2 + 2]);\n\t\t}\n\t}\n\tpublic int this[int n] { get { return Min(n, n + 1); } set { Update(n, value); } }\n\tpublic int Min(int from, int to) => Min(from, to, 0, 0, N2);\n\tint Min(int from, int to, int node, int l, int r)\n\t{\n\t\tif (to <= l || r <= from) return Func.Inf;\n\t\telse if (from <= l && r <= to) return segtree[node];\n\t\telse return Math.Min(Min(from, to, 2 * node + 1, l, (l + r) >> 1), Min(from, to, 2 * node + 2, (l + r) >> 1, r));\n\t}\n}\nclass Program\n{\n\tpublic static RandomSFMT rand = new RandomSFMT();\n\tpublic static bool IsJudgeMode = true;\n\tpublic static bool IsGCJMode = false;\n\tpublic static bool IsSolveCreated = true;\n\tstatic void Main()\n\t{\n\t\tif (IsJudgeMode)\n\t\t\tif (IsGCJMode) using (var problem = new Problem(true, new Scanner(\"C-large-practice.in.txt\"), new Printer(\"output.txt\"))) problem.Solve();\n\t\t\telse using (var problem = new Problem(false, new Printer())) problem.Solve();\n\t\telse\n\t\t{\n\t\t\tvar num = 1;\n\t\t\tint size = 0;\n\t\t\tdecimal time = 0;\n\t\t\tfor (var tmp = 0; tmp < num; tmp++)\n\t\t\t{\n\t\t\t\tusing (var P = IsSolveCreated ? new Problem(false, new Scanner(\"input.txt\"), new Printer()) : new Problem(false))\n\t\t\t\t{\n\t\t\t\t\tsize = P.Size;\n\t\t\t\t\ttime += Func.MeasureTime(() => P.Solve());\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(\"{0}, {1}ms\", size, time / num);\n\t\t}\n\t}\n}\nclass BinaryIndexedTree3D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tpublic int Z { get; private set; }\n\tint[,,] bit;\n\tpublic BinaryIndexedTree3D(int X, int Y, int Z)\n\t{\n\t\tthis.X = X; this.Y = Y; this.Z = Z;\n\t\tbit = new int[X + 1, Y + 1, Z + 1];\n\t}\n\tpublic BinaryIndexedTree3D(int[,,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1), array.GetLength(2))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) Add(x, y, z, array[x, y, z]);\n\t}\n\tpublic void Add(int x, int y, int z, int value)\n\t{\n\t\tfor (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) for (var k = z + 1; k <= Z; k += k & (-k)) bit[i, j, k] += value;\n\t}\n\tpublic int Sum(int x0, int y0, int z0, int x1, int y1, int z1)\n\t\t=> Sum(x1, y1, z1) - Sum(x0, y1, z1) - Sum(x1, y0, z1) - Sum(x1, y1, z0) + Sum(x1, y0, z0) + Sum(x0, y1, z0) + Sum(x0, y0, z1) - Sum(x0, y0, z0);\n\tint Sum(int x, int y, int z)\n\t{\n\t\tvar sum = 0;\n\t\tfor (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) for (var k = y; k > 0; k -= k & (-k)) sum += bit[i, j, k];\n\t\treturn sum;\n\t}\n}\nclass BinaryIndexedTree2D\n{\n\tpublic int X { get; private set; }\n\tpublic int Y { get; private set; }\n\tint[,] bit;\n\tpublic BinaryIndexedTree2D(int X, int Y)\n\t{\n\t\tthis.X = X; this.Y = Y;\n\t\tbit = new int[X + 1, Y + 1];\n\t}\n\tpublic BinaryIndexedTree2D(int[,] array)\n\t\t: this(array.GetLength(0), array.GetLength(1))\n\t{\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) Add(x, y, array[x, y]);\n\t}\n\tpublic void Add(int x, int y, int value) { for (var i = x + 1; i <= X; i += i & (-i)) for (var j = y + 1; j <= Y; j += j & (-j)) bit[i, j] += value; }\n\tpublic int Sum(int x0, int y0, int x1, int y1) => Sum(x0, y0) + Sum(x1, y1) - Sum(x0, y1) - Sum(x1, y0);\n\tint Sum(int x, int y) { var sum = 0; for (var i = x; i > 0; i -= i & (-i)) for (var j = y; j > 0; j -= j & (-j)) sum += bit[i, j]; return sum; }\n}\nclass BinaryIndexedTree\n{\n\tpublic int Size { get; private set; }\n\tint[] bit;\n\tpublic BinaryIndexedTree(int size)\n\t{\n\t\tSize = size;\n\t\tbit = new int[size + 1];\n\t}\n\tpublic BinaryIndexedTree(int[] array) : this(array.Length)\n\t{\n\t\tfor (var i = 0; i < Size; i++) bit[i + 1] = array[i];\n\t\tfor (var i = 1; i < Size; i++) if (i + (i & (-i)) <= Size) bit[i + (i & (-i))] += bit[i];\n\t}\n\t// index is 0-indexed\n\tpublic void Add(int index, int value) { for (var i = index + 1; i <= Size; i += i & (-i)) bit[i] += value; }\n\t// from, to is 0-indexed\n\t// from is inclusive, to is exclusive\n\tpublic int Sum(int from, int to) => Sum(to) - Sum(from);\n\tint Sum(int to) { var sum = 0; for (var i = to; i > 0; i -= i & (-i)) sum += bit[i]; return sum; }\n}\nclass Amoeba\n{\n\tpublic const int Dimension = 2;\n\tpublic const double Alpha = 1;  // reflection\n\tpublic const double Beta = 1 + 2.0 / Dimension; // expansion\n\tpublic const double Gamma = 0.75 - 0.5 / Dimension; // contraction\n\tpublic const double Delta = 1 - 1.0 / Dimension;    // shrink\n\tpublic Pair<AmoebaState, double>[] a;\n\tpublic AmoebaState m;\n\tpublic void Initiate()\n\t{\n\t\tArray.Sort(a, (x, y) => x.Second.CompareTo(y.Second));\n\t\tm = new AmoebaState();\n\t\tfor (var i = 0; i < Dimension; i++) m.Add(a[i].First);\n\t\tm.Multiply(1.0 / Dimension);\n\t}\n\tvoid PartialSort(int i, int j) { if (a[i].Second > a[j].Second) a.Swap(i, j); }\n\tvoid Accept(AmoebaState point, double value)\n\t{\n\t\tvar tmp = Func.FirstBinary(0, Dimension, x => a[x].Second >= value);\n\t\tif (tmp != Dimension) m.Add((point - a[Dimension - 1].First) / Dimension);\n\t\tfor (var i = Dimension; i > tmp; i--) a[i] = a[i - 1];\n\t\ta[tmp].First = point;\n\t\ta[tmp].Second = value;\n\t}\n\tpublic void Search()\n\t{\n\t\tvar r = m + Alpha * (m - a[Dimension].First);\n\t\tvar fr = r.Func();\n\t\tif (a[0].Second <= fr && fr < a[Dimension - 1].Second) { Accept(r, fr); return; }\n\t\tvar diff = r - m;\n\t\tif (fr < a[0].Second)\n\t\t{\n\t\t\tvar e = m + Beta * diff;\n\t\t\tvar fe = e.Func();\n\t\t\tif (fe < fr) Accept(e, fe);\n\t\t\telse Accept(r, fr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = Gamma * diff;\n\t\t\tvar o = m + tmp;\n\t\t\tvar fo = o.Func();\n\t\t\tvar i = m - tmp;\n\t\t\tvar fi = i.Func();\n\t\t\tif (fi < fo) { o = i; fo = fi; }\n\t\t\tif (fo < a[Dimension - 1].Second) Accept(o, fo);\n\t\t\telse Shrink();\n\t\t}\n\t}\n\tvoid Shrink()\n\t{\n\t\tvar tmp = (1 - Delta) * a[0].First;\n\t\tfor (var i = 1; i <= Dimension; i++) { a[i].First.Multiply(Delta); a[i].First.Add(tmp); a[i].Second = a[i].First.Func(); }\n\t\tInitiate();\n\t}\n}\nclass AmoebaState\n{\n\tpublic static int Dimension = 2;\n\tpublic double[] vec;\n\tpublic AmoebaState() { vec = new double[Dimension]; }\n\tpublic AmoebaState(params double[] elements) : this() { elements.CopyTo(vec, 0); }\n\tpublic double this[int n] { get { return vec[n]; } set { vec[n] = value; } }\n\tpublic void Multiply(double r) { for (var i = 0; i < Dimension; i++) vec[i] *= r; }\n\tpublic void Add(AmoebaState v) { for (var i = 0; i < Dimension; i++) vec[i] += v.vec[i]; }\n\tpublic static AmoebaState operator +(AmoebaState p) => new AmoebaState(p.vec);\n\tpublic static AmoebaState operator -(AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(-1); return tmp; }\n\tpublic static AmoebaState operator /(AmoebaState p, double r) { var tmp = new AmoebaState(p.vec); tmp.Multiply(1 / r); return tmp; }\n\tpublic static AmoebaState operator *(double r, AmoebaState p) { var tmp = new AmoebaState(p.vec); tmp.Multiply(r); return tmp; }\n\tpublic static AmoebaState operator *(AmoebaState p, double r) => r * p;\n\tpublic static AmoebaState operator +(AmoebaState p, AmoebaState q) { var tmp = +p; tmp.Add(q); return tmp; }\n\tpublic static AmoebaState operator -(AmoebaState p, AmoebaState q) { var tmp = -q; tmp.Add(p); return tmp; }\n\tpublic double Func()\n\t{\n\t\treturn 0;//P.Func(vec[0], vec[1]);\n\t}\n\tpublic static Problem P;\n}\nclass BucketList<T> : ICollection<T>, IEnumerable<T>, ICollection, IEnumerable\n{\n\tpublic Comparison<T> comp { get; protected set; }\n\tpublic int BucketSize = 20;\n\tpublic int Count { get { var sum = 0; var bucket = Head; while (bucket != null) { sum += bucket.Count; bucket = bucket.Next; } return sum; } }\n\tpublic int NumOfBucket { get; protected set; }\n\tpublic Bucket<T> Head { get; protected set; }\n\tpublic Bucket<T> Tail { get; protected set; }\n\tpublic BucketList(IComparer<T> comp) : this(comp.ToComparison()) { }\n\tpublic BucketList(Comparison<T> comp = null) { Head = null; Tail = null; NumOfBucket = 0; this.comp = comp ?? Func.DefaultComparison<T>(); }\n\tprotected void AddAfter(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Tail.Value, bucket.Head.Value) <= 0\n\t\t\t\t\t&& (pos.Next == null || comp(pos.Next.Head.Value, bucket.Tail.Value) >= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos;\n\t\tbucket.Next = pos.Next;\n\t\tif (pos != Tail) pos.Next.Prev = bucket;\n\t\telse Tail = bucket;\n\t\tpos.Next = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> pos, Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0 && pos != null && pos.Parent == this && comp(pos.Head.Value, bucket.Tail.Value) >= 0\n\t\t\t\t\t&& (pos.Prev == null || comp(pos.Prev.Tail.Value, bucket.Head.Value) <= 0));\n\t\tbucket.Parent = this;\n\t\tbucket.Prev = pos.Prev;\n\t\tbucket.Next = pos;\n\t\tif (pos != Head) pos.Prev.Next = bucket;\n\t\telse Head = bucket;\n\t\tpos.Prev = bucket;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddAfter(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Tail.Value, node.Value) <= 0\n\t\t\t\t\t&& (bucket.Next == null || comp(bucket.Next.Head.Value, node.Value) >= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket, bucket.Next);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Tail) bucket.Next.Prev = tmp;\n\t\telse Tail = tmp;\n\t\tbucket.Next = tmp;\n\t\tNumOfBucket++;\n\t}\n\tprotected void AddBefore(Bucket<T> bucket, BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && bucket != null && bucket.Parent == this && node.Parent.Parent == this && comp(bucket.Head.Value, node.Value) >= 0\n\t\t\t\t\t&& (bucket.Prev == null || comp(bucket.Prev.Tail.Value, node.Value) <= 0));\n\t\tvar tmp = new Bucket<T>(this, bucket.Prev, bucket);\n\t\ttmp.InitiateWith(node);\n\t\tif (bucket != Head) bucket.Prev.Next = tmp;\n\t\telse Head = tmp;\n\t\tbucket.Prev = tmp;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (node.Parent.Next == null || comp(node.Parent.Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| comp(node.Next.Value, item) >= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node, node.Next);\n\t\tif (!bucket.AddAfter(node, tmp))\n\t\t{\n\t\t\tif (node.Next == null && (bucket.Next == null || bucket.Next.Count >= BucketSize)) AddAfter(bucket, tmp);\n\t\t\telse if (node.Next == null) AddBefore(bucket.Next.Head, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Next.Prev = tmp;\n\t\t\t\tnode.Next = tmp;\n\t\t\t\twhile (node.Next.Next != null) node = node.Next;\n\t\t\t\titem = node.Next.Value;\n\t\t\t\tbucket.Tail = node;\n\t\t\t\tnode.Next = null;\n\t\t\t\tAddAfter(node, item);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent.Parent == this && comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (node.Parent.Prev == null || comp(node.Parent.Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| comp(node.Prev.Value, item) <= 0));\n\t\tvar bucket = node.Parent;\n\t\tvar tmp = new BucketNode<T>(item, bucket, node.Prev, node);\n\t\tif (!bucket.AddBefore(node, tmp))\n\t\t{\n\t\t\tif (node.Prev == null && (bucket.Prev == null || bucket.Prev.Count >= BucketSize)) AddBefore(bucket, tmp);\n\t\t\telse if (node.Prev == null) AddAfter(bucket.Prev.Tail, item);\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.Prev.Next = tmp;\n\t\t\t\tnode.Prev = tmp;\n\t\t\t\twhile (node.Prev.Prev != null) node = node.Prev;\n\t\t\t\titem = node.Prev.Value;\n\t\t\t\tbucket.Head = node;\n\t\t\t\tnode.Prev = null;\n\t\t\t\tAddBefore(node, item);\n\t\t\t}\n\t\t}\n\t}\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> UpperBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Tail.Tail.Value)) return new Tuple<BucketNode<T>, int>(Tail.Tail, Tail.Count - 1);\n\t\tvar bucket = Tail;\n\t\twhile (bucket.Prev != null && !pred(bucket.Prev.Tail.Value)) bucket = bucket.Prev;\n\t\tvar node = bucket.Tail;\n\t\tvar index = bucket.Count - 1;\n\t\twhile (node.Prev != null && !pred(node.Prev.Value)) { node = node.Prev; index--; }\n\t\tif (node.Prev == null) return bucket.Prev == null ? null : new Tuple<BucketNode<T>, int>(bucket.Prev.Tail, bucket.Prev.Count - 1);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Prev, index - 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> UpperBound(T item) => LowerBound(x => comp(x, item) <= 0);\n\t// (node, index)\n\t// index is the position of node in node.Parent\n\tpublic Tuple<BucketNode<T>, int> LowerBound(Predicate<T> pred)\n\t{\n\t\tif (NumOfBucket == 0) return null;\n\t\tif (pred(Head.Head.Value)) return new Tuple<BucketNode<T>, int>(Head.Head, 0);\n\t\tvar bucket = Head;\n\t\twhile (bucket.Next != null && !pred(bucket.Next.Head.Value)) bucket = bucket.Next;\n\t\tvar node = bucket.Head;\n\t\tvar index = 0;\n\t\twhile (node.Next != null && !pred(node.Next.Value)) { node = node.Next; index++; }\n\t\tif (node.Next == null) return bucket.Next == null ? null : new Tuple<BucketNode<T>, int>(bucket.Next.Head, 0);\n\t\telse return new Tuple<BucketNode<T>, int>(node.Next, index + 1);\n\t}\n\tpublic Tuple<BucketNode<T>, int> LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic void InitiateWith(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Count > 0);\n\t\tRemoveAll();\n\t\tHead = Tail = bucket;\n\t\tbucket.Parent = this;\n\t\tNumOfBucket++;\n\t}\n\tpublic void InitiateWith(T item)\n\t{\n\t\tRemoveAll();\n\t\tHead = Tail = new Bucket<T>(this, null, null);\n\t\tHead.Head = Head.Tail = new BucketNode<T>(item, Head, null, null);\n\t\tHead.Count++;\n\t\tNumOfBucket++;\n\t}\n\tpublic void AddFirst(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddBefore(Head, bucket); }\n\tpublic void AddLast(Bucket<T> bucket) { if (NumOfBucket == 0) InitiateWith(bucket); else AddAfter(Tail, bucket); }\n\tpublic void AddFirst(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddBefore(Head.Head, item); }\n\tpublic void AddLast(T item) { if (NumOfBucket == 0) InitiateWith(item); else AddAfter(Tail.Tail, item); }\n\tpublic void Clear() => RemoveAll();\n\tpublic void RemoveAll() { Head = Tail = null; NumOfBucket = 0; }\n\tpublic void RemoveFirst() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Head.Head); }\n\tpublic void RemoveLast() { if (NumOfBucket == 0) throw new InvalidOperationException(); else Remove(Tail.Tail); }\n\t// remove item and return whether item was removed or not\n\tpublic bool Remove(T item) { var node = Find(item); if (node != null) Remove(node); return node != null; }\n\tpublic void Remove(Bucket<T> bucket)\n\t{\n\t\tDebug.Assert(bucket != null && bucket.Parent == this);\n\t\tNumOfBucket--;\n\t\tif (bucket == Head && bucket == Tail) { Head = Tail = null; }\n\t\telse if (bucket == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\telse if (bucket == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\telse { bucket.Prev.Next = bucket.Next; bucket.Next.Prev = bucket.Prev; }\n\t}\n\tpublic void Remove(BucketNode<T> node) { Debug.Assert(node != null && node.Parent.Parent == this); if (!node.Parent.Remove(node)) Remove(node.Parent); }\n\tprotected void RemoveRange(Bucket<T> from, Bucket<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexFrom == 0 && indexTo == NumOfBucket - 1) { Clear(); return; }\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == NumOfBucket - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tNumOfBucket -= indexTo - indexFrom + 1;\n\t}\n\tpublic void RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent.Parent == this && to.Parent.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tvar bucketFrom = from.Parent;\n\t\tvar bucketTo = to.Parent;\n\t\tif (bucketFrom == bucketTo)\n\t\t{\n\t\t\tvar bucket = bucketFrom;\n\t\t\tif (indexFrom == 0 && indexTo == bucket.Count - 1) Remove(bucket);\n\t\t\telse bucket.RemoveRange(from, to, indexFrom, indexTo);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar bf = bucketFrom.Index;\n\t\t\tvar bt = bucketTo.Index;\n\t\t\tDebug.Assert(bf < bt);\n\t\t\tif (bt > bf + 1) RemoveRange(bucketFrom.Next, bucketTo.Prev, bf + 1, bt - 1);\n\t\t\tif (indexFrom == 0) { Remove(bucketFrom); RemoveRange(bucketTo.Head, to, 0, indexTo); }\n\t\t\telse if (indexTo == bucketTo.Count - 1) { Remove(bucketTo); RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1); }\n\t\t\telse\n\t\t\t{\n\t\t\t\tbucketFrom.RemoveRange(from, bucketFrom.Tail, indexFrom, bucketFrom.Count - 1);\n\t\t\t\tbucketTo.RemoveRange(bucketTo.Head, to, 0, indexTo);\n\t\t\t\tif (bucketFrom.Count + bucketTo.Count < BucketSize) Adjust();\n\t\t\t}\n\t\t}\n\t}\n\tpublic void Adjust()\n\t{\n\t\tvar array = this.ToArray();\n\t\tClear();\n\t\tvar length = array.Length;\n\t\tBucketSize = (int)Math.Sqrt(length + 1);\n\t\tvar count = (length + BucketSize - 1) / BucketSize;\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar bucket = new Bucket<T>(this, null, null);\n\t\t\tvar lim = Math.Min(BucketSize * (i + 1), length);\n\t\t\tfor (var j = BucketSize * i; j < lim; j++) bucket.AddLast(array[j]);\n\t\t\tAddLast(bucket);\n\t\t}\n\t}\n\tpublic BucketNode<T> Find(T item) { var node = LowerBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic BucketNode<T> FindLast(T item) { var node = UpperBound(item); if (node == null || comp(node.Item1.Value, item) != 0) return null; else return node.Item1; }\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar bucket = Head;\n\t\twhile (bucket != null)\n\t\t{\n\t\t\tvar node = bucket.Head;\n\t\t\twhile (node != null) { yield return node.Value; node = node.Next; }\n\t\t\tbucket = bucket.Next;\n\t\t}\n\t}\n\tpublic void Add(T item) { var ub = LowerBound(item); if (ub != null) AddBefore(ub.Item1, item); else AddLast(item); }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(Array array, int index) { foreach (var item in this) array.SetValue(item, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic bool IsReadOnly => false;\n\tpublic bool Contains(T item) => Find(item) != null;\n\tpublic void CopyTo(T[] array, int index) { foreach (var item in this) array[index++] = item; }\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"<Start>\\n\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}\\n\"); node = node.Next; }\n\t\tsb.Append(\"<end>\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (NumOfBucket == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar bucket = Head;\n\t\tvar c = 1;\n\t\twhile (bucket.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(bucket) || !CheckBucket(bucket)) return false;\n\t\t\tbucket = bucket.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn bucket == Tail && CheckBucket(Tail) && c == NumOfBucket;\n\t}\n\tbool CheckConnection(Bucket<T> bucket)\n\t{\n\t\tif (bucket.Next == null) return bucket == Tail;\n\t\telse return bucket.Next.Prev == bucket && comp(bucket.Tail.Value, bucket.Next.Head.Value) <= 0;\n\t}\n\tbool CheckBucket(Bucket<T> bucket) => bucket.Count > 0 && bucket.Count <= BucketSize && bucket.Parent == this;\n\tpublic void Start(Func<string, T> parser, Func<T> random)\n\t{\n\t\tBucketNode<T> x = null, y = null;\n\t\tvar help = true;\n\t\twhile (true)\n\t\t{\n\t\t\tConsole.Clear();\n\t\t\tConsole.WriteLine($\"{Count} items, {NumOfBucket} buckets(size : {BucketSize})\");\n\t\t\tConsole.WriteLine(this);\n\t\t\tConsole.WriteLine(Check() ? \"OK!\" : \"NG!\");\n\t\t\tif (help)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"when val is omitted, random value will be used.\");\n\t\t\t\tConsole.WriteLine(\"a val : add val\");\n\t\t\t\tConsole.WriteLine(\"r val : remove val\");\n\t\t\t\tConsole.WriteLine(\"j : adjust\");\n\t\t\t\tConsole.WriteLine(\"c : clear\");\n\t\t\t\tConsole.WriteLine(\"h : disable/enable help message\");\n\t\t\t\tConsole.WriteLine(\"x : set x\");\n\t\t\t\tConsole.WriteLine(\"x h : set x to head\");\n\t\t\t\tConsole.WriteLine(\"x t : set x to tail\");\n\t\t\t\tConsole.WriteLine(\"x n : set x to x.next\");\n\t\t\t\tConsole.WriteLine(\"x p : set x to x.prev\");\n\t\t\t\tConsole.WriteLine(\"x f val : set x to lower bound of val\");\n\t\t\t\tConsole.WriteLine(\"y : set y\");\n\t\t\t\tConsole.WriteLine(\"x : exchange x and y\");\n\t\t\t\tConsole.WriteLine(\"d : remove from x to y\");\n\t\t\t\tConsole.WriteLine(\"q : quit\");\n\t\t\t}\n\t\t\tif (x != null) Console.WriteLine($\"x = {x.Value} <- {x.Parent}\");\n\t\t\tif (y != null) Console.WriteLine($\"y = {y.Value} <- {y.Parent}\");\n\t\t\tConsole.Write(\"enter command > \");\n\t\t\tvar command = Console.ReadLine().Split();\n\t\t\tif (command[0].Length > 1 && command[0][1] == 'd')\n\t\t\t\tConsole.WriteLine(\"debug...\");\n\t\t\tif (command[0].StartsWith(\"a\")) { if (command.Length > 1) Add(parser(command[1])); else Add(random()); }\n\t\t\telse if (command[0].StartsWith(\"r\")) { if (command.Length > 1) Remove(parser(command[1])); else Remove(random()); }\n\t\t\telse if (command[0].StartsWith(\"c\")) Clear();\n\t\t\telse if (command[0].StartsWith(\"j\")) Adjust();\n\t\t\telse if (command[0].StartsWith(\"h\")) help = !help;\n\t\t\telse if (command[0].StartsWith(\"x\")) SetVariable(command, ref x, parser, random);\n\t\t\telse if (command[0].StartsWith(\"y\")) SetVariable(command, ref y, parser, random);\n\t\t\telse if (command[0].StartsWith(\"e\")) { var tmp = x; x = y; y = tmp; }\n\t\t\telse if (command[0].StartsWith(\"d\")) { RemoveRange(x, y, x.Index, y.Index); x = null; y = null; }\n\t\t\telse if (command[0].StartsWith(\"q\")) break;\n\t\t}\n\t}\n\tvoid SetVariable(string[] command, ref BucketNode<T> x, Func<string, T> parser, Func<T> random)\n\t{\n\t\tif (command[1].StartsWith(\"h\")) x = Head.Head;\n\t\telse if (command[1].StartsWith(\"t\")) x = Tail.Tail;\n\t\telse if (command[1].StartsWith(\"n\"))\n\t\t{\n\t\t\tif (x.Next != null) x = x.Next;\n\t\t\telse if (x.Parent.Next != null) x = x.Parent.Next.Head;\n\t\t\telse { Console.WriteLine(\"x is the last element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"p\"))\n\t\t{\n\t\t\tif (x.Prev != null) x = x.Prev;\n\t\t\telse if (x.Parent.Prev != null) x = x.Parent.Prev.Tail;\n\t\t\telse { Console.WriteLine(\"x is the first element...\"); Console.ReadKey(true); }\n\t\t}\n\t\telse if (command[1].StartsWith(\"f\")) { if (command.Length > 2) x = LowerBound(parser(command[2])).Item1; else x = LowerBound(random()).Item1; }\n\t}\n}\n// bucket cannot be empty\nclass Bucket<T>\n{\n\tpublic BucketList<T> Parent;\n\tpublic int Count;\n\tpublic Bucket<T> Prev;\n\tpublic Bucket<T> Next;\n\tpublic BucketNode<T> Head;\n\tpublic BucketNode<T> Tail;\n\tpublic Bucket(BucketList<T> parent, Bucket<T> prev, Bucket<T> next) { Parent = parent; Prev = prev; Next = next; Head = null; Tail = null; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic bool AddAfter(BucketNode<T> node, BucketNode<T> item) => AddAfter(node, item.Value);\n\tpublic bool AddBefore(BucketNode<T> node, BucketNode<T> item) => AddBefore(node, item.Value);\n\tpublic bool AddAfter(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) <= 0\n\t\t\t\t\t&& ((node.Next == null && (Next == null || Parent.comp(Next.Head.Value, item) >= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Next.Value, item) >= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node, node.Next);\n\t\t\tif (node.Next != null) node.Next.Prev = tmp;\n\t\t\telse Tail = tmp;\n\t\t\tnode.Next = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool AddBefore(BucketNode<T> node, T item)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this && Parent.comp(node.Value, item) >= 0\n\t\t\t\t\t&& ((node.Prev == null && (Prev == null || Parent.comp(Prev.Tail.Value, item) <= 0))\n\t\t\t\t\t\t|| Parent.comp(node.Prev.Value, item) <= 0));\n\t\tif (Count < Parent.BucketSize)\n\t\t{\n\t\t\tvar tmp = new BucketNode<T>(item, this, node.Prev, node);\n\t\t\tif (node.Prev != null) node.Prev.Next = tmp;\n\t\t\telse Head = tmp;\n\t\t\tnode.Prev = tmp;\n\t\t\tCount++;\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool InitiateWith(BucketNode<T> node)\n\t{\n\t\tHead = Tail = node;\n\t\tnode.Parent = this;\n\t\tnode.Prev = node.Next = null;\n\t\tCount++;\n\t\treturn true;\n\t}\n\tpublic bool InitiateWith(T item) => InitiateWith(new BucketNode<T>(item, this, null, null));\n\tpublic void RemoveAll() { Head = Tail = null; Count = 0; }\n\tpublic bool AddFirst(T item) { if (Count == 0) return InitiateWith(item); else return AddBefore(Head, item); }\n\tpublic bool AddLast(T item) { if (Count == 0) return InitiateWith(item); else return AddAfter(Tail, item); }\n\tpublic bool Remove(BucketNode<T> node)\n\t{\n\t\tDebug.Assert(node != null && node.Parent == this);\n\t\tif (Count > 1)\n\t\t{\n\t\t\tCount--;\n\t\t\tif (node == Head) { Head.Next.Prev = null; Head = Head.Next; }\n\t\t\telse if (node == Tail) { Tail.Prev.Next = null; Tail = Tail.Prev; }\n\t\t\telse { node.Prev.Next = node.Next; node.Next.Prev = node.Prev; }\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tpublic bool RemoveRange(BucketNode<T> from, BucketNode<T> to, int indexFrom = -1, int indexTo = -1)\n\t{\n\t\tDebug.Assert(from != null && to != null && from.Parent == this && to.Parent == this);\n\t\tif (indexFrom < 0) indexFrom = from.Index;\n\t\tif (indexTo < 0) indexTo = to.Index;\n\t\tif (indexTo == 0 && indexFrom == Count - 1) return false;\n\t\telse if (indexFrom == 0) { Head = to.Next; Head.Prev = null; }\n\t\telse if (indexTo == Count - 1) { Tail = from.Prev; Tail.Next = null; }\n\t\telse { from.Prev.Next = to.Next; to.Next.Prev = from.Prev; }\n\t\tCount -= indexTo - indexFrom + 1;\n\t\treturn true;\n\t}\n\tpublic override string ToString()\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"[\");\n\t\tvar node = Head;\n\t\twhile (node != null) { sb.Append($\"{node.ToString()}, \"); node = node.Next; }\n\t\tif (sb.Length > 1) sb.Remove(sb.Length - 2, 2);\n\t\tsb.Append(\"]\");\n\t\treturn sb.ToString();\n\t}\n\tpublic bool Check()\n\t{\n\t\tif (Count == 0) return Head == null && Tail == null;\n\t\tif (Head.Prev != null || Tail.Next != null) return false;\n\t\tvar node = Head;\n\t\tvar c = 1;\n\t\twhile (node.Next != null)\n\t\t{\n\t\t\tif (!CheckConnection(node) || !CheckNode(node)) return false;\n\t\t\tnode = node.Next;\n\t\t\tc++;\n\t\t}\n\t\treturn node == Tail && CheckNode(Tail) && c == Count;\n\t}\n\tbool CheckConnection(BucketNode<T> node)\n\t{\n\t\tif (node.Next == null) return node == Tail;\n\t\telse return node.Next.Prev == node && Parent.comp(node.Value, node.Next.Value) <= 0;\n\t}\n\tbool CheckNode(BucketNode<T> node) => node.Parent == this;\n}\nclass BucketNode<T>\n{\n\tpublic T Value;\n\tpublic Bucket<T> Parent;\n\tpublic BucketNode<T> Prev;\n\tpublic BucketNode<T> Next;\n\tpublic BucketNode(T item, Bucket<T> parent, BucketNode<T> prev, BucketNode<T> next) { Value = item; Parent = parent; Prev = prev; Next = next; }\n\tpublic int Index\n\t{\n\t\tget\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar node = Parent.Head;\n\t\t\twhile (node != this) { node = node.Next; count++; }\n\t\t\treturn count;\n\t\t}\n\t}\n\tpublic override string ToString() { return Value.ToString(); }\n}\nclass UndirectedGraph<V, E> : DirectedGraph<V, E>\n{\n\tpublic UndirectedGraph(int V) : base(V) { }\n\tpublic UndirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : base(V, edges) { }\n\tpublic override void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedges.Add(edge.Reverse());\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesFrom[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t\tedgesTo[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t}\n\tpublic bool IsConnected\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) continue;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic bool IsTree\n\t{\n\t\tget\n\t\t{\n\t\t\tif (numberOfNodes == 0) return true;\n\t\t\tvar used = new bool[numberOfNodes];\n\t\t\tvar queue = new Queue<int>();\n\t\t\tqueue.Enqueue(0);\n\t\t\twhile (queue.Count > 0)\n\t\t\t{\n\t\t\t\tvar v = queue.Dequeue();\n\t\t\t\tif (used[v]) return false;\n\t\t\t\tused[v] = true;\n\t\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t\t}\n\t\t\treturn used.All(x => x);\n\t\t}\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreePrim(int start, Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new PriorityQueue<Pair<EdgeInfo<E>, int>>((x, y) => x.Second.CompareTo(y.Second), numberOfNodes);\n\t\td[start] = 0;\n\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(-1, 0, default(E)), 0));\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First.To;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tused[v] = true;\n\t\t\tif (p.First.From >= 0) graph.AddEdge(v, p.First.From, p.First.Information);\n\t\t\tforeach (var w in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tif (!used[w.End] && cost(w.Information) < d[w.End])\n\t\t\t\t{\n\t\t\t\t\td[w.End] = cost(w.Information);\n\t\t\t\t\tqueue.Enqueue(new Pair<EdgeInfo<E>, int>(new EdgeInfo<E>(v, w.End, w.Information), cost(w.Information)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic UndirectedGraph<V, E> MinimumSpanningTreeKruskal(Func<E, int> cost)\n\t{\n\t\tvar graph = new UndirectedGraph<V, E>(numberOfNodes);\n\t\tnodes.CopyTo(graph.nodes, 0);\n\t\tvar tree = new UnionFindTree(numberOfNodes);\n\t\tedges.Sort((x, y) => cost(x.Information).CompareTo(cost(y.Information)));\n\t\tforeach (var e in edges)\n\t\t{\n\t\t\tif (!tree.IsSameCategory(e.From, e.To))\n\t\t\t{\n\t\t\t\ttree.UniteCategory(e.From, e.To);\n\t\t\t\tgraph.AddEdge(e);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\tpublic bool IsBipartite\n\t{\n\t\tget\n\t\t{\n\t\t\tvar color = new int[numberOfNodes];\n\t\t\tforeach (var v in nodes)\n\t\t\t{\n\t\t\t\tif (color[v.Code] == 0)\n\t\t\t\t{\n\t\t\t\t\tvar queue = new Queue<Pair<int, int>>();\n\t\t\t\t\tqueue.Enqueue(new Pair<int, int>(v.Code, 1));\n\t\t\t\t\twhile (queue.Count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar w = queue.Dequeue();\n\t\t\t\t\t\tif (color[w.First] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (color[w.First] != w.Second) return false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcolor[w.First] = w.Second;\n\t\t\t\t\t\tforeach (var e in EdgesFrom(w.First)) queue.Enqueue(new Pair<int, int>(e.End, -w.Second));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic IEnumerable<NodeInfo<V>> GetArticulationPoints()\n\t{\n\t\tvar visited = new bool[numberOfNodes];\n\t\tvar parent = new int[numberOfNodes];\n\t\tvar children = Enumerable.Range(0, numberOfNodes).Select(_ => new SortedSet<int>()).ToArray();\n\t\tvar order = new int[numberOfNodes];\n\t\tvar lowest = new int[numberOfNodes];\n\t\tvar isroot = new bool[numberOfNodes];\n\t\tvar count = 1;\n\t\tvar isarticulation = new bool[numberOfNodes];\n\t\tAction<int, int> dfs = null;\n\t\tdfs = (u, prev) =>\n\t\t{\n\t\t\torder[u] = count;\n\t\t\tlowest[u] = count;\n\t\t\tcount++;\n\t\t\tvisited[u] = true;\n\t\t\tforeach (var e in edgesFrom[u])\n\t\t\t{\n\t\t\t\tvar v = e.End;\n\t\t\t\tif (visited[v]) { if (v != prev) lowest[u] = Math.Min(lowest[u], order[v]); }\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\tif (isroot[u]) children[u].Add(v);\n\t\t\t\t\tdfs(v, u);\n\t\t\t\t\tlowest[u] = Math.Min(lowest[u], lowest[v]);\n\t\t\t\t\tif (order[u] <= lowest[v]) isarticulation[u] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (visited[v]) continue;\n\t\t\tcount = 1; dfs(v, -1);\n\t\t\tisroot[v] = true;\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tif (isroot[v]) { if (children[v].Count > 1) yield return nodes[v]; }\n\t\t\telse { if (isarticulation[v]) yield return nodes[v]; }\n\t\t}\n\t}\n\tpublic string ToString(Func<NodeInfo<V>, string> vertex, Func<EdgeInfo<E>, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"graph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -- v{e.To} [label=\\\"{edge(e)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass NodeInfo<V> : Pair<int, V>\n{\n\tpublic int Code { get { return First; } set { First = value; } }\n\tpublic V Information { get { return Second; } set { Second = value; } }\n\tpublic NodeInfo() : base() { }\n\tpublic NodeInfo(int code, V info) : base(code, info) { }\n}\nclass HalfEdgeInfo<E> : Pair<int, E>\n{\n\tpublic int End { get { return First; } set { First = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic HalfEdgeInfo() : base() { }\n\tpublic HalfEdgeInfo(int end, E info) : base(end, info) { }\n}\nclass EdgeInfo<E> : Pair<Pair<int, int>, E>\n{\n\tpublic int From { get { return First.First; } set { First.First = value; } }\n\tpublic int To { get { return First.Second; } set { First.Second = value; } }\n\tpublic E Information { get { return Second; } set { Second = value; } }\n\tpublic EdgeInfo() : base() { }\n\tpublic EdgeInfo(int from, int to, E info) : base(new Pair<int, int>(from, to), info) { }\n\tpublic EdgeInfo<E> Reverse() => new EdgeInfo<E>(To, From, Information);\n}\nclass DirectedGraph<V, E> : IEnumerable<NodeInfo<V>>\n{\n\tprotected int numberOfNodes;\n\tpublic int NumberOfNodes => numberOfNodes;\n\tprotected NodeInfo<V>[] nodes;\n\tprotected List<EdgeInfo<E>> edges;\n\tprotected List<HalfEdgeInfo<E>>[] edgesFrom;\n\tprotected List<HalfEdgeInfo<E>>[] edgesTo;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesFrom(int node) => edgesFrom[node];\n\tpublic int InDegree(int node) => edgesTo[node].Count;\n\tpublic int OutDegree(int node) => edgesFrom[node].Count;\n\tpublic IEnumerable<HalfEdgeInfo<E>> EdgesTo(int node) => edgesTo[node];\n\tpublic V this[int node] { get { return nodes[node].Second; } set { nodes[node].Second = value; } }\n\tpublic IEnumerable<EdgeInfo<E>> Edges => edges;\n\tpublic DirectedGraph(int V)\n\t{\n\t\tnumberOfNodes = V;\n\t\tnodes = Enumerable.Range(0, V).Select(x => new NodeInfo<V>(x, default(V))).ToArray();\n\t\tedges = new List<EdgeInfo<E>>();\n\t\tedgesFrom = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t\tedgesTo = Enumerable.Range(0, V).Select(_ => new List<HalfEdgeInfo<E>>()).ToArray();\n\t}\n\tpublic DirectedGraph(int V, IEnumerable<EdgeInfo<E>> edges) : this(V) { foreach (var e in edges) AddEdge(e.From, e.To, e.Information); }\n\tpublic virtual void AddEdge(EdgeInfo<E> edge)\n\t{\n\t\tedges.Add(edge);\n\t\tedgesFrom[edge.From].Add(new HalfEdgeInfo<E>(edge.To, edge.Information));\n\t\tedgesTo[edge.To].Add(new HalfEdgeInfo<E>(edge.From, edge.Information));\n\t}\n\tpublic void AddEdge(int from, int to, E information) => AddEdge(new EdgeInfo<E>(from, to, information));\n\tpublic void AddEdge(V from, V to, E information) => AddEdge(new EdgeInfo<E>(SearchNode(from).Code, SearchNode(to).Code, information));\n\tpublic NodeInfo<V> SearchNode(V node) => nodes.FirstOrDefault(e => e.Information.Equals(node));\n\tpublic EdgeInfo<E> SearchEdge(E edge) => edges.Find(e => e.Information.Equals(edge));\n\tpublic IEnumerator<NodeInfo<V>> GetEnumerator() { foreach (var v in nodes) yield return v; }\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic int[] ShortestPathLengthFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\td[from] = 0;\n\t\tvar update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.From] < Func.Inf && d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[] DijkstraFrom(int from, Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(Func.Inf, numberOfNodes).ToArray();\n\t\tvar queue = new PriorityQueue<Pair<int, int>>((x, y) => x.Second.CompareTo(y.Second));\n\t\td[from] = 0;\n\t\tqueue.Enqueue(new Pair<int, int>(from, 0));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.First;\n\t\t\tif (d[v] < p.Second) continue;\n\t\t\tforeach (var e in EdgesFrom(v))\n\t\t\t{\n\t\t\t\tvar tmp = d[v] + cost(e.Information);\n\t\t\t\tif (d[e.End] > tmp) queue.Enqueue(new Pair<int, int>(e.End, d[e.End] = tmp));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\t// cost(e)>=0\n\tpublic Pair<long, int>[] DijkstraFromL(int from, Func<E, long> cost)\n\t{\n\t\tvar d = new Pair<long, int>[numberOfNodes];\n\t\tfor (var i = 0; i < numberOfNodes; i++) d[i] = new Pair<long, int>(Func.InfL, -1);\n\t\tvar queue = new PriorityQueue<Tuple<int, long, int>>((x, y) => x.Item2.CompareTo(y.Item2));\n\t\td[from] = new Pair<long, int>(0, -1);\n\t\tqueue.Enqueue(new Tuple<int, long, int>(from, 0, -1));\n\t\twhile (!queue.IsEmpty)\n\t\t{\n\t\t\tvar p = queue.Dequeue();\n\t\t\tvar v = p.Item1;\n\t\t\tif (d[v].First < p.Item2) continue;\n\t\t\tforeach (var e in edgesFrom[v])\n\t\t\t{\n\t\t\t\tvar tmp = d[v].First + cost(e.Information);\n\t\t\t\tif (d[e.End].First > tmp) queue.Enqueue(new Tuple<int, long, int>(e.End, d[e.End].First = tmp, d[e.End].Second = v));\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic int[,] ShortestPathLengthEachOther(Func<E, int> cost)\n\t{\n\t\tvar d = new int[numberOfNodes, numberOfNodes];\n\t\tfor (var v = 0; v < numberOfNodes; v++) for (var w = 0; w < numberOfNodes; w++) d[v, w] = Func.Inf;\n\t\tfor (var v = 0; v < numberOfNodes; v++) d[v, v] = 0;\n\t\tforeach (var e in edges) if (e.From != e.To) d[e.From, e.To] = cost(e.Information);\n\t\tfor (var k = 0; k < numberOfNodes; k++)\n\t\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t\t\tfor (var w = 0; w < numberOfNodes; w++)\n\t\t\t\t\td[v, w] = Math.Min(d[v, w], d[v, k] + d[k, w]);\n\t\treturn d;\n\t}\n\tpublic bool ContainsNegativeLoopWF(Func<E, int> cost)\n\t{\n\t\tvar d = ShortestPathLengthEachOther(cost);\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (d[v, v] < 0) return true;\n\t\treturn false;\n\t}\n\tpublic bool ContainsNegativeLoop(Func<E, int> cost)\n\t{\n\t\tvar d = Enumerable.Repeat(0, numberOfNodes).ToArray();\n\t\tfor (var v = 0; v < numberOfNodes; v++)\n\t\t{\n\t\t\tforeach (var e in edges)\n\t\t\t{\n\t\t\t\tvar tmp = d[e.From] + cost(e.Information);\n\t\t\t\tif (d[e.To] > tmp)\n\t\t\t\t{\n\t\t\t\t\td[e.To] = tmp;\n\t\t\t\t\tif (v == numberOfNodes - 1) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic IEnumerable<int> ReachableFrom(int from)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (used[v]) yield return v;\n\t}\n\tpublic bool IsReachable(int from, int to)\n\t{\n\t\tvar used = new bool[numberOfNodes];\n\t\tvar queue = new Queue<int>();\n\t\tqueue.Enqueue(from);\n\t\twhile (queue.Count > 0)\n\t\t{\n\t\t\tvar v = queue.Dequeue();\n\t\t\tif (v == to) return true;\n\t\t\tif (used[v]) continue;\n\t\t\tused[v] = true;\n\t\t\tforeach (var e in EdgesFrom(v)) queue.Enqueue(e.End);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]> StronglyConnectedComponents()\n\t{\n\t\tvar mark = new bool[numberOfNodes];\n\t\tvar stack = new Stack<int>();\n\t\tAction<int> dfs = null;\n\t\tdfs = v =>\n\t\t{\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) dfs(w.End);\n\t\t\tstack.Push(v);\n\t\t};\n\t\tfor (var v = 0; v < numberOfNodes; v++) if (!mark[v]) dfs(v);\n\t\tvar scc = new List<HashSet<NodeInfo<V>>>();\n\t\tmark = new bool[numberOfNodes];\n\t\tvar which = new int[numberOfNodes];\n\t\tAction<int, HashSet<NodeInfo<V>>> rdfs = null;\n\t\trdfs = (v, set) =>\n\t\t{\n\t\t\tset.Add(new NodeInfo<V>(v, nodes[v].Information));\n\t\t\tmark[v] = true;\n\t\t\tforeach (var w in edgesFrom[v]) if (!mark[w.End]) rdfs(w.End, set);\n\t\t};\n\t\tvar M = 0;\n\t\twhile (stack.Count > 0)\n\t\t{\n\t\t\tvar v = stack.Pop();\n\t\t\tif (mark[v]) continue;\n\t\t\tvar set = new HashSet<NodeInfo<V>>();\n\t\t\trdfs(v, set);\n\t\t\tscc.Add(set);\n\t\t\tforeach (var w in set) which[w.Code] = M;\n\t\t\tM++;\n\t\t}\n\t\tvar graph = new UndirectedGraph<HashSet<NodeInfo<V>>, object>(M);\n\t\tfor (var v = 0; v < M; v++) graph[v] = scc[v];\n\t\tforeach (var e in edges) if (which[e.From] != which[e.To]) graph.AddEdge(which[e.From], which[e.To], null);\n\t\treturn new Pair<DirectedGraph<HashSet<NodeInfo<V>>, object>, int[]>(graph, which);\n\t}\n\tpublic string ToString(Func<V, string> vertex, Func<E, string> edge)\n\t{\n\t\tvar sb = new StringBuilder();\n\t\tsb.Append(\"digraph G {\\n\");\n\t\tforeach (var v in nodes) sb.Append($\"\\tv{v.Code} [label = \\\"{vertex(v.Information)}\\\"];\\n\");\n\t\tforeach (var e in edges) sb.Append($\"\\tv{e.From} -> v{e.To} [label=\\\"{edge(e.Information)}\\\"];\\n\");\n\t\tsb.Append(\"}\");\n\t\treturn sb.ToString();\n\t}\n\tpublic override string ToString() => ToString(v => v.ToString(), e => e.ToString());\n}\nclass UnionFindTree\n{\n\tint N;\n\tint[] parent, rank, size;\n\tpublic UnionFindTree(int capacity)\n\t{\n\t\tN = capacity;\n\t\tparent = new int[N];\n\t\trank = new int[N];\n\t\tsize = new int[N];\n\t\tfor (var i = 0; i < N; i++) { parent[i] = i; size[i] = 1; }\n\t}\n\tpublic int GetSize(int x) => size[GetRootOf(x)];\n\tpublic int GetRootOf(int x) => parent[x] == x ? x : parent[x] = GetRootOf(parent[x]);\n\tpublic bool UniteCategory(int x, int y)\n\t{\n\t\tif ((x = GetRootOf(x)) == (y = GetRootOf(y))) return false;\n\t\tif (rank[x] < rank[y]) { parent[x] = y; size[y] += size[x]; }\n\t\telse\n\t\t{\n\t\t\tparent[y] = x; size[x] += size[y];\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic bool IsSameCategory(int x, int y) => GetRootOf(x) == GetRootOf(y);\n}\nclass AVLTree<T> : IEnumerable<T>, ICollection<T>, ICollection, IEnumerable\n{\n\tpublic class AVLNode : IEnumerable<T>\n\t{\n\t\tAVLTree<T> tree;\n\t\tint height;\n\t\tpublic int Height => height;\n\t\tpublic int Bias => Left.height - Right.height;\n\t\tpublic T Item;\n\t\tpublic AVLNode Parent;\n\t\tpublic AVLNode Left;\n\t\tpublic AVLNode Right;\n\t\tAVLNode(T x, AVLTree<T> tree) { this.tree = tree; Item = x; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic AVLNode(AVLTree<T> tree) : this(default(T), tree) { height = 0; Parent = null; }\n\t\tpublic AVLNode(T x, AVLNode parent, AVLTree<T> tree) : this(x, tree) { height = 1; Parent = parent; }\n\t\tpublic void Adjust() => height = 1 + Math.Max(Left.height, Right.height);\n\t\tpublic void ResetAsSentinel() { height = 0; Left = tree.sentinel; Right = tree.sentinel; }\n\t\tpublic IEnumerator<T> GetEnumerator()\n\t\t{\n\t\t\tif (this != tree.sentinel)\n\t\t\t{\n\t\t\t\tforeach (var x in Left) yield return x;\n\t\t\t\tyield return Item;\n\t\t\t\tforeach (var x in Right) yield return x;\n\t\t\t}\n\t\t}\n\t\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\t}\n\tAVLNode sentinel;\n\tComparison<T> comp;\n\tFunc<T, T, bool> equals;\n\tint count;\n\t// assumed to be comparer\n\t// i.e. comp(x,x)=0, and comp(x,y)>0 then comp(y,x)<0, and comp(x,y)>0 & comp(y,z)>0 then comp(x,z)>0\n\tpublic AVLTree(Comparison<T> comp)\n\t{\n\t\tsentinel = new AVLNode(this);\n\t\tsentinel.ResetAsSentinel();\n\t\tthis.comp = comp ?? Func.DefaultComparison<T>();\n\t\tif (typeof(T).IsValueType) equals = (x, y) => x.Equals(y);\n\t\telse equals = (x, y) => ReferenceEquals(x, y);\n\t\tcount = 0;\n\t}\n\tpublic AVLTree(IComparer<T> comp = null) : this(comp.ToComparison()) { }\n\tvoid Replace(AVLNode u, AVLNode v)\n\t{\n\t\tvar parent = u.Parent;\n\t\tif (parent.Left == u) parent.Left = v;\n\t\telse parent.Right = v;\n\t\tv.Parent = parent;\n\t}\n\tAVLNode RotateL(AVLNode v)\n\t{\n\t\tvar u = v.Right;\n\t\tReplace(v, u);\n\t\tv.Right = u.Left;\n\t\tu.Left.Parent = v;\n\t\tu.Left = v;\n\t\tv.Parent = u;\n\t\tv.Adjust();\n\t\tu.Adjust();\n\t\treturn u;\n\t}\n\tAVLNode RotateR(AVLNode u)\n\t{\n\t\tvar v = u.Left;\n\t\tReplace(u, v);\n\t\tu.Left = v.Right;\n\t\tv.Right.Parent = u;\n\t\tv.Right = u;\n\t\tu.Parent = v;\n\t\tu.Adjust();\n\t\tv.Adjust();\n\t\treturn v;\n\t}\n\tAVLNode RotateLR(AVLNode t) { RotateL(t.Left); return RotateR(t); }\n\tAVLNode RotateRL(AVLNode t) { RotateR(t.Right); return RotateL(t); }\n\tvoid Adjust(bool isInsertMode, AVLNode node)\n\t{\n\t\twhile (node.Parent != sentinel)\n\t\t{\n\t\t\tvar parent = node.Parent;\n\t\t\tvar height = parent.Height;\n\t\t\tif ((parent.Left == node) == isInsertMode)\n\t\t\t\tif (parent.Bias == 2)\n\t\t\t\t\tif (parent.Left.Bias >= 0) parent = RotateR(parent);\n\t\t\t\t\telse parent = RotateLR(parent);\n\t\t\t\telse parent.Adjust();\n\t\t\telse\n\t\t\t\tif (parent.Bias == -2)\n\t\t\t\tif (parent.Right.Bias <= 0) parent = RotateL(parent);\n\t\t\t\telse parent = RotateRL(parent);\n\t\t\telse parent.Adjust();\n\t\t\tif (height == parent.Height) break;\n\t\t\tnode = parent;\n\t\t}\n\t}\n\tpublic void Add(T item)\n\t{\n\t\tvar parent = sentinel;\n\t\tvar pos = sentinel.Left;\n\t\tvar isLeft = true;\n\t\tcount++;\n\t\twhile (pos != sentinel)\n\t\t\tif (comp(item, pos.Item) < 0) { parent = pos; pos = pos.Left; isLeft = true; }\n\t\t\telse { parent = pos; pos = pos.Right; isLeft = false; }\n\t\tif (isLeft)\n\t\t{\n\t\t\tparent.Left = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Left);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.Right = new AVLNode(item, parent, this);\n\t\t\tAdjust(true, parent.Right);\n\t\t}\n\t}\n\t// if equals(x,y) holds then !(comp(x,y)<0) and !(comp(x,y)>0) must hold\n\t// i.e. equals(x,y) -> comp(x,y)=0\n\tpublic bool Remove(T item, AVLNode start)\n\t{\n\t\tvar pos = start;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse if (equals(pos.Item, item))\n\t\t\t{\n\t\t\t\tif (pos.Left == sentinel)\n\t\t\t\t{\n\t\t\t\t\tReplace(pos, pos.Right);\n\t\t\t\t\tAdjust(false, pos.Right);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar max = Max(pos.Left);\n\t\t\t\t\tpos.Item = max.Item;\n\t\t\t\t\tReplace(max, max.Left);\n\t\t\t\t\tAdjust(false, max.Left);\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return Remove(item, pos.Left) || Remove(item, pos.Right);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic bool Remove(T item) => Remove(item, sentinel.Left);\n\tAVLNode Max(AVLNode node)\n\t{\n\t\twhile (node.Right != sentinel) node = node.Right;\n\t\treturn node;\n\t}\n\tAVLNode Min(AVLNode node)\n\t{\n\t\twhile (node.Left != sentinel) node = node.Left;\n\t\treturn node;\n\t}\n\tpublic bool Contains(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return true;\n\t\t}\n\t\treturn false;\n\t}\n\tpublic T Find(T item)\n\t{\n\t\tvar pos = sentinel.Left;\n\t\twhile (pos != sentinel)\n\t\t{\n\t\t\tif (comp(item, pos.Item) < 0) pos = pos.Left;\n\t\t\telse if (comp(item, pos.Item) > 0) pos = pos.Right;\n\t\t\telse return pos.Item;\n\t\t}\n\t\treturn default(T);\n\t}\n\tpublic AVLNode LowerBound(Predicate<T> pred) { AVLNode node; LowerBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode UpperBound(Predicate<T> pred) { AVLNode node; UpperBound(pred, sentinel.Left, out node); return node; }\n\tpublic AVLNode LowerBound(T item) => LowerBound(x => comp(x, item) >= 0);\n\tpublic AVLNode UpperBound(T item) => UpperBound(x => comp(x, item) <= 0);\n\tbool UpperBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!UpperBound(pred, node.Right, out res)) res = node; return true; }\n\t\telse return UpperBound(pred, node.Left, out res);\n\t}\n\tbool LowerBound(Predicate<T> pred, AVLNode node, out AVLNode res)\n\t{\n\t\tif (node == sentinel) { res = null; return false; }\n\t\tif (pred(node.Item)) { if (!LowerBound(pred, node.Left, out res)) res = node; return true; }\n\t\telse return LowerBound(pred, node.Right, out res);\n\t}\n\tpublic T Min() => Min(sentinel.Left).Item;\n\tpublic AVLNode MinNode() => Min(sentinel.Left);\n\tpublic T Max() => Max(sentinel.Left).Item;\n\tpublic AVLNode MaxNode() => Max(sentinel.Left);\n\tpublic bool IsEmpty => sentinel.Left == sentinel;\n\tpublic void Clear() { sentinel.Left = sentinel; count = 0; sentinel.ResetAsSentinel(); }\n\tpublic IEnumerator<T> GetEnumerator() => sentinel.Left.GetEnumerator();\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tpublic void CopyTo(T[] array, int arrayIndex) { foreach (var x in this) array[arrayIndex++] = x; }\n\tpublic int Count => count;\n\tpublic bool IsReadOnly => true;\n\tpublic void CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic bool IsSynchronized => false;\n\tpublic object SyncRoot => this;\n\tpublic override string ToString()\n\t{\n\t\tvar nodes = new StringBuilder();\n\t\tvar edges = new StringBuilder();\n\t\tConcatSubTree(nodes, edges, sentinel.Left, \"L\");\n\t\treturn $\"digraph G {{\\n{nodes.ToString()}{edges.ToString()}}}\";\n\t}\n\tvoid ConcatSubTree(StringBuilder nodes, StringBuilder edges, AVLNode node, string code)\n\t{\n\t\tif (node == sentinel) return;\n\t\tnodes.Append($\"\\tv{code} [label = \\\"{node.Height}:{node.Item}\\\"];\\n\");\n\t\tif (node.Left != sentinel) edges.Append($\"\\tv{code} -> v{code}L;\\n\");\n\t\tif (node.Right != sentinel) edges.Append($\"\\tv{code} -> v{code}R;\\n\");\n\t\tConcatSubTree(nodes, edges, node.Left, $\"{code}L\");\n\t\tConcatSubTree(nodes, edges, node.Right, $\"{code}R\");\n\t}\n\tpublic bool IsBalanced() => IsBalanced(sentinel.Left);\n\tpublic bool IsValidBinarySearchTree() => IsValidBinarySearchTree(sentinel.Left);\n\tbool IsBalanced(AVLNode node) => node == sentinel || (Math.Abs(node.Bias) < 2 && IsBalanced(node.Left) && IsBalanced(node.Right));\n\tbool IsValidBinarySearchTree(AVLNode node)\n\t\t=> node == sentinel || (Small(node.Item, node.Left) && Large(node.Item, node.Right)\n\t\t\t&& IsValidBinarySearchTree(node.Left) && IsValidBinarySearchTree(node.Right));\n\tbool Small(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) >= 0 && Small(item, node.Left) && Small(item, node.Right));\n\tbool Large(T item, AVLNode node) => node == sentinel || (comp(item, node.Item) <= 0 && Large(item, node.Left) && Large(item, node.Right));\n\tpublic static void CheckAVL(Random rand, int N)\n\t{\n\t\tComparison<double> comp = (x, y) => x.CompareTo(y);\n\t\tvar avl = new AVLTree<double>(comp);\n\t\tvar toBeLeft = new double[N];\n\t\tvar toBeRemoved = new double[N];\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeRemoved[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) avl.Add(toBeLeft[i] = rand.NextDouble());\n\t\tfor (var i = 0; i < N; i++) Console.Write(avl.Remove(toBeRemoved[i]) ? \"\" : \"!!!NOT REMOVED!!! => \" + toBeRemoved[i] + \"\\n\");\n\t\tvar insertErrors = toBeLeft.All(x => avl.Contains(x));\n\t\tvar deleteErrors = avl.Count == N;\n\t\t//Console.WriteLine(\"【AVL木の構造】\");\n\t\t//Console.WriteLine(avl);\n\t\tif (insertErrors && deleteErrors) Console.WriteLine(\"○\\t挿入, 削除操作が正しく行われています.\");\n\t\telse if (insertErrors) Console.WriteLine(\"×\\t挿入(または削除)操作に問題があります.\");\n\t\telse Console.WriteLine(\"×\\t削除(または挿入)操作に問題があります.\");\n\t\tif (avl.IsBalanced()) Console.WriteLine(\"○\\tAVL木は平衡条件を保っています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木の平衡条件が破れています.\");\n\t\tif (avl.IsValidBinarySearchTree()) Console.WriteLine(\"○\\tAVL木は二分探索木になっています.\");\n\t\telse Console.WriteLine(\"×\\tAVL木は二分探索木になっていません.\");\n\t\tArray.Sort(toBeLeft, comp);\n\t\tConsole.WriteLine($\"最小値 : {avl.Min()} ≡ {toBeLeft.First()}\");\n\t\tConsole.WriteLine($\"最大値 : {avl.Max()} ≡ {toBeLeft.Last()}\");\n\t\tConsole.WriteLine($\"要素数 : {avl.Count} 個\");\n\t}\n}\nclass PriorityQueue<T> : IEnumerable<T>, ICollection, IEnumerable, ICloneable\n{\n\tComparison<T> comp;\n\tList<T> list;\n\tpublic int Count { get; private set; } = 0;\n\tpublic bool IsEmpty => Count == 0;\n\tpublic PriorityQueue(IEnumerable<T> source) : this((Comparison<T>)null, 0, source) { }\n\tpublic PriorityQueue(int capacity = 4, IEnumerable<T> source = null) : this((Comparison<T>)null, capacity, source) { }\n\tpublic PriorityQueue(IComparer<T> comp, IEnumerable<T> source) : this(comp.ToComparison(), source) { }\n\tpublic PriorityQueue(IComparer<T> comp, int capacity = 4, IEnumerable<T> source = null) : this(comp.ToComparison(), source) { list.Capacity = capacity; }\n\tpublic PriorityQueue(Comparison<T> comp, IEnumerable<T> source) : this(comp, 0, source) { }\n\tpublic PriorityQueue(Comparison<T> comp, int capacity = 4, IEnumerable<T> source = null) { this.comp = comp ?? Func.DefaultComparison<T>(); list = new List<T>(capacity); if (source != null) foreach (var x in source) Enqueue(x); }\n\t/// <summary>\n\t/// add an item\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <param name=\"x\">item</param>\n\tpublic void Enqueue(T x)\n\t{\n\t\tvar pos = Count++;\n\t\tlist.Add(x);\n\t\twhile (pos > 0)\n\t\t{\n\t\t\tvar p = (pos - 1) / 2;\n\t\t\tif (comp(list[p], x) <= 0) break;\n\t\t\tlist[pos] = list[p];\n\t\t\tpos = p;\n\t\t}\n\t\tlist[pos] = x;\n\t}\n\t/// <summary>\n\t/// return the minimum element and remove it\n\t/// this is an O(log n) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Dequeue()\n\t{\n\t\tvar value = list[0];\n\t\tvar x = list[--Count];\n\t\tlist.RemoveAt(Count);\n\t\tif (Count == 0) return value;\n\t\tvar pos = 0;\n\t\twhile (pos * 2 + 1 < Count)\n\t\t{\n\t\t\tvar a = 2 * pos + 1;\n\t\t\tvar b = 2 * pos + 2;\n\t\t\tif (b < Count && comp(list[b], list[a]) < 0) a = b;\n\t\t\tif (comp(list[a], x) >= 0) break;\n\t\t\tlist[pos] = list[a];\n\t\t\tpos = a;\n\t\t}\n\t\tlist[pos] = x;\n\t\treturn value;\n\t}\n\t/// <summary>\n\t/// look at the minimum element\n\t/// this is an O(1) operation\n\t/// </summary>\n\t/// <returns>the minimum</returns>\n\tpublic T Peek() => list[0];\n\tpublic IEnumerator<T> GetEnumerator() { var x = (PriorityQueue<T>)Clone(); while (x.Count > 0) yield return x.Dequeue(); }\n\tvoid CopyTo(Array array, int index) { foreach (var x in this) array.SetValue(x, index++); }\n\tpublic object Clone() { var x = new PriorityQueue<T>(comp, Count); x.list.AddRange(list); return x; }\n\tpublic void Clear() { list = new List<T>(); Count = 0; }\n\tpublic void TrimExcess() => list.TrimExcess();\n\t/// <summary>\n\t/// check whether item is in this queue\n\t/// this is an O(n) operation\n\t/// </summary>\n\tpublic bool Contains(T item) => list.Contains(item);\n\tIEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\tvoid ICollection.CopyTo(Array array, int index) => CopyTo(array, index);\n\tbool ICollection.IsSynchronized => false;\n\tobject ICollection.SyncRoot => this;\n}\nclass Deque<T>\n{\n\tT[] array;\n\tint offset, capacity;\n\tpublic int Count { get; protected set; }\n\tpublic Deque(int capacity) { array = new T[this.capacity = capacity]; Count = 0; offset = 0; }\n\tpublic Deque() : this(16) { }\n\tpublic T this[int index] { get { return array[GetIndex(index)]; } set { array[GetIndex(index)] = value; } }\n\tint GetIndex(int index) { var tmp = index + offset; return tmp >= capacity ? tmp - capacity : tmp; }\n\tpublic T PeekFront() => array[offset];\n\tpublic T PeekBack() => array[GetIndex(Count - 1)];\n\tpublic void PushFront(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tif (--offset < 0) offset += array.Length;\n\t\tarray[offset] = item;\n\t\tCount++;\n\t}\n\tpublic T PopFront()\n\t{\n\t\tCount--;\n\t\tvar tmp = array[offset++];\n\t\tif (offset >= capacity) offset -= capacity;\n\t\treturn tmp;\n\t}\n\tpublic void PushBack(T item)\n\t{\n\t\tif (Count == capacity) Extend();\n\t\tvar id = (Count++) + offset;\n\t\tif (id >= capacity) id -= capacity;\n\t\tarray[id] = item;\n\t}\n\tpublic T PopBack() => array[GetIndex(--Count)];\n\tpublic void Insert(int index, T item)\n\t{\n\t\tPushFront(item);\n\t\tfor (var i = 0; i < index; i++) this[i] = this[i + 1];\n\t\tthis[index] = item;\n\t}\n\tpublic T RemoveAt(int index)\n\t{\n\t\tvar tmp = this[index];\n\t\tfor (var i = index; i > 0; i--) this[i] = this[i - 1];\n\t\tPopFront();\n\t\treturn tmp;\n\t}\n\tvoid Extend()\n\t{\n\t\tvar newArray = new T[capacity << 1];\n\t\tif (offset > capacity - Count)\n\t\t{\n\t\t\tvar length = array.Length - offset;\n\t\t\tArray.Copy(array, offset, newArray, 0, length);\n\t\t\tArray.Copy(array, 0, newArray, length, Count - length);\n\t\t}\n\t\telse Array.Copy(array, offset, newArray, 0, Count);\n\t\tarray = newArray;\n\t\toffset = 0;\n\t\tcapacity <<= 1;\n\t}\n}\nclass PairComparer<S, T> : IComparer<Pair<S, T>>\n\twhere S : IComparable<S>\n\twhere T : IComparable<T>\n{\n\tpublic PairComparer() { }\n\tpublic int Compare(Pair<S, T> x, Pair<S, T> y)\n\t{\n\t\tvar p = x.First.CompareTo(y.First);\n\t\tif (p != 0) return p;\n\t\telse return x.Second.CompareTo(y.Second);\n\t}\n}\nclass Pair<S, T>\n{\n\tpublic S First;\n\tpublic T Second;\n\tpublic Pair() { First = default(S); Second = default(T); }\n\tpublic Pair(S s, T t) { First = s; Second = t; }\n\tpublic override string ToString() => $\"({First}, {Second})\";\n\tpublic override int GetHashCode() => First.GetHashCode() ^ Second.GetHashCode();\n\tpublic override bool Equals(object obj)\n\t{\n\t\tif (ReferenceEquals(this, obj)) return true;\n\t\telse if (obj == null) return false;\n\t\tvar tmp = obj as Pair<S, T>;\n\t\treturn tmp != null && First.Equals(tmp.First) && Second.Equals(tmp.Second);\n\t}\n}\nclass Point : Pair<int, int>\n{\n\tpublic int X { get { return First; } set { First = value; } }\n\tpublic int Y { get { return Second; } set { Second = value; } }\n\tpublic Point() : base(0, 0) { }\n\tpublic Point(int x, int y) : base(x, y) { }\n\tpublic IEnumerable<Point> Neighbors4()\n\t{\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y);\n\t}\n\tpublic IEnumerable<Point> Neighbors8()\n\t{\n\t\tyield return new Point(X - 1, Y - 1);\n\t\tyield return new Point(X - 1, Y);\n\t\tyield return new Point(X - 1, Y + 1);\n\t\tyield return new Point(X, Y - 1);\n\t\tyield return new Point(X, Y + 1);\n\t\tyield return new Point(X + 1, Y - 1);\n\t\tyield return new Point(X + 1, Y);\n\t\tyield return new Point(X + 1, Y + 1);\n\t}\n\tpublic static Point operator +(Point p) => new Point(p.X, p.Y);\n\tpublic static Point operator -(Point p) => new Point(-p.X, -p.Y);\n\tpublic static Point operator /(Point p, int r) => new Point(p.X / r, p.Y / r);\n\tpublic static Point operator *(int r, Point p) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator *(Point p, int r) => new Point(p.X * r, p.Y * r);\n\tpublic static Point operator +(Point p, Point q) => new Point(p.X + q.X, p.Y + q.Y);\n\tpublic static Point operator -(Point p, Point q) => new Point(p.X - q.X, p.Y - q.Y);\n}\nclass Printer : IDisposable\n{\n\tbool isConsole;\n\tTextWriter file;\n\tpublic Printer() { file = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; isConsole = true; }\n\tpublic Printer(string path) { file = new StreamWriter(path, false) { AutoFlush = false }; isConsole = false; }\n\tpublic void Write<T>(T value) => file.Write(value);\n\tpublic void Write(bool b) => file.Write(b ? \"YES\" : \"NO\");\n\tpublic void Write(string str, params object[] args) => file.Write(str, args);\n\tpublic void WriteLine() => file.WriteLine();\n\tpublic void WriteLine<T>(T value) => file.WriteLine(value);\n\tpublic void WriteLine(bool b) => file.WriteLine(b ? \"YES\" : \"NO\");\n\tpublic void WriteLine<T>(IEnumerable<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(List<T> list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine<T>(T[] list) { foreach (var x in list) file.WriteLine(x); }\n\tpublic void WriteLine(string str, params object[] args) => file.WriteLine(str, args);\n\tpublic void Dispose() { file.Flush(); if (!isConsole) file.Dispose(); }\n}\nclass Scanner : IDisposable\n{\n\tbool isConsole;\n\tTextReader file;\n\tpublic Scanner() { file = Console.In; }\n\tpublic Scanner(string path) { file = new StreamReader(path); isConsole = false; }\n\tpublic void Dispose() { if (!isConsole) file.Dispose(); }\n\tpublic T Get<T>() => (T)Convert(file.ReadLine(), Type.GetTypeCode(typeof(T)));\n\tpublic int Int => Get<int>();\n\tpublic uint UInt => Get<uint>();\n\tpublic long Long => Get<long>();\n\tpublic ulong ULong => Get<ulong>();\n\tpublic double Double => Get<double>();\n\tpublic decimal Decimal => Get<decimal>();\n\tpublic char Char => Get<char>();\n\tpublic string String => Get<string>();\n\tpublic Tuple<S, T> Get<S, T>() { S s; T t; Read(out s, out t); return new Tuple<S, T>(s, t); }\n\tpublic Tuple<S, T, U> Get<S, T, U>() { S s; T t; U u; Read(out s, out t, out u); return new Tuple<S, T, U>(s, t, u); }\n\tpublic Tuple<S, T, U, V> Get<S, T, U, V>() { S s; T t; U u; V v; Read(out s, out t, out u, out v); return new Tuple<S, T, U, V>(s, t, u, v); }\n\tpublic Tuple<S, T, U, V, W> Get<S, T, U, V, W>() { S s; T t; U u; V v; W w; Read(out s, out t, out u, out v, out w); return new Tuple<S, T, U, V, W>(s, t, u, v, w); }\n\tpublic Tuple<S, T, U, V, W, X> Get<S, T, U, V, W, X>() { S s; T t; U u; V v; W w; X x; Read(out s, out t, out u, out v, out w, out x); return new Tuple<S, T, U, V, W, X>(s, t, u, v, w, x); }\n\tpublic Tuple<S, T, U, V, W, X, Y> Get<S, T, U, V, W, X, Y>() { S s; T t; U u; V v; W w; X x; Y y; Read(out s, out t, out u, out v, out w, out x, out y); return new Tuple<S, T, U, V, W, X, Y>(s, t, u, v, w, x, y); }\n\tpublic Tuple<S, T, U, V, W, X, Y, Z> Get<S, T, U, V, W, X, Y, Z>() { S s; T t; U u; V v; W w; X x; Y y; Z z; Read(out s, out t, out u, out v, out w, out x, out y, out z); return new Tuple<S, T, U, V, W, X, Y, Z>(s, t, u, v, w, x, y, z); }\n\tpublic Pair<S, T> Pair<S, T>() { S s; T t; Read(out s, out t); return new Pair<S, T>(s, t); }\n\tobject Convert(string str, TypeCode type)\n\t{\n\t\tif (type == TypeCode.Int32) return int.Parse(str);\n\t\telse if (type == TypeCode.UInt32) return uint.Parse(str);\n\t\telse if (type == TypeCode.Int64) return long.Parse(str);\n\t\telse if (type == TypeCode.UInt64) return ulong.Parse(str);\n\t\telse if (type == TypeCode.Double) return double.Parse(str);\n\t\telse if (type == TypeCode.Decimal) return decimal.Parse(str);\n\t\telse if (type == TypeCode.Char) return str[0];\n\t\telse if (type == TypeCode.String) return str;\n\t\telse if (type == Type.GetTypeCode(typeof(Point))) { int s, t; Read(out s, out t); return new Point(s, t); }\n\t\telse throw new Exception();\n\t}\n\tpublic T[] ReadMany<T>() { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadMany<T>(int n) { var type = Type.GetTypeCode(typeof(T)); return file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries).Take(n).Select(str => (T)Convert(str, type)).ToArray(); }\n\tpublic T[] ReadManyLines<T>(int n, Func<T> selector) => Enumerable.Range(0, n).Select(_ => selector()).ToArray();\n\tpublic T[] ReadManyLines<T>(int n) => Enumerable.Range(0, n).Select(_ => Get<T>()).ToArray();\n\tpublic Tuple<S, T>[] ReadManyLines<S, T>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T>()).ToArray();\n\tpublic Tuple<S, T, U>[] ReadManyLines<S, T, U>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U>()).ToArray();\n\tpublic Tuple<S, T, U, V>[] ReadManyLines<S, T, U, V>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V>()).ToArray();\n\tpublic Tuple<S, T, U, V, W>[] ReadManyLines<S, T, U, V, W>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X>[] ReadManyLines<S, T, U, V, W, X>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y>[] ReadManyLines<S, T, U, V, W, X, Y>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y>()).ToArray();\n\tpublic Tuple<S, T, U, V, W, X, Y, Z>[] ReadManyLines<S, T, U, V, W, X, Y, Z>(int n) => Enumerable.Range(0, n).Select(_ => Get<S, T, U, V, W, X, Y, Z>()).ToArray();\n\tpublic T[,] ReadManyManyLines<T>(int X, int Y)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++) { var tmp = ReadMany<T>(X); for (var x = 0; x < X; x++) array[x, y] = tmp[x]; }\n\t\treturn array;\n\t}\n\tpublic void Read<S>(out S s)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S))).ToArray();\n\t\ts = (S)read[0];\n\t}\n\tpublic void Read<S, T>(out S s, out T t)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t}\n\tpublic void Read<S, T, U>(out S s, out T t, out U u)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t}\n\tpublic void Read<S, T, U, V>(out S s, out T t, out U u, out V v)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)), Type.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t}\n\tpublic void Read<S, T, U, V, W>(out S s, out T t, out U u, out V v, out W w)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t}\n\tpublic void Read<S, T, U, V, W, X>(out S s, out T t, out U u, out V v, out W w, out X x)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)), Type.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t}\n\tpublic void Read<S, T, U, V, W, X, Y, Z>(out S s, out T t, out U u, out V v, out W w, out X x, out Y y, out Z z)\n\t{\n\t\tvar read = ReadMulti(Type.GetTypeCode(typeof(S)), Type.GetTypeCode(typeof(T)),\n\t\t\tType.GetTypeCode(typeof(U)), Type.GetTypeCode(typeof(V)), Type.GetTypeCode(typeof(W)),\n\t\t\tType.GetTypeCode(typeof(X)), Type.GetTypeCode(typeof(Y)), Type.GetTypeCode(typeof(Z))).ToArray();\n\t\ts = (S)read[0];\n\t\tt = (T)read[1];\n\t\tu = (U)read[2];\n\t\tv = (V)read[3];\n\t\tw = (W)read[4];\n\t\tx = (X)read[5];\n\t\ty = (Y)read[6];\n\t\tz = (Z)read[7];\n\t}\n\tstatic char[] sep = new char[] { ' ', '/' };\n\tIEnumerable<object> ReadMulti(params TypeCode[] types)\n\t{\n\t\tvar input = file.ReadLine().Split(sep, StringSplitOptions.RemoveEmptyEntries);\n\t\tfor (var i = 0; i < types.Length; i++) yield return Convert(input[i], types[i]);\n\t}\n\tpublic T[,] Board<T>(int X, int Y, Func<char, int, int, T> selector)\n\t{\n\t\tvar array = new T[X, Y];\n\t\tfor (var y = 0; y < Y; y++)\n\t\t{\n\t\t\tvar str = Get<string>();\n\t\t\tfor (var x = 0; x < X; x++) array[x, y] = selector(str[x], x, y);\n\t\t}\n\t\treturn array;\n\t}\n}\nstatic class Func\n{\n\tpublic const int Inf = 1073741789;  // 2 * Inf < int.MaxValue, and Inf is a prime number\n\tpublic const long InfL = 4011686018427387913L;  // 2 * InfL < long.MaxValue, and InfL is a prime number\n\tpublic static Comparison<T> DefaultComparison<T>() => (x, y) => Comparer<T>.Default.Compare(x, y);\n\tpublic static Comparison<T> ToComparison<T>(this IComparer<T> comp) => comp == null ? DefaultComparison<T>() : (x, y) => comp.Compare(x, y);\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static long FirstBinary(long min, long max, Predicate<long> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\t/// <summary>\n\t/// Find the first number x such that pred(x) is true\n\t/// if pred(x) is false for all min&lt;=x&lt;max, then return max\n\t/// in other words, pred(max) is assumed to be true\n\t/// </summary>\n\t/// <param name=\"min\">inclusive lower limit</param>\n\t/// <param name=\"max\">exclusive upper limit</param>\n\t/// <param name=\"pred\">monotonous predicate, i.e. if pred(a) and a&lt;b, then pred(b)</param>\n\t/// <returns>first number such that satisfy pred</returns>\n\tpublic static int FirstBinary(int min, int max, Predicate<int> pred)\n\t{\n\t\twhile (min < max)\n\t\t{\n\t\t\tvar mid = (min + max) / 2;\n\t\t\tif (pred(mid)) max = mid;\n\t\t\telse min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n\tpublic static Dictionary<T, S> Reverse<S, T>(this IDictionary<S, T> dict)\n\t{\n\t\tvar r = new Dictionary<T, S>();\n\t\tforeach (var t in dict) r.Add(t.Value, t.Key);\n\t\treturn r;\n\t}\n\tpublic static void Swap<T>(this IList<T> array, int i, int j) { var tmp = array[i]; array[i] = array[j]; array[j] = tmp; }\n\tpublic static void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\tpublic static T IndexAt<T>(this T[,] array, Pair<int, int> index) => array[index.First, index.Second];\n\tpublic static bool InRegion(this Pair<int, int> p, int X, int Y) => p.InRegion(0, X, 0, Y);\n\tpublic static bool InRegion(this Pair<int, int> p, int x, int X, int y, int Y) => p.First >= x && p.Second >= y && p.First < X && p.Second < Y;\n\t/// <summary>\n\t/// get all permutation of 0, 1, ..., n - 1\n\t/// </summary>\n\t/// <param name=\"n\">length of array</param>\n\t/// <param name=\"func\">if you want to change the elements of the array, you must take a copy</param>\n\tpublic static void Permutation(int n, Action<int[]> func)\n\t{\n\t\tvar array = new int[n];\n\t\tvar unused = new bool[n];\n\t\tfor (var i = 0; i < n; i++) unused[i] = true;\n\t\tPermutation(n, 0, array, unused, func);\n\t}\n\tstatic void Permutation(int n, int i, int[] array, bool[] unused, Action<int[]> func)\n\t{\n\t\tif (i == n) func(array);\n\t\telse\n\t\t\tfor (var x = 0; x < n; x++)\n\t\t\t\tif (unused[x])\n\t\t\t\t{\n\t\t\t\t\tarray[i] = x;\n\t\t\t\t\tunused[x] = false;\n\t\t\t\t\tPermutation(n, i + 1, array, unused, func);\n\t\t\t\t\tunused[x] = true;\n\t\t\t\t}\n\t}\n\tpublic static long Fact(int n)\n\t{\n\t\tvar fact = 1L;\n\t\tfor (var i = 2; i <= n; i++) fact *= i;\n\t\treturn fact;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n, List<int> primes)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var j = 0; j < primes.Count; j++)\n\t\t{\n\t\t\tvar i = primes[j];\n\t\t\tif (i * i > n) break;\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static Dictionary<long, int> Factorize(this long n)\n\t{\n\t\tvar d = new Dictionary<long, int>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\td.Add(i, 0);\n\t\t\t\twhile (n % i == 0) { n /= i; d[i]++; }\n\t\t\t}\n\t\tif (n > 1) d.Add(n, 1);\n\t\treturn d;\n\t}\n\tpublic static long LCM(long n, long m) => Math.Abs((n / GCD(n, m)) * m);\n\tpublic static long Divide(long n, long m) => (n - Remainder(n, m)) / m;\n\tpublic static long Remainder(long n, long m)\n\t{\n\t\tif (m == 0) throw new DivideByZeroException();\n\t\telse if (m < 0) return Remainder(n, -m);\n\t\telse\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\treturn r < 0 ? r + m : r;\n\t\t}\n\t}\n\tpublic static long Recurrence(long[] coeff, long[] init, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < 0)\n\t\t{\n\t\t\tvar inv = Inverse(coeff[0], mod);\n\t\t\tvar rc = new long[K];\n\t\t\tfor (var i = 1; i < K; i++) rc[K - i] = -coeff[i] * inv % mod;\n\t\t\trc[0] = inv;\n\t\t\tvar ri = new long[K];\n\t\t\tfor (var i = 0; i < K; i++) ri[K - 1 - i] = init[i];\n\t\t\treturn Recurrence(rc, ri, K - 1 - N, mod);\n\t\t}\n\t\tvar tmp = new long[K];\n\t\tRecurrence(coeff, init, tmp, N, mod);\n\t\tvar sum = 0L;\n\t\tfor (var i = 0; i < K; i++) sum += init[i] * tmp[i] % mod;\n\t\tsum %= mod;\n\t\tif (sum < 0) sum += mod;\n\t\treturn sum;\n\t}\n\tpublic static void Recurrence(long[] coeff, long[] init, long[] state, long N, long mod)\n\t{\n\t\tvar K = init.Length;\n\t\tif (N < K) state[N] = init[N];\n\t\telse if ((N & 1) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K][];\n\t\t\tfor (var i = 0; i < K; i++) tmp[i] = new long[K];\n\t\t\tRecurrence(coeff, init, tmp[0], N / 2, mod);\n\t\t\tfor (var i = 1; i < K; i++) tmp[i] = Next(coeff, tmp[i - 1], mod);\n\t\t\tfor (var i = 0; i < K; i++)\n\t\t\t{\n\t\t\t\tstate[i] = 0;\n\t\t\t\tfor (var j = 0; j < K; j++) state[i] += tmp[0][j] * tmp[j][i] % mod;\n\t\t\t\tstate[i] %= mod;\n\t\t\t}\n\t\t}\n\t\telse if (N < 2 * K || (N & 2) == 0)\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N - 1, mod);\n\t\t\ttmp = Next(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar tmp = new long[K];\n\t\t\tRecurrence(coeff, init, tmp, N + 1, mod);\n\t\t\ttmp = Prev(coeff, tmp, mod);\n\t\t\tfor (var i = 0; i < K; i++) state[i] = tmp[i];\n\t\t}\n\t}\n\tstatic long[] Next(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tfor (var i = 0; i < K; i++) tmp[i] = coeff[i] * state[K - 1] % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i] = (tmp[i] + state[i - 1]) % mod;\n\t\treturn tmp;\n\t}\n\tstatic long[] Prev(long[] coeff, long[] state, long mod)\n\t{\n\t\tvar K = coeff.Length;\n\t\tvar tmp = new long[K];\n\t\tvar inv = Inverse(coeff[0], mod);\n\t\ttmp[K - 1] = state[0] * inv % mod;\n\t\tfor (var i = 1; i < K; i++) tmp[i - 1] = (state[i] - coeff[i] * tmp[K - 1] % mod) % mod;\n\t\treturn tmp;\n\t}\n\t// get all primes less than or equal to n\n\tpublic static List<int> GetPrimes(int n)\n\t{\n\t\tif (n < 3) n = 3;\n\t\tvar m = (n - 1) >> 1;\n\t\tvar primes = new List<int>((int)(n / Math.Log(n)));\n\t\tprimes.Add(2);\n\t\tvar composites = new bool[m];\n\t\tcomposites[0] = false;\n\t\tfor (var p = 0; p < m; p++)\n\t\t{\n\t\t\tif (!composites[p])\n\t\t\t{\n\t\t\t\tvar pnum = 2 * p + 3;\n\t\t\t\tprimes.Add(pnum);\n\t\t\t\tfor (var k = 3 * p + 3; k < m; k += pnum) composites[k] = true;\n\t\t\t}\n\t\t}\n\t\treturn primes;\n\t}\n\t/// <summary>\n\t/// solve nx+my=1 and returns (x,y)\n\t/// </summary>\n\t/// <param name=\"n\">assumed to be with m</param>\n\t/// <param name=\"m\">assumed to be with n</param>\n\t/// <returns>(x,y) where nx+my=1</returns>\n\tpublic static Tuple<long, long> SolveLinear(long n, long m)\n\t{\n\t\tif (n < 0) { var p = SolveLinear(-n, m); return p == null ? p : new Tuple<long, long>(-p.Item1, p.Item2); }\n\t\tif (m < 0) { var p = SolveLinear(n, -m); return p == null ? p : new Tuple<long, long>(p.Item1, -p.Item2); }\n\t\tif (n < m) { var p = SolveLinear(m, n); return p == null ? p : new Tuple<long, long>(p.Item2, p.Item1); }\n\t\tlong a = 1, b = 0, c = 0, d = 1;\n\t\twhile (m > 0)\n\t\t{\n\t\t\tvar r = n % m;\n\t\t\tvar q = n / m;\n\t\t\tn = m;\n\t\t\tm = r;\n\t\t\tvar tmp = a;\n\t\t\ta = -a * q + b;\n\t\t\tb = tmp;\n\t\t\ttmp = c;\n\t\t\tc = -c * q + d;\n\t\t\td = tmp;\n\t\t}\n\t\treturn n != 1 ? null : new Tuple<long, long>(d, b);\n\t}\n\tpublic static int GCD(int n, int m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}\n\t/*public static long GCD(long n, long m)\n\t{\n\t\tvar a = Math.Abs(n);\n\t\tvar b = Math.Abs(m);\n\t\tif (a < b) { var c = a; a = b; b = c; }\n\t\twhile (b > 0)\n\t\t{\n\t\t\tvar c = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t\treturn a;\n\t}*/\n\tpublic static long GCD(long a, long b)\n\t{\n\t\tvar n = (ulong)Math.Abs(a); var m = (ulong)Math.Abs(b);\n\t\tif (n == 0) return (long)m; if (m == 0) return (long)n;\n\t\tint zm = 0, zn = 0;\n\t\twhile ((n & 1) == 0) { n >>= 1; zn++; }\n\t\twhile ((m & 1) == 0) { m >>= 1; zm++; }\n\t\twhile (m != n)\n\t\t{\n\t\t\tif (m > n) { m -= n; while ((m & 1) == 0) m >>= 1; }\n\t\t\telse { n -= m; while ((n & 1) == 0) n >>= 1; }\n\t\t}\n\t\treturn (long)n << Math.Min(zm, zn);\n\t}\n\tpublic static BigInteger GCD(BigInteger a, BigInteger b) => BigInteger.GreatestCommonDivisor(a, b);\n\tpublic static long Inverse(long a, long mod)\n\t{\n\t\tif (a < 0) { a %= mod; if (a < 0) a += mod; }\n\t\tvar t = SolveLinear(a, mod);\n\t\treturn t.Item1 > 0 ? t.Item1 : t.Item1 + mod;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b, ulong mod)\n\t{\n\t\tvar p = 1uL;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b, long mod)\n\t{\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p = (p * x) % mod;\n\t\t\tb >>= 1;\n\t\t\tx = (x * x) % mod;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long Pow(long a, long b)\n\t{\n\t\tif (a == 1) return 1;\n\t\telse if (a == 0) { if (b >= 0) return 0; else throw new DivideByZeroException(); }\n\t\telse if (b < 0) return 0;\n\t\tvar p = 1L;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static ulong Pow(ulong a, ulong b)\n\t{\n\t\tvar p = 1ul;\n\t\tvar x = a;\n\t\twhile (b > 0)\n\t\t{\n\t\t\tif ((b & 1) == 1) p *= x;\n\t\t\tb >>= 1;\n\t\t\tx *= x;\n\t\t}\n\t\treturn p;\n\t}\n\tpublic static long ChineseRemainder(Tuple<long, long> modRemainder1, Tuple<long, long> modRemainder2)\n\t{\n\t\tvar m1 = modRemainder1.Item1;\n\t\tvar m2 = modRemainder2.Item1;\n\t\tvar a1 = modRemainder1.Item2;\n\t\tvar a2 = modRemainder2.Item2;\n\t\tvar t = SolveLinear(m1, m2);\n\t\tvar n1 = t.Item1;\n\t\tvar n2 = t.Item2;\n\t\treturn (m1 * n1 * a2 + m2 * n2 * a1) % (m1 * m2);\n\t}\n\tpublic static long ChineseRemainder(params Tuple<long, long>[] modRemainder)\n\t{\n\t\tif (modRemainder.Length == 0) throw new DivideByZeroException();\n\t\telse if (modRemainder.Length == 1) return modRemainder[0].Item2;\n\t\telse if (modRemainder.Length == 2) return ChineseRemainder(modRemainder[0], modRemainder[1]);\n\t\telse\n\t\t{\n\t\t\tvar tuple = new Tuple<long, long>(1, 0);\n\t\t\tfor (var i = 0; i < modRemainder.Length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = ChineseRemainder(tuple, modRemainder[i]);\n\t\t\t\ttuple = new Tuple<long, long>(tuple.Item1 * modRemainder[i].Item1, tmp);\n\t\t\t}\n\t\t\treturn tuple.Item2;\n\t\t}\n\t}\n\t// forward transform -> theta= 2*PI/n\n\t// reverse transform -> theta=-2*PI/n, and use a[i]/n instead of a\n\t// O(n*log(n))\n\tpublic static void FastFourierTransform(int n, double theta, Complex[] a)\n\t{\n\t\tfor (var m = n; m >= 2; m >>= 1)\n\t\t{\n\t\t\tvar mh = m >> 1;\n\t\t\tfor (var i = 0; i < mh; i++)\n\t\t\t{\n\t\t\t\tvar w = Complex.Exp(i * theta * Complex.ImaginaryOne);\n\t\t\t\tfor (var j = i; j < n; j += m)\n\t\t\t\t{\n\t\t\t\t\tvar k = j + mh;\n\t\t\t\t\tvar x = a[j] - a[k];\n\t\t\t\t\ta[j] += a[k];\n\t\t\t\t\ta[k] = w * x;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttheta *= 2;\n\t\t}\n\t\tvar s = 0;\n\t\tfor (var j = 1; j < n - 1; j++)\n\t\t{\n\t\t\tfor (var k = n >> 1; k > (s ^= k); k >>= 1) ;\n\t\t\tif (j < s) a.Swap(s, j);\n\t\t}\n\t}\n\t// get table of Euler function\n\t// let return value f, f[i]=phi(i) for 0<=i<=n\n\t// nearly O(n)\n\tpublic static long[] EulerFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new long[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = i;\n\t\tfor (var i = 2L; i <= n; i++) if (f[i] == i) for (var j = i; j <= n; j += i) f[j] = f[j] / i * (i - 1);\n\t\treturn f;\n\t}\n\t// O(sqrt(n))\n\tpublic static long EulerFunction(long n)\n\t{\n\t\tvar res = n;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tres = res / i * (i - 1);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) res = res / n * (n - 1);\n\t\treturn res;\n\t}\n\t// get moebius function of d s.t. 0<=d<=n\n\t// O(n)\n\tpublic static int[] MoebiusFunctionTable(long n)\n\t{\n\t\tif (n < 2) n = 2;\n\t\tvar f = new int[n + 1];\n\t\tvar p = new bool[n + 1];\n\t\tfor (var i = 0L; i <= n; i++) f[i] = 1;\n\t\tfor (var i = 2L; i <= n; i++) if (!p[i])\n\t\t\t{\n\t\t\t\tfor (var j = i; j <= n; j += i) { f[j] *= -1; p[j] = true; }\n\t\t\t\tfor (var j = i * i; j <= n; j += i * i) f[j] = 0;\n\t\t\t}\n\t\treturn f;\n\t}\n\t// get moebius function of d s.t. d|n\n\t// if dict.ContainsKey(d), dict[d]!=0, otherwise moebius function of d is 0\n\t// O(sqrt(n))\n\tpublic static Dictionary<long, int> MoebiusFunctionOfDivisors(long n)\n\t{\n\t\tvar ps = new List<long>();\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tps.Add(i);\n\t\t\t\tdo n /= i; while (n % i == 0);\n\t\t\t}\n\t\tif (n != 1) ps.Add(n);\n\t\tvar dict = new Dictionary<long, int>();\n\t\tvar m = ps.Count;\n\t\tfor (var i = 0; i < (1 << m); i++)\n\t\t{\n\t\t\tvar mu = 1;\n\t\t\tvar k = 1L;\n\t\t\tfor (var j = 0; j < m; j++) if ((i & (1 << j)) != 0) { mu *= -1; k *= ps[j]; }\n\t\t\tdict.Add(k, mu);\n\t\t}\n\t\treturn dict;\n\t}\n\t// O(sqrt(n))\n\tpublic static int MoebiusFunction(long n)\n\t{\n\t\tvar mu = 1;\n\t\tfor (var i = 2L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tmu *= -1;\n\t\t\t\tif ((n /= i) % i == 0) return 0;\n\t\t\t}\n\t\treturn n == 1 ? mu : -mu;\n\t}\n\t// O(sqrt(n))\n\tpublic static long CarmichaelFunction(long n)\n\t{\n\t\tvar lambda = 1L;\n\t\tvar c = 0;\n\t\twhile (n % 2 == 0) { n /= 2; c++; }\n\t\tif (c == 2) lambda = 2; else if (c > 2) lambda = 1 << (c - 2);\n\t\tfor (var i = 3L; i * i <= n; i++)\n\t\t\tif (n % i == 0)\n\t\t\t{\n\t\t\t\tvar tmp = i - 1;\n\t\t\t\tn /= i;\n\t\t\t\twhile (n % i == 0) { n /= i; tmp *= i; }\n\t\t\t\tlambda = LCM(lambda, tmp);\n\t\t\t}\n\t\tif (n != 1) lambda = LCM(lambda, n - 1);\n\t\treturn lambda;\n\t}\n\t// a+bi is Gaussian prime or not\n\tpublic static bool IsGaussianPrime(ulong a, ulong b)\n\t{\n\t\tif (a == 0) return b % 4 == 3 && IsPrime(b);\n\t\telse if (b == 0) return a % 4 == 3 && IsPrime(a);\n\t\telse return IsPrime(a * a + b * b);\n\t}\n\t// nearly O(200)\n\tpublic static bool IsPrime(ulong n)\n\t{\n\t\tif (n <= 1 || (n > 2 && n % 2 == 0)) return false;\n\t\tvar test = new uint[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 111 };\n\t\tvar d = n - 1;\n\t\tint s = 0;\n\t\twhile (d % 2 == 0) { ++s; d /= 2; }\n\t\tPredicate<ulong> f = t =>\n\t\t{\n\t\t\tvar x = Pow(t, d, n);\n\t\t\tif (x == 1) return true;\n\t\t\tfor (var r = 0L; r < s; r++)\n\t\t\t{\n\t\t\t\tif (x == n - 1) return true;\n\t\t\t\tx = (x * x) % n;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tfor (var i = 0; test[i] < n && test[i] != 111; i++) if (!f(test[i])) return false;\n\t\treturn true;\n\t}\n\tpublic static decimal MeasureTime(Action action)\n\t{\n\t\tvar sw = new System.Diagnostics.Stopwatch();\n\t\tsw.Restart();\n\t\taction();\n\t\tsw.Stop();\n\t\treturn sw.ElapsedTicks * 1000m / System.Diagnostics.Stopwatch.Frequency;\n\t}\n\tstatic readonly double GoldenRatio = 2 / (3 + Math.Sqrt(5));\n\t// assume f is 凹\n\t// find c s.t. a<=c<=b and for all a<=x<=b, f(c)<=f(x)\n\tpublic static double GoldenSectionSearch(double a, double b, Func<double, double> f)\n\t{\n\t\tdouble c = a + GoldenRatio * (b - a), d = b - GoldenRatio * (b - a);\n\t\tdouble fc = f(c), fd = f(d);\n\t\twhile (d - c > 1e-9)\n\t\t{\n\t\t\tif (fc > fd)\n\t\t\t{\n\t\t\t\ta = c; c = d; d = b - GoldenRatio * (b - a);\n\t\t\t\tfc = fd; fd = f(d);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb = d; d = c; c = a + GoldenRatio * (b - a);\n\t\t\t\tfd = fc; fc = f(c);\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\t// O(NW)\n\tpublic static int KnapsackW(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar dp = new int[W + 1];\n\t\tfor (var i = 0; i < N; i++) for (var j = W; j >= w[i]; j--)\n\t\t\t\tdp[j] = Math.Max(dp[j], v[i] + dp[j - w[i]]);\n\t\treturn dp[W];\n\t}\n\t// O(NV)\n\tpublic static int KnapsackV(int[] w, int[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar V = v.Sum();\n\t\tvar dp = new int[V + 1];\n\t\tfor (var i = 1; i <= V; i++) dp[i] = Inf;\n\t\tfor (var i = 0; i < N; i++) for (var j = V; j >= v[i]; j--)\n\t\t\t\tdp[j] = Math.Min(dp[j], w[i] + dp[j - v[i]]);\n\t\tfor (var j = V; j >= 0; j--) if (dp[j] <= W) return j;\n\t\treturn 0;\n\t}\n\t// O(N*2^(N/2))\n\tpublic static long KnapsackN(long[] w, long[] v, int W)\n\t{\n\t\tvar N = w.Length;\n\t\tvar half = N / 2;\n\t\tvar items = new Tuple<long, long>[N];\n\t\tfor (var i = 0; i < N; i++) items[i] = new Tuple<long, long>(w[i], v[i]);\n\t\tArray.Sort(items, (x, y) => x.Item1.CompareTo(y.Item1));\n\t\tFunc<int, int, List<Pair<long, long>>> gen = (start, end) =>\n\t\t{\n\t\t\tif (start >= end) return new List<Pair<long, long>>();\n\t\t\tvar lim = 1 << (end - start);\n\t\t\tvar list = new List<Pair<long, long>>();\n\t\t\tfor (var i = 0; i < lim; i++)\n\t\t\t{\n\t\t\t\tvar weight = 0L;\n\t\t\t\tvar value = 0L;\n\t\t\t\tvar tmp = i;\n\t\t\t\tfor (var j = start; j < end; j++)\n\t\t\t\t{\n\t\t\t\t\tif ((tmp & 1) == 1) { weight += items[j].Item1; value += items[j].Item2; }\n\t\t\t\t\ttmp >>= 1;\n\t\t\t\t}\n\t\t\t\tif (weight <= W) list.Add(new Pair<long, long>(weight, value));\n\t\t\t}\n\t\t\tlist.Sort((x, y) => { var c = x.First.CompareTo(y.First); return c == 0 ? x.Second.CompareTo(y.Second) : c; });\n\t\t\tvar n = list.Count;\n\t\t\tif (n == 0) return list;\n\t\t\tfor (var i = list.Count - 2; i >= 0; i--) if (list[i].First == list[i + 1].First) list[i].Second = Math.Max(list[i].Second, list[i + 1].Second);\n\t\t\tvar small = new List<Pair<long, long>>();\n\t\t\tvar last = -1;\n\t\t\twhile (last + 1 < n)\n\t\t\t{\n\t\t\t\tvar tmp = list[last + 1].First;\n\t\t\t\tlast = Func.FirstBinary(last + 1, n, x => list[x].First > tmp) - 1;\n\t\t\t\tif (small.Count == 0 || list[last].Second > small[small.Count - 1].Second) small.Add(list[last]);\n\t\t\t}\n\t\t\treturn small;\n\t\t};\n\t\tvar first = gen(0, half);\n\t\tvar second = gen(half, N);\n\t\tvar max = 0L;\n\t\tvar last2 = second.Count;\n\t\tforeach (var item in first)\n\t\t{\n\t\t\tlast2 = Func.FirstBinary(0, last2, x => second[x].First > W - item.First) - 1;\n\t\t\tif (last2 < 0) break;\n\t\t\tif (second[last2].First <= W - item.First) Func.SetToMax(ref max, item.Second + second[last2].Second);\n\t\t\tlast2++;\n\t\t}\n\t\treturn max;\n\t}\n\t// nums[i] が counts[i] 個\n\t// K is partial sum?\n\t// O(NK)\n\tpublic static bool PartialSum(int[] nums, int[] counts, int K)\n\t{\n\t\tvar N = nums.Length;\n\t\tvar memo = new int[K + 1];\n\t\tfor (var s = 1; s <= K; s++) memo[s] = -1;\n\t\tfor (var n = 0; n < N; n++) for (var s = 0; s <= K; s++) memo[s] = memo[s] >= 0 ? counts[n] : s < nums[n] ? -1 : memo[s - nums[n]] - 1;\n\t\treturn memo[K] >= 0;\n\t}\n\t// O(N log(N))\n\tpublic static int LongestIncreasingSubsequence(int[] a)\n\t{\n\t\tvar N = a.Length;\n\t\tvar memo = new int[N];\n\t\tfor (var n = 0; n < N; n++) memo[n] = Inf;\n\t\tfor (var n = 0; n < N; n++)\n\t\t{\n\t\t\tvar k = Func.FirstBinary(0, N, x => a[n] <= memo[x]);\n\t\t\tmemo[k] = a[n];\n\t\t}\n\t\treturn Func.FirstBinary(0, N, x => memo[x] == Inf);\n\t}\n\t// O(nm)\n\tpublic static int LongestCommonSubsequence(string s, string t)\n\t{\n\t\tvar n = s.Length;\n\t\tvar m = t.Length;\n\t\tvar memo = new int[n + 1, m + 1];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tfor (int j = m - 1; j >= 0; j--)\n\t\t\t\tif (s[i] == t[j]) memo[i, j] = memo[i + 1, j + 1] + 1;\n\t\t\t\telse memo[i, j] = Math.Max(memo[i + 1, j], memo[i, j + 1]);\n\t\treturn memo[0, 0];\n\t}\n\t// the number of ways of dividing N to M numbers\n\t// O(NM)\n\tpublic static int Partition(int N, int M, int Mod)\n\t{\n\t\tvar memo = new long[N + 1, M + 1];\n\t\tfor (var m = 0; m <= M; m++) memo[0, m] = 1;\n\t\tfor (var n = 1; n <= N; n++)\n\t\t{\n\t\t\tmemo[n, 0] = 0;\n\t\t\tfor (var m = 1; m <= M; m++) memo[n, m] = (memo[n, m - 1] + (n - m >= 0 ? memo[n - m, m] : 0)) % Mod;\n\t\t}\n\t\treturn (int)memo[N, M];\n\t}\n\t// max{f(a)+...+f(b-1) | from<=a<b<=to}\n\t// O(to-from)\n\tpublic static long MaxIntervalSum(int from, int to, Func<long, long> f)\n\t{\n\t\tlong max, dp;\n\t\tmax = dp = f(from);\n\t\tfor (var i = from + 1; i < to; i++)\n\t\t{\n\t\t\tvar tmp = f(i);\n\t\t\tdp = tmp + Math.Max(0, dp);\n\t\t\tmax = Math.Max(max, dp);\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source, Comparison<T> comp)\n\t{\n\t\tvar p = source.GetEnumerator();\n\t\tif (!p.MoveNext()) return -1;\n\t\tvar max = p.Current;\n\t\tvar mi = 0;\n\t\tvar i = 0;\n\t\twhile (p.MoveNext())\n\t\t{\n\t\t\ti++;\n\t\t\tif (comp(max, p.Current) < 0) { max = p.Current; mi = i; }\n\t\t}\n\t\treturn mi;\n\t}\n\tpublic static int MaxElement<T>(this IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => x.CompareTo(y));\n\tpublic static int MinElement<T>(IEnumerable<T> source, Comparison<T> comp) => source.MaxElement((x, y) => comp(y, x));\n\tpublic static int MinElement<T>(IEnumerable<T> source) where T : IComparable<T> => source.MaxElement((x, y) => y.CompareTo(x));\n\tpublic static void Shuffle<T>(IList<T> source, Random rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static void Shuffle<T>(IList<T> source, RandomSFMT rand) { for (var i = source.Count - 1; i >= 0; --i) source.Swap(i, rand.Next(0, i + 1)); }\n\tpublic static char NextChar(this Random rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static char NextChar(this RandomSFMT rand) => (char)(rand.Next(0, 'z' - 'a' + 1) + 'a');\n\tpublic static string NextString(this Random rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static string NextString(this RandomSFMT rand, int length) => new string(Enumerable.Range(0, length).Select(_ => rand.NextChar()).ToArray());\n\tpublic static IEnumerable<T> Rotate<T>(this IEnumerable<T> source)\n\t{\n\t\tvar e = source.GetEnumerator();\n\t\tif (e.MoveNext())\n\t\t{\n\t\t\tvar f = e.Current;\n\t\t\twhile (e.MoveNext()) yield return e.Current;\n\t\t\tyield return f;\n\t\t}\n\t}\n\tpublic static T Apply<T>(this Func<T, T> func, T x, int n)\n\t{\n\t\tvar a = x;\n\t\tfor (var i = 0; i < n; i++) a = func(a);\n\t\treturn a;\n\t}\n\tpublic static void MemberSet<T>(this T[] array, T value)\n\t{\n\t\tvar X = array.Length;\n\t\tfor (var x = 0; x < X; x++) array[x] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) array[x, y] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) array[x, y, z] = value;\n\t}\n\tpublic static void MemberSet<T>(this T[,,,] array, T value)\n\t{\n\t\tvar X = array.GetLength(0); var Y = array.GetLength(1); var Z = array.GetLength(2); var W = array.GetLength(3);\n\t\tfor (var x = 0; x < X; x++) for (var y = 0; y < Y; y++) for (var z = 0; z < Z; z++) for (var w = 0; w < W; w++) array[x, y, z, w] = value;\n\t}\n\tpublic static string ToYesNo(this bool flag) => flag ? \"YES\" : \"NO\";\n\tpublic static int SetToMin(ref int min, int other) => min = Math.Min(min, other);\n\tpublic static int SetToMax(ref int max, int other) => max = Math.Max(max, other);\n\tpublic static long SetToMin(ref long min, long other) => min = Math.Min(min, other);\n\tpublic static long SetToMax(ref long max, long other) => max = Math.Max(max, other);\n\tpublic static Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>> Compress(IEnumerable<int> coord, int width, int X)\n\t{\n\t\tvar tmp = new SortedSet<int>();\n\t\tforeach (var x in coord)\n\t\t{\n\t\t\tfor (var w = -width; w <= width; w++)\n\t\t\t\tif (x + w < 0 || x + w >= X) continue;\n\t\t\t\telse if (tmp.Contains(x + w)) continue;\n\t\t\t\telse tmp.Add(x + w);\n\t\t}\n\t\tvar index = 0;\n\t\tvar inverse = new SortedDictionary<int, int>();\n\t\tvar dict = new SortedDictionary<int, int>();\n\t\tforeach (var pair in tmp)\n\t\t{\n\t\t\tdict.Add(pair, index);\n\t\t\tinverse.Add(index++, pair);\n\t\t}\n\t\treturn new Tuple<SortedDictionary<int, int>, SortedDictionary<int, int>>(dict, inverse);\n\t}\n\tpublic static int MSB(uint n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(uint n)\n\t{\n\t\tn = (n & 0x55555555) + ((n >> 1) & 0x55555555);\n\t\tn = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n\t\tn = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);\n\t\tn = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);\n\t\treturn (int)((n & 0x0000ffff) + ((n >> 16) & 0x0000ffff));\n\t}\n\tpublic static int LSB(uint n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\treturn 32 - BitCount(n);\n\t}\n\tpublic static int MSB(ulong n)\n\t{\n\t\tn |= (n >> 1);\n\t\tn |= (n >> 2);\n\t\tn |= (n >> 4);\n\t\tn |= (n >> 8);\n\t\tn |= (n >> 16);\n\t\tn |= (n >> 32);\n\t\treturn BitCount(n) - 1;\n\t}\n\tpublic static int BitCount(ulong n)\n\t{\n\t\tn = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\t\tn = (n & 0x3333333333333333) + ((n >> 2) & 0x3333333333333333);\n\t\tn = (n & 0x0f0f0f0f0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f0f0f0f0f);\n\t\tn = (n & 0x00ff00ff00ff00ff) + ((n >> 8) & 0x00ff00ff00ff00ff);\n\t\tn = (n & 0x0000ffff0000ffff) + ((n >> 16) & 0x0000ffff0000ffff);\n\t\treturn (int)((n & 0x00000000ffffffff) + ((n >> 32) & 0x00000000ffffffff));\n\t}\n\tpublic static int LSB(ulong n)\n\t{\n\t\tn |= (n << 1);\n\t\tn |= (n << 2);\n\t\tn |= (n << 4);\n\t\tn |= (n << 8);\n\t\tn |= (n << 16);\n\t\tn |= (n << 32);\n\t\treturn 64 - BitCount(n);\n\t}\n\tpublic static int Abs(this int n) => Math.Abs(n);\n\tpublic static long Abs(this long n) => Math.Abs(n);\n\tpublic static double Abs(this double n) => Math.Abs(n);\n\tpublic static float Abs(this float n) => Math.Abs(n);\n\tpublic static decimal Abs(this decimal n) => Math.Abs(n);\n\tpublic static short Abs(this short n) => Math.Abs(n);\n\tpublic static sbyte Abs(this sbyte n) => Math.Abs(n);\n\tpublic static int Min(params int[] nums) { var min = int.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static long Min(params long[] nums) { var min = long.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static uint Min(params uint[] nums) { var min = uint.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static ulong Min(params ulong[] nums) { var min = ulong.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static double Min(params double[] nums) { var min = double.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static decimal Min(params decimal[] nums) { var min = decimal.MaxValue; foreach (var n in nums) min = Math.Min(min, n); return min; }\n\tpublic static int Max(params int[] nums) { var min = int.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static long Max(params long[] nums) { var min = long.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static uint Max(params uint[] nums) { var min = uint.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static ulong Max(params ulong[] nums) { var min = ulong.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static double Max(params double[] nums) { var min = double.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static decimal Max(params decimal[] nums) { var min = decimal.MinValue; foreach (var n in nums) min = Math.Max(min, n); return min; }\n\tpublic static void MultiKeySort(this string[] list) => new MultiSorter(list).QuickSort();\n\tclass MultiSorter\n\t{\n\t\tconst int MIN = 0;\n\t\tstring[] a;\n\t\tint max;\n\t\tpublic MultiSorter(string[] l) { a = l; max = a.Max(s => s.Length); }\n\t\tpublic void QuickSort() { if (a.Length <= 1) return; QuickSort(0, a.Length, 0); }\n\t\tpublic int At(int i, int z) => z < a[i].Length ? a[i][z] : MIN;\n\t\tpublic int At(string s, int z) => z < s.Length ? s[z] : MIN;\n\t\tpublic void QuickSort(int l, int r, int z)\n\t\t{\n\t\t\tint w = r - l, pl = l, pm = l + w / 2, pn = r - 1, c;\n\t\t\tif (w > 30)\n\t\t\t{\n\t\t\t\tvar d = w / 8;\n\t\t\t\tpl = Median(pl, pl + d, pl + 2 * d, z);\n\t\t\t\tpm = Median(pm - d, pm, pm + d, z);\n\t\t\t\tpn = Median(pn - 2 * d, pn - d, pn, z);\n\t\t\t}\n\t\t\tpm = Median(pl, pm, pn, z);\n\t\t\tvar s = a[pm]; a[pm] = a[l]; a[l] = s;\n\t\t\tvar pivot = At(l, z);\n\t\t\tint i = l + 1, x = l + 1, j = r - 1, y = r - 1;\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\twhile (i <= j && (c = At(i, z) - pivot) <= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (i != x) { s = a[i]; a[i] = a[x]; a[x] = s; } x++; }\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\twhile (i <= j && (c = At(j, z) - pivot) >= 0)\n\t\t\t\t{\n\t\t\t\t\tif (c == 0) { if (j != y) { s = a[j]; a[j] = a[y]; a[y] = s; } y--; }\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\tif (i > j) break;\n\t\t\t\ts = a[i]; a[i] = a[j]; a[j] = s;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t\tj++; y++;\n\t\t\tvar m = Min(x - l, i - x); SwapRegion(l, i - m, m);\n\t\t\tm = Min(y - j, r - y); SwapRegion(i, r - m, m);\n\t\t\ti += l - x;\n\t\t\tj += r - y;\n\t\t\tif (i - l >= 10) QuickSort(l, i, z); else InsertSort(l, i, z);\n\t\t\tif (pivot != MIN) if (j - i >= 10) QuickSort(i, j, z + 1); else InsertSort(i, j, z + 1);\n\t\t\tif (r - j >= 10) QuickSort(j, r, z); else InsertSort(j, r, z);\n\t\t}\n\t\tprivate void SwapRegion(int p, int q, int n)\n\t\t{\n\t\t\tstring s;\n\t\t\twhile (n-- > 0) { s = a[p]; a[p++] = a[q]; a[q++] = s; }\n\t\t}\n\t\tprivate void InsertSort(int l, int r, int z)\n\t\t{\n\t\t\tstring s;\n\t\t\tfor (int i = l + 1; i < r; i++)\n\t\t\t{\n\t\t\t\tvar tmp = a[i];\n\t\t\t\tint x = z, y = z, p, q;\n\t\t\t\ts = a[i - 1];\n\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tint j = i;\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j] = a[j - 1];\n\t\t\t\t\t\t--j;\n\t\t\t\t\t\tif (j <= l) break;\n\t\t\t\t\t\tx = y = z;\n\t\t\t\t\t\ts = a[j - 1];\n\t\t\t\t\t\twhile ((p = At(tmp, x++)) == (q = At(s, y++)) && p != MIN) ;\n\t\t\t\t\t\tif (q <= p) break;\n\t\t\t\t\t}\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate int Median(int a, int b, int c, int z)\n\t\t{\n\t\t\tint p = At(a, z), q = At(b, z);\n\t\t\tif (p == q) return a;\n\t\t\tvar r = At(c, z);\n\t\t\tif (r == p || r == q) return c;\n\t\t\treturn p < q ?\n\t\t\t\t\t(q < r ? b : (p < r ? c : a))\n\t\t\t\t\t: (q > r ? b : (p < r ? a : c));\n\t\t}\n\t}\n}\nclass RandomSFMT : Random\n{\n\tint index, coin_bits, byte_pos, range, shift;\n\tuint coin_save, byte_save, bse;\n\tprotected uint[] x = new uint[40];\n\tstatic uint[] ParityData = { 0x00000001U, 0x00000000U, 0x00000000U, 0x20000000U };\n\tpublic virtual void gen_rand_all()\n\t{\n\t\tint a = 0, b = 28, c = 32, d = 36; uint y; uint[] p = x;\n\t\tdo\n\t\t{\n\t\t\ty = p[a + 3] ^ (p[a + 3] << 24) ^ (p[a + 2] >> 8) ^ ((p[b + 3] >> 5) & 0xb5ffff7fU);\n\t\t\tp[a + 3] = y ^ (p[c + 3] >> 8) ^ (p[d + 3] << 14);\n\t\t\ty = p[a + 2] ^ (p[a + 2] << 24) ^ (p[a + 1] >> 8) ^ ((p[b + 2] >> 5) & 0xaff3ef3fU);\n\t\t\tp[a + 2] = y ^ ((p[c + 2] >> 8) | (p[c + 3] << 24)) ^ (p[d + 2] << 14);\n\t\t\ty = p[a + 1] ^ (p[a + 1] << 24) ^ (p[a] >> 8) ^ ((p[b + 1] >> 5) & 0x7fefcfffU);\n\t\t\tp[a + 1] = y ^ ((p[c + 1] >> 8) | (p[c + 2] << 24)) ^ (p[d + 1] << 14);\n\t\t\ty = p[a] ^ (p[a] << 24) ^ ((p[b] >> 5) & 0xf7fefffdU);\n\t\t\tp[a] = y ^ ((p[c] >> 8) | (p[c + 1] << 24)) ^ (p[d] << 14);\n\t\t\tc = d; d = a; a += 4; b += 4;\n\t\t\tif (b == 40) b = 0;\n\t\t} while (a != 40);\n\t}\n\tvoid period_certification()\n\t{\n\t\tuint work, inner = 0; int i, j;\n\t\tindex = 40; range = 0; coin_bits = 0; byte_pos = 0;\n\t\tfor (i = 0; i < 4; i++) inner ^= x[i] & ParityData[i];\n\t\tfor (i = 16; i > 0; i >>= 1) inner ^= inner >> i;\n\t\tinner &= 1;\n\t\tif (inner == 1) return;\n\t\tfor (i = 0; i < 4; i++) for (j = 0, work = 1; j < 32; j++, work <<= 1) if ((work & ParityData[i]) != 0) { x[i] ^= work; return; }\n\t}\n\tpublic void InitMt(uint s)\n\t{\n\t\tunchecked\n\t\t{\n\t\t\tx[0] = s;\n\t\t\tfor (uint p = 1; p < 40; p++) x[p] = s = 1812433253 * (s ^ (s >> 30)) + p;\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint s) { InitMt(s); }\n\tpublic void InitMtEx(uint[] init_key)\n\t{\n\t\tuint r, i, j, c, key_len = (uint)init_key.Length;\n\t\tunchecked\n\t\t{\n\t\t\tfor (i = 0; i < 40; i++) x[i] = 0x8b8b8b8b;\n\t\t\tif (key_len + 1 > 40) c = key_len + 1; else c = 40;\n\t\t\tr = x[0] ^ x[17] ^ x[39]; r = (r ^ (r >> 27)) * 1664525;\n\t\t\tx[17] += r; r += key_len; x[22] += r; x[0] = r; c--;\n\t\t\tfor (i = 1, j = 0; j < c && j < key_len; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r;\n\t\t\t\tr += init_key[j] + i; x[(i + 22) % 40] += r;\n\t\t\t\tx[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (; j < c; j++)\n\t\t\t{\n\t\t\t\tr = x[i] ^ x[(i + 17) % 40] ^ x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1664525; x[(i + 17) % 40] += r; r += i;\n\t\t\t\tx[(i + 22) % 40] += r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tfor (j = 0; j < 40; j++)\n\t\t\t{\n\t\t\t\tr = x[i] + x[(i + 17) % 40] + x[(i + 39) % 40];\n\t\t\t\tr = (r ^ (r >> 27)) * 1566083941; x[(i + 17) % 40] ^= r;\n\t\t\t\tr -= i; x[(i + 22) % 40] ^= r; x[i] = r; i = (i + 1) % 40;\n\t\t\t}\n\t\t\tperiod_certification();\n\t\t}\n\t}\n\tpublic RandomSFMT(uint[] init_key) { InitMtEx(init_key); }\n\tpublic RandomSFMT() : this((uint)(DateTime.Now.Ticks & 0xffffffff)) { }\n\tpublic uint NextMt() { if (index == 40) { gen_rand_all(); index = 0; } return x[index++]; }\n\tpublic int NextInt(int n) => (int)(n * (1.0 / 4294967296.0) * NextMt());\n\tpublic double NextUnif() { uint z = NextMt() >> 11, y = NextMt(); return (y * 2097152.0 + z) * (1.0 / 9007199254740992.0); }\n\tpublic int NextBit() { if (--coin_bits == -1) { coin_bits = 31; return (int)(coin_save = NextMt()) & 1; } else return (int)(coin_save >>= 1) & 1; }\n\tpublic int NextByte() { if (--byte_pos == -1) { byte_pos = 3; return (int)(byte_save = NextMt()) & 255; } else return (int)(byte_save >>= 8) & 255; }\n\tpublic override int Next(int maxValue) => Next(0, maxValue);\n\tprotected override double Sample() => NextUnif();\n\tpublic override double NextDouble() => NextUnif();\n\tpublic override int Next() => 1 + NextIntEx(int.MaxValue);\n\tpublic override void NextBytes(byte[] buffer) { for (var i = 0; i < buffer.Length; i++) buffer[i] = (byte)NextByte(); }\n\tpublic override int Next(int min, int max) => min + NextIntEx(max - min);\n\tpublic int NextIntEx(int range_)\n\t{\n\t\tuint y_, base_, remain_; int shift_;\n\t\tif (range_ <= 0) return 0;\n\t\tif (range_ != range)\n\t\t{\n\t\t\tbse = (uint)(range = range_);\n\t\t\tfor (shift = 0; bse <= (1UL << 30); shift++) bse <<= 1;\n\t\t}\n\t\twhile (true)\n\t\t{\n\t\t\ty_ = NextMt() >> 1;\n\t\t\tif (y_ < bse) return (int)(y_ >> shift);\n\t\t\tbase_ = bse; shift_ = shift; y_ -= base_;\n\t\t\tremain_ = (1U << 31) - base_;\n\t\t\tfor (; remain_ >= (uint)range_; remain_ -= base_)\n\t\t\t{\n\t\t\t\tfor (; base_ > remain_; base_ >>= 1) shift_--;\n\t\t\t\tif (y_ < base_) return (int)(y_ >> shift_);\n\t\t\t\telse y_ -= base_;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<int>[] E = new List<int>[N];\n\t\tfor(int i=0;i<N;i++) E[i] = new List<int>();\n\t\t\n\t\tPair[] P = new Pair[M];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tP[i] = new Pair(i, C[i]);\n\t\t}\n\t\t\n\t\tArray.Sort(P, (p, q) => p.Cost.CompareTo(q.Cost));\n\t\t\n\t\tvar UF = new UnionFind(N);\n\t\tlong totalCost = 0;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = A[P[i].Idx];\n\t\t\tint b = B[P[i].Idx];\n\t\t\tif(UF.IsUnited(a, b)) continue;\n\t\t\tUF.Unite(a, b);\n\t\t\tE[a].Add(P[i].Idx);\n\t\t\tE[b].Add(P[i].Idx);\n\t\t\ttotalCost += C[P[i].Idx];\n\t\t}\n\t\t\n\t\tlong[][] maxBottle = new long[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tmaxBottle[i] = new long[N];\n\t\t\tfor(int j=0;j<N;j++) maxBottle[i][j] = -1;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tvar q = new Queue<int>();\n\t\t\tq.Enqueue(i);\n\t\t\tmaxBottle[i][i] = 0;\n\t\t\twhile(q.Count > 0){\n\t\t\t\tvar now = q.Dequeue();\n\t\t\t\tforeach(var nidx in E[now]){\n\t\t\t\t\tint nxt = A[nidx] == now ? B[nidx] : A[nidx];\n\t\t\t\t\tlong cost = C[nidx];\n\t\t\t\t\tif(maxBottle[i][nxt] != -1) continue;\n\t\t\t\t\tmaxBottle[i][nxt] = Math.Max(maxBottle[i][now], cost);\n\t\t\t\t\tq.Enqueue(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar sb = new StringBuilder();\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tsb.AppendLine((totalCost - maxBottle[S[i]][T[i]]).ToString());\n\t\t}\n\t\tConsole.Write(sb.ToString());\n\t\t\n\t}\n\tint N,M;\n\tint[] A,B;\n\tlong[] C;\n\t\n\tint Q;\n\tint[] S,T;\n\tpublic Sol(){\n\t\t\n\t\tvar d = ria();\n\t\tN = d[0]; M = d[1];\n\t\tA = new int[M];\n\t\tB = new int[M];\n\t\tC = new long[M];\n\t\tfor(int i=0;i<M;i++){\n\t\t\td = ria();\n\t\t\tA[i] = d[0] - 1;\n\t\t\tB[i] = d[1] - 1;\n\t\t\tC[i] = d[2];\n\t\t}\n\t\t\n\t\tQ = ri();\n\t\t\n\t\tS = new int[Q];\n\t\tT = new int[Q];\n\t\tfor(int i=0;i<Q;i++){\n\t\t\td = ria();\n\t\t\tS[i] = d[0] - 1;\n\t\t\tT[i] = d[1] - 1;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n\nclass Pair{\n\tpublic int Idx;\n\tpublic long Cost;\n\tpublic Pair (int idx, long cost){\n\t\tIdx = idx; Cost = cost;\n\t}\n}\nclass UnionFind{\n\t\n\tint[] parent;\n\tint[] mem;\n\tint compo;\n\tint N;\n\tpublic UnionFind(int n_){\n\t\tInitialize(n_);\n\t}\n\t\n\tpublic void Initialize(int n_){\n\t\tN=n_;\n\t\tparent=new int[N];\n\t\tmem=new int[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tparent[i]=i;\n\t\t\tmem[i]=1;\n\t\t}\n\t\tcompo=N;\n\t}\n\t\n\tpublic int Parent(int a){\n\t\tif(parent[a]==a)return a;\n\t\treturn parent[a]=Parent(parent[a]);\n\t}\n\t\n\tpublic bool IsUnited(int a,int b){\n\t\treturn Parent(a) == Parent(b);\n\t}\n\t\n\tpublic void Unite(int a,int b){\n\t\ta=Parent(a);b=Parent(b);\n\t\tif(a==b)return;\n\t\tparent[a]=b;\n\t\tmem[b]+=mem[a];\n\t\tcompo-=1;\n\t}\n\t\n\tpublic bool IsRoot(int x){\n\t\treturn x==parent[x];\n\t}\n\tpublic int MemCnt(int x){\n\t\treturn mem[Parent(x)];\n\t}\n\t\n\tpublic void Dump(){\n\t\tfor(int i=0;i<parent.Length;i++){\n\t\t\tConsole.Write(i==0?\"{0}\":\" {0}\",parent[i]);\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n\t\n\tpublic int Compo{\n\t\tget{\n\t\t\treturn compo;\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\n\nstatic string[] input = Console.ReadLine().Split(' ');\nstatic long n = long.Parse(input[0]);//グラフの頂点数\nstatic long m = long.Parse(input[1]);\nstatic long[] parents = new long[n];//親\n  \n\tstatic void Main()\n\t{\n    long[,] maxDistance = new long[n,n];\n  \n    for(long i = 1; i < n; i++)\n    {\n      parents[i] = i;//unionFindの初期化\n    }\n\n    long[,] edges = new long[n,3];\n    for(int i = 0; i < m; i++)//全ての辺\n    {\n      long[] edgesGet = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);\n      edges[i,0] = edgesGet[0]-1;\n      edges[i,1] = edgesGet[1]-1;\n      edges[i,2] = edgesGet[2];\n    }\n    long[,] edgesSub = MinimumAllTree(edges);//最小全域木の作成\n    long[,] maxLengths = new long[n,n];\n    for(int i = 0; i < n; i++)\n    {\n      TreeProblem(edgesSub);\n    }\n    \n    \n\t}\n\n  static long[] TreeProblem(long[,] edges, int startNum)\n  {//木の全ての辺を辿る問題でO(頂点数)、根は0-indexでstartNum\n  //辺は無向で[始点、終点、長さ]\n    int vertexCount = edges.GetLength(0)+1;//頂点の個数\n    List<int>[] nextList = new List<int>[vertexCount];//隣接リスト（リストの入った配列）\n    List<long>[] nextListLength = new List<long>[vertexCount];\n    for(int i = 0; i < vertexCount; i++)\n    {\n      nextList[i] = new List<long>();//リストの宣言\n      nextListLength[i] = new List<long>();\n    }\n    for(int i = 0; i < vertexCount-1; i++)\n    {\n      nextList[edges[i,0]].Add(edges[i,1]);\n      nextListLength[edges[i,0]].Add(edges[i,2]);\n      nextList[edges[i,1]].Add(edges[i,0]);\n      nextListLength[edges[i,1]].Add(edges[i,2]);\n    }\n\n    //ここから問題による操作\n    long[] answers = new long[vertexCount];\n    int[] mothers = new int[vertexCount];\n    \n  }\n\n  static long[] TreeProblemRepeat(int vertexNum)\n  {\n    \n  }\n\n  static long[,] MinimumAllTree(long[,] edgesSub)\n  {//unionfindでまだ繋がっていない全ての頂点を繋ぎ辺の和が最小の最小全域木で新たに繋いだ辺を返す。\n  //辺数をeとして、辺の長さ順にソートするのでO(eloge)。\n  //辺は0-indexの無向で[始点、終点、長さ]\n    List<long> listStart = new List<long>();\n    List<long> listGoal = new List<long>();\n    List<long> listLength = new List<long>();\n    int e = edges.GetLength(0);\n    long[][] edges = new long[e][];\n    for(int i = 0; i < e; i++)\n    {\n      edges[i] = new long[3];\n      for(int j = 0; j < 3; j++) edges[i][j] = edgesSub[i,j];\n    }\n    Array.Sort(vertexes, (a, b) => a[2].CompareTo(b[2]));//辺の長さでソート\n\n    for(int i = 0; i < e; i++)\n    {\n      if(whatParent(edges[i][0]) != whatParent(edges[i][1]))\n      {\n        listStart.Add(edges[i][0]);\n        listGoal.Add(edges[i][1]);\n        listLength.Add(edges[i][2]);\n        parents[whatParent(edges[i][0])] = whatParent(edges[i][0]);//親を結合して統一。親が2人できることはない。\n      }\n    }\n    \n    int answerCount = listStart.Count();\n    long[,] answer = new long[answerCount];\n    for(int i = 0; i < answerCount; i++)\n    {\n      answer[i,0] = listStart[i];\n      answer[i,1] = listGoal[i];\n      answer[i,2] = listLength[i];\n    }\n\n    return answer;\n  }\n\n  static long whatParent(long child)\n  {\n    if(parents[child] == child) return child;\n    else return parents[child] = whatParent(parents[child]);\n  }\n  \n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Threading.Tasks;\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tList<int>[] E = new List<int>[N];\n\t\tfor(int i=0;i<N;i++) E[i] = new List<int>();\n\t\t\n\t\tPair[] P = new Pair[M];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tP[i] = new Pair(i, C[i]);\n\t\t}\n\t\t\n\t\tArray.Sort(P, (p, q) => p.Cost.CompareTo(q.Cost));\n\t\t\n\t\tvar UF = new UnionFind(N);\n\t\tlong totalCost = 0;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint a = A[P[i].Idx];\n\t\t\tint b = B[P[i].Idx];\n\t\t\tif(UF.IsUnited(a, b)) continue;\n\t\t\tUF.Unite(a, b);\n\t\t\tE[a].Add(P[i].Idx);\n\t\t\tE[b].Add(P[i].Idx);\n\t\t\ttotalCost += C[P[i].Idx];\n\t\t}\n\t\t\n\t\tlong[][] maxBottle = new long[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tmaxBottle[i] = new long[N];\n\t\t\tfor(int j=0;j<N;j++) maxBottle[i][j] = -1;\n\t\t}\n\t\t\n\t\tParallel.For(0,N,i => {\n\t\t\tvar q = new Queue<int>();\n\t\t\tq.Enqueue(i);\n\t\t\tmaxBottle[i][i] = 0;\n\t\t\twhile(q.Count > 0){\n\t\t\t\tvar now = q.Dequeue();\n\t\t\t\tforeach(var nidx in E[now]){\n\t\t\t\t\tint nxt = A[nidx] == now ? B[nidx] : A[nidx];\n\t\t\t\t\tlong cost = C[nidx];\n\t\t\t\t\tif(maxBottle[i][nxt] != -1) continue;\n\t\t\t\t\tmaxBottle[i][nxt] = Math.Max(maxBottle[i][now], cost);\n\t\t\t\t\tq.Enqueue(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar sb = new StringBuilder();\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tsb.AppendLine((totalCost - maxBottle[S[i]][T[i]]).ToString());\n\t\t}\n\t\tConsole.Write(sb.ToString());\n\t\t\n\t}\n\tint N,M;\n\tint[] A,B;\n\tlong[] C;\n\t\n\tint Q;\n\tint[] S,T;\n\tpublic Sol(){\n\t\t\n\t\tusing(var r = new FastIn()){\n\t\tN = r.ReadInt(); M = r.ReadInt();\n\t\tA = new int[M];\n\t\tB = new int[M];\n\t\tC = new long[M];\n\t\tfor(int i=0;i<M;i++){\n\t\t\tA[i] = r.ReadInt() - 1;\n\t\t\tB[i] = r.ReadInt() - 1;\n\t\t\tC[i] = r.ReadInt();\n\t\t}\n\t\t\n\t\tQ = r.ReadInt();\n\t\t\n\t\tS = new int[Q];\n\t\tT = new int[Q];\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tS[i] = r.ReadInt() - 1;\n\t\t\tT[i] = r.ReadInt() - 1;\n\t\t}\n\t\t\n\t\t\n\t\t}\n\t\t\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n\nclass Pair{\n\tpublic int Idx;\n\tpublic long Cost;\n\tpublic Pair (int idx, long cost){\n\t\tIdx = idx; Cost = cost;\n\t}\n}\nclass UnionFind{\n\t\n\tint[] parent;\n\tint[] mem;\n\tint compo;\n\tint N;\n\tpublic UnionFind(int n_){\n\t\tInitialize(n_);\n\t}\n\t\n\tpublic void Initialize(int n_){\n\t\tN=n_;\n\t\tparent=new int[N];\n\t\tmem=new int[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tparent[i]=i;\n\t\t\tmem[i]=1;\n\t\t}\n\t\tcompo=N;\n\t}\n\t\n\tpublic int Parent(int a){\n\t\tif(parent[a]==a)return a;\n\t\treturn parent[a]=Parent(parent[a]);\n\t}\n\t\n\tpublic bool IsUnited(int a,int b){\n\t\treturn Parent(a) == Parent(b);\n\t}\n\t\n\tpublic void Unite(int a,int b){\n\t\ta=Parent(a);b=Parent(b);\n\t\tif(a==b)return;\n\t\tparent[a]=b;\n\t\tmem[b]+=mem[a];\n\t\tcompo-=1;\n\t}\n\t\n\tpublic bool IsRoot(int x){\n\t\treturn x==parent[x];\n\t}\n\tpublic int MemCnt(int x){\n\t\treturn mem[Parent(x)];\n\t}\n\t\n\tpublic void Dump(){\n\t\tfor(int i=0;i<parent.Length;i++){\n\t\t\tConsole.Write(i==0?\"{0}\":\" {0}\",parent[i]);\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n\t\n\tpublic int Compo{\n\t\tget{\n\t\t\treturn compo;\n\t\t}\n\t}\n\t\n}\n\n\n\nclass FastIn:IDisposable {\n\tint Size;\n\tbyte[] Mem;\n\tint ptr;\n\tint rsize;\n\tbool unfinished;\n\tStream stdin;\n\tvoid Init(int n) {\n\t\tSize = n;\n\t\tMem = new byte[Size];\n\t\trsize=(stdin=Console.OpenStandardInput()).Read(Mem, 0, Size);\n\t\tptr = 0;\n\t\tunfinished=(rsize == Size);\n\t}\n\tvoid Next() {\n\t\tif (unfinished == false) return;\n\t\trsize=stdin.Read(Mem, 0, Size);\n\t\tptr = 0;\n\t\tunfinished = (rsize == Size);\n\t}\n\t\n\t~FastIn(){\n\t\tstdin.Dispose();\n\t}\n\tvoid IDisposable.Dispose(){\n\t\tstdin.Dispose();\n\t}\n\tpublic void Dispose(){\n\t\tstdin.Dispose();\n\t}\n\t\n\tpublic FastIn() {\n\t\tInit(100000);\n\t}\n\tpublic FastIn(int n) {\n\t\tInit(n);\n\t}\n\tpublic int ReadInt() {\n\t\tint ret = 0;\n\t\tint sig = 1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tif(ret==0 && Mem[ptr] == '-'){\n\t\t\t\tsig *= -1; ptr++; continue;\n\t\t\t}\n\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\twhile (ptr < rsize && (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\tpublic uint ReadUint() {\n\t\tuint ret = 0;\n\t\tuint sig = 1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\twhile (ptr < rsize && (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\tpublic long ReadLong() {\n\t\tlong ret = 0;\n\t\tlong sig = 1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tif(ret==0 && Mem[ptr] == '-'){\n\t\t\t\tsig *= -1; ptr++; continue;\n\t\t\t}\n\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\twhile (ptr < rsize &&  (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r')  ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\t\n\tpublic double ReadDouble() {\n\t\tdouble ret = 0;\n\t\tdouble sig = 1;\n\t\tbool dot = false;\n\t\tdouble keta = 0.1;\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r' ) {\n\t\t\tif(ret==0 && Mem[ptr] == '-'){\n\t\t\t\tsig *= -1; ptr++;\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(Mem[ptr] == '.'){\n\t\t\t\tdot = true;\n\t\t\t\tptr++;\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!dot){\n\t\t\t\tret = ret * 10 + Mem[ptr++] - '0';\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t}else{\n\t\t\t\tret = ret + (Mem[ptr++] - '0')*keta;\n\t\t\t\tketa /= 10.0;\n\t\t\t\tif (ptr == Size) Next();\n\t\t\t}\n\t\t}\n\t\twhile (ptr < rsize && (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size) Next();\n\t\t}\n\t\treturn ret*sig;\n\t}\n\n\tpublic String ReadStr() {\n\t\t//2byte文字はNG\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (ptr < rsize && Mem[ptr] != ' ' && Mem[ptr] != '\\n' && Mem[ptr] != '\\r') {\n\t\t\tsb.Append((char)Mem[ptr++]);\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\twhile (ptr < rsize &&  (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r') ) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\treturn sb.ToString();\n\t}\n\tpublic String ReadLine() {\n\t\t//極力使わない(split/parseするくらいなら上をつかう）\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (ptr < rsize && Mem[ptr] != '\\n' && Mem[ptr] != '\\r') {\n\t\t\tsb.Append((char)Mem[ptr++]);\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\twhile (ptr < rsize &&  (Mem[ptr] == ' ' || Mem[ptr] == '\\n' || Mem[ptr] == '\\r')) {\n\t\t\tptr++;\n\t\t\tif (ptr == Size && unfinished) Next();\n\t\t}\n\t\treturn sb.ToString();\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -na\na,b,c=$F.map &:to_i;$.<2?(N,M,*P=a,b;R,*U=->x{U[x]?U[x]=R[U[x]]:x};Z=(G=1..N).map{[]};Q=G.map{[]};D=->i,q,r,v{Z[r][i]=v;Q[i].map{|j,c|j!=q&&D[j,i,r,[v,c].max]}}):$.<M+2?P<<[c,a-1,b-1]:$.<M+3?(s=0;P.sort.map{|c,a,b|R[a]==R[b]||(U[R[b]]=R[a];Q[a]<<[b,c];Q[b]<<[a,c];s+=c)};N.times{|i|D[i,i,i,0]}):p(s-Z[a-1][b-1])"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"sort\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n,m := input.Next2Ints()\n  es := NewEdges(m)\n  for i:=0;i<m;i++ {\n    a,b,c := input.Next3Ints()\n    es[i] = Edge{a-1,b-1,c}\n  }\n  q := input.NextInt()\n  qs := NewQueries(q)\n  for i:=0;i<q;i++ {\n    s,t := input.Next2Ints()\n    qs[i] = Query{i,s-1,t-1}\n  }\n  sort.Sort(es)\n  uf := NewUnionFind(n)\n  tr := Edges{}\n  for i:=0;i<m;i++ {\n    if uf.Same(es[i].fm,es[i].to) { continue }\n    uf.Unite(es[i].fm,es[i].to)\n    tr = append(tr,es[i])\n  }\n  for i:=0;i<q;i++ { fmt.Println(qs[i].Answer(tr)) }\n}\n\nfunc max(n,m int64) int64 {\n  if n > m { return n }\n  return m\n}\n\ntype UnionFind struct { par,rank []int }\nfunc NewUnionFind(n int) UnionFind {\n  par := make([]int,n)\n  rank := make([]int,n)\n  for i:=0;i<n;i++ { par[i] = i }\n  return UnionFind{par,rank}\n}\nfunc(u UnionFind) Find(i int) int {\n  if u.par[i] == i { return i }\n  u.par[i] = u.Find(u.par[i])\n  return u.par[i]\n}\nfunc(u UnionFind) Same(i,j int) bool { return u.Find(i) == u.Find(j) }\nfunc(u UnionFind) Unite(i,j int) {\n  i,j = u.Find(i),u.Find(j)\n  if i == j { return }\n  if u.rank[i] < u.rank[j] { u.par[i] = j;return }\n  u.par[j] = i\n  if u.rank[i] == u.rank[j] { u.rank[i]++ }\n}\n\ntype Edge struct { fm,to int;cost int64 }\ntype Edges []Edge\nfunc NewEdges(n int) Edges { return make([]Edge,n) }\nfunc(e Edges) Len() int { return len(e) }\nfunc(e Edges) Swap(i,j int) { e[i],e[j] = e[j],e[i] }\nfunc(e Edges) Less(i,j int) bool { return e[i].cost < e[j].cost }\ntype Graph [][]Edge\nfunc NewGraph(n int) Graph { return make([][]Edge,n) }\nfunc(g Graph) AddEdge(fm int,e Edge) { g[fm] = append(g[fm],e) }\nfunc(g Graph) Add(fm,to int,cost int64) { g.AddEdge(fm,Edge{fm,to,cost}) }\n\ntype Query struct { id,s,t int }\ntype Queries []Query\nfunc NewQueries(q int) Queries { return make([]Query,q) }\nfunc(q Query) Answer(tr Edges) int64 {\n  es := append(Edges{Edge{q.s,q.t,0}},tr...)\n  m := len(es)\n  uf := NewUnionFind(m)\n  tot := int64(0)\n  for i:=0;i<m;i++ {\n    if uf.Same(es[i].fm,es[i].to) { continue }\n    uf.Unite(es[i].fm,es[i].to)\n    tot += es[i].cost\n  }\n  return tot\n}\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) Next2Ints() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}\nfunc(i *Input) Next3Ints() (int,int,int64) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.ParseInt(s[2],10,64)\n  return x,y,z\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"sort\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n,m := input.Next2Ints()\n  es := NewEdges(m)\n  for i:=0;i<m;i++ {\n    a,b,c := input.Next3Ints()\n    es[i] = Edge{a-1,b-1,c}\n  }\n  q := input.NextInt()\n  qs := NewQueries(q)\n  for i:=0;i<q;i++ {\n    s,t := input.Next2Ints()\n    qs[i] = Query{i,s-1,t-1}\n  }\n  sort.Sort(es)\n  uf := NewUnionFind(n)\n  tr := NewGraph(n)\n  tot := int64(0)\n  for i:=0;i<m;i++ {\n    if uf.Same(es[i].fm,es[i].to) { continue }\n    uf.Same(es[i].fm,es[i].to)\n    tr.Add(es[i].fm,es[i].to,es[i].cost)\n    tr.Add(es[i].to,es[i].fm,es[i].cost)\n    tot += es[i].cost\n  }\n  for i:=0;i<q;i++ { fmt.Println(tot-qs[i].Dfs(tr)) }\n}\n\nfunc max(n,m int64) int64 {\n  if n > m { return n }\n  return m\n}\n\ntype UnionFind struct { par,rank []int }\nfunc NewUnionFind(n int) UnionFind {\n  par := make([]int,n)\n  rank := make([]int,n)\n  for i:=0;i<n;i++ { par[i] = i }\n  return UnionFind{par,rank}\n}\nfunc(u UnionFind) Find(i int) int {\n  if u.par[i] == i { return i }\n  u.par[i] = u.Find(u.par[i])\n  return u.par[i]\n}\nfunc(u UnionFind) Same(i,j int) bool { return u.Find(i) == u.Find(j) }\nfunc(u UnionFind) Unite(i,j int) {\n  i,j = u.Find(i),u.Find(j)\n  if i == j { return }\n  if u.rank[i] < u.rank[j] { u.par[i] = j;return }\n  u.par[j] = i\n  if u.rank[i] == u.rank[j] { u.rank[i]++ }\n}\n\ntype Edge struct { fm,to int;cost int64 }\ntype Edges []Edge\nfunc NewEdges(n int) Edges { return make([]Edge,n) }\nfunc(e Edges) Len() int { return len(e) }\nfunc(e Edges) Swap(i,j int) { e[i],e[j] = e[j],e[i] }\nfunc(e Edges) Less(i,j int) bool { return e[i].cost < e[j].cost }\ntype Graph [][]Edge\nfunc NewGraph(n int) Graph { return make([][]Edge,n) }\nfunc(g Graph) AddEdge(fm int,e Edge) { g[fm] = append(g[fm],e) }\nfunc(g Graph) Add(fm,to int,cost int64) { g.AddEdge(fm,Edge{fm,to,cost}) }\n\ntype Query struct { id,s,t int }\ntype Queries []Query\nfunc NewQueries(q int) Queries { return make([]Query,q) }\nfunc(q Query) Dfs(g Graph) int64 {\n  used := make([]bool,len(g))\n  var dfs func(int,int64) int64\n  dfs = func(v int,m int64) int64 {\n    if v == q.t { return m }\n    used[v] = true\n    ret := int64(0)\n    for _,e := range g[v] {\n      if used[e.to] { continue }\n      x := dfs(e.to,max(m,e.cost))\n      ret = max(ret,x)\n    }\n    return ret\n  }\n  return dfs(q.s,0)\n}\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) Next2Ints() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}\nfunc(i *Input) Next3Ints() (int,int,int64) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.ParseInt(s[2],10,64)\n  return x,y,z\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"sort\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n,m := input.Next2Ints()\n  es := NewEdges(m)\n  for i:=0;i<m;i++ {\n    a,b,c := input.Next3Ints()\n    es[i] = Edge{a-1,b-1,c}\n  }\n  q := input.NextInt()\n  qs := NewQueries(q)\n  for i:=0;i<q;i++ {\n    s,t := input.Next2Ints()\n    qs[i] = Query{i,s-1,t-1}\n  }\n  sort.Sort(es)\n  uf := NewUnionFind(n)\n  tr := NewGraph(n)\n  tot := int64(0)\n  for i:=0;i<m;i++ {\n    if uf.Same(es[i].fm,es[i].to) { continue }\n    uf.Unite(es[i].fm,es[i].to)\n    tr.Add(es[i].fm,es[i].to,es[i].cost)\n    tr.Add(es[i].to,es[i].fm,es[i].cost)\n    tot += es[i].cost\n  }\n  for i:=0;i<q;i++ { fmt.Println(tot-qs[i].Dfs(tr)) }\n}\n\nfunc max(n,m int64) int64 {\n  if n > m { return n }\n  return m\n}\n\ntype UnionFind struct { par,rank []int }\nfunc NewUnionFind(n int) UnionFind {\n  par := make([]int,n)\n  rank := make([]int,n)\n  for i:=0;i<n;i++ { par[i] = i }\n  return UnionFind{par,rank}\n}\nfunc(u UnionFind) Find(i int) int {\n  if u.par[i] == i { return i }\n  u.par[i] = u.Find(u.par[i])\n  return u.par[i]\n}\nfunc(u UnionFind) Same(i,j int) bool { return u.Find(i) == u.Find(j) }\nfunc(u UnionFind) Unite(i,j int) {\n  i,j = u.Find(i),u.Find(j)\n  if i == j { return }\n  if u.rank[i] < u.rank[j] { u.par[i] = j;return }\n  u.par[j] = i\n  if u.rank[i] == u.rank[j] { u.rank[i]++ }\n}\n\ntype Edge struct { fm,to int;cost int64 }\ntype Edges []Edge\nfunc NewEdges(n int) Edges { return make([]Edge,n) }\nfunc(e Edges) Len() int { return len(e) }\nfunc(e Edges) Swap(i,j int) { e[i],e[j] = e[j],e[i] }\nfunc(e Edges) Less(i,j int) bool { return e[i].cost < e[j].cost }\ntype Graph [][]Edge\nfunc NewGraph(n int) Graph { return make([][]Edge,n) }\nfunc(g Graph) AddEdge(fm int,e Edge) { g[fm] = append(g[fm],e) }\nfunc(g Graph) Add(fm,to int,cost int64) { g.AddEdge(fm,Edge{fm,to,cost}) }\n\ntype Query struct { id,s,t int }\ntype Queries []Query\nfunc NewQueries(q int) Queries { return make([]Query,q) }\nfunc(q Query) Dfs(g Graph) int64 {\n  used := make([]bool,len(g))\n  var dfs func(int,int64) int64\n  dfs = func(v int,m int64) int64 {\n    if v == q.t { return m }\n    used[v] = true\n    ret := int64(0)\n    for _,e := range g[v] {\n      if used[e.to] { continue }\n      x := dfs(e.to,max(m,e.cost))\n      ret = max(ret,x)\n    }\n    return ret\n  }\n  return dfs(q.s,0)\n}\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) Next2Ints() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}\nfunc(i *Input) Next3Ints() (int,int,int64) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.ParseInt(s[2],10,64)\n  return x,y,z\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"sort\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n,m := input.Next2Ints()\n  es := NewEdges(m)\n  for i:=0;i<m;i++ {\n    a,b,c := input.Next3Ints()\n    es[i] = Edge{a-1,b-1,c}\n  }\n  q := input.NextInt()\n  qs := NewQueries(q)\n  for i:=0;i<q;i++ {\n    s,t := input.Next2Ints()\n    qs[i] = Query{s-1,t-1}\n  }\n  sort.Sort(es)\n  uf := NewUnionFind(n)\n  tr := NewGraph(n)\n  tot := int64(0)\n  for i:=0;i<m;i++ {\n    if uf.Same(es[i].fm,es[i].to) { continue }\n    uf.Unite(es[i].fm,es[i].to)\n    tr.Add(es[i].fm,es[i].to,es[i].cost)\n    tr.Add(es[i].to,es[i].fm,es[i].cost)\n    tot += es[i].cost\n  }\n  maxcost := make([][]int64,n)\n  for i:=0;i<n;i++ {\n    tmp := make([]int64,n)\n    var dfs func(int,int)\n    dfs = func(v,p int) {\n      for _,e := range tr[v] {\n        if e.to == p { continue }\n        tmp[e.to] = max(tmp[v],e.cost)\n        dfs(e.to,v)\n      }\n    }\n    dfs(i,-1)\n    maxcost[i] = tmp\n  }\n  for i:=0;i<q;i++ { fmt.Println(tot-maxcost[qs[i].s][qs[i].t]) }\n}\n\nfunc max(n,m int64) int64 {\n  if n > m { return n }\n  return m\n}\n\ntype UnionFind struct { par,rank []int }\nfunc NewUnionFind(n int) UnionFind {\n  par := make([]int,n)\n  rank := make([]int,n)\n  for i:=0;i<n;i++ { par[i] = i }\n  return UnionFind{par,rank}\n}\nfunc(u UnionFind) Find(i int) int {\n  if u.par[i] == i { return i }\n  u.par[i] = u.Find(u.par[i])\n  return u.par[i]\n}\nfunc(u UnionFind) Same(i,j int) bool { return u.Find(i) == u.Find(j) }\nfunc(u UnionFind) Unite(i,j int) {\n  i,j = u.Find(i),u.Find(j)\n  if i == j { return }\n  if u.rank[i] < u.rank[j] { u.par[i] = j;return }\n  u.par[j] = i\n  if u.rank[i] == u.rank[j] { u.rank[i]++ }\n}\n\ntype Edge struct { fm,to int;cost int64 }\ntype Edges []Edge\nfunc NewEdges(n int) Edges { return make([]Edge,n) }\nfunc(e Edges) Len() int { return len(e) }\nfunc(e Edges) Swap(i,j int) { e[i],e[j] = e[j],e[i] }\nfunc(e Edges) Less(i,j int) bool { return e[i].cost < e[j].cost }\ntype Graph [][]Edge\nfunc NewGraph(n int) Graph { return make([][]Edge,n) }\nfunc(g Graph) AddEdge(fm int,e Edge) { g[fm] = append(g[fm],e) }\nfunc(g Graph) Add(fm,to int,cost int64) { g.AddEdge(fm,Edge{fm,to,cost}) }\n\ntype Query struct { s,t int }\ntype Queries []Query\nfunc NewQueries(q int) Queries { return make([]Query,q) }\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInt() int {\n  n,_ := strconv.Atoi(i.NextLine())\n  return n\n}\nfunc(i *Input) Next2Ints() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}\nfunc(i *Input) Next3Ints() (int,int,int64) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.ParseInt(s[2],10,64)\n  return x,y,z\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip, std.regex;\n\nimmutable long INF = 1L << 59;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto G = new Tuple!(int, long)[][](N);\n    foreach (i; 0..M) {\n        s = readln.split.map!(to!int);\n        G[s[0]-1] ~= tuple(s[1]-1, s[2].to!long);\n        G[s[1]-1] ~= tuple(s[0]-1, s[2].to!long);\n    }\n\n    long mst_cost = 0;\n    auto H = new Tuple!(int, long)[][](N);\n    auto P = new Tuple!(int, long)[](N);\n    auto D = new int[](N);\n    auto used = new bool[](N);\n    auto q = new BinaryHeap!(Array!(Tuple!(int, int, long)), \"a[2] > b[2]\")();\n    q.insert(tuple(-1, 0, 0L));\n\n    while (!q.empty) {\n        auto t = q.front;\n        auto from = t[0];\n        auto cur = t[1];\n        auto d = t[2];\n        q.removeFront;\n        if (used[cur]) continue;\n        used[cur] = true;\n        mst_cost += d;\n        if (from != -1) {\n            H[from] ~= tuple(cur, d);\n            H[cur] ~= tuple(from, d);\n        }\n        foreach (m; G[cur]) {\n            auto tar = m[0];\n            auto nd = m[1];\n            if (used[tar]) continue;\n            q.insert(tuple(cur, tar, nd));\n        }\n    }\n\n    void dfs(int n, int p, long c, int d) {\n        P[n] = tuple(p, c);\n        D[n] = d;\n        foreach (to; H[n]) if (to[0] != p) dfs(to[0], n, to[1], d+1);\n    }\n\n    dfs(0, -1, 0, 0);\n\n\n    auto Q = readln.chomp.to!int;\n    while (Q--) {\n        s = readln.split.map!(to!int);\n        auto a = s[0]-1;\n        auto b = s[1]-1;\n        if (D[a] > D[b]) swap(a, b);\n        long maxv = -1;\n        while (D[b] > D[a]) {\n            maxv = max(maxv, P[b][1]);\n            b = P[b][0];\n        }\n        while (a != b) {\n            maxv = max(maxv, P[a][1]);\n            a = P[a][0];\n            maxv = max(maxv, P[b][1]);\n            b = P[b][0];\n        }\n        writeln(mst_cost - maxv);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\nimport std.typecons;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.datastructure.unionfind;\n// import dcomp.graph.lca;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m;\n    sc.read(n, m);\n    int[] a = new int[m];\n    int[] b = new int[m];\n    long[] c = new long[m];\n    foreach (i; 0..m) {\n        sc.read(a[i], b[i], c[i]);\n        a[i]--; b[i]--;\n    }\n    int[] idx = iota(m).array;\n    idx.sort!((x, y) => c[x] < c[y]);\n    auto uf = new UnionFind(n);\n\n    alias Edge = Tuple!(int, \"to\", long, \"cost\");\n    auto g = new Edge[][n];\n    long sm;\n    foreach (i; idx) {\n        if (uf.same(a[i], b[i])) continue;\n        uf.merge(a[i], b[i]);\n        sm += c[i];\n        g[a[i]] ~= Edge(b[i], c[i]);\n        g[b[i]] ~= Edge(a[i], c[i]);\n    }\n\n    auto lca = lcaInfo(g);\n    int lg = lca.anc.length.to!int;\n    long[][] ma = new long[][](lg, n);\n    void dfs(int p, int b) {\n        foreach (e; g[p]) {\n            if (e.to == b) continue;\n            ma[0][e.to] = e.cost;\n            dfs(e.to, p);\n        }\n    }\n    dfs(0, -1);\n    foreach (i; 1..lg) {\n        foreach (j; 0..n) {\n            ma[i][j] = ma[i-1][j];\n            if (lca.anc[i-1][j] != -1) {\n                ma[i][j] = max(ma[i][j], ma[i-1][lca.anc[i-1][j]]);\n            }\n        }\n    }\n    long getMa(int s, int t) {\n        int di = lca.dps[s]-lca.dps[t];\n        long ans = -1;\n        foreach_reverse (i; 0..lg) {\n            if (2^^i <= di) {\n                di -= 2^^i;\n                ans = max(ans, ma[i][s]);\n                s = lca.anc[i][s];\n            }\n        }\n        return ans;\n    }\n    int q;\n    sc.read(q);\n\n    foreach (i; 0..q) {\n        int s, t;\n        sc.read(s, t); s--; t--;\n        int u = lca.lca(s, t);\n//        writeln(s, \" \", t, \" \", u, \" \", getMa(s, u), \" \", getMa(t, u));\n        writeln(sm - max(getMa(s, u), getMa(t, u)));\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\nversion (X86) static if (__VERSION__ < 2071) {\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                //todo optimize\n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File, writeln;\n    import std.datetime;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    foreach (i; 0..1_000_000) {\n        fout.writeln(3*i, \" \", 3*i+1, \" \", 3*i+2);\n    }\n    fout.close;\n    writeln(\"Scanner Speed Test(3*1,000,000 int)\");\n    StopWatch sw;\n    sw.start;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    foreach (i; 0..500_000) {\n        int a, b, c;\n        sc.read(a, b, c);\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 500_000..700_000) {\n        int[3] d;\n        sc.read(d);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 700_000..1_000_000) {\n        int[] d;\n        sc.read(d);\n        assert(d.length == 3);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/graph/lca.d */\n// module dcomp.graph.lca;\n\nstruct LCAInfo {\n    int[] dps;\n    int[][] anc;\n    this(int n) {\n        import core.bitop : bsr;\n        int lg = n.bsr;\n        if ((2^^lg) < n) lg++;\n        dps = new int[n];\n        anc = new int[][](lg, n);\n    }\n}\n\nLCAInfo lcaInfo(T)(T g) {\n    import std.conv : to;\n    const int n = g.length.to!int;\n    auto info = LCAInfo(n);\n    with(info) {\n        int lg = anc.length.to!int;\n        void dfs(int p, int b, int nowDps) {\n            anc[0][p] = b;\n            dps[p] = nowDps;\n            foreach (e; g[p]) {\n                int d = e.to;\n                if (d == b) continue;\n                dfs(d, p, nowDps+1);\n            }\n        }\n        dfs(0, -1, 0);\n        foreach (i; 1..lg) {\n            foreach (j; 0..n) {\n                anc[i][j] = (anc[i-1][j] == -1) ? -1 : anc[i-1][anc[i-1][j]];\n            }\n        }\n    }\n    return info;\n}\n\nint lca(in LCAInfo lca, int l, int r) {\n    import std.algorithm : swap;\n    import std.conv : to;\n    int lg = lca.anc.length.to!int;\n    with (lca) {\n        if (dps[l] < dps[r]) swap(l, r);\n        int di = dps[l]-dps[r];\n        foreach_reverse (i; 0..lg) {\n            if (di < 2^^i) continue;\n            di -= 2^^i;\n            l = anc[i][l];\n        }\n        if (l == r) return l;\n        foreach_reverse (i; 0..lg) {\n            if (anc[i][l] == anc[i][r]) continue;\n            l = anc[i][l];\n            r = anc[i][r];\n        }\n    }\n    return lca.anc[0][l];\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/unionfind.d */\n// module dcomp.datastructure.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id; // group id\n    int[][] groups; // group list\n    int count; // group count\n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\nunittest {\n    import std.algorithm : equal, sort;\n    auto uf = UnionFind(5);\n    assert(!uf.same(1, 3));\n    assert(uf.same(0, 0));\n\n    uf.merge(3, 2);\n    uf.merge(1, 1);\n    uf.merge(4, 2);\n    uf.merge(4, 3);\n\n    assert(uf.count == 3);\n    assert(uf.id[2] == uf.id[3]);\n    assert(uf.id[2] == uf.id[4]);\n    assert(equal(uf.group(0), [0]));\n    assert(equal(uf.group(1), [1]));\n    assert(equal(sort(uf.group(2)), [2, 3, 4]));\n}\n\nunittest {\n    import std.datetime, std.stdio, std.range;\n    // speed check\n    writeln(\"UnionFind Speed Test\");\n    StopWatch sw;\n    sw.start;\n    UnionFind uf;\n    // line\n    uf = UnionFind(1_000_000);\n    foreach (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // line(reverse)\n    uf = UnionFind(1_000_000);\n    foreach_reverse (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // binary tree\n    uf = UnionFind(1_000_000);\n    foreach (lg; 1..20) {\n        int len = 1<<lg;\n        foreach (i; iota(0, 1_000_000-len/2, len)) {\n            uf.merge(i, i+len/2);\n        }\n    }\n    sw.stop;\n    writeln(sw.peek.msecs, \"ms\");\n}\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\nproc readInt1*(): int = readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype UnionFindTree = tuple[ p, h, w: seq[int] ]\n\nproc initUnionFindTree(n: int): UnionFindTree =\n  var p = newSeq[int](n)\n  p.fill(-1)\n  var h = newSeq[int](n)\n  h.fill(0)\n  var w = newSeq[int](n)\n  w.fill(1)\n  return (p, h, w)\n\nproc find(this: var UnionFindTree, v: int): int =\n  if this.p[v] == -1:\n    return v\n  this.p[v] = find(this, this.p[v])\n  return this.p[v]\n\nproc same(this: var UnionFindTree, u, v: int): bool =\n  this.find(u) == this.find(v)\n\nproc union(this: var UnionFindTree, u, v: int) =\n  let uRoot = this.find(u)\n  let vRoot = this.find(v)\n  if uRoot == vRoot:\n    return\n\n  if this.h[uRoot] > this.h[vRoot]:\n    this.p[vRoot] = uRoot\n    this.w[uRoot] += this.w[vRoot]\n  else:\n    this.p[uRoot] = vRoot\n    this.w[vRoot] += this.w[uRoot]\n    if this.h[uRoot] == this.h[vRoot]:\n      this.h[vRoot] += 1\n\nproc reduceL[T1, T2](a: seq[T1]; e: T2; f: (T2, T1) -> T2): T2 =\n  var ans = e\n  for i in 0..<a.len():\n    ans = f(ans, a[i])\n  return ans\n\n#------------------------------------------------------------------------------#\ntype Pred1[T] = T -> bool\n\n# [lb, ub)\nproc nibutanLb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      lb = mid\n    else:\n      ub = mid\n  return lb\n\n# (lb, ub]\nproc nibutanUb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      ub = mid\n    else:\n      lb = mid\n  return ub\n#------------------------------------------------------------------------------#\n\ntype Edge = tuple [ a, b, c: int ]\n\nproc compareEdgeByWeight(e1, e2: Edge): int =\n  if e1.c == e2.c:\n    return 0\n  elif e1.c > e2.c:\n    return 1\n  else:\n    return -1\n\nproc minimum_spanning_tree(n: int; es: seq[Edge]): seq[Edge] =\n  let es = es.sorted(compareEdgeByWeight)\n\n  var uft = initUnionFindTree(n)\n  var ans = newSeq[Edge](0)\n  for e in es:\n    if ans.len() >= n - 1:\n      break\n    if not uft.same(e.a, e.b):\n      ans.add(e)\n      uft.union(e.a, e.b)\n\n  return ans\n\nproc buildRootedTree(n: int; es: seq[Edge]): seq[Edge] =\n  var g = newSeq2[(int, int)](n, 0)\n  for e in es:\n    g[e.a].add((e.b, e.c))\n    g[e.b].add((e.a, e.c))\n\n  var ans = newSeq[Edge](n)\n  var stack = newSeq[int](0)\n  var used = newSeq[bool](n)\n  stack.add(0)\n  used[0] = true\n  ans[0] = (0, 0, 0)\n  while stack.len() != 0:\n    let v = stack.pop()\n    for e in g[v]:\n      if used[e[0]]:\n        continue\n      used[e[0]] = true\n      stack.add(e[0])\n      ans[e[0]] = (e[0], v, e[1])\n\n  return ans\n\nproc parent(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return u\n\nproc parentMaxEdge(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var ans = -1\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      ans = max(ans, pps[k][u].c)\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return ans\n\nproc depth(pps: seq2[Edge]; v: int): int =\n  var pps2: seq2[Edge]\n  shallowCopy(pps2, pps)\n\n  nibutanUb(-1, 2^12, it => parent(pps2, v, it) == 0)\n\nproc lca(pps: seq2[Edge]; d: seq[int]; v, u: int): int =\n  var pps2: seq2[Edge]\n  shallowCopy(pps2, pps)\n\n  var v = v\n  var u = u\n  if d[v] < d[u]:\n    swap(v, u)\n  v = parent(pps, v, d[v] - d[u])\n  let diff = nibutanUb(-1, 2^12, it => parent(pps2, v, it) == parent(pps2, u, it))\n  return parent(pps, v, diff)\n\nproc main() =\n  let (n, m) = readInt2()\n\n  var es = newSeq[Edge](m)\n  for i in 0..<m:\n    let (a, b, c) = readInt3()\n    es[i] = (a - 1, b - 1, c)\n\n  let q = readInt1()\n  var qs = newSeq[(int, int)](q)\n  for i in 0..<q:\n    let (s, t) = readInt2()\n    qs[i] = (s - 1, t - 1)\n\n  let mst = minimum_spanning_tree(n, es)\n  let mstSum = mst.reduceL(0, (acc, e) => (acc + e.c))\n\n  let ps = buildRootedTree(n, mst)\n  var pps = newSeq2[Edge](13, n)\n  pps[0] = ps\n  for i in 1..12:\n    for v in 0..<n:\n      let parent = pps[i - 1][pps[i - 1][v].b].b\n      let maxWeight = max(pps[i - 1][v].c, pps[i - 1][pps[i - 1][v].b].c)\n      pps[i][v] = (v, parent, maxWeight)\n\n  var d = newSeq[int](n)\n  for v in 0..<n:\n    d[v] = depth(pps, v)\n\n  for q in qs:\n    let a = lca(pps, d, q[0], q[1])\n    var ans = 0\n    ans = max(ans, parentMaxEdge(pps, q[0], d[q[0]] - d[a]))\n    ans = max(ans, parentMaxEdge(pps, q[1], d[q[1]] - d[a]))\n    echo mstSum - ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\nproc readInt1*(): int = readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype UnionFindTree = tuple[ p, h, w: seq[int] ]\n\nproc initUnionFindTree(n: int): UnionFindTree =\n  var p = newSeq[int](n)\n  p.fill(-1)\n  var h = newSeq[int](n)\n  h.fill(0)\n  var w = newSeq[int](n)\n  w.fill(1)\n  return (p, h, w)\n\nproc find(this: var UnionFindTree, v: int): int =\n  if this.p[v] == -1:\n    return v\n  this.p[v] = find(this, this.p[v])\n  return this.p[v]\n\nproc same(this: var UnionFindTree, u, v: int): bool =\n  this.find(u) == this.find(v)\n\nproc union(this: var UnionFindTree, u, v: int) =\n  let uRoot = this.find(u)\n  let vRoot = this.find(v)\n  if uRoot == vRoot:\n    return\n\n  if this.h[uRoot] > this.h[vRoot]:\n    this.p[vRoot] = uRoot\n    this.w[uRoot] += this.w[vRoot]\n  else:\n    this.p[uRoot] = vRoot\n    this.w[vRoot] += this.w[uRoot]\n    if this.h[uRoot] == this.h[vRoot]:\n      this.h[vRoot] += 1\n\nproc reduceL[T1, T2](a: seq[T1]; e: T2; f: (T2, T1) -> T2): T2 =\n  var ans = e\n  for i in 0..<a.len():\n    ans = f(ans, a[i])\n  return ans\n\n#------------------------------------------------------------------------------#\ntype Pred1[T] = T -> bool\n\n# [lb, ub)\nproc nibutanLb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      lb = mid\n    else:\n      ub = mid\n  return lb\n\n# (lb, ub]\nproc nibutanUb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      ub = mid\n    else:\n      lb = mid\n  return ub\n#------------------------------------------------------------------------------#\n\ntype Edge = tuple [ a, b, c: int ]\n\nproc compareEdgeByWeight(e1, e2: Edge): int =\n  if e1.c == e2.c:\n    return 0\n  elif e1.c > e2.c:\n    return 1\n  else:\n    return -1\n\nproc minimum_spanning_tree(n: int; es: seq[Edge]): seq[Edge] =\n  let es = es.sorted(compareEdgeByWeight)\n\n  var uft = initUnionFindTree(n)\n  var ans = newSeq[Edge](0)\n  for e in es:\n    if ans.len() >= n - 1:\n      break\n    if not uft.same(e.a, e.b):\n      ans.add(e)\n      uft.union(e.a, e.b)\n\n  return ans\n\nproc buildRootedTree(n: int; es: seq[Edge]): seq[Edge] =\n  var ps = newSeq[Edge](n)\n  for e in es:\n    var v = e.a\n    var u = e.b\n    if v > u:\n      swap(v, u)\n    ps[u] = (u, v, e.c)\n  return ps\n\nproc parent(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return u\n\nproc parentMaxEdge(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var ans = -1\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      ans = max(ans, pps[k][u].c)\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return ans\n\nproc depth(pps: seq2[Edge]; v: int): int =\n  nibutanUb(-1, 2^12, it => parent(pps, v, it) == 0)\n\nproc lca(pps: seq2[Edge]; d: seq[int]; v, u: int): int =\n  var v = v\n  var u = u\n  if d[v] < d[u]:\n    swap(v, u)\n  v = parent(pps, v, d[v] - d[u])\n  let diff = nibutanUb(-1, 2^12, it => parent(pps, v, it) == parent(pps, u, it))\n  return parent(pps, v, diff)\n\nproc main() =\n  let (n, m) = readInt2()\n\n  var es = newSeq[Edge](m)\n  for i in 0..<m:\n    let (a, b, c) = readInt3()\n    es[i] = (a - 1, b - 1, c)\n\n  let q = readInt1()\n  var qs = newSeq[(int, int)](q)\n  for i in 0..<q:\n    let (s, t) = readInt2()\n    qs[i] = (s - 1, t - 1)\n\n  let mst = minimum_spanning_tree(n, es)\n  let mstSum = mst.reduceL(0, (acc, e) => (acc + e.c))\n\n  let ps = buildRootedTree(n, mst)\n  var pps = newSeq2[Edge](13, n)\n  pps[0] = ps\n  for i in 1..12:\n    for v in 0..<n:\n      let parent = pps[i - 1][pps[i - 1][v].b].b\n      let maxWeight = max(pps[i - 1][v].c, pps[i - 1][pps[i - 1][v].b].c)\n      pps[i][v] = (v, parent, maxWeight)\n\n  var d = newSeq[int](n)\n  for v in 0..<n:\n    d[v] = depth(pps, v)\n\n  for q in qs:\n    let a = lca(pps, d, q[0], q[1])\n    var ans = 0\n    ans = max(ans, parentMaxEdge(pps, q[0], d[q[0]] - d[a]))\n    ans = max(ans, parentMaxEdge(pps, q[1], d[q[1]] - d[a]))\n    echo mstSum - ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\nproc readInt1*(): int = readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype UnionFindTree = tuple[ p, h, w: seq[int] ]\n\nproc initUnionFindTree(n: int): UnionFindTree =\n  var p = newSeq[int](n)\n  p.fill(-1)\n  var h = newSeq[int](n)\n  h.fill(0)\n  var w = newSeq[int](n)\n  w.fill(1)\n  return (p, h, w)\n\nproc find(this: var UnionFindTree, v: int): int =\n  if this.p[v] == -1:\n    return v\n  this.p[v] = find(this, this.p[v])\n  return this.p[v]\n\nproc same(this: var UnionFindTree, u, v: int): bool =\n  this.find(u) == this.find(v)\n\nproc union(this: var UnionFindTree, u, v: int) =\n  let uRoot = this.find(u)\n  let vRoot = this.find(v)\n  if uRoot == vRoot:\n    return\n\n  if this.h[uRoot] > this.h[vRoot]:\n    this.p[vRoot] = uRoot\n    this.w[uRoot] += this.w[vRoot]\n  else:\n    this.p[uRoot] = vRoot\n    this.w[vRoot] += this.w[uRoot]\n    if this.h[uRoot] == this.h[vRoot]:\n      this.h[vRoot] += 1\n\nproc reduceL[T1, T2](a: seq[T1]; e: T2; f: (T2, T1) -> T2): T2 =\n  var ans = e\n  for i in 0..<a.len():\n    ans = f(ans, a[i])\n  return ans\n\n#------------------------------------------------------------------------------#\ntype Pred1[T] = T -> bool\n\n# [lb, ub)\nproc nibutanLb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      lb = mid\n    else:\n      ub = mid\n  return lb\n\n# (lb, ub]\nproc nibutanUb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      ub = mid\n    else:\n      lb = mid\n  return ub\n#------------------------------------------------------------------------------#\n\ntype Edge = tuple [ a, b, c: int ]\n\nproc compareEdgeByWeight(e1, e2: Edge): int =\n  if e1.c == e2.c:\n    return 0\n  elif e1.c > e2.c:\n    return 1\n  else:\n    return -1\n\nproc minimum_spanning_tree(n: int; es: seq[Edge]): seq[Edge] =\n  let es = es.sorted(compareEdgeByWeight)\n\n  var uft = initUnionFindTree(n)\n  var ans = newSeq[Edge](0)\n  for e in es:\n    if ans.len() >= n - 1:\n      break\n    if not uft.same(e.a, e.b):\n      ans.add(e)\n      uft.union(e.a, e.b)\n\n  return ans\n\nproc buildRootedTree(n: int; es: seq[Edge]): seq[Edge] =\n  var g = newSeq2[(int, int)](n, 0)\n  for e in es:\n    g[e.a].add((e.b, e.c))\n    g[e.b].add((e.a, e.c))\n\n  var ans = newSeq[Edge](n)\n  var stack = newSeq[int](0)\n  var used = newSeq[bool](n)\n  stack.add(0)\n  used[0] = true\n  ans[0] = (0, 0, 0)\n  while stack.len() != 0:\n    let v = stack.pop()\n    for e in g[v]:\n      if used[e[0]]:\n        continue\n      used[e[0]] = true\n      stack.add(e[0])\n      ans[e[0]] = (e[0], v, e[1])\n\n  return ans\n\nproc parent(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return u\n\nproc parentMaxEdge(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var ans = -1\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      ans = max(ans, pps[k][u].c)\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return ans\n\nproc depth(pps: var seq2[Edge]; v: int): int =\n  var pps2: seq2[Edge]\n  shallowCopy(pps2, pps)\n\n  nibutanUb(-1, 2^12, it => parent(pps2, v, it) == 0)\n\nproc lca(pps: var seq2[Edge]; d: seq[int]; v, u: int): int =\n  var pps2: seq2[Edge]\n  shallowCopy(pps2, pps)\n\n  var v = v\n  var u = u\n  if d[v] < d[u]:\n    swap(v, u)\n  v = parent(pps, v, d[v] - d[u])\n  let diff = nibutanUb(-1, 2^12, it => parent(pps2, v, it) == parent(pps2, u, it))\n  return parent(pps, v, diff)\n\nproc main() =\n  let (n, m) = readInt2()\n\n  var es = newSeq[Edge](m)\n  for i in 0..<m:\n    let (a, b, c) = readInt3()\n    es[i] = (a - 1, b - 1, c)\n\n  let q = readInt1()\n  var qs = newSeq[(int, int)](q)\n  for i in 0..<q:\n    let (s, t) = readInt2()\n    qs[i] = (s - 1, t - 1)\n\n  let mst = minimum_spanning_tree(n, es)\n  let mstSum = mst.reduceL(0, (acc, e) => (acc + e.c))\n\n  let ps = buildRootedTree(n, mst)\n  var pps = newSeq2[Edge](13, n)\n  pps[0] = ps\n  for i in 1..12:\n    for v in 0..<n:\n      let parent = pps[i - 1][pps[i - 1][v].b].b\n      let maxWeight = max(pps[i - 1][v].c, pps[i - 1][pps[i - 1][v].b].c)\n      pps[i][v] = (v, parent, maxWeight)\n\n  var d = newSeq[int](n)\n  for v in 0..<n:\n    d[v] = depth(pps, v)\n\n  for q in qs:\n    let a = lca(pps, d, q[0], q[1])\n    var ans = 0\n    ans = max(ans, parentMaxEdge(pps, q[0], d[q[0]] - d[a]))\n    ans = max(ans, parentMaxEdge(pps, q[1], d[q[1]] - d[a]))\n    echo mstSum - ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\nproc readInt1*(): int = readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype UnionFindTree = tuple[ p, h, w: seq[int] ]\n\nproc initUnionFindTree(n: int): UnionFindTree =\n  var p = newSeq[int](n)\n  p.fill(-1)\n  var h = newSeq[int](n)\n  h.fill(0)\n  var w = newSeq[int](n)\n  w.fill(1)\n  return (p, h, w)\n\nproc find(this: var UnionFindTree, v: int): int =\n  if this.p[v] == -1:\n    return v\n  this.p[v] = find(this, this.p[v])\n  return this.p[v]\n\nproc same(this: var UnionFindTree, u, v: int): bool =\n  this.find(u) == this.find(v)\n\nproc union(this: var UnionFindTree, u, v: int) =\n  let uRoot = this.find(u)\n  let vRoot = this.find(v)\n  if uRoot == vRoot:\n    return\n\n  if this.h[uRoot] > this.h[vRoot]:\n    this.p[vRoot] = uRoot\n    this.w[uRoot] += this.w[vRoot]\n  else:\n    this.p[uRoot] = vRoot\n    this.w[vRoot] += this.w[uRoot]\n    if this.h[uRoot] == this.h[vRoot]:\n      this.h[vRoot] += 1\n\nproc reduceL[T1, T2](a: seq[T1]; e: T2; f: (T2, T1) -> T2): T2 =\n  var ans = e\n  for i in 0..<a.len():\n    ans = f(ans, a[i])\n  return ans\n\n#------------------------------------------------------------------------------#\ntype Pred1[T] = T -> bool\n\n# [lb, ub)\nproc nibutanLb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      lb = mid\n    else:\n      ub = mid\n  return lb\n\n# (lb, ub]\nproc nibutanUb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      ub = mid\n    else:\n      lb = mid\n  return ub\n#------------------------------------------------------------------------------#\n\ntype Edge = tuple [ a, b, c: int ]\n\nproc compareEdgeByWeight(e1, e2: Edge): int =\n  if e1.c == e2.c:\n    return 0\n  elif e1.c > e2.c:\n    return 1\n  else:\n    return -1\n\nproc minimum_spanning_tree(n: int; es: seq[Edge]): seq[Edge] =\n  let es = es.sorted(compareEdgeByWeight)\n\n  var uft = initUnionFindTree(n)\n  var ans = newSeq[Edge](0)\n  for e in es:\n    if ans.len() >= n - 1:\n      break\n    if not uft.same(e.a, e.b):\n      ans.add(e)\n      uft.union(e.a, e.b)\n\n  return ans\n\nproc buildRootedTree(n: int; es: seq[Edge]): seq[Edge] =\n  var ps = newSeq[Edge](n)\n  for e in es:\n    var v = e.a\n    var u = e.b\n    if v > u:\n      swap(v, u)\n    ps[u] = (u, v, e.c)\n  return ps\n\nproc parent(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return u\n\nproc parentMaxEdge(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var ans = -1\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      ans = max(ans, pps[k][u].c)\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return ans\n\nproc depth(pps: seq2[Edge]; v: int): int =\n  nibutanUb(-1, 2^12, it => parent(pps, v, it) == 0)\n\nproc main() =\n  let (n, m) = readInt2()\n\n  var es = newSeq[Edge](m)\n  for i in 0..<m:\n    let (a, b, c) = readInt3()\n    es[i] = (a - 1, b - 1, c)\n\n  let q = readInt1()\n  var qs = newSeq[(int, int)](q)\n  for i in 0..<q:\n    let (s, t) = readInt2()\n    qs[i] = (s - 1, t - 1)\n\n  let mst = minimum_spanning_tree(n, es)\n  let mstSum = mst.reduceL(0, (acc, e) => (acc + e.c))\n\n  let ps = buildRootedTree(n, mst)\n  var pps = newSeq2[Edge](13, n)\n  pps[0] = ps\n  for i in 1..12:\n    for v in 0..<n:\n      let parent = pps[i - 1][pps[i - 1][v].b].b\n      let maxWeight = max(pps[i - 1][v].c, pps[i - 1][pps[i - 1][v].b].c)\n      pps[i][v] = (v, parent, maxWeight)\n\n  for q in qs:\n    var s = q[0]\n    var t = q[1]\n    var sd = depth(pps, s)\n    var td = depth(pps, t)\n    if sd < td:\n      swap(sd, td)\n      swap(s, t)\n    let ss = parent(pps, s, sd - td)\n    let lcaDepthDiff = nibutanUb(-1, 2^12, it => parent(pps, ss, it) == parent(pps, t, it))\n    let lca = parent(pps, ss, lcaDepthDiff)\n    let lcaDepth = parent(pps, ss, lcaDepthDiff)\n\n    var ans = 0\n    ans = max(ans, parentMaxEdge(pps, s, sd - lcaDepth))\n    ans = max(ans, parentMaxEdge(pps, t, td - lcaDepth))\n\n    # echo \"q = \", q\n    # echo \"s = \", s\n    # echo \"ss = \", ss\n    # echo \"t = \", t\n    # echo \"lca = \", lca\n    echo mstSum - ans\n    # echo \"\"\n    # echo \"\"\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\nproc readInt1*(): int = readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype UnionFindTree = tuple[ p, h, w: seq[int] ]\n\nproc initUnionFindTree(n: int): UnionFindTree =\n  var p = newSeq[int](n)\n  p.fill(-1)\n  var h = newSeq[int](n)\n  h.fill(0)\n  var w = newSeq[int](n)\n  w.fill(1)\n  return (p, h, w)\n\nproc find(this: var UnionFindTree, v: int): int =\n  if this.p[v] == -1:\n    return v\n  this.p[v] = find(this, this.p[v])\n  return this.p[v]\n\nproc same(this: var UnionFindTree, u, v: int): bool =\n  this.find(u) == this.find(v)\n\nproc union(this: var UnionFindTree, u, v: int) =\n  let uRoot = this.find(u)\n  let vRoot = this.find(v)\n  if uRoot == vRoot:\n    return\n\n  if this.h[uRoot] > this.h[vRoot]:\n    this.p[vRoot] = uRoot\n    this.w[uRoot] += this.w[vRoot]\n  else:\n    this.p[uRoot] = vRoot\n    this.w[vRoot] += this.w[uRoot]\n    if this.h[uRoot] == this.h[vRoot]:\n      this.h[vRoot] += 1\n\nproc reduceL[T1, T2](a: seq[T1]; e: T2; f: (T2, T1) -> T2): T2 =\n  var ans = e\n  for i in 0..<a.len():\n    ans = f(ans, a[i])\n  return ans\n\n#------------------------------------------------------------------------------#\ntype Pred1[T] = T -> bool\n\n# [lb, ub)\nproc nibutanLb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      lb = mid\n    else:\n      ub = mid\n  return lb\n\n# (lb, ub]\nproc nibutanUb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      ub = mid\n    else:\n      lb = mid\n  return ub\n#------------------------------------------------------------------------------#\n\ntype Edge = tuple [ a, b, c: int ]\n\nproc compareEdgeByWeight(e1, e2: Edge): int =\n  if e1.c == e2.c:\n    return 0\n  elif e1.c > e2.c:\n    return 1\n  else:\n    return -1\n\nproc minimum_spanning_tree(n: int; es: seq[Edge]): seq[Edge] =\n  let es = es.sorted(compareEdgeByWeight)\n\n  var uft = initUnionFindTree(n)\n  var ans = newSeq[Edge](0)\n  for e in es:\n    if ans.len() >= n - 1:\n      break\n    if not uft.same(e.a, e.b):\n      ans.add(e)\n      uft.union(e.a, e.b)\n\n  return ans\n\nproc buildRootedTree(n: int; es: seq[Edge]): seq[Edge] =\n  var g = newSeq2[(int, int)](n, 0)\n  for e in es:\n    g[e.a].add((e.b, e.c))\n    g[e.b].add((e.a, e.c))\n\n  var ans = newSeq[Edge](n)\n  var stack = newSeq[int](0)\n  var used = newSeq[bool](n)\n  stack.add(0)\n  used[0] = true\n  ans[0] = (0, 0, 0)\n  while stack.len() != 0:\n    let v = stack.pop()\n    for e in g[v]:\n      if used[e[0]]:\n        continue\n      used[e[0]] = true\n      stack.add(e[0])\n      ans[e[0]] = (e[0], v, e[1])\n\n  return ans\n\nproc parent(pps: ref seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return u\n\nproc parentMaxEdge(pps: ref seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var ans = -1\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      ans = max(ans, pps[k][u].c)\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return ans\n\nproc depth(pps: ref seq2[Edge]; v: int): int =\n  nibutanUb(-1, 2^12, it => parent(pps, v, it) == 0)\n\nproc lca(pps: ref seq2[Edge]; d: seq[int]; v, u: int): int =\n  var v = v\n  var u = u\n  if d[v] < d[u]:\n    swap(v, u)\n  v = parent(pps, v, d[v] - d[u])\n  let diff = nibutanUb(-1, 2^12, it => parent(pps, v, it) == parent(pps, u, it))\n  return parent(pps, v, diff)\n\nproc main() =\n  let (n, m) = readInt2()\n\n  var es = newSeq[Edge](m)\n  for i in 0..<m:\n    let (a, b, c) = readInt3()\n    es[i] = (a - 1, b - 1, c)\n\n  let q = readInt1()\n  var qs = newSeq[(int, int)](q)\n  for i in 0..<q:\n    let (s, t) = readInt2()\n    qs[i] = (s - 1, t - 1)\n\n  let mst = minimum_spanning_tree(n, es)\n  let mstSum = mst.reduceL(0, (acc, e) => (acc + e.c))\n\n  let ps = buildRootedTree(n, mst)\n  var pps: ref seq2[Edge]\n  pps.new()\n  pps[] = newSeq2[Edge](13, n)\n\n  pps[0] = ps\n  for i in 1..12:\n    for v in 0..<n:\n      let parent = pps[i - 1][pps[i - 1][v].b].b\n      let maxWeight = max(pps[i - 1][v].c, pps[i - 1][pps[i - 1][v].b].c)\n      pps[i][v] = (v, parent, maxWeight)\n\n  var d = newSeq[int](n)\n  for v in 0..<n:\n    d[v] = depth(pps, v)\n\n  for q in qs:\n    let a = lca(pps, d, q[0], q[1])\n    var ans = 0\n    ans = max(ans, parentMaxEdge(pps, q[0], d[q[0]] - d[a]))\n    ans = max(ans, parentMaxEdge(pps, q[1], d[q[1]] - d[a]))\n    echo mstSum - ans\n\nmain()\n\n"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readSeq*(): seq[string] = stdin.readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = stdin.readLine().strip()\n\nproc readInt1*(): int = readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\n\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] = newSeqWith(n1, newSeq[T](n2))\n\n#------------------------------------------------------------------------------#\ntype UnionFindTree = tuple[ p, h, w: seq[int] ]\n\nproc initUnionFindTree(n: int): UnionFindTree =\n  var p = newSeq[int](n)\n  p.fill(-1)\n  var h = newSeq[int](n)\n  h.fill(0)\n  var w = newSeq[int](n)\n  w.fill(1)\n  return (p, h, w)\n\nproc find(this: var UnionFindTree, v: int): int =\n  if this.p[v] == -1:\n    return v\n  this.p[v] = find(this, this.p[v])\n  return this.p[v]\n\nproc same(this: var UnionFindTree, u, v: int): bool =\n  this.find(u) == this.find(v)\n\nproc union(this: var UnionFindTree, u, v: int) =\n  let uRoot = this.find(u)\n  let vRoot = this.find(v)\n  if uRoot == vRoot:\n    return\n\n  if this.h[uRoot] > this.h[vRoot]:\n    this.p[vRoot] = uRoot\n    this.w[uRoot] += this.w[vRoot]\n  else:\n    this.p[uRoot] = vRoot\n    this.w[vRoot] += this.w[uRoot]\n    if this.h[uRoot] == this.h[vRoot]:\n      this.h[vRoot] += 1\n\nproc reduceL[T1, T2](a: seq[T1]; e: T2; f: (T2, T1) -> T2): T2 =\n  var ans = e\n  for i in 0..<a.len():\n    ans = f(ans, a[i])\n  return ans\n\n#------------------------------------------------------------------------------#\ntype Pred1[T] = T -> bool\n\n# [lb, ub)\nproc nibutanLb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      lb = mid\n    else:\n      ub = mid\n  return lb\n\n# (lb, ub]\nproc nibutanUb(lb, ub: int; f: Pred1[int]): int =\n  var lb = lb\n  var ub = ub\n  while ub - lb > 1:\n    let mid = (ub + lb) div 2\n    if f(mid):\n      ub = mid\n    else:\n      lb = mid\n  return ub\n#------------------------------------------------------------------------------#\n\ntype Edge = tuple [ a, b, c: int ]\n\nproc compareEdgeByWeight(e1, e2: Edge): int =\n  if e1.c == e2.c:\n    return 0\n  elif e1.c > e2.c:\n    return 1\n  else:\n    return -1\n\nproc minimum_spanning_tree(n: int; es: seq[Edge]): seq[Edge] =\n  let es = es.sorted(compareEdgeByWeight)\n\n  var uft = initUnionFindTree(n)\n  var ans = newSeq[Edge](0)\n  for e in es:\n    if ans.len() >= n - 1:\n      break\n    if not uft.same(e.a, e.b):\n      ans.add(e)\n      uft.union(e.a, e.b)\n\n  return ans\n\nproc buildRootedTree(n: int; es: seq[Edge]): seq[Edge] =\n  var g = newSeq2[(int, int)](n, 0)\n  for e in es:\n    g[e.a].add((e.b, e.c))\n    g[e.b].add((e.a, e.c))\n\n  var ans = newSeq[Edge](n)\n  var stack = newSeq[int](0)\n  var used = newSeq[bool](n)\n  stack.add(0)\n  used[0] = true\n  ans[0] = (0, 0, 0)\n  while stack.len() != 0:\n    let v = stack.pop()\n    for e in g[v]:\n      if used[e[0]]:\n        continue\n      used[e[0]] = true\n      stack.add(e[0])\n      ans[e[0]] = (e[0], v, e[1])\n\n  return ans\n\nproc parent(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return u\n\nproc parentMaxEdge(pps: seq2[Edge]; v, i: int): int =\n  var u = v\n  var j = i\n\n  var ans = -1\n  var k = 0\n  while j != 0:\n    if (j and 1) != 0:\n      ans = max(ans, pps[k][u].c)\n      u = pps[k][u].b\n    j = j div 2\n    k += 1\n\n  return ans\n\nproc depth(pps: seq2[Edge]; v: int): int =\n  nibutanUb(-1, 2^12, it => parent(pps, v, it) == 0)\n\nproc lca(pps: seq2[Edge]; d: seq[int]; v, u: int): int =\n  var v = v\n  var u = u\n  if d[v] < d[u]:\n    swap(v, u)\n  v = parent(pps, v, d[v] - d[u])\n  let diff = nibutanUb(-1, 2^12, it => parent(pps, v, it) == parent(pps, u, it))\n  return parent(pps, v, diff)\n\nproc main() =\n  let (n, m) = readInt2()\n\n  var es = newSeq[Edge](m)\n  for i in 0..<m:\n    let (a, b, c) = readInt3()\n    es[i] = (a - 1, b - 1, c)\n\n  let q = readInt1()\n  var qs = newSeq[(int, int)](q)\n  for i in 0..<q:\n    let (s, t) = readInt2()\n    qs[i] = (s - 1, t - 1)\n\n  let mst = minimum_spanning_tree(n, es)\n  let mstSum = mst.reduceL(0, (acc, e) => (acc + e.c))\n\n  let ps = buildRootedTree(n, mst)\n  var pps = newSeq2[Edge](13, n)\n  pps[0] = ps\n  for i in 1..12:\n    for v in 0..<n:\n      let parent = pps[i - 1][pps[i - 1][v].b].b\n      let maxWeight = max(pps[i - 1][v].c, pps[i - 1][pps[i - 1][v].b].c)\n      pps[i][v] = (v, parent, maxWeight)\n\n  var d = newSeq[int](n)\n  for v in 0..<n:\n    d[v] = depth(pps, v)\n\n  for q in qs:\n    let a = lca(pps, d, q[0], q[1])\n    var ans = 0\n    ans = max(ans, parentMaxEdge(pps, q[0], d[q[0]] - d[a]))\n    ans = max(ans, parentMaxEdge(pps, q[1], d[q[1]] - d[a]))\n    echo mstSum - ans\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\n\nclass Unionfindtree:\n    def __init__(self, number):\n        self.par = [i for i in range(number)]\n        self.rank = [0] * (number)\n\n    def find(self, x):  # 親を探す\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):  # x,yを繋げる\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            self.par[px] = py\n        else:\n            self.par[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\n    def connect(self, x, y):  # 親が同じかみる\n        return self.find(x) == self.find(y)\n\n\n\nN,M=map(int,input().split())\ntable=[]\nfor i in range(M):\n    a,b,c=map(int,input().split())\n    a,b=a-1,b-1\n    table.append((c,a,b))\nQ=int(input())\nquery=[]\nfor i in range(Q):\n    s,t=map(int,input().split())\n    s,t=s-1,t-1\n    query.append((s,t))\nif Q>1:\n    sys.exit()\ntable.sort()\nT=Unionfindtree(N)\ns,t=query[0]\nT.union(s,t)\nans=0\nfor c,a,b in table:\n    if not T.connect(a,b):\n        ans+=c\n        T.union(a,b)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, raw_input().split())\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n            c1[v] = INF if p0[v] < 0 else max(c0[v], c0[p0[v]])\ninit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if (ds[v] - ds[u]) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    res = max(res, cs[0][u], cs[0][v])\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    try:\n        print su - solve(s-1, t-1)\n    except:\n        exit(0)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nfrom collections import deque\n\nclass Unionfindtree:\n    def __init__(self, number):\n        self.par = [i for i in range(number)]\n        self.rank = [0] * (number)\n\n    def find(self, x):  # 親を探す\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):  # x,yを繋げる\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            self.par[px] = py\n        else:\n            self.par[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\n    def connect(self, x, y):  # 親が同じかみる\n        return self.find(x) == self.find(y)\n\n\nN,M=map(int,input().split())\ntable=[[int(i) for i in input().split()]for i in range(M)]\nQ=int(input())\nquery=[[int(i) for i in input().split()]for i in range(Q)]\ntable = sorted(table,key=itemgetter(2))\nif N<3:\n    for a,b in query:\n        print(0)\n    sys.exit()\nT=Unionfindtree(N)\nsear=Unionfindtree(2*N-1)\nans=0\nvalue=[0]*(N+N-1)\ndp=[[0]*(2*N-1) for i in range(16)]\ntable2=[[] for i in range(2*N-1)]\ns=0\nfor i in range(M):\n    a,b,c=table[i]\n    a,b=a-1,b-1\n    if not T.connect(a,b):\n        ans+=c\n        T.union(a,b)\n        value[s+N]=c\n        le=a\n        ri=b\n        for j in range(s+N,N-1,-1):\n            if sear.connect(a,j):\n                le=j\n                break\n        for j in range(s+N,N-1,-1):\n            if sear.connect(b,j):\n                ri=j\n                break\n        table2[s+N].append(le)\n        table2[s+N].append(ri)\n        sear.union(le,s+N)\n        sear.union(ri,s+N)\n        s+=1\n    if s==N-1:\n        break\n\nH=deque()\nH.append((0,2*N-2))\ndepth=[-1]*(2*N-1)\ndepth[2*N-2]=0\nwhile H:\n    dep,pt=H.popleft()\n    for p in table2[pt]:\n        H.append((dep+1,p))\n        depth[p]=dep+1\n        dp[0][p]=pt\n#print(table2)\n#print(depth,dp[0])\n\nfor k in range(1,16):\n    for x in range(2*N-1):\n        dp[k][x]=dp[k-1][dp[k-1][x]]\ndef LCA(s,t):\n    if depth[s]>depth[t]:\n        s,t=t,s\n    for k in range(16):\n        if ((depth[t]-depth[s] )>>k) & 1:\n            t = dp[k][t]\n    if s==t:\n        return s\n    for k in range(15,-1,-1):\n        if dp[k][s]!=dp[k][t]:\n            s=dp[k][s]\n            t=dp[k][t]\n    return dp[0][s]\n\nfor s,t in query:\n    s,t=s-1,t-1\n    pa=LCA(s,t)\n    #print(pa,value[pa])\n    print(ans-value[pa])\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\n\nclass Unionfindtree:\n    def __init__(self, number):\n        self.par = [i for i in range(number)]\n        self.rank = [0] * (number)\n\n    def find(self, x):  # 親を探す\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):  # x,yを繋げる\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            self.par[px] = py\n        else:\n            self.par[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\n    def connect(self, x, y):  # 親が同じかみる\n        return self.find(x) == self.find(y)\n\n\n\nN,M=map(int,input().split())\ntable=[[int(i) for i in input().split()]for i in range(M)]\nQ=int(input())\nquery=[[int(i) for i in input().split()]for i in range(Q)]\nif Q>1:\n    sys.exit()\ntable = sorted(table,key=itemgetter(2))\nT=Unionfindtree(N)\ns,t=query[0]\ns,t=s-1,t-1\nT.union(s,t)\nans=0\nfor a,b,c in table:\n    a,b=a-1,b-1\n    if not T.connect(a,b):\n        ans+=c\n        T.union(a,b)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "k = input()\ns = raw_input()\n\nleft = 0; right = int(s)\nwhile 1:\n    mid = (left + right) / 2\n    cnt = 0\n    now = 0\n    for c in s:\n        now = 10*now + int(c)\n        if now > mid:\n            cnt += 1\n            now = int(c)\n            if now > mid:\n                cnt = 100003\n                break\n    if cnt > k:\n        if left == mid:\n            break\n        left = mid\n    else:\n        if right == mid:\n            break\n        right = mid\nprint left+1\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom operator import itemgetter\nfrom collections import deque\n\nclass Unionfindtree:\n    def __init__(self, number):\n        self.par = [i for i in range(number)]\n        self.rank = [0] * (number)\n\n    def find(self, x):  # 親を探す\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):  # x,yを繋げる\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            self.par[px] = py\n        else:\n            self.par[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\n    def connect(self, x, y):  # 親が同じかみる\n        return self.find(x) == self.find(y)\n\ndef dfs(s):\n    H=deque()\n    visit=[False]*N\n    H.append((0,s))\n    visit[s]=True\n    L=[0]*N\n    while H:\n        pt,x=H.popleft()\n        for y,cost in tree[x]:\n            if visit[y]:\n                continue\n            c=max(cost,pt)\n            H.append((c,y))\n            visit[y]=True\n            L[y]=c\n    return L\n\n\n\nN,M=map(int,input().split())\ntable=[[int(i) for i in input().split()]for i in range(M)]\nQ=int(input())\nquery=[[int(i) for i in input().split()]for i in range(Q)]\ntable = sorted(table,key=itemgetter(2))\nT=Unionfindtree(N)\n#s,t=query[0]\n#s,t=s-1,t-1\n#T.union(s,t)\nans=0\ntree=[[] for i in range(N)]\nfor i in range(M):\n    a,b,c=table[i]\n    a,b=a-1,b-1\n    if not T.connect(a,b):\n        ans+=c\n        T.union(a,b)\n        tree[a].append((b,c))\n        tree[b].append((a,c))\nM=[[0]*N for i in range(N)]\nfor i in range(N):\n    M[i]=dfs(i)\nfor s,t in query:\n    s,t=s-1,t-1\n    print(ans-M[s][t])\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nn, m = map(int, raw_input().split())\nsys.setrecursionlimit(100000)\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n            c1[v] = INF if p0[v] < 0 else max(c0[v], c0[p0[v]])\ninit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if (ds[v] - ds[u]) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    res = max(res, cs[0][u], cs[0][v])\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, raw_input().split())\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n            c1[v] = INF if p0[v] < 0 else max(c0[v], c0[p0[v]])\ninit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if (ds[v] - ds[u]) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    res = max(res, cs[0][u], cs[0][v])\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, raw_input().split())\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n        if i:\n            for v in xrange(n):\n                c1[v] = INF if c0[v] == INF else max(c0[v], c0[p0[v]])\ninit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if ((ds[v] - ds[u]) >> k & 1):\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "inputs=lambda:map(int,raw_input().split())\nn, m = inputs()\nes = [inputs()[::-1] for i in xrange(m)]\nes.sort()\nparent = range(n+1)\ndef root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x)\n    py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nsu = 0\ng = [[] for i in xrange(n+1)]\nfor c, a, b in es:\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append((b, c))\n        g[b].append((a, c))\n\nimport sys\nsys.setrecursionlimit(100000)\ndic = {}\ndef dfs(s, v, prev, cost):\n    dic[s,v] = cost\n    for e, c in g[v]:\n        if prev != e:\n            dfs(s, e, v, max(cost, c))\nfor i in xrange(n):\n    dfs(i+1, i+1, -1, 0)\nfor i in xrange(input()):\n    s, t = inputs()\n    print su-dic[s,t]\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, raw_input().split())\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n            c1[v] = INF if p0[v] < 0 else max(c0[v], c0[p0[v]])\ntry:\n    init(0)\nexcept:\n    exit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if (ds[v] - ds[u]) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    res = max(res, cs[0][u], cs[0][v])\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "n, m = map(int, raw_input().split())\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n            c1[v] = INF if c0[v] == INF else max(c0[v], c0[p0[v]])\ninit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if (ds[v] - ds[u]) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    res = max(res, cs[0][u], cs[0][v])\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "INF = 10**7\nclass PPUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.time = [INF] * n\n        self.number_time = [[0] for _ in [None] * n]\n        self.number_dots = [[1] for _ in [None] * n]\n\n    def find(self, x, t):\n        while self.time[x] <= t:\n            x = self.parents[x]\n        return x\n\n    def union(self, x, y, t):\n        x = self.find(x, t)\n        y = self.find(y, t)\n        if x == y:\n            return 0\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.number_time[x] += [t]\n        self.number_dots[x] += [-self.parents[x]]\n        self.time[y] = t\n        return 1\n\n    def size(self, x, y, t):\n        x = self.find(x, t)\n        y = self.find(y, t)\n        a = self.number_dots[x][bisect_left(self.number_time[x], t) - 1]\n        if x != y:\n            a += self.number_dots[y][bisect_left(self.number_time[y], t) - 1]\n        return a\n\n    def same(self, x, y, t = 0):\n        if x == y:\n            return t\n        if self.time[x] == self.time[y] == INF:\n            return -1\n        if self.time[x] > self.time[y]:\n            x, y = y, x\n        return self.same(self.parents[x], y, self.time[x])\n\n(n, m), *q = [[*map(int, o.split())] for o in open(0)]\nUF = PPUnionFind(n)\nE = sorted(q[:m], key = lambda t: t[2])\nans = 0\nfor a, b, c in E:\n    if UF.union(a - 1, b - 1, c):\n        ans += c\nfor s, t in q[m+1:]:\n    print(ans - UF.same(s - 1, t - 1))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nn, m = map(int, raw_input().split())\nsys.setrecursionlimit(10000)\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()\nrn = range(n)\nrnl = range(nl)\nrnl1 = range(nl-1)\nps = [[0]*n for i in rnl]\ncs = [[0]*n for i in rnl]\nds = [0]*n\nINF = 10**9+7\np0 = ps[0]\nc0 = cs[0]\ndef dfs(v, p, d):\n    p0[v] = p\n    c0[v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndfs(0, -1, 0)\nfor i in rnl1:\n    p1 = ps[i+1]; p0 = ps[i]\n    c1 = cs[i+1]; c0 = cs[i]\n    for v in rn:\n        p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n        c1[v] = INF if p0[v] < 0 else max(c0[v], c0[p0[v]])\ncache = {}\ndef solve(u, v):\n    if ds[u] > ds[v]:\n        u,v = v,u\n    if (u, v) in cache:\n        return cache(u, v)\n    res = 0\n    du = ds[u]\n    for k in rnl:\n        if (ds[v] - du) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u!=v:\n        for k in reversed(rnl):\n            pk = ps[k]\n            if pk[u] != pk[v]:\n                ck = cs[k]\n                res = max(res, ck[u], ck[v])\n                u = pk[u]; v = pk[v]\n        res = max(res, c0[u], c0[v])\n    cache[u, v] = cache[v, u] = res\n    return res\nq = input()\nraw_input = sys.stdin.readline\nwhile q:\n    q -= 1\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nn, m = map(int, raw_input().split())\nsys.setrecursionlimit(10000)\nque = []\nfor i in xrange(m):\n    a, b, c = map(int, raw_input().split())\n    que.append((c, a, b))\nque.sort()\np = range(n)\ndef root(x):\n    if x!=p[x]: x=p[x]=root(p[x])\n    return x\ndef unite(x, y):\n    px = p[x]\n    py = p[y]\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\nsu = 0\ng = [[] for i in xrange(n)]\ndic = {(0, -1): 0}\nfor c, a, b in que:\n    a -= 1; b -= 1\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append(b)\n        g[b].append(a)\n        dic[a, b] = dic[b, a] = c\n\nnl = n.bit_length()+20\nps = [[0]*n for i in xrange(nl)]\ncs = [[0]*n for i in xrange(nl)]\nds = [0]*n\nINF = 10**9+7\ndef dfs(v, p, d):\n    ps[0][v] = p\n    cs[0][v] = dic[v,p]\n    ds[v] = d\n    for e in g[v]:\n        if e!=p:dfs(e, v, d+1)\ndef init(s):\n    dfs(s, -1, 0)\n    for i in xrange(nl-1):\n        p1 = ps[i+1]; p0 = ps[i]\n        c1 = cs[i+1]; c0 = cs[i]\n        for v in xrange(n):\n            p1[v] = -1 if p0[v] < 0 else p0[p0[v]]\n            c1[v] = INF if p0[v] < 0 else max(c0[v], c0[p0[v]])\ninit(0)\ndef solve(u, v):\n    res = 0\n    if ds[u] > ds[v]:\n        u,v = v,u\n    for k in xrange(nl-1):\n        if (ds[v] - ds[u]) >> k & 1:\n            res = max(res, cs[k][v])\n            v = ps[k][v]\n    if u==v: return res\n    for k in xrange(nl-1, -1, -1):\n        pk = ps[k]\n        if pk[u] != pk[v]:\n            res = max(res, cs[k][u], cs[k][v])\n            u = pk[u]; v = pk[v]\n    res = max(res, cs[0][u], cs[0][v])\n    return res\n\nfor i in xrange(input()):\n    s, t = map(int, raw_input().split())\n    print su - solve(s-1, t-1)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nsys.setrecursionlimit(10**5)\n\nN, M = map(int, input().split())\nE = []\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    E.append((c, a-1, b-1))\nE.sort()\n\n*p, = range(N)\ndef root(x):\n    if x == p[x]:\n        return x\n    p[x] = y = root(p[x])\n    return y\n\nL = 2*N-1\nG = [[]] * L\nC = [0]*L\n*lb, = range(N)\ncur = N\n\ns = 0\nfor c, a, b in E:\n    pa = root(a); pb = root(b)\n    if pa == pb:\n        continue\n    s += c\n    chds = [lb[pa], lb[pb]]\n    if pa < pb:\n        p[pb] = pa\n        lb[pa] = cur\n    else:\n        p[pa] = pb\n        lb[pb] = cur\n    C[cur] = c\n    G[cur] = chds\n    cur += 1\n\nH = [0]*L\nprv = [-1]*L\ndef dfs(v):\n    s = 1; heavy = -1; m = 0\n    for w in G[v]:\n        prv[w] = v\n        c = dfs(w)\n        if m < c:\n            heavy = w\n            m = c\n        s += c\n    H[v] = heavy\n    return s\ndfs(L-1)\n\nSS = []\nD = []\nLB = [0]*L\nI = [0]*L\nque = deque([(L-1, 0)])\nwhile que:\n    v, d = que.popleft()\n    S = []\n    k = len(SS)\n    while v != -1:\n        I[v] = len(S)\n        S.append(v)\n        LB[v] = k\n        h = H[v]\n        for w in G[v]:\n            if h == w:\n                continue\n            que.append((w, d+1))\n        v = h\n    SS.append(S)\n    D.append(d)\n\n\ndef query(u, v):\n    lu = LB[u]; lv = LB[v]\n    dd = D[lv] - D[lu]\n    if dd < 0:\n        lu, lv = lv, lu\n        v, u = u, v\n        dd = -dd\n\n    for _ in range(dd):\n        v = prv[SS[lv][0]]\n        lv = LB[v]\n\n    while lu != lv:\n        u = prv[SS[lu][0]]\n        lu = LB[u]\n\n        v = prv[SS[lv][0]]\n        lv = LB[v]\n\n    return u if I[u] < I[v] else v\n\n\ndef gen():\n    Q = int(input())\n    for i in range(Q):\n        u, v = map(int, input().split())\n        w = query(u-1, v-1)\n        yield \"%d\\n\" % (s - C[w])\nans = list(gen())\nsys.stdout.writelines(ans)"
  },
  {
    "language": "Python",
    "code": "INF = 10**7\nclass PPUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.time = [INF] * n\n        self.number_time = [[0] for _ in [None] * n]\n        self.number_dots = [[1] for _ in [None] * n]\n\n    def find(self, x, t):\n        while self.time[x] <= t:\n            x = self.parents[x]\n        return x\n\n    def union(self, x, y, t):\n        x = self.find(x, t)\n        y = self.find(y, t)\n        if x == y:\n            return 0\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.number_time[x] += [t]\n        self.number_dots[x] += [-self.parents[x]]\n        self.time[y] = t\n        return t\n\n    def size(self, x, y, t):\n        x = self.find(x, t)\n        y = self.find(y, t)\n        a = self.number_dots[x][bisect_left(self.number_time[x], t) - 1]\n        if x != y:\n            a += self.number_dots[y][bisect_left(self.number_time[y], t) - 1]\n        return a\n\n    def same(self, x, y, t = 0):\n        if x == y:\n            return t\n        if self.time[x] == self.time[y] == INF:\n            return -1\n        if self.time[x] > self.time[y]:\n            x, y = y, x\n        return self.same(self.parents[x], y, self.time[x])\n\n(n, m), *q = [[*map(int, o.split())] for o in open(0)]\nUF = PPUnionFind(n)\nans = sum(UF.union(a - 1, b - 1, c) for a, b, c in sorted(q[:m], key = lambda t: t[2]))\nfor s, t in q[m+1:]:\n    print(ans - UF.same(s - 1, t - 1))"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\ndef solve():\n    s, t = map(int, input().split())\n    visited = [0] * N\n    visited[s-1] = 1\n    visited[t-1] = 1\n    cost = 0\n\n    vss = [v for v in range(N) if visited[v] == 1]\n    vts = [v for v in range(N) if visited[v] == 0]\n    while vts:\n        mc = 10 ** 9 + 1\n        mvt = None\n        for vs in vss:\n            for vt in vts:\n                if edges[vs][vt] is not None and edges[vs][vt] < mc:\n                    mc = edges[vs][vt]\n                    mvt = vt\n        vss.append(mvt)\n        vts.remove(mvt)\n        cost += mc\n    return cost\n\n\nN, M = map(int, input().split())\n\nedges = [[None] * N for _ in range(N)]\nfor i in range(M):\n    a, b, c = map(int, input().split())\n    edges[a-1][b-1] = c\n    edges[b-1][a-1] = c\n\nQ = int(input())\nfor i in range(Q):\n    print(solve())\n"
  },
  {
    "language": "Python",
    "code": "inputs=lambda:map(int,raw_input().split())\nn, m = inputs()\nes = [inputs() for i in xrange(m)]\nes.sort(key=lambda x:x[-1])\nparent = range(n+1)\ndef root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x)\n    py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nsu = 0\ng = [[] for i in xrange(n+1)]\nfor a, b, c in es:\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append((b, c))\n        g[b].append((a, c))\n\nimport sys\nsys.setrecursionlimit(100000)\ndic = {}\ndef dfs(s, v, prev, cost):\n    dic[s,v] = cost\n    for e, c in g[v]:\n        if prev != e:\n            dfs(s, e, v, max(cost, c))\nfor i in xrange(n):\n    dfs(i+1, i+1, -1, 0)\nfor i in xrange(input()):\n    s, t = inputs()\n    print su-dic[s,t]\n"
  },
  {
    "language": "Python",
    "code": "INF = 10**7\nclass PPUnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n        self.time = [INF] * n\n        self.number_time = [[0] for _ in [None] * n]\n        self.number_dots = [[1] for _ in [None] * n]\n\n    def find(self, x, t):\n        while self.time[x] <= t:\n            x = self.parents[x]\n        return x\n\n    def union(self, x, y, t):\n        x = self.find(x, t)\n        y = self.find(y, t)\n        if x == y:\n            return 0\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n        self.number_time[x] += [t]\n        self.number_dots[x] += [-self.parents[x]]\n        self.time[y] = t\n        return 1\n\n    def size(self, x, y, t):\n        x = self.find(x, t)\n        y = self.find(y, t)\n        a = self.number_dots[x][bisect_left(self.number_time[x], t) - 1]\n        if x != y:\n            a += self.number_dots[y][bisect_left(self.number_time[y], t) - 1]\n        return a\n\n    def same(self, x, y, t = 0):\n        if x == y:\n            return t\n        if self.time[x] == self.time[y] == INF:\n            return -1\n        if self.time[x] > self.time[y]:\n            x, y = y, x\n        return self.same(self.parents[x], y, self.time[x])\n\n(n, m), *q = [[*map(int, o.split())] for o in open(0)]\nUF = PPUnionFind(n)\nE = sorted(q[:m], key = lambda t: t[2])\nans = 0\nfor a, b, c in E:\n    if UF.union(a - 1, b - 1, c):\n        ans += c\nfor s, t in q[m+1:]:\n    print(ans - UF.same(s - 1, t - 1))"
  },
  {
    "language": "Python",
    "code": "inputs=lambda:map(int,raw_input().split())\nn, m = inputs()\nes = [inputs() for i in xrange(m)]\nes.sort(key=lambda x:x[2])\nparent = range(n+1)\ndef root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x)\n    py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nsu = 0\ng = [[] for i in xrange(n+1)]\nfor c, a, b in es:\n    if root(a) != root(b):\n        unite(a, b)\n        su += c\n        g[a].append((b, c))\n        g[b].append((a, c))\n\nimport sys\nsys.setrecursionlimit(100000)\ndic = {}\ndef dfs(s, v, prev, cost):\n    dic[s,v] = cost\n    for e, c in g[v]:\n        if prev != e:\n            dfs(s, e, v, max(cost, c))\nfor i in xrange(n):\n    dfs(i+1, i+1, -1, 0)\nfor i in xrange(input()):\n    s, t = inputs()\n    print su-dic[s,t]\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// ここまで\n\nuse std::io::Write;\n\nfn root(p: &Vec<i32>, mut x: usize) -> usize {\n    while p[x] >= 0 {\n        x = p[x] as usize;\n    }\n    x\n}\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        m: usize,\n        e: [(usize1, usize1, u64); m],\n        q: usize,\n        p: [(usize1, usize1); q],\n    }\n    let mut e = e;\n    e.sort_by(|a, b| a.2.cmp(&b.2));\n    let mut parent = vec![-1; n];\n    let mut cost = vec![1000000000 + 1; n];\n    let mut sum = 0;\n    for (a, b, c) in e {\n        let mut a = root(&parent, a);\n        let mut b = root(&parent, b);\n        if a == b {\n            continue;\n        }\n        sum += c;\n        if parent[a] > parent[b] {\n            std::mem::swap(&mut a, &mut b);\n        }\n        parent[a] += parent[b];\n        parent[b] = a as i32;\n        cost[b] = c;\n    }\n    for (mut s, mut t) in p {\n        let mut ans = 0;\n        while s != t {\n            if cost[s] < cost[t] {\n                ans = cost[s];\n                s = parent[s] as usize;\n            } else {\n                ans = cost[t];\n                t = parent[t] as usize;\n            }\n        }\n        writeln!(out, \"{}\", sum - ans).unwrap();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\n\nfn root(parent: &[usize], mut x: usize) -> usize {\n    while parent[x] != x {\n        x = parent[x];\n    }\n    x\n}\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        m: usize,\n        e: [(usize1, usize1, u64); m],\n        q: usize,\n        p: [(usize1, usize1); q],\n    }\n    let mut parent = Vec::with_capacity(n);\n    let mut size = Vec::with_capacity(n);\n    let mut cost = Vec::with_capacity(n);\n    for i in 0..n {\n        parent.push(i);\n        size.push(1);\n        cost.push(1_000_000_000 + 1);\n    }\n    let mut e = e;\n    e.sort_by_key(|e| e.2);\n    let mut sum = 0;\n    for (a, b, c) in e {\n        let mut a = root(&parent, a);\n        let mut b = root(&parent, b);\n        if a == b {\n            continue;\n        }\n        if size[a] < size[b] {\n            std::mem::swap(&mut a, &mut b);\n        }\n        size[a] += size[b];\n        parent[b] = a;\n        cost[b] = c;\n        sum += c;\n    }\n    for (mut a, mut b) in p {\n        let mut ans = 0;\n        while a != b {\n            if cost[a] < cost[b] {\n                ans = cost[a];\n                a = parent[a];\n            } else {\n                ans = cost[b];\n                b = parent[b];\n            }\n        }\n        writeln!(out, \"{}\", sum - ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  }
]