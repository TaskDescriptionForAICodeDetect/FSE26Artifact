[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 200005\n#define MAX_M 200005\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else if (rank[px] > rank[py]) {\n        parent[py] = px;\n    } else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}\n\nint compareEdge(const void* a, const void* b) {\n    Edge* edge1 = (Edge*)a;\n    Edge* edge2 = (Edge*)b;\n    return edge1->w - edge2->w;\n}\n\nint main() {\n    int N, M, Q;\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    Edge edges[MAX_M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n    \n    qsort(edges, M, sizeof(Edge), compareEdge);\n    \n    while (Q--) {\n        int S, T;\n        scanf(\"%d %d\", &S, &T);\n        \n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        \n        int totalWeight = 0;\n        \n        for (int i = 0; i < M; i++) {\n            int u = edges[i].u, v = edges[i].v, w = edges[i].w;\n            \n            if (find(u) != find(v)) {\n                if (find(S) != find(u) && find(S) != find(v) &&\n                    find(T) != find(u) && find(T) != find(v)) {\n                    unionSet(u, v);\n                    totalWeight += w;\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", totalWeight);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100000\n#define MAX_M 200000\n#define MAX_LOG 20\n\ntypedef struct {\n    int u, v, c;\n} Edge;\n\ntypedef struct {\n    int to, cost;\n} AdjNode;\n\nEdge edges[MAX_M];\nAdjNode adj[MAX_N * 2];\nint parent[MAX_N * 2][MAX_LOG];\nint depth[MAX_N * 2];\nint min_cost[MAX_N * 2][MAX_LOG];\nint uf_parent[MAX_N * 2];\nint rank[MAX_N * 2];\nint N, M, Q;\nint tree_size;\n\nint compare_edges(const void *a, const void *b) {\n    return ((Edge *)a)->c - ((Edge *)b)->c;\n}\n\nint uf_find(int x) {\n    if (uf_parent[x] != x) {\n        uf_parent[x] = uf_find(uf_parent[x]);\n    }\n    return uf_parent[x];\n}\n\nvoid uf_union(int x, int y, int c) {\n    x = uf_find(x);\n    y = uf_find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n        int tmp = x;\n        x = y;\n        y = tmp;\n    }\n    uf_parent[y] = x;\n    if (rank[x] == rank[y]) rank[x]++;\n    adj[tree_size].to = x;\n    adj[tree_size].cost = 0;\n    adj[tree_size + 1].to = y;\n    adj[tree_size + 1].cost = 0;\n    parent[x][0] = tree_size / 2 + N;\n    parent[y][0] = tree_size / 2 + N;\n    min_cost[x][0] = c;\n    min_cost[y][0] = c;\n    tree_size += 2;\n}\n\nvoid build_mst() {\n    qsort(edges, M, sizeof(Edge), compare_edges);\n    for (int i = 1; i <= 2 * N - 1; i++) {\n        uf_parent[i] = i;\n        rank[i] = 0;\n    }\n    tree_size = 0;\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int c = edges[i].c;\n        uf_union(u, v, c);\n    }\n}\n\nvoid dfs(int v, int p, int d) {\n    depth[v] = d;\n    for (int i = 1; i < MAX_LOG; i++) {\n        if (parent[v][i - 1] == -1) break;\n        parent[v][i] = parent[parent[v][i - 1]][i - 1];\n        min_cost[v][i] = (min_cost[v][i - 1] < min_cost[parent[v][i - 1]][i - 1]) ? min_cost[v][i - 1] : min_cost[parent[v][i - 1]][i - 1];\n    }\n    for (int i = 0; adj[v].to != 0; i++) {\n        int to = adj[v].to;\n        if (to == p) continue;\n        parent[to][0] = v;\n        min_cost[to][0] = adj[v].cost;\n        dfs(to, v, d + 1);\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int tmp = u;\n        u = v;\n        v = tmp;\n    }\n    int res = INT_MAX;\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != -1 && depth[parent[u][i]] >= depth[v]) {\n            if (min_cost[u][i] < res) res = min_cost[u][i];\n            u = parent[u][i];\n        }\n    }\n    if (u == v) return res;\n    for (int i = MAX_LOG - 1; i >= 0; i--) {\n        if (parent[u][i] != parent[v][i]) {\n            int cost = (min_cost[u][i] < min_cost[v][i]) ? min_cost[u][i] : min_cost[v][i];\n            if (cost < res) res = cost;\n            u = parent[u][i];\n            v = parent[v][i];\n        }\n    }\n    int cost = (min_cost[u][0] < min_cost[v][0]) ? min_cost[u][0] : min_cost[v][0];\n    if (cost < res) res = cost;\n    return res;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].c);\n    }\n    build_mst();\n    for (int i = 0; i < 2 * N; i++) {\n        for (int j = 0; j < MAX_LOG; j++) {\n            parent[i][j] = -1;\n            min_cost[i][j] = INT_MAX;\n        }\n    }\n    dfs(2 * N - 2, -1, 0);\n    while (Q--) {\n        int S, T;\n        scanf(\"%d %d\", &S, &T);\n        if (uf_find(S) != uf_find(T)) {\n            printf(\"-1\\n\");\n            continue;\n        }\n        printf(\"%d\\n\", lca(S, T));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef tuple<ll, int, int> Edge;\n\nstruct UnionFind {\n    vector<int> parent;\n    UnionFind(int n) : parent(n, -1) {}\n    int find(int x) {\n        if (parent[x] < 0) return x;\n        return parent[x] = find(parent[x]);\n    }\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return false;\n        if (parent[x] > parent[y]) swap(x, y);\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, M;\n    cin >> N >> M;\n    vector<Edge> edges;\n    for (int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        --a; --b;\n        edges.emplace_back(c, a, b);\n    }\n    sort(edges.begin(), edges.end());\n\n    int Q;\n    cin >> Q;\n    vector<int> S(Q), T(Q);\n    for (int i = 0; i < Q; ++i) {\n        cin >> S[i] >> T[i];\n        --S[i]; --T[i];\n    }\n\n    vector<ll> res(Q, LLONG_MAX);\n    vector<int> low(Q, 0), high(Q, M - 1);\n\n    while (true) {\n        bool updated = false;\n        vector<vector<int>> check(M);\n        for (int q = 0; q < Q; ++q) {\n            if (low[q] <= high[q]) {\n                int mid = (low[q] + high[q]) / 2;\n                check[mid].push_back(q);\n                updated = true;\n            }\n        }\n        if (!updated) break;\n\n        UnionFind uf(2 * N);\n        for (int mid = 0; mid < M; ++mid) {\n            ll c = get<0>(edges[mid]);\n            int a = get<1>(edges[mid]);\n            int b = get<2>(edges[mid]);\n            uf.unite(a, b + N);\n            uf.unite(b, a + N);\n            for (int q : check[mid]) {\n                if (uf.find(S[q]) == uf.find(T[q]) || uf.find(S[q]) == uf.find(T[q] + N)) {\n                    res[q] = c;\n                    high[q] = mid - 1;\n                } else {\n                    low[q] = mid + 1;\n                }\n            }\n        }\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        cout << res[q] << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:31:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        int to, weight;\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int vertex;\n        long cost;\n        Pair(int vertex, long cost) {\n            this.vertex = vertex;\n            this.cost = cost;\n        }\n        public int compareTo(Pair other) {\n            return Long.compare(this.cost, other.cost);\n        }\n    }\n\n    static void dijkstra(int start, long[] dist, List<List<Edge>> graph) {\n        Arrays.fill(dist, Long.MAX_VALUE);\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\n        dist[start] = 0;\n        pq.add(new Pair(start, 0));\n        while (!pq.isEmpty()) {\n            Pair p = pq.poll();\n            int u = p.vertex;\n            if (dist[u] < p.cost) continue;\n            for (Edge e : graph.get(u)) {\n                int v = e.to;\n                long newDist = dist[u] + e.weight;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.add(new Pair(v, newDist));\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().split(\" \");\n        int N = Integer.parseInt(parts[0]);\n        int M = Integer.parseInt(parts[1]);\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            parts = br.readLine().split(\" \");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            int c = Integer.parseInt(parts[2]);\n            graph.get(a).add(new Edge(b, c));\n            graph.get(b).add(new Edge(a, c));\n        }\n\n        parts = br.readLine().split(\" \");\n        int Q = Integer.parseInt(parts[0]);\n\n        long[] distS = new long[N + 1];\n        long[] distT = new long[N + 1];\n\n        for (int i = 0; i < Q; i++) {\n            parts = br.readLine().split(\" \");\n            int S = Integer.parseInt(parts[0]);\n            int T = Integer.parseInt(parts[1]);\n\n            dijkstra(S, distS, graph);\n            dijkstra(T, distT, graph);\n\n            long minTotal = Long.MAX_VALUE;\n            for (int u = 1; u <= N; u++) {\n                long total = distS[u] + distT[u];\n                if (total < minTotal) {\n                    minTotal = total;\n                }\n            }\n            System.out.println(minTotal);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:32:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class GraphProblem {\n    static int N, M, Q;\n    static List<Edge> edges;\n    static int[] parent;\n\n    static class Edge implements Comparable<Edge> {\n        int u, v, weight;\n        \n        public Edge(int u, int v, int weight) {\n            this.u = u;\n            this.v = v;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n        }\n    }\n\n    static int minimumSpanningTree(Set<Integer> sources, Set<Integer> destinations) {\n        Collections.sort(edges);\n        parent = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n        }\n        \n        int totalWeight = 0;\n        for (Edge edge : edges) {\n            int u = edge.u, v = edge.v;\n            \n            boolean uReachable = sources.contains(u) || destinations.contains(u);\n            boolean vReachable = sources.contains(v) || destinations.contains(v);\n            \n            if (find(u) != find(v) && (uReachable || vReachable)) {\n                union(u, v);\n                totalWeight += edge.weight;\n            }\n        }\n        \n        return totalWeight;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        Q = Integer.parseInt(st.nextToken());\n        \n        edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            int c = Integer.parseInt(st.nextToken());\n            edges.add(new Edge(a, b, c));\n        }\n        \n        for (int i = 0; i < Q; i++) {\n            st = new StringTokenizer(br.readLine());\n            int S = Integer.parseInt(st.nextToken());\n            int T = Integer.parseInt(st.nextToken());\n            \n            Set<Integer> sources = new HashSet<>();\n            sources.add(S);\n            \n            Set<Integer> destinations = new HashSet<>();\n            destinations.add(T);\n            \n            System.out.println(minimumSpanningTree(sources, destinations));\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:32:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent, rank;\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        parent[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int N, M, Q;\n    cin >> N >> M;\n    \n    vector<tuple<int, int, int>> edges(M);\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges[i] = {c, a-1, b-1};\n    }\n    \n    sort(edges.begin(), edges.end());\n    \n    cin >> Q;\n    \n    while (Q--) {\n        int S, T;\n        cin >> S >> T;\n        S--; T--;\n        \n        UnionFind uf(N);\n        int total_weight = 0;\n        \n        for (auto [w, u, v] : edges) {\n            if (uf.find(S) == uf.find(T)) break;\n            \n            if (uf.find(u) != uf.find(S) && uf.find(u) != uf.find(T) &&\n                uf.find(v) != uf.find(S) && uf.find(v) != uf.find(T)) {\n                uf.unite(u, v);\n                total_weight += w;\n            }\n        }\n        \n        for (int i = 0; i < N; i++) {\n            if (uf.find(i) != uf.find(S) && uf.find(i) != uf.find(T)) {\n                for (auto [w, u, v] : edges) {\n                    if ((uf.find(u) == uf.find(S) || uf.find(u) == uf.find(T)) &&\n                        (uf.find(v) == uf.find(i) || uf.find(v) == uf.find(i))) {\n                        uf.unite(u, v);\n                        total_weight += w;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        cout << total_weight << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        root_u = self.find(u)\n        root_v = self.find(v)\n        if root_u != root_v:\n            if self.rank[root_u] < self.rank[root_v]:\n                self.parent[root_u] = root_v\n            elif self.rank[root_u] > self.rank[root_v]:\n                self.parent[root_v] = root_u\n            else:\n                self.parent[root_v] = root_u\n                self.rank[root_u] += 1\n            return True\n        return False\n\ndef find_min_weight(N, M, edges, queries):\n    edges.sort(key=lambda x: x[2])\n    results = []\n    \n    for s, t in queries:\n        uf = UnionFind(N + 1)\n        total_weight = 0\n\n        for u, v, w in edges:\n            if uf.union(u, v):\n                total_weight += w\n\n            if uf.find(s) == uf.find(t):\n                break\n        \n        results.append(total_weight if uf.find(s) == uf.find(t) else -1)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    Q = int(input())\n    queries = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    results = find_min_weight(N, M, edges, queries)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 15:37:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimumEdgeSubset {\n\n    static class Edge implements Comparable<Edge> {\n        int u, v, weight;\n        Edge(int u, int v, int weight) {\n            this.u = u;\n            this.v = v;\n            this.weight = weight;\n        }\n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    static class DSU {\n        int[] parent, rank;\n        DSU(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) parent[i] = i;\n        }\n        int find(int x) {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        }\n        boolean union(int x, int y) {\n            int rootX = find(x), rootY = find(y);\n            if (rootX == rootY) return false;\n            if (rank[rootX] > rank[rootY]) parent[rootY] = rootX;\n            else if (rank[rootX] < rank[rootY]) parent[rootX] = rootY;\n            else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n    }\n    \n    public static int findMinimumWeight(int n, List<Edge> edges, int s, int t) {\n        edges.sort(Comparator.naturalOrder());\n        DSU dsuS = new DSU(n);\n        DSU dsuT = new DSU(n);\n        \n        dsuS.union(s, 0);\n        dsuT.union(t, 0);\n        \n        int totalWeight = 0;\n        \n        for (Edge edge : edges) {\n            boolean addedInS = dsuS.find(edge.u) != dsuS.find(edge.v);\n            boolean addedInT = dsuT.find(edge.u) != dsuT.find(edge.v);\n            \n            if (addedInS || addedInT) {\n                if (addedInS) dsuS.union(edge.u, edge.v);\n                if (addedInT) dsuT.union(edge.u, edge.v);\n                totalWeight += edge.weight;\n            }\n            if (dsuS.find(0) == dsuS.find(s) && dsuT.find(0) == dsuT.find(t)) {\n                break;\n            }\n        }\n        \n        return totalWeight;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<Edge> edges = new ArrayList<>();\n        \n        for (int i = 0; i < M; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            int c = scanner.nextInt();\n            edges.add(new Edge(a, b, c));\n        }\n        \n        int Q = scanner.nextInt();\n        for (int i = 0; i < Q; i++) {\n            int S = scanner.nextInt() - 1;\n            int T = scanner.nextInt() - 1;\n            System.out.println(findMinimumWeight(N, edges, S, T));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 15:38:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n#define MAX_Q 1000\n\ntypedef struct Edge {\n    int u, v, weight;\n} Edge;\n\ntypedef struct Query {\n    int start, end;\n} Query;\n\ntypedef struct UnionFind {\n    int parent[MAX_N+1];\n    int rank[MAX_N+1];\n} UnionFind;\n\nvoid initializeUF(UnionFind *uf, int n) {\n    for (int i = 1; i <= n; ++i) {\n        uf->parent[i] = i;\n        uf->rank[i] = 0;\n    }\n}\n\nint find(UnionFind *uf, int x) {\n    if (uf->parent[x] != x) {\n        uf->parent[x] = find(uf, uf->parent[x]);\n    }\n    return uf->parent[x];\n}\n\nvoid unionSets(UnionFind *uf, int x, int y) {\n    int rootX = find(uf, x);\n    int rootY = find(uf, y);\n    if (rootX != rootY) {\n        if (uf->rank[rootX] < uf->rank[rootY]) {\n            uf->parent[rootX] = rootY;\n        } else if (uf->rank[rootX] > uf->rank[rootY]) {\n            uf->parent[rootY] = rootX;\n        } else {\n            uf->parent[rootY] = rootX;\n            uf->rank[rootX]++;\n        }\n    }\n}\n\nint compareEdges(const void *a, const void *b) {\n    return ((Edge*)a)->weight - ((Edge*)b)->weight;\n}\n\nint findMinimumSpanningSubset(int n, int m, Edge edges[], int u1, int u2) {\n    qsort(edges, m, sizeof(Edge), compareEdges);\n    UnionFind uf;\n    initializeUF(&uf, n);\n\n    unionSets(&uf, u1, u2);\n    int totalWeight = 0;\n    for (int i = 0; i < m; ++i) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        if (find(&uf, u) != find(&uf, v)) {\n            unionSets(&uf, u, v);\n            totalWeight += edges[i].weight;\n        }\n    }\n    // Check if only one connected component containing u1 and u2\n    for (int i = 1; i <= n; ++i) {\n        if (find(&uf, u1) != find(&uf, i) && find(&uf, u2) != find(&uf, i)) {\n            return INT_MAX; // it wasn't possible to connect all vertices\n        }\n    }\n    return totalWeight;\n}\n\nint main() {\n    int n, m, q;\n    scanf(\"%d %d\", &n, &m);\n\n    Edge edges[MAX_M];\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].weight);\n    }\n\n    scanf(\"%d\", &q);\n    Query queries[MAX_Q];\n    for (int i = 0; i < q; ++i) {\n        scanf(\"%d %d\", &queries[i].start, &queries[i].end);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int result = findMinimumSpanningSubset(n, m, edges, queries[i].start, queries[i].end);\n        if (result == INT_MAX) {\n            printf(\"-1\\n\"); // not possible\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:38:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v, w;\n    \n    Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n    \n    bool operator<(const Edge &other) const {\n        return w < other.w;\n    }\n};\n\nstruct UnionFind {\n    vector<int> parent, rank;\n    \n    UnionFind(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    \n    int find(int u) {\n        if (parent[u] == u) return u;\n        return parent[u] = find(parent[u]);\n    }\n    \n    bool unite(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU == rootV) return false;\n        if (rank[rootU] < rank[rootV]) swap(rootU, rootV);\n        parent[rootV] = rootU;\n        if (rank[rootU] == rank[rootV]) ++rank[rootU];\n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<Edge> edges;\n    for (int i = 0; i < M; ++i) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.push_back(Edge(a - 1, b - 1, c));\n    }\n    \n    sort(edges.begin(), edges.end());\n\n    int Q;\n    cin >> Q;\n    for (int qi = 0; qi < Q; ++qi) {\n        int S, T;\n        cin >> S >> T;\n        --S, --T;\n\n        UnionFind uf(N);\n\n        int total_weight = 0;\n        bool reachedS = false, reachedT = false;\n\n        for (const auto &edge : edges) {\n            if (uf.unite(edge.u, edge.v)) {\n                total_weight += edge.w;\n                if (uf.find(S) == uf.find(edge.u) || uf.find(S) == uf.find(edge.v)) reachedS = true;\n                if (uf.find(T) == uf.find(edge.u) || uf.find(T) == uf.find(edge.v)) reachedT = true;\n                if (reachedS && reachedT) break;\n            }\n        }\n\n        cout << total_weight << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:38:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve_graph_problem(N, M, edges, Q, queries):\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    def union(parent, x, y):\n        px, py = find(parent, x), find(parent, y)\n        if px != py:\n            parent[px] = py\n\n    result = []\n    for S, T in queries:\n        parent = list(range(N+1))\n        chosen_edges = []\n        \n        # Sort edges by weight\n        sorted_edges = sorted(edges, key=lambda x: x[2])\n        \n        # Add special vertices S and T\n        for edge in sorted_edges:\n            a, b, w = edge\n            if find(parent, S) == find(parent, T):\n                break\n            \n            if find(parent, a) != find(parent, S) or find(parent, b) != find(parent, T):\n                if find(parent, a) != find(parent, b):\n                    union(parent, a, b)\n                    chosen_edges.append(w)\n        \n        result.append(sum(chosen_edges))\n    \n    return result\n\n# Example usage\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    edges.append((a, b, c))\n\nQ = int(input())\nqueries = []\nfor _ in range(Q):\n    S, T = map(int, input().split())\n    queries.append((S, T))\n\nresults = solve_graph_problem(N, M, edges, Q, queries)\nfor res in results:\n    print(res)",
    "timestamp": "2025-08-13 15:38:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    M = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n\n    Q = int(input[ptr])\n    ptr += 1\n    queries = []\n    for _ in range(Q):\n        S = int(input[ptr])\n        ptr += 1\n        T = int(input[ptr])\n        ptr += 1\n        queries.append((S, T))\n\n    # Precompute Dijkstra from all nodes\n    INF = 1 << 60\n    dist = [{} for _ in range(N+1)]\n    for start in range(1, N+1):\n        heap = []\n        heapq.heappush(heap, (0, start))\n        dist[start][start] = 0\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[start].get(u, INF):\n                continue\n            for (v, c) in adj[u]:\n                if dist[start].get(v, INF) > current_dist + c:\n                    dist[start][v] = current_dist + c\n                    heapq.heappush(heap, (dist[start][v], v))\n\n    # Process queries\n    for S, T in queries:\n        min_total = INF\n        for u in range(1, N+1):\n            d1 = dist[S].get(u, INF)\n            d2 = dist[T].get(u, INF)\n            total = d1 + d2\n            if total < min_total:\n                min_total = total\n        print(min_total)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 15:38:51"
  }
]