[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100005\n\ntypedef struct {\n    int distance;\n    int nutrition;\n} Sushi;\n\nint solve(int C, int N, Sushi sushi[]) {\n    int max_nutrition = INT_MIN;\n    \n    for (int start = 0; start < N; start++) {\n        int total_nutrition = 0;\n        int total_calories = 0;\n        \n        for (int i = 0; i < N; i++) {\n            int current = (start + i) % N;\n            int next = (start + i + 1) % N;\n            \n            int walk_distance = abs(sushi[next].distance - sushi[current].distance);\n            if (walk_distance > C / 2) {\n                walk_distance = C - walk_distance;\n            }\n            \n            total_calories += walk_distance;\n            total_nutrition += sushi[current].nutrition;\n            \n            int net_nutrition = total_nutrition - total_calories;\n            max_nutrition = (net_nutrition > max_nutrition) ? net_nutrition : max_nutrition;\n        }\n    }\n    \n    return max_nutrition;\n}\n\nint main() {\n    int C, N;\n    scanf(\"%d %d\", &C, &N);\n    \n    Sushi sushi[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &sushi[i].distance, &sushi[i].nutrition);\n    }\n    \n    int result = solve(C, N, sushi);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    long long x;\n    long long v;\n} Sushi;\n\nlong long max(long long a, long long b) {\n    return a > b ? a : b;\n}\n\nlong long solve(int N, long long C, Sushi *sushi) {\n    long long *clock_prefix = (long long *)malloc((N + 1) * sizeof(long long));\n    long long *clock_max = (long long *)malloc((N + 1) * sizeof(long long));\n    long long *counter_prefix = (long long *)malloc((N + 1) * sizeof(long long));\n    long long *counter_max = (long long *)malloc((N + 1) * sizeof(long long));\n    \n    clock_prefix[0] = 0;\n    clock_max[0] = 0;\n    for (int i = 0; i < N; ++i) {\n        clock_prefix[i + 1] = clock_prefix[i] + sushi[i].v;\n        clock_max[i + 1] = max(clock_max[i], clock_prefix[i + 1] - sushi[i].x);\n    }\n    \n    counter_prefix[0] = 0;\n    counter_max[0] = 0;\n    for (int i = 0; i < N; ++i) {\n        int j = N - 1 - i;\n        counter_prefix[i + 1] = counter_prefix[i] + sushi[j].v;\n        counter_max[i + 1] = max(counter_max[i], counter_prefix[i + 1] - (C - sushi[j].x));\n    }\n    \n    long long res = 0;\n    for (int i = 0; i <= N; ++i) {\n        long long temp = clock_max[i] + (i < N ? counter_max[N - i] - (C - sushi[N - i].x) : 0);\n        res = max(res, temp);\n    }\n    for (int i = 0; i <= N; ++i) {\n        long long temp = counter_max[i] + (i < N ? clock_max[N - i] - sushi[N - i - 1].x : 0);\n        res = max(res, temp);\n    }\n    \n    free(clock_prefix);\n    free(clock_max);\n    free(counter_prefix);\n    free(counter_max);\n    \n    return res;\n}\n\nint main() {\n    int N;\n    long long C;\n    scanf(\"%d %lld\", &N, &C);\n    \n    Sushi *sushi = (Sushi *)malloc(N * sizeof(Sushi));\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%lld %lld\", &sushi[i].x, &sushi[i].v);\n    }\n    \n    long long result = solve(N, C, sushi);\n    printf(\"%lld\\n\", result);\n    \n    free(sushi);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nlong long solve() {\n    int N;\n    long long C;\n    cin >> N >> C;\n    vector<long long> x(N), v(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> v[i];\n    }\n\n    vector<long long> clockwise_prefix(N + 1, 0);\n    vector<long long> clockwise_max(N + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        clockwise_prefix[i + 1] = clockwise_prefix[i] + v[i];\n        clockwise_max[i + 1] = max(clockwise_max[i], clockwise_prefix[i + 1] - x[i]);\n    }\n\n    vector<long long> counterclockwise_prefix(N + 1, 0);\n    vector<long long> counterclockwise_max(N + 1, 0);\n    for (int i = N - 1; i >= 0; --i) {\n        counterclockwise_prefix[i] = counterclockwise_prefix[i + 1] + v[i];\n        counterclockwise_max[i] = max(counterclockwise_max[i + 1], counterclockwise_prefix[i] - (C - x[i]));\n    }\n\n    long long max_nutrition = 0;\n\n    // Only clockwise\n    for (int i = 0; i <= N; ++i) {\n        max_nutrition = max(max_nutrition, clockwise_prefix[i] - x[i - 1]);\n    }\n\n    // Only counterclockwise\n    for (int i = N; i >= 0; --i) {\n        max_nutrition = max(max_nutrition, counterclockwise_prefix[i] - (C - x[i]));\n    }\n\n    // Clockwise then counterclockwise\n    for (int i = 1; i <= N; ++i) {\n        long long current = clockwise_prefix[i] - 2 * x[i - 1];\n        if (i < N) {\n            current += counterclockwise_max[i];\n        }\n        max_nutrition = max(max_nutrition, current);\n    }\n\n    // Counterclockwise then clockwise\n    for (int i = N - 1; i >= 0; --i) {\n        long long current = counterclockwise_prefix[i] - 2 * (C - x[i]);\n        if (i > 0) {\n            current += clockwise_max[i];\n        }\n        max_nutrition = max(max_nutrition, current);\n    }\n\n    return max_nutrition;\n}\n\nint main() {\n    cout << solve() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        long C = scanner.nextLong();\n        long[] x = new long[N + 2];\n        long[] v = new long[N + 2];\n        \n        for (int i = 1; i <= N; i++) {\n            x[i] = scanner.nextLong();\n            v[i] = scanner.nextLong();\n        }\n        \n        long[] maxClockwise = new long[N + 2];\n        long[] maxClockwiseReturn = new long[N + 2];\n        long[] maxCounterClockwise = new long[N + 2];\n        long[] maxCounterClockwiseReturn = new long[N + 2];\n        \n        long sumV = 0;\n        for (int i = 1; i <= N; i++) {\n            sumV += v[i];\n            maxClockwise[i] = Math.max(maxClockwise[i - 1], sumV - x[i]);\n        }\n        \n        sumV = 0;\n        for (int i = 1; i <= N; i++) {\n            sumV += v[i];\n            maxClockwiseReturn[i] = Math.max(maxClockwiseReturn[i - 1], sumV - 2 * x[i]);\n        }\n        \n        sumV = 0;\n        for (int i = N; i >= 1; i--) {\n            sumV += v[i];\n            maxCounterClockwise[i] = Math.max(maxCounterClockwise[i + 1], sumV - (C - x[i]));\n        }\n        \n        sumV = 0;\n        for (int i = N; i >= 1; i--) {\n            sumV += v[i];\n            maxCounterClockwiseReturn[i] = Math.max(maxCounterClockwiseReturn[i + 1], sumV - 2 * (C - x[i]));\n        }\n        \n        long maxNutrition = 0;\n        for (int i = 0; i <= N; i++) {\n            maxNutrition = Math.max(maxNutrition, maxClockwise[i] + maxCounterClockwiseReturn[i + 1]);\n            maxNutrition = Math.max(maxNutrition, maxClockwiseReturn[i] + maxCounterClockwise[i + 1]);\n        }\n        \n        System.out.println(maxNutrition);\n    }\n}",
    "timestamp": "2025-08-05 23:08:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxNetNutrition {\n    public static int findMaxNetNutrition(int C, int[] distances, int[] nutritions) {\n        int N = distances.length;\n        int maxNetNutrition = Integer.MIN_VALUE;\n        \n        for (int start = 0; start < N; start++) {\n            int currentNetNutrition = 0;\n            int totalDistance = 0;\n            \n            for (int count = 0; count < N; count++) {\n                int currentIndex = (start + count) % N;\n                \n                int distanceToNext = (count == N - 1) ? 0 : \n                    (distances[(currentIndex + 1) % N] - distances[currentIndex] + C) % C;\n                \n                totalDistance += distanceToNext;\n                currentNetNutrition += nutritions[currentIndex] - distanceToNext;\n                \n                maxNetNutrition = Math.max(maxNetNutrition, currentNetNutrition);\n            }\n        }\n        \n        return maxNetNutrition;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int C = 10;\n        int[] distances = {1, 3, 6, 8};\n        int[] nutritions = {5, 2, 4, 3};\n        \n        System.out.println(findMaxNetNutrition(C, distances, nutritions));\n    }\n}",
    "timestamp": "2025-08-05 23:08:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxNetNutrition(int C, vector<int>& positions, vector<int>& nutrition) {\n    int N = positions.size();\n    vector<pair<int, int>> sushis(N);\n    \n    for (int i = 0; i < N; i++) {\n        sushis[i] = {positions[i], nutrition[i]};\n    }\n    \n    sort(sushis.begin(), sushis.end());\n    \n    int maxNet = 0;\n    for (int start = 0; start < N; start++) {\n        int currentNet = 0;\n        int currentPos = sushis[start].first;\n        \n        for (int j = 0; j < N; j++) {\n            int idx = (start + j) % N;\n            int distance = abs(sushis[idx].first - currentPos);\n            distance = min(distance, C - distance);\n            \n            currentNet += sushis[idx].second - distance;\n            currentPos = sushis[idx].first;\n            \n            maxNet = max(maxNet, currentNet);\n        }\n    }\n    \n    return maxNet;\n}\n\nint main() {\n    int C, N;\n    cin >> C >> N;\n    \n    vector<int> positions(N);\n    vector<int> nutrition(N);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> positions[i] >> nutrition[i];\n    }\n    \n    cout << maxNetNutrition(C, positions, nutrition) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_net_nutrition(C, N, distances, nutritions):\n    net_nutrition = [nutritions[i] - distances[i] for i in range(N)]\n    max_total_net = 0\n    current_net = 0\n\n    # Calculate the maximum subarray sum\n    for net in net_nutrition + net_nutrition:\n        current_net += net\n        if current_net < 0:\n            current_net = 0\n        max_total_net = max(max_total_net, current_net)\n    \n    return max_total_net\n\n# Example usage:\nC = 12\nN = 3\ndistances = [1, 5, 8]\nnutritions = [10, 3, 7]\nprint(max_net_nutrition(C, N, distances, nutritions))",
    "timestamp": "2025-08-13 13:44:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SushiMaximizer {\n    \n    static class Sushi {\n        int position;\n        int nutrition;\n        \n        Sushi(int position, int nutrition) {\n            this.position = position;\n            this.nutrition = nutrition;\n        }\n    }\n    \n    public static int maximizeNutrition(int C, List<Sushi> sushiList) {\n        int n = sushiList.size();\n        int[] maxNutrition = new int[2 * n];\n        \n        Collections.sort(sushiList, Comparator.comparingInt(a -> a.position));\n        \n        for (int i = 0; i < n; i++) {\n            sushiList.add(new Sushi(sushiList.get(i).position + C, sushiList.get(i).nutrition));\n        }\n        \n        int result = 0, sumNutrition = 0, sumDistance = 0;\n        Deque<Integer> deque = new ArrayDeque<>();\n        \n        for (int i = 0; i < sushiList.size(); i++) {\n            if (!deque.isEmpty() && i - deque.peekFirst() >= n) {\n                sumNutrition -= sushiList.get(deque.pollFirst()).nutrition;\n            }\n            \n            sumNutrition += sushiList.get(i).nutrition;\n            sumDistance = sushiList.get(i).position - (deque.isEmpty() ? 0 : sushiList.get(deque.peekFirst()).position);\n            \n            result = Math.max(result, sumNutrition - sumDistance);\n            \n            while (!deque.isEmpty() && sushiList.get(deque.peekLast()).nutrition <= sushiList.get(i).nutrition) {\n                deque.pollLast();\n            }\n            \n            deque.offer(i);\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        int C = 10;\n        List<Sushi> sushiList = Arrays.asList(\n            new Sushi(1, 5),\n            new Sushi(3, 10),\n            new Sushi(6, 7)\n        );\n        \n        System.out.println(maximizeNutrition(C, sushiList)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 13:44:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int distance;\n    int nutrition;\n} Sushi;\n\nint compareSushi(const void* a, const void* b) {\n    return ((Sushi*)a)->distance - ((Sushi*)b)->distance;\n}\n\nint maxNetNutrition(Sushi sushi[], int N, int C) {\n    qsort(sushi, N, sizeof(Sushi), compareSushi);\n    \n    int maxNutrition = 0;\n    int currentNutrition = 0;\n    int startDistance = 0;\n\n    for (int i = 0; i < N; i++) {\n        startDistance = sushi[i].distance;\n        currentNutrition = 0;\n        \n        for (int j = i; j < N; j++) {\n            int distanceWalked = sushi[j].distance - startDistance;\n            currentNutrition += sushi[j].nutrition;\n            int netNutrition = currentNutrition - distanceWalked;\n            if (netNutrition > maxNutrition) {\n                maxNutrition = netNutrition;\n            }\n        }\n        \n        currentNutrition = 0;\n        for (int j = N - 1; j >= i; j--) {\n            int distanceWalked = C - (sushi[j].distance - startDistance);\n            currentNutrition += sushi[j].nutrition;\n            int netNutrition = currentNutrition - distanceWalked;\n            if (netNutrition > maxNutrition) {\n                maxNutrition = netNutrition;\n            }\n        }\n    }\n    \n    return maxNutrition;\n}\n\nint main() {\n    int C, N;\n    scanf(\"%d %d\", &C, &N);\n\n    Sushi *sushi = (Sushi*)malloc(N * sizeof(Sushi));\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &sushi[i].distance, &sushi[i].nutrition);\n    }\n\n    int result = maxNetNutrition(sushi, N, C);\n    printf(\"%d\\n\", result);\n\n    free(sushi);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:44:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Sushi {\n    int position;\n    int nutrition;\n};\n\nint main() {\n    int C, N;\n    cin >> C >> N;\n    \n    vector<Sushi> sushi(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> sushi[i].position >> sushi[i].nutrition;\n    }\n\n    sort(sushi.begin(), sushi.end(), [](Sushi &a, Sushi &b) {\n        return a.position < b.position;\n    });\n\n    vector<int> maxNutritionEnd(C + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        int startPos = sushi[i].position;\n        for (int j = 0; j <= C; ++j) {\n            int dist = (sushi[i].position - j + C) % C;\n            maxNutritionEnd[sushi[i].position] = max(maxNutritionEnd[sushi[i].position], \n                                                     maxNutritionEnd[j] + sushi[i].nutrition - dist);\n        }\n    }\n\n    int maxNetNutrition = *max_element(maxNutritionEnd.begin(), maxNutritionEnd.end());\n    cout << maxNetNutrition << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:44:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_net_nutrition(C, sushi_distances, sushi_nutrition):\n    N = len(sushi_distances)\n    max_nutrition = float('-inf')\n    \n    # Try every possible starting point\n    for start in range(N):\n        current_nutrition = 0\n        current_energy = 0\n        \n        # Try every possible end point\n        for length in range(N):\n            end = (start + length) % N\n            \n            # Calculate energy spent and nutrition gained\n            distance = (sushi_distances[end] - sushi_distances[start] + C) % C\n            current_energy += distance\n            current_nutrition += sushi_nutrition[end]\n            \n            # Calculate net nutrition\n            net_nutrition = current_nutrition - current_energy\n            max_nutrition = max(max_nutrition, net_nutrition)\n    \n    return max_nutrition\n\n# Example usage\nC = 10\nsushi_distances = [2, 4, 6, 8]\nsushi_nutrition = [5, 3, 7, 2]\nresult = max_net_nutrition(C, sushi_distances, sushi_nutrition)\nprint(result)",
    "timestamp": "2025-08-13 13:45:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    C, N = map(int, sys.stdin.readline().split())\n    sushi = []\n    for _ in range(N):\n        x, v = map(int, sys.stdin.readline().split())\n        sushi.append((x, v))\n    \n    # Clockwise prefix sums\n    clockwise_prefix = [0] * (N + 1)\n    clockwise_max = [0] * (N + 1)\n    sum_v = 0\n    for i in range(N):\n        x, v = sushi[i]\n        sum_v += v\n        clockwise_prefix[i+1] = sum_v - x\n        clockwise_max[i+1] = max(clockwise_max[i], clockwise_prefix[i+1])\n    \n    # Counter-clockwise prefix sums\n    counter_clockwise_prefix = [0] * (N + 1)\n    counter_clockwise_max = [0] * (N + 1)\n    sum_v = 0\n    for i in range(N-1, -1, -1):\n        x, v = sushi[i]\n        sum_v += v\n        dist = C - x\n        counter_clockwise_prefix[N - i] = sum_v - dist\n        counter_clockwise_max[N - i] = max(counter_clockwise_max[N - i - 1], counter_clockwise_prefix[N - i])\n    \n    max_net = 0\n    \n    # Case 1: Only clockwise\n    max_net = max(max_net, clockwise_max[N])\n    \n    # Case 2: Only counter-clockwise\n    max_net = max(max_net, counter_clockwise_max[N])\n    \n    # Case 3: Clockwise then counter-clockwise\n    for i in range(1, N):\n        clockwise_part = clockwise_prefix[i]\n        counter_part = counter_clockwise_max[N - i]\n        total = clockwise_part + counter_part - sushi[i-1][0]\n        max_net = max(max_net, total)\n    \n    # Case 4: Counter-clockwise then clockwise\n    for i in range(1, N):\n        counter_part = counter_clockwise_prefix[i]\n        clockwise_part = clockwise_max[N - i]\n        total = counter_part + clockwise_part - (C - sushi[N - i][0])\n        max_net = max(max_net, total)\n    \n    print(max_net)\n\nsolve()",
    "timestamp": "2025-08-13 13:45:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxNetNutrition(C, distances, nutritionValues) {\n    const N = distances.length;\n    const doubledDistances = [...distances, ...distances.map(d => d + C)];\n    const doubledNutritionValues = [...nutritionValues, ...nutritionValues];\n    \n    let maxNetNutri = 0;\n    \n    for (let start = 0; start < N; start++) {\n        let netNutriCW = 0;\n        let netNutriCCW = 0;\n        let currentPos = distances[start];\n\n        for (let end = start; end < start + N; end++) {\n            const posCW = doubledDistances[end];\n            const kcalConsumedCW = posCW - currentPos;\n            netNutriCW += doubledNutritionValues[end] - kcalConsumedCW;\n            maxNetNutri = Math.max(maxNetNutri, netNutriCW);\n\n            // Circular anticlockwise consideration, considering backwards walk\n            const posCCW = doubledDistances[end] - C;\n            const kcalConsumedCCW = currentPos - posCCW;\n            netNutriCCW += doubledNutritionValues[end] - kcalConsumedCCW;\n            maxNetNutri = Math.max(maxNetNutri, netNutriCCW);\n        }\n    }\n\n    return maxNetNutri;\n}\n\n// Example usage:\nconst C = 20;\nconst distances = [3, 5, 8, 10, 12];\nconst nutritionValues = [6, 1, 8, 9, 6];\nconsole.log(maxNetNutrition(C, distances, nutritionValues)); // Output should reflect the maximum net nutrition possible",
    "timestamp": "2025-08-13 13:45:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxNetNutrition(C, sushis) {\n    const n = sushis.length;\n    let maxNutrition = 0;\n\n    for (let start = 0; start < n; start++) {\n        for (let length = 1; length <= n; length++) {\n            let totalNutrition = 0;\n            let totalDistance = 0;\n\n            for (let i = 0; i < length; i++) {\n                const idx = (start + i) % n;\n                totalNutrition += sushis[idx].nutrition;\n                \n                const nextIdx = (start + i + 1) % n;\n                const distance = Math.min(\n                    Math.abs(sushis[nextIdx].position - sushis[idx].position),\n                    C - Math.abs(sushis[nextIdx].position - sushis[idx].position)\n                );\n                totalDistance += distance;\n            }\n\n            const netNutrition = totalNutrition - totalDistance;\n            maxNutrition = Math.max(maxNutrition, netNutrition);\n        }\n    }\n\n    return maxNutrition;\n}",
    "timestamp": "2025-08-13 13:45:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [C, N] = input[0].split(' ').map(Number);\n    const sushi = [];\n    for (let i = 1; i <= N; i++) {\n        const [x, v] = input[i].split(' ').map(Number);\n        sushi.push({ x, v });\n    }\n\n    // Compute prefix sums for clockwise and counter-clockwise\n    const prefixClockwise = Array(N + 1).fill(0);\n    const prefixCounterClockwise = Array(N + 1).fill(0);\n    const maxClockwise = Array(N + 1).fill(0);\n    const maxCounterClockwise = Array(N + 1).fill(0);\n\n    for (let i = 0; i < N; i++) {\n        prefixClockwise[i + 1] = prefixClockwise[i] + sushi[i].v;\n        maxClockwise[i + 1] = Math.max(maxClockwise[i], prefixClockwise[i + 1] - sushi[i].x);\n    }\n\n    for (let i = N - 1; i >= 0; i--) {\n        const j = N - i;\n        prefixCounterClockwise[j] = prefixCounterClockwise[j - 1] + sushi[i].v;\n        const dist = C - sushi[i].x;\n        maxCounterClockwise[j] = Math.max(maxCounterClockwise[j - 1], prefixCounterClockwise[j] - dist);\n    }\n\n    let maxNutrition = 0;\n\n    // Case 1: Only clockwise\n    for (let i = 0; i <= N; i++) {\n        const nutrition = prefixClockwise[i] - sushi[i - 1]?.x || 0;\n        if (nutrition > maxNutrition) {\n            maxNutrition = nutrition;\n        }\n    }\n\n    // Case 2: Only counter-clockwise\n    for (let i = 0; i <= N; i++) {\n        const dist = i === 0 ? 0 : C - sushi[N - i].x;\n        const nutrition = prefixCounterClockwise[i] - dist;\n        if (nutrition > maxNutrition) {\n            maxNutrition = nutrition;\n        }\n    }\n\n    // Case 3: Clockwise then counter-clockwise\n    for (let i = 1; i < N; i++) {\n        const j = N - i;\n        const dist = sushi[i - 1].x * 2 + (C - sushi[N - j].x);\n        const nutrition = prefixClockwise[i] + prefixCounterClockwise[j] - dist;\n        if (nutrition > maxNutrition) {\n            maxNutrition = nutrition;\n        }\n    }\n\n    // Case 4: Counter-clockwise then clockwise\n    for (let i = 1; i < N; i++) {\n        const j = N - i;\n        const dist = (C - sushi[N - i].x) * 2 + sushi[j - 1]?.x || 0;\n        const nutrition = prefixCounterClockwise[i] + prefixClockwise[j] - dist;\n        if (nutrition > maxNutrition) {\n            maxNutrition = nutrition;\n        }\n    }\n\n    console.log(maxNutrition);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:46:07"
  }
]