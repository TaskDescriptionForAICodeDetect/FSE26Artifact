[
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\nstruct ModCombination {\n    vector<mint> Fac;\n    vector<mint> Facinv;\n\n    ModCombination(int x) {\n        Fac.resize(x+1);\n        Facinv.resize(x+1);\n        Fac[0] = 1;\n        for (int i = 0; i < x; ++i) Fac[i+1] = Fac[i]*(i+1);\n        Facinv[x] = Fac[0]/Fac[x];\n        for (int i = x; i > 0; --i) Facinv[i-1] = Facinv[i]*i;\n    }\n\n    mint get(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return Fac[n]*Facinv[k]*Facinv[n-k];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,K; cin >> N >> K;\n    ModCombination MC(K);\n    mint ans = 0;\n    for (int i = K; i >= 1; i--) {\n        mint b = i;\n        b ^= N;\n        if ((K-i)&1) ans -= MC.get(K,i)*b;\n        else ans += MC.get(K,i)*b;\n    }\n\n    cout << ans.a << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <tuple>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...) do{ } while(false)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\ntemplate<typename T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate<typename T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\ntemplate<typename T> void print(T a) { cout << a << endl; }\ntemplate<typename T, typename... Ts> void print(T a, Ts... ts) { cout << a << ' '; print(ts...); }\ntemplate<typename T> istream &operator,(istream &in, T &t) { return in >> t; }\n// clang-format on\n\ntemplate<ll MOD = 1000000007>\nclass ModInt {\n    ll n;\n    ModInt constexpr inverse() const {\n        return ModInt::pow(*this, MOD - 2);\n    }\n\npublic:\n    ModInt()\n        : n(0) {}\n    ModInt(ll _n)\n        : n(((_n % MOD) + MOD) % MOD) {}\n    ModInt operator+=(const ModInt &m) {\n        n += m.n;\n        if (n >= MOD) n -= MOD;\n        return *this;\n    }\n    ModInt operator-=(const ModInt &m) {\n        n -= m.n;\n        if (n < 0) n += MOD;\n        return *this;\n    }\n    ModInt operator*=(const ModInt &m) {\n        n *= m.n;\n        if (n >= MOD) n %= MOD;\n        return *this;\n    }\n    ModInt operator/=(const ModInt &m) {\n        (*this) *= m.inverse();\n        return *this;\n    }\n    friend ModInt operator+(ModInt t, const ModInt &m) {\n        return t += m;\n    }\n    friend ModInt operator-(ModInt t, const ModInt &m) {\n        return t -= m;\n    }\n    friend ModInt operator*(ModInt t, const ModInt &m) {\n        return t *= m;\n    }\n    friend ModInt operator/(ModInt t, const ModInt &m) {\n        return t /= m;\n    }\n    ModInt operator=(const ll l) {\n        n = l % MOD;\n        if (n < 0) n += MOD;\n        return *this;\n    }\n    friend ostream &operator<<(ostream &out, const ModInt &m) {\n        out << m.n;\n        return out;\n    }\n    friend istream &operator>>(istream &in, ModInt &m) {\n        ll l;\n        in >> l;\n        m = l;\n        return in;\n    }\n    static constexpr ModInt pow(const ModInt x, ll p) {\n        ModInt<MOD> ans = 1;\n        for (ModInt<MOD> m = x; p > 0; p /= 2, m *= m) {\n            if (p % 2) ans *= m;\n        }\n        return ans;\n    }\n};\nusing mint = ModInt<>;\nmint operator\"\" _m(unsigned long long m) {\n    return mint(m);\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin, n, k;\n    int SZ = 2020;\n    vector<mint> fact(SZ + 1, 1_m);\n    REP(i, 1, SZ) {\n        fact[i + 1] = fact[i] * (i + 1);\n    }\n    auto nCr = [&](int a, int b) {\n        if (a < b)\n            return 0_m;\n        else\n            return fact[a] / fact[a - b] / fact[b];\n    };\n    mint ans = 0;\n    REP(i, 0, k + 1) {\n        // i個以下が0個の箱\n        int sign = 1 - 2 * (i % 2);\n        ans += sign * nCr(k, i) * mint::pow(k - i, n);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ninline int64 modPow(int64 x, int64 n)\n{\n  if(n == 0) return(1);\n  int64 ret = modPow(x, n / 2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return(ret);\n}\ninline int64 modInv(int64 a)\n{\n  return(modPow(a, mod - 2));\n}\ninline int64 modCombination(int p, int q)\n{\n  static int64 fact[202020], rfact[202020];\n  if(fact[0] == 0) {\n    fact[0] = rfact[0] = 1;\n    for(int i = 1; i < 102020; i++) {\n      fact[i] = fact[i - 1] * i % mod;\n      rfact[i] = modInv(fact[i]);\n    }\n  }\n  if(q < 0 || p < q) return(0);\n  return(fact[p] * rfact[q] % mod * rfact[p - q] % mod);\n}\ninline int64 count1_3(int n, int k)\n{\n  if(n < k) return(0);\n  int64 ret = 0;\n  for(int i = 1; i <= k; i++) {\n    // i 個以下の箱に n 個の玉を入れる場合の数\n    int64 tmp = modCombination(k, i) * modPow(i, n) % mod;\n    if((k - i) & 1) ret = (ret - tmp + mod) % mod;\n    else (ret += tmp) %= mod;\n  }\n  return(ret);\n}\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  cout << count1_3(N, K) << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\ntemplate<int MOD> struct ModInt {\n    static const int Mod = MOD; unsigned x; ModInt() : x(0) { }\n    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }\n    int get() const { return (int)x; }\n    ModInt &operator+=(ModInt that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(ModInt that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MOD; return *this; }\n    ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    ModInt inverse() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); }\n        return ModInt(u); }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt operator-() const { ModInt t; t.x = x == 0 ? 0 : Mod - x; return t; }\n};\ntemplate<int MOD> ostream& operator<<(ostream& st, const ModInt<MOD> a) { st << a.get(); return st; };\ntemplate<int MOD> ModInt<MOD> operator^(ModInt<MOD> a, unsigned long long k) {\n    ModInt<MOD> r = 1; while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\ntemplate<typename T, int FAC_MAX> struct Comb { vector<T> fac, ifac;\n    Comb(){fac.resize(FAC_MAX,1);ifac.resize(FAC_MAX,1);rep(i,1,FAC_MAX)fac[i]=fac[i-1]*i;\n        ifac[FAC_MAX-1]=T(1)/fac[FAC_MAX-1];rrep(i,FAC_MAX-2,1)ifac[i]=ifac[i+1]*T(i+1);}\n    T aPb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b]; }\n    T aCb(int a, int b) { if (b < 0 || a < b) return T(0); return fac[a] * ifac[a - b] * ifac[b]; }\n    T nHk(int n, int k) { if (n == 0 && k == 0) return T(1); if (n <= 0 || k < 0) return 0;\n        return aCb(n + k - 1, k); }}; // nHk = (n+k-1)Ck : n is separator\ntypedef ModInt<1000000007> mint;\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\nint N, K;\nComb<mint, 10101> com;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> K;\n\n    mint ans = 0;\n    rep(k, 0, K) {\n        mint d = com.aCb(K, k) * (mint(K - k) ^ N);\n        if (k % 2 == 0) ans += d;\n        else ans -= d;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nll factmemo[SIZE];\nll factmemoMod = -1;\nvoid initFactorial(int n, int M){\n  factmemoMod = M;\n  factmemo[0] = 1;\n  for(int i=1;i<=n;i++) factmemo[i] = (factmemo[i-1] * i)%M;\n}\n\nll factorial(int n,int M){\n  if(factmemoMod == M) return factmemo[n];\n  \n  ll ret=1;\n  if(n<=1) return 1;\n  \n  for(int i=1;i<=n;i++) ret = (ret*i)%M;\n  \n  return ret;\n}\n\nll power(int k,int n,int M){\n  if(n==0) return 1;\n  if(n==1) return (ll)k;\n  \n  ll ret = power(k,n/2,M);\n  \n  ret=(ret*ret)%M;\n  \n  if(n%2==1) ret=(ret*k)%M;\n  \n  return ret;\n}\n\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nint C(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0 || n==m) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = (factorial(m,M) * factorial(n-m,M))%M;\n  \n  mot = power((int)mot,M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n\n/*Permutation*/\nint P(int n,int m,int M){\n  if(n<m) return 0;\n  if(m==0) return 1;\n  \n  ll chi = factorial(n,M);\n  ll mot = factorial(n-m,M);\n  \n  mot = power((int)mot, M-2,M);\n  \n  ll ret = (chi*mot)%M;\n  \n  return (int)ret;\n}\n\n/*Combination with Repetitions*/\nint H(int n,int m,int M){\n  if(n==0 && m==0) return 1;\n  return C(n+m-1,m,M);\n}\n\n\nint main(){\n  int n, k;\n\n  cin >> n >> k;\n\n  initFactorial(2020, mod);\n  \n  ll ans = 0;\n  \n  for(int i=0;i<k;i++){\n    ll add = power(k-i, n, mod) * C(k, i, mod) % mod;\n    if(i%2) add *= -1;\n    ans = (ans + add + mod)%mod;\n  }\n  \n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstatic const ll MOD = 1000000007;\n\nll mod_pow(ll n, ll x){\n\tif(n == 0) return 1;\n\tll ret = mod_pow(n / 2, x * x % MOD) % MOD;\n\tif(n % 2) return ret * x % MOD;\n\treturn ret;\n}\n\nll comb(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\tvector<ll> memo(n + 1);\n\tmemo[0] = 1; memo[1] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tmemo[i] = memo[i - 1] * (ll)i;\n\t\tmemo[i] %= MOD;\n\t}\n\treturn ((memo[n] * mod_pow(MOD - 2, memo[k])) % MOD) * mod_pow(MOD - 2, memo[n - k]) % MOD;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\tvector<ll> memo(k + 1, 0);\n\tmemo[1] = 1;\n\tfor(int i = 2; i <= k; i++){\n\t\tmemo[i] = mod_pow(n, i);\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tmemo[i] -= (comb(i, j) * memo[j]) % MOD;\n\t\t\twhile(memo[i] < 0) memo[i] += MOD;\n\t\t}\n\t}\n\tcout << memo[k] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Mint{\n    public:\n    int v;\n    const long long MOD = 1000000007;\n    Mint():v(0){}\n    Mint(signed v):v(v){}\n    Mint(long long t){v=t%MOD; if(v<0)v+=MOD;}\n\n    Mint pow(long long k){\n        Mint res(1), tmp(v);\n        while(k){\n            if(k&1)res*=tmp;\n            tmp*=tmp;\n            k>>=1;\n        }\n        return res;\n    }\n    Mint inv(){return pow(MOD-2);}\n\n    Mint& operator+=(Mint a){v+=a.v; if(v>=MOD)v-=MOD; return *this;}\n    Mint& operator-=(Mint a){v+=MOD-a.v; if(v>=MOD)v-=MOD; return *this;}\n    Mint& operator*=(Mint a){v=1LL*v*a.v%MOD; return *this;}\n    Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n    Mint operator+(Mint a) const{return Mint(v)+=a;};\n    Mint operator-(Mint a) const{return Mint(v)-=a;};\n    Mint operator*(Mint a) const{return Mint(v)*=a;};\n    Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n    Mint operator-(){return v ? MOD-v : v;}\n    bool operator==(Mint a)const{return v==a.v;}\n    bool operator!=(Mint a)const{return v!=a.v;}\n\n    Mint operator=(Mint a) {v=a.v;return a;}\n\n    friend ostream& operator<<(ostream& os, const Mint& mint){\n        os << mint.v;\n        return os;\n    }\n};\n\nclass cmbs{\n    public:\n    vector<Mint> fact, finv, inv;\n    cmbs(){\n        fact.clear(); finv.clear(); inv.clear();\n    }\n    void init(int n){\n        if(n+1 <= (signed)fact.size())return;\n        fact.assign(n+1,1);\n        finv.assign(n+1,1);\n        inv.assign(n+1,1);\n\n        for(int i=1; i<=n; i++) fact[i] = fact[i-1]*Mint(i);\n        finv[n] = Mint(1)/fact[n];\n        for(int i=n; i>=1;i--) finv[i-1] = finv[i]*Mint(i);\n        for(int i=1; i<=n; i++) inv[i] = finv[i]*fact[i-1];\n    }\n    Mint comb(long long n, int k){\n        if(n<k||k<0)return Mint(0);\n        Mint res(1);\n        for(int i=0; i<k; i++){\n            res *= Mint(n-i);\n            res /= Mint(i+1);\n        }\n        return res;\n    }\n    Mint C(int n,int k){\n        if(n<k||k<0)return Mint(0);\n        init(n);\n        return fact[n]*finv[n-k]*finv[k];\n    }\n    Mint P(int n, int k){\n        if(n<k || k<0)return Mint(0);\n        init(n);\n        return fact[n]*finv[n-k];\n    }\n    Mint H(int n, int k){\n        if(n<0||k<0)return Mint(0);\n        if(!n&&!k)return Mint(1);\n        init(n+k-1);\n        return C(n+k-1,k);\n    }\n    Mint S(int n, int k){\n        Mint res;\n        init(k);\n        for(int i=0; i<=k; i++){\n            Mint v = (C(k,i) * Mint(k-i).pow(n));\n            if(i%2==0) res+=v;\n            else res-=v;\n        }\n        return res;\n    }\n};\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    if(n<k){\n        cout<<\"0\"<<endl;\n        return 0;\n    }\n    cmbs cmb;\n    cout<<cmb.S(n,k)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\ntypedef long long int ll;\nconst int MOD=1e9+7;\nconst int N=1e3+10;\nll fac[N];\nll pow(ll a,ll t){\n    if(t==0)return 1;\n    ll temp=pow(a,t/2);\n    temp*=temp;\n    temp%=MOD;\n    if(t&1){\n        temp*=a;\n        temp%=MOD;\n    }\n    return temp;\n}\nll rev(ll n){return pow(n,MOD-2);}\nll C(int n,int k){return (fac[n]*((rev(fac[k])*rev(fac[n-k]))%MOD))%MOD;}\nvoid init(){\n    fac[0]=fac[1]=1;\n    for(int i=2;i<N;i++)fac[i]=(fac[i-1]*i)%MOD;\n    return ;\n}\nint main(){\n    int n,k,now=1;\n    ll ans=0;\n    scanf(\"%d%d\",&n,&k);\n    if(n<k)printf(\"0\\n\");\n    else{\n        init();\n        for(int i=0;i<k;i++){\n            ans+=now*((pow(k-i,n)*C(k,i))%MOD);\n            ans%=MOD;\n            now=-now;\n        }\n        ans+=MOD;\n        ans%=MOD;\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\nconstexpr i64 MOD = 1e9 + 7;\n\ni64 modpow(i64 a, i64 n, i64 mod) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        i64 t = modpow(a, n / 2, mod);\n        return t * t % mod;\n    }\n    return a * modpow(a, n - 1, mod) % mod;\n}\n\ni64 modinv(i64 a, i64 mod) {\n    // mod is prime\n    return modpow(a, mod - 2, mod);\n}\n\nstruct Combination {\n    const int MAX_N = 1 << 21;\n    vi fact = vi(MAX_N);\n    vi factinv = vi(MAX_N);\n\n    Combination() {\n        fact[0] = 1;\n        for (int i = 1; i < MAX_N; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        factinv[MAX_N - 1] = modinv(fact[MAX_N - 1], MOD);\n        for (int i = MAX_N - 2; i >= 0; i--) {\n            factinv[i] = factinv[i + 1] * (i + 1) % MOD;\n        }\n    }\n\n    i64 ncr(i64 n, i64 r) {\n        if (r < 0 || r > n) return 0;\n        return fact[n] * factinv[r] % MOD * factinv[n - r] % MOD;\n    }\n\n    i64 npr(i64 n, i64 r) {\n        if (r < 0 || r > n) return 0;\n        return fact[n] * factinv[n - r] % MOD;\n    }\n\n    i64 nhr(i64 n, i64 r) {\n        if (n == 0 && r == 0) return 1;\n        return ncr(n + r - 1, r);\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    i64 ans = 0;\n    Combination comb;\n    for (int i = k, j = 1; i >= 1; i--, j++) {\n        if (j % 2) {\n            ans += comb.ncr(k, i) * modpow(i, n, MOD) % MOD;\n        } else {\n            ans -= comb.ncr(k, i) * modpow(i, n, MOD) % MOD;\n        }\n        ans %= MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nll fac[200007],finv[200007],inv[200007];\nvoid cominit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<200007;i++){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n}\nll com(ll n,ll k){\n    if(n<k)return 0;\n    if(n<0 || k<0)return 0;\n    return fac[n]*(finv[k]*finv[n-k]%mod)%mod;\n}\nlong long modpow(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    cominit();\n    ll n,k;\n    cin>>n>>k;\n    ll ans=0;\n    for(ll i=0LL;i<=k;i++){\n    \tans+=(com(k,i)*modpow(i,n)*modpow(-1,k-i))%mod;\n    \tans%=mod;\n    }\n    cout <<(ans+mod)%mod<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,k);\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      (rinv*=inverse(k))%=MOD;\n      if(k%2) (res+=MOD-rinv)%=MOD;\n      else (res+=rinv)%=MOD;\n    }\n    for(Int i=1;i<=n;i++)\n      (res*=i)%=MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  Int ans=0;\n  for(Int i=1;i<=k;i++){\n    Int res=mod.C(k,i)*mod.pow(i,n)%MOD;\n    if((k-i)&1) ans+=MOD-res;\n    else ans+=res;\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst ll mod = 1e9+7;\n\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n// 線分 ab の偏角 返り値は[-π, π]\ntemplate<typename T>\nT argument(const pair<T, T> &a, const pair<T, T> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n/* 注意 \n\n    1LL<<60 * N とかのオーバーフローに気を付けろ\n    制約がヒントになる、ちゃんと全ての制約を見ろ\n\n*/\n\nint const MAX = 2000000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\nlong long COM(int n, int k){\n    if(n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    COMinit();\n    int n, k; std::cin >> n >> k;\n    if (n<k) { std::cout << 0 << std::endl; return 0; }\n\n    ll ans = 0;\n    repr(i, 1, k+1) {\n        ll add = COM(k, i) * modpow(k-i, n);\n        chmod(add);\n        ans += add * (i%2==1? 1:-1);\n        chmod(ans);\n    }\n    ans = modpow(k, n) - ans;\n    chmod(ans);\n    std::cout << ans << std::endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Combination{\n\tvector<ll> fac,finv,inv;\npublic:\n\tCombination(ll N){\n\t\tfac.resize(N+1);\n\t\tfinv.resize(N+1);\n\t\tinv.resize(N+1);\n\t\tfac[0] = fac[1] = 1;\n\t\tfinv[0] = finv[1] = 1;\n\t\tinv[1] = 1;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tfac[i] = fac[i-1] * i % atcoder_mod;\n\t\t\tinv[i] = atcoder_mod - inv[atcoder_mod%i] * (atcoder_mod/i) % atcoder_mod;\n\t\t\tfinv[i] = finv[i-1] * inv[i] % atcoder_mod;\n\t\t}\n\t}\n\tll Caluclation(ll n,ll r){\n\t\tif(n < r) return 0;\n\t\tif (n < 0 || r < 0) return 0;\n\t\treturn fac[n] * (finv[r] * finv[n-r] % atcoder_mod) % atcoder_mod;\n\t}\n\n};\nll powermod(ll a,ll b,ll m){\n\tif(b==0){\n\t\treturn 1LL;\n\t}\n\tif(b%2){\n\t\treturn (a*powermod(a,b-1LL,m))%m;\n\t}\n\treturn powermod((a*a)%m,b/2LL,m);\n}\n\nll BallBoxCombination3(ll n,ll k){\n\tll sum = 0;\n\tCombination comb(k);\n\tfor(ll i=1;i<=k;i++){\n\t\tll C = comb.Caluclation(k,i)%atcoder_mod;\n\t\tll P = powermod(i,n,atcoder_mod)%atcoder_mod;\n\t\tll V = (C*P)%atcoder_mod;\n\t\tif((k-i)%2){\n\t\t\tsum = (sum-V+atcoder_mod)%atcoder_mod;\n\t\t}\n\t\telse sum = (sum+V)%atcoder_mod;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll N=in<ll>(),K=in<ll>();\n\t\n\tll ans = BallBoxCombination3(N,K);\n\tout(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nconst int MAX = 510000;\nconst int MOD = 1000000007;\nlong long fac[MAX], finv[MAX], inv[MAX];\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n/*\n    Ball and Boxes 2\n    男、女、一人以上(保護者形式)\n*/\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n    COMinit();\n\n    ll ans = 0;\n\n    rep(i,k){\n        ll mul = 1;\n        rep(j,n){\n            mul *= (k-i);\n            mul %= MOD;\n        }\n        mul *= COM(k,i);\n        mul %= MOD;\n        if(i%2==0){\n            ans += mul;\n            ans %= MOD;\n        }else{\n            ans -= mul;\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll, ll>\nconst ll maxn = 1e5 + 111;\nconst ll mod = 1e9 + 7;\nll jc[100005];\nvoid init() {  //打表n!\n    jc[0] = 1;\n    ll ret = 1;\n    for (ll i = 1; i <= 100000; ++i) {\n        ret = ret * i % mod;\n        jc[i] = ret;\n    }\n}\nll binaryPow(ll a, ll b, ll m) {\n    ll ret = a, ans = 1;\n    while (b) {\n        if (b & 1) ans = (ans * ret) % m;\n        ret = ret * ret % m;\n        b >>= 1;\n    }\n    return ans;\n}\ninline ll cal(ll a, ll b) {\n    return jc[a] * binaryPow(jc[b] * jc[a - b] % mod, mod - 2, mod) % mod;\n}\nll s[1111][1111];\nint main() {\n    init();\n    ll n, m;\n    scanf(\"%lld%lld\", &n, &m);\n    s[0][0] = 1;\n    for (ll i = 1; i <= 1111; i++) {\n        for (ll j = 1; j <= 1111; j++) {\n            s[i][j] = ((s[i - 1][j - 1] * (m - j + 1)) % mod +\n                       (j * s[i - 1][j]) % mod) %\n                      mod;\n        }\n    }\n    if (n < m) {\n        puts(\"0\");\n        return 0;\n    }\n    ll ans = 1;\n    for (ll i = 1; i <= m; ++i) {\n        ans = ans * i % mod;\n    }\n    printf(\"%lld\\n\", s[n][m] % mod);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define rep(i,a,b) for(int i=a;i<(b);++i)\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\nusing ll = long long;\nconstexpr long long INF = 1LL << 62;\nconstexpr int MOD = 1e9 + 7;\n\nconstexpr int MAX = 1001;\nlong long fac[MAX], inv[MAX], finv[MAX];\nvoid CombInit(){\n    fac[0] = inv[0] = finv[0] = 1;\n    fac[1] = inv[1] = finv[1] = 1;\n    for(int i=2; i<MAX; ++i){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\n\nlong long Comb(int n,int k){\n    if(n < 0 || k < 0 || n < k) return 0;\n    return (fac[n] * finv[n-k] % MOD) * finv[k] % MOD;\n}\n\nll mod_pow(ll x,int e){\n    ll y = 1;\n    while(e) {\n        if(e & 1) y = y * x % MOD;\n        x = x * x % MOD;\n        e >>= 1;\n    }\n    return y;\n}\n\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n, k; cin >> n >> k;\n    CombInit();\n\n    ll ans = 0;\n    for(int i = 1; i < k; ++i) {\n        ll num = (mod_pow(k - i, n) * Comb(k, i)) % MOD;\n        if(i & 1) ans = (ans + num) % MOD;\n        else ans = (ans - num + MOD) % MOD;\n    }\n    cout << (mod_pow(k, n) - ans + MOD) % MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * aoj/dpl_5_c/main.cpp\n */\n\n// C++ 14\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring> // memset\n#include <cassert>\nusing namespace std;\n#define ll long long\n#define loop(__x, __start, __end) for(int __x = __start; __x < __end; __x++)\ntemplate <class T> ostream & operator << (ostream & out, vector<T> const & v) {\n  for (auto &&a: v) out << a << \" \"; out << endl; return out;\n}\ntemplate <class T> void dump(T &a) { cout << a << endl; }\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\n\n#define MOD 1000000007\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%MOD+MOD)%MOD){}\n  mint& fix() { x = (x%MOD+MOD)%MOD; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n  mint& operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nostream & operator << (ostream & out, mint const & v) {\n  out << v.x;\n  return out;\n}\n/* nCk */\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n// sum((-1)^(k-i)*kCi*i^n | for i in range(0, k+1))\nint N, K;\nBiCoef<mint> bc;\nvoid solve() {\n  cin >> N >> K;\n  if (K > N) {\n    cout << 0 << endl;\n    return;\n  }\n\n  bc.init(1001);\n  mint s = 0;\n  for (int i=0; i<=K; i++) {\n    mint sign = (K-i) % 2 == 1 ? -1 : 1;\n    mint i_n = 1;\n    loop(x,0,N) i_n *= i;\n    s += sign * bc.com(K, i) * i_n;\n  }\n  cout << s << endl;\n}\n\nint main() {\n  // cout.precision(15); cout << fixed;\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<bool bigN=false>\nll combi(ll N_, ll K_, ll mo=MOD) {\n  const int NUM_=5e5;\n  static ll fact[NUM_+1]={},factr[NUM_+1]={},inv[NUM_+1]={};\n  auto binpow = [&](ll x, ll e) -> ll {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % mo; e /= 2;}\n      else {a = (a*p) % mo; e--;}\n    }\n    return a;\n  };\n  if (fact[0]==0) {\n    if(!bigN) {\n      fact[0] = factr[0] = inv[0] = 1;\n      FOR(i, 1, NUM_+1) fact[i] = fact[i-1] * i % MOD;\n      factr[NUM_] = binpow(fact[NUM_], mo-2);\n      for(int i=NUM_-1; i>=0; --i) factr[i] = factr[i+1] * (i+1) % MOD;\n    } else {\n      FOR(i, 1, NUM_+1) fact[i] = fact[i-1] * i % MOD;\n      REP(i, NUM_+1) inv[i] = binpow(i, MOD-2);\n    }\n  }\n  if(K_<0 || K_>N_) return 0;\n  // 前計算 O(max(N,K)) クエリ O(1)\n  if(!bigN) return factr[K_]*fact[N_]%MOD*factr[N_-K_]%MOD;\n  // Nが大きいけどKが小さい場合に使う 前計算 O(Klog(mod)) クエリ O(K)\n  ll ret = 1;\n  for(;K_>0;N_--,K_--) (ret *= N_%MOD) %= MOD, (ret *= inv[K_]) %= MOD;\n  return ret;\n}\n\nll binpow(ll x, ll e) {\n  ll ret = 1, p = x;\n  while(e > 0) {\n    if(e&1) {(ret *= p) %= MOD; e--;}\n    else {(p *= p) %= MOD; e /= 2;} \n  }\n  return ret;\n}\n\nstruct mint {\n  ll x;\n  mint(): x(0) { }\n  mint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n  ll get() const { return x; }\n  // e乗\n  mint pow(ll e) {\n    ll a = 1, p = x;\n    while(e > 0) {\n      if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n      else {a = (a*p) % MOD; e--;}\n    }\n    return mint(a);\n  }\n  // Comparators\n  bool operator <(mint b) { return x < b.x; }\n  bool operator >(mint b) { return x > b.x; }\n  bool operator<=(mint b) { return x <= b.x; }\n  bool operator>=(mint b) { return x >= b.x; }\n  bool operator!=(mint b) { return x != b.x; }\n  bool operator==(mint b) { return x == b.x; }\n  // increment, decrement\n  mint operator++() { x++; return *this; }\n  mint operator++(signed) { mint t = *this; x++; return t; }\n  mint operator--() { x--; return *this; }\n  mint operator--(signed) { mint t = *this; x--; return t; }\n  // Basic Operations\n  mint &operator+=(mint that) {\n    x += that.x;\n    if(x >= MOD) x -= MOD;\n    return *this;\n  }\n  mint &operator-=(mint that) {\n    x -= that.x;\n    if(x < 0) x += MOD;\n    return *this;\n  }\n  mint &operator*=(mint that) {\n    x = (ll)x * that.x % MOD;\n    return *this;\n  }\n  mint &operator/=(mint that) {\n    x = (ll)x * that.pow(MOD-2).x % MOD;\n    return *this;\n  }\n  mint &operator%=(mint that) {\n    x = (ll)x % that.x;\n    return *this;\n  }\n  mint operator+(mint that) const { return mint(*this) += that; }\n  mint operator-(mint that) const { return mint(*this) -= that; }\n  mint operator*(mint that) const { return mint(*this) *= that; }\n  mint operator/(mint that) const { return mint(*this) /= that; }\n  mint operator%(mint that) const { return mint(*this) %= that; }\n};\n// Input/Output\nostream &operator<<(ostream& os, mint a) { return os << a.x; }\nistream &operator>>(istream& is, mint &a) { return is >> a.x; }\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, k;\n    cin >> n >> k;\n\n    mint ans = 0;\n    REP(i, k+1) {\n        if(i%2) ans -= combi(k, i) * binpow(k - i, n);\n        else ans += combi(k, i) * binpow(k - i, n);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nconst ULL M = 1000000007;\n\nULL powm(ULL a, ULL i) {\n    if (!i) return 1;\n    if (i & 1) return powm(a * a % M, i >> 1) * a % M;\n    return powm(a * a % M, i >> 1);\n}\n\nULL F[10001], I[10001], iF[10001];\n\nULL C(ULL n, ULL r) { return F[n] * iF[r] % M * iF[n - r] % M; }\nULL P(ULL n, ULL r) { return F[n] * iF[n - r] % M; }\nULL H(ULL n, ULL r) { return C(r + n - 1, n - 1); }\n\nstruct Problem {\n\n    void Solve() {\n        F[0] = 1; for (UL i = 1; i <= 10000; i++) F[i] = F[i - 1] * i % M;\n        I[1] = 1; for (UL i = 2; i <= 10000; i++) I[i] = M - M / i * I[M % i] % M;\n        iF[0] = 1; for (UL i = 1; i <= 10000; i++) iF[i] = iF[i - 1] * I[i] % M;\n        ULL N, K; cin >> N >> K;\n        if (N < K) { cout << 0 << endl; return; }\n        ULL ans[1001]; ans[0] = 0;\n        for (UL i = 1; i <= K; i++) {\n            ans[i] = powm(i, N);\n            rep(j, i) ans[i] += (M - ans[j]) * C(i, j) % M;\n            ans[i] %= M;\n        }\n        cout << ans[K] << endl;\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    p->Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_C\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long MOD = 1e9 + 7;\n\nlong long powMod(long long x, long long k, long long m) {\n    if (k == 0) return 1;\n    if (k % 2 == 0) return (powMod((x * x + m) % m, k / 2, m) + m) % m;\n    else return (x * powMod(x, k - 1, m) + m) % m;\n}\n\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n    long long g = a;\n    x = 1;\n    y = 0;\n    if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    return g;\n}\n\nlong long invMod(long long a, long long m) {\n    long long x, y;\n    if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n    else return 0;\n}\n\nlong long factorial(long long n, long long m) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return (n * factorial(n - 1, m) + m) % m;\n    }\n}\n\nlong long binomial(long long n, long long k, long long m) {\n    long long tmp = (factorial(n, m) * invMod(factorial(k, m), m) + m) % m;\n    return (tmp * invMod(factorial(n - k, m), m) + m) % m;\n}\n\nint main() {\n    long long n;//ボール\n    long long k;//箱\n    cin >> n >> k;\n\n    long long ans = 0;\n    for (long long i = 0; i < k; ++i) {\n        long long tmp = (binomial(k, k - i, MOD) * powMod(k - i, n, MOD) + MOD) % MOD;\n        if (i % 2 == 0) {\n            ans = (ans + tmp + MOD) % MOD;\n        } else {\n            ans = (ans - tmp + MOD) % MOD;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n/*\n * n人を3つのグループにわけるとする。\n * 3^n-C(3,2)2^n+C(3,1)1^n\n * これを一般化する。\n *\n */\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"combination_table.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_C\"\n#line 1 \"/mnt/c/Users/leafc/dev/compro/lib/math/modint.hpp\"\n#include <cassert>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n#ifndef MOD_INT\n#define MOD_INT\n\ntemplate <std::uint_fast64_t MOD> class ModInt {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  ModInt(const u64 val = 0) { value = val % MOD; }\n\n  ModInt operator+(const ModInt rhs) const { return ModInt(*this) += rhs; }\n  ModInt operator-(const ModInt rhs) const { return ModInt(*this) -= rhs; }\n  ModInt operator*(const ModInt rhs) const { return ModInt(*this) *= rhs; }\n  ModInt operator/(const ModInt rhs) const { return ModInt(*this) /= rhs; }\n\n  ModInt &operator+=(const ModInt rhs) {\n    value += rhs.value;\n    if (value >= MOD) {\n      value -= MOD;\n    }\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt rhs) {\n    if (value < rhs.value) {\n      value += MOD;\n    }\n    value -= rhs.value;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt rhs) {\n    value = value * rhs.value % MOD;\n    return *this;\n  }\n\n  ModInt &operator/=(ModInt rhs) {\n    *this *= rhs.inv();\n    return *this;\n  }\n\n  ModInt &operator++(int n) {\n    value++;\n    if (value >= MOD) {\n      value -= MOD;\n    }\n    return *this;\n  }\n\n  ModInt &operator--(int n) {\n    if (value == 0) {\n      value += MOD;\n    }\n    value--;\n    return *this;\n  }\n\n  ModInt inv() { return ModInt::pow(*this, MOD - 2); }\n\n  static ModInt pow(ModInt base, long long int n) {\n    ModInt res = ModInt(1);\n    while (n) {\n      if (n & 1) {\n        res *= base;\n      }\n      base *= base;\n      n /= 2;\n    }\n    return res;\n  }\n\n  static ModInt comb(ModInt n, ModInt r) { return comb(n.value, r.value); }\n\n  static ModInt comb(int n, int r) {\n    if (n < r)\n      return ModInt(0);\n    ModInt res = ModInt(1);\n    for (int i = 0; i < r; i++) {\n      res *= ModInt(n - i);\n    }\n\n    ModInt inv = ModInt(1);\n    for (int i = 0; i < r; i++) {\n      inv *= ModInt(r - i);\n    }\n    return res / inv;\n  }\n\n  // nC0からnCnまでを計算する。計算量はO(n)\n  // @param n     要素数\n  // @param vec   結果を格納する配列\n  static void combination_table(int n, std::vector<ModInt> &vec) {\n    assert(static_cast<int>(vec.size()) >= n + 1);\n    vec[0] = ModInt(1);\n    for (int r = 1; r < n + 1; r++) {\n      vec[r] = vec[r - 1] * ModInt(n - r + 1) / ModInt(r);\n    }\n  }\n\n  u64 getValue() const { return value; }\n\nprivate:\n  u64 value;\n\n  friend std::ostream &operator<<(std::ostream &out, const ModInt<MOD> &m) {\n    out << m.value;\n    return out;\n  }\n\n  friend std::istream &operator>>(std::istream &in, ModInt &m) {\n    uint_fast64_t i;\n    in >> i;\n    m = ModInt(i);\n    return in;\n  }\n};\n\n#endif\n#line 4 \"combination_table.test.cpp\"\n\nusing mint = ModInt<(int)1e9 + 7>;\n\nint main() {\n  int n, k;\n  std::cin >> n >> k;\n  if (n < k) {\n    std::cout << 0 << std::endl;\n    return 0;\n  }\n\n  std::vector<mint> table(k + 1);\n  mint::combination_table(k, table);\n\n  mint ans(0);\n  for (int i = 0; i <= k; i++) {\n    mint tmp = table[i] * mint::pow(mint(k - i), n);\n    if (i % 2 == 0)\n      ans += tmp;\n    else\n      ans -= tmp;\n  }\n\n  std::cout << ans << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD = 1e9+7;\nconst ll N =1e5;\n\nll mod_pow(ll x,ll n,ll mod){\n\n  if(n==0)return 1;\n\n  ll res=mod_pow( x*x%mod , n/2 , mod );\n\n  if( n & 1 )res = res*x%mod;\n\n  return res;\n\n}\n\n\n\nll fact[N];\n\nll infact[N];\n\n\n\nvoid make_factorial(void){\n\n  fact[0] = 1;\n\n  for( ll i = 1 ; i < N ; i++ ){\n\n    fact[i] = fact[i-1] * i;\n\n    fact[i] %= MOD;\n\n  }\n\n  for( ll i = 0 ; i < N ; i++ ){\n\n    infact[i] = mod_pow( fact[i] , MOD-2 , MOD );\n\n  }\n\n}\n\n\n\nll comb(ll a,ll b){\n\n  if(a == 0 && b == 0)return 1;\n\n  if(a < b || a < 0)return 0;\n\n  ll tmp = infact[a-b]* infact[b] % MOD;\n\n  return tmp * fact[a] % MOD; \n\n}\n\nll f(ll n,ll k){\n  ll res=0;\n  for(int i=1;i<=k;i++){\n\tll ex=1;\n\tfor(int j=0;j<n;j++)ex=(ex*i)%MOD;\n  \n\tll tmp=(comb(k,i)*ex)%MOD;\n\tif((k-i)%2)res+=(MOD-tmp)%MOD;\n\telse res+=tmp;\n\tres%=MOD;\n  }\n  return res;\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  if(n<k){\n\tcout<<0<<endl;\n\treturn 0;\n  }\n  make_factorial();\n  cout<<f(n,k)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,k);\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      (rinv*=inverse(k))%=MOD;\n      if(k%2) (res+=MOD-rinv)%=MOD;\n      else (res+=rinv)%=MOD;\n    }\n    for(Int i=1;i<=n;i++)\n      (res*=i)%=MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  Int ans=0;\n  for(Int i=1;i<=k;i++){\n    Int res=mod.C(k,i)*mod.pow(i,n)%MOD;\n    if((k-i)&1) ans+=MOD-res;\n    else ans+=res;\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nLL n, k;\nconst LL MOD = 1000000007;\nLL combi(LL N_, LL C_) {\n\tconst int NUM_ = 400001;\n\tstatic LL fact[NUM_ + 1], factr[NUM_ + 1], inv[NUM_ + 1];\n\tif (fact[0] == 0) {\n\t\tinv[1] = fact[0] = factr[0] = 1;\n\t\tfor (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfor (int i = 1; i <= NUM_; ++i) fact[i] = fact[i - 1] * i%MOD, factr[i] = factr[i - 1] * inv[i] % MOD;\n\t}\n\tif (C_<0 || C_>N_) return 0;\n\treturn factr[C_] * fact[N_] % MOD*factr[N_ - C_] % MOD;\n}\n\nLL hcomb(int P_, int Q_) { return (P_ == 0 && Q_ == 0) ? 1 : combi(P_ + Q_ - 1, Q_); }\n\nLL modpow(LL a, LL n = MOD - 2) {\n\tLL r = 1;\n\twhile (n) r = r*((n % 2) ? a : 1) % MOD, a = a*a%MOD, n >>= 1;\n\treturn r;\n}\n\nlong long power(long long n, long long k, long long m) {\n\tif (k == 0) {\n\t\treturn 1;\n\t}\n\telse if (k % 2 == 1) {\n\t\treturn power(n, k - 1, m)*n%m;\n\t}\n\telse {\n\t\tlong long t = power(n, k / 2, m);\n\t\treturn t*t%m;\n\t}\n}\n\nint main() {\n\tcin >> n >> k;\n\tLL ans = 0;\n\tfor (int i = 1; i <= k; i++) {\n\t\tif ((k - i) % 2) {\n\t\t\tans -= combi(k, i)*power(i, n, MOD) % MOD;\n\t\t}\n\t\telse {\n\t\t\tans += combi(k, i)*power(i, n, MOD) % MOD;\n\t\t}\n\t\tans = (ans + MOD) % MOD;\n\t}\n\tcout << (ans + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconstexpr long long MOD = 1'000'000'007;\n\nclass binomial_coefficients {\n\tlong long MAX_VAL;\n\tvector<long long> fac, mmi;\n\npublic:\n\n\tbinomial_coefficients(){\n\t}\n\t\n\tbinomial_coefficients(long long num){\n\t\tinit(num);\n\t}\n\t\n\t~binomial_coefficients(){\n\t\t\n\t}\n\t\n\tvoid init(long long num){\n\t\tMAX_VAL = num+1; \n\t\tfac.resize(MAX_VAL);\n\t\tmmi.resize(MAX_VAL);\n\t\t\n\t\tfactorial_mod();\n\t\tmodular_multiplicatibe_inverse();\n\t}\n\t\n\tvoid factorial_mod(){\n\t\t fac[0] = 1;\n\t\tfor(long long i = 1; i < MAX_VAL; fac[i] %= MOD, i++)\n\t\t\tfac[i] = fac[i - 1] * (i % MOD);\n\t}\n\t\n\tlong long power(long long x, long long n){\n\t\tlong long ans = 1;\n\t\tfor(;n;n >>= 1, x *= x, ans %= MOD, x %= MOD)\n\t\t\tif(n&1)ans*=x;\n\t\treturn ans % MOD;\n\t}\n\t\n\tvoid exgcd(long long a, long long b, long long &x, long long &y){\n\t\tif(b == 0){\n\t\t\tx = 1;\n\t\t\ty = 0;\n\t\t\treturn ;\n\t\t}\n\t\texgcd(b, a % b, y, x);\n\t\ty -= a / b * x;\n\t}\n\t\n\tvoid modular_multiplicatibe_inverse(){\n\t\tlong long x, y;  \n\t\texgcd(fac[MAX_VAL - 1], MOD, x, y);\n\t\tmmi[MAX_VAL-1] = (x % MOD + MOD) % MOD;\n\t\t// mmi[MAX_VAL-1] = power(fac[MAX_VAL-1], MOD-2);\n\t\tfor(long long i = MAX_VAL - 2; i >= 0; mmi[i]%=MOD, i--)\n\t\t\tmmi[i] = mmi[i + 1] * ((i + 1) % MOD);\n\t}\n\t\n\tlong long combination(long long n, long long r){\n\t\treturn n < r ? 0 :fac[n] * (mmi[r] * mmi[n-r] % MOD) % MOD;\n\t}\n};\n\n\nint main(){\n\t\n\tlong long n, k;\n\tlong long ans = 0;\n\tbinomial_coefficients bc;\n\t\n\tcin>>n>>k;\n\t\n\tbc.init(n+k);\n\t\n\t\n\tfor(int i = 0; i <= k; i++){\n\t\tif(i%2) {\n\t\t\tans += (MOD - bc.combination(k, i) * bc.power(k - i, n)%MOD);\n\t\t} else {\n\t\t\tans += bc.combination(k, i) * bc.power(k - i, n);\n\t\t}\n\t\t\n\t\tans %= MOD;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define repp(i, n) rep(i, n)\n#define reppp(i, n) repp(i, n)\n#define rrepp(i, n) rrep(i, n)\n#define repss(i, n) reps(i, n)\n#define repcc(i, n) repc(i, n)\n#define repii(i, a, b) repi(i, a, b)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt(): x(0) {}\n  ModInt(i64 a) { x = a % mod; if (x < 0) x += mod; }\n  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n  ModInt &operator*=(ModInt that) { x = (i64) x * that.x % mod; return *this; }\n  ModInt &operator/=(ModInt that) { return *this *= power(that, mod - 2); }\n  ModInt operator+(ModInt that) { return ModInt(*this) += that; }\n  ModInt operator-(ModInt that) { return ModInt(*this) -= that; }\n  ModInt operator*(ModInt that) { return ModInt(*this) *= that; }\n  ModInt operator/(ModInt that) { return ModInt(*this) /= that; }\n  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n};\n\nusing mint = ModInt<1000000007>;\n\ntemplate <typename T>\nstruct ModCalc {\n  vector<T> fac, finv;\n  ModCalc(int max) {\n    fac = vector<T>(max + 1);\n    finv = vector<T>(max + 1);\n    fac[0] = 1;\n    reps(i, max) fac[i] = fac[i - 1] * i;\n    finv[max] = (T) 1 / fac[max];\n    rreps(i, max) finv[i - 1] = finv[i] * i;\n  }\n  T com(int a, int b) {\n    if (a < 0 || b < 0 || b > a) return 0;\n    return fac[a] * finv[a - b] * finv[b];\n  }\n};\n\nusing mcalc = ModCalc<mint>;\nauto mc = mcalc(1010);\n\nvoid solve() {\n  int n, k; cin >> n >> k;\n  mint ans = 0;\n  repc(i, k) {\n    if ((k - i) % 2 == 0) ans += mc.com(k, i) * power((mint) i, n);\n    else ans -= mc.com(k, i) * power((mint) i, n);\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\ntemplate<int64_t mod>\nstruct modint {\n    using LL = int64_t;\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\ntemplate<typename Field>\nstruct Combination {\n    vector<Field> _fact, _rfact, _inv;\n\n    Combination(int n) : _fact(n), _rfact(n), _inv(n) {\n        _fact[0] = _rfact[n-1] = 1;\n        for (int i = 1; i < n; ++i) _fact[i] = _fact[i-1] * i;\n        _rfact[n-1] /= _fact[n-1];\n        for (int i = n-1; i > 0; --i) _rfact[i-1] = _rfact[i] * i;\n        for (int i = 1; i < n; ++i) _inv[i] = _rfact[i] * _fact[i-1];\n    }\n\n    inline Field fact(int k) const { return _fact.at(k); }\n\n    inline Field rfact(int k) const { return _rfact.at(k); }\n\n    inline Field inv(int k) const { assert(k != 0); return _inv.at(k); }\n\n    Field P(int n, int r) const {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * rfact(n-r);\n    }\n\n    Field C(int n, int r) const {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * rfact(r) * rfact(n-r);\n    }\n\n    Field H (int n, int r) const {\n        return (n == 0 && r == 0) ? 1 : C(n+r-1, r);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int N, K; cin >> N >> K;\n\n    using Int = modint<MOD>;\n\n    Combination<Int> comb(K+1);\n\n    Int ans = 0;\n    for (int l = 0; l < K; ++l) {\n        ans += Int{K-l}.pow(N) * comb.C(K, l) * (l & 1 ? -1 : 1);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntypedef long long ll;\nusing namespace std;\n\nll dp[1001][1001];\n\nll solve(ll n, ll k, ll m) {\n  dp[0][0] = 1;\n  for(int i=1;i<=n;++i) {\n    for(int j=1;j<=i;++j) {\n      dp[i][j] = j*(dp[i-1][j-1] + dp[i-1][j]) % m;\n    }\n  }\n  return dp[n][k];\n}\n\nint main() {\n  ll n,k,mod=1e9+7;\n  cin>>n>>k;\n  cout<<solve(n,k,mod)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nconst int INF = 1e9;\nconst long long INFLL = 1LL<<60;\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nstruct combination {\n  vector<mint> fact, ifact;  // 階乗と階乗の逆元\n  combination(int n):fact(n+1),ifact(n+1) {  // 階乗と階乗の逆元を n まで求める\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll n, k;\n  cin >> n >> k;\n\n  mint ans;\n  combination comb(k);\n  for (ll i = 0; i <= k; i++) {\n    mint tmp = comb(k, i) * mint(i).pow(n);\n    if ((k-i) % 2 == 1) ans -= tmp;\n    else ans += tmp;\n  }\n\n  cout << ans.x << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1000000007LL;\n\ntemplate <ll mod> class ModInt {\n    ll a;\npublic:\n    constexpr ModInt(const ll a = 0) noexcept : a((a % mod + mod) % mod) {}\n    constexpr ll &value() noexcept { return a; }\n    constexpr ModInt operator + (const ModInt &rhs) const noexcept { return ModInt(*this) += rhs; }\n    constexpr ModInt operator - (const ModInt &rhs) const noexcept { return ModInt(*this) -= rhs; }\n    constexpr ModInt operator * (const ModInt &rhs) const noexcept { return ModInt(*this) *= rhs; }\n    constexpr ModInt operator / (const ModInt &rhs) const noexcept { return ModInt(*this) /= rhs; }\n    constexpr ModInt &operator += (const ModInt &rhs) noexcept {\n        a += rhs.a;\n        if (a >= mod) a -= mod;\n        return *this;\n    }\n    constexpr ModInt &operator -= (const ModInt &rhs) noexcept {\n        a += mod - rhs.a;\n        if (a >= mod) a -= mod;\n        return *this;\n    }\n    constexpr ModInt &operator *= (const ModInt &rhs) noexcept {\n        a = a * rhs.a % mod;\n        return *this;\n    }\n    constexpr ModInt pow(ll t) const noexcept {\n        if (t == 0) return 1;\n        auto ret = pow(t >> 1);\n        ret *= ret;\n        if (t & 1) ret *= *this;\n        return ret;\n    }\n    constexpr ModInt inv() const noexcept { return pow(mod - 2); }\n    constexpr ModInt operator /=(const ModInt &rhs) { return (*this) *= rhs.inv(); }\n    constexpr bool operator == (const ModInt &rhs) const noexcept { return this->a == rhs.a; }\n    constexpr bool operator != (const ModInt &rhs) const noexcept { return this->a != rhs.a; }\n    friend constexpr ostream &operator << (ostream &os, const ModInt &rhs) noexcept { return os << rhs.a; }\n    friend constexpr istream &operator >> (istream &is, ModInt &rhs) {\n        is >> rhs.a;\n        return is;\n    }\n};\nusing mint = ModInt<MOD>;\n\nclass Combination {\npublic:\n    vector <mint> fac, inv, fiv;\n    Combination(int N) : fac(N + 1), inv(N + 1), fiv(N + 1) {\n        fac[0] = inv[0] = fiv[0] = fac[1] = inv[1] = fiv[1] = 1;\n        for (ll i = 2; i <= N; i++) {\n            fac[i] = fac[i - 1] * i; // n!\n            inv[i] = inv[MOD % i] * (MOD - MOD / i); // n^-1\n            fiv[i] = fiv[i - 1] * inv[i]; // (n!)^-1\n        }\n    }\n    mint C(ll n, ll k) {\n        if (k < 0 || n < k) return 0;\n        return fac[n] * fiv[k] * fiv[n - k];\n    }\n    mint P(ll n, ll k) {\n        if (k < 0 || n < k) return 0;\n        return fac[n] * fiv[n - k];\n    }\n    mint H(ll n, ll k) {\n        if (n == 0 && k == 0) return 1;\n        return C(n + k - 1, k - 1);\n    }\n};\n\n\n// verified\n//   https://yukicoder.me/problems/no/117\nvoid yuki117() {\n    int T;\n    cin >> T;\n    Combination com(2000005);\n    for (int t = 0; t < T; t++) {\n        string s;\n        cin >> s;\n        int n = 0, k = 0, i = 2;\n        while (s[i] != ',') { n *= 10; n += s[i++] - '0'; }\n        i++;\n        while (s[i] != ')') { k *= 10; k += s[i++] - '0'; }\n        if (s[0] == 'C') cout << com.C(n, k) << \"\\n\";\n        else if (s[0] == 'P') cout << com.P(n, k) << \"\\n\";\n        else cout << com.H(k, n) << \"\\n\";\n    }\n}\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/all/DPL_5_B\nvoid AOJ_DPL_5_B() {\n    int n, k;\n    cin >> n >> k;\n    Combination com(k);\n    cout << com.P(k, n) << \"\\n\";\n}\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_C\nvoid AOJ_DPL_5_C() {\n    int n, k;\n    cin >> n >> k;\n    Combination com(k);\n    mint ans = 0;\n    for (int i = 0; i < k; i++) {\n        mint sgn = i % 2 == 0 ? 1 : -1;\n        ans += sgn * com.C(k, k - i) * ((mint)(k - i)).pow(n);\n    }\n    cout << ans << \"\\n\";\n}\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_D\nvoid AOJ_DPL_5_D() {\n    int n, k;\n    cin >> n >> k;\n    Combination com(n + k);\n    cout << com.H(n, k) << \"\\n\";\n}\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_E\nvoid AOJ_DPL_5_E() {\n    int n, k;\n    cin >> n >> k;\n    Combination com(k);\n    cout << com.C(k, n) << \"\\n\";\n}\n\n\n// verified\n//   https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_F\nvoid AOJ_DPL_5_F() {\n    int n, k;\n    cin >> n >> k;\n    Combination com(n);\n    cout << com.H(n - k, k) << \"\\n\";\n}\n\nint main() {\n    // yuki117();\n    // AOJ_DPL_5_B();\n    AOJ_DPL_5_C();\n    // AOJ_DPL_5_D();\n    // AOJ_DPL_5_E();\n    // AOJ_DPL_5_F();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;} return false;\n}\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint &rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept {\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept {\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    rep2(i,2,MAX){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int n,k; cin >> n >> k;\n    mint ans=0;\n    rep(i,k+1){\n        mint a=i;\n        mint tmp=pow(a,n)*COM(k,i);\n        if ((k-i)&1) ans-=tmp;\n        else ans+=tmp;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1001\n\nll POW[NUM];\nll nCm[NUM][NUM];\nll memo[NUM];\n\nint main(){\n\n\tll N,K;\n\tscanf(\"%lld %lld\",&N,&K);\n\n\tif(N < K){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\t//コンビネーションを求める\n\tnCm[0][0] = 1;\n\tfor(int n = 1; n <= K; n++) {\n\t\tfor (int k = 0; k <= N; k++) {\n\t\t\tif(k > 0){\n\t\t\t\tnCm[n][k] = nCm[n-1][k]+nCm[n-1][k-1];\n\t\t\t}else{ //k == 0\n\t\t\t\tnCm[n][k] = 1;\n\t\t\t}\n\t\t\tnCm[n][k] %= MOD;\n\t\t}\n\t}\n\n\tll tmp;\n\n\t//num^Nを作っておく\n\tfor(ll num = 1; num <= K; num++){\n\t\ttmp = 1;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\ttmp *= num;\n\t\t\ttmp %= MOD;\n\t\t}\n\t\tPOW[num] = tmp;\n\t}\n\n\tmemo[1] = 1;\n\n\tfor(ll num = 2; num <= K; num++){\n\n\t\tmemo[num] = POW[num];\n\n\t\tfor(int i = 1; i <= num-1; i++){\n\t\t\tmemo[num] -= nCm[num][i]*memo[i];\n\t\t\tmemo[num] %= MOD;\n\t\t\tif(memo[num] < 0)memo[num] += MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",memo[K]);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1e9+7;\nconst int N=1e3+10;\n\nll myPow(ll a,ll n)\n{\n    ll ans=1;\n    while(n>0)\n    {\n        if(n&1)\n        {\n            ans=ans*a%M;\n        }\n        a=a*a%M;\n        n>>=1;\n    }\n    return ans;\n}\n\nll fac[N],inv[N];\n\nvoid init()\n{\n    fac[0]=1;\n    for(int i=1;i<N;i++)\n    {\n        fac[i]=fac[i-1]*i%M;\n    }\n    inv[N-1]=myPow(fac[N-1],M-2);\n    for(int i=N-2;i>=0;i--)\n    {\n        inv[i]=inv[i+1]*(i+1)%M;\n    }\n}\n\nint main()\n{\n    init();\n    int n,k;\n    while(cin>>n>>k)\n    {\n        ll ans=0;\n        for(int i=0;i<k;i++)\n        {\n            ll tmp=fac[k]*inv[k-i]%M*inv[i]%M*myPow(k-i,n)%M;\n            ans+=(i%2?-1:1)*tmp;\n            ans=(ans+M)%M;\n        }\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\n\nll MOD = 1e9 + 7;\n\nclass Combination {\n    //a^p%mod\n    ll powmod(ll a, ll p) {\n        ll ans = 1LL;\n        ll mul = a;\n        // p >>=1 <-> p=(p >> 1)\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod) {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n\n        return ans;\n    }\npublic:\n    int N;\n    ll mod;\n    vector<ll> fact;\n    vector<ll> revFact;\n\n    Combination(int n, ll m) : N(n), mod(m), fact(n+1), revFact(n+1) {\n        fact[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            fact[i] = fact[i-1] * i;\n            fact[i] %= mod;\n        }\n\n        // Fermat's little theorem\n        revFact[N] = powmod(fact[N], mod - 2);\n\n        for (int i = N-1; i >= 0; i--) {\n            revFact[i] = revFact[i+1] * (i+1);\n            revFact[i] %= mod;\n        }\n    }\n\n    ll get(int a, int b) {\n        if (a < 0 || b < 0) return 0;\n        if (b > a) return 0;\n        return (((fact[a] * revFact[b]) % mod) * revFact[a-b]) % mod;\n    }\n};\n\nll powmod(ll a, ll b){\n    ll ret = 1;\n    ll c = a;\n    while(b > 0){\n        if(b % 2 == 1){\n            ret *= c;\n            ret %= MOD;\n        }\n\n        c = (c * c) % MOD;\n        b /= 2;\n    }\n\n    return ret;\n}\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n\n    Combination cm = Combination(K + 5, MOD);\n\n    ll ans = 0;\n    for(int i = 1; i < K; i++){\n        ll tmp = 1;\n\n        tmp *= cm.get(K, i);\n        tmp %= MOD;\n        tmp *= powmod(K - i, N);\n        tmp %= MOD;\n\n        if(i % 2 == 0){\n            ans -= tmp;\n            ans += MOD;\n            ans %= MOD;\n        } else {\n            ans += tmp;\n            ans %= MOD;\n        }\n    }\n\n    ans = powmod(K, N) - ans + MOD;\n    ans %= MOD;\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0;}\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n\nint main() {\n    int n,k;\n    cin >> k >> n;\n    mint sum(n);\n    sum = sum.pow(k);\n    mint tmp(0);\n    \n    for(int i = 1;i<=n;i++) {\n        combination comb(n);\n        mint cnt = mint(n-i).pow(k);\n        if(i%2==1) {\n            tmp += comb(n,i)*cnt;\n        } else {\n            tmp -= comb(n,i)*cnt;\n        }\n        // cout << tmp << endl;\n    }\n    // cout << sum << endl;\n    mint ans = sum - tmp;\n    cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\n\nll dp[1001][1001];\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n\n  dp[0][0]=1;\n  \n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=i;j++){\n      dp[i][j]+=dp[i-1][j-1]*(k-j+1);\n      dp[i][j]+=dp[i-1][j]*j;\n      dp[i][j]%=mod;\n    }\n  }\n  cout<<dp[n][k]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\n\n\n//---------------------------------------------------------------\ntemplate<int MOD> struct ModInt { int x;\n    explicit operator bool() const { return !!x; }\n    ModInt(int v = 0) : x(v % MOD) { if (x < 0) x += MOD; }\n    ModInt(long long v) : x(v % MOD) { if (x < 0) x += MOD; }\n    ModInt &operator+=(const ModInt &r) { if ((x += r.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &r) { if ((x += MOD - r.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &r) { x = 1LL * x * r.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt &r) { return *this *= r.inv(); }\n    ModInt operator-() const { return x ? ModInt(MOD - x) : ModInt(x); }\n    ModInt operator+(const ModInt &r) const { return ModInt(*this) += r; }\n    ModInt operator-(const ModInt &r) const { return ModInt(*this) -= r; }\n    ModInt operator*(const ModInt &r) const { return ModInt(*this) *= r; }\n    ModInt operator/(const ModInt &r) const { return ModInt(*this) /= r; }\n    ModInt inv() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n        return ModInt(u); } // x.pow(MOD-2)\n    ModInt pow(long long k) const { ModInt r(1), a(x);\n        while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\n    bool operator==(const ModInt r) const { return x == r.x; }\n    bool operator!=(const ModInt r) const { return x != r.x; }\n    bool operator< (const ModInt r) const { return x <  r.x; }\n    friend ostream& operator<<(ostream &os, const ModInt<MOD>& a) { return os << a.x; }\n    friend istream& operator>>(istream &is, ModInt<MOD>& a) { return is >> a.x; }\n};\ntemplate<typename T, int SZ> struct Comb { vector<T> _fac, _ifac, _inv;\n    Comb() : _fac(SZ + 1), _ifac(SZ + 1), _inv(SZ + 1) {\n        _fac[0] = _ifac[SZ] = _inv[0] = 1;\n        for (int i = 1; i <= SZ; i++) _fac[i] = _fac[i - 1] * i;\n        _ifac[SZ] /= _fac[SZ];\n        for (int i = SZ - 1; i >= 0; i--) _ifac[i] = _ifac[i + 1] * (i + 1);\n        for (int i = 1; i <= SZ; i++) _inv[i] = _ifac[i] * _fac[i - 1]; }\n    T inv(int n) { return n < 0 ? T(0) : _inv[n]; }\n    T fac(int n) { return n < 0 ? T(0) : _fac[n]; }\n    T ifac(int n) { return n < 0 ? T(0) : _ifac[n]; }\n    T P(int a, int b) { return (b < 0 || a < b) ? T(0) : _fac[a] * _ifac[a - b]; }\n    T C(int a, int b) { return b < 0 ? T(0) : P(a, b) * _ifac[b]; }\n    T H(int n, int k) { if (n < 0 || k < 0) return T(0);\n        return k == 0 ? T(0) : C(n + k - 1, k); }\n    T S(int n, int k) { T r = 0;\n        for (int i = 0; i <= k; i++) {\n            T t = C(k, i) * T(i).pow(n); r += ((k - i) & 1 ? -t : t);\n        }\n        return r * _ifac[k];\n    }\n};\ntypedef ModInt<MOD> mint;\n//---------------------------------------------------------------\n\nint main() {\n    Comb<mint, 250000> com;\n    int n, k; cin >> n >> k;\n    cout << com.S(n, k) * com.fac(k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define RFOR(i,n,m) for(int i=(int)(n); i>=(int)(m); i--)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\n#define ld long double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--ModInt\n//-------------------------------------------------\nconst ::std::uint_fast64_t MOD = 1e9+7;\n\nclass mint\n{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    mint():n(0){}\n    mint(::std::int_fast64_t _n):n(_n<0 ? MOD-(-_n)%MOD : _n%MOD){}\n    mint(const mint &m):n(m.n){}\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const mint &a){\n\t\treturn os << a.n;\n\t}\n    friend ::std::istream& operator>>(::std::istream &is, mint &a){\n        value_type temp; is>>temp;\n        a = mint(temp);\n        return is;\n    }\n\n    mint& operator+=(const mint &m){n+=m.n; n=(n<MOD)?n:n-MOD; return *this;}\n    mint& operator-=(const mint &m){n+=MOD-m.n; n=(n<MOD)?n:n-MOD; return *this;}\n    mint& operator*=(const mint &m){n=n*m.n%MOD; return *this;}\n    mint& operator/=(const mint &m){return *this*=m.inv();}\n    mint& operator++(){return *this+=1;}\n    mint& operator--(){return *this-=1;}\n\n    mint operator+(const mint &m) const {return mint(*this)+=m;}\n    mint operator-(const mint &m) const {return mint(*this)-=m;}\n    mint operator*(const mint &m) const {return mint(*this)*=m;}\n    mint operator/(const mint &m) const {return mint(*this)/=m;}\n    mint operator++(int){mint t(*this); *this+=1; return t;}\n    mint operator--(int){mint t(*this); *this-=1; return t;}\n\n    mint operator==(const mint &m) const {return n==m.n;}\n    mint operator!=(const mint &m) const {return n!=m.n;}\n    mint operator-() const {return mint(MOD-n);}\n\n    mint pow(value_type b) const {\n        mint ret(1), m(*this);\n        while(b){\n            if (b & 1) ret*=m;\n            m*=m;\n            b>>=1;\n        }\n        return ret;\n    }\n\n    mint inv() const {return pow(MOD-2);}\n};\n\n//-------------------------------------------------\n//--Combination (depends on ModInt)\n//-------------------------------------------------\nclass Combination\n{\nprivate:\n    ::std::vector<mint> _fact;\n    ::std::vector<mint> _finv;\npublic:\n    Combination(int n):_fact(n+1), _finv(n+1){\n        _fact[0] = _fact[1] = 1;\n        _finv[0] = _finv[1] = 1;\n        for(int i=2; i<=n; i++){\n            _fact[i] = _fact[i-1]*i;\n            _finv[i] = _fact[i].inv();\n        }\n    }\n    mint fact(int x){return _fact[x];}\n    mint finv(int x){return _finv[x];}\n    mint comb(int x, int y){\n        if (y>x || y<0) return 0;\n        return _fact[x]*_finv[y]*_finv[x-y];\n    }\n    mint homo(int x, int y){return comb(x+y-1, y);}\n};\n\n//-------------------------------------------------\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,k; cin>>n>>k;\n    Combination bn(k);\n    mint ans = 0;\n    FOR(i,0,k){\n        if (i&1){\n            ans -= bn.comb(k,i)*mint(k-i).pow(n);\n        }else{\n            ans += bn.comb(k,i)*mint(k-i).pow(n);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://www.igaris.com/math/c.pdf\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define NEXTP(x) next_permutation(x.begin(),x.end())\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nclass comb{\n\tpublic:\n\tvector<ll> f,fr;\n\tll MOD;\n\t//a^(p-1) = 1 (mod p)(p->Prime numbers)\n\t//a^(p-2) = a^(-1)\n\tll calc(ll a,ll b,ll p){//a^(b) mod p   \n\t\tif(b==0)return 1;\n\t\tll y = calc(a,b/2,p);y=(y*y)%p;\n\t\tif(b & 1) y = (y * a) % p;\n\t\treturn y;\n\t}\n\tvoid init(ll n,ll mod){//input max_n\n\t\tMOD = mod;\n\t\tf.resize(n+1);\n\t\tfr.resize(n+1);\n\t\tf[0]=fr[0]=1;\n\t\tfor(ll i=1;i<n+1;i++){\n\t\t\tf[i] = (f[i-1] * i) % mod;\n\t\t\tfr[i] = calc(f[i],mod-2,mod);\n\t\t}\n\t}\n\tll nCr(ll n,ll r){\n\t\treturn f[n] * fr[r] % MOD * fr[n-r] % MOD;\n\t}\n};\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n,k;\n\tcin >> n >> k;\n\tcomb co;\n\tco.init(n+k,MOD);\n\tll ans = 0;\n\tFOR(i,1,k+1){\n\t\tans += co.calc(-1,k-i,MOD)*co.nCr(k,i)%MOD*co.calc(i,n,MOD)%MOD;\n\t\tans %= MOD;\n\t}\n\tif(ans<0)ans+=MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing VS = vector<string>;\nusing VB = vector<bool>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\nusing PII = std::pair<int, int>;\nusing PLL = std::pair<ll, ll>;\nusing TI3 = std::tuple<int, int, int>;\nusing TI4 = std::tuple<int, int, int, int>;\nusing TL3 = std::tuple<ll, ll, ll>;\nusing TL4 = std::tuple<ll, ll, ll, ll>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define rep3(i, s, n, d) for (int i = (s); i < (int)(n); i += (d))\n#define allpt(v) (v).begin(), (v).end()\n#define allpt_c(v) (v).cbegin(), (v).cend()\n#define allpt_r(v) (v).rbegin(), (v).rend()\n\nconst int mod1 = 1e9 + 7, mod2 = 998244353, mod3 = 1e9 + 9;\nconst int mod = mod1;\nconst ll inf = 1e18;\n\nconst string wsp = \" \";\nconst string tb = \"\\t\";\nconst string rt = \"\\n\";\n\ntemplate <typename T>\nvoid show1dvec(const vector<T> &v)\n{\n    if (v.size() == 0)\n        return;\n    int n = v.size() - 1;\n    rep(i, n) cout << v[i] << wsp;\n    cout << v[n] << rt;\n\n    return;\n}\n\ntemplate <typename T>\nvoid show2dvec(const vector<vector<T>> &v)\n{\n    int n = v.size();\n    rep(i, n) show1dvec(v[i]);\n}\n\ntemplate <typename T, typename S>\nvoid show1dpair(const vector<pair<T, S>> &v)\n{\n    int n = v.size();\n    rep(i, n) cout << v[i].first << wsp << v[i].second << rt;\n    return;\n}\n\ntemplate <typename T, typename S>\nvoid pairzip(const vector<pair<T, S>> &v, vector<T> &t, vector<T> &s)\n{\n    int n = v.size();\n    rep(i, n)\n    {\n        t.push_back(v[i].first);\n        s.push_back(v[i].second);\n    }\n    return;\n}\n\ntemplate <typename T>\nvoid maxvec(vector<T> &v)\n{\n    T s = v[0];\n    int n = v.size();\n    rep(i, n - 1)\n    {\n        if (s > v[i + 1])\n        {\n            v[i + 1] = s;\n        }\n        s = v[i + 1];\n    }\n}\n\ntemplate <typename T, typename S>\nbool myfind(T t, S s)\n{\n    return find(t.cbegin(), t.cend(), s) != t.cend();\n}\n\nbool check(int y, int x, int h, int w)\n{\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\ntemplate <typename T>\nvector<T> cumsum(const vector<T> &v)\n{\n    T s = 0;\n    vector<T> ret;\n\n    rep(i, v.size())\n    {\n        s += v[i];\n        s %= mod;\n        ret.emplace_back(s);\n    }\n    return ret;\n}\n\nbool iskadomatsu(int a, int b, int c)\n{\n    return (a != b && b != c && c != a) && ((a > b && b < c) || (a < b && b > c));\n}\n\nVS split(string s, char c)\n{\n    VS ret;\n    string part;\n    s += c;\n    rep(i, s.length())\n    {\n        if (s[i] == c)\n        {\n            ret.emplace_back(part);\n            part = \"\";\n        }\n        else if (s[i] != c)\n        {\n            part += s[i];\n        }\n    }\n    return ret;\n}\n\nstring removezero(string &s)\n{\n    string ret;\n    for (auto z : s)\n        if (z != '0')\n            ret += z;\n    return ret;\n}\n\nll sumdigit(ll x)\n{\n    ll ans{0};\n    while (x > 0)\n    {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ntemplate <typename T, typename S, typename R>\nll pow_mod(T p, S q, R mod = 1ll)\n{\n    ll ret = 1, r = p;\n    while (q)\n    {\n        if (q % 2)\n            ret *= r, ret %= mod;\n        r = (r * r) % mod, q /= 2;\n    }\n    return ret % mod;\n}\n\ntemplate <typename T, typename S>\nll pow_no_mod(T p, S q)\n{\n    ll ret = 1, r = p;\n    while (q)\n    {\n        if (q % 2)\n            ret *= r;\n        r = (r * r), q /= 2;\n    }\n    return ret;\n}\n\nvoid make_frac_tables(VL &frac_list, VL &frac_inv_list)\n{\n    rep(i, frac_list.size() - 1)\n    {\n        frac_list[i + 1] *= frac_list[i] * (i + 1);\n        frac_list[i + 1] %= mod;\n        frac_inv_list[i + 1] *= frac_inv_list[i] * pow_mod(i + 1, mod - 2, mod);\n        frac_inv_list[i + 1] %= mod;\n    }\n}\n\nll comb(int a, int b, const VL &frac_list, const VL &frac_inv_list)\n{\n    if (a < b)\n        return 0;\n    if (b < 0)\n        return 0;\n    ll ret = frac_list[a];\n    ret *= frac_inv_list[b];\n    ret %= mod;\n    ret *= frac_inv_list[a - b];\n    ret %= mod;\n    return ret;\n}\n\n\nint main()\n{\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, k;\n    const int m = 10000;\n    cin >> n >> k;\n    if (n < k)\n    {\n        cout << 0 << rt;\n        return 0;\n    }\n    ll p, d{1ll}, ans{0ll};\n    VL frac(m, 1), frac_inv(m, 1);\n    make_frac_tables(frac, frac_inv);\n    rep(i, n)\n    {\n        p = comb(k, k - i, frac, frac_inv);\n        p *= pow_mod(k - i, n, mod);\n        p %= mod;\n        p = p * d + 20ll * mod;\n        p %= mod;\n        ans += p;\n        ans %= mod;\n        d *= -1;\n    }\n    cout << ans << rt;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    mint nPk(int n, int k) {\n        if (n < k) return 0;\n        if (n < 0 || k < 0) return 0;\n        return fact[n] * ifact[n - k];\n    }\n\n} combination(10000);\n\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    mint ans = 0;\n    for (int i = 0; i < k; i++) {\n        mint sign = i % 2 == 0 ? 1 : -1;\n        mint c = combination(k, i);\n        mint j = (mint(k - i)).pow(n);\n        ans += sign * c * j;\n    }\n\n    cout << ans.x << endl;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\n#define MK make_pair\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll mod_pow(ll a,ll x){\n    ll ans=1;\n    for(int i=0;i<63;i++){\n        if(x>>i&1){ans*=a; ans%=MOD;}\n        a*=a;\n        a%=MOD;\n    }\n    return ans;\n}\n\nll R(ll a){\n    return mod_pow(a,MOD-2);\n}\n\nll factorial(ll n){\n    ll ret=1;\n    for(int i=2;i<=n;i++){\n        ret*=i%MOD;\n        ret%=MOD;\n    }\n    return ret;\n}\n\nll c(ll n,ll k){\n    return factorial(n)*R(factorial(n-k))%MOD*R(factorial(k))%MOD;\n}\n\nll gcd(ll a,ll b){\n    if(a%b==0){return b;}\n    return gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n    return a/gcd(a,b)*b;\n}\n\nbool prime(ll p){\n    for(int i=2;i*i<=p;i++){\n        if(p%i==0){return false;}\n    }\n    return true;\n}\n\nvector<ll> mk_prime(ll mx){\n    vector<ll> p={2};\n    for(int i=3;i<=mx;i++){\n        bool j=true;\n        for(int t=0;p[t]*p[t]<=i;t++){\n            if(i%p[t]==0){j=false; break;}\n        }\n        if(j){p.push_back(i);}\n    }\n    return p;\n}\n\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    ll ans=0;\n    for(ll i=1;i<=k;i++){\n        if((k-i)%2){ans-=c(k,i)*mod_pow(i,n)%MOD;}\n        else{ans+=c(k,i)*mod_pow(i,n)%MOD;}\n        ans%=MOD;\n    }\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto  operator++(int) {modular result(*this); operator++(); return result;}\n    auto  operator--(int) {modular result(*this); operator--(); return result;}\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> power (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\n// using mod_type = int;\n\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\ntemplate < typename Value >\nclass factorials {\n    std::vector< Value > fact, finv;\n\n  public:\n    factorials()=default;\n\n    void build(int n) {\n      fact.resize(n), finv.resize(n);\n      fact.at(0) = 1;\n      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * Value(i);\n      finv.at(n - 1) = Value(1) / fact.at(n - 1);\n      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * Value(i + 1);\n    }\n    auto operator()  (int i) const {return fact.at(i);}\n    auto inv         (int i) const {return finv.at(i);}\n    auto binom(int i, int j) const {\n      assert(0 <= i);\n      if (j < 0 ||i < j) return Value(0);\n      return fact.at(i) * finv.at(j) * finv.at(i - j);\n    }\n    auto deal(int i, int j) const\n      { return binom(i + j - 1, j - 1); }\n};\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, k; std::cin >> n >> k;\n  factorials<mint> fact;\n  fact.build(n+k+1);\n  std::vector<mint> dp(k+1);\n  dp.at(0) = 0;\n  rep(i,1,k+1) {\n    mint& crr = dp.at(i);\n    crr = power(mint{i},n);\n  }\n  debug(dp);\n  rep(i,1,k+1) {\n    mint & crr = dp.at(i);\n    rep(j,0,i) {\n      mint now = dp.at(j);\n      now *= fact.binom(i,j);\n      crr -= now;\n    }\n  }\n  debug(dp);\n  mint ans = dp.at(k);\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// a quote from http://www.igaris.com/math/c.pdf\n\n#define MOD (1000000000+7)\n\nlong long dp[1001];\n\nlong long C[1001][1001];\n\n\n\nlong long power( long long x, int n )\n{\n\tif( n == 0 ) {\n\t\treturn 1;\n\t}\n\tif( n % 2 ) {\n\t\treturn x * power( x, n - 1 ) % MOD;\n\t}\n\telse {\n\t\treturn power( x * x % MOD, n / 2 );\n\t}\n}\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\n\tlong long ans = 0;\n\tif( n >= k ) {\n\t\t// Pascal's triangle for combination\n\t\tC[0][0] = 1;\n\t\tfor( int i = 1; i < 1001; i++ ) {\n\t\t\tfor( int j = 0; j <= i; j++ ) {\n\t\t\t\tif( j == 0 || j == i ) {\n\t\t\t\t\tC[i][j] = C[i - 1][0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tC[i][j] = ( C[i - 1][j - 1] + C[i - 1][j] ) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdp[1] = 1;\n\t\tfor( int i = 2; i <= k; i++ ) {\n\t\t\tlong long po = power( i, n ) % MOD;\n\t\t\tfor( int j = 1; j < i; j++ ) {\n\t\t\t\tpo -= ( C[i][j] * dp[j] ) % MOD;\n\t\t\t\tpo %= MOD;\n\t\t\t\tif( po < 0 ) {\n\t\t\t\t\tpo += MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = po;\n\t\t}\n\t\tans = dp[k];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1001\n\nll POW[NUM];\nll nCm[NUM][NUM];\nll memo[NUM];\n\nint main(){\n\n\tll N,K;\n\tscanf(\"%lld %lld\",&N,&K);\n\n\tif(N < K){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\t//コンビネーションを求める\n\tnCm[0][0] = 1;\n\tfor(int n = 1; n <= K; n++) {\n\t\tfor (int k = 0; k <= N; k++) {\n\t\t\tif(k > 0){\n\t\t\t\tnCm[n][k] = nCm[n-1][k]+nCm[n-1][k-1];\n\t\t\t}else{ //k == 0\n\t\t\t\tnCm[n][k] = 1;\n\t\t\t}\n\t\t\tnCm[n][k] %= MOD;\n\t\t}\n\t}\n\n\tll tmp;\n\n\t//num^Nを作っておく\n\tfor(ll num = 1; num <= K; num++){\n\t\ttmp = 1;\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\ttmp *= num;\n\t\t\ttmp %= MOD;\n\t\t}\n\t\tPOW[num] = tmp;\n\t}\n\n\tmemo[1] = 1;\n\n\tfor(ll num = 2; num <= K; num++){\n\n\t\tmemo[num] = POW[num];\n\n\t\tfor(int i = 1; i <= num-1; i++){\n\t\t\tmemo[num] -= nCm[num][i]*memo[i];\n\t\t\tmemo[num] %= MOD;\n\t\t\tif(memo[num] < 0)memo[num] += MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",memo[K]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n// chmax, chmin\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// debug stream of pair, vector \n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n\ntemplate<int MODULO> struct Fp {\n    long long val;\n\n    constexpr Fp(long long v = 0) noexcept : val(v % MODULO) {\n        if (val < 0) v += MODULO;\n    }\n    constexpr Fp operator - () const noexcept {\n        return val ? MODULO - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MODULO) val -= MODULO;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MODULO;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MODULO;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MODULO, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MODULO;\n        if (val < 0) val += MODULO;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n};\n\ntemplate<int MODULO> constexpr ostream& operator <<\n(ostream &os, const Fp<MODULO>& x) noexcept {\n    return os << x.val;\n}\ntemplate<int MODULO> constexpr istream& operator >>\n(istream &is, Fp<MODULO>& x) noexcept {\n    return is >> x.val;\n}\n\ntemplate<int MODULO> constexpr Fp<MODULO> modpow\n(const Fp<MODULO> &a, long long n) noexcept {\n    if (n == 0) return 1;\n    auto t = modpow(a, n / 2);\n    t = t * t;\n    if (n & 1) t = t * a;\n    return t;\n}\n\n\ntemplate<int MODULO> struct BiCoef {\n    vector<Fp<MODULO> > fac, inv, finv;\n    constexpr BiCoef(int n = 210000) noexcept : fac(n, 1), inv(n, 1), finv(n, 1) {\n        for(int i = 2; i < n; i++){\n            fac[i] = fac[i-1] * i;\n            inv[i] = -inv[MODULO%i] * (MODULO/i);\n            finv[i] = finv[i-1] * inv[i];\n        }\n    }\n    constexpr Fp<MODULO> com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fac[n] * finv[k] * finv[n-k];\n    }\n};\n\n\nconst int MAX = 201010;\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\n\nint main() {\n    BiCoef<MOD> bc(MAX);\n\n    int N, K;\n    cin >> N >> K;\n    mint res = 0;\n    for (int i = 0; i <= K; ++i) {\n        mint tmp = bc.com(K, i) * modpow(mint(i), N);\n        if ( (K-i) & 1 ) res -= tmp;\n        else res += tmp;\n    }\n    cout << res << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nll MOD = 1000000007;\n//ll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\n\n//二項演算\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\n\nmint comb_simple(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\nll N, K;\nint main(){\n  COMinit();\n  cin >> N >> K;\n  mint ans = 0;\n  for(ll i = 0; i < K; i++){//少なくともiこの箱が空っぽ\n    if(i % 2) ans -= comb(K, i) * pow_mod(K-i, N);\n    else ans += comb(K, i) * pow_mod(K-i, N);\n  }\n  ans.get();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\") //コンパイラ最適化用\n\n#define _GLIBCXX_DEBUG //配列に[]でアクセス時のエラー表示\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n// forループ関係\n#define REP(i, n) for (ll i = 0; i < ll(n); i++)\n#define REPD(i, n) for (ll i = n - 1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = a; i < ll(b); i++)\n#define FORD(i, a, b) for (ll i = a; i > ll(b); i--)\n// xにはvectorなどのコンテナ\n#define ALL(x) x.begin(), x.end() // sortなどの引数を省略したい\n#define SIZE(x) ll(x.size())      // sizeをsize_tからllに直しておく\n//定数\n#define INF 1000000000000 // 10^12:極めて大きい値,∞\nconst int MOD = 1000000007;\n#define MAXR 100000 // 10^5:配列の最大のrange(素数列挙などで使用)\n//略記\n#define PB push_back // vectorヘの挿入\n#define MP make_pair // pairのコンストラクタ\n#define F first      // pairの一つ目の要素\n#define S second     // pairの二つ目の要素\n#define Umap unordered_map\n#define Uset unordered_set\n#define P pair<ll, ll>\nconst unsigned int BIT_FLAG_0 = (1 << 0); // 0000 0000 0000 0001\nconst unsigned int BIT_FLAG_1 = (1 << 1); // 0000 0000 0000 0010\nconst unsigned int BIT_FLAG_2 = (1 << 2); // 0000 0000 0000 0100\nconst unsigned int BIT_FLAG_3 = (1 << 3); // 0000 0000 0000 1000\nconst unsigned int BIT_FLAG_4 = (1 << 4); // 0000 0000 0001 0000\nconst unsigned int BIT_FLAG_5 = (1 << 5); // 0000 0000 0010 0000\nconst unsigned int BIT_FLAG_6 = (1 << 6); // 0000 0000 0100 0000\nconst unsigned int BIT_FLAG_7 = (1 << 7); // 0000 0000 1000 0000\nvoid add(long long &a, long long b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0)\n            val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os,\n                                         const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0)\n            return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1)\n            t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate <class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for (int i = 2; i < n; i++) {\n            fact_[i] = fact_[i - 1] * i;\n            inv_[i] = -inv_[MOD % i] * (MOD / i);\n            finv_[i] = finv_[i - 1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return fact_[n];\n    }\n    // 追加\n    constexpr T perm(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k] * fact_[k];\n    }\n\n    constexpr T inv(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return finv_[n];\n    }\n};\n// a^n mod を計算する\nlong long modpower(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n// mint(modpower(i, N, MOD))\n\nint main() {\n    using mint = Fp<MOD>;\n    BiCoef<mint> bc;\n\n    long long N, K;\n    cin >> N >> K;\n    bc.init(510000);\n\n    mint ans_rev;\n\n    for (int i = 1; i <= K; i++) {\n        mint diff_val = bc.com(K, i) * mint(modpower(K - i, N, MOD));\n        if (i % 2 == 1) {\n            ans_rev += diff_val;\n        } else {\n            ans_rev -= diff_val;\n        }\n    }\n    mint ans = mint(modpower(K, N, MOD)) - ans_rev;\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll comb[1002][1002];\n\nvoid makeComb(int a, ll MOD){\n  comb[0][0] = 1;\n  for(int i = 1; i <= a; i++){\n    comb[i][i] = comb[i][0] = 1;\n    for(int j = 1; j < i; j++){\n      comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n    }\n  }\n}\n\n\nint main() {\n  ll MOD = 1000000007LL;\n  makeComb(1000, MOD);\n\n  ll p[1002][1002];\n  for (int i = 1; i <= 1000; i++) {\n    p[i][0] = 1;\n    for (int j = 1; j <= 1000; j++) {\n      p[i][j] = p[i][j - 1] * i;\n      p[i][j] %= MOD;\n    }\n  }\n\n  int n, k;\n\n  while (cin >> n >> k) {\n    ll ans = 0;\n    for (int i = 0; i < k; i++) {\n      if (i % 2 == 0) {\n\tans += p[k - i][n] * comb[k][i];\n      } else {\n\tans += MOD * MOD;\n\tans -= p[k - i][n] * comb[k][i];\n      }\n      ans %= MOD;\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n#include <random>\n#include <iterator>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\n\nconst i64 mod = 1e9 + 7;\ni64 ipow(i64 a, i64 b) {\n    i64 x = a, y = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) (y *= x) %= mod;\n        (x *= x) %= mod;\n    }\n    return y;\n}\ni64 inv(i64 x) {\n    return ipow(x, mod - 2);\n}\ni64 fact(i64 x) {\n    static vector<i64> f;\n    i64 i = f.size();\n    if (x >= i) {\n        f.resize(x + 1);\n        for (; i <= x; ++i) {\n            f[i] = i == 0 ? 1 : i * f[i - 1] % mod;\n        }\n    }\n    return f[x];\n}\ni64 perm(i64 n, i64 k) {\n    return k <= n ? fact(n) * inv(fact(n - k)) % mod : 0;\n}\ni64 comb(i64 n, i64 k) {\n    return k <= n ? fact(n) * inv(fact(k) * fact(n - k) % mod) % mod : 0;\n}\nint main() {\n    i64 n, k;\n    cin >> n >> k;\n    i64 ans = 0;\n    for (i64 i = k, sign = 1; i >= 1; --i) {\n        ans += sign * (comb(k, i) * ipow(i, n) % mod) + mod;\n        ans %= mod;\n        sign = -sign;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\n\nstruct Mint {\n  int x;\n\n  Mint() : x(0) {}\n\n  Mint(int y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n\n  Mint &operator+=(const Mint &p) {\n    if((x += p.x) >= M) x -= M;\n    return *this;\n  }\n\n  Mint &operator-=(const Mint &p) {\n    if((x += M - p.x) >= M) x -= M;\n    return *this;\n  }\n\n  Mint &operator*=(const Mint &p) {\n    x = (int) (1LL * x * p.x % M);\n    return *this;\n  }\n\n  Mint &operator/=(const Mint &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  Mint operator-() const { return Mint(-x); }\n\n  Mint operator+(const Mint &p) const { return Mint(*this) += p; }\n\n  Mint operator-(const Mint &p) const { return Mint(*this) -= p; }\n\n  Mint operator*(const Mint &p) const { return Mint(*this) *= p; }\n\n  Mint operator/(const Mint &p) const { return Mint(*this) /= p; }\n\n  bool operator==(const Mint &p) const { return x == p.x; }\n\n  bool operator!=(const Mint &p) const { return x != p.x; }\n\n  Mint inverse() const {\n    int a = x, b = M, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return Mint(u);\n  }\n\n  Mint power(int n) const {\n    Mint ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const Mint &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, Mint &a) {\n    int t;\n    is >> t;\n    a = Mint(t);\n    return (is);\n  }\n\n\n};\nusing mint = Mint;\n\n\nll power(ll x,ll k){\n  ll ret=1;\n  while(k>0){\n    if(k&1) (ret*=x) %= M;\n    (x*=x) %= M;\n    k >>= 1;\n  }\n  return ret;\n}\n\n\n\nstruct Combinations {\n  static int num;\n  vi fact,factr,inv;\n\n  Combinations(int num) {\n\n    fact.assign(num+1,0);\n    factr.assign(num+1,0);\n    inv.assign(num+1,0);\n    inv[1]=fact[0]=factr[0]=1;\n    FOR(i,2,num+1) inv[i]=inv[M%i]*(M-M/i)%M;\n    FOR(i,1,num+1) fact[i]=fact[i-1]*i%M,factr[i]=factr[i-1]*inv[i]%M;\n  }\n\n\n  int comb(int n,int c){\n    if(c<0||c>n) return 0;\n    return factr[c]*fact[n]%M*factr[n-c]%M;\n  }\n\n  int per(int n,int c){\n    if(c<0||c>n) return 0;\n    return fact[n]*factr[n-c]%M;\n  }\n\n  int hcomb(int n,int c){\n    if(n==0&&c==0) return 1;\n    return comb(n+c-1,c);\n  }\n\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,k;\n  cin>>n>>k;\n  if(n<k) cout<<0<<endl;\n  else{\n    Combinations comb(n);\n    Mint ans=0;\n    FOR(i,1,k+1){\n      Mint tmp = comb.comb(k,i);\n      tmp=tmp*power(i,n);\n      if((k-i)&1) ans=ans-tmp;\n      else ans=ans+tmp;\n    }\n    cout<<ans<<endl;\n  }\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <fstream>\n#include <unistd.h>\n#include <string.h>\n#include <string>\n#include <numeric>\n#include <queue>\n#include <deque>\n#include <sstream>\n#include <iomanip>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <functional>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<vvvl> vvvvl;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vvb> vvvb;\ntypedef vector<vvvb> vvvvb;\ntypedef vector<string> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<char> vc;\ntypedef vector<vector<char>> vvc;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<vvd> vvvd;\ntypedef unordered_map<ll, ll> uii;\ntypedef unordered_map<ll, ll> uuii;\ntypedef unordered_map<ll, ll> uuuii;\ntypedef long double LD;\ntypedef vector<LD> vld;\ntypedef vector<pair<LD, LD>> vpld;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> vpl;\ntypedef vector<vector<PL>> vvpl;\ntypedef vector<vvpl> vvvpl;\ntypedef pair<ll, PL> TL;\ntypedef vector<TL> vtl;\ntypedef vector<vtl> vvtl;\ntypedef long double ld;\ntypedef vector<ld> vld;\nconst ll LINF = 1e17;\nconst double pi = 3.1415926535897932;\nconst string endstr = \"\\n\";\n#define FOR(i, a, b) for(ll i = (a); i < b; i++)\n#define RFOR(i, a, b) for(ll i = (a); i > b; i--)\n#define rep(i, n) for(ll i = 0; i < n; i++)\n#define rrep(i, n) for(ll i = n-1; i > -1; i--)\n#define FORMAP(it, m) for(auto it = m.begin(); it != m.end(); it++)\n#define ff first\n#define ss second\n#define pb push_back\n#define epb emplace_back\n#define ALL(X) (X).begin(),(X).end()\n\ntemplate <typename T> T gcd(T a, T b) {return (a == 0) ? b : gcd(b%a, a);}\ntemplate <typename T> T lcm(T a, T b) { return a / gcd(a, b) * b;}\n\nbool p_comp_fs(const PL p1, const PL p2){ return p1.first < p2.first;};\nbool p_comp_fg(const PL p1, const PL p2){ return p1.first > p2.first;};\nbool p_comp_ss(const PL p1, const PL p2){ return p1.second < p2.second;};\nbool p_comp_sg(const PL p1, const PL p2){ return p1.second > p2.second;};\ntemplate <typename T>\nvector<T> uniquen(vector<T> vec /* copy */){\n    sort(ALL(vec)); vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec;\n}\n\ninline ll popcnt(ll x){return __builtin_popcountll((unsigned long long)x);};\ntemplate<class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\n//friend bool operator<(const tpl& lhs, const tpl& rhs){\n//    return std::tie(lhs.l, lhs.r) < std::tie(rhs.l, rhs.r);\n//}\n\nbool bit(ll st, ll b){return ((st>>b)&1) == 1;}\n\n\nconst ll mod = 1e9+7;\ntemplate< int mod >\nstruct ModInt {\n    int x;\n    ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inv();\n        return *this;\n    }\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    \n    ModInt inv() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    \n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    \n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    \n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n    \n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt<mod>;\ntypedef vector<mint> vm;\ntypedef vector<vm> vvm;\ntypedef vector<vvm> vvvm;\n\ntypedef unordered_map<ll, mint> uim;\ntypedef unordered_map<ll, uim> uuim;\ntypedef unordered_map<ll, uuim> uuuim;\n\n\n\nconst ll size = 300300; // ******** CHECK ME !!!!!!! ********\nmint fact[size], finv[size];\n\nmint nCk(ll n, ll k){\n    if(n < k) return 0;\n    return fact[n]*finv[k]*finv[n-k];\n}\n\nmint Catalan(ll N){\n    return nCk(2*N, N) - nCk(2*N, N-1);\n}\n\nvoid prepare(){\n    fact[0] = 1;\n    rep(i, size-1) fact[i+1] = fact[i]*mint(i+1);\n    finv[size-1] = fact[size-1].inv();\n    for (ll i = size-1; i > 0; i--) {\n        finv[i-1] = finv[i]*mint(i);\n    }\n}\n\n\n\nint main(){\n#ifdef __DEBUG_LOCAL__\n    ifstream file(\"../../../../../in.txt\"); if(file.is_open()) cin.rdbuf(file.rdbuf());\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\n    \n    prepare();\n    ll N, K; cin >> N >> K;\n    \n    vm f(K+1, 0);\n    f[1] = 1;\n    FOR(k, 2, K+1){\n        mint sum = 0;\n        FOR(i, 1, k){\n            sum += nCk(k, i) * f[i];\n        }\n        f[k] = mint(k).pow(N) - sum;\n    }\n    \n    cout << f[K] << endstr;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <iomanip>\n#include <numeric>\n#include <complex>\n\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\nconst int INF = (1<<30);\nconst ll INFL = (1LL<<62);\nconst ll MOD = 1000000007;\ntemplate<class T> bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<class T> ll mod_pow(ll a, ll n, T mod) { mod=(ll)mod; ll res=1, p=a%mod; while(n){ if(n&1) res=res*p%mod; p=p*p%mod; n>>=1; } return res; }\ntemplate <int mod>\nstruct ModInt {\n    using ll = long long;\n    ll x;\n    ModInt() : x(0) {}\n    ModInt(ll y) : x(y >= 0 ? y % mod : ((mod + y) % mod)) {}\n    ModInt &operator+=(const ModInt &rhs) {\n        if ((x += rhs.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &rhs) {\n        if ((x += mod - rhs.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &rhs) {\n        x = x * rhs.x % mod;\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &rhs) {\n        *this *= rhs.inverse();\n        return *this;\n    }\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n    ModInt operator==(const ModInt &rhs) const { return x == rhs.x; }\n    ModInt operator!=(const ModInt &rhs) const { return x != rhs.x; }\n    friend ostream &operator<<(ostream &os, const ModInt &rhs) {\n        return os << rhs.x;\n    }\n    friend istream &operator>>(istream &is, ModInt &rhs) {\n        ll t;\n        is >> t;\n        rhs = ModInt<mod>(t);\n        return (is);\n    }\nprivate:\n    ModInt inverse() const {\n        ll a = x, u = 1LL, v = 0LL, t, b = (ll)mod;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n};\nusing mint = ModInt<1000000007>;\n\nmint dp[1010];\nmint com[1010][1010];\n\nint main() {\n    com[0][0]=1LL;\n    for(int i=1; i < 1010; ++i){\n        for(int j=0; j <= i; ++j){\n            com[i][j] += com[i-1][j];\n            if(j>0)com[i][j] += com[i-1][j-1];\n        }\n    }\n    int n, k;\n    cin >> n >> k;\n    if(n < k){ cout << 0 << endl; return 0; }\n    dp[1] = 1LL;\n    for(int i=2; i <=k; ++i){\n        dp[i] = mod_pow(i, n, MOD);\n        for(int j=1; j <= i-1; ++j){\n            dp[i] -= (com[i][j]*dp[j]);\n        }\n    }\n    cout << dp[k] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp> namespace mp = boost::multiprecision; //mp::cpp_intで宣言\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\n\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\n//ll inf=(ll)1E12;//10^12\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\n//const long double EPS=1E-8;\n////////////////////////////////////////\n#define N 100004\n\nll kai[N];\nll kai2[N];\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else if(p==1)return mod(i);\n    else if(p%2==0)return mod(po(mod(mod(i)*mod(i)),p/2));\n    else  return mod(mod(i)*mod(po(i,p-1)));\n}\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    for(int i=1;i<N;i++){\n        kai[i]=mod(kai[i-1]*i);\n        kai2[i]=mod(po(kai[i],i_5));\n    }\n}\nll comb(ll n,ll k){\n    if(n==0){\n        if(k==0)return 1;\n        else return 0;\n    }\n    else if(n<k)return 0;\n    else return mod(mod(mod(kai[n])*mod(kai2[n-k]))*mod(kai2[k]));\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    \n    calc();\n    ll n,k;cin>>n>>k;\n    ll ans=0;\n    for(int c=k;c>=1;c--){\n        ll add=mod(po(c,n)*comb(k,c));\n        if((c-k)%2==0)Add(&ans,add);\n        else Add(&ans,-add);\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}\n//ios::sync_with_stdio(false);cin.tie(0);\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\nconst int MAX = 510000;\nconst ll mod = 1e9+7;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i-1] * (ll)i % mod;\n    inv[i] = mod - inv[mod%i] * (mod/(ll)i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll COM(int n, int k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll Pow(ll x, ll n){\n  if(n == 0) return 1;\n  if(n % 2 == 0) return Pow(x*x % mod,n/2);\n  else return x * Pow(x,n-1) % mod;\n}\n\nint main(){\n  ll n, k;\n  cin >> n >> k;\n  COMinit();\n  if(n < k) {\n    cout << 0 << endl;\n    return 0;\n  }\n  ll ans = 0;\n  rep(i,k) {\n    if(i % 2 == 0) (ans += Pow(k-i,n) * COM(k,k-i)) %= mod;\n    else (ans -= Pow(k-i,n) * COM(k,k-i)) %= mod;\n  }\n  if(ans < 0) ans += mod;\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,k);\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      (rinv*=inverse(k))%=MOD;\n      if(k%2) (res+=MOD-rinv)%=MOD;\n      else (res+=rinv)%=MOD;\n    }\n    for(Int i=1;i<=n;i++)\n      (res*=i)%=MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  Int ans=0;\n  for(Int i=1;i<=k;i++){\n    Int res=mod.C(k,i)*mod.pow(i,n)%MOD;\n    if((k-i)&1) ans+=MOD-res;\n    else ans+=res;\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/DPL_5_C.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_C\"\n#line 1 \"macro/macros.hpp\"\n\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\n#define Yes \"Yes\"\n#define No \"No\"\n#define YES \"YES\"\n#define NO \"NO\"\ntypedef long long ll;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n  os << \"{\" <<p.first << \", \" << p.second << \"}\";\n  return os;\n}\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e18+1;\nconst ll MOD = (ll)1e9+7;\n\nconst double PI = acos(-1.0);\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string dir = \"DRUL\";\n\n\n#line 1 \"math/mint.hpp\"\n\n\n\n#line 5 \"math/mint.hpp\"\n\nstruct mint {\n    long long x;\n    mint(long long _x=0):x((_x%MOD+MOD)%MOD){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint modpow(long long t) const {\n        if (!t) return 1;\n        mint a = modpow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return modpow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const mint& a){\n        os << a.x;\n        return os;\n    }\n};\n\n#line 1 \"math/comb.hpp\"\n\n\n#line 5 \"math/comb.hpp\"\n\n/*\n@title 組み合わせ(Combination)\n*/\nstruct combination {\n    vector<mint> fact, ifact;\n    combination(int n):fact(n+1),ifact(n+1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n    }\n    mint Comb(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n    mint H(int n, int m){\n        return Comb(n + m - 1, n);\n    }\n    //nPk\n    mint Perm(int n, int k){\n        if (k < 0 || n < k) return 0;\n        return fact[n]*ifact[n-k];\n    }\n};\n\n#line 5 \"test/DPL_5_C.test.cpp\"\n/*\n@title 玉区別する、箱区別する、1個以上($\\sum_{i=0}^{k} (-1)^{i} {}_{k} C _{i} (k-i)^n$)\n@category 写像12相\n*/\ncombination C(200010);\nint main(){\n    int n, k;\n    cin >> n >> k;\n    mint ans = 0;\n    for(int i = 0; i <= k;i++){\n        mint x = C.Comb(k, i) * mint(k-i).modpow(n);\n        ans += (i & 1) ? -x:x;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ボール: 区別あり, 箱：区別あり, 入れ方: 1 つ以上\n#include <iostream>\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long MAXN = 1001024;\n\n// 繰り返し 2 乗法\nlong long modpow(long long a, long long n) {\n  long long res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * a % MOD;\n    a = a * a % MOD;\n    n >>= 1;\n  }\n  return res;\n}\n\nlong long fac[MAXN], finv[MAXN], inv[MAXN];\n\n// 前処理 O(n)\nvoid comb_init(){\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for(long long i = 2; i < MAXN; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算 O(1)\nlong long COM(long long n, long long k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n  \n  int n, k; cin >> n >> k;\n  long long ans = 0;\n  comb_init();\n  for(int i = 0; i < k; i++) {\n    // i 個の箱を選んで, 絶対ボールを入れないことにする\n    // 残りの箱に自由に入れる\n    int rest = k - i;\n    long long add = COM(k, i) * modpow(rest, n) % MOD;\n    \n    if(i % 2 == 0) ans = (ans + add      ) % MOD;\n    else           ans = (ans - add + MOD) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  \n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n  \n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\n\n//BEGIN CUT HERE\ntemplate<typename M>\nclass Enumeration{\nprivate:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n    \n    int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(int n){\n    init(n);\n    return fact[n];    \n  }  \n  static M Finv(int n){\n    init(n);\n    return finv[n];    \n  }\n  static M Invs(int n){\n    init(n);\n    return invs[n];    \n  }\n  \n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(int n,int k){\n    M res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(int n,int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(int n,int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);    \n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    M res;\n    for(int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static M montmort(int n){\n    M res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    M num(1);\n    for(int i=0;i<=n;i++) num*=t-M(i);\n    M res;\n    for(int i=0;i<=n;i++){\n      M tmp=y[i]*num/(t-M(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n//END CUT HERE\n\ntemplate<typename T> \nmap<T, int> factorize(T x){\n  map<T, int> res;\n  for(int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n//INSERT ABOVE HERE\n\nsigned DPL_5_A(){\n  int n;\n  Mint<int> k;\n  scanf(\"%d %d\",&n,&k.v);\n  printf(\"%d\\n\",k.pow(n).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_A&lang=jp\n*/\n\nsigned DPL_5_B(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::P(k,n).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_B&lang=jp\n*/\n\nsigned DPL_5_C(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  Enumeration<Mint<int>>::init(k);  \n  printf(\"%d\\n\",(Enumeration<Mint<int>>::S(n,k)*Enumeration<Mint<int>>::Fact(k)).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_C&lang=jp\n*/\n\nsigned DPL_5_D(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::H(k,n).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_D&lang=jp\n*/\n\nsigned DPL_5_E(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::C(k,n).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_E&lang=jp\n*/\n\nsigned DPL_5_F(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::C(n-1,k-1).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_F&lang=jp\n*/\n\nsigned DPL_5_G(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::B(n,k).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_G&lang=jp\n*/\n\nsigned DPL_5_H(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",(n<=k));\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_H&lang=jp\n*/\n\nsigned DPL_5_I(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::S(n,k).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_I&lang=jp\n*/\n\nsigned DPL_5_J(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::D(n,k)[n][k].v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_J&lang=jp\n*/\n\nsigned DPL_5_K(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",(n<=k));\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_K&lang=jp\n*/\n\nsigned DPL_5_L(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",n>=k?Enumeration<Mint<int>>::D(n,k)[n-k][k].v:0);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_L&lang=jp\n*/\n\nsigned ABC110_D(){\n  int n;\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  M m;\n  scanf(\"%d %d\",&n,&m.v);\n\n  E::init(n+100);\n  \n  Mint<int> ans(1);\n  auto x=factorize(m.v);\n  for(auto p:x) ans*=E::H(n,p.second);\n\n  printf(\"%d\\n\",ans.v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  https://beta.atcoder.jp/contests/abc110/tasks/abc110_d\n*/\n\n//montmort\nsigned ARC009_C(){\n  Int n,k;\n  scanf(\"%lld %lld\",&n,&k);\n  const int MOD = 1777777777;\n  using M = Mint<long long, MOD>;  \n  using E = Enumeration<M>;\n  M a=E::montmort(k)*M::comb(n,k);\n  printf(\"%lld\\n\",a.v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  https://beta.atcoder.jp/contests/arc009/tasks/arc009_3\n*/\n\nsigned ARC033_D(){\n  int n;\n  scanf(\"%d\",&n);\n  using M = Mint<int>;  \n  using E = Enumeration<M>;\n  vector<M> y(n+1);\n  for(Int i=0;i<=n;i++) scanf(\"%d\",&y[i].v);\n  int t;\n  scanf(\"%d\",&t);\n  printf(\"%d\\n\",(t<=n?y[t]:E::LagrangePolynomial(y,M(t))).v);\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  https://beta.atcoder.jp/contests/arc033/tasks/arc033_4\n*/\n\nsigned YUKI_117(){\n  int T;\n  scanf(\"%d\\n\",&T);\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(2e6+100);\n  while(T--){\n    char c;\n    int n,k;\n    scanf(\"%c(%d,%d)\\n\",&c,&n,&k);\n    if(c=='C') printf(\"%d\\n\",E::C(n,k).v);\n    if(c=='P') printf(\"%d\\n\",E::P(n,k).v);\n    if(c=='H') printf(\"%d\\n\",E::H(n,k).v);\n  }\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  https://yukicoder.me/problems/no/117\n*/\n\nsigned YUKI_042(){\n  using M = Mint<int, int(1e9+9)>;  \n  using E = Enumeration<M>;\n  const int MAX = 666 * 6 + 10;\n  M dp[MAX];\n  for(int j=0;j<MAX;j++) dp[j]=M(0);\n  dp[0]=M(1);\n  \n  vector<int> a({1,5,10,50,100,500});\n  for(int x:a)\n    for(int j=x;j<MAX;j++) dp[j]+=dp[j-x];\n  \n  int T;\n  scanf(\"%d\",&T);\n  while(T--){\n    Int m;\n    scanf(\"%lld\",&m);\n    vector<M> y(6);\n    for(int i=0;i<6;i++) y[i]=dp[(m%500)+(i*500)];\n    M ans=E::LagrangePolynomial(y,M(m/500));\n    printf(\"%d\\n\",ans.v);\n  }\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  https://yukicoder.me/problems/no/42\n*/\n\nsigned CFR315_B(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  \n  int n;\n  cin>>n;\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(n+1);\n  M res;\n  for(int i=0;i<n;i++)\n    res+=E::C(n,i)*E::B(i,i);  \n  cout<<res.v<<endl;\n  return 0;\n}\n/*\n  verified on 2019/05/19\n  https://codeforces.com/contest/568/problem/B\n*/\n\nsigned main(){\n  //DPL_5_A();\n  //DPL_5_B();\n  DPL_5_C();\n  //DPL_5_D();\n  //DPL_5_E();\n  //DPL_5_F();\n  //DPL_5_G();\n  //DPL_5_H();\n  //DPL_5_I();\n  //DPL_5_J();\n  //DPL_5_K();\n  //DPL_5_L();\n  \n  //ABC110_D();\n  //ARC009_C();\n  //ARC033_D();\n\n  //YUKI_117();\n  //YUKI_042();\n\n  //CFR315_B();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<long long> VL;\ntypedef vector<vector<long long>> VVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define EXIST(m,v) (m).find((v)) != (m).end()\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconstexpr double EPS = 1e-9;\nconstexpr double PI  = 3.1415926535897932;\nconstexpr int INF = 2147483647;\nconstexpr long long LINF = 1LL<<60;\nconstexpr long long MOD = 1000000007; // 998244353;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nstruct mint {\n    long long x;\n    mint(long long x=0):x((x%MOD+MOD)%MOD){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n    \treturn *this;\n    }\n    mint& operator*=(const mint a) {\n    \t(x *= a.x) %= MOD;\n    \treturn *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(long long t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n    \tif (t&1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n    \treturn (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n    combination(long long n):fact(n+1),ifact(n+1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n    }\n    mint operator()(long long n, long long k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n};\n\nvoid Main(){\n    int n,k; cin >> n >> k;\n    combination C(n+k);\n    vector<mint> kai(n+k+1,1); REP(i,n+k) kai[i+1] = kai[i]*(i+1);\n    mint ans = mint(k).pow(n);\n    FOR(x,1,k){\n        int sign = x%2 ? -1 : 1;\n        ans += C(k,x) * mint(k-x).pow(n) * sign;\n    }\n    cout << ans.x << en;\n    return;\n}\n\nint main(void){\n    cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);\n    int t=1; //cin>>t;\n    REP(_,t) Main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst ll MOD = (ll)(1e9 + 7);\n\nconst int SZ = 312345;\nll inv[SZ];\nll fact[SZ];\nll fact_inv[SZ];\nll choose(int n, int r) {\n  if (n < 0 || r < 0 || n < r) return 0;\n  return fact[n] * fact_inv[n-r] % MOD * fact_inv[r] % MOD;\n}\n\nll mod_pow(ll a, ll b, ll p) {\n  ll res = 1;\n  while (b > 0) {\n    if (b & 1) res = (res * a) % p;\n    a = (a * a) % p;\n    b >>= 1;\n  }\n  return res;\n}\n\n\nint main2() {\n  int N = nextInt();\n  int K = nextInt();\n  ll ans = 0;\n  for (int k = 0; k <= K; k++) {\n    int sign = k % 2 == 0 ? +1 : -1;\n    ans += sign * choose(K, k) * mod_pow(K - k, N, MOD);\n    ans = (ans % MOD + MOD) % MOD;\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  {\n  inv[1] = 1;\n  for (int i = 2; i < SZ; i++) inv[i] = inv[(int) (MOD % i)] * (MOD - MOD / i) % MOD;\n  fact[0] = 1;\n  for (int i = 1; i < SZ; i++) fact[i] = fact[i-1] * i % MOD;\n  fact_inv[0] = 1;\n  for (int i = 1; i < SZ; i++) fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;\n  }\n\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n// #define int ll\nusing namespace std;\nconst int INF (1 << 30);\nconst ll LLINF (1LL << 55LL);\nconst int MOD = 1000000007;\nconst int MAX = 510000;\nconst double pi=3.14159265358979;\n\nll fac[MAX], finv[MAX], inv[MAX];\nll POW[MAX];\n\nvoid POWinit(){\n    POW[0]=0;\n    POW[1]=1;\n    for(ll i=2;i<MAX;i++){\n        POW[i]=POW[i-1]*i;\n        POW[i]%=MOD;\n    }\n}\n\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,k,ans[1010]={};\n    cin>>n>>k;\n    COMinit();\n    POWinit();\n    if(n<k){\n        cout<<0<<endl;\n        return 0;\n    }\n    ans[1]=1;\n    rep2(i,2,k+1){\n        ans[i]=1;\n        rep(j,n){\n            ans[i]*=i;\n            ans[i]%=MOD;\n        }\n        rep2(j,1,i){\n            ans[i]-=COM(i,j)*ans[j]%MOD;\n            ans[i]%=MOD;\n            if(ans[i]<0) ans[i]+=MOD;\n        }\n    }\n    cout<<ans[k]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define rep(i, n) for(int i=0;i<n;++i)\n#define rrep(i, n) for(int i=n;i>=0;--i)\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nll comb[1005];\nll frac[1005];\nll N, K;\n\nvoid prepare(){\n  ll P[K+1];\n  P[0] = 1;\n  for(ll i=1;i<=K;++i){\n    P[i] = P[i-1] * i;\n    P[i] %= mod;\n  }\n  ll shita1, shita2, tmpshita1, tmpshita2, two, h;\n  for(ll k=0;k<=K;++k){\n    h = mod - 2;\n    shita1 = 1;\n    shita2 = 1;\n    while(h>0){\n      two = 1;\n      tmpshita1 = P[K-k];\n      tmpshita2 = P[k];\n      while(2*two<=h){\n        two *= 2;\n        tmpshita1 *= tmpshita1;\n        tmpshita1 %= mod;\n        tmpshita2 *= tmpshita2;\n        tmpshita2 %= mod;\n      }\n      h -= two;\n      shita1 *= tmpshita1;\n      shita1 %= mod;\n      shita2 *= tmpshita2;\n      shita2 %= mod;\n    }\n    comb[k] = P[K]*shita1%mod*shita2%mod;\n  }\n  h = N;\n  ll tmp[K+1];\n  for(int i=1;i<=K;++i) frac[i] = 1;\n  while(h>0){\n    two = 1;\n    for(ll i=1;i<=K;++i){\n      tmp[i] = i;\n    }\n    while(2*two<=h){\n      two *= 2;\n      for(int i=1;i<=K;++i){\n        tmp[i] *= tmp[i];\n        tmp[i] %= mod;\n      }\n    }\n    h -= two;\n    for(int i=1;i<=K;++i){\n      frac[i] *= tmp[i];\n      frac[i] %= mod;\n    }\n  }\n}\n\nint main() {\n  cin>>N>>K;\n  prepare();\n  ll ans = 0;\n  for(int k=0;k<=K;++k){\n    if(k%2==0){\n      ans += comb[k]*frac[K-k];\n    }\n    else{\n      ans -= comb[k]*frac[K-k];\n    }\n    ans = (ans+mod)%mod;\n  }\n  cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\nusing namespace std;\nusing ll=long long;\nusing P=pair<int,int>;\nconst ll INF=1LL<<31;\nconst ll LINF=1LL<<60;\nconst double eps=1e-9;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0}; \nll mpow(ll x,ll n){\n    ll res=1;\n    while(n>0){\n        if(n&1){\n            res=res*x%MOD;\n        }\n        n>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nvector<ll> f,fi;\nvoid comb(){\n    f.resize(1010);\n    fi.resize(1010);\n    f[0]=1;\n    for(ll i=1;i<=1000;i++){\n        f[i]=f[i-1]*i;\n        f[i]%=MOD;\n    }\n    fi[1000]=mpow(f[1000],MOD-2);\n    for(ll i=999;i>=0;i--){\n        fi[i]=fi[i+1]*(i+1LL);\n        fi[i]%=MOD;\n    }\n}\nll ncr(ll n,ll r){\n    return f[n]*fi[r]%MOD*fi[n-r]%MOD;\n}\nint main(){\n    comb();\n    ll n,k;cin>>n>>k;\n    if(n<k){\n        cout<<0<<endl;\n        return 0;\n    }\n    ll ans=mpow(k,n);\n    for(ll i=1;i<=k;i++){\n        if(i%2){\n            ans+=MOD;\n            ans-=ncr(k,i)*mpow(k-i,n)%MOD;\n            ans%=MOD;\n        }else{\n            ans+=ncr(k,i)*mpow(k-i,n)%MOD;\n            ans%=MOD;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define repi(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repdi(i,a,b) for(ll i=(a)-1;i>=(b);--i)\n#define repd(i,a) repdi(i,a,0)\n#define itr(it,a) for( auto it = (a).begin(); it != (a).end(); ++it )\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\nconstexpr ll INF = 1ll<<60;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class S, class T>\nstd::ostream& operator<< ( std::ostream& out, const std::pair<S,T>& a )\n{ std::cout << '(' << a.first << \", \" << a.second << ')'; return out; }\n\ntemplate<class T>\nstd::ostream &operator<< ( std::ostream& out, const std::vector<T>& a )\n{ std::cout << '['; rep( i, a.size() ){ std::cout << a[i]; if( i != a.size()-1 ) std::cout << \", \"; } std::cout << ']'; return out; }\n\nconst ll mod = 1000000007;\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nstruct combination {\n  std::vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n\nll n, k;\ncombination comb( 1010 );\n\nint main()\n{\n  std::cin >> n >> k;\n\n  mint ans = 0;\n\n  rep( i, k+1 )\n    ans += comb(k,i)*mint(i).pow(n)*((k-i)&1 ? -1 : 1);\n\n  std::cout << ans.x << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconstexpr int64 P = 1000000007;\n\n// Verified: ABC133E, ABC132D, ABC130E\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {}\n  FiniteField() : x(0) {}\n  int64 Value() { return x; }\n  inline FiniteField operator+(FiniteField o) {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nvector<FiniteField> MakeFactorialTable(int n) {\n  vector<FiniteField> values(n + 1);\n  values[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    values[i] = values[i - 1] * i;\n  }\n  return values;\n}\n\nFiniteField Power(FiniteField x, int p) {\n  if (p < 0) return FiniteField(1) / Power(x, -p);\n  FiniteField value = 1;\n  while (p) {\n    if (p % 2) value *= x;\n    x *= x;\n    p /= 2;\n  }\n  return value;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, k;\n  cin >> n >> k;\n  if (k > n) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  auto factorials = MakeFactorialTable(k + 1);\n  FiniteField value = 0;\n  for (int i = 0; i <= k; i++) {\n    value += Power(i, n) * Power(P - 1, k - i)\n        * factorials[k] / factorials[i] / factorials[k - i];\n  }\n  cout << value.Value() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(long long i=0; i<n; i++)\n#define repr(i,n,m) for(long long i=m; i<n; i++)\n#define mod 1000000007\n#define sorti(x) sort(x.begin(), x.end())\n#define sortd(x) sort(x.begin(), x.end(), std::greater<long long>())\n#define debug(x) std::cerr << (x) << std::endl;\n#define roll(x) for (auto&& itr : x) { cerr << (itr) << \" \"; }\n\ntemplate <class T> inline void chmax(T &ans, T t) { if (t > ans) ans = t;}\ntemplate <class T> inline void chmin(T &ans, T t) { if (t < ans) ans = t;}\n\ntemplate <class T>\nT inf = numeric_limits<T>::max();\n\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long modpow(long long a, long long n, long long m) {\n  long long res = 1;\n  while (n > 0) {\n    if (n & 1) res = res * a % mod;\n    a = a * a % mod;\n    n >>= 1;\n  }\n  \n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll N,K,ans = 0;\n  cin >> N >> K;\n  COMinit();\n  // N個の箱のうち、K個の箱が空の状態を指す。\n  for (ll i = 0; i < K; ++i) {\n    ll md = modpow(K-i, N, mod);\n    // 包除原理\n    if (i % 2 == 0) {\n      ans += COM(K, i) * md;\n    } else {\n      ans += (mod - (COM(K, i) * md) % mod) % mod;\n    } \n\n    ans %= mod;\n  }\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\n\nconst ll MOD = (ll)(1e9 + 7);\nll dp[1024][1024];\nint main2() {\n  int N = nextInt();\n  int K = nextInt();\n  CLR(dp, 0);\n  dp[0][0] = 1;\n  for (int i = 0; i < N; i++) {\n    for (int k = 0; k <= K; k++) {\n      if (dp[i][k] != 0) {\n        (dp[i+1][k] += k * dp[i][k]) %= MOD;\n        (dp[i+1][k+1] += (K - k) * dp[i][k]) %= MOD;\n      }\n    }\n  }\n  ll ans = dp[N][K];\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n\nconstexpr intmax_t mod = 1e9+7;\n\ntemplate <typename Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u = y, v = x; a;) {\n    Tp q = b/a;\n    std::swap(x -= q*u, u);\n    std::swap(y -= q*v, v);\n    std::swap(b -= q*a, a);\n  }\n  return b;\n}\n\ntemplate <typename Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <typename Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modadd(std::initializer_list<Tp> const& adds, Tp mod) {\n  Tp res = 0;\n  for (auto const& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <typename Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modmul(std::initializer_list<Tp> const& muls, Tp mod) {\n  Tp res = 1;\n  for (auto const& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <typename Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nclass modchoose {\n  std::vector<intmax_t> fact, fact_inv;\n  const intmax_t mod;\n\npublic:\n  modchoose(intmax_t N, intmax_t mod): mod(mod) {\n    fact.resize(N+1);\n    fact_inv.resize(N+1);\n    fact[0] = 1;\n    for (intmax_t i = 1; i <= N; ++i)\n      fact[i] = fact[i-1] * i % mod;\n\n    fact_inv[N] = modinv(fact[N], mod);\n    for (intmax_t i = N; i--;)\n      fact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n  }\n\n  intmax_t operator ()(intmax_t n, intmax_t r) const {\n    intmax_t res = fact[n] * fact_inv[r] % mod;\n    (res *= fact_inv[n-r]) %= mod;\n    return res;\n  }\n};\n\nint main() {\n  intmax_t n, k;\n  scanf(\"%jd %jd\", &n, &k);\n\n  modchoose mc(k, mod);\n  intmax_t res = 0;\n  for (intmax_t i = 1; i <= k; ++i) {\n    intmax_t cur = mc(k, i);\n    if ((i-1) % 2) cur = (mod-cur) % mod;\n    (cur *= modpow(k-i, n, mod)) %= mod;\n    (res += cur) %= mod;\n  }\n  res = modsub(modpow(k, n, mod), res, mod);\n  printf(\"%jd\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nusing P = pair<ll, ll>;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst ll INF = 1LL << 60;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, pair<T,T> const&P){\n    os << P.first;\n    os << \" \";\n    os << P.second;\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\nll pow(int a,int b,int mod){\n    vector<bool> bit;\n    for(b=b;b>0;b>>=1){\n        bit.push_back(b&1);\n    }\n    vector<ll> fac(bit.size()); fac[0] = a;\n    ll res = 1;\n    for(int i=1;i<bit.size();i++){\n        fac[i] = (fac[i-1] * fac[i-1])%mod;\n    }\n    for(int i=0;i<bit.size();i++){\n        if(bit[i]) res*=fac[i];\n        res%=mod;\n    }\n    return res;\n}\n\n\n//mint\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x+2*MOD)%MOD){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\nostream& operator<<(ostream& os, mint a){\n    os << a.x;\n    return os;\n}\n\nclass BigCombination{\nprivate:\n    const int MAX = 510'000;\n    mint fac[510000], inv[510000];\npublic:\n    BigCombination(){\n        fac[0] = fac[1] = 1;\n        for(int i=2; i<MAX; i++){\n            fac[i] = fac[i-1] * i;\n        }\n        inv[MAX-1] = fac[MAX-1].inv();\n        for(int i=MAX-1;i>0;i--){\n            inv[i-1] = inv[i] * i;\n        }\n    }\n\n    mint combination(int n,int r){\n        if(n<r) return 0;\n        if(n==r) return 1;\n        return fac[n] * inv[r] * inv[n-r];\n    }\n};\n\n\n//写像12相\n//区別できるボール/区別できる箱/制限なし r^n\nmint ball_1(int n,int r){\n    return pow(n,r,MOD);\n}\n//区別できるボール/区別できる箱/1個以下 rCn * n!\nmint ball_2(int n,int r){\n    BigCombination B;\n    mint res = B.combination(r,n);\n    while (n>0){\n        res *= n;\n        n--;\n    }\n    return res;\n}\n//区別できるボール/区別できる箱/1個以上 包除原理\nmint ball_3(int n,int r){\n    BigCombination B;\n    mint res = 0;\n    for(int i=0;i<r;i++){\n        mint x = B.combination(r,i) * pow((r-i), n, MOD);\n        if (i&1) x *= -1;\n        res += x;\n    }\n    return res;\n}\n\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,r;\n    cin >> n >> r;\n\n    mint ans=ball_3(n,r);\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define ll long long\nusing namespace std;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n//template<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nusing mint = Fp<MOD>;\nBiCoef<mint> bc(510000);\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, K;\n    cin >> N >> K;\n    mint ans = 0;\n    for(int k=0;k<=K;k++){\n        mint tmp = bc.com(K,k) * modpow(mint(K-k), N);\n        if(k % 2 == 0) ans += tmp;\n        else ans -= tmp;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\n\nll modpow(ll a, ll b, ll p = 1e9+7){\n    if(b == 0)  return 1;\n\n    if(b % 2 == 0){\n        ll d = modpow(a, b/2, p);\n        return (d*d) % p;\n    }else{\n        return (a%p * modpow(a, b-1, p)) % p;\n    }\n}\n\nstruct ModComb{\n    vector<ll> po, inv;\n    ll N;\n\n    ModComb(ll n) : N(n), po(n), inv(n) {\n        po[0] = 1;\n        for(int i = 1; i < N; i++)  po[i] = (po[i-1] * i) % mod;\n        inv[N-1] = modpow(po[N-1], mod-2, mod);\n        for(int i = N-2; i >= 0; i--)   inv[i] = (inv[i+1] * (i+1)) % mod;\n    }\n    \n    ll nCk(ll n, ll k){\n        if(n < k)   return 0;\n        return (((po[n]*inv[n-k])%mod)*inv[k])%mod;\n    }\n\n    ll nPk(ll n, ll k){\n        if(n < k)   return 0;\n        return (po[n]*inv[n-k])%mod;\n    }\n\n    ll nHk(ll n, ll k){\n        if(n == 0 && k == 0)    return 1;\n        return nCk(n+k-1, k);\n    }\n};\n\nint main(){\n    ll n, k;\n    cin >> n >> k;\n\n    if(n < k){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    ModComb mc(1001);\n    ll ans = modpow(k, n);\n    for(int i = 1; i < k; i++){\n        if(i%2 == 1)    ans = (ans + mod - (mc.nCk(k, i)*modpow(k-i, n))%mod )%mod;\n        else            ans = (ans + mc.nCk(k, i) * modpow(k-i, n));\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct Combination\n{\n  int mod;\n  vector<int> mfact;\n  vector<int> rfact;\n\n  /*\n    constructor : O(sz+log(mod))    \n   */\n  Combination(int sz, int mod) : mfact(sz+1), rfact(sz+1), mod(mod) {\n    mfact[0] = 1;\n    for ( int i = 1; i < (int)mfact.size(); i++ ) {\n      mfact[i] = mfact[i-1]*i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for ( int i = sz-1; i >= 0; i-- ) {\n      rfact[i] = rfact[i+1]*(i+1) % mod;\n    }\n  }\n\n  int fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int pow(int x, int n) const {\n    int ret = 1;\n    while ( n > 0 ) {\n      if ( n & 1 ) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int inv(int x) const {\n    return (pow(x, mod - 2));\n  }\n\n  /*\n    permutation\n   */\n  int P(int n, int r) const {\n    if ( r < 0 || n < r ) return (0);\n    return (mfact[n]*rfact[n-r] % mod);\n  }\n\n  /*\n    combination\n   */\n  int C(int n, int r) const {\n    if ( r < 0 || n < r ) return (0);    \n    return (mfact[n]*rfact[r]%mod * rfact[n-r]%mod);    \n  }  \n\n  /*\n    combination with repetition\n   */\n  int H(int n, int r) const {\n    if ( n < 0 || r < 0 ) return (0);\n    return (r == 0 ? 1 : C(n+r-1, r));\n  }\n\n  /*\n    stirling number\n   */\n  int S(int n, int r) const {\n    int ret;\n    for ( int i = 1; i <= r; i++ ) {\n      \n    }\n  }\n\n  /*\n    bell number\n   */\n  int B(int n, int r) const {\n\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, k;\n  cin >> n >> k;\n\n  int MOD = 1e9+7;  \n  Combination c(1000, MOD);\n  int ans = 0;\n  for ( int i = 1; i <= k; i++ ) {\n    int add = c.C(k, i) * c.pow(i, n);\n    if ( (k-i)%2 ) add *= -1;\n    ans += MOD*MOD;    \n    ans += add;    \n    ans %= MOD;    \n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int MAX = 1000001;\nconst int MOD = 1000000007;\n\nint fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nint COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint modpow(int m, int n){\n  if(n == 0) return 1;\n  else if(n % 2 == 0) return modpow(m * m % MOD, n/2);\n  else{\n    return modpow(m, n - 1) * m % MOD;\n  }\n}\n\nsigned main(){\n\tint N, K; cin >> N >> K;\n\tint ans = modpow(K, N);\n\tCOMinit();\n\tfor(int i = 1; i <= K; i++){\n\t\tint rest = K - i;\n\t\tint ans1 = COM(K, i) * modpow(rest, N);\n\t\tans1 %= MOD;\n\t\tif(i % 2 == 1) ans -= ans1;\n\t\telse ans += ans1;\n\t\tans %= MOD;\n\t\tif(ans < 0) ans += MOD;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto x:v)cerr<<x<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define EPS 1e-9\ntypedef long long ll;\n\nlong long POW(long long x,long long n,long long mod){\n  long long ans = 1;\n  while(n){\n    if(n%2)ans *= x;\n    x *= x;\n    x %= mod;\n    ans %= mod;\n    n >>= 1;\n  }\n  return ans;\n}\nvector<long long> factorial(2,1);\nlong long nckmodp(long long n,long long k,long long p){\n  if(n < k || n <= 0 || k < 0)return 0;\n  while(factorial.size() <= n){\n    long long i = factorial.size();\n    factorial.push_back(i*factorial[i-1]%p);\n  }\n  return ((factorial[n]*POW(factorial[k],p-2,p))%p)*POW(factorial[n-k],p-2,p)%p;\n}\nlong long TwelvefoldWay3(long long n,long long k,long long MOD){\n  long long ans = 0;\n  for(long long i = 1;i <= k;i++){\n    ans += ((k-i)%2 ? -1 : 1)*nckmodp(k,i,MOD)*POW(i,n,MOD);\n    ans = (ans%MOD+MOD)%MOD;\n  }\n  return ans;\n}\n\nsigned main(){\n  ll n,k;\n  cin >> n >> k;\n  cout << TwelvefoldWay3(n,k,INF) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long int ll;\nconst ll MOD=1000000007;\n\nint main(){\n\tll n,k;\n\tll dp[1001][1001]={};\n\tscanf(\"%lld %lld\",&n,&k);\n\tif(n<k) printf(\"0\\n\");\n\telse{\n\t\tdp[0][0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=k;j++){\n\t\t\t\tdp[i][j]+=dp[i-1][j]*j;\n\t\t\t\tdp[i][j]+=dp[i-1][j-1]*j;\n\t\t\t\tdp[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",dp[n][k]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\ntypedef  unsigned long long int ull;\ntypedef pair<ll,ll> P;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\n//const ll mod=998244353;\nconst ll mod=1000000007;\n//ios_base::sync_with_stdio(false);\n//cin.tie(NULL);\nll gcd(ll a,ll b) {return b ? gcd(b,a%b):a;}\nll lcm(ll c,ll d){return c/gcd(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nstruct mint{\n    using ull=unsigned long long int;\n    ull v;\n    mint(ll vv=0){s(vv%mod+mod);}\n    mint& s(ull vv){\n        v=vv<mod?vv:vv-mod;\n        return *this;\n    }\n    //オーバーロード\n    mint operator-()const{return mint()-*this;}//符号反転\n    mint&operator+=(const mint&val){return s(v+val.v);}\n    mint&operator-=(const mint&val){return s(v+mod-val.v);}\n    mint&operator*=(const mint&val){\n        v=ull(v)*val.v%mod;\n        return *this;\n    }\n    mint&operator/=(const mint&val){return *this*=val.inv();}\n    mint operator+(const mint&val){return mint(*this)+=val;}\n    mint operator-(const mint&val){return mint(*this)-=val;}\n    mint operator*(const mint&val){return mint(*this)*=val;}\n    mint operator/(const mint&val){return mint(*this)/=val;}\n    mint pow(int n)const{\n        mint res(1),x(*this);\n        while(n){\n            if(n&1)res*=x;\n            x*=x;\n            n>>=1;\n        }\n        return res;\n    }\n    mint inv()const{return pow(mod-2);}\n    //拡張ユークリッドの互除法\n    /* mint inv()const{\n        int x,y;\n        int g=extgcd(v,mod,x,y);\n        assert(g==1);\n        if(x<0)x+=mod;\n        return mint(x);\n    }*/\n    friend ostream& operator<<(ostream&os,const mint&val){\n        return os<<val.v;\n    }//出力\n    bool operator<(const mint&val)const{return v<val.v;}\n    bool operator==(const mint&val)const{return v==val.v;}\n    bool operator>(const mint&val)const{return v>val.v;}\n};\nconst ll MAX = 2000010;//設定\nmint fac[MAX], finv[MAX], inv[MAX];\n// テーブルを作る前処理\nvoid init(){\n    fac[0] = fac[1] = 1;\n    for(int i=1;i<MAX;i++)fac[i]=fac[i-1]*i;\n    finv[MAX-1]=fac[MAX-1].inv();\n    for(int i=MAX-2;i>=0;i--)finv[i]=finv[i+1]*(i+1);\n    for(int i=MAX-2;i>=1;i--)inv[i]=finv[i]+fac[i-1];\n}\n//階乗\nmint factor(ll n,ll k){\n  if (n<k) return 0;\n  if (n<0 || k<0) return 0;\n  return fac[n]*finv[k];\n}\n// 二項係数計算\nmint COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] * finv[n - k];\n}\nint main(){\nll n,k;\ninit();\ncin>>n>>k;\nmint ans=0;\nfor(int i=0;i<=k;i++){\n\tif((k-i)%2==0)ans+=COM(k,i)*mint(i).pow(n);\n\telse ans-=COM(k,i)*mint(i).pow(n);\n}\ncout<<ans<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFIMES\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nconst int MOD = 1'000'000'007;\nconst int INF = 1'000'000'000; //1e9\nconst int NIL = -1;\nconst long long LINF = 1'000'000'000'000'000'000; // 1e18\nconst long double EPS = 1E-10;\n\ntemplate<class T, class S> inline bool chmax(T &a, const S &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T, class S> inline bool chmin(T &a, const S &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\n\n\n\n\ntemplate<unsigned long long m> class comb_perm{\nprivate:\n    int n;\n    std::vector<long long> fact, fact_inv;\npublic:\n    comb_perm(): n(0), fact(1), fact_inv(1){\n        fact[0] = fact_inv[0] = 1;\n    }\n    comb_perm(int N): n(N), fact(N+1), fact_inv(N+1){\n        fact[0] = fact[1] = fact_inv[0] = fact_inv[1] = 1;\n        for(int i(2); i <= n; ++i) fact[i] = fact[i - 1] * i % m;\n        for(int i(2); i <= n; ++i) fact_inv[i] = inv(fact[i]);\n    }\n\n    void resize(int N){\n        fact.resize(N+1);\n        fact_inv.resize(N+1);\n        if(!n && N){\n            fact[1] = fact_inv[1] = 1;\n        }\n        for(int i(std::max(2, n+1)); i <= N; ++i) fact[i] = fact[i - 1] * i % m;\n        for(int i(std::max(2, n+1)); i <= N; ++i) fact_inv[i] = inv(fact[i], m);\n        n = N;\n    }\n\n    long long power(long long a, unsigned long long b){\n        long long ret(1);\n        while(b){\n            if(b & 1) ret = (ret * a) % m;\n            a = (a * a) % m;\n            b /= 2;\n            if(ret < 0) ret += m;\n            if(a < 0) a += m;\n        }\n        return ret;\n    }\n\n    long long inv(long long a){ // GCD(a, m) = 1\n        return power(a, m-2);\n    }\n\n    long long permutation(int n, int r){\n        if(n < r) return 0;\n        if(n < 0 || r < 0) return 0;\n        long long ret(fact[n]);\n        ret = ret * fact_inv[n - r] % m;\n        return ret;\n    }\n\n    long long combination(int n, int r){\n        if(n < r) return 0;\n        if(n < 0 || r < 0) return 0;\n        long long ret(permutation(n, r));\n        return ret * fact_inv[r] % m;\n    }\n\n    long long factorise(int a){\n        return fact[a];\n    }\n\n    long long inv_factorise(int a){\n        return fact_inv[a];\n    }\n};\n\nint main(){\n    int n, k; std::cin >> n >> k;\n    comb_perm<MOD> cp(k+1);\n    long long ans(0);\n    for(int i(1); i <= k; ++i){\n        int a(((k-i) % 2) ? -1 : 1);\n        long long c(cp.combination(k, i));\n        c *= cp.power(i, n);\n        c %= MOD;\n        ans += a*c;\n        ans %= MOD;\n        if(ans < 0) ans += MOD;\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// Mod int\n// cf. https://www.youtube.com/watch?v=1Z6ofKN03_Y\nstruct mint {\n  ll x;\n  mint(ll x = 0) : x((x + MOD) % MOD) {}\n  mint& operator+= (const mint a) {\n    if ((x += a.x) >= MOD) x %= MOD;\n    return *this;\n  }\n  mint operator+ (const mint a) const {\n    mint res(*this);\n    return res += a;\n  }\n  mint& operator-= (const mint a) {\n    if ((x += MOD - a.x) >= MOD) x %= MOD;\n    return *this;\n  }\n  mint operator- (const mint a) const {\n    mint res(*this);\n    return res -= a;\n  }\n  mint& operator*= (const mint a) {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint operator* (const mint a) const {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const {\n    if (!t) { return 1; }\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(MOD-2);\n  }\n  mint& operator/= (const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/ (const mint a) const {\n    mint res(*this);\n    return res /= a;\n  }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\n//int main(int argc, char** argv) {\n//  // int p;\n//  // cin >> p;\n//\n//  MOD = 13;\n//  mint p(10);\n//  cout << (p + 15).x << endl;   // 12 (25 % 13)\n//  cout << (p - 15).x << endl;   // 8  (-5 % 13)\n//  cout << (p * 2).x << endl;    // 7  (20 % 13)\n//  cout << (p.pow(3)).x << endl; // 12 (1000 % 13)\n//  cout << (p / 3).x << endl;    // 12 (12 * 3 = 10 (36 % 13))\n//\n//  mint p2(-3);\n//  cout << p2.x << endl; // 10 (-3 % 13)\n//}\n\n// Combination mod prime.\n// cf. https://www.youtube.com/watch?v=1Z6ofKN03_Y\nstruct Combination {\n  vector<mint> fact, ifact;\n  Combination(int n) { init(n); }\n  void init(int n) {\n    assert(n < MOD); // n must be lower than MOD.\n\n    fact.resize(n + 1);\n    ifact.resize(n + 1);\n\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) { fact[i] = fact[i-1] * i; }\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) { ifact[i-1] = ifact[i] * i; }\n  }\n  mint operator() (int n, int k) const {\n    if (k < 0 || k > n) { return 0; }\n    return fact[n] * ifact[k] * ifact[n-k];\n  }\n  mint perm(int n, int k) const {\n    if (k < 0 || k > n) { return 0; }\n    return fact[n] * ifact[n-k];\n  }\n};\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  ll n,k;\n  cin >> n >> k;\n  Combination comb(1005);\n\n  mint ans = 0;\n  rep(i,k+1) {\n    mint now = comb(k,i) * mint(i).pow(n);\n    if ((k-i)%2) {\n      now *= -1;\n    }\n    ans += now;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntemplate <typename NumType, int LIMIT = 2000010>\nstruct Combination {\n    vector<NumType> fact_, finv_;\n\n    Combination() : fact_(LIMIT+1), finv_(LIMIT+1) {\n        fact_[0] = finv_[LIMIT] = NumType(1);\n        for(int i=1; i<=LIMIT; i++) {\n            fact_[i] = fact_[i-1] * NumType(i);\n        }\n        \n        finv_[LIMIT] /= fact_[LIMIT];\n        for(int i=LIMIT-1; i>=0; i--) {\n            finv_[i] = finv_[i+1] * NumType(i+1);\n        }\n    }\n\n    inline NumType fact(int k) const { return fact_[k]; }\n    inline NumType finv(int k) const { return finv_[k]; }\n    NumType P(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r];\n    }\n    NumType C(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r] * finv_[r];\n    }\n    // 重複組み合わせ\n    NumType H(int n, int r) const {\n        if(n < 0 or r < 0) return NumType(0);\n        return r == 0 ? NumType(0) : C(n + r - 1, r);\n    }\n    // ベル数 (区別できる n 個のボールを区別できない k 個以下の箱に分割)\n    // B(n, n) := n 個のボールを任意個のグループに分割する場合の数\n    NumType B(int n, int k) const {\n        if(n == 0) return NumType(1);\n        k = min(n, k);\n        NumType ret(0);\n        vector<NumType> pref(k + 1); pref[0] = NumType(1);\n        for(int i=1; i<=k; i++) {\n            if(i & 1) pref[i] = pref[i-1] - finv_[i];\n            else pref[i] = pref[i-1] + finv_[i];\n        }\n        for(int i=1; i<=k; i++) {\n            // 累乗が必要なので適宜書き換える？\n            // ModInt 使うならこれでいい\n            ret += NumType(i).pow(n) * finv_[i] * pref[k-i];\n        }\n        return ret;\n    }\n    // スターリング数 (区別できる n 個のボールを区別できない k 個の箱に分割)\n    NumType S(int n, int k) const {\n        if(n < k) return NumType(0);\n        NumType ans(0);\n        for(int i=0; i<=k; i++) {\n            NumType val = C(k, i) * NumType(i).pow(n);\n            if((k - i) % 2) ans -= val;\n            else ans += val;\n        }\n        return ans * finv_[k];\n    }\n};\n\n// P(n, k) := n の k 分割 (k 個の 0 以上の整数の和)\ntemplate <typename NumType, int LIMIT = 3010>\nstruct Partition {\n    vector< vector<NumType> > dp;\n    Partition() : dp(LIMIT, vector<NumType>(LIMIT)) {\n        for(int k=0; k<LIMIT; k++) dp[0][k] = NumType(1);\n        for(int i=1; i<LIMIT; i++) {\n            for(int j=1; j<LIMIT; j++) {\n                dp[i][j] += dp[i][j-1];\n                if(i-j >= 0) dp[i][j] += dp[i-j][j];\n            }\n        }\n    }\n    inline NumType get(int n, int k) {\n        if(n < 0 or k < 0) return NumType(0);\n        return dp[n][k];\n    }\n};\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v() {\n        if(a >= mod) v = a % mod;\n        else if(a < 0) v = mod - (-a % mod);\n        else v = a;\n    }\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    operator int() const { return int(v); }\n    operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod> a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<1000000007>;\n\nvoid DPL_5_A() {\n    int N, K; cin >> N >> K;\n    mint ans(K);\n    cout << ans.pow(N) << endl;\n}\n\nvoid DPL_5_B() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.P(K, N) << endl;\n}\n\nvoid DPL_5_C() {\n    int N, K; cin >> N >> K;\n\n    Combination<mint> comb;\n    mint ans = comb.S(N, K) * comb.fact(K);\n    cout << ans << endl;\n}\n\nvoid DPL_5_D() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.H(K, N) << endl;\n}\n\nvoid DPL_5_E() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.C(K, N) << endl;\n}\n\nvoid DPL_5_F() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.C(N-1, K-1) << endl;\n}\n\nvoid DPL_5_G() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.B(N, K) << endl;\n}\n\nvoid DPL_5_I() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.S(N, K) << endl;\n}\n\nvoid DPL_5_J() {\n    int N, K; cin >> N >> K;\n    Partition<mint> part;\n    cout << part.get(N, K) << endl;\n}\n\nvoid DPL_5_L() {\n    int N, K; cin >> N >> K;\n    Partition<mint> part;\n    cout << part.get(N-K, K) << endl;\n}\n\nint main() {\n    // DPL_5_A();\n    // DPL_5_B();\n    DPL_5_C();\n    // DPL_5_D();\n    // DPL_5_E();\n    // DPL_5_F();\n    // DPL_5_G();\n    // DPL_5_I();\n    // DPL_5_J();\n    // DPL_5_L();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n    bc.init(3030);\n    mint res = 0;\n    for(int i = 1; i < k; ++ i) {\n        if(i & 1) res += bc.com(k, i) * modpow((mint)(k - i), n);\n        else res -= bc.com(k, i) * modpow((mint)(k - i), n);\n    }\n    cout << modpow((mint)k, n) - res << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k, m, b;\nlong long ans, semi, a[31];\n\nint main() {\n    cin >> n >> k;\n    for (int i=1; i<k+1; i++) {\n        if ((k-i)%2 == 0) semi =1;\n        else semi = -1;\n        a[0] = i; b = n;\n        for (int j=0; b > 0; j++) {\n            if (b%2 == 1) semi = (semi*a[j]) % 1000000007;\n            a[j+1] = (a[j]*a[j]) % 1000000007;\n            b/=2;\n        }\n        if (2*i > k) m = i;\n        else m = k-i;\n        for (int j=k; j>m; j--) {\n            semi = (semi * j) % 1000000007;\n        }\n        for (int j=2; j<k-m+1; j++) {\n            a[0] = j; b = 1000000005;\n            for (int s=0; b>0; s++) {\n                if (b%2 == 1) semi = (semi * a[s]) % 1000000007;\n                a[s+1] = (a[s]*a[s]) % 1000000007;\n                b/=2;\n            }\n        }\n        ans = (ans + semi + 1000000007)%1000000007;\n    }\n    if (n < k) ans = 0;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if ((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if ((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return is;\n    }\n\n    static int get_mod() { return mod; }\n};\n\ntemplate <typename T>\nstruct Combination {\n    vector<T> _fact, _rfact, _inv;\n\n    Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n        _fact[0] = _rfact[sz] = _inv[0] = 1;\n        for (int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n        _rfact[sz] /= _fact[sz];\n        for (int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n        for (int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n    }\n    inline T fact(int k) const { return _fact[k]; }\n\n    inline T rfact(int k) const { return _rfact[k]; }\n\n    inline T inv(int k) const { return _inv[k]; }\n\n    T P(int n, int r) const {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * rfact(n - r);\n    }\n\n    T C(int p, int q) const {\n        if (q < 0 || p < q) return 0;\n        return fact(p) * rfact(q) * rfact(p - q);\n    }\n\n    T H(int n, int r) const {\n        if (n < 0 || r < 0) return 0;\n        return r == 0 ? 1 : C(n + r - 1, n);\n    }\n};\n\nint main() {\n    const int mod = 1000000007;\n    int n, k;\n    cin >> n >> k;\n    Combination<ModInt<mod>> comb(k);\n    ModInt<mod> ans;\n    for (int i = 0; i < k; i++) {\n        auto tmp = comb.C(k, i) * ModInt<mod>(k - i).pow(n);\n        if (i % 2 == 0)\n            ans += tmp;\n        else\n            ans -= tmp;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstatic const ll MOD = 1000000007;\n\nll mod_pow(ll n, ll x){\n\tif(n == 0) return 1;\n\tll ret = mod_pow(n / 2, x * x % MOD) % MOD;\n\tif(n % 2) return ret * x % MOD;\n\treturn ret;\n}\n\nll comb(int n, int k, vector<ll> memo){\n\tif(k < 0 || k > n) return 0;\n\treturn ((memo[n] * mod_pow(MOD - 2, memo[k])) % MOD) * mod_pow(MOD - 2, memo[n - k]) % MOD;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\tif(n < k){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<ll> memo(k + 1, 0);\n\tmemo[1] = 1;\n\tvector<ll> memo2(n + 1);\n\tmemo2[0] = 1; memo2[1] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tmemo2[i] = memo2[i - 1] * (ll)i;\n\t\tmemo2[i] %= MOD;\n\t}\n\tfor(int i = 2; i <= k; i++){\n\t\tmemo[i] = mod_pow(n, i);\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tmemo[i] -= (comb(i, j, memo2) * memo[j]) % MOD;\n\t\t\twhile(memo[i] < 0) memo[i] += MOD;\n\t\t}\n\t}\n\tcout << memo[k] << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nconst ll mo = 1000000007;\nll mypow(ll a, ll b)\n{\n  ll res = 1;\n  a %= mo;\n  while (b)\n  {\n    if (b & 1)\n      res = res * a % mo;\n    a = a * a % mo;\n    b >>= 1;\n  }\n  return res;\n}\nconst ll MAX = 510000;\nconst ll MOD = 1000000007;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nlong long COM(ll n, ll k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nvector<ll> factorial(ll n)\n{\n  vector<ll> fac;\n  fac.push_back(1);\n  for (ll i = 1; i < n + 10; i++)\n  {\n    fac.push_back((fac[i - 1] * i) % mo);\n  }\n  return fac;\n}\nint main()\n{\n/* \nhttps://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5\nボール      箱\t      入れ方に制限なし 箱の中身は1つ以下 箱の中身は1つ以上\n区別できる   区別できる  1            2             3\n区別できない  区別できる  4            5             6\n区別できる   区別できない 7            8             9\n区別できない  区別できない 10          11            12\n*/\nll n , k ;\ncin >> n >> k ;\nauto mod = [](ll modx) {modx%=mo;modx+=mo;modx%=mo;return modx; };\nCOMinit();\nvector<ll> fac = factorial(100000);\n/* \n//1\ncout << mypow(k,n) << endl;\n */\n/* \n//2\ncout << (COM(k,n)*fac[n])%mo << endl;\n */\n\n//3\nll t=0;\nrep(i,k+1){\n  t=mod(t+mypow(-1,k-i)*COM(k,i)*mypow(i,n));\n}\ncout << t << endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\nusing   namespace   std;\ntypedef long long ll;\n\nconst int MOD = 1000000007;\n\nll  F(const ll &n, const ll &k, vector<vector<ll>> &DP) {\n    if (1==k)\n        return 1;\n    if (n<k)\n        return 0;\n    if (DP.at(n).at(k)>=0)\n        return DP.at(n).at(k);\n    ll S=F(n-1, k-1, DP)*k;\n    S %=MOD;\n    S +=F(n-1, k, DP)*k;\n    S %=MOD;\n    DP.at(n).at(k)=S;\n    return S;\n}\n\nint main() {\n    ll n, k;\n    cin >>n >>k;\n    vector<vector<ll>> DP(n+1, vector<ll> (k+1, -1));\n    cout <<F(n, k, DP) <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\n\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x% mod + mod) % mod) {}\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\t(x *= a.x) %= mod;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const {\n\t\treturn pow(mod - 2);\n\t}\n\tmint& operator/=(const mint a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n};\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\n\nmint COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn mint(fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n}\n\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tCOMinit();\n\tll n, k; scanf(\"%lld %lld\", &n, &k);\n\tmint res = 0;\n\tfor (ll i = k; i >= 0; i--) {\n\t\tif (i % 2 == k % 2) res += mint(i).pow(n) * COM(k, i);\n\t\telse res -= mint(i).pow(n) * COM(k, i);\n\t}\n\tcout << res.x << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nconstexpr lint mod = 1e9 + 7;\ninline lint emod(lint a, lint p = mod) { return (a % p + p) % p; }\ninline lint invm(lint a, lint p = mod) { a %= p; return a == 1 ? 1 : -p / a * invm(p % a) % p; }\ninline lint powm(lint a, lint n, lint p = mod) { return !n ? 1 : powm(a * a % p, n >> 1, p) * (n & 1 ? a : 1) % p; }\n\nV<lint> fact, ifact;\nvoid init_table(int n) {\n  fact.assign(n + 1, 1), ifact.assign(n + 1, 1);\n  for (int i = 2; i < n + 1; ++i) fact[i] = i * fact[i - 1] % mod;\n  ifact[n] = invm(fact[n]);\n  for (int i = n; i > 2; --i) ifact[i - 1] = i * ifact[i] % mod;\n}\n\nlint comb(lint n, lint r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] % mod * ifact[n - r] % mod;\n}\n\nlint mulcomb(lint n, lint r) {\n  if (n < 1 or r < 0) return 0;\n  return fact[r + n - 1] * ifact[r] % mod * ifact[n - 1] % mod;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  lint n, k; cin >> n >> k;\n  if (n < k) return cout << 0 << '\\n', 0;\n  init_table(n + k);\n  lint res = 0;\n  for (lint i = 0; i < k + 1; ++i) res += (k - i & 1 ? -1 : 1) * comb(k, i) * powm(i, n) % mod;\n  cout << emod(res) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef long long int ll;\n\nconstexpr ll mod=1e9+7;\n\nll mod_pow(ll a,ll b){\n\ta%=mod;\n\tif(b==0)return 1;\n\tif(b==1)return a;\n\tll res=mod_pow(a,b/2)%mod;\n\tres*=res; res%=mod;\n\tif(b%2)res*=a;\n\treturn res%mod;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=mod_pow(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(1<<20);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,k; cin >> n >> k;\n\tif(k>n){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tll res=0;\n\tfor(int i=0;i<k;i++){\n\t\tif(i%2==0){\n\t\t\t(res+=mod_pow(k-i,n)*p.comb(k,i)%mod)%=mod;\n\t\t}else{\n\t\t\t(res-=mod_pow(k-i,n)*p.comb(k,i)%mod)%=mod;\n\t\t}\n\t}\n\tif(res<0)res+=mod;\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  long long n,k,m=1e9+7,dp[1002][1002]={};\n  cin>>n>>k;\n  dp[0][0]=1;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<=k;j++){\n      ( dp[i+1][j]+=dp[i][j]*j )%=m;\n      ( dp[i+1][j+1]+=dp[i][j]*(k-j) )%=m;   \n    }\n  }\n  cout<<dp[n][k]<<endl;\n  return 0;\n}\n\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\nlong double EPS=1E-8;\n////////////////////////////////////////\n#define N 5004\n\nll kai[N];\nll kai2[N];\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else if(p==1)return mod(i);\n    else if(p%2==0)return po(mod(mod(i)*mod(i)),p/2);\n    else  return mod(mod(i)*po(i,p-1));\n}\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(int i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    else if(n==0)return 1;\n    else return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\nint main(){\n    calc();\n    ll n,k;cin>>n>>k;\n    ll ans=0;\n    for(ll i=k;i>=1;i--){\n        ll sum=mod(comb(k,i)*po(i,n));\n        if((k-i)%2==0)ans+=sum;\n        else ans-=sum;\n        //cout<<sum<<endl;\n        ans=mod(ans);\n    }\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x; \n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\n\nmint f(int n){ \n  if(n == 0)return 1;\n  mint x = f(n / 2); \n  x *= x; \n  if(n % 2 == 1)x *= 2;\n  return x;\n}\n\nmint choose(int n, int a){\n  mint x = 1, y = 1;\n  for(int i = 0; i < a; ++i){\n    x *= n - i;\n    y *= i + 1;\n  }\n  return x / y;\n}\n\nmint fact[1010];\nmint inv_fact[1010];\nvoid init(){\n  fact[0] = 1;\n  for(int i = 1; i < 1010; ++i){\n    fact[i] = fact[i - 1] * i;\n  }\n\n  inv_fact[1010 - 1] = fact[1010 - 1].inv();\n  for(int i = 1010 - 1; i >= 1; --i){\n    inv_fact[i - 1] = inv_fact[i] * i;\n  }\n}\n\nmint comb(int n, int k){\n  if(n < k)return 0;\n  else return fact[n] * inv_fact[n - k] * inv_fact[k];\n}\n\nmint mod_pow(mint n, ll k){\n  if(k == 0)return 1;\n  mint a = mod_pow(n, k / 2);\n  a *= a;\n  if(k % 2)a *= n;\n  return a;\n}\n\nint main(){\n  init();\n  int n, k;\n  cin >> n >> k;\n\n  mint ans = mod_pow((mint)k, n);\n  for(int i = 1; i <= k; ++i){\n    if(i % 2)ans -= comb(k, i) * mod_pow((mint)(k - i), n);\n    else ans += comb(k, i) * mod_pow((mint)(k - i), n);\n  }\n\n  cout << ans.x << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n\nconst ll MOD = 1e9+7;\nll dp[1005][1005];\nll solve(){\n    ll res = 0;\n    ll n,k; cin >> n >> k;\n    dp[0][0] = 1;\n    for(int i = 1; i <= n; i++){\n        for(int j = 1; j <= k; j++){\n            dp[i][j] += dp[i-1][j] * j;\n            dp[i][j] += dp[i-1][j-1] * j;\n            dp[i][j] %= MOD;\n        }\n    }\n    res = dp[n][k];\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nll modpow(ll a, ll b){\n    if(b == 0) return 1;\n    else if(b % 2 == 0){\n        ll d = modpow(a, b / 2) % MOD;\n        return (d * d) % MOD;\n    }\n    else{\n        return (a * modpow(a, b - 1)) % MOD;\n    }\n}\n\nconst int MAX_N = 1010;\n\nll fact[MAX_N], finv[MAX_N];\nll comb(int n, int r){\n    if(n < r || r < 0) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nvoid comb_init(int n){\n    fact[0] = finv[0] = 1;\n    for(int i=1; i<=n; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        finv[i] = modpow(fact[i], MOD - 2);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k; cin>>n>>k;\n\n    comb_init(1005);\n\n    ll ans = 0;\n    for(int i=0; i<=k; i++){\n        int rest = k - i;\n        ll cur = comb(k, i) * modpow(rest, n) % MOD;\n\n        if(i % 2 == 0) ans = (ans + cur) % MOD;\n        else           ans = (ans - cur + MOD) % MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n\nll modpow(ll a, ll b){\n  ll r = 1;\n  while(b){\n    if(b&1)r=r*a%MOD;\n    a=a*a%MOD;\n    b>>=1;\n  }\n  return r;\n}\nll modinv(ll a){return modpow(a,MOD-2);}\n\nint n,k;\n\nint main(){\n  cin>>n>>k;\n  ll ans = 0;\n  REP(i,k){\n    ll comb = 0;\n    { // k C i\n      ll a = 1, b = 1;\n      FOR(j,1,i+1){\n        a = a*(k-j+1)%MOD;\n        b = b*j%MOD;\n      }\n      comb = a * modinv(b) % MOD;\n    }\n    ll pw = modpow(k-i,n);\n    int sign = i%2==0 ? 1 : -1;\n    ans += MOD + sign*comb*pw%MOD;\n    ans %= MOD;\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int mod> struct ModInt {\n    int x;\n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) { if((x += p.x) >= mod) x -= mod; return *this; }\n    ModInt &operator-=(const ModInt &p) { if((x += mod-p.x) >= mod) x -= mod; return *this; }\n    ModInt &operator*=(const ModInt &p) { x = (int)(1LL*x*p.x%mod); return *this; }\n    ModInt &operator/=(const ModInt &p) { *this *= p.inverse(); return *this; }\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) { t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n        return ModInt(u);\n    }\n    ModInt pow(long long e){\n        long long a = 1, p = x;\n        while(e > 0) {\n            if (e & 1) {a = (a * p) % mod; e--;}\n            else {p = (p * p) % mod; e /= 2;}\n        }\n        return ModInt(a);\n    }\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\ntemplate<int mod> struct Combination {\n    vector<ModInt<mod>> fact, ifact;\n    Combination(int n) : fact(n+1), ifact(n+1) {\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i - 1] * i);\n        ifact[n] = fact[n].inverse();\n        for (int i = n; i > 0; i--) ifact[i - 1] = ifact[i] * i;\n    }\n    ModInt<mod> operator() (int n, int r) {\n        if (r < 0 or r > n) return 0;\n        return fact[n] * ifact[n-r] * ifact[r];\n    }\n    const ModInt<mod> &operator[] (int i) const {\n        return fact[i];\n    }\n};\n\nconstexpr int MOD = 1000000007;\nconstexpr int MAX = 1000100;\n\nint main() {\n\tCombination<MOD> binom(MAX);\n\tint n, k;\n\tcin >> n >> k;\n\t\n\tif (n < k) {\n\t\tcout << 0 << '\\n';\n\t\treturn 0;\n\t}\n\t\n\tModInt<MOD> ans = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tModInt<MOD> res = binom(k, i) * ModInt<MOD>(i).pow(n);\n\t\tif ((k - i) & 1) ans -= res;\n\t\telse ans += res;\n\t}\n\t\n\tcout << ans << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntypedef long long ll;\nusing namespace std;\n\nll dp[1001][1001];\n\nll solve(ll n, ll k, ll m) {\n  dp[0][0] = 1;\n  for(int i=1;i<=n;++i) {\n    for(int j=1;j<=i;++j) {\n      dp[i][j] = j*(dp[i-1][j-1] + dp[i-1][j]) % m;\n    }\n  }\n  return dp[n][k];\n}\n\nint main() {\n  ll n,k,mod=1e9+7;\n  cin>>n>>k;\n  cout<<solve(n,k,mod)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class T>\nstruct Combination {\n    int max_n;\n    std::vector<T> f, invf;\n\n    explicit Combination(int n)\n        : max_n(n), f(n + 1), invf(n + 1) {\n        f[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            f[i] = f[i - 1] * i;\n        }\n\n        invf[max_n] = f[max_n].inv();\n        for (int i = max_n - 1; i >= 0; --i) {\n            invf[i] = invf[i + 1] * (i + 1);\n        }\n    }\n\n    T fact(int n) const { return f[n]; }\n    T invfact(int n) const { return invf[n]; }\n    T perm(int a, int b) const {\n        return a < b ? T(0) : f[a] * invf[a - b];\n    }\n    T comb(int a, int b) const {\n        return a < b ? T(0) : f[a] * invf[a - b] * invf[b];\n    }\n};\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nconst Combination<mint> C(1000);\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    mint ans = 0;\n    for (int i = 0; i <= k; ++i) {\n        ans += mint(-1).pow(k - i) * C.comb(k, i) * mint(i).pow(n);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>  \nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000000000000000000000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long power(long long a,long long now) {\n\tlong long ans = 1;\n\twhile (now != 0) {\n\t\tif (now % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\tnow /= 2;\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t}\n\treturn ans;\n}\nlong long inv(long long a) {\n\treturn power(a, MAX_MOD - 2);\n}\nlong long Permutation(long long a, long long b) {\n\tlong long ans = 1;\n\tfor (long long i = 0; i < b; ++i) {\n\t\tans *= (a - i);\n\t\tans %= MAX_MOD;\n\t}\n\treturn ans;\n}\nlong long Combination(long long a, long long b) {\n\tlong long ans = 1;\n\tfor (long long i = 0; i < b; ++i) {\n\t\tans *= (a - i);\n\t\tans %= MAX_MOD;\n\t\tans *= inv(i + 1);\n\t\tans %= MAX_MOD;\n\t}\n\treturn ans;\n}\nint main() {\n\tlong long n, k;\n\tcin >> n >> k;\n\tlong long ans = 0;\n\tfor (long long i = 0; i < k; ++i) {\n\t\tlong long tmp = Combination(k,i);\n\t\ttmp *= power(k - i, n);\n\t\ttmp %= MAX_MOD;\n\t\tif (i % 2 == 0) {\n\t\t\tans += tmp;\n\t\t}\n\t\telse {\n\t\t\tans -= tmp;\n\t\t}\n\t\tans += MAX_MOD;\n\t\tans %= MAX_MOD;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\nll modpow(ll a, ll n, ll mod_) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod_;\n        a = a * a % mod_;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst ll MAX_SIZE = 200005;\narray<ll, MAX_SIZE> fac, inv, finv;\nvoid finit() {\n    // combination init\n    fac[0] = 1;\n    for (ll i = 1; i < MAX_SIZE; i++) fac[i] = fac[i - 1] * i % MOD;\n    finv[MAX_SIZE - 1] = modpow(fac[MAX_SIZE - 1], MOD - 2, MOD);\n    for(ll i = MAX_SIZE - 1; i > 0; i--) finv[i - 1] = finv[i] * i % MOD;\n    \n    //inv init\n    repe(i, 1, MAX_SIZE) inv[i] = modpow(i, MOD - 2, MOD);\n}\n\nll perm(ll a, ll b) { return fac[a] * finv[a - b] % MOD; }\n\nll comb(ll a, ll b) { return fac[a] * finv[b] % MOD * finv[a - b] % MOD; }\n\nint main() {\n    init();\n    finit();\n    ll N, K;\n    cin >> N >> K;\n    \n    if(N<K){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    ll ans = 0;\n    rep(i,K+1){\n        ans += (i & 1 ? -1 : 1) * comb(K, i) * modpow(K - i, N, MOD) % MOD;\n    }\n\n    cout << (MOD + ans%MOD)%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(obj) (obj).begin(),(obj).end()\n#define RALL(obj) (obj).rbegin(),(obj).rend()\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define RANGE(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(n)-1;i>= 0;--i)\n\n#define endl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define pque priority_queue\n#define umap unordered_map\n#define uset unordered_set\n#define BIG 2000000000\n#define VERYBIG 1000000000000000ll\n#define PI 3.141592653589793238\n#define dcout cout<<fixed<<setprecision(50)\n#define _popcnt __builtin_popcount\n\nconst long long dx[]={1,0,-1,0,1,1,-1,-1}, dy[]={0,-1,0,1,1,-1,1,-1};\nconst long long MOD = 1e9+7;\n\n// typedef long long ll;\n#define int long long\n#define double long double\n\ntemplate<typename T> inline T GCD(T a,T b){T c;while(b!=0){c=a%b;a=b;b=c;}return a;}\ntemplate<typename T> inline T LCM(T a,T b){T c=GCD(a,b);a/=c;return a*b;}\ntemplate<typename T> inline T nCr(T a,T b){T i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\ntemplate<typename T> inline T nHr(T a,T b){return nCr(a+b-1,b);}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n\ntypedef pair<int, int> INTP;\ntypedef vector<int> INTV;\nstruct edge2 {int to, cost;};\nstruct edge3 {int from, to, cost;};\n\nint powmod(int a, int p, int m){\n  int res = 1, tmp = a;\n  while(p != 0){\n    if(p % 2)\n      res = (res*tmp) % m;\n    tmp = (tmp*tmp) % m;\n    p /= 2;\n  }\n  return res;\n}\n\nint fact[2000], invfact[2000];\n\nint invmod(int a, int p){ // a^-1 mod p\n  int b = p, u = 1, v = 0;\n  while(b){\n    int t = a / b;\n    a -= t*b; swap(a, b);\n    u -= t*v; swap(u, v);\n  }\n  u %= p;\n  if(u < 0) u += p;\n  return u;\n}\n\nvoid factmod(int m){\n  fact[0] = invfact[0] = 1;\n  for(int i = 1; i < 2000; i++){\n    fact[i] = (fact[i-1] * i) % m;\n    invfact[i] = (invfact[i-1] * invmod(i, m)) % m;\n  }\n}\n\nint nCrmod(int n, int r, int m){\n  return (((fact[n] * invfact[r]) % m) * invfact[n-r]) % m;\n}\n\nsigned main(void){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n \n  int N, K; cin >> N >> K;\n  factmod(MOD);\n  int ans = 0;\n  for(int emp = 1; emp < K; emp++){\n    int num = nCrmod(K, emp, MOD) * powmod(K-emp, N, MOD);\n    num %= MOD;\n    if(emp & 1){\n      ans += num; ans %= MOD;\n    } else {\n      ans += MOD;\n      ans -= num; ans %= MOD;\n    }\n  }\n  ans = powmod(K, N, MOD) + MOD - ans;\n  ans %= MOD;\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\ntemplate<typename T>\nvoid FROM_STRING(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// {{{ num\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// gcd(0,0) = 0\ni64 gcd(i64 a, i64 b) {\n    return gcd_impl(abs(a), abs(b));\n}\n\n// lcm(0,x) は未定義\ni64 lcm(i64 a, i64 b) {\n    assert(a != 0 && b != 0);\n    a = abs(a);\n    b = abs(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// 事前条件: a >= 0, b >= 0\ni64 extgcd_impl(i64 a, i64 b, i64& x, i64& y) {\n    if(b == 0) {\n        x = 1; y = 0;\n        return a;\n    }\n    i64 g = extgcd_impl(b, a%b, y, x);\n    y -= a/b * x;\n    return g;\n}\n\n// g=gcd(a,b), および ax+by=g の整数解 (x0,y0) を求める\n// (g,x0,y0) を返す\n// g!=0 のとき、一般解は (x,y) = (x0+m*b/g, y0-m*a/g) で与えられる(mは整数)\ntuple<i64,i64,i64> extgcd(i64 a, i64 b) {\n    i64 x, y;\n    i64 g = extgcd_impl(abs(a), abs(b), x, y);\n    x *= sgn(a);\n    y *= sgn(b);\n    return make_tuple(g, x, y);\n}\n\n// 素因数分解\n// (素因数,指数) のリストを返す\n// n >= 1 でなければならない\n// n == 1 の場合、空リストを返す\nvector<pair<i64,i64>> factorize(i64 n) {\n    assert(n >= 1);\n\n    vector<pair<i64,i64>> res;\n\n    i64 m = n;\n    for(i64 i = 2; i*i <= n; ++i) {\n        if(m == 1) break;\n        i64 e = 0;\n        while(m % i == 0) {\n            ++e;\n            m /= i;\n        }\n        if(e) res.emplace_back(i, e);\n    }\n    if(m > 1) res.emplace_back(m, 1);\n\n    return res;\n}\n\n// 二分累乗\ntemplate<typename Monoid>\nMonoid pow_binary(Monoid x, i64 e) {\n    assert(e >= 0);\n\n    Monoid res(1);  // 行列などの場合はここを適当に変える\n    Monoid cur = x;\n    while(e > 0) {\n        if(e & 1)\n            res *= cur;\n        cur *= cur;\n        e >>= 1;\n    }\n    return res;\n}\n\n// mod m での a の逆元\n// a ⊥ m でなければならない\ni64 inv_mod(i64 a, i64 m) {\n    i64 g,x0; tie(g,x0,ignore) = extgcd(a, m);\n    assert(g == 1);\n    return modulo(x0, m);\n}\n\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) : v_(modulo(v,P)) {}\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT inv() const {\n        return ModPT(inv_mod(v_,P));\n    }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nistream& operator>>(istream& in, ModPT<P>& x) {\n    return in >> x.v_;\n}\n\ntemplate<i64 P>\nostream& operator<<(ostream& out, ModPT<P> x) {\n    return out << x.v_;\n}\n\nusing ModP = ModPT<MOD>;\n\n// F(0) = 0\n// F(1) = 1\n// F(n) = F(n-1) + F(n-2)\n//\n// // decltype(auto) で受けると SIZE() が使える (auto だとポインタになってしまう)\n// decltype(auto) fib = fibonacci<1000>();\ntemplate<size_t N>\nModP (&fibonacci())[N] {\n    static_assert(N >= 2, \"\");\n    static ModP fib[N] {};\n\n    if(fib[1] != 1) {\n        fib[0] = 0;\n        fib[1] = 1;\n        FOR(i, 2, N) {\n            fib[i] = fib[i-1] + fib[i-2];\n        }\n    }\n    return fib;\n}\n\ntemplate<size_t N>\nModP (&factorial())[N] {\n    static_assert(N >= 1, \"\");\n    static ModP fac[N] {};\n\n    if(fac[0] != 1) {\n        fac[0] = 1;\n        FOR(i, 1, N) {\n            fac[i] = i * fac[i-1];\n        }\n    }\n    return fac;\n}\n\ntemplate<size_t N>\nModP (&ifactorial())[N] {\n    static_assert(N >= 1, \"\");\n    static ModP ifac[N] {};\n\n    if(ifac[0] != 1) {\n        decltype(auto) fac = factorial<N>();\n        ifac[N-1] = fac[N-1].inv();\n        for(i64 i = N-2; i >= 0; --i) {\n            ifac[i] = (i+1) * ifac[i+1];\n        }\n    }\n    return ifac;\n}\n\ntemplate<size_t N>\nModP permutation_count(i64 n, i64 r, const ModP (&fac)[N], const ModP (&ifac)[N]) {\n    if(n < r) return 0;\n    return fac[n] * ifac[n-r];\n}\n\n// }}}\n\n//--------------------------------------------------------------------\n\ntemplate<size_t N>\nModP combination_count(i64 n, i64 r, const ModP (&fac)[N], const ModP (&ifac)[N]) {\n    if(n < r) return 0;\n    return fac[n] * ifac[r] * ifac[n-r];\n}\n\nvoid solve() {\n    i64 N,K; RD(N); RD(K);\n\n    decltype(auto) fac  = factorial<1001>();\n    decltype(auto) ifac = ifactorial<1001>();\n\n    ModP ans = 0;\n    FOR(i, 0, K+1) {\n        i64 sign = is_even(i) ? 1 : -1;\n        ans += sign * combination_count(K,i,fac,ifac) * pow_binary(ModP(K-i),N);\n    }\n\n    // * MOD はとった?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n  return res;\n}\n\nstruct Factorial{\n  int n;\n  const int MOD = 1e9 + 7;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  LL(n); LL(k);\n  Factorial fac(n);\n  if(n < k)cout << 0 << endl;\n  else{\n    ll res = 0;\n    for(int i = k; i > 0; i--){\n      ll tmp = power<ll>(i, n, mod) * fac.comb(k, i) % mod;\n      if((k-i) % 2 == 0)res = (res + tmp) % mod;\n      else res = (res - tmp) % mod;\n      if(res < 0)res += mod;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(i, n) for(int i=0; i<=n; i++)\n#define repr(i, n) for(int i=n; i>0; i--)\n#define REPR(i, n) for(int i=n; i>=0; i--)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst ll MOD = 1e9+7;\ntemplate<class T> void puts(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int MAX = 1005;\nll nCk[MAX][MAX];\nll dp[MAX];\n\nll pow_mod(ll k, ll n) {\n    ll ret = 1;\n    rep(i, n) {\n        ret *= k;\n        ret %= MOD;\n    }\n    return ret;\n}\n\nll mod(ll a, ll b) {\n    return (a%b + b) % b;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n\n    if (n < k) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    // nCkを求める\n    for (int i = 0; i < MAX; i++) nCk[i][0] = nCk[i][i] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 1; j <= i-1; j++) {\n            nCk[i][j] = nCk[i-1][j-1] + nCk[i-1][j];\n            nCk[i][j] %= MOD;\n        }\n    }\n\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2; i <= k; i++) {\n        ll tmp = pow_mod(i, n);\n        for (int j = i-1; j >= 1; j--) {\n            tmp -= nCk[i][j] * dp[j];\n            tmp = mod(tmp, MOD);\n        }\n        dp[i] = tmp;\n    }\n\n    cout << dp[k] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#if __has_include(<boost/multiprecision/cpp_int.hpp>)\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n\tusing namespace boost::multiprecision;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::reverse_iterator first, const typename std::vector<T>::reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_iterator first, const typename std::vector<T>::const_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_reverse_iterator first, const typename std::vector<T>::const_reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\t\t\n\t\tdbool(const dbool&) = default;\n\t\tdbool(dbool&&) = default;\n\t\tdbool& operator=(const dbool&) = default;\n\t\tdbool& operator=(dbool&&) = default;\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\\\\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception(); }\n\tvoid catch_SIGSEGV([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\t//inline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*\nnCk：n!が間に合わないくらい巨大でkが小さいとき、素直に計算すると間に合う のは1e7以上に組み込んであります\n\tauto f = [](ll n, ll k){\n\t\tif(n<k)return Modint(0);\n\t\tModint val(1);\n\t\tk=min(k,n-k);\n\t\tfor(ll i=n;i>(n-k);i--)val*=i;\n\t\tfor(ll i=k;i>1;i--)val/=i;\n\t\treturn val;\n\t};\n*/\n\n////\n\nModint ball1box1(ll N,ll K){\n\treturn Modint(K).pow(N);\n}\nModint ball1box1injection(ll N,ll K){\n\treturn nPk(K,N);\n}\nModint ball1box1surjection(ll N,ll K){\n\tModint ans=0;\n\tfor(ll i=0; i<=K; i++){\n\t\tModint t=nCk(K,i)*Modint(i).pow(N);\n\t\tif((K-i)%2==0)ans+=t;\n\t\telse ans-=t;\n\t}\n\treturn ans;\n}\n\n\n/*-----8<-----library-----8<-----*/\n \nvoid solve() {\n\tll N,K;\n\tcin>>N>>K;\n\tModint ans;\n\t//ボール区別あり 箱区別あり 制限なし\n\t//ans=ball1box1(N,K);\n\t//ボール区別あり 箱区別あり 箱の中身は1つ以下\n\t//ans=ball1box1injection(N,K);\n\t//ボール区別あり 箱区別あり 箱の中身は1つ以上\n\tans=ball1box1surjection(N,K);\n\t//ボール区別あり 箱区別あり 制限なし\n\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以下\n\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以上\n\n\t//ボール区別なし 箱区別あり 制限なし\n\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以下\n\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以上\n\n\t//ボール区別あり 箱区別なし 制限なし\n\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以下\n\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以上\n\n\t//ボール区別なし 箱区別なし 制限なし\n\n\t//ボール区別なし 箱区別なし 箱の中身は1つ以下\n\n\t//ボール区別なし 箱区別なし 箱の中身は1つ以上\n\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/finder.jsp?course=DPL\n//https://qiita.com/drken/items/f2ea4b58b0d21621bd51\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\n\nll mod_pow(ll a, ll n) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) {\n\t\tll tmp = mod_pow(a, n / 2);\n\t\treturn (tmp * tmp) % MOD;\n\t}\n\treturn (a * mod_pow(a, n - 1)) % MOD;\n}\n\nvector<ll> fact;\nvector<ll> inv_fact;\n\nvoid comb_init(int n) {\n\tfact.resize(n + 1);\n\tinv_fact.resize(n + 1);\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n}\n\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tll ans = 0;\n\tcomb_init(k);\n\tfor (int i = 0; i <= k; i++) {\n\t\tll x = mod_pow(k - i, n);\n\t\t(x *= comb(k, i));\n\t\tif (i % 2 == 0) (ans += x) %= MOD;\n\t\telse (ans += MOD - x) %= MOD;\n\t}\n\tcout << ans << endl;\n }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\n\nll dp[1001][1001];\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n\n  dp[0][0]=1;\n  \n  for(int i=1;i<=n;i++){\n    for(int j=1;j<=i;j++){\n      dp[i][j]+=dp[i-1][j-1]*(k-j+1);\n      dp[i][j]+=dp[i-1][j]*j;\n      dp[i][j]%=mod;\n    }\n  }\n  cout<<dp[n][k]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nll rui(ll a,ll b){\n    if(b==1) return a%mod;\n    else if(b==0) return 1;\n    else if(b%2==0) return (rui(a,b/2)*rui(a,b/2))%mod;\n    else return (rui(a,b-1)*a)%mod;\n}\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n\n    int N,K;cin>>N>>K;\n    make();\n    ll ans=0;\n    for(int i=1;i<=K;i++){\n        if((K-i)%2){\n            ans+=comb(K,i)*(mod-rui(i,N));\n            ans=ans%mod;\n        }else{\n            ans+=comb(K,i)*rui(i,N);\n            ans=ans%mod;\n        }\n    }\n    \n    if(N<K) ans=0;\n    \n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nconst int MAX = 1010;\nlong long inv[MAX];\nlong long fac[MAX];\nlong long finv[MAX];\n\nvoid init() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (long long i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 累乗 a^n\nlong long pow_mod(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\n// 組み合わせ nCk = n! / (k! * (n - k)!)\nlong long nCk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n - k] % MOD;\n}\n\n// 包除原理\nlong long PIE(int n, int k) {\n    if (n > k) return 0;\n    if (n < 0 || k < 0) return 0;\n    long long res = 0;\n    for (int i = 0; i <= n; i++) {\n        long long tmp = nCk(n, i) * pow_mod(i, k) % MOD;\n        if ((n - i) & 1) res = (res + MOD - tmp) % MOD;\n        else res = (res + tmp) % MOD;\n    }\n    return res;\n}\n\n\nvoid _main() {\n    int n, k;\n    cin >> n >> k;\n    init();\n    cout << PIE(k, n) << endl;\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cfloat>\n#include<climits>\n#include<cmath>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type\nfill_v(T& t, const V& v) { t = v; }\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type\nfill_v(T& t, const V& v) {\n\tfor (auto& e : t) fill_v(e, v);\n}\n\n\n#define ARRAY_MAX 100005\nconst int INF = INT32_MAX / 3;\nconst ll MOD = 1e9 + 7;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\n/******************************************************************************************/\n\n\n//xのn乗をmで余りを取る\nll mod_pow(ll x, ll n, ll m) {\n\tif (n == 0) {\n\t\treturn 1LL;\n\t}\n\telse if (n % 2 == 0) {\n\t\treturn mod_pow(x * x % m, n / 2, m);\n\t}\n\telse {\n\t\treturn (x * mod_pow(x, n - 1, m)) % m;\n\t}\n}\n\nstruct Combination {\n\n\tvector<ll> fact, rfact;\n\n\tCombination(ll sz) : fact(sz + 1), rfact(sz + 1) {\n\n\t\tfact[0] = 1;\n\t\tfor (ll i = 1; i < fact.size(); i++) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\t//逆元\n\t\trfact[sz] = inv(fact[sz]);\n\t\tfor (ll i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % MOD;\n\t\t}\n\t}\n\n\tll inv(ll x) {\n\t\treturn pow(x, MOD - 2);\n\t}\n\tll pow(ll x, ll n) {\n\t\tll ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= MOD;\n\t\t\t(x *= x) %= MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\tll P(ll n, ll r) {\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (fact[n] * rfact[n - r] % MOD);\n\t}\n\n\tll C(ll p, ll q) {\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (fact[p] * rfact[q] % MOD * rfact[p - q] % MOD);\n\t}\n\n\tll H(ll n, ll r) {\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\n\n\nll comb[1005][1005];\n\n\nint main() {\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\n\tint n, k;\n\tcin >> n >> k;\n\tint ans = 0;\n\n\tCombination comb(k + 10);\n\n\tfor (int i = 1; i <= k; i++)\n\t{\n\t\tint rest = k - i;\n\t\tll val = comb.C(k,i) * mod_pow(rest, n, MOD);\n\t\tif (i % 2) {\n\t\t\tans = (ans + val) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans = (ans - val + MOD) % MOD;\n\t\t}\n\t}\n\t\n\tans = (mod_pow(k, n, MOD) - ans + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\nconst intmax_t MOD = intmax_t(1e9) + 7;\n// ModInt {{{\ntemplate <intmax_t MOD>\nclass ModInt {\n    intmax_t value;\n\npublic:\n    inline ModInt(const ModInt& other) :\n        value(other.value)\n    {}\n\n    inline ModInt(intmax_t value = 0) {\n        if (value >= MOD) {\n            this->value = value % MOD;\n        } else if (value < 0) {\n            this->value = (value + MOD) % MOD;\n        } else {\n            this->value = value;\n        }\n    }\n\n    template <class T>\n        explicit inline operator T() const {\n            return static_cast<T>(value);\n        }\n\n    inline ModInt inverse() const {\n        return ModInt::pow(value, MOD - 2);\n    }\n\n    inline ModInt& operator+=(const ModInt other) {\n        value = (value + other.value) % MOD;\n        return *this;\n    }\n\n    inline ModInt& operator-=(const ModInt other) {\n        value = (MOD + value - other.value) % MOD;\n        return *this;\n    }\n\n    inline ModInt& operator*=(const ModInt other) {\n        value = (value * other.value) % MOD;\n        return *this;\n    }\n\n    inline ModInt& operator/=(const ModInt other) {\n        value = (value * other.inverse().value) % MOD;\n        return *this;\n    }\n\n    inline ModInt operator+(const ModInt other) {\n        return ModInt(*this) += other;\n    }\n\n    inline ModInt operator-(const ModInt other) {\n        return ModInt(*this) -= other;\n    }\n\n    inline ModInt operator*(const ModInt other) {\n        return ModInt(*this) *= other;\n    }\n\n    inline ModInt operator/(const ModInt other) {\n        return ModInt(*this) /= other;\n    }\n\n    inline bool operator==(const ModInt other) {\n        return value == other.value;\n    }\n\n    inline bool operator!=(const ModInt other) {\n        return value != other.value;\n    }\n\n    friend ostream& operator<<(ostream &os, const ModInt other) {\n        os << other.value;\n        return os;\n    }\n\n    friend istream& operator>>(istream &is, ModInt& other) {\n        is >> other.value;\n        return is;\n    }\n\n    static constexpr inline ModInt pow(intmax_t n, intmax_t p) {\n        intmax_t ret = 1;\n        for (; p > 0; p >>= 1) {\n            if (p & 1) ret = (ret * n) % MOD;\n            n = (n * n) % MOD;\n        }\n        return ret;\n    }\n};\n\nusing Mint = ModInt<MOD>;\n// }}}\n\n// Factorial {{{\n#ifdef DEBUG\n#define constexpr\n#endif\n\ntemplate <size_t N, size_t MOD>\nstruct Factorial {\n    vector<uint_fast64_t> fact_;\n\n    constexpr inline Factorial() : fact_(N + 1) {\n        fact_[0] = 1;\n        for (intmax_t i = 1; i <= N; ++i) {\n            fact_[i] = (fact_[i - 1] * i) % MOD;\n        }\n    }\n\n    constexpr inline Mint operator[](size_t pos) const {\n        return fact_[pos];\n    }\n};\n\ntemplate <size_t N, size_t MOD>\nstruct InvFact {\n    vector<uint_fast64_t> inv_;\n    vector<uint_fast64_t> finv_;\n\n    constexpr inline InvFact() : inv_(N + 1), finv_(N + 1) {\n        inv_[1] = 1;\n        finv_[0] = finv_[1] = 1;\n        for (intmax_t i = 2; i <= N; ++i) {\n            inv_[i] = (MOD - MOD / i) * inv_[MOD % i] % MOD;\n            finv_[i] = finv_[i - 1] * inv_[i] % MOD;\n        }\n    }\n\n    constexpr inline Mint operator[](size_t pos) const {\n        return finv_[pos];\n    }\n};\n\n#ifdef constexpr\n#undef constexpr\n#endif\n\nFactorial<510000, MOD> fact;\nInvFact<510000, MOD> finv;\n\ninline Mint nCr(int n, int r) {\n    if (r < 0 || n < r) {\n        return 0;\n    }\n    return fact[n] * (finv[r] * finv[n - r]);\n}\n\ninline Mint nPr(int n, int r) {\n    if (r < 0 || n < r) {\n        return 0;\n    }\n    return fact[n] * finv[n - r];\n}\n\ninline Mint nHr(int n, int r) {\n    return nCr(n + r - 1, r);\n}\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n\n    var(intmax_t, n, k);\n\n    Mint res = 0;\n    reps(i, 1, k) {\n        res += Mint::pow(-1, k - i) * nCr(k, i) * Mint::pow(i, n);\n    }\n\n    output(res);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(ll i=2; i<MAX; i++){\n        fac[i] = fac[i-1]*i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\n\n\nll com(ll n, ll k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll modpow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n\nint main(){\n    ll n,k; cin >> n >> k;\n    mint ans = 0;\n    comInit();\n    rep(i,k+1){\n        mint tmp = com(k,i) * modpow(i,n,mod);\n        if((k-i) & 1) ans -= tmp;\n        else ans += tmp;\n    }\n    cout << ans.value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\n/* constant */\nconst int INF = 1 << 30;\nconst int NIL = -1;\nconst int MAX = 10000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\nstruct mint {\n    ll x;\n    mint(ll x = 0):x((x % mod + mod) % mod) {}\n    mint operator-() const { return mint(-x); }\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct combination {\n    // vector size : n + 1\n    vector<mint> fact, ifact;\n    // precaliculation O(n)\n    combination(int n):fact(n+1), ifact(n+1) {\n        assert(n < mod);\n        // 0! = 1;\n        fact[0] = 1;\n        // 1! = 0! * 1 ... n! = (n-1)! * n\n        for (int i = 1; i <= n; i++) fact[i] = fact[i-1] * i;\n        // 1/n! = n!^(-1)\n        ifact[n] = fact[n].inv();\n        // (n-1)!^(-1) = n!^(-1) * n ... 0!^(-1) = 1!^(-1) * 1\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i] * i;\n    }\n    // combination O(1)\n    // nCk = n! / (k! * (n-k)!)\n    //     = n! * k!^(-1) * (n-k)!^(-1)\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n-k];\n    }\n};\n/* global variables */\n/* function */\n/* main */\nint main() {\n    int n, k;\n    cin >> n >> k;\n    if (n < k) { cout << 0 << '\\n'; return 0; }\n    mint ans = 0;\n    combination c = combination(1000);\n    for (int i = 0; i <= k; i++) {\n        mint tmp = i;\n        tmp = tmp.pow(n);\n        tmp *= c(k, i);\n        if ((k - i) % 2) ans -= tmp;\n        else ans += tmp;\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// DPL_5_C: Count the number of ways to put\n// n distinguishable balls in\n// k distinguishable boxes, s.t.\n// each box receives at least one ball\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nll S[1002][1002];\nll M = 1e9 + 7;\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n\n  S[0][0] = 1;\n  // S(n,k)= S(n-1,k-1) + kS(n-1,k)\n  for (int k = 1; k <= K; ++k)\n    for (int n = 1; n <= N; ++n)\n      S[n][k] = (S[n - 1][k - 1] + k * S[n - 1][k]) % M;\n\n  ll F = 1;\n  for (int i = 2; i <= K; ++i)\n    F = (F * i) % M;\n\n  cout << ((F * S[N][K]) % M) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\ntemplate <typename T>\nT mypow(T a, T b)\n{\n    if (b == 0)\n        return 1;\n    T tmp = mypow(a, b / 2);\n    if (b % 2)\n        return (((tmp * tmp) % MOD) * a) % MOD;\n    else\n        return (tmp * tmp) % MOD;\n}\n\n// v[i][j] := iCj\ntemplate <typename T>\nstd::vector<std::vector<T>> comb2(T n)\n{\n    std::vector<std::vector<T>> v(n + 1, std::vector<T>(n + 1, 0));\n    for (int i = 0; i < (int)v.size(); i++)\n    {\n        v[i][0] = 1;\n        v[i][i] = 1;\n    }\n    for (int j = 1; j < (int)v.size(); j++)\n    {\n        for (int k = 1; k < j; k++)\n        {\n            v[j][k] = (v[j - 1][k - 1] + v[j - 1][k]);\n            v[j][k] %= MOD;\n        }\n    }\n    return v;\n}\n\nauto comb = comb2(1010);\nvector<ll> fact(1010, 1);\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, k;\n    cin >> n >> k;\n    for (int i = 2; i <= 1000; i++)\n    {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n    ll ret = 0;\n    for (int i = 1; i <= k; i++)\n    {\n        // i 個空\n        ll r = k - i;\n        ll tmp = comb[k][i] * mypow(r, n) % MOD;\n        if (i % 2)\n            ret = (ret + tmp) % MOD;\n        else\n            ret = (ret - tmp + MOD) % MOD;\n    }\n    ret = (mypow(k, n) - ret + MOD) % MOD;\n    cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n                                            #include<iostream>\n                                            #include<cstdio>\n                                            #include<vector>\n                                            #include<queue>\n                                            #include<map>\n                                            #include<cstring>\n                                            #include<string>\n                                            #include <math.h>\n                                            #include<algorithm>\n                                        //    #include <boost/multiprecision/cpp_int.hpp>\n                                            #include<functional>\n                                   #define int long long\n                                            #define inf  1000000007\n                                            #define pa pair<int,int>\n                                            #define ll long long\n                                            #define pal pair<double,double>\n                                            #define ppap pair<pa,int>\n                                    //  #define PI 3.14159265358979323846\n                                            #define paa pair<int,char>\n                                            #define  mp make_pair\n                                            #define  pb push_back\n                                            #define EPS (1e-10)\n                                            #define equals(a,b) (fabs((a)-(b))<EPS)\n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n                                                   #define ppa pair<int,pas>\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                 \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\nint dp[1010][1010]={0};\n\n    signed main(){\n     \n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n,k;\n    \tcin>>n>>k;\n   \n    \tmod=inf;\n    \tgya(10000);\n   \n    \tint ans=0;\n    \tfor(int i=0;i<=k;i++){\n    \t\tint r=beki(k-i,n,inf);\n    \t\tint co=comb(k,i);\n    \t\tr*=co;\n    \t\tr%=inf;\n    \t\tif(i%2)ans+=inf-r;\n    \t\telse ans+=r;\n    \t\tans%=inf;\n    \t}\n    \tcout<<ans<<endl;\n    \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdint.h>\n#include <stdlib.h>\n\n#include <algorithm>\n#include <iostream>\n#include <numeric>\n#include <vector>\nusing namespace std;\nusing default_counter_t = int64_t;\n\n// macro\n#define let auto const &\n#define overload4(a, b, c, d, name, ...) name\n#define rep1(n) \\\n  for (default_counter_t i = 0, end_i = default_counter_t(n); i < end_i; ++i)\n#define rep2(i, n)                                                           \\\n  for (default_counter_t i = 0, end_##i = default_counter_t(n); i < end_##i; \\\n       ++i)\n#define rep3(i, a, b)                                    \\\n  for (default_counter_t i       = default_counter_t(a), \\\n                         end_##i = default_counter_t(b); \\\n       i < end_##i; ++i)\n#define rep4(i, a, b, c)                                 \\\n  for (default_counter_t i       = default_counter_t(a), \\\n                         end_##i = default_counter_t(b); \\\n       i < end_##i; i += default_counter_t(c))\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n\n#define rrep1(n) \\\n  for (default_counter_t i = default_counter_t(n) - 1; i >= 0; --i)\n#define rrep2(i, n) \\\n  for (default_counter_t i = default_counter_t(n) - 1; i >= 0; --i)\n#define rrep3(i, a, b)                                         \\\n  for (default_counter_t i         = default_counter_t(b) - 1, \\\n                         begin_##i = default_counter_t(a);     \\\n       i >= begin_##i; --i)\n#define rrep4(i, a, b, c)                                          \\\n  for (default_counter_t                                           \\\n           i = (default_counter_t(b) - default_counter_t(a) - 1) / \\\n                   default_counter_t(c) * default_counter_t(c) +   \\\n               default_counter_t(a),                               \\\n           begin_##i = default_counter_t(a);                       \\\n       i >= begin_##i; i -= default_counter_t(c))\n#define rrep(...) \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n\n#define ALL(f, c, ...)                                           \\\n  (([&](decltype((c)) cccc) {                                    \\\n    return (f)(std::begin(cccc), std::end(cccc), ##__VA_ARGS__); \\\n  })(c))\n\n// function\ntemplate <class C>\nconstexpr C &Sort(C &a) {\n  std::sort(std::begin(a), std::end(a));\n  return a;\n}\ntemplate <class C>\nconstexpr auto &Min(C const &a) {\n  return *std::min_element(std::begin(a), std::end(a));\n}\ntemplate <class C>\nconstexpr auto &Max(C const &a) {\n  return *std::max_element(std::begin(a), std::end(a));\n}\ntemplate <class C>\nconstexpr auto Total(C const &c) {\n  return std::accumulate(std::begin(c), std::end(c), C(0));\n}\ntemplate <typename T>\nauto CumSum(std::vector<T> const &v) {\n  std::vector<T> a(v.size() + 1, T(0));\n  for (std::size_t i = 0; i < a.size() - size_t(1); ++i) a[i + 1] = a[i] + v[i];\n  return a;\n}\ntemplate <typename T>\nconstexpr bool ChMax(T &a, T const &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\nconstexpr bool ChMin(T &a, T const &b) {\n  if (b < a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nvoid In(void) { return; }\n\ntemplate <typename First, typename... Rest>\nvoid In(First &first, Rest &... rest) {\n  cin >> first;\n  In(rest...);\n  return;\n}\n\ntemplate <class T, typename I>\nvoid VectorIn(vector<T> &v, const I n) {\n  v.resize(size_t(n));\n  rep(i, v.size()) cin >> v[i];\n}\n\nvoid Out(void) {\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid Out(First first, Rest... rest) {\n  cout << first << \" \";\n  Out(rest...);\n  return;\n}\n\nconstexpr auto yes(const bool c) { return c ? \"yes\" : \"no\"; }\nconstexpr auto Yes(const bool c) { return c ? \"Yes\" : \"No\"; }\nconstexpr auto YES(const bool c) { return c ? \"YES\" : \"NO\"; }\n\n// http://koturn.hatenablog.com/entry/2018/08/01/010000\ntemplate <typename T, typename U>\ninline std::vector<U> MakeNdVector(T n, U val) noexcept {\n  static_assert(std::is_integral<T>::value,\n                \"[MakeNdVector] The 1st argument must be an integer\");\n  return std::vector<U>(std::forward<T>(n), std::forward<U>(val));\n}\n\ntemplate <typename T, typename... Args>\ninline decltype(auto) MakeNdVector(T n, Args &&... args) noexcept {\n  static_assert(std::is_integral<T>::value,\n                \"[MakeNdVector] The 1st argument must be an integer\");\n  return std::vector<decltype(MakeNdVector(std::forward<Args>(args)...))>(\n      std::forward<T>(n), MakeNdVector(std::forward<Args>(args)...));\n}\n\ntemplate <typename T, std::size_t N,\n          typename std::enable_if<(N > 0), std::nullptr_t>::type = nullptr>\nstruct NdvectorImpl {\n  using type = std::vector<typename NdvectorImpl<T, N - 1>::type>;\n};  // struct ndvector_impl\n\ntemplate <typename T>\nstruct NdvectorImpl<T, 1> {\n  using type = std::vector<T>;\n};  // struct ndvector_impl\n\ntemplate <typename T, std::size_t N>\nusing NdVector = typename NdvectorImpl<T, N>::type;\n\ntemplate <int64_t Mod>\nstruct ModInt {\n  int64_t x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % Mod : (Mod - (-y) % Mod) % Mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= Mod) x -= Mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += Mod - p.x) >= Mod) x -= Mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = int64_t(1LL * x * p.x % Mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.Inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt Inverse() const {\n    int64_t a = x, b = Mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt Pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<Mod>(t);\n    return (is);\n  }\n\n  static int64_t GetMod() { return Mod; }\n};\n\ntemplate <typename T>\nstruct Combination {\n  vector<T> _fact, _rfact, _inv;\n\n  Combination(int64_t sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for (int64_t i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for (int64_t i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int64_t i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T Fact(int64_t k) const { return _fact[k]; }\n\n  inline T Rfact(int64_t k) const { return _rfact[k]; }\n\n  inline T Inv(int64_t k) const { return _inv[k]; }\n\n  T P(int64_t n, int64_t r) const {\n    if (r < 0 || n < r) return 0;\n    return Fact(n) * Rfact(n - r);\n  }\n\n  T C(int64_t p, int64_t q) const {\n    if (q < 0 || p < q) return 0;\n    return Fact(p) * Rfact(q) * Rfact(p - q);\n  }\n\n  T H(int64_t n, int64_t r) const {\n    if (n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\ntemplate <typename T>\nT ModPow(T x, T n, const T &p) {\n  T ret = 1;\n  while (n > 0) {\n    if (n & T(1)) (ret *= x) %= p;\n    (x *= x) %= p;\n    n >>= T(1);\n  }\n  return ret;\n}\n\n#ifdef USE_STACK_TRACE_LOGGER\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Weverything\"\n#include <glog/logging.h>\n#pragma clang diagnostic pop\n#endif  //__clang__\n#endif  // USE_STACK_TRACE_LOGGER\n\nusing Mi = ModInt<1000000007>;\n\nsigned main(int argc, char *argv[]) {\n  (void)argc;\n#ifdef USE_STACK_TRACE_LOGGER\n  google::InitGoogleLogging(argv[0]);\n  google::InstallFailureSignalHandler();\n#else\n  (void)argv;\n#endif  // USE_STACK_TRACE_LOGGER\n  int64_t n, k;\n  In(n, k);\n  Combination<Mi> c(k);\n  Mi ans = 0;\n  rep(i, 1, k + 1) {\n    Mi sign = (i % 2 == 1 ? Mi(1) : Mi(-1));\n    ans += sign * c.C(k, i) * Mi(ModPow(k - i, n, int64_t(1000000007)));\n  }\n  cout << Mi(ModPow(k, n, int64_t(1000000007))) - ans << endl;\n  return EXIT_SUCCESS;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\n#define pii pair<int,int>\n#pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void IN(void){return;}\ntemplate <typename First, typename... Rest> void IN(First& first, Rest&... rest){cin >> first;IN(rest...);return;}\ninline void OUT(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void OUT(First first, Rest... rest){cout << first << \" \";OUT(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst long long LLINF = 1e18;\nlong long lcm(ll a, ll b){return a * b / __gcd(a,b);}\nstruct IoSetup { IoSetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n} } iosetup;\ntemplate< int mod > struct ModInt {\n    int x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(int k) const { return _fact[k]; }\n\n  inline T rfact(int k) const { return _rfact[k]; }\n\n  inline T inv(int k) const { return _inv[k]; }\n\n  T P(int n, int r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(int p, int q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\ntemplate< typename T >\nT mod_pow(T x, T n, const T &p) {\n  T ret = 1;\n  while(n > 0) {\n    if(n & 1) (ret *= x) %= p;\n    (x *= x) %= p;\n    n >>= 1;\n  }\n  return ret;\n}\n\n\nint main(){\n    iosetup;\n    int n, k; cin >> n >> k;\n    Combination<modint> cb(k+1);\n    modint ans = 0;\n    rep(i, 0, k + 1){\n        if(i&1) ans -= cb.C(k, i) * mod_pow<ll>((k-i), n, mod);\n        else ans += cb.C(k, i) * mod_pow<ll>((k-i), n, mod);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nconst i32 mod = 1000000007;\n\ni32 mod_pow (i32 r, i32 n) {\n  i32 t = 1;\n  i32 s = r;\n  while (n > 0) {\n    if (n & 1) t = (i64) t * s % mod;\n    s = (i64) s * s % mod;\n    n >>= 1;\n  }\n  return t;\n}\n\ni32 comb (i32 n, i32 k) {\n  if (!(0 <= k && k <= n)) return 0;\n  i32 a = 1;\n  i32 b = 1;\n  for (i32 i =1; i <= k; ++i) {\n    a = (i64) a * (n + 1 - i) % mod;\n    b = (i64) b * i % mod;\n  }\n  return (i64) a * mod_pow (b, mod - 2) % mod;\n}\n\nvoid run (void) {\n  i32 n, k;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &k);\n  i32 ans = 0;\n  for (i32 i = k, sign = 1; i >= 1; --i, sign *= -1) {\n    ans = (ans + mod + (i64) sign * comb (k, i) * mod_pow (i, n) % mod) % mod;\n  }\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_5_C Balls and Boxes 3\n// n 個の区別できるボールを k 個の区別できる箱に入れる\n// とき、可能な入れ方の総数を求めてください。\n// ただし、\n//    どのボールも、必ずいずれかの箱に入れる。\n//    どの箱にも、1つ以上のボールを入れる。\n// 答えは　階乗*第2種スターリング数 k! * stirling2(n, k)\n// 2019.3.11 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\nint tbl[1001][1001];\n\nint fact(int n)\n{\n\tint i;\n\tlong long ans = 1;\n\tfor (i = 2; i <= n; i++) ans = (ans * i) % MOD;\n\treturn (int)ans;\n}\n\nint stirling2(int n, int k)\n{\n\tint ans;\n\n\tif (k == 0) return 0;\n\tif (tbl[n][k]) return tbl[n][k];\n\tif (k == 1 || k == n) ans = 1;\n\telse ans = (((long long)k * stirling2(n - 1, k)) % MOD)\n\t\t+ stirling2(n - 1, k - 1);\n\treturn tbl[n][k] = ans % MOD;\n}\n\nint main()\n{\n\tint n, k;\n\n\tscanf(\"%d%d\", &n, &k);\n\tif (n < k) puts(\"0\");\n\telse printf(\"%d\\n\", (int)(((long long)fact(k)*stirling2(n, k)) % MOD));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//Twelvefold way[syazou 12-sou]\n#include<stdio.h>\n#define mod 1000000007\n#define faclim 1048576\n#define partition_nlim 1024\n#define partition_klim 1024\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[faclim];\nlong long invfact[faclim];\nlong long bce[faclim];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<faclim;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[faclim-1]=modular_inverse(factorial[faclim-1]);\n  for(i=faclim-2;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n  for(i=0;i<faclim;i++){\n    if(i%2==1){bce[i]=mod-1;}\n    else{bce[i]=1;}\n    bce[i]*=invfact[i];\n    bce[i]%=mod;\n    if(i!=0){\n      bce[i]+=bce[i-1];\n      if(bce[i]>=mod){bce[i]-=mod;}\n    }\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  if(k<0 || n<k){return 0;}\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nlong long partition[partition_nlim][partition_klim];\nlong long partition_isinit=0;\n\nvoid partition_init(){\n  if(partition_isinit==1){return;}\n  partition_isinit=1;\n  long long i,j;\n  for(i=0;i<partition_nlim;i++){\n    for(j=0;j<partition_klim;j++){\n      partition[i][j]=-1;\n    }\n  }\n}\n\nlong long partition_rep(long long n,long long k){\n  if(n<0 || k<0){return 0;}\n  if(n==0){return 1;}\n  if(k==0){\n    if(n==0){return 1;}\n    else{return 0;}\n  }\n  if(partition[n][k]!=-1){return partition[n][k];}\n  partition[n][k]=(partition_rep(n,k-1)+partition_rep(n-k,k))%mod;\n  return partition[n][k];\n}\n\n// packing n balls using k boxes\n// |  distinguish  |  each boxes contains the balls limited  |\n// | balls | boxes |  no limits  |  at most 1  | at least 1  |\n// |  can  |  can  |      1      |      2      |      3      |\n// | can't |  can  |      4      |      5      |      6      |\n// |  can  | can't |      7      |      8      |      9      |\n// | can't | can't |     10      |     11      |     12      |\n\nlong long twelvefold_way(long long n,long long k,long long type){\n  long long i,r=0,dt;\n  switch(type){\n    case 1:\n      return power(k,n);\n      break;\n    case 2:\n      if(k<n){return 0;}\n      return (factorial[k]*invfact[k-n])%mod;\n      break;\n    case 3:\n      if(n<k){return 0;}\n      for(i=0;i<=k;i++){\n        dt=(calcnCr(k,i)*power(i,n))%mod;\n        if((k-i)%2==1){r+=(mod-dt);}\n        else{r+=dt;}\n        if(r>=mod){r-=mod;}\n      }\n      return r;\n      break;\n    case 4:\n      return calcnCr(n+k-1,n);\n      break;\n    case 5:\n      if(k<n){return 0;}\n      return calcnCr(k,n);\n      break;\n    case 6:\n      if(n<k){return 0;}\n      return calcnCr(n-1,k-1);\n      break;\n    case 7:\n      for(i=0;i<=k;i++){\n        dt=(power(i,n)*invfact[i])%mod;\n        r+=dt*bce[k-i];\n        r%=mod;\n      }\n      return r;\n    case 8:\n      if(k<n){return 0;}\n      return 1;\n      break;\n    case 9:\n      if(n<k){return 0;}\n      for(i=0;i<=k;i++){\n        dt=(calcnCr(k,i)*power(i,n))%mod;\n        if((k-i)%2==1){r+=(mod-dt);}\n        else{r+=dt;}\n        if(r>=mod){r-=mod;}\n      }\n      r*=invfact[k];r%=mod;\n      return r;\n      break;\n    case 10:\n      partition_init();\n      return partition_rep(n,k);\n      break;\n    case 11:\n      if(k<n){return 0;}\n      return 1;\n      break;\n    case 12:\n      if(n<k){return 0;}\n      partition_init();\n      return partition_rep(n-k,k);\n      break;\n  }\n}\n\nint main(){\n  cfact();\n  long long n,k;\n  scanf(\"%lld%lld\",&n,&k);\n  printf(\"%lld\\n\",twelvefold_way(n,k,3));\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\n//階乗,二項係数\n//*\nll fact[100010];\nll invfact[100010];\nvoid makefact(int n,ll m){\n\tfact[0]=1;\n\trep(i,0,n)fact[i+1]=fact[i]*(i+1)%m;\n\tinvfact[n]=invp(fact[n],m);\n\tfor(int i=n;i>0;i--)invfact[i-1]=invfact[i]*i%m;\n}\nll choose(int n,int r,int m){return n<0||r<0||n-r<0?0:fact[n]*invfact[r]%m*invfact[n-r]%m;}\n//*/\n\nint main(){\n\tmakefact(2000,MOD);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tll s=0;\n\trep(i,0,m+1)s=(s+choose(m,i,MOD)*pom(i,n,MOD)*((m-i)%2==0?1:-1))%MOD;\n\tprintf(\"%lld\\n\",(s+MOD)%MOD);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n \npublic class Main implements Runnable {\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        \n        Combinatrics c = new Combinatrics(k);\n\n    \tSystem.out.println(c.surjection(n,k));\n\n    }\n}\n\n\n\nclass Combinatrics {\n\t\n\tstatic long mod = 1000000007; //逆元を取るので素数前提\n\tstatic long[] fact; //階乗のテーブル\n\tstatic long[] inv;\t//逆元のテーブル\n\tstatic long[] finv; //階乗の逆元のテーブル\n\t\n\tpublic Combinatrics(int n){\n\t\tint N = Math.max(2,n+1);\n\t\tfact = new long[N];\n\t\tinv = new long[N];\n\t\tfinv = new long[N];\n\t    fact[0] = fact[1] = 1;\n\t    finv[0] = finv[1] = 1;\n\t    inv[1] = 1;\n\t    for(int i=2;i<n+1; i++){\n\t        fact[i] = fact[i-1] * i % mod;\n\t        inv[i] = mod - inv[(int)mod%i] * (mod / i) % mod;\n\t        finv[i] = finv[i-1] * inv[i] % mod;\n\t    }\n\t}\n\t\n\t//逆元\n\tint inv(int n){\n\t\treturn (int)inv[n];\n\t}\n\t\n\t//n!\n\tint factorial(int n){\n\t\treturn (int)fact[n];\n\t}\n\t\n\t//n!の逆元\n\tint factInv(int n){\n\t\treturn (int)finv[n];\n\t}\n\t\n\t//nCr（n個からr個選ぶ）\n    int combination(int n, int r) {\n        if(n<r|| r<0){\n        \treturn 0;\n        }\n        return (int)(fact[n]*finv[r]%mod*finv[n-r]%mod);\n    }\n\n    //nPr (=n*(n-1)*...*(n-r+1))（n個からr個選んで並べる）\n    int permutation(int n, int r) {\n        if(n<r || r<0){\n        \treturn 0;\n        }\n        return (int)(fact[n]*finv[n-r]%mod);\n    }\n\n    //nHr (=n+r-1Cr)（n個から重複を許してk個とる）\n    //（テーブルがn+r-1まで必要な事に注意！）\n    int homogeneous(int n, int r) {\n        if(n==0 && r==0){\n        \treturn 1;\n        }\n        return combination(n+r-1,r);\n    }\n    \n    int surjection(int n, int k){\n    \tlong ans = 0;\n    \tint sign = 1; //符号\n    \tif(k%2 == 0){\n    \t\tsign = -1;\n    \t}\n    \tfor(int i=1;i<=k;i++){\n    \t\tif(sign==1){\n    \t\t\tans += (long)combination(k,i)*iterationPow(i,n);\n    \t\t\tans %= mod;\n    \t\t}\n    \t\telse{\n    \t\t\tans -= (long)combination(k,i)*iterationPow(i,n);\n    \t\t\tans %= mod;\n    \t\t}\n    \t\tsign *= -1;\n    \t}\n    \tans = mod(ans);\n    \treturn (int)ans;\n    }\n\t//x^nをmodのもとで繰り返し2乗法で求める。\n\tstatic long iterationPow(long x, long n){\n\t    long sum = 1;\n\t    while(n>0){\n\t        if((n&1)== 1){  //ビットが立っていたら\n\t            sum *= x;        //x^2^k1 * x^2^k2 * x^2^k3 * ・・・\n\t            sum %= mod;\n\t        }\n\t        x *= x;              //((x^2)^2)^2・・・\n\t        x %= mod;\n\t        n >>= 1;\n\t    }\n\t    return sum;\n\t}\n\t//負の数に対応したmod\n\tstatic long mod(long a) {\n\t\treturn (a % mod + mod) % mod;\n\t}\n\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextIntArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solve();\n\t}\n\n\tprivate void solve() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tlong MOD = 1000000007L;\n\n\t\tlong ans = 1L;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tans = (ans * K) % MOD;\n\t\t}\n\t\tCombCalculator cc = new FactorialTableCombCalculator(1001, MOD);\n\t\tfor (int empty = 1; empty <= K - 1; empty++) {\n\t\t\tlong tmp = cc.comb(K, empty);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\ttmp = (tmp * (K - empty)) % MOD;\n\t\t\t}\n\t\t\tans = (ans + MOD + (tmp * (empty % 2 == 1 ? -1 : 1))) % MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tinterface CombCalculator {\n\t\tlong comb(int n, int m);\n\t}\n\n\tinterface MobiusFunction {\n\t\tint get(int n);\n\t}\n\n\t/**\n\t * メビウス関数をエラトステネスの篩っぽく前計算するクラスです。\n\t * 計算量はO(1)で、前計算でO(N logN)です。\n\t */\n\tclass SieveMobiusFunction implements MobiusFunction {\n\t\tint size;\n\t\tint[] mobiusFunctionValues;\n\n\t\tpublic SieveMobiusFunction(int size) {\n\t\t\tthis.size = size;\n\t\t\tmobiusFunctionValues = new int[size];\n\n\t\t\tmobiusFunctionValues[0] = 0;\n\t\t\tmobiusFunctionValues[1] = 1;\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t}\n\t\t\tfor (int i = 2; i * i < size; i++) {\n\t\t\t\tfor (int k = 1; i * i * k < size; k++) {\n\t\t\t\t\tmobiusFunctionValues[i * i * k] *= 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < size; i++) {\n\t\t\t\tif (mobiusFunctionValues[i] == 1) {\n\t\t\t\t\tfor (int k = 1; i * k < size; k++) {\n\t\t\t\t\t\tmobiusFunctionValues[i * k] *= -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] > 1) {\n\t\t\t\t\tmobiusFunctionValues[i] = 1;\n\t\t\t\t}\n\t\t\t\tif (mobiusFunctionValues[i] < -1) {\n\t\t\t\t\tmobiusFunctionValues[i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn mobiusFunctionValues[n];\n\t\t}\n\t}\n\n\t/**\n\t * メビウス関数を定義通り計算するクラスです。\n\t * 計算量はO(logN)です。\n\t */\n\tclass PrimeFactorizationMobiusFunction implements MobiusFunction {\n\t\t@Override\n\t\tpublic int get(int n) {\n\t\t\tif (n <= 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (n == 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tint num = 0;\n\t\t\tfor (int i = 2; i < n; i++) {\n\t\t\t\tif (n % i == 0) {\n\t\t\t\t\tn /= i;\n\t\t\t\t\tnum++;\n\t\t\t\t\tif (n % i == 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn num % 2 == 0 ? -1 : 1;\n\t\t}\n\t}\n\n\t/**\n\t * 組み合わせ計算を階乗の値で行うクラスです(MOD対応)\n\t * 階乗とその逆元は前計算してテーブルに格納します。\n\t * C(N, N) % M の計算量は O(1)、 前計算でO(max(N, logM))です。\n\t * sizeを1e8より大きい値で実行するとMLEの危険性があります。\n\t * また素数以外のMODには対応していません(逆元の計算に素数の剰余環の性質を利用しているため)。\n\t */\n\tclass FactorialTableCombCalculator implements CombCalculator {\n\t\tint size;\n\t\tlong[] factorialTable;\n\t\tlong[] inverseFactorialTable;\n\t\tlong mod;\n\n\t\tpublic FactorialTableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\tfactorialTable = new long[size + 1];\n\t\t\tinverseFactorialTable = new long[size + 1];\n\t\t\tthis.mod = mod;\n\n\t\t\tfactorialTable[0] = 1L;\n\t\t\tfor (int i = 1; i <= size; i++) {\n\t\t\t\tfactorialTable[i] = (factorialTable[i - 1] * i) % mod;\n\t\t\t}\n\t\t\tinverseFactorialTable[size] = inverse(factorialTable[size], mod);\n\t\t\tfor (int i = size - 1; i >= 0; i--) {\n\t\t\t\tinverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n\t\t\t}\n\t\t}\n\n\t\tprivate long inverse(long n, long mod) {\n\t\t\treturn pow(n, mod - 2, mod);\n\t\t}\n\n\t\tprivate long pow(long n, long p, long mod) {\n\t\t\tif (p == 0) {\n\t\t\t\treturn 1L;\n\t\t\t}\n\t\t\tlong half = pow(n, p / 2, mod);\n\t\t\tlong ret = (half * half) % mod;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tret = (ret * n) % mod;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn (((factorialTable[n] * inverseFactorialTable[m]) % mod) * inverseFactorialTable[n - m]) % mod;\n\t\t}\n\t}\n\n\t/**\n\t * 組み合わせ計算をテーブルで実装したクラスです(MOD対応)\n\t * 前計算でO(N^2), combはO(1)で実行できます\n\t * sizeを2 * 1e4より大きい値で実行するとMLEの危険性があります\n\t */\n\tclass TableCombCalculator implements CombCalculator {\n\t\tlong[][] table;\n\t\tint size;\n\n\t\tpublic TableCombCalculator(int size, long mod) {\n\t\t\tthis.size = size;\n\t\t\ttable = new long[size + 1][];\n\n\t\t\ttable[0] = new long[1];\n\t\t\ttable[0][0] = 1L;\n\t\t\tfor (int n = 1; n <= size; n++) {\n\t\t\t\ttable[n] = new long[n + 1];\n\t\t\t\ttable[n][0] = 1L;\n\t\t\t\tfor (int m = 1; m < n; m++) {\n\t\t\t\t\ttable[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n\t\t\t\t}\n\t\t\t\ttable[n][n] = 1L;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long comb(int n, int m) {\n\t\t\tif (n > size) {\n\t\t\t\tthrow new RuntimeException(\"n is greater than size.\");\n\t\t\t}\n\t\t\tif (n < 0 || m < 0 || n < m) {\n\t\t\t\treturn 0L;\n\t\t\t}\n\t\t\treturn table[n][m];\n\t\t}\n\t}\n\n\tinterface Graph {\n\t\tvoid link(int from, int to, long cost);\n\t\tOptional<Long> getCost(int from, int to);\n\t\tint getVertexNum();\n\t}\n\n\tinterface FlowResolver {\n\t\tlong maxFlow(int from, int to);\n\t}\n\n\t/**\n\t * グラフの行列による実装\n\t * 接点数の大きいグラフで使うとMLEで死にそう\n\t */\n\tclass ArrayGraph implements Graph {\n\t\tprivate Long[][] costArray;\n\t\tprivate int vertexNum;\n\n\t\tpublic ArrayGraph(int n) {\n\t\t\tcostArray = new Long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tcostArray[i] = new Long[n];\n\t\t\t}\n\t\t\tvertexNum = n;\n\t\t}\n\n\t\t@Override\n\t\tpublic void link(int from, int to, long cost) {\n\t\t\tcostArray[from][to] = new Long(cost);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Long> getCost(int from, int to) {\n\t\t\treturn Optional.ofNullable(costArray[from][to]);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getVertexNum() {\n\t\t\treturn vertexNum;\n\t\t}\n\t}\n\n\t/**\n\t * DFS(深さ優先探索)による実装\n\t * 計算量はO(E*MaxFlow)のはず (E:辺の数, MaxFlow:最大フロー)\n\t */\n\tclass DfsFlowResolver implements FlowResolver {\n\t\tprivate Graph graph;\n\t\tpublic DfsFlowResolver(Graph graph) {\n\t\t\tthis.graph = graph;\n\t\t}\n\n\t\t/**\n\t\t * 最大フロー(最小カット)を求める\n\t\t * @param from 始点(source)のID\n\t\t * @param to 終点(target)のID\n\t\t * @return 最大フロー(最小カット)\n\t\t */\n\t\tpublic long maxFlow(int from, int to) {\n\t\t\tlong sum = 0L;\n\t\t\tlong currentFlow;\n\t\t\tdo {\n\t\t\t\tcurrentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n\t\t\t\tsum += currentFlow;\n\t\t\t} while (currentFlow > 0);\n\t\t\treturn sum;\n\t\t}\n\n\t\t/**\n\t\t * フローの実行 グラフの更新も行う\n\t\t * @param from 現在いる節点のID\n\t\t * @param to 終点(target)のID\n\t\t * @param current_flow ここまでの流量\n\t\t * @param passed 既に通った節点か否かを格納した配列\n\t\t * @return 終点(target)に流した流量/戻りのグラフの流量\n\t\t */\n\t\tprivate long flow(int from, int to, long current_flow, boolean[] passed) {\n\t\t\tpassed[from] = true;\n\t\t\tif (from == to) {\n\t\t\t\treturn current_flow;\n\t\t\t}\n\t\t\tfor (int id = 0; id < graph.getVertexNum(); id++) {\n\t\t\t\tif (passed[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tOptional<Long> cost = graph.getCost(from, id);\n\t\t\t\tif (cost.orElse(0L) > 0) {\n\t\t\t\t\tlong nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n\t\t\t\t\tlong returnFlow = flow(id, to, nextFlow, passed);\n\t\t\t\t\tif (returnFlow > 0) {\n\t\t\t\t\t\tgraph.link(from, id, cost.get() - returnFlow);\n\t\t\t\t\t\tgraph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n\t\t\t\t\t\treturn returnFlow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0L;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexedのBIT配列\n\t */\n\tclass BinaryIndexedTree {\n\t\tprivate long[] array;\n\n\t\tpublic BinaryIndexedTree(int size) {\n\t\t\tthis.array = new long[size + 1];\n\t\t}\n\n\t\t/**\n\t\t * 指定した要素に値を加算する\n\t\t * 計算量はO(logN)\n\t\t * @param index 加算する要素の添字\n\t\t * @param value 加算する量\n\t\t */\n\t\tpublic void add(int index, long value) {\n\t\t\tfor (int i = index; i < array.length; i += (i & -i)) {\n\t\t\t\tarray[i] += value;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 1〜指定した要素までの和を取得する\n\t\t * 計算量はO(logN)\n\t\t * @param index 和の終端となる要素の添字\n\t\t * @return 1〜indexまでの和\n\t\t */\n\t\tpublic long getSum(int index) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i = index; i > 0; i -= (i & -i)) {\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\t/**\n\t * 1-indexedの2次元BIT配列\n\t */\n\tclass BinaryIndexedTree2D {\n\t\tprivate long[][] array;\n\n\t\tpublic BinaryIndexedTree2D(int size1, int size2) {\n\t\t\tthis.array = new long[size1 + 1][];\n\t\t\tfor (int i = 1; i <= size1; i++) {\n\t\t\t\tthis.array[i] = new long[size2 + 1];\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * 指定した要素に値を加算する\n\t\t * 計算量はO(logN * logN)\n\t\t * @param index1 加算する要素の1次元目の添字\n\t\t * @param index2 加算する要素の2次元目の添字\n\t\t * @param value 加算する量\n\t\t */\n\t\tpublic void add(int index1, int index2, long value) {\n\t\t\tfor (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n\t\t\t\t\tarray[i1][i2] += value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * (1,1)〜指定した要素までの矩形和を取得する\n\t\t * 計算量はO(logN * logN)\n\t\t * @param index1 和の終端となる要素の1次元目の添字\n\t\t * @param index2 和の終端となる要素の2次元目の添字\n\t\t * @return (1,1)〜(index1,index2)までの矩形和\n\t\t */\n\t\tpublic long getSum(int index1, int index2) {\n\t\t\tlong sum = 0L;\n\t\t\tfor (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n\t\t\t\tfor (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n\t\t\t\t\tsum += array[i1][i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\n\tinterface UnionFind {\n\t\tvoid union(int A, int B);\n\t\tboolean judge(int A, int B);\n\t\tSet<Integer> getSet(int id);\n\t}\n\n\t/**\n\t * ArrayUnionFindの拡張\n\t * MapSetで根の添字から根にぶら下がる頂点の集合が取得できるようにした\n\t * getSetメソッドをO(logN * logN)に落とせているはず\n\t * ただしunionメソッドは2倍の計算量になっているので注意(オーダーは変わらないはず)\n\t */\n\tclass SetUnionFind extends ArrayUnionFind {\n\t\tMap<Integer, Set<Integer>> map;\n\t\tpublic SetUnionFind(int size) {\n\t\t\tsuper(size);\n\t\t\tmap = new HashMap<>();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tmap.put(i, new HashSet<>());\n\t\t\t\tmap.get(i).add(i);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tsuper.unionTo(source, dest);\n\t\t\tmap.get(dest).addAll(map.get(source));\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\treturn map.get(root(id));\n\t\t}\n\t}\n\n\t/**\n\t * 配列によるUnionFindの実装\n\t * getSetメソッドはO(NlogN)なのでTLEに注意\n\t */\n\tclass ArrayUnionFind implements UnionFind {\n\t\tint[] parent;\n\t\tint[] rank;\n\t\tint size;\n\t\tpublic ArrayUnionFind(int size) {\n\t\t\tparent = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t\trank = new int[size];\n\t\t\tthis.size = size;\n\t\t}\n\n\t\t@Override\n\t\tpublic void union(int A, int B) {\n\t\t\tint rootA = root(A);\n\t\t\tint rootB = root(B);\n\t\t\tif (rootA != rootB) {\n\t\t\t\tif (rank[rootA] < rank[rootB]) {\n\t\t\t\t\tunionTo(rootA, rootB);\n\t\t\t\t} else {\n\t\t\t\t\tunionTo(rootB, rootA);\n\t\t\t\t\tif (rank[rootA] == rank[rootB]) {\n\t\t\t\t\t\trank[rootA]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprotected void unionTo(int source, int dest) {\n\t\t\tparent[source] = dest;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean judge(int A, int B) {\n\t\t\treturn root(A) == root(B);\n\t\t}\n\n\t\t@Override\n\t\tpublic Set<Integer> getSet(int id) {\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tIntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n\t\t\treturn set;\n\t\t}\n\n\t\tprotected int root(int id) {\n\t\t\tif (parent[id] == id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\tparent[id] = root(parent[id]);\n\t\t\treturn parent[id];\n\t\t}\n\t}\n\n\t/**\n\t * 素数のユーティリティ\n\t */\n\tclass PrimeNumberUtils {\n\t\tboolean[] isPrimeArray;\n\t\tList<Integer> primes;\n\n\t\t/**\n\t\t * 素数判定の上限となる値を指定してユーティリティを初期化\n\t\t * @param limit 素数判定の上限(この値以上が素数であるか判定しない)\n\t\t */\n\t\tpublic PrimeNumberUtils(int limit) {\n\t\t\tif (limit > 10000000) {\n\t\t\t\tSystem.err.println(\"上限の値が高すぎるため素数ユーティリティの初期化でTLEする可能性が大変高いです\");\n\t\t\t}\n\t\t\tprimes = new ArrayList<>();\n\t\t\tisPrimeArray = new boolean[limit];\n\t\t\tif (limit > 2) {\n\t\t\t\tprimes.add(2);\n\t\t\t\tisPrimeArray[2] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 3; i < limit; i += 2) {\n\t\t\t\tif (isPrime(i, primes)) {\n\t\t\t\t\tprimes.add(i);\n\t\t\t\t\tisPrimeArray[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Integer> getPrimeNumberList() {\n\t\t\treturn primes;\n\t\t}\n\n\t\tpublic boolean isPrime(int n) {\n\t\t\treturn isPrimeArray[n];\n\t\t}\n\n\t\tprivate boolean isPrime(int n, List<Integer> primes) {\n\t\t\tfor (int prime : primes) {\n\t\t\t\tif (n % prime == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (prime > Math.sqrt(n)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tinterface BitSet {\n\t\tvoid set(int index, boolean bit);\n\t\tboolean get(int index);\n\t\tvoid shiftRight(int num);\n\t\tvoid shiftLeft(int num);\n\t\tvoid or(BitSet bitset);\n\t\tvoid and(BitSet bitset);\n\t}\n\n\t/**\n\t * Longの配列によるBitSetの実装\n\t * get/setはO(1)\n\t * shift/or/andはO(size / 64)\n\t */\n\tclass LongBit implements BitSet {\n\t\tlong[] bitArray;\n\n\t\tpublic LongBit(int size) {\n\t\t\tbitArray = new long[((size + 63) / 64)];\n\t\t}\n\n\t\tpublic long getOne() {\n\t\t\tlong sum = 0L;\n\t\t\tfor (long bit : bitArray) {\n\t\t\t\tsum += Long.bitCount(bit);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\n\t\t@Override\n\t\tpublic void set(int index, boolean bit) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\tif (bit) {\n\t\t\t\tbitArray[segment] |= 1L << inIndex;\n\t\t\t} else {\n\t\t\t\tbitArray[segment] &= ~(1L << inIndex);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean get(int index) {\n\t\t\tint segment = index / 64;\n\t\t\tint inIndex = index % 64;\n\t\t\treturn (bitArray[segment] & (1L << inIndex)) != 0L;\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftRight(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tint sourceSeg = segment + shiftSeg;\n\t\t\t\tif (sourceSeg < bitArray.length) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void shiftLeft(int num) {\n\t\t\tint shiftSeg = num / 64;\n\t\t\tint shiftInI = num % 64;\n\t\t\tfor (int segment = bitArray.length - 1; segment >= 0; segment--) {\n\t\t\t\tint sourceSeg = segment - shiftSeg;\n\t\t\t\tif (sourceSeg >= 0) {\n\t\t\t\t\tbitArray[segment] = bitArray[sourceSeg] << shiftInI;\n\t\t\t\t\tif (shiftInI > 0 && sourceSeg > 0) {\n\t\t\t\t\t\tbitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbitArray[segment] = 0L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic long getLong(int segment) {\n\t\t\treturn bitArray[segment];\n\t\t}\n\n\t\t@Override\n\t\tpublic void or(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] |= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void and(BitSet bitset) {\n\t\t\tif (!(bitset instanceof LongBit)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (int segment = 0; segment < bitArray.length; segment++) {\n\t\t\t\tbitArray[segment] &= ((LongBit)bitset).getLong(segment);\n\t\t\t}\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\n\n\nclass Main{\n\tstatic long ans=0;\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\tint N=sc.nextInt();\n\t\tint K=sc.nextInt();\n\t\tlong[][] dp=new long[N+1][K+1];\n\t\tlong MOD=1000000007;\n\t\tfor(int i=0; i<=N; i++) {\n\t\t\tfor(int j=0; j<=K; j++) {\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=1;\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tfor(int j=1; j<=K; j++) {\n\t\t\t\tdp[i][j]+=dp[i-1][j]*j;\t//j個の箱の中にi-1個のボールが入っていてi個目のボールを入れる\t新しく入れるボールはi種類（ボール1を、ボール2をボール３を。。。ボールiを）\n\t\t\t\tdp[i][j]+=dp[i-1][j-1]*j;\t//i-1個のボールがj-1個の箱に入っている状態で、i個目のボールは新しい箱に入れる場合　は i通り\n\t\t\t\tdp[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t\tpl(dp[N][K]);\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int K = cin.nextint;\n        var ncr = new BinomialCoefficient(N + K);\n        // 包除原理\n        ModInt ans = 0;\n        for (int i = 1; i <= K; i++)\n        {\n            int z = (K - i) % 2 == 1 ? -1 : 1;\n            ans += z * ncr[K, i] * ModInt.Pow(i, N);\n        }\n        WriteLine(ans);\n    }\n\n}\n\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\n/// <OriginalAuthor>camypaper</OriginalAuthor>\nstruct ModInt\n{\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k)\n    {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n\nclass BinomialCoefficient\n{\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n)\n    {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r]\n    {\n        get\n        {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tstring[] input = Console.ReadLine().Split(' ');//Splitで区切り文字を指定して複数個受け取る。\n\t\tlong n = long.Parse(input[0]);\n\t\tlong k = long.Parse(input[1]);\n    long p = 1000000007;\n    long answer = 0;\n\n    if(k > n) answer = 0;\n    else\n    {\n      answer = DivideMod(n-1,k,p);\n      if(k % 2 == 0) answer--;\n      else answer++;\n\n      answer += p;\n      answer %= p;\n    }\n\n\t\tConsole.WriteLine(answer);//WriteLineをWriteとすると、改行なしで出力。\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n  \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using static Modulo;\nusing static System.Math;\nusing System;\n\nclass Modulo\n{\n    public const int MOD = 1000000007;\n    private readonly int[] m_facs;\n    public int Mul(int a, int b) => (int)(BigMul(a, b) % MOD);\n    public Modulo(int n)\n    {\n        m_facs = new int[n + 1];\n        m_facs[0] = 1;\n        for (int i = 1; i <= n; ++i)\n            m_facs[i] = Mul(m_facs[i - 1], i);\n    }\n    public int Fac(int n) => m_facs[n];\n    public int Pow(int a, int m)\n    {\n        switch (m)\n        {\n            case 0:\n                return 1;\n            case 1:\n                return a;\n            default:\n                int p1 = Pow(a, m / 2);\n                int p2 = Mul(p1, p1);\n                return ((m % 2) == 0) ? p2 : Mul(p2, a);\n        }\n    }\n    public int Div(int a, int b) => Mul(a, Pow(b, MOD - 2));\n    public int Ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        if (n == r) return 1;\n        int res = Fac(n);\n        res = Div(res, Fac(r));\n        res = Div(res, Fac(n - r));\n        return res;\n    }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var k = int.Parse(line[1]);\n        if (n < k) { Console.WriteLine(0); goto exit; }\n        var md = new Modulo(n);\n        var ans = (long)md.Pow(k, n);\n        for (int i = 1; i <= n - 1; i++)\n        {\n            var w = (long)md.Ncr(k, i);\n            w *= md.Pow(k - i, n);\n            w %= MOD;\n            if (i % 2 == 1) { ans -= w; if (ans < 0) ans += MOD; ans %= MOD; }\n            else { ans += w; ans %= MOD; }\n        }\n        Console.WriteLine(ans);\n        exit:;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic long factMax = 200000;//nCkにおけるnの最大値\nstatic long[] factorials = new long[factMax+1];//i!(mod p)をO(n)で先にメモ。\nstatic long[] factorialRs = new long[factMax+1];//i!^-1(mod p), pは素数でO(n)。\n\n\tstatic void Main()\n\t{\n    string[] input = Console.ReadLine().Split(' ');\n    long n = long.Parse(input[0]);\n    long m = long.Parse(input[1]);\n    long p = 1000000007;\n  \n    factorials[0] = 1;\n    factorialRs[factMax] = DivideModFactorial(factMax,p);\n    for(long i = 1; i <= factMax; i++)\n    {\n      factorials[i] = (factorials[i-1]*i)%p;//i!(mod p)\n      factorialRs[factMax-i] = (factorialRs[factMax+1-i]*(factMax+1-i))%p;//逆元も先にメモ\n    }\n\n    Console.WriteLine(BallBoxDistinction(n,m,p));\n\t}\n\n  static long BallBoxDistinction(long n, long m, long mod)\n  {//区別するn個の玉をm個の箱に少なくとも1個入れる方法の個数(mod)をO(mlogn)で返す。\n  //求める方法は、m^n通りから、(一番左の箱に1個もいれない)または…で包除原理。\n    long answer = DivideMod(m,n,mod);\n\n    for(int i = 1; i <= m; i++)\n    {\n      if(i % 2 == 1)\n      {\n        answer -= Comb(m,i,mod)*DivideMod(m-i,n,mod);\n      }else\n      {\n        answer += Comb(m,i,mod)*DivideMod(m-i,n,mod);\n      }\n      answer %= mod;\n      if(answer < 0) answer += mod;\n    }\n\n    return answer;\n  }\n\n  static long MathPow(long x, long a)//戻り値はx^a。O(loga)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x;\n  \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n      }\n    memo *= memo;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)。O(loga)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  static long DivideModReverse(long x, long p)//戻り値はx^-1(mod p), pは素数。O(logp)\n  {\n    long answer = DivideMod(x, p-2, p);\n    return answer;\n  }\n\n  static long ModFactorial(long x, long p)//戻り値はx!(mod p)\n  {\n    long answer = 1;\n    for(int i = 2; i <= x; i++)\n    {\n      answer *= i;\n      answer %= p;\n    }\n    return answer;\n  }\n\n  static long DivideModFactorial(long x, long p)//戻り値はx!^-1(mod p), pは素数\n  {\n    long answer = 1;\n    for(long i = x; i >= 2; i--)\n    {\n      answer *= DivideModReverse(i, p);\n      answer %= p;\n    }\n    return answer;\n  }\n\n  static long Comb(long a, long b, long p)//組み合わせC(a,b)(mod p)をO(1)で返す\n  {\n    if(a-b < 0) return 0;//引数a-bが負なら0を返す\n    long answer = 1;\n    answer *= factorials[a];\n    answer %= p;\n    answer *= factorialRs[a-b];\n    answer %= p;\n    answer *= factorialRs[b];\n    answer %= p;\n    return answer;\n  }\n  \n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');//Splitで区切り文字を指定して複数個受け取る。\nstatic long n = long.Parse(input[0]);\nstatic long k = long.Parse(input[1]);\nstatic long p = 1000000007;\nstatic long answer = 0;\nstatic long[] factorials = new long[n+1];//i!(mod p)を先にメモ\nstatic long[] factorialRs = new long[n+1];//i!^-1(mod p), pは素数\n\n\tstatic void Main()\n\t{\n    factorials[0] = 1;\n    factorialRs[n] = DivideModFactorial(n,p);\n    for(long i = 1; i <= n; i++)\n    {\n      factorials[i] = (factorials[i-1]*i)%p;//i!(mod p)\n      factorialRs[n-i] = (factorialRs[n+1-i]*(n+1-i))%p;//逆元も先にメモ\n    }\n  \n    if(k > n) answer = 0;\n    else\n    {\n      for(long i = 0; i <= k-1; i++)\n      {\n        long memo = Comb(k, i, p) * DivideMod(k-i, n, p);\n        if(i % 2 == 0)\n        {\n          answer += memo;\n          answer %= p;\n        }else\n        {\n          answer -= memo;\n          answer %= p;\n          if(answer < 0) answer += p;\n        }\n      }\n    }\n\n\t\tConsole.WriteLine(answer);//WriteLineをWriteとすると、改行なしで出力。\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  static long DivideModReverse(long x, long p)//戻り値はx^-1(mod p), pは素数\n  {\n    long answer = DivideMod(x, p-2, p);\n    return answer;\n  }\n\n  static long DivideModFactorial(long x, long p)//戻り値はx!^-1(mod p), pは素数\n  {\n    long answer = 1;\n    for(long i = x; i >= 2; i--)\n    {\n      answer *= DivideModReverse(i, p);\n      answer %= p;\n    }\n    return answer;\n  }\n\n  static long Comb(long a, long b, long p)//戻り値は組み合わせC(a,b)のmod p\n  {\n    long answer = 1;\n    answer *= factorials[a];\n    answer %= p;\n    answer *= factorialRs[a-b];//引数a-bは負にならないようにする\n    answer %= p;\n    answer *= factorialRs[b];\n    answer %= p;\n    return answer;\n  }\n\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace CsharpSpiral {\n    partial class Program {\n        static void Main(string[] args) {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new ConsoleInput(Console.In, ' '));\n            Console.Out.Flush();\n        }\n        public void Solve(ConsoleInput cin) {\n            var n = cin.ReadInt;\n            var k = cin.ReadInt;\n            const int modulo= 1000000007;\n            var F = new ResidueField(modulo);\n            if(n < k) Console.WriteLine(0);\n            else {\n                var D = new long[n + 1, k + 1];\n                D[1, 1] = 1;\n                for(int i = 1; i <= n; i++) {\n                    D[i, 1] = 1;\n                    for(int j = 2; j < i && j <= k; j++) { \n                        D[i, j] = F.Add(F.Mul(D[i - 1, j], j), D[i - 1, j - 1]);\n                    }\n                    if(i <= k) D[i, i] = 1;\n                }\n                Console.WriteLine(F.Mul(D[n, k], F.Factorial(k)));\n            }\n        }\n        class ResidueField {\n            public readonly long modulo;\n            public ResidueField(long mModulo) {\n                modulo = mModulo;\n            }\n            private long[] factorialTable = { 1 };\n            private int factorialTableLastIndex { get { return factorialTable.Length - 1; } }\n            public long mod(long x) => x < 0 ? x % modulo + modulo : x % modulo;\n            public long Add(long a, long b) => mod(a + b);\n            public long Sub(long a, long b) => mod(a - b);\n            public long Mul(long a, long b) => mod(a * b);\n            public long Pow(long a, long n) {\n                if(n == 0) return 1;\n                var R = 1L;\n                n = n < 0 ? n % (modulo - 1) + (modulo - 1) : n % (modulo - 1);\n                for(; n > 0; a = Mul(a, a), n >>= 1) {\n                    if((n & 1) != 0) R = Mul(R, a);\n                }\n                return R;\n            }\n            private static long extgcd(long a, long b, ref long x, ref long y) {\n                if(b == 0) {\n                    x = 1; y = 0; return a;\n                }\n                var q = a / b;\n                var g = extgcd(b, a - q * b, ref x, ref y);\n                var z = x - q * y;\n                x = y; y = z;\n                return g;\n            }\n            public long Inv(long a) {\n                if(a == 0) throw new DivideByZeroException();\n                long x = 0, y = 0;\n                extgcd(a, modulo, ref x, ref y);\n                return mod(x);\n            }\n            public long Div(long a, long b) => Mul(a, Inv(b));\n            public void ExpandFactorialTable(int N) {\n                var k = factorialTableLastIndex;\n                Array.Resize(ref factorialTable, N + 1);\n                for(int i = k + 1; i <= N; i++) {\n                    if(i == 0) { factorialTable[i] = 1; continue; }\n                    factorialTable[i] = Mul(factorialTable[i - 1], i);\n                }\n            }\n            public long Factorial(int n) {\n                if(n > factorialTableLastIndex)\n                    ExpandFactorialTable(n);\n                return factorialTable[n];\n            }\n            public long Permutation(int n, int k) {\n                if(k < 0 || k > n) throw new InvalidOperationException();\n                return Div(Factorial(n), Factorial(n - k));\n            }\n            public long Combination(int n, int k) {\n                if(k < 0 || k > n) throw new InvalidOperationException();\n                return Div(Factorial(n), Mul(Factorial(k), Factorial(n - k)));\n            }\n        }\n    }\n\n    static class ExtendClass {\n        public static string Join<T>(this T[] X, string separator = \" \") => string.Join(separator, X);\n    }\n\n    class ConsoleInput {\n        private readonly TextReader _stream;\n        private readonly char _separator = ' ';\n        private readonly Queue<string> inputStream;\n        public ConsoleInput(TextReader stream, char separator = ' ') {\n            this._separator = separator;\n            this._stream = stream;\n            inputStream = new Queue<string>();\n        }\n        public string Read {\n            get {\n                if(inputStream.Count != 0) return inputStream.Dequeue();\n                string[] tmp = _stream.ReadLine().Split(_separator);\n                for(int i = 0; i < tmp.Length; ++i)\n                    inputStream.Enqueue(tmp[i]);\n                return inputStream.Dequeue();\n            }\n        }\n        public string ReadLine { get { return _stream.ReadLine(); } }\n        public int ReadInt { get { return int.Parse(Read); } }\n        public long ReadLong { get { return long.Parse(Read); } }\n        public double ReadDouble { get { return double.Parse(Read); } }\n        public string[] ReadStrArray(long N) {\n            var ret = new string[N];\n            for(long i = 0; i < N; ++i)\n                ret[i] = Read;\n            return ret;\n        }\n        public int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n        public long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n        public double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n    }\n\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "St2=[[1],[0,1]]\n2.upto(1000){|n|St2<<[0,*St2[-1].each_cons(2).map.with_index(1){|(x,y),k|x+y*k},1]}\na,b=gets.split.map &:to_i\np (1..b).reduce(:*)*St2[a][b].to_i%(10**9+7)\n"
  },
  {
    "language": "Ruby",
    "code": "n,k=gets.split.map &:to_i\nf=[1]\n(1..1000).map{|i|f<<f[-1]*i}\nc=->a,b{f[a]/f[b]/f[a-b]}\ns=0\n1.upto(k){|i|s=(s+(1-(k-i)%2*2)*c[k,i]%(10**9+7)*i**n%(10**9+7))%(10**9+7)}\np s\n\n"
  },
  {
    "language": "Ruby",
    "code": "MOD = 1_000_000_007\n\nFACT = [1]\n(1..1000).each do |k|\n  FACT << FACT[-1] * k % MOD\nend\n\ndef exp(n, k)\n  x = 1\n  r = n\n  while k > 0\n    x *= r if k & 1 == 1\n    r *= r\n    x %= MOD\n    r %= MOD\n    k >>= 1\n  end\n  x\nend\n\ndef inv(n)\n  exp(n, MOD - 2)\nend\n\ndef perm(n, k)\n  n >= k ? FACT[n] * inv(FACT[n - k]) % MOD : 0\nend\n\ndef comb(n, k)\n  perm(n, k) * inv(FACT[k]) % MOD\nend\n\nn, k = gets.split.map(&:to_i)\nanswer = 0\n(0..k-1).each do |t|\n  answer = (answer + (-1) ** t * comb(k, t) % MOD * exp(k - t, n)) % MOD\nend\np answer\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\nfunc getStirlingType2(n, k, p int) [][]int {\n\ttable := make([][]int, n+1)\n\ttable[1] = make([]int, k+1)\n\ttable[1][1] = 1\n\tfor i := 2; i <= n; i++ {\n\t\ttable[i] = make([]int, k+1)\n\t\tfor j := 1; j <= k; j++ {\n\t\t\ttable[i][j] = (table[i-1][j-1] + j*table[i-1][j]) % p\n\t\t}\n\t}\n\treturn table\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tprime := 1000000000 + 7\n\n\tnBalls := nextInt()\n\tnBoxes := nextInt()\n\n\tif nBalls < nBoxes {\n\t\tfmt.Println(0)\n\t} else {\n\t\ttable := getStirlingType2(nBalls, nBoxes, prime)\n\t\tnCombinations := table[nBalls][nBoxes]\n\t\tfor i := 1; i <= nBoxes; i++ {\n\t\t\tnCombinations = (nCombinations * i) % prime\n\t\t}\n\t\tfmt.Println(nCombinations)\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\tk := getNextInt(scanner)\n\tdp := makeGrid(n+1, k+1)\n\tdp[0][0] = 1\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 0; j < k; j++ {\n\t\t\tdp[i+1][j+1].addAs(dp[i][j].mul(mint(k - j)))\n\t\t\tdp[i+1][j+1].addAs(dp[i][j+1].mul(mint(j + 1)))\n\t\t}\n\t}\n\tfmt.Fprintln(writer, dp[n][k])\n}\n\nfunc makeGrid(h, w int) [][]mint {\n\tindex := make([][]mint, h, h)\n\tdata := make([]mint, h*w, h*w)\n\tfor i := 0; i < h; i++ {\n\t\tindex[i] = data[i*w : (i+1)*w]\n\t}\n\treturn index\n}\n\ntype mint int64\n\nfunc (mt mint) mod() mint {\n\tm := mint(1e9 + 7)\n\tmt %= m\n\tif mt < 0 {\n\t\treturn mt + m\n\t}\n\treturn mt\n}\nfunc (mt mint) inv() mint {\n\treturn mt.pow(mint(0).sub(2))\n}\nfunc (mt mint) pow(n mint) mint {\n\tp := mint(1)\n\tfor n > 0 {\n\t\tif n%2 == 1 {\n\t\t\tp.mulAs(mt)\n\t\t}\n\t\tmt.mulAs(mt)\n\t\tn >>= 1\n\t}\n\treturn p\n}\nfunc (mt mint) add(x mint) mint {\n\treturn (mt + x).mod()\n}\nfunc (mt mint) sub(x mint) mint {\n\treturn (mt - x).mod()\n}\nfunc (mt mint) mul(x mint) mint {\n\treturn (mt * x).mod()\n}\nfunc (mt mint) div(x mint) mint {\n\treturn mt.mul(x.inv())\n}\nfunc (mt *mint) addAs(x mint) *mint {\n\t*mt = mt.add(x)\n\treturn mt\n}\nfunc (mt *mint) subAs(x mint) *mint {\n\t*mt = mt.sub(x)\n\treturn mt\n}\nfunc (mt *mint) mulAs(x mint) *mint {\n\t*mt = mt.mul(x)\n\treturn mt\n}\nfunc (mt *mint) divAs(x mint) *mint {\n\t*mt = mt.div(x)\n\treturn mt\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric, std.container;\n\nlong P = 10^^9+7;\nlong[1001] F, RF;\n\nlong pow(long x, long n) {\n    long y = 1;\n    while (n) {\n        if (n%2 == 1) y = (y * x) % P;\n        x = x^^2 % P;\n        n /= 2;\n    }\n    return y;\n}\n\nlong inv(long x)\n{\n    return pow(x, P-2);\n}\n\nvoid init()\n{\n    F[0] = F[1] = 1;\n    foreach (i, ref x; F[2..$]) x = (F[i+1] * (i+2)) % P;\n\n    {\n        RF[$-1] = 1;\n        auto x = F[$-1];\n        auto k = P-2;\n        while (k) {\n            if (k%2 == 1) RF[$-1] = (RF[$-1] * x) % P;\n            x = x^^2 % P;\n            k /= 2;\n        }\n    }\n    foreach_reverse(i, ref x; RF[0..$-1]) x = (RF[i+1] * (i+1)) % P;\n}\n\nlong comb(N)(N n, N k)\n{\n    if (k > n) return 0;\n    auto n_b = F[n];    // n!\n    auto nk_b = RF[n-k]; // 1 / (n-k)!\n    auto k_b = RF[k];    // 1 / k!\n\n    auto nk_b_k_b = (nk_b * k_b) % P; // 1 / (n-k)!k!\n\n    return (n_b * nk_b_k_b) % P;  // n! / (n-k)!k!\n}\n\nlong perm(N)(N n, N k)\n{\n    if (k > n) return 0;\n    auto n_b = F[n];\n    auto n_k_b = RF[n-k];\n    return (n_b * n_k_b) % P;\n}\n\nvoid main()\n{\n    init();\n    auto nk = readln.split.to!(long[]);\n    auto N = nk[0];\n    auto K = nk[1];\n    if (K > N) {\n        writeln(0);\n        return;\n    }\n    long r;\n    foreach (e; 0..K) {\n        (r += comb(K, e) * pow(K-e, N) % P * (-1)^^e + P) %= P;\n    }\n    writeln(r);\n}\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\ndef combination(i: int, j: int) -> int:\n    return math.factorial(i) // math.factorial(i - j) // math.factorial(j)\n\n\nif __name__ == \"__main__\":\n    n, k = map(lambda x: int(x), input().split())\n    modulo = 10 ** 9 + 7\n    ans = 0\n    if k <= n:\n        for i in range(k):\n            if 0 == i % 2:\n                ans += (k - i) ** n * combination(k, i)\n            else:\n                ans -= (k - i) ** n * combination(k, i)\n        ans = ans % modulo\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "class Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C と同じ\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def C(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def P(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[n-r] % self.mod\n\n    def H(self, n, r):\n        if n == 0 and r > 0: return 0\n        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod\n\n    def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)\n        return self.fac[n+r-1] * self.facinv[n-1] % self.mod\n\n    def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数\n        if n == k: return 1\n        if k == 0: return 0\n        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod\n\n    def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数\n        if n == k: return 1  # n==k==0 のときのため\n        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))\n        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))\n        if n == 0: return 1\n        if n % 2 and n >= 3: return 0  # 高速化\n        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n    def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k\n        # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))\n        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod\n\n    def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)\n        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n    def bell(self, n, k):  # n 要素を k 個以下に分割する場合の数  O(k**2 + k*log(mod))\n        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod\n\nmod = 10**9+7\ncomb = Combination(2000)\nn, k = map(int, input().split())\nprint(comb.balls_and_boxes_3(n, k))\n\n"
  },
  {
    "language": "Python",
    "code": "class Combination:\n    \"\"\"階乗とその逆元のテーブルをO(N)で事前作成し、組み合わせの計算をO(1)で行う\"\"\"\n    def __init__(self, n, MOD):\n        self.fact = [1]\n        for i in range(1, n + 1):\n            self.fact.append(self.fact[-1] * i % MOD)\n        self.inv_fact = [0] * (n + 1)\n        self.inv_fact[n] = pow(self.fact[n], MOD - 2, MOD)\n        for i in reversed(range(n)):\n            self.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % MOD\n        self.MOD = MOD\n\n    def factorial(self, k):\n        \"\"\"k!を求める O(1)\"\"\"\n        return self.fact[k]\n\n    def inverse_factorial(self, k):\n        \"\"\"k!の逆元を求める O(1)\"\"\"\n        return self.inv_fact[k]\n\n    def permutation(self, k, r):\n        \"\"\"kPrを求める O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r]) % self.MOD\n\n    def combination(self, k, r):\n        \"\"\"kCrを求める O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r]) % self.MOD\n\n\ndef way3(ball, box):\n    \"\"\"ball: True / box: True / constraints: 1 or more\n    -> ans = (包除原理)\n    \"\"\"\n    if ball < box:\n        return 0\n    ans = 0\n    for i in range(box + 1):\n        ans += pow(-1, i, MOD) * comb.combination(box, i) * pow(box - i, ball, MOD)\n        ans %= MOD\n    return ans\n\n\nn, k = map(int, input().split())\nMOD = 10 ** 9 + 7\ncomb = Combination(10 ** 4, MOD)\n\nprint(way3(n, k))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nEPS = 10 ** -10\n\nclass ModTools:\n    \"\"\" 階乗・逆元用のテーブルを構築する \"\"\"\n\n    def __init__(self, MAX, MOD):\n        \n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        inverse = [1] * MAX\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, -1, -1):\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n    \n    def nCr(self, n, r):\n        \"\"\" 組み合わせ \"\"\"\n\n        if n < r: return 0\n        r = min(r, n-r)\n        numerator = self.fact[n]\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\n    def nHr(self, n, r):\n        \"\"\" 重複組み合わせ \"\"\"\n\n        return self.nCr(r+n-1, r)\n\n    def nPr(self, n, r):\n        \"\"\" 順列 \"\"\"\n\n        if n < r: return 0\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n    def div(self, x, y):\n        \"\"\" MOD除算 \"\"\"\n\n        return x * pow(y, self.MOD-2, self.MOD) % self.MOD\n\nN, K = MAP()\n\nmt = ModTools(max(N, K)+1, MOD)\nans = 0\nfor i in range(K+1):\n    if i % 2 == 0:\n        ans += mt.nCr(K, i) * pow(K-i, N, MOD) % MOD\n    else:\n        ans -= mt.nCr(K, i) * pow(K-i, N, MOD) % MOD\nprint(ans%MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nMOD = 10 ** 9 + 7\nn, k = map(int, raw_input().split())\n\ndef fact(N):\n    if N <= 1:\n        return 1\n    return fact(N - 1) * N\n\ndef pow(N):\n    ret = 1\n    for i in range(n):\n        ret *= N\n        ret %= MOD\n    return ret\n\nC = 0\nfor i in range(k - 1, 0, -1):\n    num = fact(k) / fact(i) / fact(k - i) * pow(i)\n    if (i - k) % 2 == 1:\n        num *= -1\n    C += num\nprint (pow(k) + C) % MOD\n"
  },
  {
    "language": "Python",
    "code": "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef prepare(n, MOD):\n    # 1! - n! の計算\n    f = 1\n    factorials = [1]  # 0!の分\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 の計算\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 の計算\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef main():\n    n, k = ns()\n\n    # 使い方\n    facts, invs = prepare(k, MOD)\n\n    ans = 0\n    for i in range(k):\n        tmp = pow(k - i, n, MOD) * (facts[k] * invs[i] * invs[k - i] % MOD)\n        tmp %= MOD\n        if i % 2:\n            ans -= tmp\n        else:\n            ans += tmp\n        ans %= MOD\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\nmemo = {0:1}\ndef fact(x):\n  if x in memo:\n    return memo[x]\n  memo[x] = x * fact(x - 1)\n  return memo[x]\n\ndef comb(x, y):\n  return fact(x) // fact(x - y) // fact(y)\n\nn, k = map(int, input().split())\nif n < k:print(0)\nelse:\n  ans = 0\n  for i in range(k):\n    #print(ans)\n    ans += (k - i) ** n * comb(k, i) * (-1) ** i\n  print(ans % 1000000007)\n"
  },
  {
    "language": "Python",
    "code": "MOD = 1000000007\nclass ModInt:\n    def __init__(self, x):\n        self.x = x % MOD\n\n    def __str__(self):\n        return str(self.x)\n    def __int__(self):\n        return self.x\n\n    __repr__ = __str__\n\n    def __add__(self, other):\n        return (\n            ModInt(self.x + other.x) if isinstance(other, ModInt) else\n            ModInt(self.x + other)\n        )\n\n    def __sub__(self, other):\n        return (\n            ModInt(self.x - other.x) if isinstance(other, ModInt) else\n            ModInt(self.x - other)\n        )\n\n    def __mul__(self, other):\n        return (\n            ModInt(self.x * other.x) if isinstance(other, ModInt) else\n            ModInt(self.x * other)\n        )\n\n    def __truediv__(self, other):\n        return (\n            ModInt(\n                self.x * pow(other.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(self.x * pow(other, MOD - 2, MOD))\n        )\n\n    def __mod__(self, other):\n        return (\n            ModInt(\n                other.x\n            ) if isinstance(other, ModInt) else\n            self.x\n        )\n\n    def __pow__(self, other):\n        return (\n            ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else\n            ModInt(pow(self.x, other, MOD))\n        )\n\n    __radd__ = __add__\n\n    def __rsub__(self, other):\n        return (\n            ModInt(other.x - self.x) if isinstance(other, ModInt) else\n            ModInt(other - self.x)\n        )\n\n    __rmul__ = __mul__\n\n    def __rtruediv__(self, other):\n        return (\n            ModInt(\n                other.x * pow(self.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(other * pow(self.x, MOD - 2, MOD))\n        )\n\n    def __rpow__(self, other):\n        return (\n            ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else\n            ModInt(pow(other, self.x, MOD))\n        )\n    \n    def __iadd__(self,other):\n        self.x += other.x if isinstance(other, ModInt) else other\n        self.x %= MOD\n        return self\n\n    def __isub__(self,other):\n        self.x += ModInt(MOD - other.x) if isinstance(other, ModInt) else ModInt(MOD - other)\n        return self\n\n    def __imul__(self, other):\n        self.x *= other.x if isinstance(other, ModInt) else other\n        self.x %= MOD\n        return self\n    \n    def __ifloordiv__(self, other):\n        self.x *= pow(int(other), MOD - 2, MOD)\n        return self\n    \n    def factorical(self,n):\n        tmp = ModInt(1)\n        for i in range(n):\n            tmp *= (i+1)\n        return tmp\n    \n    #m:int MOD\n    def modinv(self,a,m=MOD):\n        b = m\n        u = 1\n        v = 0\n        while(b):\n            t = a//b\n            a -= t * b\n            a,b = b,a\n            u -= t * v\n            u,v = v,u\n        return ModInt(u)\n\n    def comb(self,n,r):\n        n = int(n)\n        r = int(r)\n        if r > n or n < 0 or r < 0:\n            return 0\n        m = n+1\n        nterms = min(r, n-r)\n        numerator = ModInt(1)\n        denominator = ModInt(1)\n        for j in range(1, nterms + 1):\n            numerator *= m - j\n            denominator *= j\n        return numerator * self.modinv(denominator.x)\n        \nif __name__ == \"__main__\":\n    n,k = map(int,input().split())\n    if n < k:\n        print(0)\n    else:\n        ans = ModInt(0)\n        v = ModInt(1)\n        for i in range(k):\n            if i%2:\n                ans -= pow(k-i,n,MOD)*v\n            else:\n                ans += pow(k-i,n,MOD)*v\n            v *= k-i\n            v //= i+1\n        print(ans)\n"
  },
  {
    "language": "Python",
    "code": "class Twelvefold(): #n <= 1000程度\n    def __init__(self, n, mod):\n        self.mod = mod\n        self.fct = [0 for _ in range(n + 1)]\n        self.inv = [0 for _ in range(n + 1)]\n        self.stl = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.bel = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.prt = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.fct[0] = 1\n        self.inv[0] = 1\n        self.stl[0][0] = 1\n        self.bel[0][0] = 1\n        for i in range(n):\n            self.fct[i + 1] = self.fct[i] * (i + 1) % mod\n        self.inv[n] = pow(self.fct[n], mod - 2, mod)\n        for i in range(n)[::-1]:\n            self.inv[i] = self.inv[i + 1] * (i + 1) % mod\n        for i in range(n):\n            for j in range(n):\n                self.stl[i + 1][j + 1] = self.stl[i][j] + (j + 1) * self.stl[i][j + 1]\n                self.stl[i + 1][j + 1] %= mod\n        for i in range(n):\n            for j in range(n):\n                self.bel[i + 1][j + 1] = self.bel[i + 1][j] + self.stl[i + 1][j + 1] % mod\n                self.bel[i + 1][j + 1] %= mod\n        for j in range(n):\n            self.prt[0][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if i - j >= 0:\n                    self.prt[i + 1][j + 1] = self.prt[i + 1][j] + self.prt[i - j][j + 1]\n                else:\n                    self.prt[i + 1][j + 1] = self.prt[i + 1][j]\n                self.prt[i + 1][j + 1] %= mod\n\n    def solve(self, element, subset, equate_element=False, equate_subset=False, less_than_1=False, more_than_1=False):\n        assert not less_than_1 or not more_than_1\n        n = element\n        k = subset\n        a = equate_element\n        b = equate_subset\n        c = less_than_1\n        d = more_than_1\n        id = a * 3 + b * 6 + c + d * 2\n        tw = [self.tw1, self.tw2, self.tw3, self.tw4, self.tw5, self.tw6, self.tw7, self.tw8, self.tw9, self.tw10, self.tw11, self.tw12]\n        return tw[id](n, k)\n\n    def tw1(self, n, k):\n        return pow(k, n, self.mod)\n\n    def tw2(self, n, k):\n        if k - n < 0: return 0\n        return self.fct[k] * self.inv[k - n] % self.mod\n\n    def tw3(self, n, k):\n        return self.stl[n][k] * self.fct[k] % self.mod\n\n    def tw4(self, n, k):\n        if k == 0: return 0\n        return self.fct[n + k - 1] * self.inv[n] * self.inv[k - 1] % self.mod\n\n    def tw5(self, n, k):\n        if k - n < 0: return 0\n        return self.fct[k] * self.inv[n] * self.inv[k - n] % self.mod\n\n    def tw6(self, n, k):\n        if n - k < 0 or k == 0: return 0\n        return self.fct[n - 1] * self.inv[k - 1] * self.inv[n - k]\n\n    def tw7(self, n, k):\n        return self.bel[n][k]\n\n    def tw8(self, n, k):\n        if k - n < 0: return 0\n        return 1\n\n    def tw9(self, n, k):\n        return self.stl[n][k]\n\n    def tw10(self, n, k):\n        return self.prt[n][k]\n\n    def tw11(self, n, k):\n        if k - n < 0: return 0\n        return 1\n\n    def tw12(self, n, k):\n        if n - k < 0: return 0\n        return self.prt[n - k][k]\n\nn, k = map(int, input().split())\nt = Twelvefold(1000, 10**9 + 7)\nprint(t.solve(n, k, 0, 0, 0, 1))\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n# 逆元の前計算\nfactorial = [1, 1]\ninverse = [1, 1]\ninvere_base = [0, 1]\nfor i in range(2, K + 1):\n    factorial.append((factorial[-1] * i) % MOD)\n    invere_base.append((-invere_base[MOD % i] * (MOD // i)) % MOD)\n    inverse.append((inverse[-1] * invere_base[-1]) % MOD)\n\n\n# フェルマーの小定理を用いたMOD上Combination\ndef nCr(n, r):\n    if (r < 0 or r > n):\n        return 0\n    r = min(r, n - r)\n    return factorial[n] * inverse[r] * inverse[n - r] % MOD\n\n\n# 包除原理\nans = pow(K, N, MOD)\nfor r in range(1, K + 1):\n    ans -= ((-1) ** ((r % 2) ^ 1)) * nCr(K, r) * pow(K - r, N, MOD) % MOD\n\nprint(ans % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n    \nclass Combinatorics:\n    def __init__(self, N, mod):\n        '''\n        Preprocess for calculating binomial coefficients nCr (0 <= r <= n, 0 <= n <= N)\n        over the finite field Z/(mod)Z.\n        Input:\n            N (int): maximum n\n            mod (int): a prime number. The order of the field Z/(mod)Z over which nCr is calculated.\n        '''\n        self.mod = mod\n        self.fact = {i: None for i in range(N+1)}         # n!\n        self.inverse = {i: None for i in range(1, N+1)}   # inverse of n in the field Z/(MOD)Z\n        self.fact_inverse = {i: None for i in range(N+1)} # inverse of n! in the field Z/(MOD)Z\n        \n        # preprocess\n        self.fact[0] = self.fact[1] = 1\n        self.fact_inverse[0] = self.fact_inverse[1] = 1\n        self.inverse[1] = 1\n        for i in range(2, N+1):\n            self.fact[i] = i * self.fact[i-1] % self.mod\n            q, r = divmod(self.mod, i)\n            self.inverse[i] = (- (q % self.mod) * self.inverse[r]) % self.mod\n            self.fact_inverse[i] = self.inverse[i] * self.fact_inverse[i-1] % self.mod\n    \n    def perm(self, n, r):\n        '''\n        Calculate nPr = n! / (n-r)! % mod\n        '''\n        if n < r or n < 0 or r < 0:\n            return 0\n        else:\n            return (self.fact[n] * self.fact_inverse[n-r]) % self.mod\n    \n    def binom(self, n, r):\n        '''\n        Calculate nCr = n! /(r! (n-r)!) % mod\n        '''\n        if n < r or n < 0 or r < 0:\n            return 0\n        else:\n            return self.fact[n] * (self.fact_inverse[r] * self.fact_inverse[n-r] % self.mod) % self.mod\n        \n    def hom(self, n, r):\n        '''\n        Calculate nHr = {n+r-1}Cr % mod.\n        Assign r objects to one of n classes.\n        Arrangement of r circles and n-1 partitions:\n            o o o | o o | | | o | | | o o | | o\n        '''\n        if n == 0 and r > 0:\n            return 0\n        if n >= 0 and r == 0:\n            return 1\n        return self.binom(n + r - 1, r)\n    \nn, k = map(int, input().split())\nMOD = 10**9 + 7\ncom = Combinatorics(k, MOD)\nans = 0\nfor i in range(k):\n    if i % 2 == 0:\n        ans = (ans + com.binom(k, i) * pow(k - i, n, MOD)) % MOD\n    else:\n        ans = (ans - com.binom(k, i) * pow(k - i, n, MOD)) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!python3\nfrom math import factorial\n\niim = lambda: map(int, input().rstrip().split())\n\ndef resolve():\n    N, K = iim()\n    mod = 10**9 + 7\n    if N < K:\n        print(0)\n        return\n    elif N == K:\n        print(factorial(N) % mod)\n        return\n\n    ans = 0\n    cm = 1\n    for i in range(K):\n        ans += ((-1)**i) * cm * pow(K - i, N, mod)\n        ans %= mod\n        cm = cm * (K - i) // (i + 1)\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "MOD = int(1e9) + 7\nMAXN = 2000\ncomb = [[0 for i in range(MAXN)] for j in range(MAXN)]\n\n# 組み合わせ(1e9+7で割る場合)\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nN = 2000\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, N + 1 ):\n    g1.append( ( g1[-1] * i ) % MOD )\n    inverse.append( ( -inverse[MOD % i] * (MOD//i) ) % MOD )\n    g2.append( (g2[-1] * inverse[-1]) % MOD )\n\nfor i in range(MAXN):\n    for j in range(MAXN):\n        comb[i][j] = cmb(i, j, MOD)\n\nN, K = map(int, input().split())\nans = 0\nfor i in range(1, K+1):\n    rest = K - i\n    val = comb[K][i] * pow(rest, N, MOD) % MOD\n    if i % 2 == 1:\n        ans = (ans + val) % MOD\n    else:\n        ans = (ans - val + MOD) % MOD\nans = (pow(K, N, MOD) - ans + MOD) % MOD\nprint(int(ans))\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#1:combinatorial\n#1_A\n\"\"\"\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\ndp = [float(\"inf\") for i in range(n+1)]\ndp[0] = 0\nfor i in range(n):\n    for j in c:\n        if i+j <= n:\n            dp[i+j] = min(dp[i+j], dp[i]+1)\nprint(dp[n])\n\"\"\"\n#1_B\n\"\"\"\nn,w = map(int,input().split())\nb = [list(map(int, input().split())) for i in range(n)]\ndp = [0 for i in range(w+1)]\nmemo = [[] for i in range(w+1)]\nfor i in range(w):\n    for j in range(n):\n        if i+b[j][1] <= w and j not in memo[i]:\n            if dp[i+b[j][1]] > dp[i]+b[j][0]:\n                continue\n            else:\n                memo[i+b[j][1]] = memo[i]+[j]\n                dp[i+b[j][1]] = dp[i]+b[j][0]\n\nprint(max(dp))\n\"\"\"\n#1_C\n\"\"\"\nn,w = map(int,input().split())\nb = [list(map(int, input().split())) for i in range(n)]\ndp = [0 for i in range(w+1)]\nfor i in range(w):\n    for j in b:\n        if i+j[1] <= w:\n            dp[i+j[1]] = max(dp[i+j[1]], dp[i]+j[0])\nprint(dp[w])\n\"\"\"\n#1_D\n\"\"\"\nimport bisect\n\nn = int(input())\ns = [int(input()) for i in range(n)]\ndp = [float(\"INF\") for i in range(n)]\nfor i in range(n):\n    dp[bisect.bisect_left(dp,s[i])] = s[i]\nprint(bisect.bisect_left(dp,100000000000000))\n\"\"\"\n\n#1_E\n\"\"\"\ns1 = input()\ns2 = input()\nn = len(s1)\nm = len(s2)\ndp = [[0 for j in range(m+1)] for i in range(n+1)]\nfor i in range(n+1):\n    dp[i][0] = i\nfor j in range(m+1):\n    dp[0][j] = j\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        cost = 0 if s1[i-1] == s2[j-1] else 1\n        dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost)\nprint(dp[n][m])\n\"\"\"\n#1_F\n\"\"\"\nimport bisect\n\nn,W = map(int,input().split())\nb = [list(map(int, input().split())) for i in range(n)]\ndp = [float(\"INF\") for i in range(10001)]\ndp[0] = 0\nfor v,w in b:\n    for i in range(10001):\n        if 10000-i+v < 10001:\n            dp[10000-i+v] = min(dp[10000-i+v], dp[10000-i]+w)\nfor i in range(1,10000):\n    dp[10000-i] = min(dp[10000-i], dp[10001-i])\nprint(bisect.bisect_right(dp,W)-1)\n\"\"\"\n\n#1_G\n\"\"\"\nn,W = LI()\ng = LIR(n)\n\"\"\"\n\n#1_H\n\n\n#2:permutaion/path\n#2_A\n\"\"\"\nn,e = LI()\nv = [[] for i in range(n)]\nf = [-1 for i in range(n)]\nfor i in range(e):\n    s,t,d = LI()\n    v[s].append([t,d])\n    if t == 0:\n        f[s] = d\npo = [1 for i in range(n+1)]\nfor i in range(n):\n    po[i+1] = po[i]*2\ndp = [[float(\"inf\") for i in range(po[n])] for j in range(n)]\ndp[0][1] = 0\nfor j in range(po[n]):\n    for x in range(n):\n        if po[x]&j:\n            for y,d in v[x]:\n                if not po[y]&j:\n                    dp[y][j|po[y]] = min(dp[y][j|po[y]],dp[x][j]+d)\nans = float(\"inf\")\nfor i in range(n):\n    if f[i] != -1:\n        ans = min(ans,dp[i][-1]+f[i])\nif ans == float(\"inf\"):\n    print(-1)\nelse:\n    print(ans)\n\"\"\"\n#3:pattern\n\n#3_A\n\"\"\"\nh,w = map(int, input().split())\nc = [list(map(int, input().split())) for i in range(h)]\ndp = [[0 for i in range(w)] for j in range(h)]\nfor i in range(h):\n    dp[i][0] = 1 if c[i][0] == 0 else 0\nfor i in range(w):\n    dp[0][i] = 1 if c[0][i] == 0 else 0\nfor i in range(1,h):\n    for j in range(1,w):\n        if c[i][j] == 0:\n            dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1\nans = 0\nfor i in dp:\n    for j in i:\n        ans = max(ans, j)\nprint(ans**2)\n\"\"\"\n\n#3_B\n\n#4:counting\n#4_A\n\"\"\"\nn,v = LI()\na = LI()\nb = LI()\nc = LI()\nd = LI()\np = defaultdict(int)\nq = defaultdict(int)\nfor i in a:\n    for j in b:\n        if i+j <= v-2:\n            p[i+j] += 1\nfor i in c:\n    for j in d:\n        if i+j <= v-2:\n            q[i+j] += 1\nans = 0\nfor i,j in p.items():\n    ans += j*q[v-i]\nprint(ans)\n\"\"\"\n\n\n#5:Twelvedfold_Way\n\n#5_A\n\"\"\"\nn,k = map(int, input().split())\nans = k\nfor i in range(n-1):\n    ans *= k\n    ans %= 1000000007\nprint(ans)\n\"\"\"\n\n#5_B\n\"\"\"\nimport sys\nsys.setrecursionlimit(10000)\nmemo = [1,1]\ndef fact(a):\n    if len(memo) > a:\n        return memo[a]\n    b = a*fact(a-1)\n    memo.append(b)\n    return b\nn,k = map(int, input().split())\nif n > k:\n    ans = 0\nelse:\n    ans = fact(k)//fact(k-n)\nprint(ans%1000000007)\n\"\"\"\n\n#5_C\ndef comb(a,b):\n    return fac[a]*inv[b]*inv[a-b]%mod\nn,k = LI()\nif n < k:\n    print(0)\n    quit()\nfac = [1 for i in range(k+1)]\nfor i in range(k):\n    fac[i+1] = fac[i]*(i+1)%mod\ninv = [None for i in range(n+1)]\ninv[k] = pow(fac[k],mod-2,mod)\nfor i in range(k)[::-1]:\n    inv[i] = inv[i+1]*(i+1)%mod\nans = 0\nfor i in range(k+1):\n    if i%2:\n        ans -= comb(k,i)*pow(k-i,n,mod)%mod\n    else:\n        ans += comb(k,i)*pow(k-i,n,mod)%mod\n    ans %= mod\nprint(ans)\n#5_D\n\"\"\"\nn,k = map(int, input().split())\nimport sys\nsys.setrecursionlimit(10000)\nmemo = [1,1]\ndef fact(a):\n    if len(memo) > a:\n        return memo[a]\n    b = a*fact(a-1)\n    memo.append(b)\n    return b\nans = fact(n+k-1)//(fact(n)*fact(k-1))%1000000007\nprint(ans)\n\"\"\"\n\n#5_E\n\"\"\"\nimport sys\nsys.setrecursionlimit(10000)\nmemo = [1,1]\ndef fact(a):\n    if len(memo) > a:\n        return memo[a]\n    b = a*fact(a-1)\n    memo.append(b)\n    return b\nn,k = map(int, input().split())\nans = fact(n+k-1)//(fact(n)*fact(k-1))%1000000007\nprint(ans)\n\"\"\"\n#5_F\n\n#5_G\n\n#5_H\n\n#5_I\n\n#5_J\n\n#5_K\n\n#5_L\n\n"
  },
  {
    "language": "Python",
    "code": "N,K=map(int,input().split())\nmod=10**9+7\nans=0\ncmb=K\nfor i in range(1,K+1):\n\tans+=(-1)**(K-i)*cmb*pow(i,N,mod)%mod\n\tans%=mod\n\tcmb=cmb*(K-i)*pow(i+1,mod-2,mod)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n,k=map(int,input().split(\" \"))\nif n<k:\n    print(0)\nelse:\n    a=[1,0]\n    for i in range(n):\n        a=[0]+[a[i-1]+i*a[i] for i in range(1,len(a))]+[0]\n    for i in range(1,k+1):\n        a[k]*=i\n    print(a[k]%(10**9+7))\n"
  },
  {
    "language": "Python",
    "code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9 + 7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef combMod(n, r, p):\n    numer = 1\n    denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n-r+i) % p\n        denom = denom * i % p\n    return numer * pow(denom, p-2, p) % p\n\ndef resolve():\n    n, k = LI()\n\n    if n >= k:\n        ans = 0\n        for i in range(k):\n            ans += (-1) ** i * combMod(k, k - i, MOD) * pow(k - i, n, MOD)\n            ans %= MOD\n    else:\n        ans = 0\n\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nimport sys\n\nmod=1000000007\n\nn,k=[int(i) for i in input().split(\" \")]\n\n\n\nfacts=[1 for i in range(n+k+1)]\n\nfor i in range(1,n+k+1):\n    facts[i]=i*facts[i-1]\n\nif n<k:\n    print(0)\n    sys.exit()\n\ntables=[[-1 for i in range(k+1)] for j in range(n+1)]\n\ndef f(n,k):\n    if k==1:\n        return 1\n\n    elif n==k:\n        return facts[n]%mod\n\n    elif tables[n][k]!=-1:\n            return tables[n][k]\n\n    else:\n        retval=(k*f(n-1,k)+k*f(n-1,k-1))%mod\n        tables[n][k]=retval\n        return retval\n\nprint(f(n,k)%mod)\n\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10**9 + 7\n\nif N < K:\n    print(0)\nelse:\n    ans = 0\n    v = 1\n    for i in range(K):\n        if i % 2:\n            ans -= pow(K-i, N, MOD) * v\n        else:\n            ans += pow(K-i, N, MOD) * v\n        v = v * (K-i) * pow(i+1, MOD-2, MOD) % MOD\n    print(ans % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10**9 + 7\n \nif N < K:\n    print(0)\nelse:\n    ans = 0\n    v = 1\n    for i in range(K):\n        if i % 2:\n            ans -= pow(K-i, N, MOD) * v\n        else:\n            ans += pow(K-i, N, MOD) * v\n        v = v * (K-i) * pow(i+1, MOD-2, MOD) % MOD\n    print(ans % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef comb(n, k):\n    if n < 0 or k < 0 or n < k: return 0\n    return math.factorial(n) // math.factorial(n-k) // math.factorial(k)\n\n\n\nn,k = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nall = 0\n\nfor i in range(k):\n    add = comb(k, i) * ((k-i) ** n) % MOD\n    if i & 1: all = (all - add + MOD) % MOD\n    else: all = (all + add) % MOD\n\nprint(all)\n"
  },
  {
    "language": "Python",
    "code": "from math import factorial\ndef P(n,r):\n    return factorial(n)//factorial(n-r)\ndef C(n,r):\n    return P(n,r)//factorial(r)\ndef calc(n,k):\n    ans = 0\n    for i in range(k):\n        ans += (k-i)**n*C(k,i)*(-1)**i\n    return ans\nn, k = map(int, input().split())\nprint(calc(n,k)%(pow(10,9)+7) if n > k else factorial(n)%(pow(10,9)+7) if n == k else 0 )\n"
  },
  {
    "language": "Python",
    "code": "n, k = map(int, input().split( ))\nmod = 10**9+7\n\ndef chs(s,t,mod):\n    nume =  1\n    for i in range(s-t+1,s+1):\n        nume *= i\n        nume %= mod\n    deno = 1\n    for i in range(1,t+1):\n        deno *= i\n        deno %= mod\n    deno = pow(deno,mod-2,mod)\n    \n    return (nume*deno%mod)\nans = 0\n\nfor i in range(k):\n    x1 = chs(k, k-i, mod)\n    #print(\"chs\",x1)\n    x2 = pow(k-i,n, mod)\n    #print(\"pow\",x2)\n    ans += x1*x2*(-1)**i\nprint(ans%mod)\n"
  },
  {
    "language": "Python",
    "code": "class Combination:\n    \"\"\"\n    SIZEが10^6程度以下の二項係数を何回も呼び出したいときに使う\n    使い方:\n    comb = Combination(SIZE, MOD)\n    comb(10, 3) => 120\n    \"\"\"\n\n    def __init__(self, N, MOD=10 ** 9 + 7):\n        self.MOD = MOD\n        self.fact, self.inv = self._make_factorial_list(N)\n\n    def __call__(self, n, k):\n        if k < 0 or k > n:\n            return 0\n        res = self.fact[n] * self.inv[k] % self.MOD\n        res = res * self.inv[n - k] % self.MOD\n        return res\n\n    def _make_factorial_list(self, N):\n        fact = [1] * (N + 1)\n        inv = [1] * (N + 1)\n        MOD = self.MOD\n        for i in range(1, N + 1):\n            fact[i] = (fact[i - 1] * i) % MOD\n        inv[N] = pow(fact[N], MOD - 2, MOD)\n        for i in range(N, 0, -1):\n            inv[i - 1] = (inv[i] * i) % MOD\n        return fact, inv\n\n\nif __name__ == \"__main__\":\n    N, K = map(int, input().split())\n    mod = 10 ** 9 + 7\n    U = 1000\n    comb = Combination(U + 5, mod)\n\n    total = pow(K, N, mod)\n    ng = 0\n    for i in range(1, K):\n        pair = comb(K, i)\n        cnt = pow(K - i, N, mod)\n        if i % 2 == 0:\n            ng -= pair * cnt\n            ng += mod\n            ng %= mod\n        else:\n            ng += pair * cnt\n            ng %= mod\n\n    ans = (total - ng + mod) % mod\n    print(ans)\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse mod_int::ModInt;\n\npub mod mod_int {\n    use std::ops::{\n        Add, AddAssign, BitAnd, Div, DivAssign, Mul, MulAssign, RemAssign, ShrAssign, Sub,\n        SubAssign,\n    };\n\n    pub struct ModInt<T> {\n        v: T,\n        m: T,\n    }\n\n    impl<T> ModInt<T>\n    where\n        T: Copy,\n    {\n        pub fn value(&self) -> T {\n            self.v\n        }\n        pub fn modulo(&self) -> T {\n            self.m\n        }\n    }\n\n    impl<T> ModInt<T> {\n        fn new_unchecked(v: T, modulo: T) -> Self {\n            Self { v, m: modulo }\n        }\n    }\n\n    impl<T> ModInt<T>\n    where\n        T: Copy + RemAssign + PartialOrd,\n    {\n        pub fn new(mut v: T, modulo: T) -> Self {\n            if v >= modulo {\n                v %= modulo;\n            }\n            Self::new_unchecked(v, modulo)\n        }\n    }\n\n    impl<T> ModInt<T>\n    where\n        T: Copy\n            + Sub<Output = T>\n            + ShrAssign\n            + BitAnd<Output = T>\n            + PartialEq\n            + PartialOrd\n            + Div<Output = T>\n            + RemAssign,\n        ModInt<T>: MulAssign,\n    {\n        pub fn pow(self, e: T) -> Self {\n            let zero = self.modulo() - self.modulo();\n            let one = self.modulo() / self.modulo();\n            let mut e = e;\n            let mut result = Self::new_unchecked(one, self.modulo());\n            let mut cur = self;\n            while e > zero {\n                if e & one == one {\n                    result *= cur;\n                }\n                e >>= one;\n                cur *= cur;\n            }\n            result\n        }\n    }\n\n    impl<T> Copy for ModInt<T> where T: Copy {}\n    impl<T> Clone for ModInt<T>\n    where\n        T: Copy,\n    {\n        fn clone(&self) -> Self {\n            Self::new_unchecked(self.value(), self.modulo())\n        }\n    }\n\n    impl<T> Add<T> for ModInt<T>\n    where\n        T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,\n    {\n        type Output = Self;\n        fn add(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n            rhs += self.value();\n            if rhs >= self.modulo() {\n                rhs -= self.modulo();\n            }\n            Self::new_unchecked(rhs, self.modulo())\n        }\n    }\n\n    impl<T> Sub<T> for ModInt<T>\n    where\n        T: AddAssign + SubAssign + RemAssign + Copy + PartialOrd,\n    {\n        type Output = Self;\n        fn sub(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n\n            let mut result = self.value();\n            result += self.modulo();\n            result -= rhs;\n\n            if result >= self.modulo() {\n                result -= self.modulo();\n            }\n            Self::new_unchecked(result, self.modulo())\n        }\n    }\n\n    impl<T> Mul<T> for ModInt<T>\n    where\n        T: MulAssign + RemAssign + Copy + PartialOrd,\n    {\n        type Output = Self;\n        fn mul(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n            rhs *= self.value();\n            rhs %= self.modulo();\n            Self::new_unchecked(rhs, self.modulo())\n        }\n    }\n\n    impl<T> Add<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Add<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn add(self, rhs: ModInt<T>) -> Self::Output {\n            self + rhs.value()\n        }\n    }\n    impl<T> Sub<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Sub<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn sub(self, rhs: ModInt<T>) -> Self::Output {\n            self - rhs.value()\n        }\n    }\n    impl<T> Mul<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Mul<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn mul(self, rhs: ModInt<T>) -> Self::Output {\n            self * rhs.value()\n        }\n    }\n    impl<T> Div<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Div<T, Output = ModInt<T>>,\n    {\n        type Output = Self;\n        fn div(self, rhs: ModInt<T>) -> Self::Output {\n            self / rhs.value()\n        }\n    }\n\n    impl<T> AddAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Add<T, Output = ModInt<T>>,\n    {\n        fn add_assign(&mut self, other: T) {\n            *self = *self + other;\n        }\n    }\n    impl<T> AddAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Add<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn add_assign(&mut self, other: ModInt<T>) {\n            *self = *self + other;\n        }\n    }\n\n    impl<T> SubAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Sub<T, Output = ModInt<T>>,\n    {\n        fn sub_assign(&mut self, other: T) {\n            *self = *self - other;\n        }\n    }\n\n    impl<T> SubAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Sub<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn sub_assign(&mut self, other: ModInt<T>) {\n            *self = *self - other;\n        }\n    }\n\n    impl<T> DivAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Div<T, Output = ModInt<T>>,\n    {\n        fn div_assign(&mut self, rhs: T) {\n            *self = *self / rhs\n        }\n    }\n    impl<T> DivAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Div<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn div_assign(&mut self, rhs: ModInt<T>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl<T> MulAssign<T> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Mul<T, Output = ModInt<T>>,\n    {\n        fn mul_assign(&mut self, rhs: T) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T> MulAssign<ModInt<T>> for ModInt<T>\n    where\n        T: Copy,\n        ModInt<T>: Mul<ModInt<T>, Output = ModInt<T>>,\n    {\n        fn mul_assign(&mut self, rhs: ModInt<T>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl<T> Div<T> for ModInt<T>\n    where\n        T: Copy\n            + Add<Output = T>\n            + Sub<Output = T>\n            + Div<Output = T>\n            + BitAnd<Output = T>\n            + PartialEq\n            + PartialOrd\n            + ShrAssign\n            + RemAssign\n            + MulAssign,\n    {\n        type Output = Self;\n        fn div(self, mut rhs: T) -> Self::Output {\n            if rhs >= self.modulo() {\n                rhs %= self.modulo();\n            }\n            let one = self.modulo() / self.modulo();\n            let two = one + one;\n            self * Self::new_unchecked(rhs, self.modulo()).pow(self.modulo() - two)\n        }\n    }\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Self {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Self {\n            fact,\n            inv_fact,\n            modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> usize {\n        assert!(x >= y);\n        self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo\n    }\n\n    pub fn h(&self, n: usize, r: usize) -> usize {\n        self.get(n + r - 1, r)\n    }\n}\n\n\nfn main() {\n    input!{\n        n: usize,\n        k: usize,\n    }\n    let modulo = 1000000007;\n    let mut count = ModInt::new(0, modulo);\n    let comb = Combination::new(2500, modulo);\n    \n    for empty in 0..k {\n        let sign = if (empty & 1) == 0 { 1 } else { modulo - 1 };\n        let sign = ModInt::new(sign, modulo);\n        count += sign * comb.get(k, empty) * ModInt::new(k - empty, modulo).pow(n);\n    }\n\n    println!(\"{}\", count.value());\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[doc = \" main\"]\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        n:i64,k:i64,\n    }\n    let MO = 1_000_000_007;\n    let mut mc = ModComb::new(2000, MO);\n    let ans = (mc.nSk(n, k) * mc.fact(k as usize)) % MO;\n    println!(\"{}\", ans);\n}\n\nstruct ModComb {\n    fact: Vec<i64>,\n    fact_inv: Vec<i64>,\n    n: usize,\n    p: i64,\n}\nimpl ModComb {\n    fn initialize(ft: &mut Self) {\n        let n = ft.n;\n        ft.fact[0] = 1;\n        for i in 1..n {\n            ft.fact[i] = (ft.fact[i - 1] * i as i64) % ft.p;\n        }\n        ft.fact_inv[n - 1] = modpow(ft.fact[n - 1], ft.p - 2, ft.p);\n        for i in (0..n - 1).rev() {\n            ft.fact_inv[i] = (ft.fact_inv[i + 1] * (i + 1) as i64) % ft.p;\n        }\n    }\n    #[doc = \"O(N)\"]\n    fn new(max_n: usize, p: i64) -> ModComb {\n        let mut ft = ModComb {\n            fact: vec![0; max_n + 1],\n            fact_inv: vec![0; max_n + 1],\n            n: max_n + 1,\n            p: p,\n        };\n        Self::initialize(&mut ft);\n        ft\n    }\n    fn fact(&self, n: usize) -> i64 {\n        self.fact[n]\n    }\n    #[doc = \"choose k numbers from 1..n\"]\n    fn nCk(&self, n: i64, k: i64) -> i64 {\n        if n < k {\n            return 0;\n        }\n        (self.nPk(n, k) * self.fact_inv[k as usize]) % self.p\n    }\n    fn nPk(&self, n: i64, k: i64) -> i64 {\n        if n < k {\n            return 0;\n        }\n        self.fact[n as usize] * self.fact_inv[(n - k) as usize] % self.p\n    }\n    #[doc = \"split k into n number as x1+x2+...xn=k\"]\n    fn nHk(&self, n: i64, k: i64) -> i64 {\n        if n == 0 && k == 0 {\n            return 1;\n        }\n        self.nCk(n + k - 1, k)\n    }\n    #[doc = \"put n balls into k different boxes. In case of n=3,k+2 [[1,2],[3]]==[[3],[1,2]]\"]\n    fn nSk(&self, n: i64, k: i64) -> i64 {\n        if n < k {\n            return 0;\n        }\n        let mut res = 0;\n        for i in 0..k + 1 {\n            let v = self.nCk(k, i) * modpow(i, n, self.p) % self.p;\n            if (k - i) % 2 == 1 {\n                res = (res + self.p - v) % self.p;\n            } else {\n                res = (res + v) % self.p;\n            }\n        }\n        return res * self.fact_inv[k as usize] % self.p;\n    }\n    fn nBk(&self, n: i64, k: i64) -> i64 {\n        0\n    }\n}\n#[allow(dead_code)]\n#[doc = \" x ^ n % m\"]\npub fn modpow(x: i64, n: i64, m: i64) -> i64 {\n    let mut res = 1;\n    let mut x = x % m;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n >>= 1;\n    }\n    res\n}\n"
  }
]