[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nlong long solve(int N, int M, int K) {\n    long long total_cost = 0;\n    \n    for (int row1 = 0; row1 < N; row1++) {\n        for (int col1 = 0; col1 < M; col1++) {\n            for (int row2 = row1; row2 < N; row2++) {\n                for (int col2 = (row2 == row1 ? col1 : 0); col2 < M; col2++) {\n                    if (row1 == row2 && col1 == col2) continue;\n                    \n                    long long pair_diff = abs(row1 - row2) + abs(col1 - col2);\n                    long long combinations = 1;\n                    \n                    for (int k = 2; k <= K; k++) {\n                        long long new_pieces_combs = (N * M - k + 1);\n                        combinations = (combinations * new_pieces_combs) % MOD;\n                    }\n                    \n                    total_cost = (total_cost + pair_diff * combinations) % MOD;\n                }\n            }\n        }\n    }\n    \n    return total_cost;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    printf(\"%lld\\n\", solve(N, M, K));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MOD 1000000007\n\nlong long comb[2002][2002];\n\nvoid precompute_combinations(int max_n) {\n    for (int n = 0; n <= max_n; n++) {\n        comb[n][0] = 1;\n        for (int k = 1; k <= n; k++) {\n            comb[n][k] = (comb[n-1][k-1] + comb[n-1][k]) % MOD;\n        }\n    }\n}\n\nlong long compute_sum(int N, int M, int K) {\n    if (K < 2) return 0;\n    long long total = 0;\n    long long ways = comb[N*M][K];\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            long long cnt = (comb[(i-1)*M + (N-i)*M + (j-1) + (M-j)][K-2] * (long long)(i*(N - i + 1) + j*(M - j + 1) - 2)) % MOD;\n            total = (total + cnt) % MOD;\n        }\n    }\n    \n    return (total * comb[N*M][K]) % MOD;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n    \n    precompute_combinations(N * M);\n    \n    long long sum_row = 0;\n    for (int i = 1; i <= N; i++) {\n        sum_row = (sum_row + (long long)i * (i - 1) % MOD) % MOD;\n    }\n    sum_row = sum_row * M % MOD * M % MOD * comb[N * M - 2][K - 2] % MOD;\n    \n    long long sum_col = 0;\n    for (int j = 1; j <= M; j++) {\n        sum_col = (sum_col + (long long)j * (j - 1) % MOD) % MOD;\n    }\n    sum_col = sum_col * N % MOD * N % MOD * comb[N * M - 2][K - 2] % MOD;\n    \n    long long total = (sum_row + sum_col) % MOD;\n    printf(\"%lld\\n\", total);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <modint.hpp>\n\nusing namespace std;\nusing mint = ModInt<1000000007>;\n\nmint comb(int n, int k, const vector<mint>& fact, const vector<mint>& inv_fact) {\n    if (k < 0 || k > n) return 0;\n    return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    int max_nm = max(N, M);\n    vector<mint> fact(max_nm * max_nm + 1);\n    vector<mint> inv_fact(max_nm * max_nm + 1);\n\n    fact[0] = 1;\n    for (int i = 1; i <= max_nm * max_nm; ++i) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    inv_fact[max_nm * max_nm] = fact[max_nm * max_nm].inv();\n    for (int i = max_nm * max_nm - 1; i >= 0; --i) {\n        inv_fact[i] = inv_fact[i + 1] * (i + 1);\n    }\n\n    mint total = 0;\n\n    // Row contribution\n    for (int i = 1; i <= N; ++i) {\n        for (int j = i + 1; j <= N; ++j) {\n            mint ways = comb(N * M - 2, K - 2, fact, inv_fact);\n            total += (j - i) * ways * M * M;\n        }\n    }\n\n    // Column contribution\n    for (int i = 1; i <= M; ++i) {\n        for (int j = i + 1; j <= M; ++j) {\n            mint ways = comb(N * M - 2, K - 2, fact, inv_fact);\n            total += (j - i) * ways * N * N;\n        }\n    }\n\n    cout << total.val() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\n\npublic class Main {\n    static final long MOD = 1000000007;\n    \n    static long modPow(long a, long b) {\n        long res = 1;\n        a = a % MOD;\n        while (b > 0) {\n            if ((b & 1) != 0) {\n                res = (res * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            b >>= 1;\n        }\n        return res;\n    }\n    \n    static long comb(int n, int k, long[] fact, long[] invFact) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int K = sc.nextInt();\n        \n        int maxNM = Math.max(N, M);\n        long[] fact = new long[maxNM * maxNM + 1];\n        long[] invFact = new long[maxNM * maxNM + 1];\n        \n        fact[0] = 1;\n        for (int i = 1; i <= maxNM * maxNM; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[maxNM * maxNM] = modPow(fact[maxNM * maxNM], MOD - 2);\n        for (int i = maxNM * maxNM - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n        \n        long total = 0;\n        \n        // Sum for row differences\n        long rowSum = 0;\n        for (int d = 1; d < N; d++) {\n            long ways = (long) d * (N - d) % MOD;\n            ways = ways * M % MOD;\n            ways = ways * M % MOD;\n            long c = comb(N * M - 2, K - 2, fact, invFact);\n            rowSum = (rowSum + ways * c) % MOD;\n        }\n        \n        // Sum for column differences\n        long colSum = 0;\n        for (int d = 1; d < M; d++) {\n            long ways = (long) d * (M - d) % MOD;\n            ways = ways * N % MOD;\n            ways = ways * N % MOD;\n            long c = comb(N * M - 2, K - 2, fact, invFact);\n            colSum = (colSum + ways * c) % MOD;\n        }\n        \n        total = (rowSum + colSum) % MOD;\n        System.out.println(total);\n    }\n}",
    "timestamp": "2025-08-05 22:52:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int gridArrangementCost(int N, int M, int K) {\n        final int MOD = 1_000_000_007;\n        long totalCost = 0;\n        \n        long[][] combs = new long[N * M + 1][K + 1];\n        combs[0][0] = 1;\n        \n        for (int total = 1; total <= N * M; total++) {\n            combs[total][0] = 1;\n            for (int pieces = 1; pieces <= Math.min(total, K); pieces++) {\n                combs[total][pieces] = (combs[total - 1][pieces - 1] + combs[total - 1][pieces]) % MOD;\n            }\n        }\n        \n        for (int i1 = 0; i1 < N; i1++) {\n            for (int j1 = 0; j1 < M; j1++) {\n                for (int i2 = 0; i2 < N; i2++) {\n                    for (int j2 = 0; j2 < M; j2++) {\n                        if (i1 == i2 && j1 == j2) continue;\n                        long rowDiff = Math.abs(i1 - i2);\n                        long colDiff = Math.abs(j1 - j2);\n                        \n                        for (int p = 2; p <= K; p++) {\n                            totalCost += (combs[N * M - 2][p - 2] * rowDiff * colDiff) % MOD;\n                            totalCost %= MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return (int) totalCost;\n    }\n}",
    "timestamp": "2025-08-05 22:52:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int placePieces(int N, int M, int K) {\n        ll total = 0;\n        \n        vector<vector<ll>> choose(N*M + 1, vector<ll>(K + 1, 0));\n        choose[0][0] = 1;\n        \n        for (int i = 1; i <= N*M; i++) {\n            choose[i][0] = 1;\n            for (int j = 1; j <= min(i, K); j++) {\n                choose[i][j] = (choose[i-1][j-1] + choose[i-1][j]) % MOD;\n            }\n        }\n        \n        for (int first = 0; first < N*M; first++) {\n            int r1 = first / M, c1 = first % M;\n            for (int second = first + 1; second < N*M; second++) {\n                int r2 = second / M, c2 = second % M;\n                \n                ll count = 0;\n                for (int remaining = K - 2; remaining >= 0; remaining--) {\n                    count = (count * (N*M - second - 1) + choose[N*M - second - 1][remaining]) % MOD;\n                    \n                    ll cost = abs(r1 - r2) + abs(c1 - c2);\n                    total = (total + cost * choose[first][1] % MOD * choose[N*M - second - 1][remaining]) % MOD;\n                }\n            }\n        }\n        \n        return total;\n    }\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    \n    Solution solution;\n    cout << solution.placePieces(N, M, K) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef sum_of_costs(N, M, K):\n    total_cost = 0\n    \n    # Calculate combinations\n    def comb(n, k):\n        if k > n:\n            return 0\n        if k == 0:\n            return 1\n        num = 1\n        denom = 1\n        for i in range(k):\n            num = num * (n - i) % MOD\n            denom = denom * (i + 1) % MOD\n        return num * pow(denom, MOD-2, MOD) % MOD\n    \n    # Compute sum of differences in rows\n    row_sum = 0\n    for i in range(1, N):\n        row_sum += i * (N - i) % MOD\n        \n    # Compute sum of differences in columns\n    col_sum = 0\n    for j in range(1, M):\n        col_sum += j * (M - j) % MOD\n    \n    # Total sum of costs\n    total_cost = (row_sum * M**2 % MOD + col_sum * N**2 % MOD) % MOD\n    \n    # Multiply by combination of K pieces\n    total_cost = total_cost * comb(N * M - 2, K - 2) % MOD\n    \n    return total_cost\n\n# Example usage\nN, M, K = 2, 3, 2\nresult = sum_of_costs(N, M, K)\nprint(result)",
    "timestamp": "2025-08-13 12:45:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GridArrangementCost {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        scanner.close();\n\n        long[][] comb = calculateCombinations(Math.max(N, M) * 2, K);\n\n        long totalCost = 0;\n\n        for (int r1 = 0; r1 < N; r1++) {\n            for (int r2 = r1 + 1; r2 < N; r2++) {\n                long costPerRowDifference = (r2 - r1) * comb[N * M - 2][K - 2];\n                totalCost = (totalCost + costPerRowDifference) % MOD;\n            }\n        }\n\n        for (int c1 = 0; c1 < M; c1++) {\n            for (int c2 = c1 + 1; c2 < M; c2++) {\n                long costPerColumnDifference = (c2 - c1) * comb[N * M - 2][K - 2];\n                totalCost = (totalCost + costPerColumnDifference) % MOD;\n            }\n        }\n\n        totalCost = (totalCost * comb[N * M][K]) % MOD;\n        System.out.println(totalCost);\n    }\n\n    private static long[][] calculateCombinations(int n, int k) {\n        long[][] comb = new long[n + 1][k + 1];\n        comb[0][0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= k; j++) {\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n            }\n        }\n\n        return comb;\n    }\n}",
    "timestamp": "2025-08-13 12:45:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\nlong long mod_inverse(long long a, long long m) {\n    long long m0 = m, t, q;\n    long long x0 = 0, x1 = 1;\n    if (m == 1) return 0;\n    while (a > 1) {\n        q = a / m;\n        t = m;\n        m = a % m, a = t;\n        t = x0;\n        x0 = x1 - q * x0;\n        x1 = t;\n    }\n    if (x1 < 0) x1 += m0;\n    return x1;\n}\n\nlong long binomial_coefficient(long long n, long long k, long long m) {\n    if (k > n) return 0;\n    if (k == 0 || k == n) return 1;\n    long long num = 1, denom = 1;\n    for (long long i = 0; i < k; i++) {\n        num = (num * (n - i)) % m;\n        denom = (denom * (i + 1)) % m;\n    }\n    return (num * mod_inverse(denom, m)) % m;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    long long binom_K_minus_1 = binomial_coefficient(K - 1, K - 2, MOD);\n    long long total_cost = 0;\n\n    for (int i1 = 0; i1 < N; i1++) {\n        for (int i2 = 0; i2 < N; i2++) {\n            long long cost_rows = abs(i1 - i2);\n            long long combinations_rows = binom_K_minus_1 * (binomial_coefficient(N, K - 2, MOD) * binomial_coefficient(M, 2, MOD) % MOD) % MOD;\n            total_cost = (total_cost + cost_rows * combinations_rows % MOD) % MOD;\n        }\n    }\n\n    for (int j1 = 0; j1 < M; j1++) {\n        for (int j2 = 0; j2 < M; j2++) {\n            long long cost_cols = abs(j1 - j2);\n            long long combinations_cols = binom_K_minus_1 * (binomial_coefficient(M, K - 2, MOD) * binomial_coefficient(N, 2, MOD) % MOD) % MOD;\n            total_cost = (total_cost + cost_cols * combinations_cols % MOD) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", total_cost);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:45:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateCostSum(N, M, K) {\n  const MOD = 1000000007;\n\n  const sumOfSquares = (x) => (x * (x + 1) * (2 * x + 1)) / 6;\n  const sum = (x) => (x * (x + 1)) / 2;\n\n  let totalSum = 0;\n\n  function sumCalculation(n, m, k) {\n    let result = 0;\n    for (let i = 1; i <= n; i++) {\n      const term1 = (n - i) * i * m * m;\n      const term2 = i * (n - i) * sum(m - 1);\n      result = (result + term1 + term2) % MOD;\n    }\n\n    for (let j = 1; j <= m; j++) {\n      const term1 = (m - j) * j * n * n;\n      const term2 = j * (m - j) * sum(n - 1);\n      result = (result + term1 + term2) % MOD;\n    }\n\n    return result;\n  }\n\n  totalSum = (sumCalculation(N, M, K) * binomialCoefficient(N * M, K, MOD)) % MOD;\n\n  return totalSum;\n}\n\nfunction binomialCoefficient(n, k, mod) {\n  if (k > n) return 0;\n\n  let nom = 1;\n  for (let i = 0; i < k; i++) {\n    nom = (nom * (n - i)) % mod;\n  }\n\n  let denom = 1;\n  for (let i = 1; i <= k; i++) {\n    denom = (denom * i) % mod;\n  }\n\n  return (nom * modInverse(denom, mod)) % mod;\n}\n\nfunction modInverse(a, mod) {\n  let m0 = mod, t, q;\n  let x0 = 0, x1 = 1;\n\n  if (mod === 1) return 0;\n\n  while (a > 1) {\n    q = Math.floor(a / mod);\n    t = mod;\n    mod = a % mod; a = t;\n    t = x0;\n    x0 = x1 - q * x0;\n    x1 = t;\n  }\n\n  if (x1 < 0) x1 += m0;\n\n  return x1;\n}",
    "timestamp": "2025-08-13 12:45:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, M, K):\n    MOD = 10**9 + 7\n    \n    # Precompute row and column contributions\n    row_contribution = [0] * (N+1)\n    col_contribution = [0] * (M+1)\n    \n    # Row contributions\n    for i in range(1, N+1):\n        row_contribution[i] = row_contribution[i-1] + i * (N-i+1)\n    \n    # Column contributions\n    for j in range(1, M+1):\n        col_contribution[j] = col_contribution[j-1] + j * (M-j+1)\n    \n    # Compute total arrangements\n    total_arrangements = 0\n    \n    # Iterate through all possible combinations of K squares\n    from itertools import combinations\n    \n    all_squares = [(i, j) for i in range(1, N+1) for j in range(1, M+1)]\n    \n    for chosen_squares in combinations(all_squares, K):\n        cost = 0\n        for (r1, c1), (r2, c2) in combinations(chosen_squares, 2):\n            cost += abs(r1 - r2) + abs(c1 - c2)\n        total_arrangements = (total_arrangements + cost) % MOD\n    \n    return total_arrangements\n\n# Read input\nN, M, K = map(int, input().split())\nprint(solve(N, M, K))",
    "timestamp": "2025-08-13 12:45:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, M, K) {\n    const MOD = 1000000007;\n    let result = 0n;\n    \n    for (let r1 = 0; r1 < N; r1++) {\n        for (let c1 = 0; c1 < M; c1++) {\n            for (let r2 = r1; r2 < N; r2++) {\n                for (let c2 = 0; c2 < M; c2++) {\n                    if (r1 === r2 && c1 > c2) continue;\n                    \n                    let arrangements = countArrangements(N, M, K, r1, c1, r2, c2);\n                    let cost = Math.abs(r1 - r2) + Math.abs(c1 - c2);\n                    \n                    result = (result + BigInt(arrangements) * BigInt(cost)) % BigInt(MOD);\n                }\n            }\n        }\n    }\n    \n    return Number(result);\n}\n\nfunction countArrangements(N, M, K, r1, c1, r2, c2) {\n    if (K === 2) return 1;\n    \n    let remaining = K - 2;\n    let totalCells = N * M;\n    let availableCells = totalCells - 2;\n    \n    return combinations(availableCells, remaining);\n}\n\nfunction combinations(n, k) {\n    if (k > n) return 0;\n    \n    let result = 1;\n    for (let i = 1; i <= k; i++) {\n        result *= (n - i + 1);\n        result /= i;\n    }\n    \n    return result;\n}",
    "timestamp": "2025-08-13 12:45:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    N, M, K = map(int, sys.stdin.readline().split())\n    \n    # Precompute factorial, inverse factorial up to N*M\n    max_n = N * M\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    total = 0\n    \n    # Sum over row differences\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            cnt = (j - i) * M * M % MOD\n            ways = comb(N * M - 2, K - 2)\n            total = (total + cnt * ways) % MOD\n    \n    # Sum over column differences\n    for i in range(1, M + 1):\n        for j in range(i + 1, M + 1):\n            cnt = (j - i) * N * N % MOD\n            ways = comb(N * M - 2, K - 2)\n            total = (total + cnt * ways) % MOD\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 12:46:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split(' ');\n    const N = parseInt(input[0], 10);\n    const M = parseInt(input[1], 10);\n    const K = parseInt(input[2], 10);\n\n    if (K < 2) {\n        console.log(0);\n        return;\n    }\n\n    const comb = precomputeCombinations(N * M, K);\n    \n    let total = 0;\n    \n    // Sum for row differences\n    for (let d = 1; d < N; d++) {\n        const cnt = (N - d) * M * M;\n        const ways = comb.totalComb;\n        const current = (d * cnt % MOD) * ways % MOD;\n        total = (total + current) % MOD;\n    }\n    \n    // Sum for column differences\n    for (let d = 1; d < M; d++) {\n        const cnt = (M - d) * N * N;\n        const ways = comb.totalComb;\n        const current = (d * cnt % MOD) * ways % MOD;\n        total = (total + current) % MOD;\n    }\n    \n    console.log(total);\n}\n\nfunction precomputeCombinations(maxN, K) {\n    const factorial = new Array(maxN + 1).fill(0);\n    const invFact = new Array(maxN + 1).fill(0);\n    \n    factorial[0] = 1;\n    for (let i = 1; i <= maxN; i++) {\n        factorial[i] = factorial[i - 1] * i % MOD;\n    }\n    \n    invFact[maxN] = modInverse(factorial[maxN], MOD);\n    for (let i = maxN - 1; i >= 0; i--) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n    \n    function nCr(n, k) {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return factorial[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n    \n    const totalComb = nCr(maxN - 2, K - 2);\n    \n    return { nCr, totalComb };\n}\n\nfunction modInverse(a, mod) {\n    let m = mod;\n    let [x, y, u, v] = [0, 1, 1, 0];\n    while (a !== 0) {\n        const q = Math.floor(m / a);\n        [x, y, u, v] = [u, v, x - u * q, y - v * q];\n        [m, a] = [a, m % a];\n    }\n    if (m !== 1) return 0; // No inverse exists\n    return (x % mod + mod) % mod;\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:46:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#define MOD 1000000007\n\nusing namespace std;\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n\n    long long rowSum = 0, colSum = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        rowSum = (rowSum + (i * (long long)(i - 1) / 2) % MOD) % MOD;\n    }\n\n    for (int i = 1; i <= M; ++i) {\n        colSum = (colSum + (i * (long long)(i - 1) / 2) % MOD) % MOD;\n    }\n\n    long long rowCost = (rowSum * M % MOD) * (M * (long long)((K - 2 >= 0 ? K - 2 : 0) % MOD) % MOD) % MOD;\n    long long colCost = (colSum * N % MOD) * (N * (long long)((K - 2 >= 0 ? K - 2 : 0) % MOD) % MOD) % MOD;\n\n    long long result = ((rowCost + colCost) % MOD) * ((long long)(K * (K - 1) % MOD) / 2 % MOD) % MOD;\n\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:36:14"
  }
]