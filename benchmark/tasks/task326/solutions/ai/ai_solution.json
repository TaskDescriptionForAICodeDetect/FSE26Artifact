[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 100\n\ntypedef struct {\n    int dest;\n    int cost;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_NODES][MAX_NODES];\n    int edgeCount[MAX_NODES];\n    int nodeCount;\n} Graph;\n\nvoid initGraph(Graph *g, int nodeCount) {\n    g->nodeCount = nodeCount;\n    for (int i = 0; i < nodeCount; i++) {\n        g->edgeCount[i] = 0;\n    }\n}\n\nvoid addEdge(Graph *g, int src, int dest, int cost) {\n    g->edges[src][g->edgeCount[src]].dest = dest;\n    g->edges[src][g->edgeCount[src]].cost = cost;\n    g->edgeCount[src]++;\n}\n\nint minDistance(int dist[], int visited[], int nodeCount) {\n    int min = INT_MAX, minIndex;\n    for (int v = 0; v < nodeCount; v++) {\n        if (!visited[v] && dist[v] <= min) {\n            min = dist[v];\n            minIndex = v;\n        }\n    }\n    return minIndex;\n}\n\nvoid dijkstra(Graph *g, int src, int dist[]) {\n    int visited[MAX_NODES] = {0};\n    for (int i = 0; i < g->nodeCount; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[src] = 0;\n\n    for (int count = 0; count < g->nodeCount - 1; count++) {\n        int u = minDistance(dist, visited, g->nodeCount);\n        visited[u] = 1;\n        for (int i = 0; i < g->edgeCount[u]; i++) {\n            int v = g->edges[u][i].dest;\n            int cost = g->edges[u][i].cost;\n            if (!visited[v] && dist[u] != INT_MAX && dist[u] + cost < dist[v]) {\n                dist[v] = dist[u] + cost;\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, S, A, B;\n    scanf(\"%d %d %d %d %d\", &N, &M, &S, &A, &B);\n    Graph g;\n    initGraph(&g, N);\n\n    for (int i = 0; i < M; i++) {\n        int src, dest, cost;\n        scanf(\"%d %d %d\", &src, &dest, &cost);\n        addEdge(&g, src, dest, cost);\n    }\n\n    int distS[MAX_NODES], distA[MAX_NODES], distB[MAX_NODES];\n    dijkstra(&g, S, distS);\n    dijkstra(&g, A, distA);\n    dijkstra(&g, B, distB);\n\n    int minCost = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        if (distS[i] != INT_MAX && distA[i] != INT_MAX && distB[i] != INT_MAX) {\n            int totalCost = distS[i] + distA[i] + distB[i];\n            if (totalCost < minCost) {\n                minCost = totalCost;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", minCost);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid dijkstra(int src, vector<vector<pii>>& adj, vector<int>& dist) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    dist[src] = 0;\n    pq.push({0, src});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int d = pq.top().first;\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (auto& edge : adj[u]) {\n            int v = edge.first;\n            int w = edge.second;\n\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, S, A, B;\n    cin >> N >> M >> S >> A >> B;\n\n    vector<vector<pii>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({v, w});\n    }\n\n    vector<int> distS(N + 1, INT_MAX);\n    dijkstra(S, adj, distS);\n\n    vector<int> distA(N + 1, INT_MAX);\n    dijkstra(A, adj, distA);\n\n    vector<int> distB(N + 1, INT_MAX);\n    dijkstra(B, adj, distB);\n\n    int min_cost = INT_MAX;\n    for (int i = 1; i <= N; ++i) {\n        if (distS[i] != INT_MAX && distA[i] != INT_MAX && distB[i] != INT_MAX) {\n            int total = distS[i] + distA[i] + distB[i];\n            if (total < min_cost) {\n                min_cost = total;\n            }\n        }\n    }\n\n    cout << min_cost << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to, cost;\n    Edge(int to, int cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int S = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        \n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int c = sc.nextInt();\n            graph.get(u).add(new Edge(v, c));\n        }\n        \n        int[] distFromS = dijkstra(graph, S, N);\n        int[] distFromA = dijkstra(graph, A, N);\n        int[] distFromB = dijkstra(graph, B, N);\n        \n        int minCost = Integer.MAX_VALUE;\n        for (int i = 1; i <= N; i++) {\n            if (distFromS[i] != Integer.MAX_VALUE && distFromA[i] != Integer.MAX_VALUE && distFromB[i] != Integer.MAX_VALUE) {\n                int totalCost = distFromS[i] + distFromA[i] + distFromB[i];\n                if (totalCost < minCost) {\n                    minCost = totalCost;\n                }\n            }\n        }\n        \n        System.out.println(minCost);\n    }\n    \n    static int[] dijkstra(List<List<Edge>> graph, int start, int N) {\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[start] = 0;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.add(new int[]{start, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int cost = current[1];\n            \n            if (cost > dist[u]) continue;\n            \n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newCost = cost + edge.cost;\n                if (newCost < dist[v]) {\n                    dist[v] = newCost;\n                    pq.add(new int[]{v, newCost});\n                }\n            }\n        }\n        \n        return dist;\n    }\n}",
    "timestamp": "2025-08-05 21:06:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n        \n        public Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    static class DisjointSet {\n        int[] parent, rank;\n        \n        public DisjointSet(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    public static int minimumPipelineCost(int n, List<Edge> edges, int sourceBase, int[] targetBases) {\n        Collections.sort(edges);\n        DisjointSet ds = new DisjointSet(n);\n        int totalCost = 0;\n        \n        // Create directed spanning tree from source base\n        for (Edge edge : edges) {\n            int u = edge.src;\n            int v = edge.dest;\n            \n            if (ds.find(u) != ds.find(v)) {\n                // Ensure water flows from source base\n                if (u == sourceBase || ds.find(sourceBase) == ds.find(u)) {\n                    ds.union(u, v);\n                    totalCost += edge.weight;\n                }\n            }\n        }\n        \n        // Check if all target bases are connected\n        for (int target : targetBases) {\n            if (ds.find(sourceBase) != ds.find(target)) {\n                return -1;  // Cannot connect to all bases\n            }\n        }\n        \n        return totalCost;\n    }\n    \n    public static void main(String[] args) {\n        int n = 5;  // Total number of bases\n        List<Edge> edges = new ArrayList<>();\n        edges.add(new Edge(0, 1, 10));\n        edges.add(new Edge(0, 2, 15));\n        edges.add(new Edge(1, 3, 12));\n        edges.add(new Edge(2, 4, 20));\n        \n        int sourceBase = 0;\n        int[] targetBases = {3, 4};\n        \n        int result = minimumPipelineCost(n, edges, sourceBase, targetBases);\n        System.out.println(\"Minimum Pipeline Cost: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 21:06:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 1001\n#define INF 1000000000\n\ntypedef struct {\n    int to, weight;\n} Edge;\n\nEdge graph[MAX_NODES][MAX_NODES];\nint graph_size[MAX_NODES];\nint n, m, source, base1, base2;\nint dist[MAX_NODES];\nint parent[MAX_NODES];\nint visited[MAX_NODES];\n\nvoid dijkstra(int start) {\n    for (int i = 1; i <= n; i++) {\n        dist[i] = INF;\n        visited[i] = 0;\n        parent[i] = -1;\n    }\n    dist[start] = 0;\n\n    for (int count = 1; count <= n; count++) {\n        int u = -1, min_dist = INF;\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && dist[v] < min_dist) {\n                min_dist = dist[v];\n                u = v;\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (int i = 0; i < graph_size[u]; i++) {\n            int v = graph[u][i].to;\n            int weight = graph[u][i].weight;\n            if (!visited[v] && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                parent[v] = u;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d %d %d\", &n, &m, &source, &base1, &base2);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        graph[u][graph_size[u]].to = v;\n        graph[u][graph_size[u]].weight = w;\n        graph_size[u]++;\n    }\n\n    dijkstra(source);\n    int cost1 = dist[base1];\n    dijkstra(source);\n    int cost2 = dist[base2];\n\n    int total_cost = cost1 + cost2;\n    printf(\"%d\\n\", total_cost);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<vector<int>> graph;\n    int n;\n\npublic:\n    int minimumCostFlow(int source, vector<int>& destinations) {\n        vector<vector<int>> dist(n, vector<int>(n, numeric_limits<int>::max()));\n        \n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (graph[i][k] != numeric_limits<int>::max() && \n                        graph[k][j] != numeric_limits<int>::max()) {\n                        dist[i][j] = min(dist[i][j], graph[i][k] + graph[k][j]);\n                    }\n                }\n            }\n        }\n        \n        int totalCost = 0;\n        for (int dest : destinations) {\n            if (dist[source][dest] == numeric_limits<int>::max()) {\n                return -1;\n            }\n            totalCost += dist[source][dest];\n        }\n        \n        return totalCost;\n    }\n    \n    void solve() {\n        int m, k;\n        cin >> n >> m >> k;\n        \n        graph.resize(n, vector<int>(n, numeric_limits<int>::max()));\n        \n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n            cin >> u >> v >> w;\n            u--; v--;\n            graph[u][v] = w;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            graph[i][i] = 0;\n        }\n        \n        int source;\n        cin >> source;\n        source--;\n        \n        vector<int> destinations(k);\n        for (int i = 0; i < k; i++) {\n            cin >> destinations[i];\n            destinations[i]--;\n        }\n        \n        int result = minimumCostFlow(source, destinations);\n        cout << result << endl;\n    }\n};\n\nint main() {\n    Solution solution;\n    solution.solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef min_cost_to_supply_water(n, roads, source_base, base1, base2):\n    def dijkstra(start, target):\n        min_heap = [(0, start)]\n        heapq.heapify(min_heap)\n        dist = {i: float('inf') for i in range(1, n + 1)}\n        dist[start] = 0\n        \n        while min_heap:\n            current_distance, current_node = heapq.heappop(min_heap)\n            \n            if current_node == target:\n                return current_distance\n            \n            if current_distance > dist[current_node]:\n                continue\n            \n            for neighbor, weight in graph[current_node]:\n                distance = current_distance + weight\n                \n                if distance < dist[neighbor]:\n                    dist[neighbor] = distance\n                    heapq.heappush(min_heap, (distance, neighbor))\n        \n        return float('inf')\n\n    graph = {i: [] for i in range(1, n + 1)}\n    \n    for u, v, cost in roads:\n        graph[u].append((v, cost))\n\n    cost_base1 = dijkstra(source_base, base1)\n    cost_base2 = dijkstra(source_base, base2)\n    \n    return cost_base1 + cost_base2\n\n# Example usage:\nn = 4\nroads = [(1, 2, 3), (1, 3, 5), (2, 4, 4), (3, 4, 6)]\nsource_base = 1\nbase1 = 2\nbase2 = 4\n\nprint(min_cost_to_supply_water(n, roads, source_base, base1, base2))  # Output: 7",
    "timestamp": "2025-08-13 04:57:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MarsWaterPipeline {\n\n    static class Edge {\n        int target, cost;\n        \n        public Edge(int target, int cost) {\n            this.target = target;\n            this.cost = cost;\n        }\n    }\n\n    static class Graph {\n        int vertices;\n        List<List<Edge>> adjList;\n\n        public Graph(int vertices) {\n            this.vertices = vertices;\n            adjList = new ArrayList<>();\n            for (int i = 0; i < vertices; i++) {\n                adjList.add(new ArrayList<>());\n            }\n        }\n\n        public void addEdge(int u, int v, int cost) {\n            adjList.get(u).add(new Edge(v, cost));\n        }\n    }\n\n    public static int dijkstra(Graph graph, int start, int[] targets) {\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.cost));\n        pq.add(new Edge(start, 0));\n\n        int[] minCost = new int[graph.vertices];\n        Arrays.fill(minCost, Integer.MAX_VALUE);\n        minCost[start] = 0;\n\n        boolean[] visited = new boolean[graph.vertices];\n\n        while (!pq.isEmpty()) {\n            Edge currentEdge = pq.poll();\n            int current = currentEdge.target;\n            \n            if (visited[current]) continue;\n            visited[current] = true;\n\n            for (Edge neighbor : graph.adjList.get(current)) {\n                int newCost = minCost[current] + neighbor.cost;\n                if (newCost < minCost[neighbor.target]) {\n                    minCost[neighbor.target] = newCost;\n                    pq.add(new Edge(neighbor.target, newCost));\n                }\n            }\n        }\n        \n        int totalCost = 0;\n        for (int target : targets) {\n            if (minCost[target] == Integer.MAX_VALUE) {\n                return Integer.MAX_VALUE; // Indicating unreachable target\n            }\n            totalCost += minCost[target];\n        }\n        \n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        Graph graph = new Graph(5);\n\n        // Add roads (edges) here: graph.addEdge(u, v, cost);\n        graph.addEdge(0, 1, 10);\n        graph.addEdge(0, 3, 20);\n        graph.addEdge(1, 2, 5);\n        graph.addEdge(3, 4, 15);\n        graph.addEdge(4, 2, 10);\n        \n        int startBase = 0;\n        int[] targetBases = {2, 4}; // Bases to supply with water\n\n        int minimumCost = dijkstra(graph, startBase, targetBases);\n        \n        System.out.println(\"Minimum cost to lay pipes: \" + minimumCost);\n    }\n}",
    "timestamp": "2025-08-13 04:57:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 1000\n\ntypedef struct {\n    int from, to, cost;\n} Edge;\n\nEdge edges[MAX_NODES * MAX_NODES];\nint dist[MAX_NODES], predecessor[MAX_NODES];\nint numNodes, numEdges;\n\nint compareEdges(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->cost - edgeB->cost;\n}\n\nint findParent(int parent[], int i) {\n    if (parent[i] == i)\n        return i;\n    return (parent[i] = findParent(parent, parent[i]));\n}\n\nvoid kruskalMST() {\n    qsort(edges, numEdges, sizeof(Edge), compareEdges);\n    \n    int *parent = (int *)malloc(numNodes * sizeof(int));\n    for (int i = 0; i < numNodes; i++)\n        parent[i] = i;\n\n    Edge result[MAX_NODES];  // Store result\n    int e = 0;\n    \n    for (int i = 0; i < numEdges && e < numNodes - 1; i++) {\n        int x = findParent(parent, edges[i].from);\n        int y = findParent(parent, edges[i].to);\n    \n        if (x != y) {\n            result[e++] = edges[i];\n            parent[x] = y;\n        }\n    }\n    \n    free(parent);\n    \n    int totalCost = 0;\n    for (int i = 0; i < e; i++) {\n        totalCost += result[i].cost;\n    }\n    printf(\"Minimum cost to lay the pipes: %d\\n\", totalCost);\n}\n\nint main() {\n    scanf(\"%d %d\", &numNodes, &numEdges);\n    for (int i = 0; i < numEdges; i++) {\n        scanf(\"%d %d %d\", &edges[i].from, &edges[i].to, &edges[i].cost);\n    }\n    \n    kruskalMST();\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 04:57:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\ndef mars_water_pipeline(n, roads, sources, destinations):\n    graph = defaultdict(list)\n    for u, v, cost in roads:\n        graph[u].append((v, cost))\n    \n    def dijkstra(start, destinations):\n        dist = {start: 0}\n        pq = [(0, start)]\n        \n        while pq:\n            current_cost, current_node = heapq.heappop(pq)\n            \n            if current_node in destinations:\n                return current_cost\n            \n            if current_cost > dist.get(current_node, float('inf')):\n                continue\n            \n            for next_node, road_cost in graph[current_node]:\n                new_cost = current_cost + road_cost\n                if new_cost < dist.get(next_node, float('inf')):\n                    dist[next_node] = new_cost\n                    heapq.heappush(pq, (new_cost, next_node))\n        \n        return float('inf')\n    \n    total_cost = 0\n    for source in sources:\n        for dest in destinations:\n            cost = dijkstra(source, [dest])\n            if cost == float('inf'):\n                return -1\n            total_cost += cost\n    \n    return total_cost\n\n# Example usage\nn = 5  # number of bases\nroads = [\n    (0, 1, 5),  # from base 0 to base 1, cost 5\n    (1, 2, 3),  # from base 1 to base 2, cost 3\n    (0, 3, 2),  # from base 0 to base 3, cost 2\n    (3, 4, 4)   # from base 3 to base 4, cost 4\n]\nsources = [0]  # source base\ndestinations = [2, 4]  # destination bases\n\nprint(mars_water_pipeline(n, roads, sources, destinations))",
    "timestamp": "2025-08-13 04:57:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    S = int(data[idx]) - 1\n    idx += 1\n    A = int(data[idx]) - 1\n    idx += 1\n    B = int(data[idx]) - 1\n    idx += 1\n    \n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        adj[u].append((v, c))\n    \n    def dijkstra(start):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        heap = [(0, start)]\n        visited = set()\n        \n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if u in visited:\n                continue\n            visited.add(u)\n            for v, c in adj[u]:\n                if dist[v] > current_dist + c:\n                    dist[v] = current_dist + c\n                    heapq.heappush(heap, (dist[v], v))\n        return dist\n    \n    dist_S = dijkstra(S)\n    dist_A = dijkstra(A)\n    dist_B = dijkstra(B)\n    \n    min_cost = float('inf')\n    for x in range(N):\n        cost = dist_S[x] + dist_A[x] + dist_B[x]\n        if cost < min_cost:\n            min_cost = cost\n    \n    print(min_cost if min_cost != float('inf') else -1)\n\nsolve()",
    "timestamp": "2025-08-13 04:58:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\n// Define an Edge structure to store a road's information\nstruct Edge {\n    int to, cost;\n};\n\n// Function to calculate the minimum cost using Dijkstra's algorithm for two separate targets\nint dijkstra_min_cost(int source, int target1, int target2, const vector<vector<Edge>>& graph) {\n    int n = graph.size();\n    vector<int> dist1(n, INT_MAX);\n    vector<int> dist2(n, INT_MAX);\n    dist1[source] = dist2[source] = 0;\n\n    // Priority queue to select the edge with the smallest cost\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, source});\n\n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (current_dist > dist1[u] && current_dist > dist2[u]) continue;\n\n        for (const Edge& edge : graph[u]) {\n            int v = edge.to;\n            int new_cost = current_dist + edge.cost;\n\n            // Relaxation step for the first and second target\n            if (new_cost < dist1[v]) {\n                swap(new_cost, dist1[v]);\n                pq.push({dist1[v], v});\n            }\n            if (new_cost < dist2[v]) {\n                dist2[v] = new_cost;\n                pq.push({dist2[v], v});\n            }\n        }\n    }\n\n    return dist1[target1] + dist1[target2];\n}\n\nint main() {\n    int numBases, numRoads;\n    cin >> numBases >> numRoads;\n\n    vector<vector<Edge>> graph(numBases + 1);\n\n    for (int i = 0; i < numRoads; ++i) {\n        int from, to, cost;\n        cin >> from >> to >> cost;\n        graph[from].push_back({to, cost});\n    }\n\n    int sourceBase, targetBase1, targetBase2;\n    cin >> sourceBase >> targetBase1 >> targetBase2;\n\n    int min_cost = dijkstra_min_cost(sourceBase, targetBase1, targetBase2, graph);\n    cout << min_cost << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:21"
  }
]