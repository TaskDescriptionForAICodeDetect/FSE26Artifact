[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int b1,b2,c;\n  int pipe[MAX][MAX];\n  int ans=INF;\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      pipe[i][j]=INF;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      for( int k=0;k<n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  for( int i=0;i<n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<20\nusing namespace std;\nstruct node{\n  int cur;\n  int flag;\n  int cost;\n};\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    g1--,g2--,s--;\n    int d[100][100]={0},a,b,c;\n    rep(i,m){\n      cin>>a>>b>>c;\n      d[a-1][b-1]=d[b-1][a-1]=c;\n    }\n    int cost[4][100];\n    rep(i,4)rep(j,100)cost[i][j]=INF;\n    queue<node> F;\n    node cn;\n    cn.cur=s,cn.flag=0,cn.cost=0;\n    F.push(cn);\n    cost[0][s]=0;\n    while(!F.empty()){\n      int cvis=F.front().flag;\n      int cur=F.front().cur;\n      int ccost=cost[cvis][cur];\n      F.pop();\n      //cout<<\"debug \"<<cvis<<\" \"<<cur<<\" \"<<ccost<<endl;\n      rep(i,n)if(d[cur][i]>0){\n\tint nvis=cvis;\n\tif(i==g1)nvis=cvis|1;\n\tif(i==g2)nvis=cvis|2;\n\tif(cost[nvis][i]>ccost+d[cur][i]){\n\t  cn.cur=i,cn.flag=nvis,cn.cost=ccost+d[cur][i];\n\t  cost[nvis][i]=cn.cost;\n\t  F.push(cn);\n\t}\n\tif(nvis!=cvis){\n\t  cn.cur=cur,cn.flag=nvis,cn.cost=ccost+d[cur][i];\n\t  if(cost[nvis][cur]>cn.cost){\n\t    cost[nvis][cur]=cn.cost;\n\t    F.push(cn);\n\t  }\n\t}\n      }\n    }\n    cout<<cost[3][g1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\nstatic const int INF = 1e9;\n\nvoid solve()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2)\n\t{\n\t\t--s; --g1; --g2;\n\t\tvector< vector<int> > d(n, vector<int>(n));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\t--from; --to;\n\t\t\td[from][to] = cost;\n\t\t\td[to][from] = cost;\n\t\t}\n\t\tfor (int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nconst int kN = 105;\nint atl[kN][kN];\n\nvoid warshallFloyd(int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                atl[i][j] = min(atl[i][j], atl[i][k] + atl[k][j]);\n            }\n        }\n    }\n}\n\nint requestCost(int n, int s, int g1, int g2){\n    int retval = INF;\n    range(i,1,n + 1){\n        int cost = atl[s][i] + atl[i][g1] + atl[i][g2];\n        retval = min(retval, cost);\n    }\n    return retval;\n}\n\nint main(){\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n||m||s||g1||g2){\n        rep(i,kN) rep(j,kN) atl[i][j] = INF;\n        rep(i,kN) atl[i][i] = 0;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            atl[a][b] = c;\n        }\n        warshallFloyd(n);\n        cout << requestCost(n, s, g1, g2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=1000000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=10000000;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[100][100];\n\tint from[100][100];\n\tint n,m,g1,g2,s,a,b,c;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n){\n\t\tint ret = (1<<21);\n\t\ts--;g1--;g2--;\n\t\trep(i,100)rep(j,100)wf[i][j]=(1<<26);\n\t\t//rep(i,100)wf[i][i]=(1<<26);\n\t\trep(i,100)rep(j,100)from[i][j]=(1<<26);\n\t\t\n\t\trep(i,m){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tfrom[a][b] = a;\n\t\t\twf[a][b] = c;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tif(wf[i][j] > wf[i][k]+wf[k][j]){\n\t\t\t\twf[i][j] = wf[i][k]+wf[k][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\tret = min(ret,wf[i][j]+wf[j][g1]+wf[j][g2]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 100;\nconst int INF = 1 << 29;\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m, s, g1, g2;\n\t\tint cost[MAX][MAX];\n\t\tint ans = INF;\n\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, MAX) {\n\t\t\trep(j, MAX) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, m) {\n\t\t\tint b1, b2, c;\n\n\t\t\tcin >> b1 >> b2 >> c;\n\n\t\t\tcost[b1 - 1][b2 - 1] = c;\n\t\t\tcost[b2 - 1][b1 - 1] = c;\n\t\t}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tans = min(ans, cost[s - 1][i] + cost[i][g1 - 1] + cost[i][g2 - 1]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define INF 999999\n\nusing namespace std;\n\nint n,d[101][101];\n\nvoid warshall_floyd(void){\n  \n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j] , d[i][k] + d[k][j]);\n      }\n\t\n}\n \nint main(void){\n\n    int n, m, s, g1, g2, b1, b2, c, d[101][101];\n\n    while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2), n){\n        for(int i = 0; i <= n; ++i){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for(int i = 0; i < m; ++i){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            d[b1][b2] = c;\n        }\n         \n        int ans = INF;\n        for(int i = 1; i <= n; ++i){\n\t  ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, s, g1, g2;\nint matrix[110][110];\n\nint main() {\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n) {\n    MEMSET(matrix, 0x0f);\n    s--; g1--; g2--;\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      f--; t--;\n      matrix[f][t] = c;\n      matrix[t][f] = c;\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n    }\n    int ans = 1 << 30;\n    REP(i, n) {\n      ans = min(ans, matrix[s][i] + matrix[i][g1] + matrix[i][g2]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\tint b1, b2, c;\n\tint k, i, j;\n\tint minCost;\n\n\tvvi cost;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) && n!=0) {\n\n\tcost.resize(n);\n\t\n\tREP(i, n) {\n\t\tcost[i].resize(n);\n\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tcin >> b1 >> b2 >> c;\n\n\t\tcost[b1-1][b2-1] = c;\n\t}\n\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tminCost = cost[s-1][g1-1] + cost[s-1][g2-1];\n\tk = max(g1, g2);\n\n\tFOR(i, s-1, k) {\n\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t}\n\n\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,m,s,g1,g2,d[101][101];\n\nint main(){\n\twhile(cin>>n>>m>>s>>g1>>g2&&n){\n\t\trep(i,n+1)fill(d[i],d[i]+n+1,INF);\n\t\trep(i,n+1)d[i][i]=0;\n\t\tint f,t,c,ans=INF;\n\t\trep(i,m){\n\t\t\tcin>>f>>t>>c;\n\t\t\td[f][t]=c;\n\t\t}\n\t\trep(i,n+1)rep(j,n+1)rep(k,n+1)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\trep(i,n+1)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define\tINF 100000000;\nusing namespace std;\nint mp[1001][1001];\nint d[1001][1001];\nint n,m,s,g1,g2;\n\n\nint main() {\n \n\n\n  while(1) {\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n\n    for(int i=0;i<=n;i++) \n      for(int j=0;j<=n;j++)\n\tif(i == j) mp[i][j] = 0;\n\telse mp[i][j] = INF;\n\n    for(int i=0;i<m;i++) {\n      int b1,b2,c;\n      cin >> b1 >> b2 >> c;\n      mp[b1][b2] = c;\n    }\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++) \n\tfor(int j=1;j<=n;j++)\n\t  mp[i][j] = min(mp[i][j] ,mp[i][k]+mp[k][j]);\n\n    long long  ans = INF;\n    for(int i=1;i<=n;i++){\n      int sum = 0;\n      sum = mp[s][i];\n      sum += mp[i][g1];\n      sum += mp[i][g2];\n\tif(ans > sum) ans = sum;\n    }\n    cout << ans << endl;\n    \n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint dis[101][101];\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 && (n || m || s || g1 || g2)){\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tfill(&dis[0][0], &dis[100][100], INF);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tfrom--; to--;\n\t\t\tdis[from][to] = cost;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j< n; j++){\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tres = min(res, dis[s][i] + dis[i][g1] + dis[i][g2]);\n\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n        \n        \n    const int mx=1e9+7;\n    int n,m,s,go,gt;\n    cin>>n>>m>>s>>go>>gt;\n    if(n==0 && m==0){break;}\n    s--; go--; gt--;\n    int a[1000][1000];\n    fill(&a[0][0],&a[999][1000],mx);\n    for(int i=0;i<n;i++){\n        a[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        int b,c,d;\n        cin>>b>>c>>d;\n        a[b-1][c-1]=d;\n        //a[c-1][b-1]=d;\n    }\n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int k=0;k<n;k++){\n                a[t][k]=min(a[t][i]+a[i][k],a[t][k]);\n            }\n        }\n    }\n    int ans=mx;\n    for(int i=0;i<n;i++){\n        ans=min(a[s][i]+a[i][go]+a[i][gt],ans);\n    }\n        \n        /*\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                cout<<(a[i][t]==mx? -1:a[i][t])<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n        */\n        \n        \n    assert(ans!=mx);\n    cout<<ans<<endl;\n    \n    \n    \n    \n    \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define N 100\nconst int infty = 1<<28;\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n};\nstruct State{\n  int now;\n  int cost;\n  State():now(-1),cost(infty){}\n  State(int pos,int c):now(pos),cost(c){}\n  bool operator>(const State &t)const{return cost>t.cost;}\n};\ntypedef vector<Node> Graph;\nint dijkstra(int s, int g, Graph &G)\n{\n  int A[G.size()];\n  bool vis[G.size()];\n  priority_queue< State,vector<State>,greater<State> > qs;\n  fill(A,A+G.size(),infty);\n  fill(vis,vis+G.size(),false);\n  qs.push(State(s,0));\n  A[s]=0;\n  while(!qs.empty()){\n    State now=qs.top();qs.pop();\n    if(vis[now.now])continue;\n    vis[now.now]=true;\n    for(int i=0;i<G[now.now].con.size();++i){\n      int next_id=G[now.now].con[i];\n      if(now.cost+G[now.now].cost[i]<A[next_id]){\n\tA[next_id]=now.cost+G[now.now].cost[i];\n\tif(!vis[next_id]){\n\t  qs.push(State(next_id,A[next_id]));\n\t}\n      }\n    }\n  }\n  return A[g];\n}\nint main()\n{\n  int n,m,s,g1,g2;\n  while( (cin >> n >> m >> s >> g1 >> g2) && n && m && s && g1 && g2 ){\n    int ans=infty;\n    --s;--g1;--g2;\n    Graph G(n);\n    for(int i = 0; i < m; ++i){\n      int src,dst,cost;\n      cin >> src >> dst>> cost;--src;--dst;\n      G[src].con.push_back(dst);\n      G[src].cost.push_back(cost);\n    }\n    for(int i = 0; i < n; ++i){\n      int tmp=dijkstra(s,i,G)+dijkstra(i,g1,G)+dijkstra(i,g2,G);\n      if(tmp<ans)ans=tmp;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\nconst int INF = 1000000000;\n\nint solve(vector<vector<int> > dist,int s,int g1,int g2){\n    int n = dist.size();\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    int ret = INF;\n    for(int k=0;k<n;k++){\n        ret = min(ret,dist[s][k]+dist[k][g1]+dist[k][g2]);\n    }\n    return ret;\n}\nint main(){\n    while(true){\n        int n,m,s,g1,g2;\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        s--;g1--;g2--;\n        vector<vector<int> > dist(n,vector<int>(n,INF));\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            dist[a][b] = c;\n        }\n        for(int i=0;i<n;i++){\n            dist[i][i] = 0;\n        }\n        cout << solve(dist,s,g1,g2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kMaxN = 1002, kInf = 1 << 28;\nint N, M, S, G1, G2;\nint d[kMaxN][kMaxN];\n\nint main() {\n  while (scanf(\"%d%d%d%d%d\", &N, &M, &S, &G1, &G2), N) {\n    --S; --G1; --G2;\n    \n    // init\n    rep(i,N) fill(d[i], d[i] + N, kInf);\n    rep(i,N) d[i][i] = 0;\n\n    // record\n    int u, v, c;\n    rep(i,M) {\n      scanf(\"%d%d%d\", &u, &v, &c);\n      --u; --v;\n      d[u][v] = c;\n    }\n\n    // warshall froyd\n    rep(k,N) {\n      rep(i,N) {\n        rep(j,N) {\n          d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n      }\n    }\n\n    // search point of k\n    int ret = kInf;\n    rep(k,N) {\n      ret = min(ret, d[S][k] + d[k][G1] + d[k][G2]);\n    }\n    printf(\"%d\\n\", ret);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint cost[100][100];\nint V;\nvoid wf(){\n  for(int k=0;k<V;k++){\n    for(int i=0;i<V;i++){\n      for(int j=0;j<V;j++){\n\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n      }\n    }\n  }\n}\n\nmain(){\n  int m,s,g1,g2;\n  while(cin>>V>>m>>s>>g1>>g2){\n    if(V==0)break;\n    for(int i=0;i<V;i++){\n      for(int j=0;j<V;j++){\n\tcost[i][j]=100000;\n      }\n      cost[i][i]=0;\n    }\n\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      --b1;--b2;\n      cost[b1][b2]=c;\n    }\n    --s;--g1;--g2;\n    wf();\n    int ans=2<<20;\n    for(int i=0;i<V;i++){\n      ans=min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF 10000000\n\nint main()\n{\n  int n,m,s,g1,g2;\n  for(;cin>>n>>m>>s>>g1>>g2,n;)\n    {\n      int d[n][n];\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  if(i==j)\n\t    d[i][j]=0;\n\t  else\n\t    d[i][j]=INF;\n      for(int i=0;i<m;i++)\n\t{\n\t  int b1,b2,c;\n\t  cin>>b1>>b2>>c;\n\t  d[b1-1][b2-1]=c;\n\t}\n      \n      for(int k=0;k<n;k++)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    {\n\t      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t    }\n      int mins=d[s-1][g1-1]+d[s-1][g2-1];\n      for(int k=0;k<n;k++)\n\t{\n\t  mins=min(mins,d[s-1][k]+d[k][g1-1]+d[k][g2-1]);\n\t}\n      cout<<mins<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 10000001\n\n#define MAX_SIZE 101\nlong long g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tfor (int k = 0; k < v; ++k) {\n\t\tfor (int i = 0; i < v; ++i) {\n\t\t\tfor (int j = 0; j < v; ++j) {\n\t\t\t\tg_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"Text.txt\", \"r\", stdin);\n\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\tfill(g_d[0], g_d[0] + MAX_SIZE*MAX_SIZE, INF);\n\t\tfor (int i = 0; i<MAX_SIZE; ++i) {\n\t\t\tg_d[i][i] = 0;\n\t\t}\n\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tint b1,b2;\n\t\t\tcin >> b1 >> b2;\n\t\t\t--b1; --b2;\n\t\t\tcin >> g_d[b1][b2];\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tlong long cost = INF;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[111][111];\n  for(int i=0;i<111;i++){\n    for(int j=0;j<111;j++){\n      road[i][j]=INF;\n    }\n  }\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> Matrix warshallFloyd(const Graph &g) {\n  int n = g.size();\n  Matrix d(n, Array(n, inf));\n  rep(i, n) d[i][i] = 0;\n  for (auto &adj : g) {\n    for (auto &e : adj) cmin(d[e.src][e.dst], e.weight);\n  }\n  rep(k, n) rep(i, n) rep(j, n) {\n    if (d[i][k] != inf && d[k][j] != inf) cmin(d[i][j], d[i][k] + d[k][j]);\n  }\n  return d;\n}\n\nmain {\n  int n, m, s, g1, g2;\n  while (cin >> n >> m >> s >> g1 >> g2, n) {\n    --s, --g1, --g2;\n    Graph g(n);\n    while (m--) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      --b1, --b2;\n      g.addEdge(b1, b2, c);\n    }\n    Matrix d = warshallFloyd<INF>(g);\n    int mini = INF;\n    rep(i, n) cmin(mini, d[s][i] + d[i][g1] + d[i][g2]);\n    cout << mini << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=1000000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=10000000;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<=101;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst int INF = 1 << 28;\nint n, m, s, g1, g2;\nint dist[110][110];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> n >> m >> s >> g1 >> g2, n) {\n    s--, g1--, g2--;\n    fill_n((int*)dist, 110 * 110, INF);\n    for (int i = 0; i < n; i++) {\n      dist[i][i] = 0;\n    }\n    for (int i = 0; i < m; i++) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--, b2--;\n      dist[b1][b2] = c;\n    }\n    for (int k = 0; k < n; k++) {\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      ans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nint n, m, s, g1, g2;\nint d[110][110];\n\nvoid init(int n){\n   rep(i, 0, n){\n       rep(j, 0, n){\n           d[i][j] = INF;\n           if(i == j) d[i][j] = 0;\n       }\n   }\n}\n\nvoid warshall_floyd(){\n   rep(k, 0, n){\n       rep(i, 0, n){\n           rep(j, 0, n){\n               d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n           }\n       }\n   }\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n + m + s + g1 + g2 == 0) break;\n        init(n);\n        s--; g1--; g2--;\n        rep(i, 0, m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            d[a][b] = c;\n        }\n        warshall_floyd();\n        int MIN = INF;\n        rep(i, 0, n){\n            int tmp = d[s][i] + d[i][g1] + d[i][g2];\n            chmin(MIN, tmp);\n        }\n        cout << MIN << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\nusing ll = long long;\n\nint N, M, s, g1, g2;\nll dist[101][101];\nvoid init() {\n    REP(i, N) {\n        REP(j, N) { dist[i][j] = 1e9; }\n    }\n    REP(i, N) dist[i][i] = 0;\n}\n\nbool solve() {\n    cin >> N >> M >> s >> g1 >> g2;\n    if (N == 0) return false;\n    init();\n    REP(i, M) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        u--, v--;\n        dist[u][v] = c;\n    }\n    s--, g1--, g2--;\n    REP(k, N) REP(i, N) REP(j, N) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); }\n    int ans = 1e9;\n    REP(m, N) { ans = min(ans, dist[s][m] + dist[m][g1] + dist[m][g2]); }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=101;\nconst int INF=(1<<21);\n\nint main(){\n  int n, m;\n  int s, g1, g2;\n  int pipe[MAX][MAX];\n\n  while( cin >> n >> m >> s >> g1 >> g2 ) {\n\n    if( n==0 && m==0 && s==0 && g1==0 && g2==0 ) break;\n    \n    for(int i=0; i<=n; i++) {\n      for(int j=0; j<=n; j++) {\n\tpipe[i][j] = INF;\n      }\n      pipe[i][i] = 0;\n    }\n    \n    for(int i=0; i<m; i++) {\n      int b1, b2, c; \n      cin >> b1 >> b2 >> c;\n      pipe[b1][b2] = c;\n    }\n    \n    for(int i=1; i<=n; i++) {\n      for(int j=1; j<=n; j++) {\n\tfor(int k=1; k<=n; k++) {\n\t  pipe[j][k] = min(pipe[j][k], pipe[j][i]+pipe[i][k]);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=1; i<=n; i++) {\n      ans = min(ans, pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<28)\n\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int from, int to, int cost) :from(from), to(to), cost(cost) {}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n | m || s | g1 | g2) {\n\t\tn; m; s--; g1--; g2--;\n\t\tvector<vector<edge>> Graph(n);\n\t\tvector<vector<int>> dist(n, vector<int>(n, INF));\n\t\tfor (int i = 0; i < m;i++) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tGraph[b1].push_back(edge(b1, b2, c));\n\t\t}\n\n\t\tfor (int v_s = 0; v_s < n; v_s++) {\n\t\t\tqueue<int> q; q.push(v_s);\n\t\t\tdist[v_s][v_s] = 0;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint now = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < Graph[v_s].size();i++) {\n\t\t\t\t\tint next = Graph[v_s][i].to;\n\t\t\t\t\tint cost = Graph[v_s][i].cost;\n\n\t\t\t\t\tif (dist[v_s][next] > dist[v_s][now] + cost) {\n\t\t\t\t\t\tdist[v_s][next] = dist[v_s][now] + cost;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n){\n\t\tint d[101][101];\n\t\trep(i, 101)rep(j, 101)d[i][j] = (i == j ? 0 : INF);\n\t\t\n\t\trep(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = c;\n\t\t}\n\n\t\tFor(k,1, n+1)For(i,1, n+1)For(j,1, n+1){\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tFor(k, 1, n + 1){\n\t\t\tint tmp = 0;\n\t\t\ttmp += d[s][k];\n\t\t\ttmp += d[k][g1];\n\t\t\ttmp += d[k][g2];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 10000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = table[j][k] < table[j][i] + table[i][k] ?\n\t\t\t\t\ttable[j][k] : table[j][i] + table[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct P{\n\tint p,c,f[105];\n\t//int operator <(const P a){return p<a.p;};\n}P;\n\nstruct Order\n{\n\tbool operator ()(P const& a, P const& b) const\n\t{\n\t\treturn a.c>b.c;\n\t}\n};\n\n\nint N,M,S,G1,G2,C[105][105];\nint main()\n{\n\tfor(;scanf(\"%d%d%d%d%d\",&N,&M,&S,&G1,&G2),N;)\n\t{\n\t\tS--;G1--;G2--;\n\t\tmemset(C,0,sizeof(C));\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint f,t,c;\n\t\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\t\tf--;t--;\n\t\t\tC[f][t]=C[t][f]=c;\n\t\t}\n\t\tpriority_queue<P,vector<P>,Order> Q;\n\t\tP tmp;tmp.p=S;tmp.c=0;\n\t\tmemset(tmp.f,0,sizeof(tmp.f));tmp.f[S]=1;\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tif(tmp.f[G1]&&tmp.f[G2])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",tmp.c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tif(C[tmp.p][i])\n\t\t\t\t{\n\t\t\t\t\tif(tmp.f[i]==1&&i!=G1&&i!=G2)//alrady passed\n\t\t\t\t\t{\n\t\t\t\t\t\tP ins=tmp;\n\t\t\t\t\t\tins.f[i]++;\n\t\t\t\t\t\tins.p=i;\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t\telse if(tmp.f[i]==0)//new node\n\t\t\t\t\t{\n\t\t\t\t\t\tP ins=tmp;\n\t\t\t\t\t\tins.f[i]++;\n\t\t\t\t\t\tins.c+=C[tmp.p][i];\n\t\t\t\t\t\tins.p=i;\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 100\n#define min(a,b) (a>b?b:a)\n#define INF 100000000\n\nint main() {\n\tint n, m, s, g1, g2, b1, b2, c, ans;\n\tint cost[N+1][N+1];\n\twhile(1) {\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(!n&&!m&&!s&&!g1&&!g2) break;\n\t\tfor(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) {\n\t\t\tcost[i][j] = (i==j?0:INF);\n\t\t}\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tcost[b1][b2] = cost[b2][b1] = c;\n\t\t}\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tfor(int j=1; j<=n; ++j) {\n\t\t\t\tfor(int k=1; k<=n; ++k) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tans = min(cost[s][i]+cost[i][g1]+cost[i][g2], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n#include <string.h>\n#include <numeric>\nusing namespace std;\n\n#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(i,v) for(auto &(i):(v))\n#define eachr(i,v) for(auto &(i)=(v).rbegin();(i)!=(v).rend();(i)++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n#define endl \"\\n\"\n\n//typedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b=mod-2,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a/gcd(a,b)*b;}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n    oreno_initializer() {\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n    }\n} oreno_initializer;\n\n\n\nint n, m, s, g1, g2, x, y, z, d[111][111];\nvector<pair<int,int> > e[111];\n\nvoid dijkstra(int st) {\n    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\n    q.push({0,st});\n    while(!q.empty()) {\n        int v = q.top().second, dis = q.top().first; q.pop();\n        if (d[st][v]<dis) continue;\n        for (int i = 0; i < e[v].size(); ++i) {\n            int to = e[v][i].first, cost = e[v][i].second;\n            if (d[st][to] > d[st][v] + cost) {\n                d[st][to] = d[st][v] + cost;\n                q.push({d[st][to], to});\n            }\n        }\n    }\n}\n\nsigned main() {\n    while (1) {\n        cin >> n >> m >> s >> g1 >> g2;\n        if (n==0) break;\n        rep(i,n) e[i].clear();\n        rep(i,n) rep(j,n) if (i!=j) d[i][j] = 1<<30;\n        s--, g1--, g2--;\n        rep(i,m) {\n            cin >> x >> y >> z;\n            x--, y--;\n            e[x].push_back({y, z});\n        }\n\n        rep(i,n) dijkstra(i);\n        int res = 1<<30;\n        rep(i,n) chmin(res, d[s][i] + d[i][g1] + d[i][g2]);\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define INF 100000000\nint d[101][101],n,m,s,g1,g2;\nint min(int a,int b){\n\tif(a<b){\n\t\treturn a;\n\t}else{\n\t\treturn b;\n\t}\n}\nvoid warsall_floyd(){//warsall_floyd 中継地点のループを一番外側にしてみた\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\t\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\twhile(1){\n\t\tint a,b,c,ans=INF;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<101;j++){\n\t\t\t\td[i][j]=INF;\n\t\t\t}\n\t\t\td[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\twarsall_floyd();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, m, s, g1, g2;\nint c[100][100];\n\nint main(){\n\tint a1, a2, a3;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n != 0) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tc[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a1 >> a2 >> a3;\n\t\t\tc[a1][a2] = a3;\n\t\t}\n\t\tbool yet = true;\n\t\twhile (yet) {\n\t\t\tyet = false;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (c[i][j] > c[i][k] + c[k][j]) {\n\t\t\t\t\t\t\tc[i][j] = c[i][k] + c[k][j];\n\t\t\t\t\t\t\tyet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = c[s][g1] + c[s][g2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ans > c[s][i] + c[i][g1] + c[i][g2]) {\n\t\t\t\tans = c[s][i] + c[i][g1] + c[i][g2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint N, M, S, G1, G2;\nint d[100][100];\n\nint main(){\n    std::cin >> N >> M >> S >> G1 >> G2;\n    --S; --G1; --G2;\n    \n    REP(i, N){\n        REP(j, N){\n            if(i == j){d[i][j] = 0;}\n            else{d[i][j] = INF;}\n        }\n    }\n\n    REP(i, M){\n        int from, to, cost;\n        std::cin >> from >> to >> cost;\n        --from; --to;\n        \n        d[from][to] = cost;\n    }\n\n    REP(k, N){\n        REP(i, N){\n            REP(j, N){\n                d[i][j] = std::min(d[i][j], d[i][k]+d[k][j]);\n            }\n        }\n    }\n\n    int res = INF;\n    REP(i, N){\n        res = std::min(res, d[S][i]+(d[i][G1]+d[i][G2]));\n    }\n\n    std::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;/*}}}*/\n\n#define MAX_N 100\n#define INF (LONG_MAX / 10)\nint n, m, s, g1, g2;\nLL dist[MAX_N][MAX_N];\nint main(int argc, char const* argv[])\n{\n\twhile(cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\t--s; --g1; --g2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a; --b;\n\t\t\tdist[a][b] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLL ans = INF;\n\t\tfor (int div = 0; div < n; div++) { // where to divide\n\t\t\tLL cost = dist[s][div] + dist[div][g1] + dist[div][g2];\n\t\t\tans = min(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 24)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\n#ifdef _DEBUG\n#define DEBUG WRITE\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\n#else\n#define DEBUG(...)\ninline void readfrom(...) { }\ninline void writeto(...) { }\n#endif\n#ifdef colored_cout\n#  define cout colored_cout\n#  define endl colored_endl\n#endif\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, const pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << \"\";\n\tauto s = ss.str();\n\tout << s.substr(0, s.length());\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator > (const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n, m, s, g1, g2);\n\t\tif (!n) { break; }\n\t\ttypedef Path<int> P;\n\t\tvevector<P> graph(n), reverse_graph(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tREAD(int, b1, b2, c);\n\t\t\tgraph[b1 - 1].push_back(P(b1 - 1, b2 - 1, c));\n\t\t\treverse_graph[b2 - 1].push_back(P(b2 - 1, b1 - 1, c));\n\t\t}\n\t\tvector<int> x = dijkstra(graph, s - 1).first;\n\t\tvector<int> y = dijkstra(reverse_graph, g1 - 1).first;\n\t\tvector<int> z = dijkstra(reverse_graph, g2 - 1).first;\n\n\t\tint result = INF;\n\t\tREP(i, n) result = min(result, x[i] + y[i] + z[i]);\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int INF = (int)1e18;\n\nvoid WF(vector<vector<int>> &G){\n  int n = G.size();\n  \n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < n; k++){\n        G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n      }\n    }\n  }\n}\n\nsigned main(){\n\n  while(true){\n    int n, m, s, g1, g2;\n    vector<vector<int>> G;\n    int ans = INF;\n\n    cin>>n>>m>>s>>g1>>g2;\n\n    if(!n) break;\n\n\n    s--, g1--, g2--;\n    G.resize(n,vector<int>(n, INF));\n\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n\n      cin>>a>>b>>c;\n      a--, b--;\n      \n      G[a][b] = c;\n    }\n\n    for(int i = 0; i < n; i++){\n      G[i][i] = 0;\n    }\n    WF(G);\n\n    for(int i = 0; i < n; i++){\n      ans = min(ans, G[s][i] + G[i][g1] + G[i][g2]);\n    }\n\n    cout<<ans<<endl;\n    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n){\n\t\tvector<vector<int>> load(n + 1, vector<int>(n + 1, 100000000));//from back to \n\t\tREP(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tload[b1][b2] = c;\n\t\t}\n\n\t\tFOR(i, 1, n + 1)load[i][i] = 0;\n\n\t\tFOR(i, 1, n + 1){\n\t\t\tFOR(j, 1, n + 1){\n\t\t\t\tFOR(k, 1, n + 1){\n\t\t\t\t\tload[j][k] = min(load[j][k], load[j][i] + load[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 100000000;\n\t\tFOR(i, 1, n + 1){\n\t\t\tans = min(ans,load[s][i]+load[i][g1]+load[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2&&n;) {\n\t\ts--, g1--, g2--;\n\t\tstatic const int N = 101;\n\t\tstatic int wf[N][N];\n\t\trep(i, 0, n)rep(j, 0, n)wf[i][j] = INF;\n\t\trep(i, 0, n)wf[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint s, d, w; cin >> s >> d >> w;\n\t\t\ts--, d--;\n\t\t\twf[s][d] = min(wf[s][d], w);\n\t\t}\n\n\t\trep(k, 0, n)rep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (wf[i][k] != INF&&wf[k][j] != INF)\n\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(k, 0, n) {\n\t\t\tchmin(ans, wf[s][k] + wf[k][g1] + wf[k][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e8\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, s, g1, g2;\nint E[101][101];\nint dp[101][101];\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    s--; g1--; g2--;\n    rep(i, n) rep(j, n) E[i][j] = INF;\n    rep(i, m){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      E[b1][b2] = c;\n      E[b2][b1] = c;\n    }\n    //rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) dp[i][j] = E[i][j];\n    bool changed = true;\n    while(changed){\n      changed = false;\n      rep(i, n){\n\trep(j, n){\n\t  rep(k, n){\n\t    if(dp[i][j] > dp[i][k] + dp[k][j]){\n\t      dp[i][j] = dp[i][k] + dp[k][j];\n\t      changed = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int ans = INF;\n    rep(br, n){\n      ans = min(ans, dp[s][br] + dp[br][g1] + dp[br][g2]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\n#define INF 1000000000\nint route[101][101];\nint d[101];//スタートからの距離\nint d2[101];//分岐からの距離\nint n,m;\nint min(int a,int b){\n    if(a<b){\n        return a;\n    }else{\n        return b;\n    }\n}\nint di(int st){\n    int s[101],k,num,i,j;\n    for(i=0;i<101;i++){\n        s[i]=0;\n        d[i]=INF;\n    }\n    d[st]=0;\n    for(i=0;i<101;i++){\n        k=INF;\n        for(j=0;j<=n;j++){\n            if(s[j]==0){\n                if(k>d[j]){\n                    k=d[j];num=j;\n                }\n            }\n        }\n\t\ts[num]=1;\n        for(j=0;j<=n;j++){\n            if(route[num][j]!=INF){\n\t\t\t\td[j]=min(d[j],d[num]+route[num][j]);\n\t\t\t}\n        }\n    }\n    return 0;\n}\nint di2(int st){\n    int s[101],k,num,i,j;\n    for(i=0;i<101;i++){\n        s[i]=0;\n        d2[i]=INF;\n    }\n    d2[st]=0;\n    for(i=0;i<101;i++){\n        k=INF;\n        for(j=0;j<=n;j++){\n            if(s[j]==0){\n                if(k>d2[j]){\n                    k=d2[j];num=j;\n                }\n            }\n        }\n\t\ts[num]=1;\n\t\tfor(j=0;j<=n;j++){\n\t        if(route[num][j]!=INF){\n\t\t\t\t\td2[j]=min(d2[j],d2[num]+route[num][j]);\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}\nint main(){\n\twhile(1){\n\t\tint a,b,c,s,g1,g2,i,j,gr1[101],gr2[101],sum=0;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\tfor(i=0;i<101;i++){\n\t\t\tfor(j=0;j<101;j++){\n\t\t\t\troute[i][j]=INF;\n\t\t\t}\n\t\t\troute[i][i]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\troute[a][b]=c;\n\t\t}\n\t\tdi(s);//スタートからの距離をダイクストラでd[]\n\t\tsum=d[g1]+d[g2];\n\t\tfor(i=1;i<=n;i++){\n\t\t\tdi2(i);//点をひとつ選んで、分岐にする。その分岐からの距離がd2[]\n\t\t\tsum=min(sum,d[i]+d2[g1]+d2[g2]);\t\n\t\t}\t\t\n\t\tcout<<sum<<endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(void)\n{\n\tint n, m, s, g1, g2;\n\tint data[128][128];\n\tint a, b, c;\n\t\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n && m){\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tdata[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tdata[a][b] = c;\n\t\t}\n\t\t\n\t\t// わーしゃるふろいど\n\t\tfor (int k = 1; k <= n; k++){\n\t\t\tfor (int i = 1; i <= n; i++){\n\t\t\t\tfor (int j = 1; j <= n; j++){\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = data[s][g1] + data[s][g2];\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tret = min(ret, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    warshallFloyd(g, n);\n    // pma(g, n);\n    \n    int ans = -1;\n    REP(i, n){\n        if(g[s][i] != -1 && g[i][g1] != -1 && g[i][g2] != -1){\n            int cost = g[s][i] + g[i][g1] + g[i][g2];\n            if(ans == -1) ans = cost;\n            else ans = min(ans, cost);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include <functional>\n#define INF 1000000\nusing namespace std;\ntypedef long long ll;\nstruct edge { int to, cost; };\ntypedef pair<ll, int> P;\n\n\nint V;\nvector<edge> G[1010];\nll d[105];\n\nll dijkstra(int s,int g) {\n\tpriority_queue<P, vector<P>,greater<P>> que;\n\tfill(d, d + V, 1000000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!(que.empty())) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main() {\n\twhile (true) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tll ans;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0)break;\n\t\ts--; g1--; g2--;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e;\n\t\t\te.to = b - 1; e.cost = c;\n\t\t\tG[a - 1].push_back(e);\n\t\t}\n\t\tans = min(dijkstra(s, g1)+dijkstra(g1,g2),dijkstra(s,g2)+dijkstra(g2,g1));\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 9999999\n#define MAX 101\n\nint main(){\n    int n,m,s,g1,g2,d[MAX+1][MAX+1],a,b,c;\n    while(cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2){\n        fill(d[0],d[MAX],INF);\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            d[a][b] = c;\n            d[b][a] = c;\n        }\n        \n        for(int k = 1 ; k <= n ; k++)\n            for(int i = 1 ; i <= n ; i++)\n                for(int j = 1 ; j <= n ; j++)\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        \n        int res = INF;\n        for(int i = 1 ; i <= n ; i++){\n            res = min(res,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\n#define INF 0x1FFFFFFF\n\nusing namespace std;\n\nint main(void){\n\tint n, m, s, c, g1, g2, b1, b2, i, j, k, ans, w[100][100];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\ts--, g1--, g2--;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++) w[i][j] = INF;\n\t\t\tw[i][i] = 0;\n\t\t}\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tw[b1 - 1][b2 - 1] = c;\n\t\t\tw[b2 - 1][b1 - 1] = c;\n\t\t}\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\tw[j][k] = min(w[j][k],w[j][i] + w[i][k]);\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tans = min(ans,w[i][s] + w[i][g1] + w[i][g2]);\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n???road[k][g[0]]+road[k][g[1]]??????(k:any????????§)????°????????????¨?????£??????\n???road[s][k]?????§??????????????¨??????????°??????¨??????????????????\n??????road[k][g[0]]+road[k][g[1]]?????§???????????????road[s][k]????°????????????°???????¨????????°?????????????\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n ,m, s, g[2];\nint road[105][105];\n\nint main() {\n  while(1){\n    cin>>n>>m>>s>>g[0]>>g[1];\n    if(n==0) break;\n    s--; g[0]--; g[1]--;\n    REP(i,0,n)REP(j,0,n){\n      if(i==j) road[i][j] = 0;\n      else road[i][j] = INF;\n    }\n    REP(i,0,m){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      b1--; b2--;\n      road[b1][b2] = c;\n    }\n    REP(k,0,n){\n      REP(from,0,n){\n        REP(to,0,n){\n          road[from][to] = min(road[from][to], road[from][k]+road[k][to]);\n        }\n      }\n    }\n    int ans = INF;\n    REP(k,0,n){\n      REP(from,0,n){\n        REP(to,0,n){\n          ans = min(ans, road[s][k] + road[k][g[0]] + road[k][g[1]]);\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost<b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=10000000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=10000000;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost<b.cost;\n}\n\nint n,m,s,g1,g2;\n\nint edge[101][101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tmemset(edge,-1,sizeof(edge));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tedge[in][out]=edge[out][in]=c;\n\t\t}\n\t\tint ans=100000000;\n\n\t\tfor(int i=0;i<=100;i++){\n\t\t\tint dist[101];\n\t\t\tfor(int j=0;j<101;j++)\n\t\t\t\tdist[j]=100000000;\n\n\t\t\tpriority_queue<state> Q;\n\t\t\tQ.push(state(i,0));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate t=Q.top();\n//\t\t\t\tcout<<t.now<<\" \"<<t.cost<<endl;\n\t\t\t\tQ.pop();\n\t\t\t\tif(dist[t.now]<t.cost) continue;\n\t\t\t\tdist[t.now]=t.cost;\n\t\t\t\tfor(int k=0;k<101;k++){\n\t\t\t\t\tif(edge[t.now][k]>=0){\n\t\t\t\t\t\tQ.push(state(k,t.cost+edge[t.now][k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout<<dist[s]<<\" \"<<dist[g1]<<\" \"<<dist[g2]<<endl;\n\t\t\tans=min(ans,dist[s]+dist[g1]+dist[g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#define INF 1<<29\n#define MAX 3000\nusing namespace std;\nint cost[MAX][MAX],V,d[MAX][MAX];\nbool used[MAX][MAX];\n\nvoid dijkstra(int);\n\nint main(){\n  int m,s,g1,g2,b1,b2,c;\n\n  while(true)\n    {\n      cin >> V >> m >> s >> g1 >> g2;\n      if(V == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)break;\n      for(int i=1;i<=V;i++)\n\t{\n\t  for(int j=1;j<=V;j++)\n\t    {\n\t      cost[i][j]=INF;\n\t      d[i][j] = INF;\n\t    }\n\t}\n\n\t  for(int i=0;i<m;i++)\n\t{\n\t  cin >> b1 >> b2 >> c;\n\t  cost[b1][b2]=c;\n\t}\n\n      int ans = INF;\n      //cout << ans << endl;\n      for(int i=1;i<=V;i++)\n\t{\n\t  dijkstra(i);\n\t  // cout << ans << endl;\n\t  /*cout << \"i = \" << i << endl;\n\t    for(int j=1;j<=V;j++)\n\t    {\n\t      for(int k=1;k<=V;k++)cout << d[j][k] << \" \" ;\n\t      cout << endl;\n\t    }\n\t  */\n\t}\n      for(int i=1;i<=V;i++)\n\t{\n\t  ans = min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t}\n\n      cout << ans << endl;\n    }\n}\n\nvoid dijkstra(int s)\n{\n  for(int i=1;i<=V;i++)\n    {\n\t  d[s][i]=INF;\n\t  used[s][i]=false;\n    }\n  d[s][s] = 0;\n\n  while(true)\n    {\n      int v=-1;\n      for(int u=1;u<=V;u++)\n\t{\n\t  if(!used[s][u] && (v == -1 || d[s][u] < d[s][v]))v = u;\n\t}\n      if(v == -1)break;\n      used[s][v]=true;\n      for(int u=1;u<=V;u++)\n\t{\n\t  d[s][u]=min(d[s][u],d[s][v]+cost[v][u]);\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n\nusing namespace std;\n\nconst int INF=10000000;\n\nint field[101][101];\nint costs;\nint s,g1,g2;\nint n,m;\nint f,t,c;\n\nvoid root(){\n\tint a,b;\n\tfield[f][t]=min(field[f][t],c);\n\tfor(b=1;b<=n;b++){\n\t\tfor(a=1;a<=n;a++){\n\t\t\tfield[a][b]=min(field[a][b],field[a][f]+field[f][t]+field[t][b]);\n\t\t}\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tcosts=min(costs,field[s][a]+field[a][g1]+field[a][g2]);\n\t}\n}\n\nint main(void){\n\tint a,b;\n\twhile(1){\n\t\tfor(b=0;b<=100;b++){\n\t\t\tfor(a=0;a<=100;a++){\n\t\t\t\tfield[a][b]=INF;\n\t\t\t\tif(a==b)field[a][b]=0;\n\t\t\t}\n\t\t}\n\t\tcosts=INF;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\t\tfor(a=0;a<m;a++){\n\t\t\tcin >> f >> t >> c;\n\t\t\troot();\n\t\t}\n\t\tcout << costs << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\nvector<ll> daikus(vector<vector<mp> > &g,ll s){\n\tint n = g.size();\n\tvector<ll> c(n,inf);\n\tvector<ll> used(n,true);\n\tpriority_queue<mp,vector<mp> , greater<mp> > q;\n\tq.push( mp(0,s) );\n\twhile(!q.empty() ){\n\t\tmp now = q.top();\n\t\tq.pop();\n\t\tll nc = now.first;\n\t\tll nn = now.second;\n\t\tif(used[nn] && c[nn] > nc){\n\t\t\tused[nn] = false;\n\t\t\tc[nn] = min(c[nn],nc);\n\t\t\tfor(ll i=0;i<g[nn].size();i++){\n\t\t\t\tll next = g[nn][i].second;\n\t\t\t\tll nec = nc + g[nn][i].first;\n\t\t\t\tif(used[next]){\n\t\t\t\t\tq.push( mp(nec,next) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn c;\n}\n\n\nint main(){\n\twhile(1){\n\t\tll n,m,s,g1,g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tif(n==0)break;\n\t\tvector<vector<mp> > g(n),rg(n);\n\t\tfor(ll i=0;i<m;i++){\n\t\t\tll ss,t,c;\n\t\t\tcin>>ss>>t>>c;\n\t\t\tss--;\n\t\t\tt--;\n\t\t\tg[ss].push_back( mp(c,t) );\n\t\t\trg[t].push_back( mp(c,ss) );\n\t\t}\n\t\tvector<ll> sm = daikus(g,s),g1m = daikus(rg,g1),g2m = daikus(rg,g2);\n\t\tll res = inf;\n\t\tfor(ll i= 0;i<n;i++){\n\t\t\tres = min(res, sm[i]+g1m[i]+g2m[i]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef struct edge{\n  int to, cost;\n}edge;\n\nint main(){\n  int n, m, s, a, b, from, to, cost;\n  while(cin >> n >> m >> s >> a >> b, n){\n    s--, a--, b--;\n    vector<vector<edge> > g(n);\n    for(int i = 0; i < m; i++){\n      cin >> from >> to >> cost;\n      from--, to--;\n      g[from].push_back(edge{to, cost});\n    }\n    vector<vector<int> > dp(n, vector<int>(n, 1e8));\n    dp[s][s] = 0;\n    for (int i = 0; i < g[s].size(); i++) dp[s][g[s][i].to] = dp[g[s][i].to][s] = g[s][i].cost;\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < n; k++) {\n          for (int l = 0; l < g[j].size(); l++) {\n            if(k == g[j][l].to)dp[k][g[j][l].to] = dp[g[j][l].to][k] = min(dp[k][g[j][l].to], dp[j][k]);\n            else dp[k][g[j][l].to] = dp[g[j][l].to][k] = min(dp[k][g[j][l].to], dp[j][k] + g[j][l].cost);\n          }\n          for (int l = 0; l < g[k].size(); l++) {\n            if(j == g[k][l].to)dp[j][g[k][l].to] = dp[g[k][l].to][j] = min(dp[j][g[k][l].to], dp[j][k]);\n            else dp[j][g[k][l].to] = dp[g[k][l].to][j] = min(dp[j][g[k][l].to], dp[j][k] + g[k][l].cost);\n          }\n        }\n      }\n    }\n    // for (int i = 0; i < n; i++) {\n    //   for (int j = 0; j < n; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    std::cout << dp[a][b] << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint dis[123][123];\nvpint road[123];\nint n,m,s,g1,g2;\n\nint main() {\n\tIL{\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\t--s,--g1,--g2;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t--a,--b;\n\t\t\troad[a].PB(MP(b,c));\n\t\t\troad[b].PB(MP(a,c));\n\t\t}\n\t\trep(i,n)rep(j,n)dis[i][j]=INF;\n\t\trep(i,n){\n\t\t\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\t\t\tque.push(MP(0,i));\n\t\t\twhile(!que.empty()){\n\t\t\t\tpint now=que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif(dis[i][now.second]<=now.first)continue;\n\t\t\t\tdis[i][now.second]=now.first;\n\t\t\t\trep(j,sz(road[now.second])){\n\t\t\t\t\tif(dis[i][road[now.second][j].first]<=now.first+road[now.second][j].second)continue;\n\t\t\t\t\tque.push(MP(now.first+road[now.second][j].second,road[now.second][j].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\trep(i,n){\n\t\t\tchmin(res,dis[s][i]+dis[i][g1]+dis[i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint d[105][105], to[105][105];\n\nvoid warshall_floyd(int n, int m) {\n\trep(i, n) rep(j, n) d[i][j] = INF;\n\trep(i, n) d[i][i] = 0;\n\n\trep(i, n) rep(j, n) to[i][j] = j;\n\n\t//input\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\n\t\ta--; b--;\n\t\td[a][b] = c;\n\t\td[b][a] = c;\n\t}\n\n\trep(k,n) {\n\t\trep(i,n) {\n\t\t\trep(j,n) {\n\t\t\t\tif(d[i][k] == INF || d[k][j] == INF) continue;\n\t\t\t\tif(d[i][j] > d[i][k] + d[k][j]) {\n\t\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> path(int s, int g) {\n\tint cur = s;\n\tvector<int> ret;\n\tfor(; cur != g; cur = to[cur][g]) {\n\t\tret.push_back(cur);\n\t}\n\n\tret.push_back(g);\n\treturn ret;\n}\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2) {\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\n\t\ts--; g1--; g2--;\n\t\twarshall_floyd(n, m);\n\n\t\t// rep(i, n) {\n\t\t// \trep(j, n) {\n\t\t// \t\tif(d[i][j] == INF) cout << \"X \";\n\t\t// \t\telse cout << d[i][j] << \" \";\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\n\n\t\tint ans = INF;\n\t\trep(i, n) {\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tans = min(ans, d[s][g1] + d[g1][g2]);\n\t\tans = min(ans, d[s][g2] + d[g2][g1]);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF 1e9\n\nint main() {\n    int town_n, road_n, start, goal1, goal2;\n    while (cin >> town_n >> road_n >> start >> goal1 >> goal2, town_n) {\n        start--;\n        goal1--;\n        goal2--;\n\n        vvi E(town_n, vi(town_n, INF));\n        REP(i, road_n) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            E[a][b] = c;\n        }\n        REP(i, town_n) E[i][i] = 0;\n        REP(i, town_n) REP(j, town_n) REP(k, town_n) E[j][k] = min(E[j][k], E[j][i] + E[i][k]);\n\n        int mi = INF;\n        REP(i, town_n) {\n            mi = min(mi, E[start][i] + E[i][goal1] + E[i][goal2]);\n        }\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nint G[101][101], d[101][101];\n\nvoid init(){\n\tfor(int i=0 ; i < 101 ; i++ ){\n\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\td[i][j] = (i == j)? 0 : INF;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile( cin >> n >> m >> s >> g1 >> g2 , n ){\n\t\ts--; g1--; g2--;\n\t\tinit();\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\tG[u][v] = cost;\n\t\t\td[u][v] = cost;\n\t\t}\n\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , d[i][k] + d[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int v=0 ; v < n ; v++ ){\n\t\t\tans = min( ans , d[s][v] + d[v][g1] + d[v][g2] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  while (1){\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n      break;\n    }\n    s--;\n    g1--;\n    g2--;\n    vector<vector<int>> d(n, vector<int>(n, INF));\n    for (int i = 0; i < n; i++){\n      d[i][i] = 0;\n    }\n    for (int i = 0; i < m; i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--;\n      b2--;\n      d[b1][b2] = c;\n    }\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < n; j++){\n        for (int k = 0; k < n; k++){\n          d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        }\n      }\n    }\n    int ans = INF;\n    for (int i = 0; i < n; i++){\n      ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\tg1--; g2--; s--;\n\t\tvector<vector<int> >d(n, vector<int>(n, 1000000));\n\t\trep(i, 0, n)d[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c; b1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\trep(k, 0, n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    warshallFloyd(g, n);\n    // pma(g, n);\n    \n    int ans = g[s][g1] + g[s][g2];\n    REP(i, n){\n        ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        s--; g1--; g2--;\n        if(n == 0) return 0;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<29) - 1;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, S, G1, G2;\n    while(cin >> N >> M >> S >> G1 >> G2, N|M|S|G1|G2){\n        S--; G1--; G2--;\n        vector<vector<int>> G(N, vector<int>(N, INF));\n        while(M--){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            b1--; b2--;\n            G[b1][b2] = G[b2][b1] = c;\n        }\n        \n        for(int k=0; k<N; k++){\n            for(int i=0; i<N; i++){\n                for(int j=0; j<N; j++){\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                    G[j][i] = min(G[j][i], G[j][k] + G[k][i]);\n                }\n            }\n        }\n        \n        int ans = INF;\n        for(int i=0; i<N; i++){\n            ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n        }\n        cout << ans << endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//--------------------------------------------------\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<ctime>\n\nusing namespace std;\n\n//conversion\n//--------------------------------------------------\ninline int toInt(const string &s){\n    int v;istringstream sin(s);sin>>v;\n    return v;\n}\ntemplate<class T> inline string toString(T x){\n    ostringstream sout;sout<<x;\n    return sout.str();\n}\n\n//math\n//--------------------------------------------------\ntemplate<class T> inline T sqr(T x){return x*x;}\n\n//typedef\n//--------------------------------------------------\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n\n//container util\n//--------------------------------------------------\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//--------------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------------\nconst int INF=1e8;\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\n\n//clear memory\n#define CLR(a) memset((a),0,sizeof(a))\n\n//debug\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\"(L\"<<__LINE__<<\")\"<<endl\n\n//---------------------------------------------------\n\nint N,M,S,G1,G2;\nint g[100][100];\nint solve(){\n    REP(k,N)REP(i,N)REP(j,N)\n        g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\n    int mi=INF;\n    REP(i,N)mi=min(mi,g[S][i]+g[i][G1]+g[i][G2]);\n\n    return mi;\n\n}\n\n\nint main(){\n    while(cin>>N>>M>>S>>G1>>G2,N||M||S||G1||G2){\n        S--;G1--;G2--;\n        fill_n(*g,10000,INF);\n        REP(i,N)g[i][i]=0;\n        REP(i,M){\n            int a,b,c;\n            cin>>a>>b>>c;\n            g[--a][--b]=c;\n        }\n        cout<<solve()<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define fst first\n#define scn second\nint main(){\n\twhile(true){\n\t\tint n,m,s,g1,g2;\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)\tbreak;\n\t\ts--;\tg1--;\tg2--;\n\t\tvector<vector<int>> dist(n,vector<int>(n,1e9));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint f,t,d;\tcin>>f>>t>>d;\n\t\t\tf--;\tt--;\n\t\t\tdist[f][t]=d;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=1e9;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tret=min(ret,dist[s][i]+dist[i][g1]+dist[i][g2]);\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919\nusing namespace std;\n\nint dp[110][110];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(F!=dp[i][k]){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(F!=dp[j][k])\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N = 100, INF = (int)1e8;\n\nint n;\nint dp[MAX_N][MAX_N];\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g[2];\n\t\tstd::cin >> n >> m >> s >> g[0] >> g[1];\n\t\t--s;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t--g[i];\n\t\tif (n + m + s + g[0] + g[1] == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i][i] = 0;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tdp[a][b] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdp[j][k] = std::min(dp[j][k], dp[j][i] + dp[i][k]);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = std::min(ans, dp[s][i] + dp[i][g[0]] + dp[i][g[1]]);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\n\nint d[MAX_N][MAX_N];\nint n,m,s,g1,g2;\n\nvoid warshall_floyd()\n{\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        s--,g1--,g2--;\n        if(n==0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = INF;\n            }\n        }\n        rep(i,n){\n            d[i][i] = 0;\n        }\n    \trep(i,m){\n    \t\tint x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            d[x-1][y-1] = z;\n    \t}\n        warshall_floyd();\n        int res = INF;\n        rep(i,n){\n            res = min(res,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>;\nconst int MOD = (int)1e9 + 7, INF = (1 << 27); const ll INFLL = (1LL << 55);\n#define FOR(i,a,b) for(int (i)=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\ntemplate<typename T, typename U> static void chmin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void chmax(T &x, U y) { if (x < y) x = y; }\n\nint d[120][120];\n\nint main() {\n    int n, m, s, t1, t2;\n    while (cin >> n >> m >> s >> t1 >> t2, n) {\n        s--; t1--; t2--;\n        fill_n(*d, 120 * 120, INF);\n        rep(i, m) {\n            int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n            a--; b--;\n            d[a][b] = c;\n        }\n        rep(k, n) rep(i, n) rep(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n        int ans = INF;\n        rep(i, n) {\n            chmin(ans, d[s][i] + d[i][t1] + d[i][t2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 105\n#define INF (1e9)\nusing namespace std;\nvoid prim();\nvoid func(int);\nint n,m,s,g1,g2,b1,b2,c,cost[N_MAX][N_MAX],mincost[N_MAX],ans;\nbool used[N_MAX];\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) cost[i][j]=INF;\n    for(int i=0;i<m;i++) cin>>b1>>b2>>c,cost[b1][b2]=cost[b2][b1]=c;\n    prim();\n  }\n  return 0;\n}\n\nvoid prim(){\n  for(int i=1;i<=n;i++) mincost[i]=INF,used[i]=false;\n  mincost[s]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    for(int u=1;u<=n;u++)\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=1;u<=n;u++) mincost[u]=min(mincost[u],cost[v][u]);\n  }\n  func(s);\n  cout<<ans<<endl;\n}\n\nvoid func(int d){\n  if(d==g1||d==g2) return ;\n  for(int i=1;i<=n;i++){\n    if(mincost[i]==cost[d][i]){\n      ans+=mincost[i];\n      func(i);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> VI;\ntypedef vector<VI> VVI;\nconst ll INF = numeric_limits<ll>::max() / 4;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD = 1e9 + 7;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true)\n\t{\n\t\tll n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tVVI dis(n, vector<ll>(n, INF));\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tdis[i][i] = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tll b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tb1--;\n\t\t\tb2--;\n\t\t\tdis[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tll tmp = dis[s][i] + dis[i][g1] + dis[i][g2];\n\t\t\tres = min(res, tmp);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX_V = 101;\nconst int INF=100000000;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\nint main(){\n    \n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2&&!(n==0&&m==0&&s==0&&g1==0&&g2==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            d[b1][b2]=c;\n            d[b2][b1]=c;\n        }\n        warshall_floyd();\n\n        int minCost=INF;\n        // X^[g©çÇ±ÜÅ¯¶¹ðg¤©ÅÎ ¢Ê¯\n        for(int i = 1; i <= n; i++){\n            minCost=min(minCost,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 10000000\n#define cost first\n#define node second\nusing namespace std;\ntypedef pair <int,int> P;\nvector <P> mp[101];\nint n,m,s,g1,g2;\n\nint dijkstra(int start,int goal){\n  int D[101];\n  for(int i=0;i<=n;i++) D[i]=INF;\n  priority_queue <P,vector<P>,greater<P> >Q;\n  Q.push((P){0,start});\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    if(t.node==goal) return t.cost;\n    for(int i=0;i<mp[t.node].size();i++){\n      int ncost = mp[t.node][i].cost + t.cost;\n      int nnode = mp[t.node][i].node;\n      if(D[nnode] > ncost)Q.push((P){ncost,nnode}),D[nnode] = ncost;\n    }\n  }\n  return INF;\n}\n\nint main(){\n  while(1){\n    cin >>n>>m>>s>>g1>>g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n    int b1,b2,c;\n    for(int i=0;i<=n;i++) mp[i].clear();\n    for(int i=0;i<m;i++) cin >> b1>>b2>>c,mp[b1].push_back((P){c,b2});\n    \n    int ans = INF;\n    for(int i=1;i<=n;i++)ans= min(ans,dijkstra(s,i)+dijkstra(i,g1)+dijkstra(i,g2));\n    cout << ans <<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint main()\n{\n  int n, m, s, t, u, a[101][101], p, q, v;\n  \n  while(cin>>n>>m>>s>>t>>u && n){\n    fill(&a[0][0], &a[100][100], inf);\n    for(int i = 0; i <= n; i++)\n      a[i][i] = 0;\n    \n    while(m--){\n      cin >> p >> q;\n      cin >> a[p][q];\n    }\n    \n    for(int k = 1; k <= n; k++)\n      for(int i = 1; i <= n; i++)\n\tfor(int j = 1; j <= n; j++)\n\t  a[i][j] = min(a[i][j], a[i][k]+a[k][j]);\n    \n    m = inf;\n    for(int i = 1; i <= n; i++)\n      m = min(m, a[s][i]+a[i][t]+a[i][u]);\n    \n    cout << m << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint n, m, s, g1, g2;\nint d[128][128];\n\nint inf = (1 << 29);\n\n#include <algorithm>\nbool load() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      d[i][j] = inf;\n    }\n  }\n  scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n  if( n == 0 ) return false;\n  for(int i = 0; i < m; ++i) {\n    int x, y, w;\n    scanf(\"%d %d %d\", &x, &y, &w);\n    d[x][y] = w;\n  }\n  return true;\n}\n\nvoid solve() {\n  for(int k = 1; k <= n; ++k) {\n    for(int i = 1; i <= n; ++i) {\n      for(int j = 1; j <= n; ++j) {\n        d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n  int res = inf;\n  for(int i = 1; i <= n; ++i) {\n    res = std::min(res, d[s][i] + d[i][g1] + d[i][g2]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  while( load() ) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** Problem2005 : Water Pipe Construction **/\nint d[110][110];\nint V;\n\nvoid warshall_floyd()\n{\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint M, S, G1, G2;\n\twhile (cin>>V>>M>>S>>G1>>G2, V||M||S||G1||G2) {\n\t\tfill(d[0], d[0]+110*110, INF);\n\t\t\n\t\trep(i, M) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\t\n\t\twarshall_floyd();\n\t\n\t\tint ans=INF;\n\t\trep(i, V) {\n\t\t\tint tmp = d[S][i]+d[i][G1]+d[i][G2];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 30;\nint d[100][100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 , n) {\n\t\ts-- , g1-- , g2--;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = (i == j) ? 0 : INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta-- , b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tll d[n + 1][n][n];\n\t\t// ????????°????????§???????°´????????????????????????????????\\????????????????????????\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tif(i == j) d[0][i][j] = 0;\n\t\t\t\telse d[0][i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\t\t// ??\\???\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n + 1) {\t// ???????????£???????????????\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i - 1] + d[i - 1][i - 1][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n][s][i] + d[n][i][g1] + d[n][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int INF = 1e+9;\n\nint d[MAX_V][MAX_V];\n\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\td[i][j] = (i == j)? 0 : INF ;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile( cin >> n >> m >> s >> g1 >> g2 , n ){\n\t\tinit();\n\t\ts--; g1--; g2--;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\td[u][v] = cost;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , d[i][k] + d[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tans = min( ans , d[s][i] + d[i][g1] + d[i][g2] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=INT_MAX;\nconst int MAX_V=200;\n#define int long long\nsigned main(){\n\n  for(;;){\n  int v,m,s[3];\n  cin>>v>>m;\n  for(int i=0;i<3;i++) cin>>s[i];\n  s[0]--;\n  s[1]--;\n  s[2]--;\n\n  if(!v) break;\n\n  int G[MAX_V][MAX_V];\n\n  for(int i=0;i<v;i++) for(int j=0;j<v;j++) G[i][j]=1e9;\n  for(int i=0;i<v;i++) G[i][i]=0;\n\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--,b2--;\n    G[b1][b2]=c;\n  }\n\n  for(int k=0;k<v;k++)\n    for(int i=0;i<v;i++)\n      for(int j=0;j<v;j++) G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  int r=1e9;\n\n  for(int i=0;i<v;i++) r=min(r,G[s[0]][i]+G[i][s[1]]+G[i][s[2]]);\n\n  cout<<r<<endl;\n\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n#define inf 123451234512345LL\n\nll G[100][100] = {0};\nvoid warshallfloyd(int v){\n  int i, j, k;\n  rep(k, v)rep(i, v)rep(j, v)if(G[i][k] != inf && G[k][j] != inf && G[i][j] > G[i][k] + G[k][j])G[i][j] = G[i][k] + G[k][j];\n  return;\n}\n\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n\n    for(;;){\n      int n, m, s, g1, g2;\n      cin >> n >> m >> s >> g1 >> g2;\n      if((n | m | s | g1 | g2) == 0)break;\n      s--; g1--; g2--;\n\n      rep(i, n)rep(j, n)G[i][j] = inf;\n      rep(i, m){\n        int3(x, y, z);\n        x--; y--;\n        G[x][y] = z; G[y][x] = z;\n      }\n      rep(i, n)G[i][i] = 0;\n\n      warshallfloyd(n);\n\n      ll res = inf;\n      rep(i, n)res = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n      pri(res);\n    }\n\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10e7\nusing namespace std;\n\nint cost[100][100];\n\nint main(void){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n|m|s|g1|g2){\n\t\ts--,g1--,g2--;\n\t\tfor(int i=0;i<100;i++)\n\t\t\tfor(int j=0;j<100;j++)\n\t\t\t\tcost[i][j]=(i==j)?0:INF;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tb1--,b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tint ans=INF;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans=min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\tcout << ans << endl;\n\t}\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define countof(a) (sizeof(a)/sizeof(*a))\n\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vpi vector<pi >\n#define pi pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define all(n) n.begin(), n.end()\n\n#define FROMTO(var, from, to) for (register int var = (from), var##down = ((int)(to)) < ((int)(from));var##down ? (var >= (int)(to)) : (var <= (int)(to));var##down ? var-- : var++)\n#define UPTO(var, from, to)   for (register int var = (from); var <= ((int)to); var++)\n#define DOWNTO(var, from, to) for (register int var = (from); var >= ((int)to); var--)\n#define FOR(var, to)          UPTO(var, 0, (to)-1)\n#define DOWN(var, from)       DOWNTO(var, (from)-1, 0) \n\n#define INIT(var, val) FOR(i,countof(var)) var[i] = val\n#define INPUT(var) FOR(i,countof(var)) cin >> var[i]\n#define INPUT1(var) FOR(i,countof(var)) cin >> var[i], var[i]--\n\n#define SORT(v) qsort(v,countof(v),sizeof(*v),int_less)\n#define SORTT(v) qsort(v,countof(v),sizeof(*v),int_greater)\n#define QSORT(v,b) qsort(v,countof(v),sizeof(*v),b)\n\n#define MOD 1000000007\n#define INF ((1 << 30)-1)\n#define LINF ((1LL << 62)-1)\n\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef int8_t s8;\ntypedef int16_t s16;\ntypedef int32_t s32;\ntypedef int64_t s64;\n\nstruct Comb {\n    vector<vector<s64> > data;\n    Comb(int n) { // O(n^2)\n        data = vector<vector<s64> >(n+1,vector<s64>(n+1,1));\n        UPTO(i,1,n) {\n            FOR(j,i+1) {\n                if (!j || j == i) data[i][j] = 1;\n                else data[i][j] = data[i-1][j-1] + data[i-1][j];\n            }\n        }\n    }\n    \n    s64 ncr(int n, int r) {\n        return data[n][r];\n    }\n};\n\n\nstruct Graph {\n\tint n;\n\tvector<vector<pair<int, s64> > > hen;\n\t\n\t// result of Warshall–Floyd\n\tvector<vector<s64> > WF;\n\tbool wf_completed = false;\n\t\n\t// result of dijkstra and Bellman-Ford/SPFA\n\tvector<vector<s64> > SSSP;\n\tset<int> sssp_completed;\n\t\n\t// result of dfs(reachable check)\n\tvector<vector<bool> > DFS;\n\tset<int> dfs_completed;\n\t\n\tGraph(int n) { // O(N)\n\t\then.resize(n, vector<pair<int, s64> >());\n\t\tSSSP.resize(n, vector<s64>());\n\t\tDFS.resize(n, vector<bool>());\n\t\tthis->n = n;\n\t}\n\t\n\t// return the position of negative cycle(-1 if none)\n\tint bf(int k) {\n\t\tsssp_completed.insert(k);\n\t\tSSSP[k].resize(n,LINF);\n\t\tSSSP[k][k] = 0;\n\t\tFOR(i,n-1) {\n\t\t\tbool updated = false;\n\t\t\tFOR(j,n) {\n\t\t\t\tfor (auto l : hen[j]) {\n\t\t\t\t\tif (SSSP[k][j] != LINF && SSSP[k][l.fi] > SSSP[k][j] + l.se)\n\t\t\t\t\t\tSSSP[k][l.fi] = SSSP[k][j] + l.se, updated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!updated) break;\n\t\t}\n\t\t\n\t\tFOR(j,n) {\n\t\t\tfor (auto l : hen[j]) {\n\t\t\t\tif (SSSP[k][j] != LINF && SSSP[k][l.fi] > SSSP[k][j] + l.se) {\n\t\t\t\t\treturn j; // negative loop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tint spfa(int k) {\n\t\tvector<bool> inque(n,false);\n\t\tvector<int> updated(n,0);\n\t\t\n\t\tsssp_completed.insert(k);\n\t\tSSSP[k].resize(n,LINF);\n\t\tSSSP[k][k] = 0;\n\t\t\n\t\tqueue<int> que; inque[k] = true;que.push(k);\n\t\twhile (que.size()) {\n\t\t\tint i = que.front(); que.pop();\n\t\t\tfor (auto j : hen[i]) {\n\t\t\t\tif (SSSP[k][j.fi] > SSSP[k][i] + j.se) {\n\t\t\t\t\tSSSP[k][j.fi] = SSSP[k][i] + j.se;\n\t\t\t\t\tupdated[j.fi]++;\n\t\t\t\t\tif (updated[j.fi] > n) return j.fi;\n\t\t\t\t\tif (!inque[j.fi]) {\n\t\t\t\t\t\tinque[j.fi] = true;\n\t\t\t\t\t\tque.push(j.fi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinque[i] = false;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tvoid dij(int k) { // O(n+mlogm)\n\t\tSSSP[k].resize(n);\n\t\tfill(all(SSSP[k]), LINF);\n\t\tSSSP[k][k] = 0;\n\t\tpriority_queue<pair<s64, int>, vector<pair<s64, int> >, greater<pair<s64,int> > > que;\n\t\tque.push(pair<s64,int>(0,k));\n\t\twhile(que.size()) {\n\t\t\tauto i = que.top(); que.pop();\n\t\t\tfor (auto j : hen[i.se]) {\n\t\t\t\tif (SSSP[k][j.fi] > i.fi + j.se) {\n\t\t\t\t\tSSSP[k][j.fi] = i.fi + j.se;\n\t\t\t\t\tque.push(pair<s64,int>(SSSP[k][j.fi], j.fi));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsssp_completed.insert(k);\n\t}\n\t\n\tvoid wf() { // O(n^3)\n\t\tWF.resize(n);\n\t\tfill(all(WF), vector<s64>(n,LINF));\n\t\tFOR(i,n) {\n\t\t\tWF[i][i] = 0;\n\t\t\tfor (auto j : hen[i]) {\n\t\t\t\tWF[i][j.fi] = j.se;\n\t\t\t}\n\t\t}\n\t\tFOR(k,n) {\n\t\t\tFOR(i,n) {\n\t\t\t\tFOR(j,n) {\n\t\t\t\t\tif (WF[i][k] != LINF && WF[k][j] != LINF) {\n\t\t\t\t\t\tWF[i][j] = min(WF[i][j], WF[i][k] + WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twf_completed = true;\n\t}\n\t\n\tvoid dfs(int from) { // O(N+M)\n\t\tDFS[from].resize(n, false);\n\t\tDFS[from][from] = true;\n\t\tqueue<int> que; que.push(from);\n\t\twhile(que.size()) {\n\t\t\tauto i = que.front(); que.pop();\n\t\t\tfor (auto j : hen[i]) {\n\t\t\t\tif (!DFS[from][j.fi]) {\n\t\t\t\t\tDFS[from][j.fi] = true;\n\t\t\t\t\tque.push(j.fi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs_completed.insert(from);\n\t}\n\t\n\tbool reachable(int from, int to) {\n\t\tassert(dfs_completed.count(from));\n\t\treturn DFS[from][to];\n\t}\n\t\n\tpair<bool,s64> shortest(int from, int to) {\n\t\tassert(wf_completed || sssp_completed.count(from));\n\t\tif (wf_completed)\n\t\t\treturn mp(WF[from][to] != LINF, WF[from][to]);\n\t\telse if (sssp_completed.count(from))\n\t\t\treturn mp(SSSP[from][to] != LINF, SSSP[from][to]);\n\t\telse return {}; // should not reached\n\t}\n\t\n\tvoid add_hen(int from, int to, s64 cost, bool muki) {\n\t\then[from].push_back(mp(to, cost));\n\t\tif (!muki) hen[to].push_back(mp(from, cost));\n\t}\n};\n// Graph.dfs : O(N)\n// Graph.dij : O(N+MlogM)\n// Graph.bf  : O(NM)\n// Graph.spfa: O(NM) faster\n// Graph.wf  : O(N^3)\n// Graph.reachable\n// Graph.shortest\n\nstatic inline int ri() {\n  int a;\n  scanf(\"%d\", &a);\n  return a;\n}\n\nint int_less(const void *a, const void *b) {\n  return (*((const int*)a) - *((const int*)b));\n}\nint int_greater(const void *a, const void *b) {\n  return (*((const int*)b) - *((const int*)a));\n}\n\nint main() {\n\twhile(1) {\n\t    int n = ri();\n\t\tif (n == 0) break;\n\t\tint m = ri();\n\t\tint r = ri()-1;\n\t\tint g0 = ri()-1;\n\t\tint g1 = ri()-1;\n\t\tGraph graph(n);\n\t\tFOR(i,m) {\n\t\t\tint a = ri()-1;\n\t\t\tint b = ri()-1;\n\t\t\tgraph.add_hen(a,b,ri(),true);\n\t\t}\n\t\tgraph.wf();\n\t\ts64 best = LINF;\n\t\tFOR(i,n) {\n\t\t\tauto r0 = graph.shortest(r,i);\n\t\t\tauto r1 = graph.shortest(i,g0);\n\t\t\tauto r2 = graph.shortest(i,g1);\n\t\t\tif (r0.fi && r1.fi && r2.fi)\n\t\t\t\tbest = min(best, r0.se+r1.se+r2.se);\n\t\t}\n\t\tcout << best << endl;\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#define INF 1<<29\n#define MAX 3000\nusing namespace std;\nint cost[MAX][MAX],V,d[MAX];\nbool used[MAX];\n\nvoid dijkstra(int);\n\nint main(){\n  int m,s,g1,g2,b1,b2,c;\n\n  while(true)\n    {\n      cin >> V >> m >> s >> g1 >> g2;\n      if(V == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)break;\n      for(int i=0;i<=V+2;i++)for(int j=0;j<=V+2;j++)cost[i][j];\n      for(int i=0;i<m;i++)\n\t{\n\t  cin >> b1 >> b2 >> c;\n\t  cost[b1][b2]=c;\n\t}\n      dijkstra(s);\n      int ans = d[g1]+d[g2];\n      //cout << ans << endl;\n      int dr[MAX];\n      for(int i=1;i<=V;i++)dr[i]=d[i];\n      for(int i=1;i<=V;i++)\n\t{\n\t  if(i == s || i == g1 || i == g2)continue;\n\t  dijkstra(i);\n\t  ans = min(ans,dr[i]+d[g1]+d[g2]);\n\t  // cout << ans << endl;\n\t}\n      cout << ans << endl;\n    }\n}\n\nvoid dijkstra(int s)\n{\n  for(int i=0;i<=V+2;i++)\n    {\n      d[i]=INF;\n      used[i]=false;\n    }\n  d[s] = 0;\n\n  while(true)\n    {\n      int v=-1;\n      for(int u=1;u<=V;u++)\n\t{\n\t  if(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t}\n      if(v == -1)break;\n      used[v]=true;\n      for(int u=1;u<=V;u++)\n\t{\n\t  d[u]=min(d[u],d[v]+cost[v][u]);\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\ntypedef pair<int, int> P;\nstruct edge {\n    int to, cost; \n    edge(int t, int c): to(t), cost(c) {}\n};\nconst int INF = 1e9;\n\nvoid dijkstra(vector<vector<edge> > G, vector<int> &d, int s) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    for(int i=0; i<d.size(); ++i) d[i] = INF;\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i=0; i<G[v].size(); ++i) {\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<vector<edge> > G(n);\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            G[b1-1].push_back(edge(b2-1, c));\n        }\n        REP(i, n) {\n            dijkstra(G, d[i], i);\n        }\n        int ans = 0;\n        int cost = INF;\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e5\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n    int i,j,k;\n    int n,m,s,g1,g2;\n    int v[100][100];\n    while(cin >> n >> m >> s >> g1 >> g2, n){\n        s--;g1--;g2--;\n        rep(i,n)rep(j,n){\n            if(i == j) v[i][j] = 0;\n            else v[i][j] = INF;\n        }\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v[a][b] = c;\n            v[b][a] = c;\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n        }\n        int ans = INF;\n\n        rep(i,n){\n            if(v[s][i] < INF && v[i][g1] < INF && v[i][g2] < INF)\n                ans = min(ans, v[s][i] + v[i][g1] + v[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 100000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\nlong long int d[101][101];\n//int path[101][101];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2){\n\t\tif(n==0&&m==0&&s==0&&g1==0&&g2==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t\t//path[i][j]=i;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t\t//path[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2]=c;\n\t\t\td[b2][b1]=c;\n\t\t}\n\t\tfor(int k=1; k<=n; ++k){\n\t\t\tfor(int i=1; i<=n; ++i){\n\t\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\t\tif(d[i][j]>d[i][k]+d[k][j]){\n\t\t\t\t\t\td[i][j]=d[i][k]+d[k][j];\n\t\t\t\t\t\t//path[i][j]=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//cout << d[1][3] << \"\\n\";\n\t\tvector<int> g1_path;\n\t\tfor(int i=g1; i!=s&&i!=INF; i=path[s][i]){\n\t\t\t//cout << path[s][i] << \"\\n\";\n\t\t\tg1_path.push_back(i);\n\t\t}\n\t\tg1_path.push_back(s);\n\t\tvector<int> g2_path;\n\t\tfor(int i=g2; i!=s&&i!=INF; i=path[s][i]){\n\t\t\tg2_path.push_back(i);\n\t\t}\n\t\tg2_path.push_back(s);\n\t\tlong long int ans=INF;\n\t\tfor(int i=0; i<g1_path.size(); ++i){\n\t\t\tif(ans>d[s][g1]+d[i][g2]) {\n\t\t\t\tcout << d[s][g1] << \" \" << d[i][g2] << \"\\n\";\n\t\t\t\tans=d[s][g1]+d[i][g2];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<g2_path.size(); ++i){\n\t\t\tif(ans>d[s][g2]+d[i][g1]) {\n\t\t\t\tcout << d[s][g2] << \" \" << d[i][g1] << \"\\n\";\n\t\t\t\tans=d[s][g2]+d[i][g1];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tlong long int ans=INF;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tif(ans>d[i][s]+d[i][g1]+d[i][g2]) ans=d[i][s]+d[i][g1]+d[i][g2];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp nake_pair\n\ntypedef long long ll;\n\nll d[110][110];\n\nint main(){\n    int n, m, s, g1, g2;\n    while(~scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2)){\n        if(n == 0 && m == 0) break;\n        rep(i, 110) rep(j, 110) d[i][j] = (i == j ) ? 0LL : 1e18;\n        int b1, b2, c;\n        s--;\n        g1--;\n        g2--;\n        rep(i, m){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            b1--;\n            b2--;\n            d[b1][b2] = min((ll)c, d[b1][b2]);\n        }\n        rep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        ll ans = d[s][g1]+d[s][g2];\n        rep(i, n){\n            ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define INF (1 << 24)\n#define NMAX 100\n#define TSIZE (NMAX + 1)\nusing namespace std;\n\nint main() {\n  int cost[TSIZE][TSIZE];\n  int n, m, s, g1, g2;\n  int b1, b2, c;\n  while (cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2) {\n    fill_n((int*)cost, TSIZE * TSIZE, INF);\n    for (int i = 1; i < TSIZE; i++) {\n      cost[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n      cin >> b1 >> b2 >> c;\n      cost[b1][b2] = c;\n    }\n\n    for (int k = 1; k < TSIZE; k++) {\n      for (int i = 1; i < TSIZE; i++) {\n        for (int j = 1; j < TSIZE; j++) {\n          cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        }\n      }\n    }\n\n    int res = INF;\n    for (int k = 1; k < TSIZE; k++) {\n      res = min(res, cost[s][k] + cost[k][g1] + cost[k][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint cost[105][105];\nint d[105][105];\t\t\t\t// 頂点 s からの最短距離\n\n// 始点 s から各頂点への最短距離を求める\n//int V;\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ) rep (j, V ) d[i][j] = INF;\n\trep (i, V ) d[i][i] = 0;\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\tif (cost[i][j] != INF ){\n\t\t\t\td[i][j] = cost[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (cost, 0, sizeof (cost) );\n\t\trep (i, n ) rep (j, n ) cost[i][j] = INF;\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\tcost[from][to] = c;\n\t\t\tcost[to][from] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\t\twarshall_floyd (n );\n/*\n\t\trep (i, n ){\n\t\t\trep (j, n ){\n\t\t\t\tif (d[i][j] == INF ){\n\t\t\t\t\tcout << \"INF\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << setw(3) << d[i][j];\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tcout << endl;\n\t\t} // end rep\n*/\n\t\trep (i, n ){\n\t\t\tif (i == s ) continue;\n\t\t\tif (i != g1 && i != g2 ){\n\t\t\t\tint curr1 = d[s][i] + d[i][g1] + d[i][g2];\n\t\t\t\tres = min (res, curr1 );\n\t\t\t\tint curr2 = d[s][i] + d[i][g1] + d[g1][g2];\n\t\t\t\tres = min (res, curr2 );\n\t\t\t\tint curr3 = d[s][i] + d[i][g2] + d[g2][g1];\n\t\t\t\tres = min (res, curr3 );\n\t\t\t}else{\n\t\t\t\tres = min (res, d[s][i] + d[i][i == g1 ? g2 : g1] );\n\t\t\t} // end if\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n){\n        s--; g1--; g2--;\n        vector<vector<ll>> G(n, vector<ll>(n, INF<int>));\n        for (int i = 0; i < m; ++i) {\n            int u, v, c; cin >> u >> v >> c;\n            G[u-1][v-1] = c;\n        }\n        for (int i = 0; i < n; ++i) {\n            G[i][i] = 0;\n        }\n        for (int k = 0; k < n; ++k) {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    G[i][j] = min(G[i][j], G[i][k]+G[k][j]);\n                }\n            }\n        }\n        ll ans = G[s][g1]+G[s][g2];\n        for (int i = 0; i < n; ++i) {\n            ans = min(ans, G[s][i]+G[i][g1]+G[i][g2]);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M,S,G1,G2;\nint d[110][110] = {};\nint inf = 1e8;\n\nint main(){\n    while(cin >> N >> M >> S >> G1 >> G2 && N>0){\n        int b1,b2,c;\n        for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) d[i][j] = inf;\n        for(int i=0;i<M;i++){\n            cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n        for(int k=1;k<=N;k++){\n            for(int i=1;i<=N;i++){\n                for(int j=1;j<=N;j++){\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=1;i<=N;i++){\n            ans = min(ans,d[S][i]+d[i][G1]+d[i][G2]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main ()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n + m + s + g1 + g2) {\n        vector<vector<int> > d(n + 1, vector<int>(n + 1, INF));\n        for (int i = 0; i <= n; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int gx, gy, c;\n            cin >> gx >> gy >> c;\n            d[gx][gy] = d[gy][gx] = c;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int  k = 1; k <= n; k++) {\n                    if (i == j || j == k || k == i) continue;\n                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < n; i++) {\n            if (i == s || i == g1 || i == g2) continue;\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nstruct Edge{\n  int weight;\n  int to;\n  Edge(int w,int t):weight(w),to(t){}\n  Edge():to(-1){}\n};\n\n\nbool operator>(Edge e1,Edge e2){\n  return (e1.weight > e2.weight);\n}\n\nbool operator<(Edge e1,Edge e2){\n  if(e1.weight != e2.weight) return (e1.weight < e2.weight);\n  else return (e1.to < e2.to);\n}\n\nstruct Point{\n  int weight;\n  int pre;\n  Point(int w):weight(w),pre(-1){}\n  Point():weight(0),pre(-1){}\n};\nint n,m,s,g1,g2;\n\nbool dfs(int index,vector<vector<Edge> > &Graph,int &ans){\n  bool res=false;\n  if(Graph[index].size() == 0){\n    if(index == g1 || index == g2) return true;\n    else return false;\n  }\n  for(vector<Edge>::iterator it=Graph[index].begin(),e=Graph[index].end();it!=e;it++){\n    bool lok=dfs(it->to,Graph,ans);\n    if(lok){\n      ans += it->weight;\n      res = true;\n    }\n    \n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    vector<vector<Edge> > Graph(n);\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      Graph[b1-1].push_back(Edge(c,b2-1));\n    }\n    priority_queue<Edge,vector<Edge>,greater<Edge> > pq; \n    vector<Point> v(n);\n    s--;g1--;g2--;\n    int index=s;\n    vector<bool> used(n,false);\n    vector<vector<Edge> > Graph2(n);\n    v[index].pre = -2;\n    while(!used[index]){\n      used[index]=true;\n      for(vector<Edge>::iterator it=Graph[index].begin(),e=Graph[index].end();it!=e;it++){\n\tif(v[it->to].pre == -1 || v[it->to].weight > it->weight){\n\t  v[it->to].pre = index;\n\t  v[it->to].weight = it->weight;\n\t  pq.push(*it);\n\t}\n      }\n      Edge edge;\n      while(pq.size() && used[index]){\n\tedge = pq.top();\n\tindex = edge.to;\n\tpq.pop();\n      }\n      if(edge.to != -1 && !used[index]){\n\tGraph2[v[edge.to].pre].push_back(edge);\n      }\n    }\n    int ans=0;\n    dfs(s,Graph2,ans);\n    /*\n    for(int i=0;i<n;i++){\n      cout<<i+1<<\" : \";\n      for(auto it=Graph2[i].begin(),e=Graph2[i].end();it!=e;it++){\n\tcout<<it->weight<<' ';\n      }\n      cout<<endl;\n      }*/\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** Problem2005 : Water Pipe Construction **/\nint d[110][110];\nint V;\n\nvoid warshall_floyd()\n{\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint M, S, G1, G2;\n\twhile (cin>>V>>M>>S>>G1>>G2, V||M||S||G1||G2) {\n\t\tS--; G1--; G2--;\n\t\t\n\t\tfill(d[0], d[0]+110*110, INF);\n\t\trep(i, 110) {\n\t\t\td[i][i]=0;\n\t\t}\n\t\t\n\t\trep(i, M) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--; b--;\n\t\t\td[a][b]=c;\n\t\t}\n\t\t\n\t\twarshall_floyd();\n\t\n\t\tint ans=d[S][G1]+d[S][G2];\n\t\trep(i, V) {\n\t\t\tif (i != S && i != G1 && i!=G2) {\n\t\t\t\tint tmp = d[S][i]+d[i][G1]+d[i][G2];\n\t\t\t\tans = min(ans, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint main()\n{\n\tint n, m, s, t, u, a[101][101], p, q, v;\n\t\n\twhile(cin>>n>>m>>s>>t>>u&&n){\n\t\tfill(&a[0][0], &a[100][100], inf);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile(m--){\n\t\t\tcin >> p >> q;\n\t\t\tcin >> a[p][q];\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\ta[i][j] = min(a[i][j], a[i][k]+a[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tm = inf;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tm = min(m, a[s][i]+a[i][t]+a[i][u]);\n\t\t}\n\t\t\n\t\tcout << m << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n,m,s,g1,g2,a,b,cost;\n  int map[100][100];\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)map[i][j]=0;\n\telse map[i][j]=1000000;\n      }\n    }\n    for(int i=0;i<5;i++){\n      cin>>a>>b>>cost;\n      map[a-1][b-1]=cost;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  map[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout<<map[i][j]<<\" \";\n      cout<<endl;\n    }\n    int mi=1000000;\n    for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]);\n    cout<<mi<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tVV(int) vv;\n\t\tinitvv(vv,n,n);\n\t\trep(i,n) rep(j,n) vv[i][j]=INF;\n\t\tvvint vvr=vv;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a][b]=c;\n\t\t\tvvr[b][a]=c;\n\t\t}\n\t\t// cout<<0<<endl;\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tvv[i][j]=min(vv[i][j],vv[i][k]+vv[k][j]);\n\t\t\t\t\tvvr[i][j]=min(vvr[i][j],vvr[i][k]+vvr[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,n){\n\t\t\tans=min(ans,vvr[i][s]+vv[i][g1]+vv[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t/*\n\t\tpriority_queue<pii> pq;\n\t\tvint v(n,-1);\n\t\tpq.push(mkp(0,s));\n\t\twhile(!pq.empty()){\n\t\t\tpii t=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(v[t.S]!=-1) continue;\n\t\t\tcout<<-t.F<<\" \"<<t.S<<endl;\n\t\t\tv[t.S]=-t.F;\n\t\t\trep(i,vv[t.S].size()){\n\t\t\t\t// cout<<vv[t.S][i].F<<endl;\n\t\t\t\tif(v[vv[t.S][i].F]==-1){\n\t\t\t\t\tpq.push(mkp(t.F-vv[t.S][i].S,vv[t.S][i].F));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t// cout<<v[g1]+v[g2]<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\n#ifdef _DEBUG\n#define DEBUG WRITE\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\n#else\n#define DEBUG(...)\ninline void readfrom(...) { }\ninline void writeto(...) { }\n#endif\n#ifdef colored_cout\n#  define cout colored_cout\n#  define endl colored_endl\n#endif\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, const pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << \"\";\n\tauto s = ss.str();\n\tout << s.substr(0, s.length());\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n//// graph ////\n\ntemplate <class TCost = double>\nstruct Path\n{\n\ttypedef TCost COST;\n\tint from;\n\tint to;\n\tTCost cost;\n\tPath(int from = 0, int to = 0, TCost cost = 0)\n\t\t: from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator > (const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// dijkstra //\ntemplate <class COST>\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path<COST>>> &routes, int start = 0, int goal = -1)\n{\n\ttypedef Path<COST> P;\n\tint N = routes.size();\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(P(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tP cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tP next = P(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[i] != -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n, m, s, g1, g2);\n\t\tif (!n) { break; }\n\t\ttypedef Path<int> P;\n\t\tvevector<P> graph(n), reverse_graph(n);\n\t\tREP(i, m)\n\t\t{\n\t\t\tREAD(int, b1, b2, c);\n\t\t\tgraph[b1 - 1].push_back(P(b1 - 1, b2 - 1, c));\n\t\t\treverse_graph[b2 - 1].push_back(P(b2 - 1, b1 - 1, c));\n\t\t}\n\t\tvector<int> x = dijkstra(graph, s - 1).first;\n\t\tvector<int> y = dijkstra(reverse_graph, g1 - 1).first;\n\t\tvector<int> z = dijkstra(reverse_graph, g2 - 1).first;\n\n\t\tint result = INF;\n\t\tREP(i, n) result = min(result, x[i] + y[i] + z[i]);\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define INF (1LL<<60)\n#define DEKAI 1000000007\n#define MOD 998244353\n#define lp(i,n) for(int i=0;i<n;i++)\n#define double long double\n#define all(c) begin(c), end(c)\n\n#define int long long \n\nnamespace {\n#define __DECLARE__(C)    \\\n    template <typename T> \\\n    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n#define __DECLAREM__(C)               \\\n    template <typename T, typename U> \\\n    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n__DECLARE__(std::vector)\n__DECLARE__(std::deque)\n__DECLARE__(std::set)\n__DECLARE__(std::stack)\n__DECLARE__(std::queue)\n__DECLARE__(std::priority_queue)\n__DECLARE__(std::unordered_set)\n__DECLAREM__(std::map)\n__DECLAREM__(std::unordered_map)\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\ntemplate <typename... T>\nstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\ntemplate <typename T, std::size_t N>\nstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\ntemplate <typename Tuple, std::size_t N>\nstruct __TuplePrinter__ {\n    static void print(std::ostream &os, const Tuple &t) {\n        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n        os << \", \" << std::get<N - 1>(t);\n    }\n};\n\ntemplate <typename Tuple>\nstruct __TuplePrinter__<Tuple, 1> {\n    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n};\n\ntemplate <typename... T>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n    os << '(';\n    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n    os << ')';\n    return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n    return os << '(' << v.first << \", \" << v.second << ')';\n}\n\n#define __INNER__                             \\\n    os << '[';                                \\\n    for (auto it = begin(c); it != end(c);) { \\\n        os << *it;                            \\\n        os << (++it != end(c) ? \", \" : \"\");   \\\n    }                                         \\\n    return os << ']';\n\ntemplate <typename T, std::size_t N>\nstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n    __INNER__\n}\n\n#define __DEFINE__(C)                                           \\\n    template <typename T>                                       \\\n    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n        __INNER__                                               \\\n    }\n\n#define __DEFINEM__(C)                                             \\\n    template <typename T, typename U>                              \\\n    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n        __INNER__                                                  \\\n    }\n\n#define __DEFINEW__(C, M1, M2)                                  \\\n    template <typename T>                                       \\\n    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n        std::deque<T> v;                                        \\\n        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n        return os << v;                                         \\\n    }\n\n__DEFINE__(std::vector)\n__DEFINE__(std::deque)\n__DEFINE__(std::set)\n__DEFINEW__(std::stack, push_front, top)\n__DEFINEW__(std::queue, push_back, front)\n__DEFINEW__(std::priority_queue, push_front, top)\n__DEFINE__(std::unordered_set)\n__DEFINEM__(std::map)\n__DEFINEM__(std::unordered_map)\n}\n\n\n#define rep(i,n) lp(i,n)\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nMatrix WarshallFloyd(const Graph &g) {\n    //auto const INF = std::numeric_limits<Weight>::max() / 8;\n    int n = g.size();\n    Matrix d(n, Array(n, INF));\n    rep(i, n) d[i][i] = 0;\n    rep(i, n) for (auto &e : g[i]) d[e.src][e.dst] = std::min(d[e.src][e.dst], e.weight);\n    rep(k, n) rep(i, n) rep(j, n) {\n        if (d[i][k] != INF && d[k][j] != INF) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n    }\n    return d;\n}\n\nsigned main(){\n\twhile(1){\n\t\tint n,m,s,g1,g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n==0)break;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tGraph g(n);\n\t\tlp(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tadd_arc(g,a-1,b-1,c);\n\t\t}\n\t\tMatrix dis=WarshallFloyd(g);\n\t\tint ans=INF;\n\t\tlp(i,n){\n\t\t\tans=min(ans,dis[s][i]+dis[i][g1]+dis[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n        long long int n , m , s , g1 , g2;\n        while( cin >> n >> m >> s >> g1 >> g2 , n && m && s && g1 && g2 )\n        {\n                s--; g1--; g2--;\n                vector<vector<long long int> >data;\n                data.resize ( n );\n                for( size_t i = 0; i < n; i++ )\n                {\n                        data[i].resize ( n );\n                        for( size_t j = 0; j < n; j++ )\n                        {\n                                data[i][j] = INT_MAX / 6;\n                        }\n                        data[i][i] = 0;\n                }\n                long long int a , b , c;\n                for( size_t i = 0; i < m; i++ )\n                {\n                        cin >> a >> b >> c;\n                        a--; b--;\n                        data[a][b] = c;\n                        data[b][a] = c;\n                }\n                for( size_t k = 0; k < n; k++ )\n                {\n                        for( size_t j = 0; j < n; j++ )\n                        {\n                                for( size_t i = 0; i < n; i++ )\n                                {\n                                        data[i][j] = min ( data[i][j] , data[i][k] + data[k][j] );\n                                        data[j][i] = data[i][j];\n                                }\n                        }\n                }\n                long long int ans = INT_MAX;\n                for( size_t i = 0; i < n; i++ )\n                {\n                        ans = min ( ans , data[s][i] + data[i][g1] + data[i][g2] );\n                }\n                cout << ans << endl;\n                data.clear ();\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M,S,G1,G2;\nint d[110][110] = {};\nint inf = 1e9;\n\nint main(){\n    while(cin >> N >> M >> S >> G1 >> G2 && N>0){\n        int b1,b2,c;\n        for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) d[i][j] = inf;\n        for(int i=0;i<M;i++){\n            cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n        for(int k=1;k<=N;k++){\n            for(int i=1;i<=N;i++){\n                for(int j=1;j<=N;j++){\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=1;i<=N;i++){\n            ans = min(ans,d[S][i]+d[i][G1]+d[i][G2]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<climits>\nusing namespace std;\n#define INF INT_MAX/3-2\n\nint n,m,s,g1,g2;\nvector< vector<int> > edge;\nvoid init(){\n  n=m=s=g1=g2=0;\n  edge.clear();\n}\n\nbool input(){\n  cin>>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0){\n    return 0;\n  }\n  s--;g1--;g2--;\n  edge.resize(n);\n  for(int i=0;i<n;i++){\n    edge[i].resize(n);\n    for(int j=0;j<n;j++){\n      edge[i][j]=INF;\n    }\n  }\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--;b2--;\n    edge[b1][b2]=c;\n    edge[b1][b2]=c;\n  }\n  return 1;\n}\n\n\n\n\nint solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<n;i++){\n    res=min(res,edge[s][i]+edge[i][g1]+edge[i][g2]);\n  }\n  return res;\n\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 25)\n\nusing namespace std;\n\nint pcost[100][100]; // begin, end\nint mcost[100][100];\n\nvoid Dijkstra( int n, int s, int cost[][100], int *minCost )\n{\n\tbool *end = new bool[n];\n\tfill(end, end+n, false);\n\tminCost[s] = 0;\n\tend[s] = true;\n\twhile(true) {\n\t\tint ii = -1, nn = (INF);\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(end[i] && nn > minCost[i]) {\n\t\t\t\tnn = minCost[i];\n\t\t\t\tii = i;\n\t\t\t}\n\t\t}\n\t\tif(ii == -1) break;\n\t\tend[ii] = false;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(minCost[i] > minCost[ii] + cost[ii][i]) {\n\t\t\t\tminCost[i] = minCost[ii] + cost[ii][i];\n\t\t\t\tend[i] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main( void )\n{\n\tint minCost1[100], minCost2[100], minCost3[100];\n\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2) {\n\t\t--s; --g1; --g2;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tfill(pcost[i], pcost[i]+n, INF);\n\t\t\tfill(mcost[i], mcost[i]+n, INF);\n\t\t\tminCost1[i] = minCost2[i] = minCost3[i] = INF;\n\t\t}\n\t\tfor(int i=0; i < m; ++i) {\n\t\t\tint bb, ee, cc;\n\t\t\tcin >> bb >> ee >> cc;\n\t\t\t--bb; --ee;\n\t\t\tpcost[bb][ee] = mcost[ee][bb] = cc;\n\t\t}\n\t\tDijkstra(n, s, pcost, minCost1);\n\t\tDijkstra(n, g1, mcost, minCost2);\n\t\tDijkstra(n, g2, mcost, minCost3);\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tans = min(ans, minCost1[i] + minCost2[i] + minCost3[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>;\nconst int MOD = (int)1e9 + 7, INF = (1 << 27); const ll INFLL = (1LL << 55);\n#define FOR(i,a,b) for(int (i)=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\ntemplate<typename T, typename U> static void chmin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void chmax(T &x, U y) { if (x < y) x = y; }\n\nint d[120][120];\n\nint main() {\n    int n, m, s, t1, t2;\n    while (cin >> n >> m >> s >> t1 >> t2, n) {\n        s--; t1--; t2--;\n        fill_n(*d, 120 * 120, INF);\n        rep(i, m) {\n            int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n            a--; b--;\n            d[a][b] = d[b][a] = c;\n        }\n        rep(k, n) rep(i, n) rep(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n        int ans = INF;\n        rep(i, n) {\n            chmin(ans, d[s][i] + d[i][t1] + d[i][t2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tint from;\n\tint to;\n\tint cost;\n}edge;\n\n\nint cmp(const void* a, const void* b){\n\tedge *e1 = (edge *)a;\n\tedge *e2 = (edge *)b;\n\treturn e1->cost - e2->cost;\n}\nint t[100], r[100];\nvoid init(int n){\n\tint i;\n\tfor(i = 0;i < n;i++){\n\t\tt[i] = i;\n\t\tr[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x == t[x]) return x;\n\telse return t[x] = find(t[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(r[x] > r[y])\n\t\tt[y] = x;\n\telse if(r[x] < r[y])\n\t\tt[x] = y;\n\telse if(x != y){\n\t\tt[y] = x;\n\t\tr[x]++;\n\t}\n}\n\nint main(void){\n\tint n, m, s, c, g1, g2, b1, b2, i, j, k, a, sum, v[100];\n\tedge e[1000], tmp;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\ts--, g1--, g2--;\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\te[i].from = b1 - 1, e[i].to = b2 - 1, e[i].cost = c;\n\t\t}\n\t\tqsort(e,m,sizeof(e[0]),cmp);\n\t\tinit(n);\n\t\ta = m;\n\t\tfor(i = 0;i < m && a != 1;i++){\n\t\t\tif(find(e[i].from) != find(e[i].to))\n\t\t\t\tunite(e[i].from,e[i].to);\n\t\t\telse{\n\t\t\t\tfor(j = i;j < m - 1;j++)\n\t\t\t\t\te[i] = e[i + 1];\n\t\t\t\tm--;\n\t\t\t}\n\t\t\ta = 0;\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tif(t[j] == j) a++;\n\t\t}\n\t\tm = i;\n\t\tmemset(v,0,sizeof(v));\n\t\tfor(i = 0;i < m;i++)\n\t\t\tv[e[i].from]++, v[e[i].to]++;\n\t\twhile(v[s] != 1 || v[g1] != 1 || v[g2] != 1){\n\t\t\tfor(i = 0;i < m;i++){\n\t\t\t\tif((v[e[i].from] == 1 || v[e[i].to] == 1) && (e[i].from == g1 || e[i].to == g1 || e[i].from == g2 || e[i].to == g2 || e[i].from == s || e[i].to == s)){\n\t\t\t\t\tfor(j = i;j < m - 1;j++)\n\t\t\t\t\t\te[i] = e[i + 1];\n\t\t\t\t\tm--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(v,0,sizeof(v));\n\t\t\tfor(i = 0;i < m;i++)\n\t\t\t\tv[e[i].from]++, v[e[i].to]++;\n\t\t}\n\t\tsum = 0;\n\t\tfor(i = 0;i < m;i++)\n\t\t\tsum += e[i].cost;\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n#define mp make_pair\n#define fst first\n#define scn second\nint main(){\n\twhile(true){\n\t\tint n,m,s,g1,g2;\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n==0)\tbreak;\n\t\ts--;\tg1--;\tg2--;\n\t\tvector<vector<ll>> dist(n,vector<ll>(n,1e9));\n\t\tfor(int i=0;i<n;i++)\tdist[i][i]=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint f,t,d;\tcin>>f>>t>>d;\n\t\t\tf--;\tt--;\n\t\t\tdist[f][t]=d;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ret=1e9;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tret=min(ret,dist[s][i]+dist[i][g1]+dist[i][g2]);\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\n#define INF 0x1FFFFFFF\n\nusing namespace std;\n\nint main(void){\n\tint n, m, s, c, g1, g2, b1, b2, i, j, k, ans, w[100][100];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\ts--, g1--, g2--;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++) w[i][j] = INF;\n\t\t\tw[i][i] = 0;\n\t\t}\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tw[b1 - 1][b2 - 1] = c;\n\t\t\tw[b2 - 1][b1 - 1] = c;\n\t\t}\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\tw[j][k] = min(w[j][k],w[j][i] + w[i][k]);\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tans = min(ans,w[i][s] + w[i][g1] + w[i][g2]);\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tprintf(\"%d \",w[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define REAP(i,a,n) for(ll i=(a);i<(n);i++)\n#define YES cout<<\"Yes\"<<endl\n#define NO cout<<\"No\"<<endl\n#define fr first\n#define sc second\n#define pb push_back\n#define All(v) v.begin(),v.end()\ntypedef long long ll;\n\nll rd[101][101];\n\nvoid solve(ll n){\n    for(ll k=0;k<n;k++){\n        for(ll i=0;i<n;i++){\n            for(ll j=0;j<n;j++){\n                rd[i][j]=min(rd[i][j],rd[i][k]+rd[k][j]);\n            }\n        }\n    }\n}\n\n\nvoid init(){\n    REP(i,101){\n        REP(j,101){\n            rd[i][j]=1e9;\n            if(i==j)rd[i][j]=0;\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    ll n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        s--;\n        g1--;\n        g2--;\n        ll a,b,c;\n        init();\n        REP(k,m){\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            rd[a][b]=c;\n        }\n        solve(n);\n\n        ll res=INT_MAX;\n        for(ll i=0;i<n;i++){\n            res = min(res, rd[s][i]+rd[i][g1]+rd[i][g2]);\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 1e8;\n\nint main(){\n    ios::sync_with_stdio(false);\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        --s;\n        --g1;\n        --g2;\n        vector<vector<int>>dist(n,vector<int>(n,INF));\n        for(int i=0;i<m;++i){\n            int u,v,cost;\n            cin>>u>>v>>cost;\n            dist[u-1][v-1]=cost;\n        }\n        for(int k=0;k<n;++k){\n            for(int i=0;i<n;++i){\n                for(int j=0;j<n;++j){\n                    if(dist[i][j] > dist[i][k]+dist[k][j]){\n                        dist[i][j] = dist[i][k]+dist[k][j];\n                    }\n                }\n            }\n        }\n        for(int i=0;i<n;++i)dist[i][i]=0;\n        int ans=1e9;\n        for(int i=0;i<n;++i){\n            ans=min(ans,dist[s][i]+dist[i][g1]+dist[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define p pair<int, int>\nusing namespace std;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\nstruct Edge {\n    int to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n};\n\nbool operator<(const Edge &a, const Edge &b) { return a.cost >= b.cost; }\n\nconst int INF = 1e7;\n\nint dist[110][110];\nint main() {\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2) {\n        if (n == 0 && m == 0) break;\n        s--;\n        g1--;\n        g2--;\n        Fill(dist, INF);\n        for (int i = 0; i < m; i++) {\n            int u, v, c;\n            cin >> u >> v >> c;\n            u--;\n            v--;\n            dist[u][v] = c;\n        }\n        for (int i = 0; i < n; i++) dist[i][i] = 0;\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            ans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint d[105][105], to[105][105];\n\nvoid warshall_floyd(int n, int m) {\n\trep(i, n) rep(j, n) d[i][j] = INF;\n\trep(i, n) d[i][i] = 0;\n\n\trep(i, n) rep(j, n) to[i][j] = j;\n\n\t//input\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\n\t\ta--; b--;\n\t\td[a][b] = c;\n\t\td[b][a] = c;\n\t}\n\n\trep(k,n) {\n\t\trep(i,n) {\n\t\t\trep(j,n) {\n\t\t\t\tif(d[i][k] == INF || d[k][j] == INF) continue;\n\t\t\t\tif(d[i][j] > d[i][k] + d[k][j]) {\n\t\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> path(int s, int g) {\n\tint cur = s;\n\tvector<int> ret;\n\tfor(; cur != g; cur = to[cur][g]) {\n\t\tret.push_back(cur);\n\t}\n\n\tret.push_back(g);\n\treturn ret;\n}\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2) {\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\n\t\ts--; g1--; g2--;\n\t\twarshall_floyd(n, m);\n\n\t\t// rep(i, n) {\n\t\t// \trep(j, n) {\n\t\t// \t\tif(d[i][j] == INF) cout << \"X \";\n\t\t// \t\telse cout << d[i][j] << \" \";\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\n\n\t\tint ans = INF;\n\t\trep(i, n) {\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 4;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tint n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2;\n        s--;g1--;g2--;\n\t\tif (n == 0) break;\n\t\tVVI dis(n, vector<int>(n, INF));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tdis[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmp = dis[s][i] + dis[i][g1] + dis[i][g2];\n\t\t\tres = min(res, tmp);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint G[101][101];\nint n;\n\nint solve(int s,int g1,int g2){\n  for(int k=0;k<n;++k)\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n\n  int ret = 1<<29;\n  for(int t=0;t<n;++t)\n    ret = min(ret,G[s][t]+G[t][g1]+G[t][g2]);\n  return ret;\n}\n\nint main(){\n  int m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = (i==j)?0:(1<<29);\n    s--;g1--;g2--;\n    while(m--){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--;b--;\n      G[a][b] = c;\n    }\n    cout << solve(s,g1,g2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int INF = 1e+9;\n\nint d[MAX_V][MAX_V];\n\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\td[i][j] = (i == j)? 0 : INF ;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile( cin >> n >> m >> s >> g1 >> g2 , n || m ){\n\t\tinit();\n\t\ts--; g1--; g2--;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\td[u][v] = cost;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , d[i][k] + d[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tans = min( ans , d[s][i] + d[i][g1] + d[i][g2] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    while(1){\n\n    int V, E, S, G1, G2; cin >> V >> E >> S >> G1 >> G2;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    if(!V) break;\n    S--;\n    G1--;\n    G2--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b, c; cin >> a >> b >> c;           // a ,b 間に コスト c の辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(c, b));\n        //adjlist[b].push_back(make_pair(c, a));      \n    }\n\n    int ans = INF;\n    vector<int> result(V);\n    vector<int> res(V);\n    result = dijk(S, V, adjlist);\n    for(int i = 0; i < V; i++){\n        res = dijk(i, V, adjlist);\n        ans = min(ans, result[i] + res[G1] + res[G2]);\n    }\n\n    cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define inf (1<<27)\n#define rep(i,n)for(int i=0;i<n;i++)\nint cost[100][100];\nint n,m,s,g1,g2,b1,b2,c;\nint main() {\n\twhile(scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2),n) {\n\t\tfill(cost[0],cost[0]+100*100,inf);\n\t\trep(i,m) {\n\t\t\tscanf(\"%d %d %d\",&b1,&b2,&c);\n\t\t\tcost[b1-1][b2-1]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) {\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint res=inf;\n\t\trep(k,n) {\n\t\t\tres=min(res,cost[s-1][k]+cost[k][g1-1]+cost[k][g2-1]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 4;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif ( !( n | m | s | g1 | g2 ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\n\t\tVVI G( n, VI( n, INF ) );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tG[i][i] = 0;\n\t\t}\n\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint f, t, c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tf--;\n\t\t\tt--;\n\t\t\tG[f][t] = c;\n\t\t}\n\n\t\tREP( k, 0, n )\n\t\t{\n\t\t\tREP( i, 0, n )\n\t\t\t{\n\t\t\t\tREP( j, 0, n )\n\t\t\t\t{\n\t\t\t\t\tG[i][j] = min( G[i][j], G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = INT_MAX;\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tres = min( res, G[s][i] + G[i][ g1 ] + G[i][ g2 ] );\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 99999999\n\n\nint main(){\n    int edge[110][110];\n    rep(i,110)rep(j,110)edge[i][j]=INF;\n    rep(i,110)edge[i][i]=0;\n    int v,e,s,g1,g2;\n    while(cin>>v>>e>>s>>g1>>g2&&v&&e&&s&&g1&&g2){\n        rep(i,e){\n            int a,b,c;\n            cin>>a>>b>>c;\n            edge[a][b]=c;\n        }\n        \n        \n        rep(k,v){\n            rep(i,v){\n                rep(j,v){\n                    edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n                }\n            }\n        }\n        int mini=INF;\n        rep(i,v){\n            mini = min(edge[s][i]+edge[i][g1]+edge[i][g2],mini);\n        }\n        cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    warshallFloyd(g, n);\n    // pma(g, n);\n    \n    int ans = g[s][g1] + g[s][g2];\n    REP(i, n){\n        if(g[s][i] != -1 && g[i][g1] != -1 && g[i][g2] != -1)\n            ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint main(){\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    s--, g1--, g2--;\n\n    vvi G(n, vi(n, 1e8));\n    rep(i, m){\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        G[a][b] = G[b][a] = c;\n    }\n\n    rep(k, n)rep(i, n)rep(j, n){\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    }\n\n    int ans = 1e8;\n    rep(i, n){\n        ans = min(ans, G[s][i] + G[i][g1] + G[i][g2]);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n        \n        \n    const int mx=1e9+7;\n    int n,m,s,go,gt;\n    cin>>n>>m>>s>>go>>gt;\n    if(n==0 && m==0){break;}\n    s--; go--; gt--;\n    int a[1000][1000];\n    fill(&a[0][0],&a[999][1000],mx);\n    for(int i=0;i<n;i++){\n        a[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        int b,c,d;\n        cin>>b>>c>>d;\n        a[b-1][c-1]=d;\n        //a[c-1][b-1]=d;\n    }\n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int k=0;k<n;k++){\n                a[t][k]=min(a[t][i]+a[i][k],a[t][k]);\n            }\n        }\n    }\n    int ans=mx;\n    for(int i=0;i<n;i++){\n        if(a[s][i]!=mx && a[i][go]!=mx && a[i][gt]!=mx){\n            ans=min(a[s][i]+a[i][go]+a[i][gt],ans);\n        }\n    }\n        \n        /*\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                cout<<(a[i][t]==mx? -1:a[i][t])<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n        */\n        \n        \n    assert(ans!=mx);\n    cout<<ans<<endl;\n    \n    \n    \n    \n    \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define INF 1 << 29\n\nusing namespace std;\n\nint n, m, s, g1, g2;\nint cost[100][100];\n\nint main(){\n\n  while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n+m+s+g1+g2){\n    s--;g1--;g2--;\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    rep(i, n) cost[i][i] = 0;\n    int a, b, c;\n    rep(i, m){\n      scanf(\"%d%d%d\", &a, &b, &c);\n      a--;b--;\n      cost[a][b] = cost[b][a] = c;\n    }\n\n    rep(i, n) rep(j, n) rep(k, n)\n      cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n    /*    rep(i, n){\n      rep(j, n) printf(\"%d \", cost[i][j]);\n      puts(\"\");\n      } */  \n \n    int res = INF;\n    rep(i, n){\n      res = min(res, cost[s][i] + cost[i][g1] + cost[i][g2]);\n      //      printf(\"%d + %d + %d\\n\", cost[s][i], cost[i][g1], cost[i][g2]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define MAX_V 1000\n\nstruct edge{\n\tlong long int to;\n\tlong long int cost;\n};\n\nlong long int INF = 1000000000000000;\n\ntypedef pair<long long int, long long int> P; // first??????????????¢???second??????????????????\n\nvector<edge> G[MAX_V];\nlong long int d[MAX_V];\n\n// ?????????O(|E|log|V|)\n\nvoid shortest_path(long long int s, long long int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(long long int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tlong long int v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(long long int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tlong long int n, m, s, g1, g2;\n\t\t\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e1;\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\te1.to = to;\n\t\t\te1.cost = cost;\n\t\t\tG[from].push_back(e1);\n\t\t}\n\t\t\n\t\tlong long int ans = INF;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tshortest_path(s, n);\n\t\t\tlong long int cost_sum = d[i];\n\t\t\tshortest_path(i, n);\n\t\t\tcost_sum += d[g1] + d[g2];\n\t\t\tif(ans > cost_sum){\n\t\t\t\tans = cost_sum;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define INF (1e9)\n#define N 101\nusing namespace std;\nint n,m,s,g1,g2,b,e,c,cost[N][N],d[N][N],ans;\nvoid warshall_floyd();\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) cost[i][j]=d[i][j]=INF;\n    for(int i=0;i<N;i++) d[i][i]=0;\n    while(m--) cin>>s>>e>>c,cost[s-1][e-1]=d[s-1][e-1]=c;\n    warshall_floyd();\n    ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,d[s-1][i]+d[i][g1-1]+d[i][g2-1]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid warshall_floyd(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define rep(i,n)   for(int i=0;i<n;++i)\n#define rep1(i,n)  for(int i=1;i<=n;++i)\n#define INF        ( 1<<20 )\n\nusing namespace std;\n\nint costs[101][101];\n\nint main()\n{\n\tint N,M,S,G1,G2;\n\twhile(cin>>N>>M>>S>>G1>>G2,N|M|S|G1|G2)\n\t{\n\t\trep1(i,N)rep1(j,N)costs[i][j] = INF;\n\t\trep1(i,N)costs[i][i] = 0;\n\n\t\tint b1,b2,c;\n\t\trep(i,M)\n\t\t{\n\t\t\tcin>>b1>>b2>>c;\n\t\t\tcosts[b1][b2] = /*costs[b2][b1] = */c;\n\t\t}\n\n\t\trep1(k,N)rep1(i,N)rep1(j,N)\n\t\t{\n\t\t\tcosts[i][j] = min(costs[i][j], costs[i][k] + costs[k][j]);\n\t\t}\n\n\t\tint m = INF;\n\t\trep1(i,N)\n\t\t{\n\t\t\tm = min(m, costs[S][i] + costs[i][G1] + costs[i][G2]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 123456789;\n\nstruct Edge{\n  int to, cost;\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nVI prv(101);\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(auto& e:edges[v]){\n\t  if(d[e.to] > d[v] + e.cost){\n\t\tprv[e.to] = v;\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, S, G1, G2;\n  while(cin>>N>>M>>S>>G1>>G2, N){\n\tint cost[101][101];\n\tfill((int*)cost, (int*)cost+101*101, INF);\n\tREP(i,M){\n\t  int a, b, t; cin >> a >> b >> t;\n\t  cost[a][b] = t;\n\t}\n\n\tREP(k,N+1) REP(i,N+1) REP(j,N+1){\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t}\n\n\tint ans = INF;\n\tREP(i,N+1){\n\t  ans = min(ans, cost[S][i] + cost[i][G1] + cost[i][G2]);\n\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\tg1--; g2--; s--;\n\t\tvector<vector<int> >d(n, vector<int>(n, INF));\n\t\trep(i, 0, n)d[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c; b1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\trep(k, 0, n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 10000001\n\n#define MAX_SIZE 101\nlong long g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tfor (int k = 0; k < v; ++k) {\n\t\tfor (int i = 0; i < v; ++i) {\n\t\t\tfor (int j = 0; j < v; ++j) {\n\t\t\t\tg_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\tfill(g_d[0], g_d[0] + MAX_SIZE*MAX_SIZE, INF);\n\t\tfor (int i = 0; i<MAX_SIZE; ++i) {\n\t\t\tg_d[i][i] = 0;\n\t\t}\n\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tint b1,b2;\n\t\t\tcin >> b1 >> b2;\n\t\t\t--b1; --b2;\n\t\t\tcin >> g_d[b1][b2];\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tlong long cost = INF;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n\nusing namespace std;\n\nconst int INF=100000000;\n\nlong int field[101][101];\nlong int costs;\nint s,g1,g2;\nint n,m;\nint f,t,c;\n\nvoid root(){\n\tint a,b;\n\tfor(b=1;b<=n;b++){\n\t\tfor(a=1;a<=n;a++){\n\t\t\tfield[a][b]=min(field[a][b],field[a][f]+field[f][t]+field[t][b]);\n\t\t}\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tcosts=min(costs,field[s][a]+field[a][g1]+field[a][g2]);\n\t}\n}\n\nint main(void){\n\tint a,b;\n\twhile(1){\n\t\tfor(b=0;b<=100;b++){\n\t\t\tfor(a=0;a<=100;a++){\n\t\t\t\tfield[a][b]=INF;\n\t\t\t\tif(a==b)field[a][b]=0;\n\t\t\t}\n\t\t}\n\t\tcosts=INF;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\t\tfor(a=0;a<m;a++){\n\t\t\tcin >> f >> t >> c;\n\t\t\tfield[f][t]=c;\n\t\t}\n\t\troot();\n\t\tcout << costs << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    warshallFloyd(g, n);\n    // pma(g, n);\n    \n    int ans = -1;\n    REP(i, n){\n        if(g[s][i] != -1 && g[i][g1] != -1 && g[i][g2] != -1){\n            int cost = g[s][i] + g[i][g1] + g[i][g2];\n            ans = ans == -1 ? cost : min(ans, cost);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[102][102];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                if(i == j) road[i][j] = 0;\n                else road[i][j] = 1000000000;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int k = 1; k < n + 1; k++){\n            for(int i = 1; i < n + 1; i++){\n                for(int j = 1; j < n + 1; j++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 1; i < n + 1; i++){\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tll d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define fr first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define FOR(i,j,n) for(int i=j;i<n;i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SET(c) memset((c),0,sizeof(c))\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define COPY(arr,to) copy(ALL(arr),back_inserter(to))\n#define BIT(n) ((1 << n) - 1)\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> iP;\ntypedef pair<iP,int> iiP;\ntypedef vector<int> vi;\ntypedef vector<iP> vii;\ntypedef stringstream ss;\n\n//Right,Under,Left,Top\nconst int dx[]={1,0,-1,0,-1,1,1,-1};\nconst int dy[]={0,1,0,-1,-1,1,-1,1}; \nconst int INF = 2 << 28;\nconst double EPS = 1e-9;\n\nstring get(){ string s; cin.ignore(); getline(cin,s); cin.ignore(); return s; }\nint value(){ int v; cin >> v; return v; }\nbool isPrime(int v){ for(int i=2;i*i<=v;i++) if(!(v % i)) return false; return (v >= 2); }\nbool isOver(int x,int y,int w,int h){ return (x >= 0 && x < w && y >= 0 && y < h); }\ninline int toInt(string s){ int f; ss sss; sss << s; sss >> f; return f; }\ntemplate<class T> inline string toStr(T f){ ss sss; sss << f; return sss.str(); }\n\nint main(){\n  int cost[128][128];\n  int n,m,s,g1,g2;\n  while(cin >> n >> m >> s >> g1 >> g2,n||m||s||g1||g2){\n    REP(i,n+1){\n      REP(j,n+1){\n\tif(i == j) cost[i][j] = 0;\n\telse cost[i][j] = INF;\n      }\n    }\n    REP(i,m){\n      int t,m,p; cin >> t >> m >> p;\n      cost[t][m] = p;\n    }\n    FOR(i,1,n+1){\n      FOR(j,1,n+1){\n\tFOR(k,1,n+1) cost[j][k] = min(cost[j][k],cost[j][i] + cost[i][k]);\n      }\n    }\n    int ret = INF;\n    FOR(i,1,n+1) ret = min(ret,cost[s][i] + cost[i][g1] + cost[i][g2]);\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tif(n == 0) break;\n\t\tll d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define N 100\nconst int infty = 1<<24;\nint MinimumSteinerTree(int nt, int T[], int n, int G[][N]){\n  if( nt <= 1 ) return 0;\n  int d[n][n];\n\n  for(int i=0;i<n;++i)\n    for(int j=0;j<n;++j)\n      d[i][j]=G[i][j];\n\n  for(int k=0;k<n;++k)\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n  \n  const int space = 1<<nt;\n  int dp[space][n];\n  for(int s=0;s<space;++s)\n    for(int x=0;x<n;++x)\n      dp[s][x]=infty;\n\n  // |S| = 2\n  for(int p=0;p<nt;++p)\n    for(int q=0;q<n;++q)\n      dp[1<<p][q]=d[T[p]][q];\n  \n  /* faster */\n  for(int s=1;s<space;++s){\n    if(!(s&(s-1)))continue;\n    for(int p=0;p<n;++p)\n      for(int e=0;e<s;++e)\n\tif((e|s)==s)\n\t  dp[s][p]=min(dp[s][p],dp[e][p]+dp[s-e][p]);\n    for(int p=0;p<n;++p)\n      for(int q=0;q<n;++q)\n\tdp[s][p]=min(dp[s][p],dp[s][q]+d[p][q]);\n  }\n  \n  /*\n  // |S| >= 2\n  for(int s=1;s<space;++s){\n    for(int p=0;p<n;++p){\n      int tmp = infty;\n      for(int q=0;q<n;++q)\n\tfor(int e=0;e<s;++e)\n\t  if((e|s)==s)\n\t    tmp = min(tmp,d[p][q]+dp[e][q]+dp[s-e][q]);\n      dp[s][p]=min(dp[s][p],tmp);\n    }\n  }\n  */\n\n  int ret=infty;\n  for(int s=0;s<space;++s)\n    for(int q=0;q<n;++q)\n      ret=min(ret,dp[s][q]+dp[(space-1)-s][q]);\n\n  return ret;\n}\n\nint main()\n{\n  int n,m,s,g1,g2;\n  while(cin >> n >> m >> s >> g1 >> g2 && n ){\n    int ans=0;\n    int G[N][N];\n    int T[3];\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tG[i][j] = infty;\n      }\n    }\n    for(int i = 0; i < m; ++i){\n      int s,d,c;\n      cin >> s >> d >> c;\n      G[s-1][d-1] = G[d-1][s-1] = c;\n    }\n    T[0]=s-1;T[1]=g1-1;T[2]=g2-1;\n    ans = MinimumSteinerTree(3,T,n,G);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  [VtCh\n   ém[hKðoR·éP[Xðl¦é\n  s©çKÌÅZoHAK©çg1,g2ÌÅZoH\n */\n\nint n,m,s,g1,g2;\nint node[128][128];\nint main(){\n  while(cin>>n>>m>>s>>g1>>g2, n|m|s|g1|g2){\n    s--; g1--; g2--;\n    rep(i,128)rep(j,128)node[i][j] = INT_MAX;\n    rep(i,128)node[i][i] = 0;\n\n    // input\n    rep(i,m){\n      int a,b,c; cin>>a>>b>>c;\n      node[a-1][b-1] = c;\n    }\n    // [VtCh\n    rep(k,n){\n      rep(i,n){\n\trep(j,n){\n\t  if( node[i][k]==INT_MAX || node[k][j]==INT_MAX )continue;\n\t  node[i][j] = min(node[i][j] , node[i][k]+node[k][j]);\n\t}\n      }\n    }\n#if DEB\n    rep(i,n){\n      rep(j,n){\n\tprintf(\"%2d \",node[i][j]);\n      }\n      puts(\"\");\n    }\n#endif\n    int ans = INT_MAX;\n    rep(k,n){ //oR·ém[hðßé\n      if( k==g1 ){\n\tif( node[s][g1]!=INT_MAX && node[g1][g2]!=INT_MAX ){\n\t  ans = min(ans, node[s][g1] + node[g1][g2]);\n\t}\n      }else if( k==g2 ){\n\tif( node[s][g2]!=INT_MAX && node[g2][g1]!=INT_MAX ){\n\t  ans = min(ans, node[s][g2] + node[g2][g1]);\n\t}\n      }else{\n\tif( node[s][k]!=INT_MAX && node[k][g1]!=INT_MAX && node[k][g2]!=INT_MAX ){\n\t  ans = min(ans, node[s][k]+node[k][g1]+node[k][g2]);\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E8;\nint n, m, s, g1, g2;\nint v, w, c;\nint d[111][111];\n\nint main()\n{\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    rep(i, n) rep(j, n) d[i][j] = INF;\n    rep(i, n) d[i][i] = 0;\n    rep(i, m){\n      cin >> v >> w >> c;\n      d[v - 1][w - 1] = c;\n    }\n    rep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int res = INF;\n    rep(i, n) res = min(res, d[s - 1][i] + d[i][g1 - 1] + d[i][g2 - 1]);\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define INF (1<<28)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint n,m,s,g,h;\n\nint v[100][100];\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \",\";\n\tout << \"}\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m >> s >> g >> h, n){\n\t\trep(i,100)rep(j,100) v[i][j] = i==j?0:INF;\n\t\tint ans = INF;\n\t\ts--; g--; h--;\n\t\trep(i,m){\n\t\t\tint x, y, c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tv[x-1][y-1] = c;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n) v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\n\t\trep(i,n){\n\t\t\tans = min (ans, v[s][i] + v[i][g] + v[i][h]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int b1,b2,c;\n  int pipe[MAX][MAX];\n  int ans;\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      pipe[i][j]=INF;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      for( int k=0;k<n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  ans=INF;\n  for( int i=0;i<n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const INF = (int)1e9;\n\nint main() {\n  int N, M, S, g1, g2;\n  \n  while(cin >> N >> M >> S >> g1 >> g2 && N) {\n    int cost[100][100]; fill(cost[0], cost[0]+10000, INF);\n    for(int i=0; i<N; i++) cost[i][i] = 0;\n    S--, g1--, g2--;\n    for(int i=0; i<M; i++) {\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      cost[a][b] = c;\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    \n    int ans = INF;\n    for(int k=0; k<N; k++) {\n      ans = min(ans, cost[S][k] + cost[k][g1] + cost[k][g2]);\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pd(a) printf(\"%.10f\\n\",a)\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define pi M_PI\n#define R cin>>\n#define F first\n#define S second\n#define C class\n#define ll long long\n#define ln cout<<'\\n'\n#define _(_1,_2,_3,N,...)N\n#define pr(...) _(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<C T>void pr1(T a){cout<<a;ln;}\ntemplate<C T,C T2>void pr2(T a,T2 b){cout<<a<<' '<<b;ln;}\ntemplate<C T,C T2,C T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c;ln;}\ntemplate<C T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nvoid Main() {\n  int n,m,s,t,r;\n  while(cin >> n >> m >> s >> t >> r && n) {\n    s--,t--,r--;\n    ll d[n][n];\n    rep(i,n)rep(j,n)d[i][j]=MAX;\n    rep(i,n)d[i][i]=0;\n    rep(i,m) {\n      int x,y,z;\n      cin >> x >> y >> z;\n      x--,y--;\n      d[x][y]=z;\n    }\n    rep(k,n)rep(i,n)rep(j,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    ll ans=MAXL;\n    rep(i,n) ans=min(ans,d[s][i]+d[i][t]+d[i][r]);\n    pr(ans);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);\n  Main();return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n;){\n    vector<vector<int>> d(n, vector<int> (n, INF));\n\n    for(int i=0;i<m;++i){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nlong long d[100][100];\n\nvoid warshall_floyd(int V){\n  rep(i,V){\n    d[i][i] = 0;\n  }\n  rep(i,V){\n      rep(j,V){\n          rep(k,V){\n              d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n          }\n      }\n  }\n}\n\nint main(){\n  while(1){\n    long long n,m,s,g1,g2,from,to,cost,minn=1e9;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0)break;\n    s--;g1--;g2--;\n    rep(i,n){rep(j,n){d[i][j]=1e9;}}\n    rep(i,m){\n      cin >> from >> to >> cost;\n      from--;to--;\n      d[from][to] = cost;\n    }\n    warshall_floyd(n);\n    rep(i,n)if (minn>d[s][i]+d[i][g1]+d[i][g2]) minn=d[s][i]+d[i][g1]+d[i][g2];\n    cout << minn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nlong long d[100][100];\n\nvoid warshall_floyd(int V){\n  rep(i,V){\n    d[i][i] = 0;\n  }\n  rep(i,V){\n      rep(j,V){\n          rep(k,V){\n              d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n          }\n      }\n  }\n}\n\nint main(){\n  while(1){\n    long long n,m,s,g1,g2,from,to,cost,minn=1e9;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0)break;\n    s--;g1--;g2--;\n    rep(i,n){rep(j,n){d[i][j]=1e9;}}\n    rep(i,m){\n      cin >> from >> to >> cost;\n      from--;to--;\n      d[from][to] = cost;\n    }\n    rep(i,n)if (minn>d[s][i]+d[i][g1]+d[i][g2]) minn=d[s][i]+d[i][g1]+d[i][g2];\n    cout << minn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\nvoid Dijkstra(int n, int s, int edge[][100], int node[])\n{\n    int close[100]={0};\n    int mn;\n    node[s] = 0;\n    for(int i=0;i<n;++i)\n    {\n        close[s] = 1;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && edge[s][j] && node[j] > node[s]+edge[s][j])\n            {\n                node[j] = node[s]+edge[s][j];\n            }\n        }\n        mn = INT_MAX;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && mn > node[j])\n            {\n                mn = node[j];\n                s = j;\n            }\n        }\n    }\n}\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int node1[100];\n    int node2[100];\n    int node3[100];\n    int close[100]={0};\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;++j) edge[i][j] = 0;\n            node1[i] = INT_MAX;\n            node2[i] = INT_MAX;\n            node3[i] = INT_MAX;\n        }\n        for(int i=0;i<m;++i)\n        {\n            cin >> b1 >> b2 >> c;\n            edge[b1][b2] = c;\n            edge[b2][b1] = c;\n        }\n        Dijkstra(n,s,edge,node1);\n        Dijkstra(n,g1,edge,node2);\n        Dijkstra(n,g2,edge,node3);\n        mn = INT_MAX;\n        for(int i=0;i<n;++i) mn = min(mn, node1[i]+node2[i]+node3[i]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/07/23  Problem: AOJ 2005 / Link: https://onlinejudge.u-aizu.ac.jp/challenges/search/volumes/2005  ----- */\n/* ------問題------\n\n21XX 年，ついに人類は火星への移住計画を開始させた．火星への移住第一陣に選抜されたあなたは，火星行政中央局（the Administrative Center of Mars）に配属され，火星で起こる様々な問題に対処している．行政中央局の目下の最大の問題は自立した需要供給サイクルの確保である．月からの援助物資が届くまでには数ヶ月単位の時間がかかるため，基本的には火星内の需要は火星内で解決する必要がある．それに加えて，循環システムを確立するまでは資源を極力節約することが求められる．\n行政中央局は極地にある氷の採掘を開始した．太陽光でこれを溶かし，水として個々の基地に供給することが最終目標である．最初の段階として，水源のある基地から2つの主要基地までの導水管を敷設することにした．また，現時点ではいくつかの基地とそれらを結ぶ道路以外には開拓されておらず，未開拓のところに導水管を敷設するには多大なるコストと燃料を要するため，道路に沿って導水管を敷設することにした．さらに，技術上の制約のため，彼らの導水管は常に一方向だけに水が流れる．\nあなたの仕事は，これらの条件のもとで，導水管の敷設にかかるコストを最小にするプログラムを作成することである．\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n日本語が悪いのでSやGiから水が分かれるとも取れる。\n×彼らの導水管は常に一方向だけに水が流れる\n○頂点を流れる水は常に一方向である\n頂点について一方向だと、分岐点を全探索するのみ。\n\n----解説ここまで---- */\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\n\tint N, M, S, G1, G2;\n\twhile (cin >> N >> M >> S >> G1 >> G2,N) {\n\t\tconst int intINF = 2e9 / 3;\n\t\tVVI dist(N, VI(N,intINF ));\n\t\tS--, G1--, G2--;\n\t\tFOR(i, 0, N)dist[i][i] = 0;\n\t\tFOR(i, 0, M) {\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\tdist[a][b] = c;\n\t\t}\n\t\tFOR(k, 0, N)FOR(i, 0, N)FOR(j, 0, N)dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tint ans = INF;\n\t\tFOR(i, 0, N) {\n\t\t\tans = min(ans, dist[S][i] + dist[i][G1] + dist[i][G2]);\n\t\t}\n\t\tcout << ans << \"\\n\";\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[100][100];\n\tint from[100][100];\n\tint n,m,g1,g2,s,a,b,c;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n){\n\t\tint ret = (1<<21);\n\t\ts--;g1--;g2--;\n\t\trep(i,100)rep(j,100)wf[i][j]=(1<<26);\n\t\t\n\t\trep(i,m){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\tfrom[a][b] = a;\n\t\t\twf[a][b] = c;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tif(wf[i][j] > wf[i][k]+wf[k][j]){\n\t\t\t\twf[i][j] = wf[i][k]+wf[k][j];\n\t\t\t}\n\t\t}\n\t\trep(j,n){\n\t\t\tret = min(ret,wf[s][j]+wf[j][g1]+wf[j][g2]);\n\t\t}\n\t\tcout << min(ret,wf[s][g1]+wf[s][g2]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1 << 28) - 1;\n\nint main()\n{\n        int n, m, s, g1, g2;\n        int mdist[105][105];\n\n        while ( cin >> n >> m >> s >> g1 >> g2, n ) {\n                --s, --g1, --g2;\n\n                fill_n(*mdist, 105 * 105, INF);\n\n                while ( m-- ) {\n                        int a, b, c;\n                        cin >> a >> b >> c; --a, --b;\n                        mdist[a][b] = c;\n                }\n\n                for ( int i = 0; i < n; i++ ) mdist[i][i] = 0;\n\n                for ( int k = 0; k < n; k++ ) {\n                        for ( int i = 0; i < n; i++ ) {\n                                for ( int j = 0; j < n; j++ ) {\n                                        mdist[i][j] = min(mdist[i][j], mdist[i][k] + mdist[k][j]);\n                                }\n                        }\n                }\n\n                int minv = INF;\n\n                for ( int i = 0; i < n; i++ ) {\n                        minv = min(minv, mdist[s][i] + mdist[i][g1] + mdist[i][g2]);\n                }\n\n                cout << minv << endl;\n        }\n\n        return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m, s, g1, g2, b1, b2, c;\n  long long int INF = 1e15;\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    --s;--g1;--g2;\n    vector< vector<long long int> > G(n,vector<long long int>(n,INF));\n    for(int i = 0; i < m; ++i){\n      cin >> b1 >> b2 >> c;\n      --b1;--b2;\n      G[b1][b2] = c;\n      G[b2][b1] = c;\n    }\n    for(int k = 0; k < n; ++k)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n          G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      ans = min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct Edge {\n\tint t, cost, type;\n\tEdge(int _t, int _c, int _type) : t(_t), cost(_c), type(_type) {}\n};\n\nbool operator > (const Edge& a, const Edge& b) {\n\treturn a.cost > b.cost;\n}\n\nint n, m, s, g1, g2;\nint cost[110][110];\n\nvoid solve() {\n\tfor_(i,0,n) fill(cost[i], cost[i] + n, iINF / 2);\n\t\n\tfor_(i,0,m) {\n\t\tint v, u, c; cin >> v >> u >> c;\n\t\t--v; --u;\n\t\tcost[v][u] = c;\n\t}\n\t\n\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\n\tint ans = iINF;\n\tfor_(k,0,n) ans = min(ans, cost[s][k] + cost[k][g1] + cost[k][g2]);\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\t--s; --g1; --g2;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\tg1--; g2--; s--;\n\t\tvector<vector<int> >d(n, vector<int>(n, INF));\n\t\trep(i, 0, n)d[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c; b1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\trep(k, 0, n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define INF 1000000000\n\nint n,m,s,g1,g2;\nint t[101][101];\n\nint main(void){\n\twhile(cin>>n>>m>>s>>g1>>g2, n){\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=n;j++) t[i][j] = INF;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,cost;\n\t\t\tcin>>a>>b>>cost;\n\t\t\tt[a][b] = cost;\n\t\t}\n\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tt[i][j] = min(t[i][j],t[i][k] + t[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans = min(ans,t[s][i]+t[i][g1]+t[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n\nint min(int a, int b){ return a < b ? a : b; }\n\nint main(void){\n  while(true){\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){ break; }\n    --s; --g1; --g2;\n\n    // ??£??\\??????????§????\n    vector<vector<int> > adjmatrix(n, vector<int>(n, INF));\n    for(int i = 0; i < m; i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      --b1; --b2;\n      adjmatrix[b1][b2] = c;\n      adjmatrix[b2][b1] = c;\n    }\n    for(int i = 0; i < n; i++){ adjmatrix[i][i] = 0; }    \n\n    // ???????????£???\n    for(int k = 0; k < n; k++)\n      for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n          adjmatrix[i][j] = min(adjmatrix[i][j], adjmatrix[i][k] + adjmatrix[k][j]);\n\n    // ???????????±???????????????????????????\n    int mincost = INF;\n    for(int i = 0; i < n; i++){\n      mincost = min(mincost, adjmatrix[s][i] + adjmatrix[i][g1] + adjmatrix[i][g2]);\n    }\n\n    // ??????\n    cout << mincost << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define INF INT_MAX\n#define SIZE 1002\nusing namespace std;\n\nint main(){\n\n  int cost[SIZE][SIZE];\n  int i,a,b,c;\n  int n,m,s,g1,g2;\n\n  while(1){\n\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0)break;\n\n    for(i=0;i<m;i++){\n      cin>>a>>b>>c;\n      cost[a][b]=cost[b][a]=c;\n    }\n\n\n    printf(\"15\\n\");\n  }\n\n\n  return 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 127, sizeof(z));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t\tx[b][a] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef struct {\n    int from, to;\n    int cost;\n} edge;\n\nint main() {\n    while (true) {\n        int b_goal[2];\n        int n_bases, n_roads, b_start;\n        cin >> n_bases >> n_roads >> b_start >> b_goal[0] >> b_goal[1];\n\n        if (n_bases == 0) break;\n\n        map< int, vector<edge> > edges;\n        map< int, vector<edge> > redges;\n\n        while (n_roads--) {\n            int b_from, b_to, cost;\n            cin >> b_from >> b_to >> cost;\n            edge e = { b_from, b_to, cost };\n            edges[b_from].push_back(e);\n            redges[b_to].push_back(e);\n        }\n\n        map<int, int> cost_from_start;\n        for (int b = 1; b <= n_bases; ++b) {\n            cost_from_start[b] = INT_MAX;\n        }\n\n        queue<edge> q;\n\n        {\n            vector<edge> ee = edges[b_start];\n            for (size_t i = 0; i < ee.size(); ++i) {\n                q.push(ee[i]);\n            }\n        }\n\n        cost_from_start[b_start] = 0;\n        for (; !q.empty(); q.pop()) {\n            edge e = q.front();\n\n            int new_cost = cost_from_start[e.from] == INT_MAX ? INT_MAX : cost_from_start[e.from] + e.cost;\n            if (new_cost < cost_from_start[e.to]) {\n                cost_from_start[e.to] = new_cost;\n\n                vector<edge> ee = edges[e.to];\n                for (size_t i = 0; i < ee.size(); ++i) {\n                    q.push(ee[i]);\n                }\n            }\n        }\n\n        map<int, vector<int> > costs_from_goal;\n        for (int b = 1; b <= n_bases; ++b) {\n            costs_from_goal[b] = vector<int>(2, INT_MAX);\n        }\n\n        for (int I = 0; I <= 1; I++) {\n            vector<edge> ee = redges[b_goal[I]];\n            for (size_t i = 0; i < ee.size(); ++i) {\n                q.push(ee[i]);\n            }\n\n            costs_from_goal[b_goal[I]][I] = 0;\n            for (; !q.empty(); q.pop()) {\n                edge e = q.front();\n\n                int new_cost = costs_from_goal[e.to][I] == INT_MAX ? INT_MAX : costs_from_goal[e.to][I] + e.cost;\n                if (new_cost < costs_from_goal[e.from][I]) {\n                    costs_from_goal[e.from][I] = new_cost;\n\n                    vector<edge> ee = redges[e.from];\n                    for (size_t i = 0; i < ee.size(); ++i) {\n                        q.push(ee[i]);\n                    }\n                }\n            }\n        }\n\n        int min = INT_MAX;\n        for (int b = 1; b <= n_bases; ++b) {\n            if (cost_from_start[b] == INT_MAX) continue;\n            if (costs_from_goal[b][0] == INT_MAX) continue;\n            if (costs_from_goal[b][1] == INT_MAX) continue;\n\n            int v = cost_from_start[b] + costs_from_goal[b][0] + costs_from_goal[b][1];\n            if (v < min) {\n                min = v;\n            }\n        }\n        cout << min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, s, e) for(int i = (int)s; i < (int) e; i++)\n#define rep(i, n) REP(i, 0 ,n)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp nake_pair\n\ntypedef long long ll;\n\nll d[110][110];\n\nint main(){\n    int n, m, s, g1, g2;\n    while(~scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2)){\n        if(n == 0 && m == 0) break;\n        rep(i, 110) rep(j, 110) d[i][j] = (i == j ) ? 0LL : 1e18;\n        int b1, b2, c;\n        rep(i, m){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            d[b1][b2] = (ll)c;\n        }\n        rep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        ll ans = 1e18;\n        rep(i, n){\n            ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define BMAX 100\n#define DMAX 1000000\n\nusing namespace std;\n\nstruct data { \n\tint cost;\n\tint where;\n};\n\n//bool bind[BMAX][BMAX];\nint cost[BMAX][BMAX];\n\n\nbool operator<( const data& a, const data& b) {\n\treturn a.cost < b.cost;\n}\n\nbool operator>( const data& a, const data& b) {\n\treturn a.cost > b.cost;\n}\n\nint main () {\n\tint count = 0;\n\twhile ( true ) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m>> s>> g1>> g2;\n\t\t//cout << \"Count: \" << count << endl;\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcost[i][j] = DMAX;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint x,y,c;\n\t\t\tcin >> x >> y >> c;\n\t\t\t//\t\t\tcout << x << \"\\t\" << y << \"\\t\" << c << endl;\n\t\t\tcost[x][y] = c;\n\t\t\tcost[y][x] = c;\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << cost[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\t\n\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tpriority_queue<data> flow;\n\n\t\t\twhile(!flow.empty()) {\n\t\t\t\tflow.pop();\n\t\t\t}\n\n\t\t\tdata now;\n\t\t\tnow.cost = 0;\n\t\t\tnow.where = i;\n\t\t\tflow.push(now);\n\n\t\t\twhile ( !flow.empty() ) {\n\t\t\t\tdata now = flow.top();\n\t\t\t\tflow.pop();\n\n\t\t\t\tdata next;\n\n\t\t\t\tbool check[n];\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tcheck[i] = true;\n\t\t\t\t}\n\t\t\t\tcheck[now.where] = false;\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tif ( check[i] ) {\n\t\t\t\t\t\tcheck[i] = false;\n\t\t\t\t\t\tint newCost = cost[i][now.where] + now.cost;\n\t\t\t\t\t\tif ( cost[i][j] >= newCost ) {\n\t\t\t\t\t\t\tif ( cost[i][j] > newCost )\n\t\t\t\t\t\t\t\tcost[i][j] = newCost;\n\t\t\t\t\t\t\tnext.cost = newCost;\n\t\t\t\t\t\t\tnext.where = j;\n\t\t\t\t\t\t\tflow.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min = DMAX;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tif ( min > cost[i][s] + cost[i][g1] + cost[i][g2] )\n\t\t\t\tmin = cost[i][s] + cost[i][g1] + cost[i][g2];\n\t\t}\n\n\t\tcout << min << endl;;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_station;\n  int total_road;\n  int water_source_idx;\n  int main_station1_idx;\n  int main_station2_idx;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_station,\n\t       &total_road,\n\t       &water_source_idx,\n\t       &main_station1_idx,\n\t       &main_station2_idx)){\n    if(total_station == 0) break;\n\n    int nodes[101][101];\n    memset(nodes,0x3f,sizeof(nodes));\n\n    for(int i=0;i<total_road;i++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      nodes[from][to] = cost;\n      nodes[to][from] = cost;\n    }\n\n    for(int k=1;k<=total_station;k++){\n      for(int i=1;i<=total_station;i++){\n\tfor(int j=1;j<=total_station;j++){\n\t  nodes[i][j] = min(nodes[i][k]+nodes[k][j],nodes[i][j]);\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=1;i<=total_station;i++){\n      res = min(nodes[water_source_idx][i]\n\t\t+ nodes[i][main_station1_idx]\n\t\t+ nodes[i][main_station2_idx],res);\n    }\n\n    printf(\"%d\\n\",res);\n  }\n\t       \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\nint cost[101][101];\nint mincost[101][101];\nint n,m,s,g1,g2;\nvoid warshall_floyd(){\n  for(int i = 0 ; i < n ; i++ )\n    for(int j = 0 ; j < n ; j++ ){\n      if(i == j)mincost[i][j] = 0;\n      else mincost[i][j] = INF;\n    }\n\n  for(int i = 0 ; i < n ; i++ ){\n    for(int j = 0 ; j < n ; j++ ){\n      for(int k = 0 ; k < n ; k++ ){\n\tmincost[j][k] = min(mincost[j][k],cost[j][i] + cost[i][k]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while( cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2 ){\n    n++;\n    for(int i = 0 ; i < n ; i++ )\n      for(int j = 0 ; j < n ; j++ ){\n\tif(i == j)cost[i][j] = 0;\n\telse cost[i][j] = INF;\n      }\n\n    for(int i = 0 ; i < m ; i++ ){\n      int a,b,c;\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n    }\n    warshall_floyd();\n\n    int mn = INF;\n    for(int i = 0 ; i < n ; i++ )\n      mn = min(mincost[s][i] + mincost[i][g1] + mincost[i][g2],mn);\n    cout << mn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef struct edge{\n  int to, cost;\n}edge;\n\nint main(){\n  int n, m, s, a, b, from, to, cost;\n  while(cin >> n >> m >> s >> a >> b, n){\n    s--, a--, b--;\n    vector<vector<edge> > g(n);\n    for(int i = 0; i < m; i++){\n      cin >> from >> to >> cost;\n      from--, to--;\n      g[from].push_back(edge{to, cost});\n    }\n    vector<vector<int> > dp(n, vector<int>(n, 1e9));\n    dp[s][s] = 0;\n    for (int i = 0; i < g[s].size(); i++) dp[s][g[s][i].to] = dp[g[s][i].to][s] = g[s][i].cost;\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < n; k++) {\n          for (int l = 0; l < g[j].size(); l++) {\n            if(j == s and k == g[j][l].to)dp[k][g[j][l].to] = dp[g[j][l].to][k] = min(dp[k][g[j][l].to], dp[j][k]);\n            else dp[k][g[j][l].to] = dp[g[j][l].to][k] = min(dp[k][g[j][l].to], dp[j][k] + g[j][l].cost);\n          }\n          for (int l = 0; l < g[k].size(); l++) {\n            if(j == g[k][l].to and k == s)dp[j][g[k][l].to] = dp[g[k][l].to][j] = min(dp[j][g[k][l].to], dp[j][k]);\n            else dp[j][g[k][l].to] = dp[g[k][l].to][j] = min(dp[j][g[k][l].to], dp[j][k] + g[k][l].cost);\n          }\n        }\n      }\n    }\n    // for (int i = 0; i < n; i++) {\n    //   for (int j = 0; j < n; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    std::cout << dp[a][b] << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<climits>\nusing namespace std;\n#define INF INT_MAX\n\nint n,m,s,g1,g2;\nvector< vector<long long> > edge;\n\nvoid init(){\n  n=m=s=g1=g2=0;\n  edge.clear();\n}\n\nbool input(){\n  cin>>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0){\n    return 0;\n  }\n  s--;g1--;g2--;\n  edge.resize(n);\n  for(int i=0;i<n;i++){\n    edge[i].resize(n);\n    for(int j=0;j<n;j++){\n      edge[i][j]=INF;\n    }\n  }\n  for(int i=0;i<m;i++){\n    long long  b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--;b2--;\n    edge[b1][b2]=c;\n  }\n  return 1;\n}\n\n\n\n\nint solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      }\n    }\n  }\n  long long res=INF;\n  for(int i=0;i<n;i++){\n    res=min(res,edge[s][i]+edge[i][g1]+edge[i][g2]);\n  }\n  return res;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nstruct Edge { int from; int to; long long weight; };\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\ntypedef std::pair<long long, int> P;\n\nstd::vector<long long> dijkstra(const Graph &g, int src) {\n\tstd::vector<long long> d(g.size(), std::numeric_limits<long long>::max()/5);\n\td[src] = 0;\n\t//vector<int> prev(g.size());\n\tstd::priority_queue<P, std::vector<P>, std::greater<P>> q;\n\tq.push({ 0, src });\n\twhile (!q.empty()) {\n\t\tauto p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif (p.first > d[v]) continue;\n\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.weight) {\n\t\t\t\td[e.to] = d[v] + e.weight;\n\t\t\t\tq.push({ d[e.to],e.to });\n\t\t\t\t//prev[e.to] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m, s, a, b;\n\twhile (cin >> n >> m >> s >> a >> b, n) {\n\t\ts--; a--; b--;\n\t\tGraph g(n), rg(n);\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tg[a].push_back(Edge{ a,b,c });\n\t\t\trg[b].push_back(Edge{ b,a,c });\n\t\t}\n\t\tvl d = dijkstra(g, s), da = dijkstra(rg, a), db = dijkstra(rg, b);\n\t\tll ans = INF * INF;\n\t\tREP(i, n) {\n\t\t\tchmin(ans, d[i] + da[i] + db[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n    int i,j,k;\n    int n,m,s,g1,g2;\n    int v[100][100];\n    while(cin >> n >> m >> s >> g1 >> g2, n){\n        s--;g1--;g2--;\n        rep(i,n)rep(j,n){\n            if(i == j) v[i][j] = 0;\n            else v[i][j] = INF;\n        }\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v[a][b] = c;\n            v[b][a] = c;\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n        }\n        int ans = INF;\n\n        rep(i,n){\n            ans = min(ans, v[s][i] + v[i][g1] + v[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define int ll\n#define INF 999999999\n\nsigned main(){\n    int edge[110][110];\n    rep(i,110)rep(j,110)edge[i][j]=INF;\n    rep(i,110)edge[i][i]=0;\n    int v,e,s,g1,g2;\n    while(cin>>v>>e>>s>>g1>>g2&&v&&e&&s&&g1&&g2){\n        s--,g1--,g2--;\n        rep(i,e){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--,b--;\n            edge[a][b]=c;\n        }\n        \n        \n        rep(k,v){\n            rep(i,v){\n                rep(j,v){\n                    edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n                }\n            }\n        }\n        int mini=INF;\n        rep(i,v){\n            mini = min(edge[s][i]+edge[i][g1]+edge[i][g2],mini);\n        }\n        cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define BMAX 100\n#define DMAX 1000000\n\nusing namespace std;\n\nstruct data { \n\tint cost;\n\tint where;\n};\n\n//bool bind[BMAX][BMAX];\nint cost[BMAX][BMAX];\nint dis[BMAX][BMAX];\nbool check[BMAX];\n\nbool operator<( const data& a, const data& b) {\n\treturn a.cost < b.cost;\n}\n\nbool operator>( const data& a, const data& b) {\n\treturn a.cost > b.cost;\n}\n\nint main () {\n\tint count = 0;\n\twhile ( true ) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m>> s>> g1>> g2;\n\t\t//cout << \"Len \" << m << n << m << s << endl;\n\t\t//cout << \"Count: \" << count << endl;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcost[i][j] = DMAX;\n\t\t\t\tdis[i][j] = DMAX;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tcost[i][i] = 0;\n\t\t\tdis[i][i] = 0;\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint x,y,c;\n\t\t\tcin >> x >> y >> c;\n\t\t\t//\t\t\tcout << x << \"\\t\" << y << \"\\t\" << c << endl;\n\t\t\tcost[x-1][y-1] = c;\n\t\t\t//cost[y-1][x-1] = c;\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << cost[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << dis[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tpriority_queue<data> flow;\n\n\t\t\twhile(!flow.empty()) {\n\t\t\t\tflow.pop();\n\t\t\t}\n\n\t\t\tdata now;\n\t\t\tnow.cost = 0;\n\t\t\tnow.where = i;\n\t\t\tflow.push(now);\n\t\t\t//cout << \"Start\" << i << endl;\n\t\t\twhile ( !flow.empty() ) {\n\t\t\t\tdata now = flow.top();\n\t\t\t\tflow.pop();\n\n\t\t\t\tdata next;\n\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tcheck[j] = true;\n\t\t\t\t}\n\t\t\t\tcheck[now.where] = false;\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tif ( check[j] ) {\n\t\t\t\t\t\t//cout << \"search \" << now.where << \"->\" << j << endl;\n\t\t\t\t\t\tcheck[j] = false;\n\t\t\t\t\t\t//cout << \"Raw\" << dis[now.where][j] << \"\\t\" << cost[now.where][j] << endl;\n\t\t\t\t\t\tint newDCost = dis[now.where][j] + now.cost ;\n\t\t\t\t\t\tint newCCost = cost[now.where][j] + now.cost ;\n\t\t\t\t\t\tint newCost;\n\t\t\t\t\t\tif ( newDCost < newCCost )\n\t\t\t\t\t\t\tnewCost = newDCost;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnewCost = newCCost;\n\t\t\t\t\t\t//cout << \"D \" << newDCost << \"\\tC \" << newCCost << endl;\n\t\t\t\t\t\t//cout << dis[i][j] << \" \" << newCost << endl;\n\t\t\t\t\t\tif ( dis[i][j] > newCost ) {\n\t\t\t\t\t\t\t//cout << \"Pass\" << endl;\n\t\t\t\t\t\t\tif ( dis[i][j] > newCost )\n\t\t\t\t\t\t\t\tdis[i][j] = newCost;\n\t\t\t\t\t\t\tnext.cost = newCost;\n\t\t\t\t\t\t\tnext.where = j;\n\t\t\t\t\t\t\tif ( next.cost != DMAX ) {\n\t\t\t\t\t\t\t\t//cout << \"New: \" << newCost << endl;\n\t\t\t\t\t\t\t\tflow.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << dis[i][j] << \" \" << newCost << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"Size: \" << flow.size() << endl;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << dis[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tint min = DMAX;\n\t\tint minb;\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tif ( min > dis[s][i] + dis[i][g1] + dis[i][g2] ) {\n\t\t\t\tmin = dis[s][i] + dis[i][g1] + dis[i][g2];\n\t\t\t\tminb = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << min << endl;\n\t\t//cout << min << \"\\t\" << minb << endl;;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define INF 1 << 29\n\nusing namespace std;\n\nint n, m, s, g1, g2;\nint cost[100][100];\n\nint main(){\n\n  while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n+m+s+g1+g2){\n    s--;g1--;g2--;\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    rep(i, n) cost[i][i] = 0;\n    int a, b, c;\n    rep(i, m){\n      scanf(\"%d%d%d\", &a, &b, &c);\n      a--;b--;\n      cost[a][b] = cost[b][a] = c;\n    }\n\n    rep(i, n) rep(j, n) rep(k, n)\n      cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n    /*    rep(i, n){\n      rep(j, n) printf(\"%d \", cost[i][j]);\n      puts(\"\");\n      } */ \n \n    int res = INF;\n    rep(i, n){\n      res = min(res, cost[s][i] + cost[i][g1] + cost[i][g2]);\n      //      printf(\"%d + %d + %d\\n\", cost[s][i], cost[i][g1], cost[i][g2]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define ERASE(v,i) (v).erase(remove(all(v),i),(v).end())\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define LINE cerr<<\"LINE: \"<<__LINE__<<endl;\n\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> void preview(T a,T b){for(T it=a;it!=b;++it)cerr<<*it<<\" \";cerr<<endl;}\n\nconst int INF = 100000000;\nconst double PI = acos(-1.0), EPS = 1e-10;\n\nint main() {\n\tfor(int n,m,s,g1,g2; cin>>n>>m>>s>>g1>>g2, n || m || s || g1 || g2;) {\n\t\tstatic int v[101][101];\n\t\trep(i,101) fill(v[i], v[i] + 101, INF);\n\t\trep(i,101) v[i][i] = 0;\n\t\trep(i,m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a][b] = c;\n\t\t}\n\n\t\trep(k, n+1) rep(i, n+1) rep(j, n+1)\n\t\t\tv[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i <= 100; i++) {\n\t\t\tans = min(ans, v[s][i] + v[i][g1] + v[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long; using pii = pair<int, int>;\nconst int MOD = (int)1e9 + 7, INF = (1 << 27); const ll INFLL = (1LL << 55);\n#define FOR(i,a,b) for(int (i)=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\ntemplate<typename T, typename U> static void chmin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void chmax(T &x, U y) { if (x < y) x = y; }\n\nint d[120][120];\n\nint main() {\n    int n, m, s, t1, t2;\n    while (cin >> n >> m >> s >> t1 >> t2, n) {\n        s--; t1--; t2--;\n        fill_n(*d, 120 * 120, INF);\n        rep(i, n) d[i][i] = 0;\n        rep(i, m) {\n            int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n            a--; b--;\n            d[a][b] = c;\n        }\n        rep(k, n) rep(i, n) rep(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n        int ans = INF;\n        rep(i, n) {\n            chmin(ans, d[s][i] + d[i][t1] + d[i][t2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define SZ(a) ((int)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(),(v).rend())\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define BIT(n) (1ULL << (n))\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;/*}}}*/\n\n#define MAX_N 100\n#define INF (INT_MAX / 10)\nint n, m, s, g1, g2;\nint dist[MAX_N][MAX_N];\nint main(int argc, char const* argv[])\n{\n\twhile(cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\t--s; --g1; --g2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdist[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c; cin >> a >> b >> c;\n\t\t\tdist[a-1][b-1] = dist[b-1][a-1] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int div = 0; div < n; div++) { // where to divide\n\t\t\tint cost = dist[s][div] + dist[div][g1] + dist[div][g2];\n\t\t\tans = min(ans, cost);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst int INF = 100000000;\n\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    s--;g1--;g2--;\n    int d[100][100];\n    REP(i,n)REP(j,n)d[i][j] = (i!=j)?INF:0;\n    while(m--){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      d[a][b] = c;\n    }\n    REP(k,n)REP(i,n)REP(j,n)d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int ans = INF;\n    REP(i,n){\n      ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nconst int inf=1e8;\nusing namespace std;\nint main(){\n  int a,b,c,d,e;\n  while(cin>>a>>b>>c>>d>>e,a+b+c+d+e){\n    c--;d--;e--;\n    vector<vector<int> >cost(a,vector<int>(a));\n    rep(i,a)rep(j,a){\n      if(i==j)cost[i][j]=0;\n      else cost[i][j]=inf;\n    }\n    rep(i,b){\n      int f,g,h;\n      cin>>f>>g>>h;\n      f--;g--;\n      cost[f][g]=h;\n    }\n    rep(k,a)rep(i,a)rep(j,a)\n      cost[i][j]=min(cost[i][k]+cost[k][j],cost[i][j]);\n    int mi=inf;\n    rep(i,a)mi=min(mi,cost[c][i]+cost[i][d]+cost[i][e]);\n    cout<<mi<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 100;\nconst int INF = 1 << 29;\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m, s, g1, g2;\n\t\tint cost[MAX][MAX];\n\t\tint ans = INF;\n\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, MAX) {\n\t\t\trep(j, MAX) {\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\trep(i, m) {\n\t\t\tint b1, b2, c;\n\n\t\t\tcin >> b1 >> b2 >> c;\n\n\t\t\tcost[b1 - 1][b2 - 1] = c;\n\t\t\tcost[b2 - 1][b1 - 1] = c;\n\t\t}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tans = min(ans, cost[s - 1][i] + cost[i][g1 - 1] + cost[i][g2 - 1]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g1, g2;\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n+1);\n        for(int i=0; i<m; ++i){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges[b1].push_back(Edge(b2, c));\n            edges[b2].push_back(Edge(b1, c));\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        int ret = INF;\n        for(int i=1; i<=n; ++i)\n            ret = min(ret, dist[i][s] + dist[i][g1] + dist[i][g2]);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include <functional>\n#define INF 1000000\nusing namespace std;\ntypedef long long ll;\nstruct edge { int to, cost; };\ntypedef pair<ll, int> P;\n\n\nint V;\nvector<edge> G[1010];\nll d[105];\n\nll dijkstra(int s,int g) {\n\tpriority_queue<P, vector<P>,greater<P>> que;\n\tfill(d, d + V, 1000000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!(que.empty())) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main() {\n\twhile (true) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tll ans;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0)break;\n\t\ts--; g1--; g2--;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e;\n\t\t\te.to = b - 1; e.cost = c;\n\t\t\tG[a - 1].push_back(e);\n\t\t}\n\t\tans = min(dijkstra(s, g1)+dijkstra(g1,g2),dijkstra(s,g2)+dijkstra(g2,g1));\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint d[100][100];\n\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  for(;;){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(!n && !m && !s && !g1 && !g2)break;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tif(i==j)d[i][j] = 0;\n\telse d[i][j] = (1<<25);\n\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      d[b1-1][b2-1] = c;\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n    /*\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++)cout << d[i][j] << \" \";\n      cout << endl;\n    }\n    */\n    int ans = (1<<25);\n    for(int i=0;i<n;i++)ans = min(ans,d[s-1][i]+d[i][g1-1]+d[i][g2-1]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define inf 1e8\nusing namespace std;\n\nint main(void){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\tint a,b,c;\n\t\tint edge[101][101];\n\t\tREP(i,1,n+1) REP(j,1,n+1) {\n\t\t\tif(i==j) edge[i][j]=0;\n\t\t\telse edge[i][j]=inf;\n\t\t}\n\t\tREP(i,0,m){\n\t\t\tcin>>a>>b>>c;\n\t\t\tedge[a][b]=c;\n\t\t}\n\t\tREP(k,1,n+1) REP(i,1,n+1) REP(j,1,n+1)\n    \t\t\t\tedge[i][j]=min(edge[i][k]+edge[k][j],edge[i][j]);\n\t\tint ans=3*1e8;\n    \tREP(i,1,n+1){\n    \t\tans=min(ans,edge[s][i]+edge[i][g1]+edge[i][g2]);\n    \t}\n    \tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x0f0f0f0f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_station;\n  int total_road;\n  int water_source_idx;\n  int main_station1_idx;\n  int main_station2_idx;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_station,\n\t       &total_road,\n\t       &water_source_idx,\n\t       &main_station1_idx,\n\t       &main_station2_idx)){\n    if(total_station == 0) break;\n\n    int nodes[101][101];\n    memset(nodes,0x0f,sizeof(nodes));\n    for(int i=1;i<=total_station;i++){\n      nodes[i][i] = 0;\n    }\n\n    for(int i=0;i<total_road;i++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      nodes[from][to] = cost;\n    }\n\n    for(int k=1;k<=total_station;k++){\n      for(int i=1;i<=total_station;i++){\n\tfor(int j=1;j<=total_station;j++){\n\t  nodes[i][j] = min(nodes[i][k]+nodes[k][j],nodes[i][j]);\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=1;i<=total_station;i++){\n      res = min(nodes[water_source_idx][i]\n\t\t+ nodes[i][main_station1_idx]\n\t\t+ nodes[i][main_station2_idx],res);\n    }\n\n    printf(\"%d\\n\",res);\n  }\n\t       \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nbool used[128];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tfill_n(res, 3, INF);\n\t\n\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(dp[v], dp[v] + 3, res);\n\t\treturn;\n\t}\n\telse if (v == g1)\n\t{\n\t\tres[0] = 0;\n\t\treturn;\n\t}\n\telse if (v == g2)\n\t{\n\t\tres[1] = 0;\n\t\treturn;\n\t}\n\n\tused[v] = true;\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tif (used[edge[v][i].to])\n\t\t\tcontinue;\n\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tused[v] = false;\n\tmin_swap(res[2], res[0] + res[1]);\n\n\tcopy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int lim = 110;\nconst int inf = 1e8;\n\nint n, m, s, g1, g2;\n\nstruct edge{\n    int from;\n    int to;\n    int cost;\n};\n\nint d[lim][lim];\n\nvoid WarshallFloyd(){\n    for(int k=0; k<n; k++){\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) return 0;\n        for(int i=0; i<lim; i++){\n            for(int j=0; j<lim; j++) d[i][j] = inf;\n        }\n        for(int i=0; i<m; i++){\n            int from, to, cost;\n            cin >> from >> to >> cost;\n            from--; to--;\n            d[from][to] = cost;\n        }\n\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++) if(i == j) d[i][j] = 0;\n        }\n\n        WarshallFloyd();\n        int ans = inf;\n        for(int i=0; i<n; i++){\n            ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<10;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n;){\n    vector<vector<int>> d(n, vector<int> (n, INF));\n\n    for(int i=0;i<m;++i){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXN 110\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n, m, s, g1, g2;\n\nint main(void) {\n    while (1) {\n        cin >> n >> m >> s >> g1 >> g2;\n        if (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n        int dist[MAXN][MAXN];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                dist[i][j] = INF;\n            }\n            dist[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            dist[a][b] = c;\n        }\n        for (int k = 1; k <= n; k++) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n        int ans = INF;\n        for (int i = 1; i <= n; i++) {\n            ans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint t[1000][1000];\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 127, sizeof(z));\n\t\tmemset(t, 0, sizeof(t));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (x[i][j] >= 1 && t[i][j] == 0) {\n\t\t\t\t\tx[j][i] = x[i][j];\n\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t\tt[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nconst int kN = 100;\nint atl[kN][kN];\n\nvoid warshallFloyd(int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                atl[i][j] = min(atl[i][j], atl[i][k] + atl[k][j]);\n            }\n        }\n    }\n}\n\nint requestCost(int n, int s, int g1, int g2){\n    int retval = INF;\n    rep(i,n){\n        int cost = atl[s][i] + atl[i][g1] + atl[i][g2];\n        retval = min(retval, cost);\n    }\n    return retval;\n}\n\nint main(){\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n||m||s||g1||g2){\n        rep(i,kN) rep(j,kN) atl[i][j] = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            atl[a][b] = c;\n        }\n        warshallFloyd(n);\n        cout << requestCost(n, s, g1, g2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(2);\n}\n#define int ll\n\nvoid solve() {\n\twhile (true) {\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0) return;\n\t\tint dist[200][200] = {};\n\t\tREP(i, 200) {\n\t\t\tREP(q, 200) {\n\t\t\t\tif (i != q) {\n\t\t\t\t\tdist[i][q] = 1e9;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(t, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tdist[a][b] = c;\n\t\t}\n\t\tn++;\n\t\tREP(t, 3) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(q, n) {\n\t\t\t\t\tREP(j, n) {\n\t\t\t\t\t\tdist[i][q] = min(dist[i][q], dist[i][j] + dist[j][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e18;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n        \n        \n    const int mx=1e9+7;\n    int n,m,s,go,gt;\n    cin>>n>>m>>s>>go>>gt;\n    if(n==0 && m==0){break;}\n    s--; go--; gt--;\n    int a[1000][1000];\n    fill(&a[0][0],&a[999][1000],mx);\n    for(int i=0;i<n;i++){\n        a[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        int b,c,d;\n        cin>>b>>c>>d;\n        a[b-1][c-1]=d;\n        a[c-1][b-1]=d;\n    }\n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int k=0;k<n;k++){\n                a[t][k]=min(a[t][i]+a[i][k],a[t][k]);\n            }\n        }\n    }\n    int ans=mx;\n    for(int i=0;i<n;i++){\n        ans=min(a[s][i]+a[i][go]+a[i][gt],ans);\n    }\n        \n        /*\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                cout<<(a[i][t]==mx? -1:a[i][t])<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n        */\n        \n        \n    assert(ans!=mx);\n    cout<<ans<<endl;\n    \n    \n    \n    \n    \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\n/*\n  n m s g1 g2\n  a b c\n  ...\n  am bm cm\n  0 0 0 0 0\n  */\n\nint n,m,s,g1,g2;\nint edge[128][128];\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n|m|s|g1|g2){\n    s--; g1--; g2--;\n    //init\n    //rep(i,128)rep(j,128)edge[i][j]=INT_MAX;\n    memset(edge, 0x2a, sizeof(edge));\n    //printf(\"%d\\n\",edge[1][2]);\n    //printf(\"%d\\n\",INT_MAX/3);\n    //return 0;\n    rep(i,100)edge[i][i]=0;\n\n    // input\n    rep(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      edge[a-1][b-1]=c;\n    }\n\n    // í[µáéÓë¢Ç\n    rep(k,n){\n      rep(i,n){\n        rep(j,n){\n          edge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n        }\n      }\n    }\n\n    int ans = 707406378;\n    rep(k,n){\n      if( k==g1 ){\n        ans = min(ans, edge[s][g1]+edge[g1][g2]);\n      }else if( k==g2 ){\n        ans = min(ans, edge[s][g2]+edge[g2][g1]);\n      }else{\n        ans = min(ans, edge[s][k]+edge[k][g1]+edge[k][g2]);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nvoid AAA(int,int,int);\nint pipe[65001];\nint joi[65002],kanemax=-1,nagasa=0;\nint sosu=0,n;\n#define REP(i,a) for(int i=0;i<a;i++)\n\nint main()\n{\n\tcin>>n;\n\twhile(n!=0){\n\t\tREP(i,n){\n\t\tcin>>pipe[i];\n\t\tnagasa+=pipe[i];\n\t\t}\n\t\tREP(i,n-1){\n\t\tcin>>joi[i];\n\t\t}\n\t\tsosu=n;\n\t\tAAA(sosu,nagasa,0);\n\n\t\tcout<<kanemax<<endl;\n\t\tnagasa=0;\n\t\tcin>>n;\n\t}\n\n\treturn 0;\n}\nvoid AAA(int a,int b,int c)\n{\n\tif(c==n){\n\t\t\tif(kanemax<b*a) kanemax=b*a;\n\t}\n\telse{\n\n\tAAA(a-1,b+joi[c],c+1); \n\tAAA(a,b,c+1);\n\t\n\t\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e8\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, s, g1, g2;\nint E[101][101];\nint dp[101][101];\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    s--; g1--; g2--;\n    rep(i, n) rep(j, n) E[i][j] = INF;\n    rep(i, m){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      E[b1][b2] = c;\n      E[b2][b1] = c;\n    }\n    //rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) dp[i][j] = E[i][j];\n    rep(i, n) dp[i][i] = 0;\n    bool changed = true;\n    while(changed){\n      changed = false;\n      rep(k, n){      \n\trep(i, n){\n\t  rep(j, n){\n\t    if(dp[i][j] > dp[i][k] + dp[k][j]){\n\t      dp[i][j] = dp[i][k] + dp[k][j];\n\t      changed = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int ans = INF;\n    rep(br, n){\n      ans = min(ans, dp[s][br] + dp[br][g1] + dp[br][g2]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int INF = INT_MAX / 3;\nvector<vector<int>> d;\n\nint main() {\n\twhile(1) {\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif(n == 0) break;\n\t\td.assign(n, vector<int>(n, INF));\t\n\t\n\t\tint from, to, cost;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tcin >> from >> to >> cost;\n\t\t\t--from; --to;\n\t\t\td[from][to] = cost;\n\t\t}\n\t\n\t\tfor(int k = 0; k < n; ++k)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tfor(int j = 0; j < n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tint ans = INF;\n\t\tfor(int c = 0; c < n; ++c) {\n\t\t\tif(d[s][c] == INF || d[c][g1] == INF || d[c][g2] == INF) continue;\t\n\t\t\tint tmp = d[s][c] + d[c][g1] + d[c][g2];\t\n\t\t\tans = min(tmp, ans);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define M 1000000\n\nusing namespace std;\n\nint Dijkstra(const vector< vector<int> >& data, int& s, int& g){\n  vector<bool> is_reached(data.size(), false);\n  vector<int> ans(data.size(), M);\n  ans[s] = 0;\n  int i, j;\n  i = s;\n  while(i != g){\n    is_reached[i] = true;\n    for(j=0; j<data[i].size(); ++j){\n      ans[j] = min(ans[j], ans[i] + data[i][j]);\n    }\n    for(i=-1, j=0; j<is_reached.size(); ++j){\n      if(!is_reached[j] && (i < 0 || ans[i] > ans[j])) i = j;\n    }\n  }\n  return ans[g];\n}\n\nint GetMinCost(const vector< vector<int> >& data, int& s, int g1, int g2){\n  int cost = Dijkstra(data, s, g1) + Dijkstra(data, s, g2);\n  for(int i=0; i<data.size(); ++i){\n    cost = min(cost, Dijkstra(data, s, i)\n\t       + Dijkstra(data, i, g1) + Dijkstra(data, i, g2));\n  }\n  return cost;\n}\n\nint main(){\n  int n, m, s, g1, g2;\n  int a, b, c;\n\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\n    --s;\n    --g1;\n    --g2;\n    vector< vector<int> > data(n, vector<int>(n, M));\n\n    for(int i=0; i<m; ++i){\n      cin >> a >> b >> c;\n      data[a-1][b-1] = c;\n    }\n    cout << GetMinCost(data, s, g1, g2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nconst int INF=1e18;\n\nvoid solve(int N,int M)\n{\n    int s,g1,g2; cin>>s>>g1>>g2;\n    s--; g1--; g2--;\n    vector<vector<int>> dist(N,vector<int>(N,INF));\n    for(int i=0;i<N;i++) dist[i][i]=0;\n    for(int i=0;i<M;i++){\n        int a,b,c; cin>>a>>b>>c;\n        a--; b--;\n        dist[a][b]=c;\n    }\n\n    for(int k=0;k<N;k++) for(int i=0;i<N;i++) for(int j=0;j<N;j++){\n        chmin(dist[i][j],dist[i][k]+dist[k][j]);\n    }\n    \n    int ans=INF;\n    for(int t=0;t<N;t++){\n        chmin(ans,dist[s][t]+dist[t][g1]+dist[t][g2]);\n    }\n    cout<<ans<<endl;\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        int N,M; cin>>N>>M;\n        if(N==0) break;\n        solve(N,M);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1e8;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\n\ntypedef unsigned long long ll;\nint main(){\n\tint N,M,s,g1,g2;\n\twhile(scanf(\"%d%d%d%d%d\",&N,&M,&s,&g1,&g2),N){\n\t\t--s;--g1;--g2;\n\t\tint dp[128][128];\n\t\trep(i,128){\n\t\t\trep(j,128){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\t--a;--b;\n\t\t\tdp[a][b] = c;\n\t\t}\n\n\t\trep(k,N){\n\t\t\trep(i,N){\n\t\t\t\trep(j,N){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\trep(i,N){\n\t\t\tans = min(ans,dp[s][i]+dp[i][g1]+dp[i][g2]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\nint cost[101][101];\nint mincost[101][101];\nint n,m,s,g1,g2;\nvoid warshall_floyd(){\n  for(int i = 0 ; i < n ; i++ )\n    for(int j = 0 ; j < n ; j++ )mincost[i][j] = INF;\n\n  for(int i = 0 ; i < n ; i++ ){\n    for(int j = 0 ; j < n ; j++ ){\n      for(int k = 0 ; k < n ; k++ ){\n\tmincost[j][k] = min(mincost[j][k],cost[j][i] + cost[i][k]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while( cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2 ){\n    n++;\n    for(int i = 0 ; i < n ; i++ )\n      for(int j = 0 ; j < n ; j++ ){\n\tif(i == j)cost[i][j] = 0;\n\telse cost[i][j] = INF;\n      }\n\n    for(int i = 0 ; i < m ; i++ ){\n      int a,b,c;\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n    }\n    warshall_floyd();\n\n    int mn = INF;\n    for(int i = 0 ; i < n ; i++ )\n      mn = min(mincost[s][i] + mincost[i][g1] + mincost[i][g2],mn);\n    cout << mn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 9999999\n#define MAX 101\n\nint main(){\n    int n,m,s,g1,g2,d[MAX+1][MAX+1],a,b,c;\n    while(cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2){\n        fill(d[0],d[MAX],INF);\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            d[a][b] = c;\n        }\n        \n        for(int k = 1 ; k <= n ; k++)\n            for(int i = 1 ; i <= n ; i++)\n                for(int j = 1 ; j <= n ; j++)\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        \n        int res = INF;\n        for(int i = 1 ; i <= n ; i++){\n            res = min(res,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define NUM_MAX 105\n#define INF INT_MAX/2\n\ntypedef long long int ll;\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0) return 0;\n\n\t\tll d[NUM_MAX][NUM_MAX];\n\t\trep(i, 0, n + 1) rep(j, 0, n + 1)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\td[i][j] = 0;\n\t\t\telse\n\t\t\t\td[i][j] = INF;\n\t\t}\n\n\t\trep(i, 0, m)\n\t\t{\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = c;\n\t\t}\n\n\t\trep(k, 0, n + 1) rep(i, 0, n + 1) rep(j, 0, n + 1)\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tll ans = INF;\n\t\trep(i, 1, n + 1) ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint solve(vector<vector<int> > dist,int s,int g1,int g2){\n    int n = dist.size();\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    int ret = INF;\n    for(int k=0;k<n;k++){\n        ret = min(ret,dist[s][k]+dist[k][g1]+dist[k][g2]);\n    }\n    return ret;\n}\nint main(){\n    while(true){\n        int n,m,s,g1,g2;\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        s--;g1--;g2--;\n        vector<vector<int> > dist(n,vector<int>(n,INF));\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            dist[a][b] = c;\n        }\n        for(int i=0;i<n;i++){\n            dist[i][i] = 0;\n        }\n        cout << solve(dist,s,g1,g2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<29) - 1;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, S, G1, G2;\n    while(cin >> N >> M >> S >> G1 >> G2, N|M|S|G1|G2){\n        S--; G1--; G2--;\n        vector<vector<int>> G(N, vector<int>(N, INF));\n        for(int i=0; i<N; i++)\n            G[i][i] = 0;\n        while(M--){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            b1--; b2--;\n            G[b1][b2] = G[b2][b1] = c;\n        }\n        \n        for(int k=0; k<N; k++)\n            for(int i=0; i<N; i++)\n                for(int j=0; j<N; j++)\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        \n        int ans = INF;\n        for(int i=0; i<N; i++){\n            ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n        }\n        cout << ans << endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\nstatic const int INF = 1e9;\n\nvoid solve()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2)\n\t{\n\t\t--s; --g1; --g2;\n\t\tvector< vector<int> > d(n, vector<int>(n));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\td[i][i] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\td[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\t--from; --to;\n\t\t\td[from][to] = cost;\n\t\t}\n\t\tfor (int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint dis[123][123];\nvpint road[123];\nint n,m,s,g1,g2;\n\nint main() {\n\tIL{\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\t--s,--g1,--g2;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t--a,--b;\n\t\t\troad[a].PB(MP(b,c));\n\t\t\troad[b].PB(MP(a,c));\n\t\t}\n\t\trep(i,n)rep(j,n)dis[i][j]=INF;\n\t\trep(i,n){\n\t\t\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\t\t\tque.push(MP(0,i));\n\t\t\twhile(!que.empty()){\n\t\t\t\tpint now=que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif(dis[i][now.second]<=now.first)continue;\n\t\t\t\tdis[i][now.second]=now.first;\n\t\t\t\trep(j,sz(road[now.second]))que.push(MP(now.first+road[now.second][j].second,road[now.second][j].first));\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\trep(i,n){\n\t\t\tchmin(res,dis[s][i]+dis[i][g1]+dis[i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 100000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = table[j][k] < table[j][i] + table[i][k] ?\n\t\t\t\t\ttable[j][k] : table[j][i] + table[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\tif(Min == INF) exit(1);\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    while(1){\n\n    int V, E, S, G1, G2; cin >> V >> E >> S >> G1 >> G2;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    if(!V) break;\n    S--;\n    G1--;\n    G2--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b, c; cin >> a >> b >> c;           // a ,b 間に コスト c の辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(c, b));\n        adjlist[b].push_back(make_pair(c, a));      \n    }\n\n    int ans = INF;\n    vector<int> result(V);\n    vector<int> res(V);\n    result = dijk(S, V, adjlist);\n    for(int i = 0; i < V; i++){\n        res = dijk(i, V, adjlist);\n        ans = min(ans, result[i] + res[G1] + res[G2]);\n    }\n\n    cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, m, s, g, gg, from, to, cost;\n  while(cin >> n >> m >> s >> g >> gg, n){\n    s--;g--;gg--;\n    vector<vector<int> > graph(n, vector<int>(n, 1e9));\n    for(int i = 0; i < m; i++){\n      cin >> from >> to >> cost;\n      from--;to--;\n      graph[from][to] = cost;\n    }\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  graph[i][j] = min(graph[i][k] + graph[k][j], graph[i][j]);\n\t}\n      }\n    }\n    int ans = 1e9;\n    for(int i = 0; i < n; i++){\n      ans = min(ans, graph[s][i]+ graph[i][g] + graph[i][gg]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nconst int INF = 100000000;\nint adj[100][100];\nint radj[100][100];\n\nint main() {\n  int n,m,s,g1,g2,b1,b2,c;\n\n  while(cin>>n>>m>>s>>g1>>g2, n|m|s|g1|g2) {\n    memset(adj, INF, sizeof(adj));\n    memset(radj, INF, sizeof(radj));\n    s--,g1--,g2--;\n\n    for(int i=0; i<100; ++i)\n      for(int j=0; j<100; ++j) {\n\tadj[i][j] = INF;\n\tradj[i][j] = INF;\n      }\n\n    for(int i=0; i<m; ++i) {\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      adj[b1][b2] = c;\n      radj[b2][b1] = c;\n    }\n\n\n    for(int k=0; k<n; ++k) {\n      for(int i=0; i<n; ++i) {\n\tfor(int j=0; j<n; ++j) {\n\t  adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t  radj[i][j] = min(radj[i][j], radj[i][k]+radj[k][j]);\n\t}\n      }\n    }\n\n    int minc = INF;\n    for(int i=0; i<n; ++i) {\n      minc = min(minc, (adj[s][i]+adj[i][g1]+adj[i][g2]));\n    }\n\n    cout<<minc<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define INF (1<<28)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint n,m,s,g,h;\n\nint v[100][100];\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \",\";\n\tout << \"}\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m >> s >> g >> h, n){\n\t\trep(i,100)rep(j,100) v[i][j] = INF;\n\t\tint ans = INF;\n\t\ts--; g--; h--;\n\t\trep(i,m){\n\t\t\tint x, y, c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tv[x-1][y-1] = c;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n) v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\n\t\trep(i,n){\n\t\t\tans = min (ans, v[s][i] + v[i][g] + v[i][h]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n\nusing namespace std;\n\nconst int INF=100000000;\n\nlong int field[101][101];\nlong int costs;\nint s,g1,g2;\nint n,m;\nint f,t,c;\n\nvoid root(){\n\tint a,b;\n\tfield[f][t]=c;\n\tfor(b=1;b<=n;b++){\n\t\tfor(a=1;a<=n;a++){\n\t\t\tfield[a][b]=min(field[a][b],field[a][f]+field[f][t]+field[t][b]);\n\t\t}\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tcosts=min(costs,field[s][a]+field[a][g1]+field[a][g2]);\n\t}\n\t//costs=min(costs,min(field[s][f]+field[f][t]+field[t][g1]+field[t][g2],min(field[s][g1]+field[s][g2],field[s][f]+field[f][g1]+field[f][g2])));\n}\n\nint main(void){\n\tint a,b;\n\twhile(1){\n\t\tfor(b=0;b<=100;b++){\n\t\t\tfor(a=0;a<=100;a++){\n\t\t\t\tfield[a][b]=INF;\n\t\t\t\tif(a==b)field[a][b]=0;\n\t\t\t}\n\t\t}\n\t\tcosts=INF;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\t\tfor(a=0;a<m;a++){\n\t\t\tcin >> f >> t >> c;\n\t\t\troot();\n\t\t}\n\t\tcout << costs << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dst, cost; \n    edge(int s, int t, int c): src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost > rhs.cost;}\n};\nconst int INF = 1e8;\n\nvoid dijkstra(const vector<vector<edge> > &G, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    typedef pair<int, int> P;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0, s));\n\n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(auto &e : G[v]) {\n            if(d[e.dst] > d[v] + e.cost) {\n                d[e.dst] = d[v] + e.cost;\n                que.push(P(d[e.dst], e.dst));\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<vector<edge> > G(n);\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            G[b1-1].push_back(edge(b1-1, b2-1, c));\n        }\n        REP(i, n) {\n            dijkstra(G, d[i], i);\n        }\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\npriority_queue<pa2,vector<pa2>,greater<pa2>> pq;  \nint d1[110],d2[110],d3[110];\nvector<pa> G[110],G2[110];\n   signed main(){\n   \tint n,m,s,g1,g2;\n   \twhile(1){\n   \tcin>>n>>m>>s>>g1>>g2;\n   \t\tif(n==0) return 0;\n   \t\t\n   \t\tfor(int i=0;i<110;i++){\n   \t\t\tG[i].clear();\n   \t\t\tG2[i].clear();\n   \t\t\td1[i]=-1;\n   \t\t\td2[i]=-1;\n   \t\t\td3[i]=-1;\n   \t\t\n   \t\t}\n   \t\tfor(int i=0;i<m;i++){\n   \t\tint y,yy,yyy;\n   \t\t\tcin>>y>>yy>>yyy;\n   \t\t\tG[y].pb(mp(yy,yyy));\n   \t\t\tG2[yy].pb(mp(y,yyy));\n   \t\t\n   \t\t}\n   \t\twhile(pq.size())pq.pop();\n   \t\t\tpq.push((pa2){0,s});\n   \t\twhile(pq.size()){\n   \t\t\tpa2 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(d1[z.y]>=0) continue;\n   \t\t\td1[z.y]=z.x;\n   \t\t\t\tfor(auto v:G[z.y])pq.push((pa2){z.x+v.second,v.first});\n   \t\t\t\n   \t\t}\n   \t\t\n   \t\t\n   \t\twhile(pq.size())pq.pop();\n   \t\t\tpq.push((pa2){0,g1});\n   \t\twhile(pq.size()){\n   \t\t\tpa2 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(d2[z.y]>=0) continue;\n   \t\t\td2[z.y]=z.x;\n   \t\t\t\tfor(auto v:G2[z.y])pq.push((pa2){z.x+v.second,v.first});\n   \t\t\t\n   \t\t}\n   \t\twhile(pq.size())pq.pop();\n   \t\t\tpq.push((pa2){0,g2});\n   \t\twhile(pq.size()){\n   \t\t\tpa2 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(d3[z.y]>=0) continue;\n   \t\t\td3[z.y]=z.x;\n   \t\t\t\tfor(auto v:G2[z.y])pq.push((pa2){z.x+v.second,v.first});\n   \t\t\t\n   \t\t}\n   \t\tint ans=inf;\n   \t\tfor(int i=1;i<=n;i++){\n   \t\t\tif(d1[i]==-1) continue;\n   \t\t\tif(d2[i]==-1) continue;\n   \t\t\tif(d3[i]==-1) continue;\n   \t\t\tans=min(d1[i]+d2[i]+d3[i],ans);\n   \t\t}\n   \t\tcout<<ans<<endl;\n   \t\n   \t\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 114514810\nusing namespace std;\n\nint dp[110][110];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x0f0f0f0f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_station;\n  int total_road;\n  int water_source_idx;\n  int main_station1_idx;\n  int main_station2_idx;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_station,\n\t       &total_road,\n\t       &water_source_idx,\n\t       &main_station1_idx,\n\t       &main_station2_idx)){\n    if(total_station == 0) break;\n\n    int nodes[101][101];\n    memset(nodes,0x0f,sizeof(nodes));\n\n    for(int i=0;i<total_road;i++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      nodes[from][to] = cost;\n      nodes[to][from] = cost;\n    }\n\n    for(int k=1;k<=total_station;k++){\n      for(int i=1;i<=total_station;i++){\n\tfor(int j=1;j<=total_station;j++){\n\t  nodes[i][j] = min(nodes[i][k]+nodes[k][j],nodes[i][j]);\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=1;i<=total_station;i++){\n      res = min(nodes[water_source_idx][i]\n\t\t+ nodes[i][main_station1_idx]\n\t\t+ nodes[i][main_station2_idx],res);\n    }\n\n    printf(\"%d\\n\",res);\n  }\n\t       \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 100000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\nint d[101][101];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2){\n\t\tif(n==0&&m==0&&s==0&&g1==0&&g2==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2]=c;\n\t\t\t//d[b2][b1]=c;\n\t\t}\n\t\tfor(int k=1; k<=n; ++k){\n\t\t\tfor(int i=1; i<=n; ++i){\n\t\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define rep(i,N) for(ll i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nint n, m, s, g1, g2;\nll dp[200][200];\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2&&n + m + s + g1 + g2) {\n\t\ts--; g1--; g2--;\n\t\trep(i, n)rep(j, n) {\n\t\t\tif (i != j)dp[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tdp[b1][b2] = c;\n\t\t}\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\trep(i, n) {\n\t\t\tif (i == s)ans = min(ans, dp[i][g1] + dp[i][g2]);\n\t\t\telse ans = min(ans, dp[s][i] + dp[i][g1] + dp[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define INF 1000000000000\ntypedef long long LL;\nint n,m,s,g1,g2;\nLL d[101][101];\n\nint main(){\n    while(cin>>n>>m>>s>>g1>>g2,n+m+s+g1+g2){\n        s--;g1--;g2--;\n        REP(i,101){\n            REP(j,101){\n                d[i][j]=INF;\n            }\n            d[i][i]=0;\n        }\n        REP(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            d[a][b]=c;\n            //d[b][a]=c;\n        }\n        REP(i,n){\n            REP(j,n){\n                REP(k,n){\n                    d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        LL ans=1e12;\n        REP(i,n){\n            ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    int d[1000][1000]={};\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(i!=j)d[i][j]=1e8;\n    for(int i=0,a,b,c;i<m;i++)\n      cin>>a>>b>>c,d[a][b]=c;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<n;k++)\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n    int ans=1e9;\n    for(int i=0;i<n;i++)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\n#include<fstream>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint n,m,s,g1,g2;\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint edge[101][101];\nint edge_rev[101][101];\n\nint main()\n{\tstd::ofstream ofs( \"ans.txt\" );\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tint ans=1000000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=10000000;\n\t\t\tfor(int j=0;j<101;j++){\n\t\t\t\tedge[i][j]=10000000;\n\t\t\t\tedge_rev[i][j]=100000000;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tedge[in][out]=c;\n\t\t\tedge_rev[out][in]=c;\n\t\t}\n\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<101;i++){\n\t\t\t\tQ.push(state(i,info.cost+edge[info.now][i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<101;i++){\n\t\t\t\tQ.push(state(i,info.cost+edge_rev[info.now][i]));\n\t\t\t}\n\t\t}\n\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<101;i++){\n\t\t\t\tQ.push(state(i,info.cost+edge_rev[info.now][i]));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<101;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tofs<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 99999;\n\nint main()\n{\n  int n, m, s, t, u, a[101][101], p, q, v;\n  bool vis[101][101];\n  \n  while(1){\n    cin >> n >> m >> s >> t >> u;\n    if(n&m&s&t&u){\n      break;\n    }\n    fill(&vis[1][1], &vis[n][n], false);\n    fill(&a[1][1], &a[n][n], inf);\n    for(int i = 1; i <= n; i++){\n      a[i][i] = 0;\n    }\n    \n    for(int i = 0; i < m; i++){\n      cin >> p >> q >> v;\n      a[p][q] = a[q][p] = v;\n    }\n    \n    for(int k = 1; k <= n; k++){\n      for(int i = 1; i <= n; i++){\n\tfor(int j = 1; j <= n; j++){\n\t  if(a[i][j] > a[i][k]+a[k][j]){\n\t    a[i][j] = a[i][k]+a[k][j];\n\t    vis[i][k] = vis[k][j] = true;\n\t  }\n\t}\n      }\n    }\n    \n    for(int i = 1; i <= n; i++){\n      for(int j = 1; j <= n; j++){\n\tcout << a[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n    \n    p = a[u][t];\n    q = inf;\n    for(int i = 1; i <= n; i++){\n      if(vis[u][i] && vis[i][t] && i != u && i != t){\n\tq = min(q, a[s][i]);\n\tcout << a[s][i] << endl;\n      }\n    }\n    \n    cout << (p+q) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <array>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint main() {\n  while(1){\n    int n,m,p[3];\n    cin>>n>>m>>p[0]>>p[1]>>p[2];\n    if(!n)break;\n    REP(i,3)--p[i];\n    int d[100][100];\n    REP(i,n)REP(j,n)d[i][j]=INF;\n    REP(i,m){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      --b1;--b2;\n      d[b1][b2]=c;\n    }\n    REP(k,n)REP(i,n)REP(j,n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    int dmin=INF;\n    REP(i,n){\n      int sum=0;\n      sum+=d[p[0]][i];\n      sum+=d[i][p[1]];\n      sum+=d[i][p[2]];\n      dmin=min(dmin,sum);\n    }\n    cout<<dmin<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 1<<25;\n\nint main(){\n    int n, m, s, g1, g2, a, b, c;\n    while(cin >> n >> m >> s >> g1 >> g2, n+m+s+g1+g2){\n        vector<vector<int>> v(n, vector<int>(n, INF));\n        for(int i = 0; i < n; i++)  v[i][i] = 0;\n        s--, g1--, g2--;\n        while(m-- > 0){\n            cin >> a >> b >> c;\n            v[--a][--b] = c;\n        }\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    if(v[i][k]==INF || v[k][j]==INF)    continue;\n                    v[i][j] = min(v[i][j], v[i][k]+v[k][j]);\n                }\n            }\n        }\n        int ans = 1<<30;\n        for(int i = 0; i < n; i++){\n            ans = min(ans, v[s][i]+v[i][g1]+v[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint G[100][100];\nint n;\n\nint solve(int s,int g1,int g2){\n  for(int k=0;k<n;++k)\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n\n  int ret = G[s][g1]+G[s][g2];\n  for(int t=0;t<n;++t)\n    ret = min(ret,G[s][t]+G[t][g1]+G[t][g2]);\n  return ret;\n}\n\nint main(){\n  int m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = 1<<29;\n    s--;g1--;g2--;\n    while(m--){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--;b--;\n      G[a][b] = c;\n    }\n    cout << solve(s,g1,g2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//--------------------------------------------------\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<ctime>\n\nusing namespace std;\n\n//conversion\n//--------------------------------------------------\ninline int toInt(const string &s){\n    int v;istringstream sin(s);sin>>v;\n    return v;\n}\ntemplate<class T> inline string toString(T x){\n    ostringstream sout;sout<<x;\n    return sout.str();\n}\n\n//math\n//--------------------------------------------------\ntemplate<class T> inline T sqr(T x){return x*x;}\n\n//typedef\n//--------------------------------------------------\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n\n//container util\n//--------------------------------------------------\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//--------------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------------\nconst int INF=1e8;\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\n\n//clear memory\n#define CLR(a) memset((a),0,sizeof(a))\n\n//debug\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\"(L\"<<__LINE__<<\")\"<<endl\n\n//---------------------------------------------------\n\nint N,M,S,G1,G2;\nint g[100][100];\nint solve(){\n    REP(k,N)REP(i,N)REP(j,N)\n        g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\n    int mi=INF;\n    REP(i,N)mi=min(mi,g[S][i]+g[i][G1]+g[i][G2]);\n\n    return mi;\n\n}\n\n\nint main(){\n    while(cin>>N>>M>>S>>G1>>G2,N||M||S||G1||G2){\n        S--;G1--;G2--;\n        fill_n(*g,10000,INF);\n        REP(i,N)g[i][i]=0;\n        REP(i,M){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            g[a][b]=g[b][a]=c;\n        }\n        cout<<solve()<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int inf = 100 * 1000;\n\nint n, m, s, g1, g2;\nvector<vector<int> > cost;\n\nint solve(){\n    rep(k, n)rep(i, n)rep(j, n){\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n    int res = inf;\n    for(int i=1; i<n; ++i)res = min(res, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n        n++;\n        cost.assign(n, vector<int>(n, inf));\n        rep(i, m){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            cost[b1][b2] = c;\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<10);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<MAX;i++ ) {\n    for( int j=0;j<MAX;j++ ) {\n      pipe[i][j]=INF;\n      pipe[i][i]=0;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX_V = 101;\nconst int INF=100000000;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\nint main(){\n    \n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2&&!(n==0&&m==0&&s==0&&g1==0&&g2==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        s--;\n        g1--;g2--;\n        for(int i = 0; i < m; i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            b1--;\n            b2--;\n            d[b1][b2]=c;\n            d[b2][b1]=c;\n        }\n        V=n;\n        warshall_floyd();\n\n        int minCost=INF;\n        // X^[g©çÇ±ÜÅ¯¶¹ðg¤©ÅÎ ¢Ê¯\n        for(int i = 0; i < n; i++){\n            minCost=min(minCost,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout<<minCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint dist[1010][1010];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 &&n!=0){\n\t\ts--,g1--,g2--;\n\t\tint mi = 1000000000;\n\t\tfor(int i=0;i<1010;i++){\n\t\t\tfor(int j=0;j<1010;j++){\n\t\t\t\tif(i!=j)dist[i][j] = mi;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tdist[a][b] = c;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = dist[s][g1]+dist[s][g2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmi = min(mi,dist[s][i]+dist[i][g1]+dist[i][g2]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nvoid dijkstra(const vector< vector<pii> > &g, int s, vector<int> &ret){\n\tint n = g.size();\n\tret = vector<int>(n, INF);\n\tpriority_queue<pii, vector<pii>, greater<pii> > dp;\n\tdp.push(pii(0, s));\n\tret[s] = 0;\n\twhile(!dp.empty()){\n\t\tint s = dp.top().second;\n\t\tdp.pop();\n\t\tFOR(it, g[s]){\n\t\t\tint t = it->first;\n\t\t\tif(ret[t] > ret[s]+it->second){\n\t\t\t\tret[t] = ret[s]+it->second;\n\t\t\t\tdp.push(pii(ret[t], t));\n\t\t\t}\n\t\t}\n\t}\n}\nint n, m, s, g1, g2;\nmain(){\n\tint n;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n){\n\t\tvector< vector<pii> > g(n), rg(n);\n\t\tREP(i, m){\n\t\t\tint u, v, c;\n\t\t\tcin >> u >> v >> c;\n\t\t\tg[u-1].push_back(pii(v-1, c));\n\t\t\trg[v-1].push_back(pii(u-1, c));\n\t\t}\n\t\tvi r1,r2,r3;\n\t\tdijkstra(g, s-1, r1);\n\t\tdijkstra(rg, g1-1, r2);\n\t\tdijkstra(rg, g2-1, r3);\n\t\tint ans = INF;\n\t\tREP(i, n) ans = min(ans, r1[i] + r2[i] + r3[i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint n, m, s, t1, t2;\nvector<edge> G[105], revG[105];\nllint distS[105], distT1[105], distT2[105];\n\nvoid dijkstra(vector<edge> G[], llint S, llint dist[])\n{\n\tfor(int i = 1; i <= n; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tQ.push(P(0, S));\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size();i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push(P(dist[G[v][i].to] , G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m >> s >> t1 >> t2;\n\t\tif(n == 0 || m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) G[i].clear(), revG[i].clear();\n\t\t\n\t\tllint u, v, w;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> u >> v >> w;\n\t\t\tG[u].push_back(edge(v, w));\n\t\t\trevG[v].push_back(edge(u, w));\n\t\t}\n\t\t\n\t\tdijkstra(G, s, distS);\n\t\tdijkstra(revG, t1, distT1);\n\t\tdijkstra(revG, t2, distT2);\n\t\t\n\t\tllint ans = inf;\n\t\tfor(int i = 1; i <= n; i++) ans = min(ans, distS[i]+distT1[i]+distT2[i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n, m, s, g1, g2, b1, b2, c, d[101][101];\n\tconst int INF = 700000000;\n\twhile(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2), n){\n\t\tfor(int i = 0; i <= n; ++i){\n\t\t\tfor(int j = 0; j <= n; ++j){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d%d%d\", &b1, &b2, &c);\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; ++k)\n\t\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int INF = INT_MAX / 3;\nvector<vector<int>> d;\n\nint main() {\n\twhile(1) {\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n == 0) break;\n\t\t--s; --g1; --g2;\t\n\t\td.assign(n, vector<int>(n, INF));\t\n\t\n\t\tint from, to, cost;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tcin >> from >> to >> cost;\n\t\t\t--from; --to;\t\n\t\t\td[from][to] = cost;\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i) d[i][i] = 0;\t\n\n\t\tfor(int k = 0; k < n; ++k)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tfor(int j = 0; j < n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tint ans = INF;\n\t\tfor(int c = 0; c < n; ++c) {\n\t\t\tif(d[s][c] == INF || d[c][g1] == INF || d[c][g2] == INF) continue;\t\n\t\t\tint tmp = d[s][c] + d[c][g1] + d[c][g2];\t\n\t\t\tans = min(tmp, ans);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll d[105][105];\nint to[105][105];\n\nvoid warshall_floyd(int n, int m) {\n\trep(i, n) rep(j, n) d[i][j] = INF;\n\trep(i, n) d[i][i] = 0;\n\n\trep(i, n) rep(j, n) to[i][j] = j;\n\n\t//input\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\n\t\ta--; b--;\n\t\td[a][b] = c;\n\t\t// d[b][a] = c;\n\t}\n\n\trep(k,n) {\n\t\trep(i,n) {\n\t\t\trep(j,n) {\n\t\t\t\tif(d[i][k] == INF || d[k][j] == INF) continue;\n\t\t\t\tif(d[i][j] > d[i][k] + d[k][j]) {\n\t\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t\t\t\tto[i][j] = to[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> path(int s, int g) {\n\tint cur = s;\n\tvector<int> ret;\n\tfor(; cur != g; cur = to[cur][g]) {\n\t\tret.push_back(cur);\n\t}\n\n\tret.push_back(g);\n\treturn ret;\n}\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2) {\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\n\t\ts--; g1--; g2--;\n\t\twarshall_floyd(n, m);\n\n\t\tll ans = INF;\n\t\trep(i, n) {\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tans = min(ans, d[s][g1] + d[g1][g2]);\n\t\tans = min(ans, d[s][g2] + d[g2][g1]);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[200][200];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\ts--;g1--;g2--;\n\t\trep(i,n)rep(j,n){\n\t\t\tcost[i][j]=LLONG_MAX/3;\n\t\t}\n\t\trep(i,n)cost[i][i]=0;\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);b1--;b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=LLONG_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint V, E, S, G1, G2, B1, B2, C;\n\nvector<vector<int> > G;\n\nvector<vector<int> > R;\n\nvoid Shortest(int s, int mode, int rev)\n{\n\tvector<bool> u(V, false);\n\t\n\tR[mode][s] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1, c = 99999999;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i] && R[mode][i] < c)\n\t\t\t{\n\t\t\t\tc = R[mode][i]; v = i;\n\t\t\t}\n\t\t}\n\n\t\tif (c == 99999999) { break; }\n\n\t\tu[v] = true;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[v])\n\t\t\t{\n\t\t\t\tif (R[mode][i] > R[mode][v] + (rev ? G[i][v] : G[v][i]))\n\t\t\t\t{\n\t\t\t\t\tR[mode][i] = R[mode][v] + (rev ? G[i][v] : G[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> V >> E >> S >> G1 >> G2;\n\n\t\tif (V == 0) { break; }\n\n\t\tG = vector<vector<int> >(V, vector<int>(V, 99999999));\n\n\t\tfor (int i = 0; i < E; i++)\n\t\t{\n\t\t\tcin >> B1 >> B2 >> C;\n\n\t\t\tG[B1 - 1][B2 - 1] = C;\n\t\t}\n\t\t\n\t\tR = vector<vector<int> >(3, vector<int>(V, 99999999));\n\n\t\tShortest(S - 1, 0, 0);\n\t\tShortest(G1 - 1, 1, 1);\n\t\tShortest(G2 - 1, 2, 1);\n\n\t\tint ret = 299999997;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tret = min(ret, R[0][i] + R[1][i] + R[2][i]);\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tif(n == 0) break;\n\t\tll d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF * INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF * INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\nusing namespace std;\n\nint n,m,a,b,c;\nint e[100][100];\n\nint main(){\n\twhile(cin>>n>>m>>a>>b>>c,n||m||a||b||c){\n\t\ta--;b--;c--;\n\t\trep(i,100)rep(j,100)e[i][j]=INF;\n\t\trep(i,100)e[i][i]=0;\n\t\trep(i,m){\n\t\t\tint p,q,t;\n\t\t\tcin>>p>>q>>t;\n\t\t\tp--;q--;\n\t\t\te[p][q]=t;\n\t\t}\n\t\trep(i,n)rep(j,n)rep(k,n)e[j][k]=min(e[j][k],e[j][i]+e[i][k]);\n\t\tint ans=INF;\n\t\trep(i,n) ans=min(ans,e[a][i]+e[i][b]+e[i][c]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n;){\n    vector<vector<int>> d(n, vector<int> (n, INF));\n\n    for(int i=0;i<m;++i){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    for(int k=0;k<n;++k)\n      for(int i=0;i<n;++i)\n        for(int j=0;j<n;++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    int ans = INF;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int G[100][100];\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        s--; g1--; g2--;\n        fill(G[0],G[100],1e8);\n        for(int i=0;i<m;i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            b1--; b2--;\n            G[b1][b2]=G[b2][b1]=c;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(G[i][j]>G[i][k]+G[k][j])G[i][j]=G[i][k]+G[k][j];\n                }\n            }\n        }\n        int ans=1e8;\n        for(int i=0;i<n;i++){\n            ans=min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    int n, m, s, g1, g2, b1, b2, c, d[101][101];\n    const int INF = 700000000;\n    while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2), n){\n        for(int i = 0; i <= n; ++i){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for(int i = 0; i < m; ++i){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            d[b1][b2] = c;\n        }\n         \n        for(int k = 1; k <= n; ++k)\n        for(int i = 1; i <= n; ++i)\n        for(int j = 1; j <= n; ++j){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n         \n        int ans = INF;\n        for(int i = 1; i <= n; ++i){\n            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x0f0f0f0f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_station;\n  int total_road;\n  int water_source_idx;\n  int main_station1_idx;\n  int main_station2_idx;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_station,\n\t       &total_road,\n\t       &water_source_idx,\n\t       &main_station1_idx,\n\t       &main_station2_idx)){\n    if(total_station == 0) break;\n\n    int nodes[101][101];\n    memset(nodes,0x0f,sizeof(nodes));\n\n    for(int i=0;i<total_road;i++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      nodes[from][to] = cost;\n    }\n\n    for(int k=1;k<=total_station;k++){\n      for(int i=1;i<=total_station;i++){\n\tfor(int j=1;j<=total_station;j++){\n\t  nodes[i][j] = min(nodes[i][k]+nodes[k][j],nodes[i][j]);\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=1;i<=total_station;i++){\n      res = min(nodes[water_source_idx][i]\n\t\t+ nodes[i][main_station1_idx]\n\t\t+ nodes[i][main_station2_idx],res);\n    }\n\n    printf(\"%d\\n\",res);\n  }\n\t       \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst int INF = INT_MAX / 4;\n\nint main(void) {\n\tint n, m, s, g1, g2;\n\t\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\ts--; g1--; g2--;\n\n\t\tVVI es(n, VI(n, INF));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tes[a][b] = c;\n\t\t\tes[b][a] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tes[i][i] = 0;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, es[s][i] + es[i][g1] + es[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define N 100\nconst int infty = 1<<28;\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n};\nstruct State{\n  int now;\n  int cost;\n  State():now(-1),cost(infty){}\n  State(int pos,int c):now(pos),cost(c){}\n  bool operator>(const State &t)const{return cost>t.cost;}\n};\ntypedef vector<Node> Graph;\nint dijkstra(int s, int g, Graph &G)\n{\n  int A[G.size()];\n  bool vis[G.size()];\n  priority_queue< State,vector<State>,greater<State> > qs;\n  fill(A,A+G.size(),infty);\n  fill(vis,vis+G.size(),false);\n  qs.push(State(s,0));\n  A[s]=0;\n  while(!qs.empty()){\n    State now=qs.top();qs.pop();\n    //if(vis[now.now])continue;\n    //vis[now.now]=true;\n    for(int i=0;i<G[now.now].con.size();++i){\n      int next_id=G[now.now].con[i];\n      if(now.cost+G[now.now].cost[i]<A[next_id]){\n\tA[next_id]=now.cost+G[now.now].cost[i];\n\t//if(!vis[next_id]){\n\tqs.push(State(next_id,A[next_id]));\n\t  //}\n      }\n    }\n  }\n  return A[g];\n}\nint main()\n{\n  int n,m,s,g1,g2;\n  while( (cin >> n >> m >> s >> g1 >> g2) && n && m && s && g1 && g2 ){\n    int ans=infty;\n    --s;--g1;--g2;\n    Graph G(n);\n    for(int i = 0; i < m; ++i){\n      int src,dst,cost;\n      cin >> src >> dst>> cost;--src;--dst;\n      G[src].con.push_back(dst);\n      //G[dst].con.push_back(src);\n      G[src].cost.push_back(cost);\n      //G[dst].cost.push_back(cost);\n    }\n    for(int i = 0; i < n; ++i){\n      int tmp=dijkstra(s,i,G)+dijkstra(i,g1,G)+dijkstra(i,g2,G);\n      if(tmp<ans)ans=tmp;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <vector<ll> > Vec;\n#define INF 10000000\nVec G;\n\nvoid war(Vec& vec) {\n\tint v = vec.size();\n\t\tfor (int k = 0; k < v; k++) {\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tfor (int j = 0; j < v; j++) {\n\t\t\t\t\tvec[i][j] = min(vec[i][j], vec[i][k] + vec[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\ts--; g1--; g2--;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tG[i].push_back(i != j ? INF : 0);\n\t\t\t}\n\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tG[a - 1][b - 1] = c;\n\t\t\t}\n\t\t\twar(G);\n\t\t\tll res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n\t\t\t}\n\t\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int INF = 1e+9;\n\nint d[MAX_V][MAX_V];\n\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\td[i][j] = (i == j)? 0 : INF ;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile( cin >> n >> m >> s >> g1 >> g2 , n || m ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\td[u][v] = d[v][u] = cost;\n\t\t}\n\t\t\n\t\tfor(int k=1 ; k <= n ; k++ ){\n\t\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\t\tfor(int j=1 ; j <= n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , d[i][k] + d[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tans = min( ans , d[s][i] + d[i][g1] + d[i][g2] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m, s, g1, g2, b1, b2, c;\n  long long int INF = 1e12;\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    --s;--g1;--g2;\n    vector< vector<long long int> > G(n,vector<long long int>(n,INF));\n    for(int i = 0; i < m; ++i){\n      cin >> b1 >> b2 >> c;\n      --b1;--b2;\n      G[b1][b2] = c;\n      G[b2][b1] = c;\n    }\n    for(int k = 0; k < n; ++k)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n          G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      ans = min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1e7\nusing namespace std;\nint main(){\n  int n,m,x,y,z,q,w,e;\n  while(cin>>n>>m>>x>>y>>z,n++){\n    int dp[n][n]={};\n    r(i,n)r(j,n)if(i!=j)dp[i][j]=INF;\n    r(i,m){\n      cin>>q>>w>>e;\n      dp[q][w]=dp[w][q]=e;\n    }\n    r(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n    int ans=INF;\n    r(i,n)ans=min(ans,dp[i][x]+dp[i][y]+dp[i][z]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include <functional>\n#define INF 1000000\nusing namespace std;\ntypedef long long ll;\nstruct edge { int to, cost; };\ntypedef pair<ll, int> P;\n\n\nint V;\nvector<edge> G[1010];\nll d[105];\n\nll dijkstra(int s,int g) {\n\tpriority_queue<P, vector<P>,greater<P>> que;\n\tfill(d, d + V, 1000000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!(que.empty())) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size; i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main() {\n\twhile (true) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tll ans;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0)break;\n\t\ts--; g1--; g2--;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e;\n\t\t\te.to = b - 1; e.cost = c;\n\t\t\tG[a - 1].push_back(e);\n\t\t}\n\t\tans = min(dijkstra(s, g1)+dijkstra(g1,g2),dijkstra(s,g2)+dijkstra(g2,g1));\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[111][111];\n  for(int i=0;i<111;i++){\n    for(int j=0;j<111;j++){\n      road[i][j]=INF;\n    }\n  }\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define ll long long\nconst int INF = 2 << 27;\n\nint main() {\n  while(1){\n    int n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n    s--;\n    g1--;\n    g2--;\n    int cost[n][n];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n        if(i == j) continue;\n        cost[i][j] = INF;\n      }\n    }\n    for(int i = 0; i < m; i++) {\n      int b1,b2,c;\n      cin >> b1 >> b2 >> c;\n      cost[b1-1][b2-1] = c;\n      cost[b2-1][b1-1] = c;\n    }\n\n\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n        for (int k = 0; k < n; k++)\n          cost[j][k] = std::min(cost[j][k], cost[j][i] + cost[i][k]);\n    int ans = INF;\n    for(int i = 0; i < n; i++) {\n      ans = min(ans,cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint n, m, s, g1, g2;\nint cost[110][110];\n\nvoid solve() {\n\tfor_(i,0,n) fill(cost[i], cost[i] + n, iINF / 2);\n\t\n\tfor_(i,0,m) {\n\t\tint v, u, c; cin >> v >> u >> c;\n\t\t--v; --u;\n\t\tcost[v][u] = cost[u][v] = c;\n\t}\n\t\n\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\n\tint ans = cost[s][g1] + cost[s][g2];\n\tans = min(ans, cost[s][g1] + cost[g1][g2]);\n\tans = min(ans, cost[s][g2] + cost[g1][g2]);\n\t\n\tfor_(k,0,n) {\n\t\tans = min(ans, cost[s][k] + cost[g1][k] + cost[g2][k]);\n\t\t\n\t\tans = min(ans, cost[s][k] + cost[g1][k] + cost[g2][s]);\n\t\tans = min(ans, cost[s][k] + cost[g1][k] + cost[g2][g1]);\n\t\t\n\t\tans = min(ans, cost[s][g1] + cost[g1][k] + cost[g2][k]);\n\t\tans = min(ans, cost[s][g2] + cost[g1][k] + cost[g2][k]);\n\t\t\n\t\tans = min(ans, cost[s][k] + cost[g1][s] + cost[g2][k]);\n\t\tans = min(ans, cost[s][k] + cost[g1][g2] + cost[g2][k]);\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\t--s; --g1; --g2;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint n, m, s, g1, g2;\nint dist[100][100];\n\nint main()\n{\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n){\n\t\t--s; --g1; --g2;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t\tdist[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tdist[--a][--b] = c;\n\t\t\t//dist[  b][  a] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int c = 0; c < n; c++){\n\t\t\tint t = dist[s][c] + dist[c][g1] + dist[c][g2];\n\t\t\tres = min(res, t);\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[100][100];\n\tint n,m,g1,g2,s,a,b,c;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n){\n\t\tint ret = (1<<21);\n\t\ts--;g1--;g2--;\n\t\trep(i,100)rep(j,100)wf[i][j]=(1<<26);\n\t\trep(i,100)wf[i][i]=0;\n\t\trep(i,m){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\twf[a][b] = c;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\twf[i][j] = min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\t\t\n\t\trep(j,n)\n\t\t\tret = min(ret,wf[s][j]+wf[j][g1]+wf[j][g2]);\n\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const INF = (int)1e9;\n\nint main() {\n  int N, M, S, g1, g2;\n  \n  while(cin >> N >> M >> S >> g1 >> g2 && N) {\n    int cost[100][100]; fill(cost[0], cost[0]+10000, INF);\n    \n    S--, g1--, g2--;\n    for(int i=0; i<M; i++) {\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      cost[a][b] = c;\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    \n    int ans = INF;\n    for(int k=0; k<N; k++) {\n      ans = min(ans, cost[S][k] + cost[k][g1] + cost[k][g2]);\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\nint n, m, s, g[2];\nll dist[100][100];\nconst ll INF = 1e15;\nvoid solve(){\n  rep(k,n){\n    rep(i,n){\n      rep(j,n){\n        dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);\n      }\n    }\n  }\n  ll ans = INF;\n  rep(mid,n){\n    ans = min(dist[s][mid] + dist[mid][g[0]] + dist[mid][g[1]], ans);\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  while(true){\n    cin >> n >> m >> s >> g[0] >> g[1];\n    if(n == 0 && m == 0 && s == 0 && g[0] == 0 && g[1] == 0) break;\n    s--, g[0]--, g[1]--;\n    rep(i,100)rep(j,100) dist[i][j] = INF;\n    rep(i,n) dist[i][i] = 0;\n    rep(i,m){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--, b--;\n      dist[a][b] = c;\n    }\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nconst int MAX_V = 110;\nint n;\nint m;//道路の数\nint s;\nint b1,b2;\nint g1,g2;\nint c;\n\nint d[MAX_V];\nint cost[MAX_V][MAX_V];\n\nint main(){\n\twhile(cin>>n>>m>>s>>g1>>g2,n||m||s||g1||g2){\n\t\trep(i,n+1){\n\t\t\trep(j,n+1){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tif(i==j){\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,m){\n\t\t\tcin>>b1>>b2>>c;\n\t\t\tcost[b1][b2] = c;\n\t\t}\n\t\tfor(int k = 1;k <=n;k++){\n\t\t\tfor(int i = 1;i <=n;i++){\n\t\t\t\tfor(int j = 1;j <=n;j++){\n\t\t\t\t\tcost[i][j] =min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 1;i <=n;i++){\n\t\t\tans = min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 105\n#define INF (1e9)\nusing namespace std;\nvoid prim();\nvoid func(int);\nint n,m,s,g1,g2,b1,b2,c,cost[N_MAX][N_MAX],mincost[N_MAX],ans;\nbool used[N_MAX];\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) cost[i][j]=INF;\n    for(int i=0;i<m;i++) cin>>b1>>b2>>c,cost[b1][b2]=cost[b2][b1]=c;\n    prim();\n  }\n  return 0;\n}\n\nvoid prim(){\n  for(int i=1;i<=n;i++) mincost[i]=INF,used[i]=false;\n  mincost[s]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    for(int u=1;u<=n;u++)\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=1;u<=n;u++) mincost[u]=min(mincost[u],cost[v][u]);\n  }\n  for(int i=1;i<=n;i++) used[i]=false;\n  func(s);\n  cout<<ans<<endl;\n}\n\nvoid func(int d){\n  if(used[d]) return ;\n  used[d]=true;\n  if(d==g1||d==g2) return ;\n  for(int i=1;i<=n;i++){\n    if(mincost[i]==cost[d][i]){\n      ans+=mincost[i];\n      func(i);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m, s, g1, g2;\n  while(cin >> n >> m >> s >> g1 >> g2, n) {\n    s--, g1--, g2--;\n    int cost[n][n];\n    rep(i, n)rep(j, n) cost[i][j] = (i == j) ? 0 : INF;\n    rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c; a--, b--;\n      cost[a][b] = c;\n    }\n\n    rep(i, n)rep(j, n)rep(k, n) minch(cost[j][k], cost[j][i] + cost[i][k]);\n    int mini = INF;\n    rep(i, n) minch(mini, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    cout << mini << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,m,s,g1,g2,d[101][101];\n\nint main(){\n\twhile(cin>>n>>m>>s>>g1>>g2&&n){\n\t\trep(i,n+1)fill(d[i],d[i]+n+1,INF);\n\t\trep(i,n+1)d[i][i]=0;\n\t\tint f,t,c,ans=INF;\n\t\trep(i,m){\n\t\t\tcin>>f>>t>>c;\n\t\t\td[f][t]=c;\n\t\t}\n\t\trep(i,n+1)rep(j,n+1)rep(k,n+1)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\t\trep(i,n+1){rep(j,n+1)cout<<d[i][j]<<\" \";cout<<endl;}\n\t\trep(i,n)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,m,s,g1,g2,d[101][101];\n\nint main(){\n\twhile(cin>>n>>m>>s>>g1>>g2&&n){\n\t\trep(i,n+1)fill(d[i],d[i]+n+1,INF);\n\t\trep(i,n+1)d[i][i]=0;\n\t\tint f,t,c,ans=INF;\n\t\trep(i,m){\n\t\t\tcin>>f>>t>>c;\n\t\t\td[f][t]=c;\n\t\t}\n\t\trep(i,n+1)rep(j,n+1)rep(k,n+1)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\trep(i,n)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint main(){\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2,n!=0){\n        s--, g1--, g2--;\n\n        vvi G(n, vi(n, 1e8));\n        rep(i, m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--, b--;\n            G[a][b] = c;\n        }\n\n        rep(k, n)rep(i, n)rep(j, n){\n            G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n        rep(i, n) G[i][i] = 0;\n\n        int ans = 1e8;\n        rep(i, n){\n            ans = min(ans, G[s][i] + G[i][g1] + G[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int N, int M, int S, int G1, int G2) {\n    const int INF = 10000000;\n    vector<vector<int>> d(N+1, vector<int>(N+1, INF));\n    for (int i = 0; i < M; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;   \n        d[a][b] = c;\n    }\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                d[i][i] = d[j][j] = d[k][k] = 0;\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    \n    int ret = INF;\n    for (int mid = 1; mid <= N; mid++) {\n        ret = min(ret, d[S][mid] + d[mid][G1] + d[mid][G2]);\n    }\n    return ret;\n}\n\nint main(void){\n    int n, m, s, g1, g2;\n    vector<int> ans;\n    while (1) {\n        cin >> n >> m >> s >> g1 >> g2;\n        if (n == 0) break;\n        ans.push_back(solve(n, m, s, g1, g2));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 110;\nconst int INF = 1e9 + 7;\n\nclass C{\n  public:\n    int from, to, cost;\n    bool d;\n    C(){}\n    C(int _f, int _t, int _c, bool _d){ from = _f; to = _t; cost = _c; d = _d; }\n    bool operator < (const C &c) const { return cost < c.cost; }\n};\n\nbool dfs(int now, int t, int c, vector<int> &cost, vector<C> &es){\n  cost[now] = c;\n  if(now == t) return true;\n  bool res = false;\n  REP(i, es.size()){\n    if(es[i].d || es[i].from != now || c + es[i].cost >= cost[es[i].to]) continue;\n    res = max(res, dfs(es[i].to, t, c + es[i].cost, cost, es));\n  }\n  return res;\n}\n\nint main() {\n  int N, M, S, G1, G2;\n  while(cin >>N >>M >>S >>G1 >>G2 && N){\n    --S; --G1; --G2;\n    vector<C> es(M);\n    int sum = 0;\n    REP(i, M){\n      int f, t, c; cin >>f >>t >>c;\n      --f; --t;\n      es.push_back(C(f, t, c, 0));\n      sum += c;\n    }\n    SORT(es);\n    REVERSE(es);\n    REP(i, M){\n      es[i].d = true;\n      vector<int> cost(N, INF), cost2(N, INF);\n      if(dfs(S, G1, 0, cost, es) && dfs(S, G2, 0, cost2, es)) sum -= es[i].cost;\n      else es[i].d = false;\n    }\n    cout <<sum <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nconst int kN = 105;\nint atl[kN][kN];\n\nvoid warshallFloyd(int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                atl[i][j] = min(atl[i][j], atl[i][k] + atl[k][j]);\n            }\n        }\n    }\n}\n\nint requestCost(int n, int s, int g1, int g2){\n    int retval = INF;\n    range(i,1,n + 1){\n        int cost = atl[s][i] + atl[i][g1] + atl[i][g2];\n        retval = min(retval, cost);\n    }\n    return retval;\n}\n\nint main(){\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n||m||s||g1||g2){\n        rep(i,kN) rep(j,kN) atl[i][j] = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            atl[a][b] = c;\n            atl[b][a] = c;\n        }\n        warshallFloyd(n);\n        cout << requestCost(n, s, g1, g2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n \n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define INF 1 << 29\n \nusing namespace std;\n \nint n, m, s, g1, g2;\nint cost[101][101];\n \nint main(){\n \n  while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n){\n    s--;g1--;g2--;\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    rep(i, n) cost[i][i] = 0;\n    int a, b, c;\n    rep(i, m){\n      scanf(\"%d%d%d\", &a, &b, &c);\n      a--;b--;\n      cost[a][b] = c;\n    }\n \n    rep(i, n) rep(j, n) rep(k, n)\n      cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n \n    /*    rep(i, n){\n      rep(j, n) printf(\"%d \", cost[i][j]);\n      puts(\"\");\n      } */\n  \n    int res = INF;\n    rep(i, n){\n      res = min(res, cost[s][i] + cost[i][g1] + cost[i][g2]);\n      //      printf(\"%d + %d + %d\\n\", cost[s][i], cost[i][g1], cost[i][g2]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 50000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = (table[j][k] < (table[j][i] + table[i][k]) ?\n\t\t\t\t\ttable[j][k] : (table[j][i] + table[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define INF 99999999\n\nusing namespace std;\n\nint n,d[101][101];\n\nvoid warshall_floyd(void){\n  \n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j] , d[i][k] + d[k][j]);\n      }\n\t\n}\n \nint main(void){\n\n    int n, m, s, g1, g2, b1, b2, c, d[101][101];\n\n    while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2), n){\n        for(int i = 0; i <= n; ++i){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for(int i = 0; i < m; ++i){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            d[b1][b2] = c;\n        }\n\n\twarshall_floyd();\n         \n        int ans = INF;\n        for(int i = 1; i <= n; ++i){\n\t  ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    s--,g1--,g2--;\n    const long long int INF=1e10;\n    vector<vector<long long int>> d(n,vector<long long int>(n,INF));\n    for(int i=0;i<n;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      d[b1][b2]=c;\n    }\n    \n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    long long int res=1e10;\n    for(int g=0;g<n;g++){\n      long long int share=d[s][g];\n      long long int cost1=d[g][g1];\n      long long int cost2=d[g][g2];\n      long long int cost=share+cost1+cost2;\n      res=min(res,cost);\n    }\n    cout<<res<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[100][100];\n\tint n,m,g1,g2,s,a,b,c;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n){\n\t\tint ret = (1<<21);\n\t\ts--;g1--;g2--;\n\t\trep(i,100)rep(j,100)wf[i][j]=(1<<26);\n\t\trep(i,100)wf[i][i]=0;\n\t\trep(i,m){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\twf[a][b] = c;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\twf[i][j] = min(wf[i][j],wf[i][k]+wf[k][j]);\n\t\t\t\n\t\trep(j,n)\n\t\t\tret = min(ret,wf[s][j]+wf[j][g1]+wf[j][g2]);\n\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint cost[100][100];\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n){\n\t\tmemset(cost,0x1f,sizeof(cost));\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=INT_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%d\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e9;\n\nint main() {\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tll cost[100][100]; fill(cost[0], cost[100], inf);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tcost[a][b] = c;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nlong long dist[1010][1010];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 &&n!=0){\n\t\ts--,g1--,g2--;\n\t\tlong long mi = 1000000000;\n\t\tfor(int i=0;i<1010;i++){\n\t\t\tfor(int j=0;j<1010;j++){\n\t\t\t\tif(i!=j)dist[i][j] = mi;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b;\n\t\t\tlong long c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--,b--;\n\t\t\tdist[a][b] = c;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmi = dist[s][g1]+dist[s][g2];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmi = min(mi,dist[s][i]+dist[i][g1]+dist[i][g2]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef struct P{\n\tint p,c,f[1000];\n\t//int operator <(const P a){return p<a.p;};\n}P;\n\nstruct Order\n{\n\tbool operator ()(P const& a, P const& b) const\n\t{\n\t\treturn a.c>b.c;\n\t}\n};\n\n\nint N,M,S,G1,G2,C[1005][1005];\nint main()\n{\n\tfor(;scanf(\"%d%d%d%d%d\",&N,&M,&S,&G1,&G2),N;)\n\t{\n\t\tS--;G1--;G2--;\n\t\tmemset(C,0,sizeof(C));\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint f,t,c;\n\t\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\t\tf--;t--;\n\t\t\tC[f][t]=C[t][f]=c;\n\t\t}\n\t\tpriority_queue<P,vector<P>,Order> Q;\n\t\tP tmp;tmp.p=S;tmp.c=0;\n\t\tmemset(tmp.f,0,sizeof(tmp.f));tmp.f[S]=1;\n\t\tQ.push(tmp);\n\t\tfor(;!Q.empty();)\n\t\t{\n\t\t\ttmp=Q.top();Q.pop();\n\t\t\tif(tmp.f[G1]&&tmp.f[G2])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",tmp.c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tif(C[tmp.p][i])\n\t\t\t\t{\n\t\t\t\t\tif(tmp.f[i]==1)//alrady passed\n\t\t\t\t\t{\n\t\t\t\t\t\tP ins=tmp;\n\t\t\t\t\t\tins.f[i]++;\n\t\t\t\t\t\tins.p=i;\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t\telse if(tmp.f[i]==0)//new node\n\t\t\t\t\t{\n\t\t\t\t\t\tP ins=tmp;\n\t\t\t\t\t\tins.f[i]++;\n\t\t\t\t\t\tins.c+=C[tmp.p][i];\n\t\t\t\t\t\tins.p=i;\n\t\t\t\t\t\tQ.push(ins);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[200][200];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\ts--;g1--;g2--;\n\t\tmemset(cost,0x3f,sizeof(cost));\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);b1--;b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=LLONG_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M,S,G1,G2;\nint d[110][110] = {};\nint inf = 1e8;\n\nint main(){\n    while(cin >> N >> M >> S >> G1 >> G2 && N>0){\n        int b1,b2,c;\n        for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) if(i!=j) d[i][j] = inf;\n        for(int i=0;i<M;i++){\n            cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n        for(int k=1;k<=N;k++){\n            for(int i=1;i<=N;i++){\n                for(int j=1;j<=N;j++){\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=1;i<=N;i++){\n            ans = min(ans,d[S][i]+d[i][G1]+d[i][G2]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint n,m,s,g1,g2;\nint d[111][111];\nint main(void){\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2; if(!n) break;\n\n    s--;g1--;g2--;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\td[i][j] = 1 << 28;\n      }\n      d[i][i] = 0;\n    }\n    \n    for(int i = 0; i < m; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      d[a-1][b-1] = c;\n    }\n\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n\n    int ret = 1 << 28;\n    for(int i = 0; i < n; i++){\n      ret = min(ret,d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n \n#define INF (1 << 25)\n \nusing namespace std;\n \nint pcost[100][100]; // begin, end\nint mcost[100][100];\n \nvoid Dijkstra( int n, int s, int cost[][100], int *minCost )\n{\n    bool *end = new bool[n];\n    fill(end, end+n, false);\n    minCost[s] = 0;\n    end[s] = true;\n    while(true) {\n        int ii = -1, nn = (INF);\n        for(int i=0; i < n; ++i) {\n            if(end[i] && nn > minCost[i]) {\n                nn = minCost[i];\n                ii = i;\n            }\n        }\n        if(ii == -1) break;\n        end[ii] = false;\n        for(int i=0; i < n; ++i) {\n            if(minCost[i] > minCost[ii] + cost[ii][i]) {\n                minCost[i] = minCost[ii] + cost[ii][i];\n                end[i] = true;\n            }\n        }\n    }\n}\n \nint main( void )\n{\n    int minCost1[100], minCost2[100], minCost3[100];\n \n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2) {\n        --s; --g1; --g2;\n        for(int i=0; i < n; ++i) {\n            fill(pcost[i], pcost[i]+n, INF);\n            fill(mcost[i], mcost[i]+n, INF);\n            minCost1[i] = minCost2[i] = minCost3[i] = INF;\n        }\n        for(int i=0; i < m; ++i) {\n            int bb, ee, cc;\n            cin >> bb >> ee >> cc;\n            --bb; --ee;\n            pcost[bb][ee] = mcost[ee][bb] = cc;\n        }\n        Dijkstra(n, s, pcost, minCost1);\n        Dijkstra(n, g1, mcost, minCost2);\n        Dijkstra(n, g2, mcost, minCost3);\n \n        int ans = INF;\n        for(int i=0; i < n; ++i) {\n            ans = min(ans, minCost1[i] + minCost2[i] + minCost3[i]);\n        }\n        cout << ans << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tint m[100][100]; fill(m[0], m[100], inf);\n\t\tREP(i, N) m[i][i] = 0;\n\t\tREP(i, M) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tm[a][b] = min(m[a][b], c);\n\t\t\tm[b][a] = min(m[b][a], c);\n\t\t}\n\t\tREP(k, N) REP(i, N) REP(j, N) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\tint ans = inf;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, m[s][i]+m[i][g1]+m[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int INF = 1<<28;\nint n,m,s,g1,g2;\nvoid warshall_floyd(vector<vector<int> > &cost){\n  for(int i = 0;i < n;i++){\n\tfor(int j = 0;j < n;j++){  \n\t  for(int k = 0;k < n;k++){\t  \n\t\tcost[j][k] = min(cost[j][k],cost[j][i] + cost[i][k]);\n\t  }\n\t}\n  }\n}\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2 &&n){\n\tvector<vector<int> > cost = vector<vector<int> >(n,vector<int>(n,INF));\n\tfor(int i =0;i < n;i++)cost[i][i] = 0;\n\tfor(int i = 0;i < m;i++){\n\t  int from,to,c;\n\t  cin >> from >> to >> c;\n\t  cost[from-1][to-1] = c;\n\t}\n\twarshall_floyd(cost);\n\ts--;g1--;g2--;\n\tint ans = INF;\n\tfor(int j = 0;j < n;j++){\n\t  ans = min(ans,(cost[s][j]+cost[j][g1]+cost[j][g2]));\n\t}\n\tcout << ans << endl;\n//\tcout << min(min(cost[s][g1]+cost[s][g2],cost[s][g1]+cost[g1][g2]),cost[s][g2]+cost[g2][g1]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 101\n#define INF (1e9)\nusing namespace std;\nvoid prim();\nint n,m,s,g1,g2,b1,b2,c,cost[N_MAX][N_MAX],mincost[N_MAX];\nbool used[N_MAX];\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) cost[i][j]=INF;\n    for(int i=0;i<m;i++) cin>>b1>>b2>>c,cost[b1][b2]=cost[b2][b1]=c;\n    prim();\n  }\n  return 0;\n}\n\nvoid prim(){\n  for(int i=1;i<=n;i++) mincost[i]=INF,used[i]=false;\n  mincost[s]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    for(int u=1;u<=n;u++)\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=1;u<=n;u++) mincost[u]=min(mincost[u],cost[v][u]);\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++)\n    if(mincost[i]!=INF) ans+=mincost[i];\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define min(a,b) a > b ? b : a\n\n\nint main(void){\n\tint n, m, s, g1, g2, b1, b2, c, i, j, k, l, path[100][100], mn;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tfor(j = 0;j < n;j++) path[i][j] = INF;\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tpath[b1 - 1][b2 - 1] = c;\n\t\t\tpath[b2 - 1][b1 - 1] = c;\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t\tpath[i][i] = 0;\n\t\tmn = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\tpath[j][k] = min(path[j][i] + path[i][k],path[j][k]);\n\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(path[i][g1 - 1] != INF && path[i][g2 - 1] != INF && path[i][s - 1] != INF)\n\t\t\t\tmn = min(mn,path[i][g1 - 1] + path[i][g2 - 1] + path[i][s - 1]);\n\t\t}\n\t\tprintf(\"%d\\n\",mn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n or m)\n    {\n        s--, g1--, g2--;\n        vector<vector<ll>> cost(n, vector<ll>(n, INF));\n        for(int i = 0; i < n; i++) cost[i][i] = 0;\n        for(int i = 0; i < m; i++)\n        {\n            int a, b; ll c; cin >> a >> b >> c;\n            a--, b--;\n            cost[a][b] = c;\n        }\n        for(int k = 0; k < n; k++)\n            for(int i = 0; i < n; i++)\n                for(int j = 0; j < n; j++)\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n        ll ans = INF;\n        for(int k = 0; k < n; k++)\n        {\n            ans = min(ans, cost[s][k] + cost[k][g1] + cost[k][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<27;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n,m,s,t1,t2;\n\t\tcin>>n>>m>>s>>t1>>t2;\n\t\tif(n==0) break;\n\t\ts--;t1--;t2--;\n\t\tvvi g(n,vi(n,inf));\n\t\tfor(int i=0;i<n;i++) g[i][i]=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,w;\n\t\t\tcin>>u>>v>>w;\n\t\t\tu--;v--;\n\t\t\tg[u][v]=w;\n\t\t}\n\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\tint res=inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres=min(res,g[s][i]+g[i][t1]+g[i][t2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <algorithm>\n#define INF 0x1FFFFFFF\n\nusing namespace std;\n\nint main(void){\n\tint n, m, s, c, g1, g2, b1, b2, i, j, k, ans, w[100][100];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\ts--, g1--, g2--;\n\t\t\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++) w[i][j] = INF;\n\t\t\tw[i][i] = 0;\n\t\t}\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\t\tw[b1 - 1][b2 - 1] = c;\n\t\t}\n\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\tw[j][k] = min(w[j][k],w[j][i] + w[i][k]);\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tans = min(ans,w[s][i] + w[i][g1] + w[i][g2]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, m, s, g1, g2;\nint c[101][101];\n\nint main(){\n\tint a1, a2, a3;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n != 0) {\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\t\tc[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a1 >> a2 >> a3;\n\t\t\tc[a1][a2] = a3;\n\t\t}\n\t\tbool yet = true;\n\t\twhile (yet) {\n\t\t\tyet = false;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\t\tif (c[i][j] > c[i][k] + c[k][j]) {\n\t\t\t\t\t\t\tc[i][j] = c[i][k] + c[k][j];\n\t\t\t\t\t\t\tyet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = c[s][g1] + c[s][g2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (ans > c[s][i] + c[i][g1] + c[i][g2]) {\n\t\t\t\tans = c[s][i] + c[i][g1] + c[i][g2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 1000000;\nusing namespace std;\n\nint n, m, s, g[2] = {0};\nint memo[105][105] = {0};\n\nint solve();\n\nint main() {\n  while(1) {\n    cin >> n >> m >> s >> g[0] >> g[1];\n    --s, --g[0], --g[1];\n    if(n + m == 0) break;\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j) memo[i][j] = inf;\n    for(int i = 0; i < m; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a, --b;\n      memo[a][b] = c;\n    }\n\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int ans = inf;\n  for(int i = 0; i < n; ++i) memo[i][i] = 0;\n  for(int k = 0; k < n; ++k)\n    for(int i = 0; i < n; ++i)\n      for(int j = 0; j < n; ++j)\n        memo[i][j] =\n            min(memo[i][j], memo[i][k] + memo[k][j]);\n  for(int i = 0; i < n; ++i)\n    ans = min(ans,\n              memo[s][i] + memo[i][g[0]] + memo[i][g[1]]);\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tll m[100][100]; fill(m[0], m[100], linf);\n\t\tREP(i, N) m[i][i] = 0;\n\t\tREP(i, M) {\n\t\t\tll a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tm[a][b] = min(m[a][b], c);\n//\t\t\tm[b][a] = min(m[b][a], c);\n\t\t}\n\t\tREP(k, N) REP(i, N) REP(j, N) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\tll ans = linf;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, m[s][i]+m[i][g1]+m[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  vector<int> par;\n  vector<int> rank;\n  \npublic:\n  \n  UnionFind(int n) {\n    par.resize(n);\n    rank.resize(n);\n    for(int i=0; i<n; i++) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  \n  bool same(int x, int y) {\n    if(find(x) == find(y)) {\n      return true;\n    }\n    return false;\n  }\n  \n  void unite(int x, int y) {\n    \n    if(same(x, y)) return;\n    \n    if(rank[y] < rank[x]) {\n      par[y] = x;\n    }\n    else {\n      par[x] = y;\n      if(rank[x] == rank[y]) {\n\trank[x] ++;\n      }\n    }\n  }\n  \n  int find(int x) {\n    if(par[x] == x) {\n      return x;\n    }\n    \n    return par[x] = find(par[x]);\n  }\n  \n};\n\nstruct Edge {\n  int e, f, cost;\n  Edge() {}\n  Edge(int e, int f, int c) : e(e), f(f), cost(c) {}\n};\n\nEdge es[5000];\n\nbool cmp(const Edge& e, const Edge& f) {\n  return e.cost < f.cost;\n}\n\nint N, M, S, g1, g2;\n\nint kruskal() {\n\n  sort(es, es+M, cmp);\n  UnionFind uf(N);\n  int ret = 0;\n  for(int i=0; i<M; i++) {\n    if(!uf.same(es[i].e, es[i].f)) {\n      uf.unite(es[i].e, es[i].f);\n      ret += es[i].cost;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  \n  while(cin >> N >> M >> S >> g1 >> g2 && N) {\n    for(int i=0; i<M; i++) {\n      int a, b, c;\n      cin >> a >> b >> c; a--, b--;\n      es[i] = Edge(a, b, c);\n    }\n    \n    cout << kruskal() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const INF = 1<<29;\n\nint main() {\n  int N, M, S, g1, g2;\n  \n  while(cin >> N >> M >> S >> g1 >> g2 && N) {\n    int cost[100][100]; fill(cost[0], cost[0]+10000, INF);\n    for(int i=0; i<N; i++) cost[i][i] = 0;\n    S--, g1--, g2--;\n    for(int i=0; i<M; i++) {\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      cost[a][b] = c;\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    \n    int ans = INF;\n    for(int k=0; k<N; k++) {\n      ans = min(ans, cost[S][k] + cost[k][g1] + cost[k][g2]);\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    pma(g, n);\n    warshallFloyd(g, n);\n    pma(g, n);\n    \n    int ans = g[s][g1] + g[s][g2];\n    REP(i, n){\n        ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include <functional>\n#define INF 1000000\nusing namespace std;\ntypedef long long ll;\nstruct edge { int to, cost; };\ntypedef pair<ll, int> P;\n\n\nint V;\nvector<edge> G[1010];\nll d[105];\n\nll dijkstra(int s,int g) {\n\tpriority_queue<P, vector<P>,greater<P> > que;\n\tfill(d, d + V, 1000000);\n\td[s] = 0;\n\tque.push(P(0, s));\n\n\twhile (!(que.empty())) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first)continue;\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[g];\n}\n\nint main() {\n\twhile (true) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tll ans;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0)break;\n\t\ts--; g1--; g2--;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge e;\n\t\t\te.to = b - 1; e.cost = c;\n\t\t\tG[a - 1].push_back(e);\n\t\t}\n\t\tans = min(dijkstra(s, g1)+dijkstra(g1,g2),dijkstra(s,g2)+dijkstra(g2,g1));\n\t\tcout << ans << endl;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 9999999\n\nusing namespace std;\n\nint n, d[101][101];\n\nvoid warshall_floyd(void){\n\n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n}\n\n \nint main(void){\n\n    int m, s, g1, g2, b1, b2, c;\n\n    while(cin >> n >> m >> s >> g1 >> g2 ){\n      if( n == m && m == s && s == g1 && g1 == g2 && g2 == 0 ) break;\n\n        for( int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for( int i = 0; i < m; i++ ){\n\t  cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n\n\twarshall_floyd();\n                  \n        int ans = INF;\n        for( int i = 1; i <= n; i++ ){\n            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n        \n        \n    const int mx=1e9+7;\n    int n,m,s,go,gt;\n    cin>>n>>m>>s>>go>>gt;\n    if(n==0 && m==0){break;}\n    s--; go--; gt--;\n    int a[1000][1000];\n    fill(&a[0][0],&a[999][1000],mx);\n    for(int i=0;i<n;i++){\n        a[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        int b,c,d;\n        cin>>b>>c>>d;\n        a[b-1][c-1]=d;\n    }\n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int k=0;k<n;k++){\n                a[t][k]=min(a[t][i]+a[i][k],a[t][k]);\n            }\n        }\n    }\n    int ans=mx;\n    for(int i=0;i<n;i++){\n        ans=min(a[s][i]+a[i][go]+a[i][gt],ans);\n    }\n        \n        /*\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                cout<<(a[i][t]==mx? -1:a[i][t])<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n        */\n        \n        \n    assert(ans!=mx);\n    cout<<ans<<endl;\n    \n    \n    \n    \n    \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int d[101][101];\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2;){\n    for(int y=1;y<=n;y++){\n      for(int x=1;x<=n;x++){\n\td[y][x]=(y==x)?0:1<<28;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      d[b1][b2]=c;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int ans=1<<30;\n    for(int i=1;i<n;i++){\n      ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint n, m, s, g1, g2;\nint c[100][100];\n\nint main(){\n\tint a1, a2, a3;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n != 0) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\t\tc[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a1 >> a2 >> a3;\n\t\t\tc[a1][a2] = a3;\n\t\t}\n\t\tbool yet = true;\n\t\twhile (yet) {\n\t\t\tyet = false;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tif (c[i][j] > c[i][k] + c[k][j]) {\n\t\t\t\t\t\t\tc[i][j] = c[i][k] + c[k][j];\n\t\t\t\t\t\t\tyet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = c[s][g1] + c[s][g2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ans > c[s][i] + c[i][g1] + c[i][g2]) {\n\t\t\t\tans = c[s][i] + c[i][g1] + c[i][g2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    LL n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0) return 0;\n    s--,g1--,g2--;\n    vector<vector<LL>> dist(n,vector<LL>(n,INF));\n    for(LL i=0;i<n;i++) dist[i][i]=0;\n    LL u,v,c;\n    for(LL i=0;i<m;i++){\n      cin >> u >> v >> c;\n      dist[u-1][v-1]=c;\n    }\n    for(LL k=0;k<n;k++){\n      for(LL i=0;i<n;i++){\n        for(LL j=0;j<n;j++){\n          dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n        }\n      }\n    }\n    // for(LL i=0;i<n;i++){\n    //   for(LL j=0;j<n;j++){\n    //     cout << dist[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    LL ans=INF;\n    for(LL i=0;i<n;i++){\n      ans=min(ans,dist[s][i]+dist[i][g1]+dist[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 99999999\n\nusing namespace std;\n\nint n,d[101][101];\n\nvoid warshall_floyd(void){\n  \n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ )\n\td[i][j] = min(d[i][j] , d[i][k] + d[k][j]);\n      \n\t\n}\n \nint main(void){\n\n    int n, m, s, g1, g2, b1, b2, c, d[101][101];\n\n    while( cin >> n >> m >> s >> g1 >> g2 , n + m + s + g1 + g2 ){\n        for(int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= n; j++ ){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for(int i = 0; i < m; i++ ){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            d[b1][b2] = c;\n        }\n\n\twarshall_floyd();\n         \n        int ans = INF;\n        for( int i = 1; i <= n; i++ ){\n\t  ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define INF (1<<28)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint n,m,s,g,h;\nvector<vi> v;\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \",\";\n\tout << \"}\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m >> s >> g >> h, n){\n\t\tv.resize(n,vi(n,INF));\n\t\tint ans = INF;\n\t\ts--; g--; h--;\n\t\trep(i,m){\n\t\t\tint x, y, c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tv[x-1][y-1] = c;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n) v[i][j] = min(v[i][j], v[i][k] + v[k][i]);\n\t\t\n\t\trep(i,n){\n\t\t\tans = min (ans, v[s][i] + v[i][g] + v[i][h]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    int size;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);\n        size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y])par[x] = y;\n        else par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n};\n\nint INF=1<<28;\n\ntypedef  vector<vector<int> > Mat;\n// O(n^3) n≦100\n    void warshall_floyd(Mat& d){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    //prev[i][j]=k;\n                }\n            }\n    }\n\nint main(){\n\twhile(true){\n\t\tint n,m,s,g1,g2;cin >> n>>m >> s >> g1 >> g2;s--;g1--;g2--;\n\t\tif(n==0)break;\n\t\tMat ds(n,vector<int>(n,INF));\n\t\tREP(i,n)ds[i][i]=0;\n\t\tREP(i,m){\n\t\t\tint f,t,c;cin >> f >> t >> c;f--;t--;\n\t\t\tds[f][t]=min(ds[f][t],c);\n\t\t}\n\t\twarshall_floyd(ds);\n\n\t\t//ic...インターチェンジ(中継点) s→ic→g1,s→ic→g2\n\t\tint res=INF;\n\t\tREP(ic,n){\n\t\t\tres=min(ds[s][ic]+ds[ic][g1]+ds[ic][g2],res);\n\t\t}\n\t\tcout<< res <<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define BMAX 100\n#define DMAX 1000000\n\nusing namespace std;\n\nstruct data { \n\tint cost;\n\tint where;\n};\n\n//bool bind[BMAX][BMAX];\nint cost[BMAX][BMAX];\nint dis[BMAX][BMAX];\nbool check[BMAX];\n\nbool operator<( const data& a, const data& b) {\n\treturn a.cost < b.cost;\n}\n\nbool operator>( const data& a, const data& b) {\n\treturn a.cost > b.cost;\n}\n\nint main () {\n\tint count = 0;\n\twhile ( true ) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m>> s>> g1>> g2;\n\t\t//cout << \"Count: \" << count << endl;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcost[i][j] = DMAX;\n\t\t\t\tdis[i][j] = DMAX;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tcost[i][i] = 0;\n\t\t\tdis[i][i] = 0;\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint x,y,c;\n\t\t\tcin >> x >> y >> c;\n\t\t\t//\t\t\tcout << x << \"\\t\" << y << \"\\t\" << c << endl;\n\t\t\tcost[x-1][y-1] = c;\n\t\t\tcost[y-1][x-1] = c;\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << cost[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << dis[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tpriority_queue<data> flow;\n\n\t\t\twhile(!flow.empty()) {\n\t\t\t\tflow.pop();\n\t\t\t}\n\n\t\t\tdata now;\n\t\t\tnow.cost = 0;\n\t\t\tnow.where = i;\n\t\t\tflow.push(now);\n\t\t\t//cout << \"Start\" << i << endl;\n\t\t\twhile ( !flow.empty() ) {\n\t\t\t\tdata now = flow.top();\n\t\t\t\tflow.pop();\n\n\t\t\t\tdata next;\n\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tcheck[j] = true;\n\t\t\t\t}\n\t\t\t\tcheck[now.where] = false;\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tif ( check[j] ) {\n\t\t\t\t\t\t//cout << \"search \" << now.where << \"->\" << j << endl;\n\t\t\t\t\t\tcheck[j] = false;\n\t\t\t\t\t\t//cout << \"Raw\" << dis[now.where][j] << \"\\t\" << cost[now.where][j] << endl;\n\t\t\t\t\t\tint newDCost = dis[now.where][j] + now.cost ;\n\t\t\t\t\t\tint newCCost = cost[now.where][j] + now.cost ;\n\t\t\t\t\t\tint newCost;\n\t\t\t\t\t\tif ( newDCost < newCCost )\n\t\t\t\t\t\t\tnewCost = newDCost;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnewCost = newCCost;\n\t\t\t\t\t\t//cout << \"D \" << newDCost << \"\\tC \" << newCCost << endl;\n\t\t\t\t\t\t//cout << dis[i][j] << \" \" << newCost << endl;\n\t\t\t\t\t\tif ( dis[i][j] > newCost ) {\n\t\t\t\t\t\t\t//cout << \"Pass\" << endl;\n\t\t\t\t\t\t\tif ( dis[i][j] > newCost )\n\t\t\t\t\t\t\t\tdis[i][j] = newCost;\n\t\t\t\t\t\t\tnext.cost = newCost;\n\t\t\t\t\t\t\tnext.where = j;\n\t\t\t\t\t\t\tif ( next.cost != DMAX ) {\n\t\t\t\t\t\t\t\t//cout << \"New: \" << newCost << endl;\n\t\t\t\t\t\t\t\tflow.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << dis[i][j] << \" \" << newCost << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"Size: \" << flow.size() << endl;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << dis[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\n\t\tint min = DMAX;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tif ( min > dis[i][s] + dis[i][g1] + dis[i][g2] )\n\t\t\t\tmin = dis[i][s] + dis[i][g1] + dis[i][g2];\n\t\t}\n\n\t\tcout << min << endl;;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m,s,g1,g2;\nlong d[111][111];\nmain()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2,n)\n\t{\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(i!=j)d[i+1][j+1]=1e18;\n\t\tfor(;m--;)\n\t\t{\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\tfor(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tlong ans=1e18;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main ()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n + m + s + g1 + g2) {\n        vector<vector<int> > d(n + 1, vector<int>(n + 1, INF));\n        for (int i = 0; i <= n; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int gx, gy, c;\n            cin >> gx >> gy >> c;\n            d[gx][gy] = c;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int  k = 1; k <= n; k++) {\n                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 1; i <= n; i++) {\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<climits>\nusing namespace std;\n#define INF INT_MAX\n\nint n,m,s,g1,g2;\nvector< vector<long long> > edge;\n\nvoid init(){\n  n=m=s=g1=g2=0;\n  edge.clear();\n}\n\nbool input(){\n  cin>>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0){\n    return 0;\n  }\n  s--;g1--;g2--;\n  edge.resize(n+1);\n  for(int i=0;i<n+1;i++){\n    edge[i].resize(n+1);\n    for(int j=0;j<n+1;j++){\n      edge[i][j]=INF;\n    }\n    edge[i][i]=0;\n  }\n  for(int i=0;i<m;i++){\n    long long  b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--;b2--;\n    edge[b1][b2]=c;\n  }\n  return 1;\n}\n\n\n\n\nint solve(){\n  for(int k=0;k<n+1;k++){\n    for(int i=0;i<n+1;i++){\n      for(int j=0;j<n+1;j++){\n        edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      }\n    }\n  }\n  long long res=INF;\n  for(int i=0;i<n+1;i++){\n    res=min(res,edge[s][i]+edge[i][g1]+edge[i][g2]);\n  }\n  return res;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1e7\nusing namespace std;\nint main(){\n  int n,m,x,y,z,q,w,e;\n  while(cin>>n>>m>>x>>y>>z,n++){\n    int dp[n][n]={};\n    r(i,n)r(j,n)if(i!=j)dp[i][j]=INF;\n    r(i,m){\n      cin>>q>>w>>e;\n      dp[q][w]]=e;\n    }\n    r(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n    int ans=INF;\n    r(i,n)ans=min(ans,dp[i][x]+dp[i][y]+dp[i][z]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//--------------------------------------------------\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<ctime>\n\nusing namespace std;\n\n//conversion\n//--------------------------------------------------\ninline int toInt(const string &s){\n    int v;istringstream sin(s);sin>>v;\n    return v;\n}\ntemplate<class T> inline string toString(T x){\n    ostringstream sout;sout<<x;\n    return sout.str();\n}\n\n//math\n//--------------------------------------------------\ntemplate<class T> inline T sqr(T x){return x*x;}\n\n//typedef\n//--------------------------------------------------\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n\n//container util\n//--------------------------------------------------\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//--------------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------------\nconst int INF=1e9+7;\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\n\n//clear memory\n#define CLR(a) memset((a),0,sizeof(a))\n\n//debug\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\"(L\"<<__LINE__<<\")\"<<endl\n\n//---------------------------------------------------\n\nint N,M,S,G1,G2;\nint g[100][100];\nint solve(){\n    REP(k,N)\n        REP(i,N)\n            REP(j,N)\n                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\n    int mi=INF;\n    REP(i,N){\n        mi=min(mi,g[S][i]+g[i][G1]+g[i][G2]);\n    }\n    return mi;\n\n}\n\n\nint main(){\n    while(cin>>N>>M>>S>>G1>>G2,N||M||S||G1||G2){\n        S--;G1--;G2--;\n        fill_n(*g,10000,INF);\n        REP(i,N)g[i][i]=0;\n        REP(i,M){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            g[a][b]=g[b][a]=c;\n        }\n        cout<<solve()<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\tint b1, b2, c;\n\tint k, i, j;\n\tint minCost;\n\n\tvvi cost;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) && n!=0) {\n\n\tcost.resize(n);\n\t\n\tREP(i, n) {\n\t\tcost[i].resize(n);\n\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {A\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tcin >> b1 >> b2 >> c;\n\n\t\tcost[b1-1][b2-1] = c;\n\t}\n\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tminCost = cost[s-1][g1-1] + cost[s-1][g2-1];\n\tk = max(g1, g2);\n\n\tFOR(i, s-1, k) {\n\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t}\n\n\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, m, s, g, gg, from, to, cost;\n  cin >> n >> m >> s >> g >> gg;\n  s--;g--;gg--;\n  vector<vector<int> > graph(n, vector<int>(n, 1e9));\n  for(int i = 0; i < m; i++){\n    cin >> from >> to >> cost;\n    from--;to--;\n    graph[from][to] = cost;\n  }\n  for(int k = 0; k < n; k++){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tgraph[i][j] = min(graph[i][k] + graph[k][j], graph[i][j]);\n      }\n    }\n  }\n  int ans = 1e9;\n  for(int i = 0; i < n; i++){\n    ans = min(ans, graph[s][i]+ graph[i][g] + graph[i][gg]);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n \nusing namespace std;\n \n#define MAX_N 101\n#define INF (1<<28)\n \nint n, m, s, g1, g2;\nint graph[MAX_N][MAX_N];\nint main() {\n    while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n || m || s || g1 || g2) {\n        for (int i = 0; i <= n; i++) \n            for (int j = 0; j <= n; j++) {\n                if (i == j) graph[i][j] = 0;\n                else graph[i][j] = INF;\n            }\n        for (int i = 0; i < m; i++) {\n            int b1, b2, c;\n            scanf(\"%d %d %d\", &b1, &b2, &c);\n            graph[b1][b2] = c;\n        }\n        for (int k = 1; k <= n; k++) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n                }\n            }\n        }\n \n        int min_cost = graph[s][g1] + graph[s][g2];\n        for (int i = 1; i <= n; i++) { // 分岐する点\n            min_cost = min(min_cost, graph[s][i] + graph[i][g1] + graph[i][g2]);\n        }\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct Edge {\n\tint t, cost, type;\n\tEdge(int _t, int _c, int _type) : t(_t), cost(_c), type(_type) {}\n};\n\nbool operator > (const Edge& a, const Edge& b) {\n\treturn a.cost > b.cost;\n}\n\nint n, m, s, g1, g2;\nint cost[110][110];\n\nvoid solve() {\n\tfor_(i,0,n) fill(cost[i], cost[i] + n, iINF / 2);\n\t\n\tfor_(i,0,n) cost[i][i] = 0;\n\t\n\tfor_(i,0,m) {\n\t\tint v, u, c; cin >> v >> u >> c;\n\t\t--v; --u;\n\t\tcost[v][u] = c;\n\t}\n\t\n\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\n\tint ans = iINF;\n\tfor_(k,0,n) ans = min(ans, cost[s][k] + cost[k][g1] + cost[k][g2]);\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\t--s; --g1; --g2;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nmain {\n  int n, k;\n  while (cin >> n >> k, n) {\n    vvi g(n, vi(n, INF));\n    rep(i, n) g[i][i] = 0;\n    while (k--) {\n      int q;\n      cin >> q;\n      if (q) {\n        int c, d, e;\n        cin >> c >> d >> e;\n        --c, --d;\n        cmin(g[c][d], e), cmin(g[d][c], e);\n        rep(i, n) rep(j, n) cmin(g[i][j], g[i][c] + g[c][j]);\n        rep(i, n) rep(j, n) cmin(g[i][j], g[i][d] + g[d][j]);\n      } else {\n        int a, b;\n        cin >> a >> b;\n        --a, --b;\n        cout << (g[a][b] == INF ? -1 : g[a][b]) << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=10000000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=10000000;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m,s,t1,t2;\n\twhile(cin>>n>>m>>s>>t1>>t2,n){\n\t\ts--;t1--;t2--;\n\t\tvvi G(n,vi(n,inf));\n\t\trep(i,n)G[i][i]=0;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[a][b]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\tint out=inf;\n\t\trep(i,n)out=min(out,G[s][i]+G[i][t1]+G[i][t2]);\n\t\tcout<<out<<endl;\n\t}\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[200][200];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\ts--;g1--;g2--;\n\t\tmemset(cost,0x1f,sizeof(cost));\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);b1--;b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=LLONG_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate<typename CostType>\n/// \\brief 辺の情報\nstruct Edge{\n  int      to;\n  CostType cost;\n\n  Edge(int t, CostType c): to(t), cost(c){\n  }\n};\n\ntemplate<typename CostType>\nclass Graph{\n\nprivate:\n\n  /// \\brief adjacent_list_[n]=ノードnの隣接リストを表すvector<Edge>\n  std::vector<std::vector<Edge<CostType>>> adjacent_list_;\n\npublic:\n\n  /// \\brief 頂点数\n  const int NODE_SIZE_;\n\n  /// \\brief コンストラクタ\n  /// \\param node_size 頂点数\n  explicit Graph(const int node_size): NODE_SIZE_(node_size),\n                                       adjacent_list_(node_size){\n  }\n\n  /// \\brief 有向グラフの辺を生やす\n  /// \\param from 辺の根本の頂点の番号\n  /// \\param to 辺の先の頂点の番号\n  /// \\param cost 辺のコスト\n  void SetDirectedEdge(const int from, const int to, const CostType cost){\n    adjacent_list_[from].push_back(Edge<CostType>(to, cost));\n  }\n\n  /// \\brief 無向グラフの辺を生やす\n  /// \\param node_a 一方の頂点の番号\n  /// \\param node_b もう一方の頂点の番号\n  /// \\param cost 辺のコスト\n  void\n  SetUndirectedEdge(const int node_a, const int node_b, const CostType cost){\n    SetDirectedEdge(node_a, node_b, cost);\n    SetDirectedEdge(node_b, node_a, cost);\n  }\n\n  /// \\brief ある頂点の隣接リストを取得\n  /// \\param node_num 頂点の番号\n  /// \\return 隣接リスト\n  std::vector<Edge<CostType>> GetAdjacentList(int node_num) const{\n    return adjacent_list_[node_num];\n  }\n};\n\n/// \\brief ダイクストラ法により，ある頂点からの最短経路を求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param start_node どの頂点から最短経路を求めるか\n/// \\param INF CostType型で十分大きい値\n/// \\return グラフの各頂点への最短経路を示す配列(到達不可能なときはINF)，負の辺が入っていた場合はsize0の配列\ntemplate<typename CostType>\nstd::vector<CostType>\nDijkstra(const Graph<CostType>& graph, const int start_node, CostType INF){\n  struct Info{\n    int      node;\n    CostType cost;\n\n    Info(int n, CostType c): node(n), cost(c){\n    };\n\n    bool operator>(const Info& another) const{\n      return cost > another.cost;\n    }\n  };\n\n  std::vector<CostType>                                            min_cost\n                                                                       (graph\n                                                                            .NODE_SIZE_);\n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> pq;\n  for(int                                                          i = 0;\n      i < min_cost.size(); i++){\n    min_cost[i] = (i == start_node) ? 0 : INF;\n  }\n  pq.push(Info(start_node, 0));\n\n  while(!pq.empty()){\n    Info current_info = pq.top();\n    pq.pop();\n    if(min_cost[current_info.node] != current_info.cost){ continue; }\n    const std::vector<Edge<CostType>>\n        & adjacency_list = graph.GetAdjacentList(current_info.node);\n    for(auto e:adjacency_list){\n      if(min_cost[e.to] > min_cost[current_info.node] + e.cost){\n        min_cost[e.to] = min_cost[current_info.node] + e.cost;\n        pq.push(Info(e.to, min_cost[e.to]));\n      }\n    }\n  }\n\n  return min_cost;\n\n}\n\n/// \\brief ベルマンフォード法により，ある頂点からの最短経路を求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param start_node どの頂点から最短経路を求めるか\n/// \\param INF CostType型で十分大きい値\n/// \\return グラフの各頂点への最短経路を示す配列(到達不可能なときはINF)，負の閉路がある場合はsize0の配列\ntemplate<typename CostType>\nstd::vector<CostType>\nBellmanFord(const Graph<CostType>& graph, const int start_node, CostType INF){\n  std::vector<CostType> min_cost(graph.NODE_SIZE_);\n  for(int               i = 0; i < min_cost.size(); i++){\n    min_cost[i] = (i == start_node) ? 0 : INF;\n  }\n\n  for(int loop = 0; loop < graph.NODE_SIZE_; loop++){\n    for(int from = 0; from < graph.NODE_SIZE_; from++){\n      if(min_cost[from] == INF){ continue; }\n      std::vector<Edge<CostType>> adjacent_list = graph.GetAdjacentList(from);\n      for(auto                    e:adjacent_list){\n        CostType next_cost = min_cost[from] + e.cost;\n        if(next_cost < min_cost[e.to]){\n          if(loop == graph.NODE_SIZE_ - 1){\n            return std::vector<CostType>(0);\n          }else{\n            min_cost[e.to] = next_cost;\n          }\n        }\n      }\n    }\n  }\n\n  return min_cost;\n}\n\n/// \\brief ワーシャルフロイド法により，全点対の最小コストを求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param INF CostType型で十分大きい値\n/// \\return hoge[from][to]=from→toの最小コスト(到達できないときはINF)，\n///         負の閉路がある場合は0行の二次元配列みたいなvector\ntemplate<typename CostType>\nstd::vector<std::vector<CostType>>\nWarshallFloyd(const Graph<CostType>& graph, const CostType INF){\n  std::vector<std::vector<CostType>> min_cost;\n  for(int                            r = 0; r < graph.NODE_SIZE_; r++){\n    std::vector<CostType> rowvec;\n    for(int               c = 0; c < graph.NODE_SIZE_; c++){\n      rowvec.push_back((r == c) ? 0 : INF);\n    }\n    min_cost.push_back(rowvec);\n  }\n\n  for(int from = 0; from < graph.NODE_SIZE_; from++){\n    for(auto e:graph.GetAdjacentList(from)){\n      min_cost[from][e.to] = e.cost;\n    }\n  }\n\n  for(int k = 0; k < graph.NODE_SIZE_; k++){\n    for(int i = 0; i < graph.NODE_SIZE_; i++){\n      for(int j = 0; j < graph.NODE_SIZE_; j++){\n        if(min_cost[i][k] == INF || min_cost[k][j] == INF){ continue; }\n        min_cost[i][j] =\n            std::min(min_cost[i][j], min_cost[i][k] + min_cost[k][j]);\n      }\n    }\n  }\n\n  for(int i = 0; i < graph.NODE_SIZE_; i++){\n\n    if(min_cost[i][i] < 0){\n      std::vector<std::vector<CostType>> result(0);\n      return result;\n    }\n\n  }\n\n  return min_cost;\n}\n\nint Solve(int n,int m,int s,int g,int h){\n  Graph<int> graph(n);\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    graph.SetDirectedEdge(b1-1,b2-1,c);\n  }\n  const int INF=INT32_MAX/3;\n  std::vector<std::vector<int>>  min_cost=WarshallFloyd(graph,INF);\n  int result=INF;\n  for(int v=0;v<n;v++){\n    result=std::min(result,min_cost[s-1][v]+min_cost[v][g-1]+min_cost[v][h-1]);\n  }\n  return result;\n}\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  while(true){\n    int n,m,s,g,h;\n    cin>>n>>m>>s>>g>>h;\n    if(n==0) break;\n    cout<<Solve(n,m,s,g,h)<<endl;\n  }\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define INF 10000001\n\n#define MAX_SIZE 101\nlong long g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tfor (int k = 0; k < v; ++k) {\n\t\tfor (int i = 0; i < v; ++i) {\n\t\t\tfor (int j = 0; j < v; ++j) {\n\t\t\t\tg_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\tmemset(g_d, INF, sizeof(g_d));\n\t\tfor (int i = 0; i<MAX_SIZE; ++i) {\n\t\t\tg_d[i][i] = 0;\n\t\t}\n\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tint b1,b2;\n\t\t\tcin >> b1 >> b2;\n\t\t\t--b1; --b2;\n\t\t\tcin >> g_d[b1][b2];\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tlong long cost = INF;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n){\n\t\tint d[101][101];\n\t\trep(i, 101)rep(j, 101)d[i][j] = (i == j ? 0 : INF);\n\t\t\n\t\tvector<T> road[101][101];\n\n\t\trep(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = d[b2][b1] = c;\n\t\t\troad[b1][b2].push_back(T(b1, b2, c));\n\t\t\troad[b2][b1].push_back(T(b2, b1, c));\n\t\t}\n\n\t\tFor(k,1, n+1)For(i,1, n+1)For(j,1, n+1){\n\t\t\tif (d[i][k] + d[k][j] < INF && d[i][k] + d[k][j] <= d[i][j]){\n\t\t\t\tvector<T> tv;\n\t\t\t\trep(l, road[i][k].size())\n\t\t\t\t\ttv.push_back(road[i][k][l]);\n\t\t\t\trep(l, road[k][j].size())\n\t\t\t\t\ttv.push_back(road[k][j][l]);\n\t\t\t\troad[i][j] = tv;\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tFor(k, 1, n + 1){\n\t\t\tint tmp = 0;\n\t\t\tset<T> t;\n\t\t\trep(i, road[s][k].size())t.insert(road[s][k][i]);\n\t\t\trep(i, road[k][g1].size())t.insert(road[k][g1][i]);\n\t\t\trep(i, road[k][g2].size())t.insert(road[k][g2][i]);\n\t\t\tfor (auto i : t){\n\t\t\t\ttmp += get<2>(i);\n\t\t\t}\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#define INF 1<<29\n#define MAX 3000\nusing namespace std;\nint cost[MAX][MAX],V,d[MAX][MAX];\nbool used[MAX][MAX];\n\nvoid dijkstra(int);\n\nint main(){\n  int m,s,g1,g2,b1,b2,c;\n\n  while(true)\n    {\n      cin >> V >> m >> s >> g1 >> g2;\n      if(V == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)break;\n      for(int i=1;i<=V;i++)\n\t{\n\t  for(int j=1;j<=V;j++)\n\t    {\n\t      cost[i][j]=INF;\n\t      d[i][j] = INF;\n\t    }\n\t}\n\n\t  for(int i=0;i<m;i++)\n\t{\n\t  cin >> b1 >> b2 >> c;\n\t  cost[b1][b2]=c;\n\t}\n\n      int ans = INF;\n      //cout << ans << endl;\n      for(int i=1;i<=V;i++)\n\t{\n\t  dijkstra(i);\n\t  // cout << ans << endl;\n\t  /*cout << \"i = \" << i << endl;\n\t    for(int j=1;j<=V;j++)\n\t    {\n\t      for(int k=1;k<=V;k++)cout << d[j][k] << \" \" ;\n\t      cout << endl;\n\t    }\n\t  */\n\t}\n      for(int i=1;i<=V;i++)\n\t{\n\t  ans = min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t}\n\n      cout << ans << endl;\n    }\n}\n\nvoid dijkstra(int s)\n{\n  for(int i=1;i<=V;i++)\n    {\n\t  d[s][i]=INF;\n\t  used[s][i]=false;\n    }\n  d[s][s] = 0;\n\n  while(true)\n    {\n      int v=-1;\n      for(int u=1;u<=V;u++)\n\t{\n\t  if(!used[s][u] && (v == -1 || d[s][u] < d[s][v]))v = u;\n\t}\n      if(v == -1)break;\n      used[s][v]=true;\n      for(int u=1;u<=V;u++)\n\t{\n\t  d[s][u]=min(d[s][u],d[s][v]+cost[v][u]);\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\nusing namespace std;\n\nint n,m,a,b,c;\nint e[100][100];\n\nint main(){\n\twhile(cin>>n>>m>>a>>b>>c,n||m||a||b||c){\n\t\ta--;b--;c--;\n\t\trep(i,100)rep(j,100)e[i][j]=INF;\n\t\trep(i,100)e[i][i]=0;\n\t\trep(i,m){\n\t\t\tint p,q,t;\n\t\t\tcin>>p>>q>>t;\n\t\t\tp--;q--;\n\t\t\te[p][q]=t;\n\t\t\te[q][p]=t;\n\t\t}\n\t\trep(i,n)rep(j,n)rep(k,n)e[j][k]=min(e[j][k],e[j][i]+e[i][k]);\n\t\tint ans=INF;\n\t\trep(i,n) ans=min(ans,e[i][a]+e[i][b]+e[i][c]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n, m, s, g1, g2;\n  while(cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2){\n    s--, g1--, g2--;\n    int G[101][101];\n    const int inf = (1 << 25);\n    for(int i = 0; i < 101; i++){\n      for(int j = 0; j < 101; j++) G[i][j] = inf;\n      G[i][i] = 0;\n    }\n    while(m--){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--, b2--;\n      G[b1][b2] = c;\n    }\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tfor(int k = 0; k < n; k++){\n\t  G[j][k] = min(G[j][k], G[j][i] + G[i][k]);\n\t}\n      }\n    }\n    int ans = inf;\n    for(int i = 0; i < n; i++){\n      ans = min(ans, G[s][i]+G[i][g1]+G[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define INF (1<<20)\nint n,m,s,g1,g2;\nint G[101][101];\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2);\n    if(!n && !m && !s && !g1 && !g2) break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(i==j) G[i][j]=0;\n\telse G[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      scanf(\"%d %d %d\",&b1,&b2,&c);\n      G[b1][b2]=c;\n      G[b2][b1]=c;\n    }\n\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  G[j][k] = min(G[j][k],G[j][i]+G[i][k]);\n\n    int res = INF;\n    for(int i=1;i<=n;i++){\n      res = min(res,G[s][i]+G[i][g1]+G[i][g2]);\n      /*      printf(\"%d -> %d = %d\\n\",s,i,G[s][i]);\n      printf(\"%d -> %d = %d\\n\",i,g1,G[i][g1]);\n      printf(\"%d -> %d = %d\\n\",i,g2,G[i][g2]);*/\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define Repr(i, n, a) for (int i = (n); i >= (a); i--)\n#define rep(i, n) Rep(i, 0, n)\n#define repr(i, n) Repr(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, S, G1, G2;\n    while (1)\n    {\n        cin >> N >> M >> S >> G1 >> G2;\n        if (N == 0)\n            break;\n        S--, G1--, G2--;\n        int d[110][110];\n        rep(i, N) rep(j, N) d[i][j] = INF;\n        rep(i, N) d[i][i] = 0;\n        rep(i, M)\n        {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--, b--;\n            d[a][b] = c;\n        }\n        rep(k, N) rep(i, N) rep(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        int ans = INF;\n        rep(i, N) ans = min(ans, d[S][i] + d[i][G1] + d[i][G2]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int G[100][100];\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        s--; g1--; g2--;\n        fill(G[0],G[100],1e8);\n        for(int i=0;i<m;i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            b1--; b2--;\n            G[b1][b2]=G[b2][b1]=c;\n        }\n        for(int i=0;i<n;i++) G[i][i]=0;\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(G[i][j]>G[i][k]+G[k][j])G[i][j]=G[i][k]+G[k][j];\n                }\n            }\n        }\n        int ans=1e8;\n        for(int i=0;i<n;i++){\n            ans=min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tuple>\nusing namespace std;\ntypedef vector<int> vi;\nconst int INF=1e9;\ntypedef long long ll;\nint w,h;\nll d[105][105];\nll ans;\nint g1,g2,n,m,s;\ntemplate<typename A,size_t N,typename T>\nvoid Fill(A (&array)[N],const T &val)\n{\n  std::fill( (T*)array,(T*)(array+N),val );\n}\n\nvoid warshall_floyd()\n{\n  for(int k=1;k<=n;k++)\n    {\n      for(int i=1;i<=n;i++)\n\t{\n\t  for(int j=1;j<=n;j++)\n\t    {\n\t      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t    }\n\t}\n    }\n}\n\n\nint main(void)\n{\n  \n  while(cin >> n >> m >> s >> g1 >> g2 && n)\n    {\n      for(int i=1;i<=n;i++)\n\t{\n\t  for(int j=1;j<=n;j++)\n\t    {\n\t      d[i][j]=INF;\n\t      if(i==j) d[i][j]=0;\n\t    }\n\t}\n      for (int i = 0;i<m;i++)\n\t{\n\t  int fro,to,cost;\n\t  cin >> fro >> to >> cost;\n\t  d[fro][to]=cost;\n\t  //d[to][fro]=cost;\n\t}\n      warshall_floyd();\n      ans=INF;\n      for(int i=1;i<=n;i++)\n\t{\n\t  ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 30000\n\n#define MAX_SIZE 100\nint g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tfor (int k = 0; k < v; ++k) {\n\t\tfor (int i = 0; i < v; ++i) {\n\t\t\tfor (int j = 0; j < v; ++j) {\n\t\t\t\tg_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\tmemset(g_d, INF, sizeof(g_d));\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tg_d[i][i] = 0;\n\t\t}\n\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\t--b1; --b2;\n\t\t\tg_d[b1][b2] = c;\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tint cost = INF;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e8;\n\nint main(){\n\twhile(1){\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > adj(n+1, vector<int>(n+1, inf));\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tadj[i][i] = 0;\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint f,t,c;\n\t\t\tcin >> f >> t >> c;\n\t\t\tadj[f][t] = c;\n\t\t}\n\t\tfor(int k=1; k<=n; k++){\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=inf;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tans = min(ans, adj[s][i]+adj[i][g1]+adj[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2,hoge[101][101],a,b,c;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\thoge[i][j] = 1000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> c;\n      hoge[a][b] = c;\n      hoge[b][a] = c;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  if(hoge[j][k] > hoge[j][i] + hoge[i][k]){\n\t    hoge[j][k] = hoge[j][i] + hoge[i][k];\n\t  }\n\t}\n      }\n    }\n    int MIN=1000000;\n    for(int i=1;i<=n;i++)\n      MIN = min(MIN,hoge[s][i]+hoge[i][g1]+hoge[i][g2]);\n    cout << MIN << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919810\nusing namespace std;\n\nlong long dp[110][110];\nint n,m,s,f,g;\n\nlong long Min(long long a,long long b){\n\tif(a>b)return b;\n\treturn a;\n}\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j]=Min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tlong long ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=Min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=100000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=1000000;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[111][111];\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\troad[i][j]=INF;\n      }\n      road[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=1;k<=n;k++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=1;i<=n;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nvoid func(int N,int M,int Start,int Goal_1,int Goal_2){\n\n\tint dist[N+1][N+1];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(i != k){\n\t\t\t\tdist[i][k] = BIG_NUM;\n\t\t\t}else{\n\t\t\t\tdist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint from,to,cost;\n\n\tfor(int i = 0;i < M; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\t\tdist[from][to] = cost;\n\t}\n\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int k = 1; k <= N; k++){\n\t\t\tif(dist[k][i] == BIG_NUM)continue;\n\t\t\tfor(int p = 1; p <= N; p++){\n\t\t\t\tif(dist[i][p] == BIG_NUM)continue;\n\t\t\t\tdist[k][p] = min(dist[k][p],dist[k][i]+dist[i][p]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = dist[Start][Goal_1]+dist[Start][Goal_2];\n\n\tfor(int i = 1; i <= N; i++){\n\t\tif(dist[Start][i] == BIG_NUM || dist[i][Goal_1] == BIG_NUM || dist[i][Goal_2] == BIG_NUM)continue;\n\t\tans = min(ans,dist[Start][i]+dist[i][Goal_1]+dist[i][Goal_2]);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tint N,M,Start,Goal_1,Goal_2;\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&Start,&Goal_1,&Goal_2);\n\t\tif(N == 0 && M == 0 && Start == 0 && Goal_1 == 0 && Goal_2 == 0)break;\n\n\t\tfunc(N,M,Start,Goal_1,Goal_2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\n/*\n  n m s g1 g2\n  a b c\n  ...\n  am bm cm\n  0 0 0 0 0\n  */\n\nint n,m,s,g1,g2;\nint edge[128][128];\nint main(){\n  while(cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2){\n    s--; g1--; g2--;\n    //init\n    rep(i,128)rep(j,128)edge[i][j]=INT_MAX;\n    rep(i,128)edge[i][i]=0;\n\n    // input\n    rep(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      edge[a-1][b-1]=c;\n    }\n\n    // í[µáéÓë¢Ç\n    rep(k,n){\n      rep(i,n){\n        rep(j,n){\n          if( edge[i][k]!=INT_MAX && edge[k][j]!=INT_MAX ){\n            edge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n          }\n        }\n      }\n    }\n\n    int ans = INT_MAX;\n    rep(k,n){\n      if( k==g1 ){\n        if( edge[s][g1]!=INT_MAX && edge[g1][g2]!=INT_MAX ){\n          ans = min(ans, edge[s][g1]+edge[g1][g2]);\n        }\n      }else if( k==g2 ){\n        if( edge[s][g2]!=INT_MAX && edge[g2][g1]!=INT_MAX ){\n          ans = min(ans, edge[s][g2]+edge[g2][g1]);\n        }\n      }else{\n        if( edge[s][k]!=INT_MAX && edge[k][g1]!=INT_MAX && edge[k][g2]!=INT_MAX ){\n          ans = min(ans, edge[s][k]+edge[k][g1]+edge[k][g2]);\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nrandom_device rnd;\nmt19937 mt(rnd());\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nconst int IINF = 1 << 26;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1000000007;\n\nvector<int> djikstra(map<int, vector<pair<int, int>>> &g, int s, int n)\n{\n    vector<int> ret(n, IINF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, s});\n    while (!pq.empty())\n    {\n        auto pos = pq.top().second;\n        auto cost = pq.top().first;\n        pq.pop();\n        if (ret[pos] <= cost)\n        {\n            continue;\n        }\n        ret[pos] = cost;\n        for (auto &&x : g[pos])\n        {\n\n            pq.push({cost + x.second, x.first});\n        }\n    }\n    return ret;\n}\n\nvoid solve(int n, int m, int s, int g1, int g2)\n{\n    map<int, vector<pair<int, int>>> gf, gb;\n    rep(i, m)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        gf[a].push_back({b, c});\n        gb[b].push_back({a, c});\n    }\n    auto ds = djikstra(gf, s, n);\n    auto dg1 = djikstra(gb, g1, n);\n    auto dg2 = djikstra(gb, g2, n);\n    int ans = IINF;\n    rep(i, n)\n    {\n        chmin(ans, ds[i] + dg1[i] + dg2[i]);\n    }\n    cout << ans << endl;\n}\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n)\n    {\n        s--;\n        g1--;\n        g2--;\n        solve(n, m, s, g1, g2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\nclass Edge\n{\n\tpublic:\n\tint to,cost;\n\tEdge(int t,int c)\n\t{\n\t\tto=t;cost=c;\n\t}\n};\nvector<Edge> g[100];\nint dist[100][100];//i...始点\n\nvoid dijk(int s,int mode)\n{\n\tdist[mode][s]=0;\n\tpriority_queue<P,vector<P>,greater<P>> q;\n\tq.push(P(0,s));\n\twhile(!q.empty())\n\t{\n\t\tP p=q.top();q.pop();\n\t\tif(p.first>dist[mode][p.second])\n\t\t\tcontinue;\n\t\tfor(int i=0;i<g[p.second].size();i++)\n\t\t{\n\t\t\tEdge e=g[p.second][i];\n\t\t\tif(dist[mode][e.to]>dist[mode][p.second]+e.cost)\n\t\t\t{\n\t\t\t\tdist[mode][e.to]=dist[mode][p.second]+e.cost;\n\t\t\t\tq.push(P(dist[mode][e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint n,m,s,g1,g2;\n\twhile(1)\n\t{\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tfor(int i=0;i<100;i++)\n\t\t\tg[i].clear();\n\t\t\n\t\tfill(dist[0],dist[100],1e8-1);\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tg[a].push_back(Edge(b,c));\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tdijk(i,i);\n\t\tint ans=1e8-1;\n\t\t//どこまで共通で通るかを定める\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans=min(ans,dist[s][i]+dist[i][g1]+dist[i][g2]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint wf[100][100];\n\tint n,m,g1,g2,s,a,b,c;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n){\n\t\tint ret = (1<<21);\n\t\ts--;g1--;g2--;\n\t\trep(i,100)rep(j,100)wf[i][j]=(1<<26);\n\t\trep(i,100)wf[i][i]=0;\n\t\trep(i,m){\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;b--;\n\t\t\twf[a][b] = c;\n\t\t}\n\t\t\n\t\trep(i,n)rep(j,n)rep(k,n)\n\t\t\twf[i][k] = min(wf[i][k],wf[i][j]+wf[j][k]);\n\t\t\t\n\t\trep(j,n)\n\t\t\tret = min(ret,wf[s][j]+wf[j][g1]+wf[j][g2]);\n\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e8\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n    int i,j,k;\n    int n,m,s,g1,g2;\n    int v[100][100];\n    while(cin >> n >> m >> s >> g1 >> g2, n){\n        s--;g1--;g2--;\n        rep(i,n)rep(j,n){\n            if(i == j) v[i][j] = 0;\n            else v[i][j] = INF;\n        }\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v[a][b] = c;\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n        }\n        int ans = INF;\n\n        rep(i,n){\n            if(v[s][i] < INF && v[i][g1] < INF && v[i][g2] < INF){\n                //cout << i << \" \" << v[s][i] + v[i][g1] + v[i][g2] << endl;\n                if(ans > v[s][i] + v[i][g1] + v[i][g2]){\n                    ans = v[s][i] + v[i][g1] + v[i][g2];\n                    //cout << i << \" \" << ans << endl;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NODE (100)\n#define INF (100000000)\n\nint cost[NODE][NODE];\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nint main(void)\n{\n\tint i, j, k;\n\tint n;\n\tint from, to, m, s;\n    int g1, g2;\n    int V;\n    int ans;\n    \n\twhile (1){\n\t\tscanf(\"%d%d%d%d%d\", &V, &n, &s, &g1, &g2);\n\t\t\n        if (V + n + s + g1 + g2 == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n        s--;\n        g1--;\n        g2--;\n        \n\t\tfor (i = 0; i < V; i++){\n\t\t\tfor (j = 0; j < V; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t\tcost[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile (n-- != 0){\n\t\t\tscanf(\"%d%d%d\", &from, &to, &m);\n\t\t\tcost[from - 1][to - 1] = m;\n\t\t}\n        \n        ans = INF;\n\t\tfor (k = 0; k < V; k++){\n            for (i = 0; i < V; i++){\n                for (j = 0; j < V; j++){\n                    cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n                }\n            }\n        }\n        \n\t\tfor (i = 0; i < V; i++){\n\t\t\tans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 214748360\n\nint main(){\n  int n,m,s,p,q;\n  while(cin>>n>>m>>s>>p>>q, n){\n    s--;p--;q--;\n    vector<vector<int>> d(n, vector<int>(n, INF));\n    rep(i,m){\n      int a,b,c;\n      cin>>a>>b>>c;\n      a--;b--;\n      d[a][b] = c;\n    }\n    rep(i,n) d[i][i] = 0;\n    rep(k,n)rep(i,n)rep(j,n) d[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\n    int res = INF;\n    rep(i,n) res = min(res, d[s][i]+d[i][p]+d[i][q]);\n\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\n\nint d[MAX_N][MAX_N];\nint n,m,s,g1,g2;\n\nvoid warshall_floyd()\n{\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        s--,g1--,g2--;\n        if(n==0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = INF;\n            }\n        }\n        rep(i,n){\n            d[i][i] = 0;\n        }\n    \trep(i,m){\n    \t\tint x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            d[x-1][y-1] = z;\n    \t}\n        warshall_floyd();\n        ll res = (1LL << 60);\n        rep(i,n){\n            res = min(res,(ll)d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        printf(\"%lld\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint n, m, s, g1, g2;\nint cost[110][110];\n\nvoid solve() {\n\tfor_(i,0,n) fill(cost[i], cost[i] + n, iINF / 2);\n\t\n\tfor_(i,0,m) {\n\t\tint v, u, c; cin >> v >> u >> c;\n\t\t--v; --u;\n\t\tcost[v][u] = cost[u][v] = c;\n\t}\n\t\n\tfor_(k,0,n) for_(i,0,n) for_(j,0,n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\n\tint ans = iINF;\n\t\n\tfor_(k,0,n) {\n\t\tans = min(ans, cost[s][k] + cost[g1][k] + cost[g2][k]);\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\t--s; --g1; --g2;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[102][102];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                if(i == j) road[i][j] = 0;\n                else road[i][j] = 100000000;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int k = 1; k < n + 1; k++){\n            for(int i = 1; i < n + 1; i++){\n                for(int j = 1; j < n + 1; j++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 100000000;\n        for(int i = 1; i < n + 1; i++){\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n    int G[100][100];\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        s--; g1--; g2--;\n        fill(G[0],G[100],1000000);\n        for(int i=0;i<m;i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            b1--; b2--;\n            G[b1][b2]=c;\n        }\n        for(int i=0;i<n;i++) G[i][i]=0;\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(G[i][j]>G[i][k]+G[k][j])G[i][j]=G[i][k]+G[k][j];\n                }\n            }\n        }\n        int ans=1000000;\n        for(int i=0;i<n;i++){\n            ans=min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nll d[110][110];\nsigned main(void)\n{\n\twhile(true) {\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(!n &&!m && !s && !g1 && !g2) break;\n\t\ts--, g1--, g2--;\n\t\tREP(i, n) REP(j, n) d[i][j] = INF;\n\t\tREP(i, n) d[i][i] = 0;\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\td[a-1][b-1] = c;\n\t\t}\n\n\t\tREP(k, n) REP(i, n) REP(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tll ret = INF;\n\t\tREP(i, n) {\n\t\t\t//cout << \"i:\" << i << \" \" << ret << \" \" << d[s][i] << \" \" << d[i][g1] << \" \" << \" \" << d[i][g2] << endl;\n\t\t\tret = min(ret, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<20)\n\nstruct edge {\n\tint from;\n\tint to;\n\tint cost;\n\tedge() {}\n\tedge(int from, int to, int cost) :from(from), to(to), cost(cost) {}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n | m || s | g1 | g2) {\n\t\tn; m; s--; g1--; g2--;\n\t\tvector<vector<edge>> Graph(n);\n\t\tvector<vector<int>> dist(n, vector<int>(n, INF));\n\t\tfor (int i = 0; i < m;i++) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tGraph[b1].push_back(edge(b1, b2, c));\n\t\t}\n\n\t\tfor (int v_s = 0; v_s < n; v_s++) {\n\t\t\tqueue<int> q; q.push(v_s);\n\t\t\tdist[v_s][v_s] = 0;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint now = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < Graph[v_s].size();i++) {\n\t\t\t\t\tint next = Graph[v_s][i].to;\n\t\t\t\t\tint cost = Graph[v_s][i].cost;\n\n\t\t\t\t\tif (dist[v_s][next] > dist[v_s][now] + cost) {\n\t\t\t\t\t\tdist[v_s][next] = dist[v_s][now] + cost;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){ break; }\n\t\t--s; --g1; --g2;\n\t\tvector< vector<int> > matrix(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\t--b1; --b2;\n\t\t\tmatrix[b1][b2] = min(matrix[b1][b2], c);\n\t\t}\n\t\tfor(int i = 0; i < n; ++i){ matrix[i][i] = 0; }\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif(matrix[i][k] + matrix[k][j] < matrix[i][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = INF;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tanswer = min(\n\t\t\t\tanswer, matrix[s][i] + matrix[i][g1] + matrix[i][g2]);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n    const int max=1e9+7;\n    int n,m,s,go,gt;\n    cin>>n>>m>>s>>go>>gt;\n    if(n==0 && m==0){break;}\n    s--; go--; gt--;\n    int a[1000][1000];\n    fill(&a[0][0],&a[999][1000],max);\n    for(int i=0;i<n;i++){\n        a[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        int b,c,d;\n        cin>>b>>c>>d;\n        a[b-1][c-1]=d;\n    }\n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int k=0;k<n;k++){\n                a[t][k]=min(a[t][i]+a[i][k],a[t][k]);\n            }\n        }\n    }\n    int ans=max;\n    for(int i=0;i<n;i++){\n        ans=min(a[s][i]+a[i][go]+a[i][gt],ans);\n    }\n    assert(ans!=max);\n    cout<<ans<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) && n!=0) {\n\t\tvvi cost(n,vi(n,INT_MAX/10));\n\t\tREP(i,n){\n\t\t\tcost[i][i]=0;\n\t\t}\n\n\t\tREP(i, m) {\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\n\t\t\tcost[b1-1][b2-1] = c;\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint minCost=INT_MAX;\n\t\tFOR(i, 0, n) {\n\t\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t\t}\n\n\t\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_N = 100;\nconstexpr int INF = (1 << 29);\nint dist[MAX_N][MAX_N];\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2 && n;) {\n\t\t--s; --g1; --g2;\n\t\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INF);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tdist[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tdist[from - 1][to - 1] = cost;\n\t\t}\n\n\t\tfor(int k = 0; k < n; ++k) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\t\tchmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tchmin(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\n\t\tassert(ans != INF);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(void)\n{\n\tint n, m, s, g1, g2;\n\tint data[128][128];\n\tint a, b, c;\n\t\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n && m){\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tif (i == j) data[i][j] = 0;\n\t\t\t\telse data[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tdata[a][b] = c;\n\t\t}\n\t\t\n\t\t// わーしゃるふろいど\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tfor (int j = 1; j <= n; j++){\n\t\t\t\tfor (int k = 1; k <= n; k++){\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = data[s][g1] + data[s][g2];\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tret = min(ret, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nconst int inf = 1e6;\n\nint n, m, s, x, y;\nint g[100][100];\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\trep(i, n){\n\t\t\trep(j, n){\n\t\t\t\tg[i][j] = inf;\n\t\t\t}\n\t\t\tg[i][i] = 0;\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &m, &s, &x, &y);\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tg[a - 1][b - 1] = c;\n\t\t}\n\t\trep(k, n){\n\t\t\trep(i, n){\n\t\t\t\trep(j, n){\n\t\t\t\t\tg[i][j] = min(g[i][k] + g[k][j], g[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\trep(i, n){\n\t\t\tans = min(g[s - 1][i] + g[i][x - 1] + g[i][y - 1], ans);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n  int prev[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n    fill(prev, prev + V, -1);\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n          prev[e.to] = v;\n        }\n      }\n    }\n\n    return d;\n  }\n\n  vector<int> GetPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prev[t]) {\n      path.push_back(t);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n + m + s + g1 + g2 == 0) {\n      break;\n    }\n    s--; g1--; g2--;\n    Dijkstra dijkstra(n);\n    for (int i = 0; i < m; i++) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      dijkstra.AddEdge(b1, b2, c);\n      dijkstra.AddEdge(b2, b1, c);\n    }\n\n\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      ans = min(ans, d[s] + d[g1] + d[g2]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n){\n\t\tvector<vector<int>> load(n + 1, vector<int>(n + 1, 1000000000));//from back to \n\t\tREP(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tload[b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n + 1){\n\t\t\tFOR(j, 1, n + 1){\n\t\t\t\tFOR(k, 1, n + 1){\n\t\t\t\t\tload[j][k] = min(load[j][k], load[j][i] + load[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\tFOR(i, 1, n + 1){\n\t\t\tans = min(ans,load[s][i]+load[i][g1]+load[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint main(void){\n\tint32 n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 && n+m+s+g1+g2){\n\t\tint32 d[110][110];\n\t\tREP(j, n){\n\t\t\tREP(k, n) d[j][k] = INF;\n\t\t\td[j][j] = 0;\n\t\t}\n\t\tREP(i, m){\n\t\t\tint32 u, v, c;\n\t\t\tcin >> u >> v >> c; u--; v--;\n\t\t\td[u][v] = d[v][u] = c;\n\t\t}\n\t\tREP(k, n){\n\t\t\tREP(i, n){\n\t\t\t\tREP(j, n){\n\t\t\t\t\tif(d[i][j] > d[i][k]+d[k][j]) d[i][j] = d[i][k]+d[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint32 res = INF;\n\t\ts--; g1--; g2--;\n\t\tREP(i, n){\n\t\t\tres = min(res, d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dst, cost; \n    edge(int s, int t, int c): src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost > rhs.cost;}\n};\n\nconst int INF = 1e8;\n\nvoid bellman_ford(const vector<edge> &edges, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    for(auto &i : d) {\n        for(auto &e : edges) {\n            d[e.dst] = min(d[e.dst], d[e.src] + e.cost);\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<edge> edges;\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges.push_back(edge(b1-1, b2-1, c));\n        }\n        REP(i, n) {\n            bellman_ford(edges, d[i], i);\n        }\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1<<21\nusing namespace std;\nint d[128][128];\nint N, M;\n\nvoid warshall_floyd(){\n  for (int k = 0; k < N; k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\nint main()\n{\n  while(1){\n    int s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n\n    if (!N&&!M&&!s&&!g1&&!g2) break;   \n\n    for (int i = 0; i < N; i++){\n      fill_n(d[i], N, INF);\n    }\n    for (int i = 0; i < M; i++){\n      int u, v, c;\n      cin >> u >> v >> c;\n      d[u][v] = c;\n    }\n    warshall_floyd();\n    int res = INF;\n    for (int i = 0; i < N; i++){\n      res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nlong long d[100][100];\n\nvoid warshall_floyd(int V){\n  rep(i,V){\n    d[i][i] = 0;\n  }\n  rep(i,V){\n      rep(j,V){\n          rep(k,V){\n              d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n          }\n      }\n  }\n}\n\nint main(){\n  while(1){\n    int n,m,s,g1,g2,from,to,cost,minn=1e9;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0)break;\n    s--;g1--;g2--;\n    rep(i,n){rep(j,n){d[i][j]=1e9;}}\n    rep(i,m){\n      cin >> from >> to >> cost;\n      from--;to--;\n      d[from][to] = cost;\n    }\n    rep(i,n)if (minn>d[s][i]+d[i][g1]+d[i][g2]) minn=d[s][i]+d[i][g1]+d[i][g2];\n    cout << minn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<cstring>\nusing namespace std;\n#define INF 1000000000\nint route[101][101];\nint d[101];//スタートからの距離\nint d2[101];//分岐からの距離\nint n,m;\nint min(int a,int b){\n    if(a<b){\n        return a;\n    }else{\n        return b;\n    }\n}\nint di(int st){\n    int s[101],k,num,i,j;\n    for(i=0;i<101;i++){\n        s[i]=0;\n        d[i]=INF;\n    }\n    d[st]=0;\n    for(i=0;i<101;i++){\n        k=INF;\n        for(j=0;j<=n;j++){\n            if(s[j]==0){\n                if(k>d[j]){\n                    k=d[j];num=j;\n                }\n            }\n        }\n\t\ts[num]=1;\n        for(j=0;j<=n;j++){\n            if(route[num][j]!=INF){\n\t\t\t\td[j]=min(d[j],d[num]+route[num][j]);\n\t\t\t}\n        }\n    }\n    return 0;\n}\nint di2(int st){\n    int s[101],k,num,i,j;\n    for(i=0;i<101;i++){\n        s[i]=0;\n        d2[i]=INF;\n    }\n    d2[st]=0;\n    for(i=0;i<101;i++){\n        k=INF;\n        for(j=0;j<=n;j++){\n            if(s[j]==0){\n                if(k>d2[j]){\n                    k=d2[j];num=j;\n                }\n            }\n        }\n\t\ts[num]=1;\n\t\tfor(j=0;j<=n;j++){\n\t        if(route[num][j]!=INF){\n\t\t\t\t\td2[j]=min(d2[j],d2[num]+route[num][j]);\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}\nint main(){\n\twhile(1){\n\t\tint a,b,c,s,g1,g2,i,j,gr1[101],gr2[101],sum=0;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=n;j++){\n\t\t\t\troute[i][j]=INF;\n\t\t\t}\n\t\t\troute[i][i]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\troute[a][b]=c;\n\t\t}\n\t\tdi(s);//スタートからの距離をダイクストラでd[]\n\t\tsum=d[g1]+d[g2];\n\t\tfor(i=1;i<=n;i++){\n\t\t\tdi2(i);//点をひとつ選んで、分岐にする。その分岐からの距離がd2[]\n\t\t\tsum=min(sum,d[i]+d2[g1]+d2[g2]);\t\n\t\t}\t\t\n\t\tcout<<sum<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint V, E, S, G1, G2, B1, B2, C;\n\nvector<vector<int> > G;\n\nvector<vector<int> > R;\n\nvoid Shortest(int s, int mode, int rev)\n{\n\tvector<bool> u(V, false); R[mode][s] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1, c = 99999999;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i] && R[mode][i] < c)\n\t\t\t{\n\t\t\t\tc = R[mode][i]; v = i;\n\t\t\t}\n\t\t}\n\n\t\tif (c == 99999999) { break; }\n\n\t\tu[v] = true;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[v])\n\t\t\t{\n\t\t\t\tif (R[mode][i] > R[mode][v] + (rev ? G[i][v] : G[v][i]))\n\t\t\t\t{\n\t\t\t\t\tR[mode][i] = R[mode][v] + (rev ? G[i][v] : G[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint V, E, S, G1, G2, B1, B2, C;\n\n\twhile (true)\n\t{\n\t\tcin >> V >> E >> S >> G1 >> G2;\n\n\t\tif (V == 0) { break; }\n\n\t\tG = vector<vector<int> >(V, vector<int>(V, 99999999));\n\n\t\tfor (int i = 0; i < E; i++)\n\t\t{\n\t\t\tcin >> B1 >> B2 >> C;\n\n\t\t\tG[B1 - 1][B2 - 1] = C;\n\t\t}\n\t\t\n\t\tR = vector<vector<int> >(3, vector<int>(V, 99999999));\n\n\t\tShortest(S, 0, 0);\n\t\tShortest(G1, 1, 1);\n\t\tShortest(G2, 2, 1);\n\n\t\tint ret = 299999997;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tret = min(ret, R[0][i] + R[1][i] + R[2][i]);\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint main(){\n\tint n,m,s,a,b;\n\twhile(cin>>n>>m>>s>>a>>b,n){\n\t\ts--; a--; b--;\n\t\tvvi f(n,vi(n,INF));\n\t\trep(i,n)f[i][i]=0;\n\t\t\n\t\trep(i,m){\n\t\t\tint p,q,c;\n\t\t\tcin>>p>>q>>c;\n\t\t\tp--; q--;\n\t\t\tf[p][q]=c;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tf[i][j]=min(f[i][j],f[i][k]+f[k][j]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\trep(i,n){\n\t\t\tans=min(ans,f[s][i]+f[i][a]+f[i][b]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint d[105][105];\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ) ){\n\t\tif (n == 0 ) break;\n\t\ts--; g1--; g2--;\n\t\trep (i, n ) rep (j, n ) d[i][j] = (i != j ? INF: 0 );\n\t\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\td[from][to] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\n\t\twarshall_floyd (n );\n\n\t\trep (i, n ){\n\t\t\tint curr = d[s][i] + d[i][g1] + d[i][g2];\n\t\t\tres = min (res, curr );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define INF 1000000000000\ntypedef long long LL;\nint n,m,s,g1,g2;\nLL d[101][101];\n\nint main(){\n    while(cin>>n>>m>>s>>g1>>g2,n+m+s+g1+g2){\n        s--;g1--;g2--;\n        REP(i,101){\n            REP(j,101){\n                d[i][j]=INF;\n            }\n            d[i][i]=0;\n        }\n        REP(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            d[a][b]=c;\n            //d[b][a]=c;\n        }\n        REP(k,n){\n            REP(i,n){\n                REP(j,n){\n                    d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        LL ans=1e12;\n        REP(i,n){\n            ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 99999;\n\nint main()\n{\n\tint n, m, s, t, u, a[101][101], p, q, v;\n\t\n\twhile(cin>>n>>m>>s>>t>>u&&n){\n\t\tfill(&a[0][0], &a[n][n], inf);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile(m--){\n\t\t\tcin >> p >> q >> v;\n\t\t\ta[p][q] = a[q][p] = v;\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\ta[i][j] = min(a[i][j], a[i][k]+a[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tm = inf;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tm = min(m, a[i][s]+a[i][t]+a[i][u]);\n\t\t}\n\t\t\n\t\tcout << m << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=INT_MAX;\nconst int MAX_V=200;\nint main(){\n\n  for(;;){\n  int v,m,s[3];\n  cin>>v>>m;\n  for(int i=0;i<3;i++) cin>>s[i];\n  s[0]--;\n  s[1]--;\n  s[2]--;\n\n  if(!v) break;\n\n  int G[MAX_V][MAX_V]={};\n  for(int i=0;i<v;i++) for(int j=0;j<v;j++) G[i][j]=1e9;\n  for(int i=0;i<v;i++) G[i][i]=0;\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--,b2--;\n    G[b1][b2]=c;\n    G[b2][b1]=c;\n  }\n\n  for(int k=0;k<v;k++)\n    for(int i=0;i<v;i++)\n      for(int j=0;j<v;j++) G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  int r=1e9;\n\n  for(int i=0;i<v;i++) r=min(r,G[i][s[0]]+G[i][s[1]]+G[i][s[2]]);\n\n\n  cout<<r<<endl;\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n//#include <stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n#include<fstream>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[5] = { 0,0,1,-1,0 };\nint dx[5] = { 1,-1,0,0,0 };\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tlong long int n, m, s, g1, g2;\n\t\tlong long int mini = LINF;\n\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlong long int d[101][101];\n\t\tFOR(i, 0, 100) {\n\t\t\tFOR(j, 0, 100) {\n\t\t\t\td[i][j] = LINF;\n\t\t\t\tif (i == j) {\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong long int a, b, c;\n\t\tFOR(i, 1, m) {\n\t\t\tcin >> a >> b >> c;\n\t\t\td[a][b] = c;\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tFOR(j, 1, n) {\n\t\t\t\tFOR(k, 1, n) {\n\t\t\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tFOR(i, 1, n) {\n\t\t\tmini = min(mini, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tcout << mini << endl;\n\n\n\n\n\t}\n\n\n\n\t\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=305,INF=1<<28;\nint dis[MAX][MAX];\nint N;\n\nvoid floyd(){\n    for(int k=0;k<N;k++){\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>N;\n        if(N==0) break;\n        int M,A,B,C;cin>>M>>A>>B>>C;\n        A--;\n        B--;\n        C--;\n        \n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++) dis[i][j]=INF;\n            dis[i][i]=0;\n        }\n        \n        for(int i=0;i<M;i++){\n            int a,b,c;cin>>a>>b>>c;\n            a--;b--;\n            dis[a][b]=c;\n        }\n        \n        floyd();\n        \n        int ans=INF;\n        \n        for(int i=0;i<N;i++){\n            ans=min(ans,dis[A][i]+dis[i][B]+dis[i][C]);\n        }\n        \n        cout<<ans<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 127, sizeof(z));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t\tx[b][a] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n ,m, s, g[2];\nint road[105][105], p[105];\n\nint main() {\n  while(1){\n    cin>>n>>m>>s>>g[0]>>g[1];\n    if(n==0) break;\n    s--; g[0]--; g[1]--;\n    REP(i,0,n)REP(j,0,n){\n      if(i==j) road[i][j] = 0;\n      else road[i][j] = INF;\n    }\n    REP(i,0,m){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      b1--; b2--;\n      road[b1][b2] = c;\n    }\n\n    //WF\n    REP(k,0,n){\n      REP(from,0,n){\n        REP(to,0,n){\n          road[from][to] = min(road[from][to], road[from][k]+road[k][to]);\n        }\n      }\n    }\n    vector<int> v;\n    int tm = INF;\n    REP(k,0,n) tm = min(tm,road[k][g[0]]+road[k][g[1]]);\n    REP(k,0,n){\n      if(road[k][g[0]]+road[k][g[1]] == tm) v.push_back(k);\n    }\n    int ans = INF;\n    REP(i,0,v.size()){\n      ans = min(ans, road[s][v[i]] + tm/*road[v[i]][g[0]] + road[v[i]][g[1]]*/);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nbool used[128];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tfill_n(res, 3, INF);\n\tif (used[v])\n\t\treturn;\n\t\n/*\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(res, res + 3, dp[v]);\n\t\treturn;\n\t}\n\telse */if (v == g1)\n\t{\n\t\tres[0] = 0;\n\t\treturn;\n\t}\n\telse if (v == g2)\n\t{\n\t\tres[1] = 0;\n\t\treturn;\n\t}\n\n\tused[v] = true;\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tused[v] = false;\n\tmin_swap(res[2], res[0] + res[1]);\n\n\t//copy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 9999999\n\nusing namespace std;\n\nint n, d[101][101];\n\nvoid warshall_floyd(void){\n\n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n}\n\n \nint main(void){\n\n    int m, s, g1, g2, b1, b2, c;\n\n    while(cin >> n >> m >> s >> g1 >> g2 ){\n      if( n == m && m == s && s == g1 && g1 == g2 && g2 == 0 ) break;\n\n        for( int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for( int i = 0; i < m; i++ ){\n\t  cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n\n\twarshall_floyd();\n                  \n        int ans = INF;\n        for( int i = 1; i <= n; i++ ){\n            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1e8\n\nint main(){\n\tint n,m,s,a,b;\n\twhile(cin>>n>>m>>s>>a>>b,n){\n\t\ts--; a--; b--;\n\t\tvvi f(n,vi(n,INF));\n\t\trep(i,n)f[i][i]=0;\n\t\t\n\t\trep(i,m){\n\t\t\tint p,q,c;\n\t\t\tcin>>p>>q>>c;\n\t\t\tp--; q--;\n\t\t\tf[p][q]=c;\n\t\t}\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tf[i][j]=min(f[i][j],f[i][k]+f[k][j]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\trep(i,n){\n\t\t\tans=min(ans,f[s][i]+f[i][a]+f[i][b]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main ()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n + m + s + g1 + g2) {\n        vector<vector<int> > d(n + 1, vector<int>(n + 1, INF));\n        for (int i = 0; i <= n; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int gx, gy, c;\n            cin >> gx >> gy >> c;\n            d[gx][gy] = d[gy][gx] = c;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int  k = 1; k <= n; k++) {\n                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < n; i++) {\n            if (i == s || i == g1 || i == g2) continue;\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 110;\nconst int INF = 1e9;\n\nint n, m, s, g1, g2;\nint cost[MAX_V][MAX_V];\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++)\n    for(int j = 0 ; j < MAX_V ; j++) cost[i][j] = INF;\n}\n\nvoid wf(){\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }    \n}\n\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n    init();\n    s--, g1--, g2--;\n    int from, to, C;\n    for(int i = 0 ; i < m ; i++){\n      cin >> from >> to >> C;\n      cost[from-1][to-1] = C;\n      cost[to-1][from-1] = C;\n    }\n    \n    wf();\n        \n    int ans = INF;\n    for(int i = 0 ; i < n ; i++){\n      ans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n, m, s, g1, g2;\n\t\tint cost[101][101];\n\t\tcin >> n >> m >> s >> g1 >> g2; if (!n)break;\n\t\tFOR(i, 101)FOR(j, 101)cost[i][j] = INF;\n\t\tFOR(i, 101)cost[i][i] = 0;\n\t\tFOR(i, m)\n\t\t{\n\t\t\tint l, r, c;\n\t\t\tcin >> l >> r >> c;\n\t\t\tcost[l][r] = c;\n\t\t}\n\n\t\tFOR(k, n + 1)\n\t\t{\n\t\t\tFOR(i, n + 1)\n\t\t\t{\n\t\t\t\tFOR(j, n + 1)\n\t\t\t\t{\n\t\t\t\t\tif (cost[i][k] == INF || cost[k][j] == INF)continue;\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tFOR(k, n + 1)\n\t\t{\n\t\t\tans = min({ ans, cost[s][k] + cost[k][g1] + cost[k][g2],cost[s][k]+cost[k][g1]+cost[g1][g2],cost[s][k]+cost[k][g2]+cost[g2][g1] });\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define INF (1<<29)\nint n,m,s,g1,g2;\nint G[102][102];\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2);\n    if(!n && !m && !s && !g1 && !g2) break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(i==j) G[i][j]=0;\n\telse G[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      scanf(\"%d %d %d\",&b1,&b2,&c);\n      G[b1][b2]=c;\n      //      G[b2][b1]=c;\n    }\n\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  G[j][k] = min(G[j][k],G[j][i]+G[i][k]);\n\n    int res = INF;\n    for(int i=1;i<=n;i++){\n      res = min(res,G[s][i]+G[i][g1]+G[i][g2]);\n      /*      printf(\"%d -> %d = %d\\n\",s,i,G[s][i]);\n      printf(\"%d -> %d = %d\\n\",i,g1,G[i][g1]);\n      printf(\"%d -> %d = %d\\n\",i,g2,G[i][g2]);\n      puts(\"\");*/\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost<b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=100000000;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint dist[101];\n\t\t\tfor(int j=0;j<101;j++)\n\t\t\t\tdist[j]=100000000;\n\n\t\t\tpriority_queue<state> Q;\n\t\t\tQ.push(state(i,0));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate t=Q.top();\n//\t\t\t\tcout<<t.now<<\" \"<<t.cost<<endl;\n\t\t\t\tQ.pop();\n\t\t\t\tif(dist[t.now]<t.cost) continue;\n\t\t\t\tdist[t.now]=t.cost;\n\t\t\t\tfor(int k=0;k<E[t.now].size();k++){\n\t\t\t\t\tQ.push(state(E[t.now][k].to,t.cost+E[t.now][k].cost));\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout<<dist[s]<<\" \"<<dist[g1]<<\" \"<<dist[g2]<<endl;\n\t\t\tans=min(ans,dist[s]+dist[g1]+dist[g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\tg1--; g2--; s--;\n\t\tvector<vector<int> >d(n, vector<int>(n, INF));\n\t\trep(i, 0, n)d[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c; b1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\trep(k, 0, n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 99999999\n\n\nint main(){\n    int edge[110][110];\n    rep(i,110)rep(j,110)edge[i][j]=INF;\n    rep(i,110)edge[i][i]=0;\n    int v,e,s,g1,g2;\n    while(cin>>v>>e>>s>>g1>>g2&&v&&e&&s&&g1&&g2){\n        s--,g1--,g2--;\n        rep(i,e){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--,b--;\n            edge[a][b]=c;\n        }\n        \n        \n        rep(k,v){\n            rep(i,v){\n                rep(j,v){\n                    edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n                }\n            }\n        }\n        int mini=INF;\n        rep(i,v){\n            mini = min(edge[s][i]+edge[i][g1]+edge[i][g2],mini);\n        }\n        cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,a) for (int i = 0; i < (a); i++)\nusing namespace std;\nint const INF = 1 << 28;\nint n, m, s, g1, g2, b1, b2, c;\nint G[101][101];\n\nint main(void){\n    while (cin >> n >> m >> s >> g1 >> g2, n) {\n        s--, g1--, g2--;\n        rep(i, 101) rep(j, 101) G[i][j] = (i == j ? 0:INF);\n        rep(i, m) {\n            cin >> b1 >> b2 >> c;\n            G[b1-1][b2-1] = c;\n        }\n        rep(k, n) rep(i, n) rep(j, n) G[i][j] = min(G[i][j], G[i][k]+G[k][j]);\n        int ans = INF;\n        rep(i, n) {\n            ans = min(ans, G[s][i]+G[i][g1]+G[i][g2]);\n            ans = min(ans, G[s][i]+G[i][g1]+G[g1][g2]);\n            ans = min(ans, G[s][i]+G[i][g2]+G[g2][g1]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    int d[1001][1001]={};\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)if(i!=j)d[i][j]=1e8;\n    for(int i=0,a,b,c;i<m;i++)\n      cin>>a>>b>>c,d[a][b]=c;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n    int ans=1e9;\n    for(int i=1;i<=n;i++)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tint d[101][101];\n\t\tREP(i, 101)REP(j, 101) d[i][j] = i == j ? 0 : INF;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tint res = INF;\n\t\tREP(i, n)\n\t\t{\n\t\t\tchmin(res, d[i][s] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2,hoge[101][101],a,b,c;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\thoge[i][j] = 100000000;\n      }\n      hoge[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> c;\n      hoge[a][b] = c;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  if(hoge[j][k] > hoge[j][i] + hoge[i][k]){\n\t    hoge[j][k] = hoge[j][i] + hoge[i][k];\n\t  }\n\t}\n      }\n    }\n    int MIN=1000000000;\n    for(int i=1;i<=n;i++)\n      MIN = min(MIN,hoge[s][i]+hoge[i][g1]+hoge[i][g2]);\n    cout << MIN << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, m, s, g1, g2;\nint c[101][101];\n\nint main(){\n\tint a1, a2, a3;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n != 0) {\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\t\tc[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a1 >> a2 >> a3;\n\t\t\tc[a1][a2] = a3;\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (c[i][j] > c[i][k] + c[k][j]) {\n\t\t\t\t\t\tc[i][j] = c[i][k] + c[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = c[s][g1] + c[s][g2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (ans > c[s][i] + c[i][g1] + c[i][g2]) {\n\t\t\t\tans = c[s][i] + c[i][g1] + c[i][g2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tif(n == 0) break;\n\t\tll d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF * INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=193189311;\n  int road[111][111];\n  for(int i=0;i<111;i++){\n    for(int j=0;j<111;j++){\n      road[i][j]=517821491;\n    }\n  }\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=1948198491;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n#define inf 123451234512345LL\n\nll G[100][100] = {0};\nvoid warshallfloyd(int v){\n  int i, j, k;\n  rep(k, v)rep(i, v)rep(j, v)if(G[i][k] != inf && G[k][j] != inf && G[i][j] > G[i][k] + G[k][j])G[i][j] = G[i][k] + G[k][j];\n  return;\n}\n\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase < 1234567;testcase++){\n\n    for(;;){\n      int n, m, s, g1, g2;\n      cin >> n >> m >> s >> g1 >> g2;\n      if((n | m | s | g1 | g2) == 0)break;\n      s--; g1--; g2--;\n\n      rep(i, n)rep(j, n)G[i][j] = inf;\n      rep(i, m){\n        int3(x, y, z);\n        x--; y--;\n        G[x][y] = z;\n      }\n      rep(i, n)G[i][i] = 0;\n\n      warshallfloyd(n);\n\n      ll res = inf;\n      rep(i, n)res = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n      pri(res);\n    }\n\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int INF=1<<27;\n\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    s--;g1--;g2--;\n    int dik[100][100];\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++)\n\tif(i == j )dik[i][j] = 0;\n\telse dik[i][j]=INF;\n    while(m--){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      dik[b1-1][b2-1]=c;\n    }\n\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  dik[i][j]=min(dik[i][j],dik[i][k]+dik[k][j]);\n    int ans=dik[s][g1]+dik[s][g2];\n    for(int i=0;i<n;i++) ans = min(ans,dik[s][i]+dik[i][g1]+dik[i][g2]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#define INF (1<<21)\nusing namespace std;\n\nint main(){\n  int i,j,k,n,m,s,g1,g2,d[101][101],ans;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(!n && !m && !s && !g1 && !g2) break;\n\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tif(i == j) d[i][j] = 0;\n\telse d[i][j] = INF;\n      }\n    }\n\n    for(j=0;j<m;j++){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      d[a][b] = cost;\n    }\n\n    for(k=0;k<=n;k++){\n      for(i=0;i<=n;i++){\n\tfor(j=0;j<=n;j++){\n\t  if(d[i][k] >= INF || d[k][j] >= INF) continue;\n\t  d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n\t}\n      }\n    }\n\n   int ans = d[s][g1] + d[s][g2];\n   ans = min(ans,d[s][g1]+d[g1][g2]);\n   ans = min(ans,d[s][g2]+d[g2][g1]);\n\n   for(i=1;i<=n;i++){\n     if(i != s && i != g1 && i != g2){\n       ans = min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n     }\n   }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 10000000\nint cost[100][100];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\twhile(1){\n\t\tint n,m,s,x,y;\n\t\tint i,j,k;\n\t\tscanf(\"%d %d %d %d %d\",&n,&m,&s,&x,&y);\n\t\ts--;x--;y--;\n\t\tif(n==0)return 0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++)cost[i][j]=INF;\n\t\t\tcost[i][i]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tcost[a-1][b-1]=c;\n\t\t}\n\t\tfor(k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=0;i<n;i++)ans=min(ans,cost[s][i]+cost[i][x]+cost[i][y]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 100000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\ts--; g1--; g2--;\n\t\tint d[100][100];\n\t\trep(i, 100) {\n\t\t\trep(j, 100) {\n\t\t\t\td[i][j] = (int)MOD;\n\t\t\t\tif (i == j)d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, z; cin >> x >> y >> z; x--; y--;\n\t\t\td[x][y] = min(d[x][y], z);\n\t\t}\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = (int)MOD;\n\t\trep(i, n) {\n\t\t\tmi = min(mi, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint V, E, S, G1, G2, B1, B2, C;\n\nvector<vector<int> > G;\n\nvector<vector<int> > R;\n\nvoid Shortest(int s, int mode, int rev)\n{\n\tvector<bool> u(V, false);\n\t\n\tR[mode][s] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1, c = 99999999;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i] && R[mode][i] < c)\n\t\t\t{\n\t\t\t\tc = R[mode][i]; v = i;\n\t\t\t}\n\t\t}\n\n\t\tif (c == 99999999) { break; }\n\n\t\tu[v] = true;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i])\n\t\t\t{\n\t\t\t\tif (R[mode][i] > R[mode][v] + (rev ? G[i][v] : G[v][i]))\n\t\t\t\t{\n\t\t\t\t\tR[mode][i] = R[mode][v] + (rev ? G[i][v] : G[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> V >> E >> S >> G1 >> G2;\n\n\t\tif (V == 0) { break; }\n\n\t\tG = vector<vector<int> >(V, vector<int>(V, 99999999));\n\n\t\tfor (int i = 0; i < E; i++)\n\t\t{\n\t\t\tcin >> B1 >> B2 >> C;\n\n\t\t\tG[B1 - 1][B2 - 1] = C;\n\t\t}\n\t\t\n\t\tR = vector<vector<int> >(3, vector<int>(V, 99999999));\n\n\t\tShortest(S - 1, 0, 0);\n\t\tShortest(G1 - 1, 1, 1);\n\t\tShortest(G2 - 1, 2, 1);\n\n\t\tint ret = 299999997;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tret = min(ret, R[0][i] + R[1][i] + R[2][i]);\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10000000\nusing namespace std;\nint cost[101][101];\nint n,m,s,g1,g2;\nvoid warshall_floyd(){\n  for(int i = 0 ; i < n ; i++ ){\n    for(int j = 0 ; j < n ; j++ ){\n      for(int k = 0 ; k < n ; k++ ){\n\tcost[j][k] = min(cost[j][k],cost[j][i] + cost[i][k]);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while( cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2 ){\n    n++;\n    for(int i = 0 ; i < n ; i++ )\n      for(int j = 0 ; j < n ; j++ ){\n\tif(i == j)cost[i][j] = 0;\n\telse cost[i][j] = INF;\n      }\n\n    for(int i = 0 ; i < m ; i++ ){\n      int a,b,c;\n      cin >> a >> b >> c;\n      cost[a][b] = c;\n    }\n    warshall_floyd();\n\n    int mn = INF;\n    for(int i = 0 ; i < n ; i++ )\n      mn = min(cost[s][i] + cost[i][g1] + cost[i][g2],mn);\n    cout << mn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define INF (1e9)\n#define N 101\nusing namespace std;\nint n,m,s,g1,g2,b,e,c,d[N][N],ans;\nvoid warshall_floyd();\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) d[i][j]=INF;\n    for(int i=0;i<N;i++) d[i][i]=0;\n    while(m--) cin>>b>>e>>c,d[b][e]=c;\n    warshall_floyd();\n    ans=INF;\n    for(int i=1;i<=n;i++){\n      if(d[s][i]==INF||d[i][g1]==INF||d[i][g2]==INF) continue;\n      ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid warshall_floyd(){\n  for(int k=1;k<=n;k++)\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<10);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      pipe[i][j]=INF;\n      pipe[i][i]=0;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define INF (1 << 28)\n#define MAX_V 1000\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int, int> P; // first??????????????¢???second??????????????????\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\n// ?????????O(|E|log|V|)\n\nvoid shortest_path(int s, int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e1, e2;\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\te1.to = to;\n\t\t\te1.cost = cost;\n\t\t\te2.to = from;\n\t\t\te2.cost = cost;\n\t\t\tG[from].push_back(e1);\n\t\t\tG[to].push_back(e2);\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tshortest_path(s, n);\n\t\t\tint cost_sum = d[i];\n\t\t\tshortest_path(i, n);\n\t\t\tcost_sum += d[g1] + d[g2];\n\t\t\tans = min(ans, cost_sum);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef struct edge{\n  int to, cost;\n}edge;\n\nint main(){\n  int n, m, s, a, b, from, to, cost;\n  while(cin >> n >> m >> s >> a >> b, n){\n    s--, a--, b--;\n    vector<vector<edge> > g(n);\n    for(int i = 0; i < m; i++){\n      cin >> from >> to >> cost;\n      from--, to--;\n      g[from].push_back(edge{to, cost});\n    }\n    vector<vector<int> > dp(n, vector<int>(n, 1e8));\n    dp[s][s] = 0;\n    for (int i = 0; i < g[s].size(); i++) dp[s][g[s][i].to] = dp[g[s][i].to][s] = g[s][i].cost;\n    \n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        for (int k = 0; k < n; k++) {\n          for (int l = 0; l < g[j].size(); l++) {\n            if(j == s and k == g[j][l].to)dp[k][g[j][l].to] = dp[g[j][l].to][k] = min(dp[k][g[j][l].to], dp[j][k]);\n            else dp[k][g[j][l].to] = dp[g[j][l].to][k] = min(dp[k][g[j][l].to], dp[j][k] + g[j][l].cost);\n          }\n          for (int l = 0; l < g[k].size(); l++) {\n            if(j == g[k][l].to and k == s)dp[j][g[k][l].to] = dp[g[k][l].to][j] = min(dp[j][g[k][l].to], dp[j][k]);\n            else dp[j][g[k][l].to] = dp[g[k][l].to][j] = min(dp[j][g[k][l].to], dp[j][k] + g[k][l].cost);\n          }\n        }\n      }\n    }\n    // for (int i = 0; i < n; i++) {\n    //   for (int j = 0; j < n; j++) {\n    //     std::cout << dp[i][j] << \" \";\n    //   }\n    //   std::cout << std::endl;\n    // }\n    std::cout << dp[a][b] << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main(){\n    ios::sync_with_stdio(false);\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        --s;\n        --g1;\n        --g2;\n        vector<vector<int>>dist(n,vector<int>(n,INF));\n        for(int i=0;i<m;++i){\n            int u,v,cost;\n            cin>>u>>v>>cost;\n            dist[u-1][v-1]=cost;\n        }\n        for(int k=0;k<n;++k){\n            for(int i=0;i<n;++i){\n                for(int j=0;j<n;++j){\n                    if(dist[i][j] > dist[i][k]+dist[k][j]){\n                        dist[i][j] = dist[i][k]+dist[k][j];\n                    }\n                }\n            }\n        }\n        for(int i=0;i<n;++i)dist[i][i]=0;\n        int ans=1e9;\n        for(int i=0;i<n;++i){\n            ans=min(ans,dist[s][i]+dist[i][g1]+dist[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\nint T[MAX][MAX];\nint n,m,s,g1,g2;\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++) T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int from, to, cost;\n    cin >> from >> to >> cost;\n    T[from][to] = cost;\n  }\n}\n\nvoid solve(){\n\n  for(int k = 0; k <= n; k++)\n    for(int i = 0; i <= n; i++)\n      for(int j = 0; j <= n; j++) T[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n\n  int ans = INF;\n  for(int i = 0; i <= n; i++) ans = min(ans,T[s][i]+T[i][g1]+T[i][g2]);    \n  cout << ans << endl;\n}\n\nint main(){\n\n\n  while(cin >> n >> m >> s >> g1 >> g2 &&n+m+s+g1+g2){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#define INF 1000000\n#define cost first\n#define node second\nusing namespace std;\ntypedef pair <int,int> P;\nint mp[101][101];\nint n,m,s,g1,g2;\n\nint dijkstra(int start,int goal){\n  int D[101];\n  for(int i=0;i<=n;i++) D[i]=INF;\n  priority_queue <P>Q;\n  Q.push((P){0,start});\n  while(!Q.empty()){\n    P t=Q.top(); Q.pop();\n    if(t.node==goal) return t.cost;\n    for(int i=1;i<=n;i++){\n      int ncost = mp[t.node][i];\n      if(ncost==-1 || D[i] <= t.cost+ncost) continue;\n      Q.push((P){t.cost+ncost,i});\n      D[i] = t.cost+ncost;\n    }\n  }\nreturn INF;\n}\n\nint main(){\n  while(1){\n  cin >>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n  memset(mp,-1,sizeof(mp));\n  int b1,b2,c;\n  for(int i=0;i<m;i++) cin >> b1>>b2>>c,mp[b1][b2]=c;\n\n  int ans = INF;\n  for(int i=1;i<=n;i++)ans = min(ans,dijkstra(s,i)+dijkstra(i,g1)+dijkstra(i,g2));\n  cout << ans <<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector< vector<int> > vvi;\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n) {\n\t\tint cost[101][101];\n\t\trep(i,n+1) rep(j,n+1) cost[i][j] = 10000000;\n\t\trep(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a][b] = c;\n\t\t}\n\t\trep(i,n) cost[i+1][i+1] = 0;\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tcost[i+1][j+1] = min( cost[i+1][j+1], cost[i+1][k+1] + cost[k+1][j+1] );\n\t\tint res = 10000000;\n\t\tfor(int k=1; k<=n; k++) {\n\t\t\tres = min(res, cost[s][k]+cost[k][g1]+cost[k][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main ()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n + m + s + g1 + g2) {\n        vector<vector<int> > d(n + 1, vector<int>(n + 1, INF));\n        for (int i = 0; i <= n; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int gx, gy, c;\n            cin >> gx >> gy >> c;\n            d[gx][gy] = d[gy][gx] = c;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int  k = 1; k <= n; k++) {\n                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 0; i < n; i++) {\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(void)\n{\n\tint n, m, s, g1, g2;\n\tint data[128][128];\n\tint a, b, c;\n\t\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n && m){\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tdata[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tdata[a][b] = c;\n\t\t}\n\t\t\n\t\t// わーしゃるふろいど\n\t\tfor (int k = 1; k <= n; k++){\n\t\t\tfor (int i = 1; i <= n; i++){\n\t\t\t\tfor (int j = 1; j <= n; j++){\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 20000000;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tret = min(ret, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n){\n\t\tint d[301][301];\n\t\trep(i, 301)rep(j, 301)d[i][j] = (i == j ? 0 : INF);\n\t\t\n\t\trep(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = c;\n\t\t}\n\n\t\tFor(k,1, n+1)For(i,1, n+1)For(j,1, n+1){\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tFor(k, 1, n + 1){\n\t\t\tint tmp = 0;\n\t\t\ttmp += d[s][k];\n\t\t\ttmp += d[k][g1];\n\t\t\ttmp += d[k][g2];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100000000\n\n// 🔴\n\n// O(ElogE)\n\n// pq<pair> はfirstが大きい順に出てくるのですか？\n// s:= 開始ノード  v:= 頂点数  adjlist:= 隣接リスト (first:= コスト   second:= 行先)\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    while(1){\n\n    int V, E, S, G1, G2; cin >> V >> E >> S >> G1 >> G2;     // V:= 頂点の数    E:= 辺の数    S:= スタートノード　　G:= ゴールノード\n    if(!V) break;\n    S--;\n    G1--;\n    G2--;\n    vector<vector<pair<int, int> > > adjlist(V);      //first := コスト　second := 行先\n\n    //入力\n    for(int i = 0; i < E; i++){\n        int a, b, c; cin >> a >> b >> c;           // a ,b 間に コスト c の辺がある\n        a--;\n        b--;\n        adjlist[a].push_back(make_pair(c, b));\n        //adjlist[b].push_back(make_pair(c, a));      \n    }\n\n    int ans = INF;\n    vector<int> result(V);\n    vector<int> res(V);\n    result = dijk(S, V, adjlist);\n    for(int i = 0; i < V; i++){\n        res = dijk(i, V, adjlist);\n        ans = min(ans, result[i] + res[G1] + res[G2]);\n    }\n\n    cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\nint cost[100][100];\nint main() {\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%d %d\",&n,&m),n) {\n\t\tscanf(\"%d %d %d\",&s,&g1,&g2);s--;g1--;g2--;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j]=cost[j][i]=(i==j)?0:INF;\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\t\tcost[a-1][b-1]=c;\n\t\t}\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\tint ans=1<<30;\n\t\tfor(int k=0;k<n;k++)\n\t\t\tans=min(ans,cost[s][k]+cost[k][g1]+cost[k][g2]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1<<21\nusing namespace std;\nint d[128][128];\nint N, M;\n\nvoid warshall_floyd(){\n  for (int k = 0; k < N; k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    int s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n \n    if (!N&&!M&&!s&&!g1&&!g2) break;   \n    N++;\n    for (int i = 0; i < N; i++){\n      fill_n(d[i], N, INF);\n    }\n    for (int i = 0; i < M; i++){\n      int u, v, c;\n      cin >> u >> v >> c;\n      d[u][v] = c;\n    }\n\n    warshall_floyd();\n    int res = INF;\n    for (int i = 0; i < N; i++){\n      res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<29)\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2) {\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\t\tn; m; s--; g1--; g2--;\n\t\tvector<vector<int>> dist(n, vector<int>(n, INF));\n\t\tfor (int i = 0; i < m;i++) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tdist[b1][b2] = c;\n\t\t}\n\n\t\t//WarshallFloyd\n\t\tfor (int i = 0; i < n;i++) dist[i][i] = 0;\n\t\tfor (int i = 0;i < n;i++)for (int j = 0; j < n;j++)for (int k = 0;k < n;k++) {\n\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX (1<<21)\n\n\nint d[121][121];\nvoid reset(int n){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      d[i][j]=MAX;\n    }\n    d[i][i]=0;\n  }\n}\n\nvoid warshall_floyd(int n){\n  for(int k=1;k<n;k++){\n    for(int i=1;i<n;i++){\n      for(int j=1;j<n;j++){\n        //if (d[i][k] == MAX || d[k][j]==MAX)continue;\n        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n  }\n}\n\nmain(){\n  int n,m,s,g1,g2;\n  while(cin >> n>>m>>s>>g1>>g2){\n    if (n==0)break;\n    reset(n+1);\n    for(int i=0;i<m;i++){\n      int from,to,cost;\n      cin >> from >> to >> cost;\n      d[from][to]=cost;\n    }\n    \n    warshall_floyd(n+1);\n    int min = INT_MAX;\n    for(int i=1;i<n+1;i++){\n      int cost = d[s][i]+d[i][g1]+d[i][g2];\n      if (cost< min)min=cost;\n    }\n    cout << min << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 127, sizeof(z));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (x[i][j] >= 1) {\n\t\t\t\t\tx[j][i] = x[i][j];\n\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\n/*\n  n m s g1 g2\n  a b c\n  ...\n  am bm cm\n  0 0 0 0 0\n  */\n\nint n,m,s,g1,g2;\nint edge[128][128];\nint main(){\n  while(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n|m|s|g1|g2){\n    s--; g1--; g2--;\n    //init\n    rep(i,128)rep(j,128)edge[i][j]=INT_MAX;\n    rep(i,128)edge[i][i]=0;\n\n    // input\n    rep(i,m){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      edge[a-1][b-1]=c;\n    }\n\n    // í[µáéÓë¢Ç\n    rep(k,n){\n      rep(i,n){\n        rep(j,n){\n          if( edge[i][k]!=INT_MAX && edge[k][j]!=INT_MAX ){\n            edge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n          }\n        }\n      }\n    }\n\n    int ans = INT_MAX;\n    rep(k,n){\n      if( k==g1 ){\n        if( edge[s][g1]!=INT_MAX && edge[g1][g2]!=INT_MAX ){\n          ans = min(ans, edge[s][g1]+edge[g1][g2]);\n        }\n      }else if( k==g2 ){\n        if( edge[s][g2]!=INT_MAX && edge[g2][g1]!=INT_MAX ){\n          ans = min(ans, edge[s][g2]+edge[g2][g1]);\n        }\n      }else{\n        if( edge[s][k]!=INT_MAX && edge[k][g1]!=INT_MAX && edge[k][g2]!=INT_MAX ){\n          ans = min(ans, edge[s][k]+edge[k][g1]+edge[k][g2]);\n        }\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main ()\n{\n        long long int n , m , s , g1 , g2;\n        while( cin >> n >> m >> s >> g1 >> g2 , n && m && s && g1 && g2 )\n        {\n                s--; g1--; g2--;\n                vector<vector<long long int> >data;\n                data.resize ( n );\n                for( size_t i = 0; i < n; i++ )\n                {\n                        data[i].resize ( n );\n                        for( size_t j = 0; j < n; j++ )\n                        {\n                                data[i][j] = INT_MAX / 6;\n                        }\n                        data[i][i] = 0;\n                }\n                long long int a , b , c;\n                for( size_t i = 0; i < m; i++ )\n                {\n                        cin >> a >> b >> c;\n                        a--; b--;\n                        data[a][b] = c;\n                }\n                for( size_t k = 0; k < n; k++ )\n                {\n                        for( size_t j = 0; j < n; j++ )\n                        {\n                                for( size_t i = 0; i < n; i++ )\n                                {\n                                        data[i][j] = min ( data[i][j] , data[i][k] + data[k][j] );\n                                }\n                        }\n                }\n                long long int ans = INT_MAX;\n                for( size_t i = 0; i < n; i++ )\n                {\n                        ans = min ( ans , data[s][i] + data[i][g1] + data[i][g2] );\n                }\n                cout << ans << endl;\n                data.clear ();\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint main() {\n\n  while (true) {\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n == 0) break;\n    const int inf = 100000000;\n    vector<vector<int>> d(n, vector<int>(n, inf));\n    rep(i, n) d[i][i] = 0;\n    rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      d[a - 1][b - 1] = c;\n    }\n    rep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    auto mn = inf;\n    rep(i, n) { mn = min(mn, d[s - 1][i] + d[i][g1 - 1] + d[i][g2 - 1]); }\n    cout << mn << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<29) - 1;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, S, G1, G2;\n    while(cin >> N >> M >> S >> G1 >> G2, N|M|S|G1|G2){\n        S--; G1--; G2--;\n        vector<vector<int>> G(N, vector<int>(N, INF));\n        for(int i=0; i<N; i++)\n            G[i][i] = 0;\n        while(M--){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            b1--; b2--;\n            G[b1][b2] = c;\n        }\n        \n        for(int k=0; k<N; k++)\n            for(int i=0; i<N; i++)\n                for(int j=0; j<N; j++)\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        \n        int ans = INF;\n        for(int i=0; i<N; i++){\n            ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n        }\n        cout << ans << endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\n#define INF 0xfffffff\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main() {\n\tint n, m, s, g1, g2;\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif ((n | m | s | g1 | g2) == 0) {\n\t\treturn 0;\n\t}\n\ts--;\n\tg1--;\n\tg2--;\n\tvector< vector<int> > d(n, vector<int>(n, INF));\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to, cost;\n\t\tcin >> from >> to >> cost;\n\t\td[--from][--to] = cost;\n\t}\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i][i] = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t}\n\tcout << ans << endl;\n\treturn main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 30000\n\n#define MAX_SIZE 100\nlong long g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tfor (int k = 0; k < v; ++k) {\n\t\tfor (int i = 0; i < v; ++i) {\n\t\t\tfor (int j = 0; j < v; ++j) {\n\t\t\t\tg_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\tmemset(g_d, INF, sizeof(g_d));\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tg_d[i][i] = 0;\n\t\t}\n\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\t--b1; --b2;\n\t\t\tg_d[b1][b2] = c;\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tlong long cost = INF;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\nint G[101][101], d[101][101];\n\nvoid init(){\n\tfor(int i=0 ; i < 101 ; i++ ){\n\t\tfor(int j=0 ; j < 101 ; j++ ){\n\t\t\tG[i][j] = (i == j)? 0 : INF;\n\t\t\td[i][j] = (i == j)? 0 : INF;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile( cin >> n >> m >> s >> g1 >> g2 , n ){\n\t\tinit();\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tG[u][v] = cost;\n\t\t\td[u][v] = cost;\n\t\t}\n\n\t\tfor(int k=1 ; k <= n ; k++ ){\n\t\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\t\tfor(int j=1 ; j <= n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , G[i][k] + G[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int v=1 ; v <= n ; v++ ){\n\t\t\tans = min( ans , d[s][v] + d[v][g1] + d[v][g2] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vi2;\nconst int INF = 1 << 30;\n\nint solve();\n\nint main(void) {\n\n\twhile (solve()){}\n\n\treturn 0;\n\n}\n\nint solve() {\n\n\tint n, m, s, g1, g2;\n\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif (!(n | m | s | g1 | g2)){ return 0; }\n\n\ts--;\n\tg1--;\n\tg2--;\n\n\t//Adjacency matrix\n\tvi2 v(n, vi(n, -1));\n\n\t//distance\n\tvi2 d(n, vi(n, INF));\n\n\t//input\n\tfor (int i = 0; i < m; i++) {\n\n\t\tint b1, b2, c;\n\n\t\tcin >> b1 >> b2 >> c;\n\t\tv[b1 - 1][b2 - 1] = c;\n\n\t}\n\n\t//Floyd???Warshall algorithm\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (v[i][j] > 0) {\n\t\t\t\td[i][j] = v[i][j];\n\t\t\t}\n\t\t\tif (i == j) {\n\t\t\t\td[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ( d[i][k] < INF && d[k][j] < INF )\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\t//s??????i,g1,g2????????°???\n\tint ans = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (d[s][i] == INF || d[i][g1] == INF || d[i][g2] == INF) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tans = min(d[s][i] + d[i][g1] + d[i][g2], ans);\n\t}\n\n\t//s->g1->g2\n\tif (d[s][g1] < INF && d[g1][g2] < INF)\n\t\tans = min(d[s][g1] + d[g1][g2], ans);\n\n\t//s->g2->g1\n\tif (d[s][g2] < INF && d[g2][g1] < INF)\n\t\tans = min(d[s][g2] + d[g2][g1], ans);\n\n\tcout << ans << endl;\n\n\treturn 1;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define INF (1<<29)\n\nstruct edge {\n\tint from, to, cost;\n\tedge() {}\n\tedge(int from, int to, int cost) :from(from), to(to), cost(cost) {}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2) {\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\t\tn; m; s--; g1--; g2--;\n\t\tvector<vector<edge>> G(n);\n\t\tvector<vector<int>> dist(n, vector<int>(n, INF));\n\t\tfor (int i = 0; i < m;i++) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tG[b1].push_back(edge(b1, b2, c));\n\t\t\t//dist[b1][b2] = c;\n\t\t}\n\n\t\tfor (int i = 0; i < n;i++) dist[i][i] = 0;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tqueue<int> q; q.push(i);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint v = q.front(); q.pop();\n\t\t\t\tfor (int j = 0; j < G[v].size();j++) {\n\t\t\t\t\tint next = G[v][j].to;\n\t\t\t\t\tint c = G[v][j].cost;\n\t\t\t\t\tif (dist[i][next] > dist[i][v] + c) {\n\t\t\t\t\t\tdist[i][next] = dist[i][v] + c;\n\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\tg1--; g2--; s--;\n\t\tvector<vector<int> >d(n, vector<int>(n, 10000));\n\t\trep(i, 0, n)d[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c; b1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\trep(k, 0, n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<29) - 1;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int N, M, S, G1, G2;\n    while(cin >> N >> M >> S >> G1 >> G2, N|M|S|G1|G2){\n        S--; G1--; G2--;\n        vector<vector<int>> G(N, vector<int>(N, INF));\n        for(int i=0; i<N; i++)\n            G[i][i] = 0;\n        while(M--){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            b1--; b2--;\n            G[b1][b2] = G[b2][b1] = c;\n        }\n        \n        for(int k=0; k<N; k++){\n            for(int i=0; i<N; i++){\n                for(int j=0; j<N; j++){\n                    G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n                    G[j][i] = min(G[j][i], G[j][k] + G[k][i]);\n                }\n            }\n        }\n        \n        int ans = INF;\n        for(int i=0; i<N; i++){\n            ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n        }\n        cout << ans << endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct {\n    int from, to;\n    int cost;\n} edge;\n\nint main() {\n    while (true) {\n        int b_goal[2];\n        int n_bases, n_roads, b_start;\n        cin >> n_bases >> n_roads >> b_start >> b_goal[0] >> b_goal[1];\n\n        if (n_bases == 0) break;\n\n        map< int, vector<edge> > edges;\n        map< int, vector<edge> > redges;\n\n        while (n_roads--) {\n            int b_from, b_to, cost;\n            cin >> b_from >> b_to >> cost;\n            edge e = { b_from, b_to, cost };\n            edges[b_from].push_back(e);\n            redges[b_to].push_back(e);\n        }\n\n        map<int, int> cost_from_start;\n        for (int b = 1; b <= n_bases; ++b) {\n            cost_from_start[b] = INT_MAX;\n        }\n\n        queue<edge> q;\n\n        {\n            vector<edge> ee = edges[b_start];\n            for (size_t i = 0; i < ee.size(); ++i) {\n                q.push(ee[i]);\n            }\n        }\n\n        cost_from_start[b_start] = 0;\n        for (; !q.empty(); q.pop()) {\n            edge e = q.front();\n\n            int new_cost = cost_from_start[e.from] == INT_MAX ? INT_MAX : cost_from_start[e.from] + e.cost;\n            if (new_cost < cost_from_start[e.to]) {\n                cost_from_start[e.to] = new_cost;\n\n                vector<edge> ee = edges[e.to];\n                for (size_t i = 0; i < ee.size(); ++i) {\n                    q.push(ee[i]);\n                }\n            }\n        }\n\n        map<int, vector<int> > costs_from_goal;\n        for (int b = 1; b <= n_bases; ++b) {\n            costs_from_goal[b] = vector<int>(2, INT_MAX);\n        }\n\n        for (int I = 0; I <= 1; I++) {\n            vector<edge> ee = redges[b_goal[I]];\n            for (size_t i = 0; i < ee.size(); ++i) {\n                q.push(ee[i]);\n            }\n\n            costs_from_goal[b_goal[I]][I] = 0;\n            for (; !q.empty(); q.pop()) {\n                edge e = q.front();\n\n                int new_cost = costs_from_goal[e.to][I] == INT_MAX ? INT_MAX : costs_from_goal[e.to][I] + e.cost;\n                if (new_cost < costs_from_goal[e.from][I]) {\n                    costs_from_goal[e.from][I] = new_cost;\n\n                    vector<edge> ee = redges[e.from];\n                    for (size_t i = 0; i < ee.size(); ++i) {\n                        q.push(ee[i]);\n                    }\n                }\n            }\n        }\n\n        int min = INT_MAX;\n        for (int b = 1; b <= n_bases; ++b) {\n            if (cost_from_start[b] == INT_MAX) continue;\n            if (costs_from_goal[b][0] == INT_MAX) continue;\n            if (costs_from_goal[b][1] == INT_MAX) continue;\n\n            int v = cost_from_start[b] + costs_from_goal[b][0] + costs_from_goal[b][1];\n            if (v < min) {\n                min = v;\n            }\n        }\n        cout << min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint V, E, S, G1, G2, B1, B2, C;\n\nvector<vector<int> > G;\n\nvector<vector<int> > R;\n\ninline void Shortest(int s, int mode, int rev)\n{\n\tvector<bool> u(V, false);\n\t\n\tR[mode][s] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1, c = 99999999;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i] && R[mode][i] < c)\n\t\t\t{\n\t\t\t\tc = R[mode][i]; v = i;\n\t\t\t}\n\t\t}\n\n\t\tif (c == 99999999) { break; }\n\n\t\tu[v] = true;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i])\n\t\t\t{\n\t\t\t\tif (R[mode][i] > R[mode][v] + (rev ? G[i][v] : G[v][i]))\n\t\t\t\t{\n\t\t\t\t\tR[mode][i] = R[mode][v] + (rev ? G[i][v] : G[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &V);\n\t\tscanf(\"%d\", &E);\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &G1);\n\t\tscanf(\"%d\", &G2);\n\n\t\tif (V == 0) { break; }\n\n\t\tG = vector<vector<int> >(V, vector<int>(V, 99999999));\n\n\t\tfor (int i = 0; i < E; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &B1);\n\t\t\tscanf(\"%d\", &B2);\n\t\t\tscanf(\"%d\", &C);\n\n\t\t\tG[B1 - 1][B2 - 1] = C;\n\t\t}\n\t\t\n\t\tR = vector<vector<int> >(3, vector<int>(V, 99999999));\n\n\t\tShortest(S - 1, 0, 0);\n\t\tShortest(G1 - 1, 1, 1);\n\t\tShortest(G2 - 1, 2, 1);\n\n\t\tint ret = 299999997;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tret = min(ret, R[0][i] + R[1][i] + R[2][i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <vector<int> > Vec;\n#define INF 20000000\n\nvoid war(Vec& vec) {\n\tint v = vec.size();\n\t\tfor (int k = 0; k < v; k++) {\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tfor (int j = 0; j < v; j++) {\n\t\t\t\t\tvec[i][j] = min(vec[i][j], vec[i][k] + vec[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tVec G(n);\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\ts--; g1--; g2--;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tG[i].push_back(i != j ? INF : 0);\n\t\t\t}\n\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tG[a - 1][b - 1] = c;\n\t\t\t}\n\t\t\twar(G);\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n\t\t\t}\n\t\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 110;\nconst int INF = (1<<29);\n\nint n, m, s, g1, g2;\nint cost[MAX_V][MAX_V];\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++)\n    for(int j = 0 ; j < MAX_V ; j++) cost[i][j] = INF;\n  \n  for(int i = 0 ; i < MAX_V ; i++) cost[i][i] = 0;\n}\n\n\nvoid wf(){\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }    \n}\n\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n    init();\n    s--, g1--, g2--;\n    int from, to, C;\n    for(int i = 0 ; i < m ; i++){\n      cin >> from >> to >> C;\n      cost[from-1][to-1] = C;\n    }\n    \n    wf();\n        \n    int ans = INF;\n    for(int i = 0 ; i < n ; i++){\n      ans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\n\nclass WarshallFloyd {\nprivate:\n    int n;\n    VV d;\npublic:\n    WarshallFloyd(int _n) : n(_n) {\n        d.resize(n, V(n));\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // directed\n    void setDist(int i, int j, int c) {\n        d[i][j] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n) {\n        s--, g1--, g2--;\n        WarshallFloyd wf(n);\n        rep(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--, b--;\n            wf.setDist(a, b, c);\n        }\n\n        wf.calc();\n\n        int ans = inf;\n        rep(i, n) {\n            ans = min(ans, wf.getDist(s, i) + wf.getDist(i, g1) + wf.getDist(i, g2));\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){ break; }\n\t\t--s; --g1; --g2;\n\t\tvector< vector<int> > matrix(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\t--b1; --b2;\n\t\t\tmatrix[b1][b2] = min(matrix[b1][b2], c);\n\t\t}\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif(matrix[i][k] + matrix[k][j] < matrix[i][j]){\n\t\t\t\t\t\tmatrix[i][j] = matrix[i][k] + matrix[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answer = INF;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tanswer = min(\n\t\t\t\tanswer, matrix[s][i] + matrix[i][g1] + matrix[i][g2]);\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef long long int Int;\ntypedef pair<int, int> P;\nconst int MAX_N = 105;\nconst int INF = 1e9;\n\nint main() {\n  Int G[MAX_N][MAX_N], N, M, S, G1, G2;\n  while(cin >>N >>M >>S >>G1 >>G2 && N){\n    --S; --G1; --G2;\n    REP(i, N) REP(j, N) G[i][j] = (i == j ? 0 : INF);\n    REP(i, M){\n      int f, t, c; cin >>f >>t >>c;\n      G[f - 1][t - 1] = c;\n    }\n    Int ans = INF;\n    REP(k, N) REP(i, N) REP(j, N) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    REP(i, N) ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int INF = 0xfffffff;\n\tfor(int n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2, n;) {\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tvector<vector<int> > mat(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tmat[i][i] = 0;\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tmat[from - 1][to - 1] = cost;\n\t\t}\n\n\t\tfor(int k = 0; k < n; ++k)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t\tchmin(mat[i][j], mat[i][k] + mat[k][j]);\n\n\t\tint ans = INT_MAX;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tchmin(ans, mat[s][i] + mat[i][g1] + mat[i][g2]);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 101\n#define INF (1e9)\nusing namespace std;\nvoid prim();\nvoid func(int);\nint n,m,s,g1,g2,b1,b2,c,cost[N_MAX][N_MAX],mincost[N_MAX],ans;\nbool used[N_MAX];\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) cost[i][j]=INF;\n    for(int i=0;i<m;i++) cin>>b1>>b2>>c,cost[b1][b2]=cost[b2][b1]=c;\n    prim();\n  }\n  return 0;\n}\n\nvoid prim(){\n  for(int i=1;i<=n;i++) mincost[i]=INF,used[i]=false;\n  mincost[s]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    for(int u=1;u<=n;u++)\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=1;u<=n;u++) mincost[u]=min(mincost[u],cost[v][u]);\n  }\n  func(s);\n  cout<<ans<<endl;\n}\n\nvoid func(int d){\n  if(d==g1||d==g2) return ;\n  for(int i=1;i<=n;i++){\n    if(mincost[i]==cost[d][i]){\n      ans+=mincost[i];\n      func(i);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define BMAX 100\n#define DMAX 1000000\n\nusing namespace std;\n\nstruct data { \n\tint cost;\n\tint where;\n};\n\n//bool bind[BMAX][BMAX];\nint cost[BMAX][BMAX];\nint dis[BMAX][BMAX];\nbool check[BMAX];\n\n\n\nbool operator<( const data& a, const data& b) {\n\treturn a.cost > b.cost;\n}\n\nint main () {\n\tint count = 0;\n\twhile ( true ) {\n\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m>> s>> g1>> g2;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcost[i][j] = DMAX;\n\t\t\t\tdis[i][j] = DMAX;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tcost[i][i] = 0;\n\t\t\tdis[i][i] = 0;\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint x,y,c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tcost[x-1][y-1] = c;\n\t\t}\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tpriority_queue<data> flow;\n\n\t\t\twhile(!flow.empty()) {\n\t\t\t\tflow.pop();\n\t\t\t}\n\n\t\t\tdata now;\n\t\t\tnow.cost = 0;\n\t\t\tnow.where = i;\n\t\t\tflow.push(now);\n\t\t\twhile ( !flow.empty() ) {\n\t\t\t\tdata now = flow.top();\n\t\t\t\tflow.pop();\n\n\t\t\t\tdata next;\n\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tcheck[j] = true;\n\t\t\t\t}\n\t\t\t\tcheck[now.where] = false;\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tif ( check[j] ) {\n\t\t\t\t\t\tcheck[j] = false;\n\t\t\t\t\t\tint newDCost = dis[now.where][j] + now.cost ;\n\t\t\t\t\t\tint newCCost = cost[now.where][j] + now.cost ;\n\t\t\t\t\t\tint newCost;\n\t\t\t\t\t\tif ( newDCost < newCCost )\n\t\t\t\t\t\t\tnewCost = newDCost;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnewCost = newCCost;\n\t\t\t\t\t\tif ( dis[i][j] > newCost ) {\n\t\t\t\t\t\t\tdis[i][j] = newCost;\n\t\t\t\t\t\t\tnext.cost = newCost;\n\t\t\t\t\t\t\tnext.where = j;\n\t\t\t\t\t\t\tif ( next.cost != DMAX ) {\n\t\t\t\t\t\t\t\tflow.push(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min = DMAX;\n\t\tint minb;\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tif ( min > dis[s][i] + dis[i][g1] + dis[i][g2] ) {\n\t\t\t\tmin = dis[s][i] + dis[i][g1] + dis[i][g2];\n\t\t\t\tminb = i;\n\t\t\t}\n\t\t}\n\n\t\tcout << min << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nint main() {\n\tcin.sync_with_stdio(false); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tfor (;;) {\n\t\tint n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2;\n\t\tif (!n) break;\n\n\t\tvector<vector<ll>> dist(n + 1, vector<ll>(n + 1, 0x3f3f3f3f));\n\n\t\trep(i, 1, n + 1) dist[i][i] = 0;\n\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tdist[b1][b2] = c;\n\t\t}\n\n\t\trep(i, 1, n + 1) rep(j, 1, n + 1) rep(k, 1, n + 1) {\n\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t}\n\n\t\tll ans = 0x3f3f3f3f;\n\t\trep(i, 1, n + 1) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint N, M, s, g1, g2;\nusing pii = pair<int, int>;\nusing Graph = vector< vector<pii> >;\nusing Matrix = vector< vector<int> >;\nconst int INF = 1 << 25;\n\nvoid warshall(Matrix &mat) {\n    int P = mat.size();\n    for(int k=0; k<P; k++) {\n        for(int i=0; i<P; i++) {\n            for(int j=0; j<P; j++) {\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][i]);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin >> N >> M >> s >> g1 >> g2, N) {\n        s--; g1--; g2--;\n\n        Graph G(N);\n        Matrix gst(N, vector<int>(N, INF));\n        Matrix rev(N, vector<int>(N, INF));\n\n        for(int i=0; i<M; i++) {\n            int u, v, cost; cin >> u >> v >> cost;\n            u--; v--;\n            gst[u][v] = cost;\n            rev[v][u] = cost;\n        }\n\n        warshall(gst);\n        warshall(rev);\n\n        int ans = INF;\n        for(int i=0; i<N; i++) {\n            ans = min(ans, gst[i][g1] + gst[i][g2] + rev[i][s]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n???road[k][g[0]]+road[k][g[1]]??????(k:any????????§)????°????????????¨?????£??????\n???road[s][k]?????§??????????????¨??????????°??????¨??????????????????\n??????road[k][g[0]]+road[k][g[1]]?????§???????????????road[s][k]????°????????????°???????¨????????°?????????????\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nconst int INF = 1e8;\n\nint n ,m, s, g[2];\nint road[105][105];\n\nint main() {\n  while(1){\n    cin>>n>>m>>s>>g[0]>>g[1];\n    if(n==0) break;\n    s--; g[0]--; g[1]--;\n    REP(i,0,n)REP(j,0,n){\n      if(i==j) road[i][j] = 0;\n      else road[i][j] = INF;\n    }\n    REP(i,0,m){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      b1--; b2--;\n      road[b1][b2] = c;\n    }\n    REP(k,0,n){\n      REP(from,0,n){\n        REP(to,0,n){\n          road[from][to] = min(road[from][to], road[from][k]+road[k][to]);\n        }\n      }\n    }\n    int ans = INF;\n    REP(k,0,n){\n      ans = min(ans, road[s][k] + road[k][g[0]] + road[k][g[1]]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,m,s,t1,t2;\n  while(cin>>n>>m>>s>>t1>>t2,n) {\n    s--;t1--;t2--;\n    int g[n][n], dis[n][n];\n    REP(i,n)REP(j,n){\n      if (i==j) g[i][j] = 0;\n      else\n        g[i][j] = INF;\n    }\n    REP(i,m) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      a--;b--;\n      g[a][b] = c;\n    }\n    memcpy(dis, g, sizeof(g));\n    REP(k,n) REP(i,n) REP(j,n)\n      if (dis[i][j] > dis[i][k]+dis[k][j])\n        dis[i][j] = dis[i][k]+dis[k][j];\n    int res = INF;\n    // REP(i,n) REP(j,n) {\n    //   printf(\"%d,%d %d\\n\",i,j,dis[i][j]);\n    // }\n    REP(i,n) {\n      res = min(res, dis[s][i]+dis[i][t1]+dis[i][t2]);\n    }\n    cout << res <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 1000000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = (table[j][k] < (table[j][i] + table[i][k]) ?\n\t\t\t\t\ttable[j][k] : (table[j][i] + table[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** Problem2005 : Water Pipe Construction **/\nint d[110][110];\nint V;\n\nvoid warshall_floyd()\n{\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint M, S, G1, G2;\n\twhile (cin>>V>>M>>S>>G1>>G2, V||M||S||G1||G2) {\n\t\tfill(d[0], d[0]+110*110, INF);\n\t\t\n\t\trep(i, M) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\t\n\t\twarshall_floyd();\n\t\n\t\tint ans=d[S][G1]+d[S][G2];\n\t\trep(i, V) {\n\t\t\tif (i != S && i != G1 && i!=G2) {\n\t\t\t\tint tmp = d[S][i]+d[i][G1]+d[i][G2];\n\t\t\t\tans = min(ans, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\nconst int INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n){\n\t\tint d[101][101];\n\t\trep(i, 101)rep(j, 101)d[i][j] = (i == j ? 0 : INF);\n\t\t\n\t\trep(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = d[b2][b1] = c;\n\t\t}\n\n\t\tFor(k,1, n+1)For(i,1, n+1)For(j,1, n+1){\n\t\t\tif (d[i][k] + d[k][j] <= d[i][j]){\n\t\t\t\td[i][j] = d[i][k] + d[k][j];\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tFor(k, 1, n + 1){\n\t\t\tint tmp = 0;\n\t\t\ttmp += d[s][k];\n\t\t\ttmp += d[k][g1];\n\t\t\ttmp += d[k][g2];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dest, cost; \n    edge(int s, int t, int c): src(s), dest(t), cost(c) {}\n};\nconst int INF = 1e8;\n\nvoid warshall_floyd(vector<vector<int> > &d, vector<edge> &edges) {\n    for(size_t i=0; i<d.size(); ++i) {\n        d[i].assign(d[i].size(), INF);\n        d[i][i] = 0;\n    }\n    for(auto &e : edges) {\n        d[e.src][e.dest] = e.cost;\n    }\n    const size_t n = d.size();\n    for(size_t j=0; j<n; ++j) {\n        for(size_t i=0; i<n; ++i) {\n            for(size_t k=0; k<n; ++k) {\n                d[i][k] = min(d[i][k], d[i][j] + d[j][k]);\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<edge> edges;\n        vector<vector<int> > d(n, vector<int>(n, INF));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges.push_back(edge(b1-1, b2-1, c));\n        }\n        warshall_floyd(d, edges);\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint cost[105][105];\nint d[105][105];\t\t\t\t// 頂点 s からの最短距離\n\n// 始点 s から各頂点への最短距離を求める\n//int V;\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\td[i][j] = cost[i][j];\n\t\t} // end rep\n\t} // end rep\n\n\trep (i, V ) d[i][i] = 0;\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (cost, 0, sizeof (cost) );\n\t\trep (i, n ) rep (j, n ) cost[i][j] = INF;\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\tcost[from][to] = c;\n//\t\t\tcost[to][from] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\t\twarshall_floyd (n );\n/*\n\t\trep (i, n ){\n\t\t\trep (j, n ){\n\t\t\t\tif (d[i][j] == INF ){\n\t\t\t\t\tcout << \"INF\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << setw(3) << d[i][j];\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tcout << endl;\n\t\t} // end rep\n*/\n\t\trep (i, n ){\n\t\t\tint curr = d[s][i] + d[i][g1] + d[i][g2];\n\t\t\tres = min (res, curr );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<string.h>\n#include<map>\n#include<utility>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef vector<string> VS;\nVS wrap(VS v,char c) {\n\tint R = v.size(), C = v[0].size();\n\tVS ret(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)ret[i + 1][j + 1] = v[i][j];\n\treturn ret;\n}\nconst int dr[] = { 0,0,1,-1 };\nconst int dc[] = { 1,-1,0,0 };\ntypedef long long LL;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF = 1e14;\nint main() {\n\tint N, M, S, A, B;\n\twhile (cin>>N >> M >> S >> A >> B, N + M + S + A + B) {\n\t\tVV d(N , V(N,INF));\n\t\tREP(i, N)d[i][i] = 0;\n\t\tREP(i, M) {\n\t\t\tint a, b,c;\n\t\t\tcin >> a >> b>>c;\n\t\t\td[a - 1][b - 1] =c;\n\t\t}\n\t\tREP(k, N)REP(i, N)REP(j, N)d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tLL res = INF;\n\t\tREP(i, N)res = min(res, d[S-1][i] + d[i][A-1] + d[i][B-1]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\ts--; g1--; g2--;\n\t\tint d[100][100];\n\t\trep(i, 100) {\n\t\t\trep(j, 100) {\n\t\t\t\td[i][j] = (int)MOD;\n\t\t\t\tif (i == j)d[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, z; cin >> x >> y >> z; x--; y--;\n\t\t\td[x][y] = min(d[x][y], z);\n\t\t}\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = (int)MOD;\n\t\trep(i, n) {\n\t\t\tmi = min(mi, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000\nusing namespace std;\n\nint main(){\n\tint n;\n\tint s;\n\tint m;\n\tint g1;\n\tint g2;\n\tint cost[101][101];\n\tint x,y,c,res;\n\twhile(1){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n == 0)break;\n\t\tres = INF;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t\tcost[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> x >> y >> c;\n\t\t\tcost[x][y] = c;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= n;j++){\n\t\t\t\tfor(int k = 1;k <= n;k++){\n\t\t\t\t\tcost[j][k] = min(cost[j][k],cost[j][i] + cost[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tres = min(res,cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int>P;\nint N,M,S,G1,G2,C[105][105],d[105],R,t;\nvoid dij(int f)\n{\n\t\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tfill(d,d+N,INF);\n\td[f]=0;\n\tQ.push(P(0,f));\n\tfor(;!Q.empty();)\n\t{\n\t\tP p=Q.top();Q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(int i=0;i<N;i++)\n\t\t\tif(C[v][i]&&d[i]>d[v]+C[v][i])\n\t\t\t{\n\t\t\t\td[i]=d[v]+C[v][i];\n\t\t\t\tQ.push(P(d[i],i));\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%d%d%d\",&N,&M,&S,&G1,&G2),N;)\n\t{\n\t\tS--;G1--;G2--;R=INF;\n\t\tmemset(C,0,sizeof(C));\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint f,t,c;\n\t\t\tscanf(\"%d%d%d\",&f,&t,&c);\n\t\t\tf--;t--;\n\t\t\tC[f][t]=c;\n\t\t}\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tt=0;\n\t\t\tdij(S);\n\t\t\tt+=d[i];\n\t\t\tdij(i);\n\t\t\tt+=d[G1]+d[G2];\n\t\t\tR=min(R,t);\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=101;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<=n;i++ ) {\n    for( int j=0;j<=n;j++ ) {\n      pipe[i][j]=INF;\n    }\n    pipe[i][i]=0;\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    cin >> b1 >> b2 >> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    warshallFloyd(g, n);\n    \n    int ans = -1;\n    REP(i, n){\n        if(g[s][i] != -1 && g[i][g1] != -1 && g[i][g2] != -1){\n            int cost = g[s][i] + g[i][g1] + g[i][g2];\n            ans = ans == -1 ? cost : min(ans, cost);\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n){\n            if(i == j) g[i][j] = 0;\n            else g[i][j] = -1;\n        }\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m, s, g1, g2, b1, b2, c;\n  long long int INF = 1e15;\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    --s;--g1;--g2;\n    vector< vector<long long int> > G(n,vector<long long int>(n,INF));\n    for(int i = 0; i < m; ++i){\n      cin >> b1 >> b2 >> c;\n      --b1;--b2;\n      G[b1][b2] = c;\n    }\n    for(int k = 0; k < n; ++k)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n          G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      ans = min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dest, cost; \n    edge(int s, int t, int c): src(s), dest(t), cost(c) {}\n};\nconst int INF = 1e8;\n\nvoid warshall_floyd(vector<vector<int> > &d, vector<edge> &edges) {\n    for(size_t i=0; i<d.size(); ++i) {\n        d[i].assign(d[i].size(), INF);\n        d[i][i] = 0;\n    }\n    for(size_t i=0; i<edges.size(); ++i) {\n        edge e = edges[i];\n        d[e.src][e.dest] = e.cost;\n    }\n    for(size_t j=0; j<d.size(); ++j) {\n        for(size_t i=0; i<d.size(); ++i) {\n            for(size_t k=0; k<d.size(); ++k) {\n                d[i][k] = min(d[i][k], d[i][j] + d[j][k]);\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<edge> edges;\n        vector<vector<int> > d(n, vector<int>(n, INF));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges.push_back(edge(b1-1, b2-1, c));\n        }\n        warshall_floyd(d, edges);\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#define INF 1<<29\n#define MAX 3000\nusing namespace std;int cost[MAX][MAX],V,d[MAX];bool used[MAX];void dijkstra(int);int main(){int m,s,g1,g2,b1,b2,c;while(true){cin >> V >> m >> s >> g1 >> g2;if(V == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)break;for(int i=1;i<=V;i++){for(int j=1;j<=V;j++){cost[i][j]=INF;}}for(int i=0;i<m;i++){cin >> b1 >> b2 >> c;cost[b1][b2]=c;}dijkstra(s);int ans = d[g1]+d[g2];int dr[MAX];for(int i=1;i<=V;i++)dr[i]=d[i];for(int i=1;i<=V;i++){if(i == s)continue;dijkstra(i);ans = min(ans,dr[i]+d[g1]+d[g2]);}cout << ans << endl;}}void dijkstra(int s){for(int i=1;i<=V;i++){d[i]=INF;used[i]=false;}d[s] = 0;while(true){int v=-1;for(int u=1;u<=V;u++){if(!used[u] && (v == -1 || d[u] < d[v]))v = u;}if(v == -1)break;used[v]=true;for(int u=1;u<=V;u++){d[u]=min(d[u],d[v]+cost[v][u]);}}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint n, m, s, g1, g2;\nint d[128][128];\n\nint inf = (1 << 29);\n\n#include <algorithm>\nbool load() {\n  for(int i = 0; i < 128; ++i) {\n    for(int j = 0; j < 128; ++j) {\n      d[i][j] = inf;\n    }\n    d[i][i] = 0;\n  }\n  scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n  if( n == 0 ) return false;\n  for(int i = 0; i < m; ++i) {\n    int x, y, w;\n    scanf(\"%d %d %d\", &x, &y, &w);\n    d[x][y] = w;\n  }\n  return true;\n}\n\nvoid solve() {\n  for(int k = 1; k <= n; ++k) {\n    for(int i = 1; i <= n; ++i) {\n      for(int j = 1; j <= n; ++j) {\n        d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n  int res = inf;\n  for(int i = 1; i <= n; ++i) {\n    res = std::min(res, d[s][i] + d[i][g1] + d[i][g2]);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  while( load() ) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main()\n{\n\tint n,m,s,g1,g2,b1,b2,c,i,j,k,d[101][101],V=INT_MAX/2;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n)\n\t{\n\t\tfor(i=1;i<=n;d[i][i]=0,++i)for(j=1;j<=n;++j)d[i][j]=V;\n\t\twhile(m--)scanf(\"%d%d%d\",&b1,&b2,&c),d[b1][b2]=d[b2][b1]=c;\n\t\tfor(k=1;k<=n;++k)for(i=1;i<=n;++i)for(j=1;j<=n;++j)\n\t\t\tc=d[i][k]+d[k][j],d[i][j]=(d[i][j]<c?d[i][j]:c);\n\t\tfor(c=V,i=1;i<=n;++i)\n\t\t\tk=d[i][s]+d[i][g1]+d[i][g2],c=(c<k?c:k);\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nconst int INF = 100000000;\nint adj[100][100];\nint radj[100][100];\n\nint main() {\n  int n,m,s,g1,g2,b1,b2,c;\n\n  while(cin>>n>>m>>s>>g1>>g2, n|m|s|g1|g2) {\n    memset(adj, INF, sizeof(adj));\n    memset(radj, INF, sizeof(radj));\n    s--,g1--,g2--;\n\n    for(int i=0; i<100; ++i)\n      for(int j=0; j<100; ++j) {\n\tadj[i][j] = INF;\n\tradj[i][j] = INF;\n      }\n\n    for(int i=0; i<100; ++i)\n      adj[i][i] = 0;\n\n    for(int i=0; i<m; ++i) {\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      adj[b1][b2] = c;\n      radj[b2][b1] = c;\n    }\n\n\n    for(int k=0; k<n; ++k) {\n      for(int i=0; i<n; ++i) {\n\tfor(int j=0; j<n; ++j) {\n\t  adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t  radj[i][j] = min(radj[i][j], radj[i][k]+radj[k][j]);\n\t}\n      }\n    }\n\n    int minc = INF;\n    for(int i=0; i<n; ++i) {\n      minc = min(minc, (adj[s][i]+adj[i][g1]+adj[i][g2]));\n    }\n\n    cout<<minc<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(){\n  int n, m, s, g1, g2, b1, b2, c;\n  long long int INF = 1e12;\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    --s;--g1;--g2;\n    vector< vector<long long int> > G(n,vector<long long int>(n,INF));\n    for(int i = 0; i < n; ++i) G[i][i] = 0;\n    for(int i = 0; i < m; ++i){\n      cin >> b1 >> b2 >> c;\n      --b1;--b2;\n      G[b1][b2] = c;\n    }\n    for(int k = 0; k < n; ++k)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n          G[i][j] = min(G[i][j],G[i][k] + G[k][j]);\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i){\n      ans = min(ans,G[s][i]+G[i][g1]+G[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define fst first\n#define scn second\nint main(){\n\twhile(true){\n\t\tint n,m,s,g1,g2;\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n==0)\tbreak;\n\t\ts--;\tg1--;\tg2--;\n\t\tvector<vector<int>> dist(n,vector<int>(n,1e9));\n\t\tfor(int i=0;i<n;i++)\tdist[i][i]=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint f,t,d;\tcin>>f>>t>>d;\n\t\t\tf--;\tt--;\n\t\t\tdist[f][t]=d;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=1e9;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tret=min(ret,dist[s][i]+dist[i][g1]+dist[i][g2]);\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 100000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\nint d[101][101];\n//int path[101][101];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2){\n\t\tif(n==0&&m==0&&s==0&&g1==0&&g2==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t\t//path[i][j]=i;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t\t//path[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2]=c;\n\t\t\td[b2][b1]=c;\n\t\t\t}\n\t\tfor(int k=1; k<=n; ++k){\n\t\t\tfor(int i=1; i<=n; ++i){\n\t\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\t\tif(d[i][j]>d[i][k]+d[k][j]){\n\t\t\t\t\t\td[i][j]=d[i][k]+d[k][j];\n\t\t\t\t\t\t//path[i][j]=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//cout << d[1][3] << \"\\n\";\n\t\tvector<int> g1_path;\n\t\tfor(int i=g1; i!=s&&i!=INF; i=path[s][i]){\n\t\t\t//cout << path[s][i] << \"\\n\";\n\t\t\tg1_path.push_back(i);\n\t\t}\n\t\tg1_path.push_back(s);\n\t\tvector<int> g2_path;\n\t\tfor(int i=g2; i!=s&&i!=INF; i=path[s][i]){\n\t\t\tg2_path.push_back(i);\n\t\t}\n\t\tg2_path.push_back(s);\n\t\tlong long int ans=INF;\n\t\tfor(int i=0; i<g1_path.size(); ++i){\n\t\t\tif(ans>d[s][g1]+d[i][g2]) {\n\t\t\t\tcout << d[s][g1] << \" \" << d[i][g2] << \"\\n\";\n\t\t\t\tans=d[s][g1]+d[i][g2];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<g2_path.size(); ++i){\n\t\t\tif(ans>d[s][g2]+d[i][g1]) {\n\t\t\t\tcout << d[s][g2] << \" \" << d[i][g1] << \"\\n\";\n\t\t\t\tans=d[s][g2]+d[i][g1];\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tlong long int ans=INF;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tif(ans>d[i][s]+d[i][g1]+d[i][g2]) ans=d[i][s]+d[i][g1]+d[i][g2];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nconst int kN = 105;\nint atl[kN][kN];\n\nvoid warshallFloyd(int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                atl[i][j] = min(atl[i][j], atl[i][k] + atl[k][j]);\n            }\n        }\n    }\n}\n\nint requestCost(int n, int s, int g1, int g2){\n    int retval = INF;\n    range(i,0,n + 1){\n        int cost = atl[s][i] + atl[i][g1] + atl[i][g2];\n        retval = min(retval, cost);\n    }\n    return retval;\n}\n\nint main(){\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n||m||s||g1||g2){\n        rep(i,kN) rep(j,kN) atl[i][j] = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            atl[a][b] = c;\n            atl[b][a] = c;\n        }\n        warshallFloyd(n);\n        cout << requestCost(n, s, g1, g2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dst, cost; \n    edge(int s, int t, int c): src(s), dst(t), cost(c) {}\n};\nconst int INF = 1e8;\n\nvoid warshall_floyd(vector<vector<int> > &d, vector<edge> &edges) {\n    for(size_t i=0; i<d.size(); ++i) {\n        d[i].assign(d[i].size(), INF);\n        d[i][i] = 0;\n    }\n    for(auto &e : edges) {\n        d[e.src][e.dst] = e.cost;\n    }\n    const size_t n = d.size();\n    for(size_t j=0; j<n; ++j) {\n        for(size_t k=0; k<n; ++k) {\n            for(size_t i=0; i<n; ++i) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    for(size_t j=0; j<n; ++j) {\n        for(size_t k=0; k<n; ++k) {\n            for(size_t i=0; i<n; ++i) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n    for(size_t j=0; j<n; ++j) {\n        for(size_t k=0; k<n; ++k) {\n            for(size_t i=0; i<n; ++i) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<edge> edges;\n        vector<vector<int> > d(n, vector<int>(n, INF));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges.push_back(edge(b1-1, b2-1, c));\n        }\n        warshall_floyd(d, edges);\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 127, sizeof(z));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n#include<cmath>\n#include<string>\n#include<cstdlib>\n#include<list>\nusing namespace std;\n\n#define rep(i,n) for(i=0;i<n;i++)\n#define rep2(i,n) for(i=1;i<=n;i++)\n\nint main()\n{\n\tint n,m,s,g1,g2;\n\tint i,j,k;\n\tint M=10000000;\n\t\n\twhile(1){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0 && m == 0 && s ==0 && g1 ==0 &&g2==0) break;\n\t\tint a[101][101];\n\t\tint c[101][101];\n\t\t\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=n;j++){\n\t\t\t\ta[i][j]=M;\n\t\t\t\tc[i][j]=M;\n\t\t\t\tif(i==j) c[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tint in1,in2,in3;\n\t\t\tcin >> in1 >> in2 >> in3;\n\t\t\tc[in1][in2] = in3;\n\t\t}\n\t\t\n\t\tfor(k=1;k<=n;k++){\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\t\tc[i][j] = min(c[i][j], c[i][k] + c[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mn=M;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tmn= min(mn, c[s][i] + c[i][g1] + c[i][g2]);\n\t\t}\n\t\t\n\t\tcout << mn << endl;\n\t\t\t\t\n\t\t\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct{\n\tint from;\n\tint to;\n\tint cost;\n}edge;\n\n\nint cmp(const void* a, const void* b){\n\tedge *e1 = (edge *)a;\n\tedge *e2 = (edge *)b;\n\treturn e1->cost - e2->cost;\n}\nint t[100], r[100];\nvoid init(int n){\n\tint i;\n\tfor(i = 0;i < n;i++){\n\t\tt[i] = i;\n\t\tr[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x == t[x]) return x;\n\telse return t[x] = find(t[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(r[x] > r[y])\n\t\tt[y] = x;\n\telse if(r[x] < r[y])\n\t\tt[x] = y;\n\telse if(x != y){\n\t\tt[y] = x;\n\t\tr[x]++;\n\t}\n}\n\nint main(void){\n\tint n, m, s, c, g1, g2, b1, b2, i, j, k, a, sum, v[100], cnt;\n\tedge e[1000];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\ts--, g1--, g2--;\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\te[i].from = b1 - 1, e[i].to = b2 - 1, e[i].cost = c;\n\t\t}\n\t\tqsort(e,m,sizeof(e[0]),cmp);\n\t\tinit(n);\n\t\ta = m;\n\t\tfor(i = 0;i < m && a != 1;i++){\n\t\t\tif(find(e[i].from) != find(e[i].to))\n\t\t\t\tunite(e[i].from,e[i].to);\n\t\t\telse{\n\t\t\t\tfor(j = i;j < m - 1;j++)\n\t\t\t\t\te[j] = e[j + 1];\n\t\t\t\tm--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\ta = 0;\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tif(t[j] == j) a++;\n\t\t}\n\t\tm = i;\n//\t\tfor(i = 0;i < m;i++)\n//\t\t\tprintf(\"%d -> %d : %d\\n\",e[i].from,e[i].to,e[i].cost);\n\t\tmemset(v,0,sizeof(v));\n\t\tfor(i = 0;i < m;i++)\n\t\t\tv[e[i].from]++, v[e[i].to]++;\n\t\tcnt = 0;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tif(v[i] == 1 && i != g1 && i != g2 && i != s) cnt++;\n\t\twhile(cnt){\n\t\t\tfor(i = 0;i < n;i++){\n\t\t\t\tif(v[i] == 1 && i != g1 && i != g2 && i != s){\n\t\t\t\t\tfor(j = 0;j < m;j++){\n\t\t\t\t\t\tif(i == e[j].from || i == e[j].to){\n\t\t\t\t\t\t\tfor(k = j;k < m;k++)\n\t\t\t\t\t\t\t\te[k] = e[k + 1];\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t\tm--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(v,0,sizeof(v));\n\t\t\tfor(j = 0;j < m;j++)\n\t\t\t\tv[e[j].from]++,v[e[j].to]++;\n\t\t\tcnt = 0;\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tif(v[j] == 1 && j != g1 && j != g2 && j != s) cnt++;\n\t\t}\n\t\tsum = 0;\n\t\tfor(i = 0;i < m;i++)\n\t\t\tsum += e[i].cost;\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\n#define INF 1e+9\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\n\nint main(){\n    int n,m,s,g1,g2;\n\n    while(cin >> n >> m >> s >> g1 >> g2){\n        if((n|m|s|g1|g2) == 0) break;\n        int cost[n][n];\n        int ret = INF;\n        int src,dst,c;\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j] = INF;\n            }\n        }\n\n        for(int i=0;i<n;i++) cost[i][i] = 0;\n\n        //load roads lol\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> c;\n            cost[src-1][dst-1] = c;\n        }\n\n        //WF\n        for(int r=0;r<n;r++){\n            for(int p=0;p<n;p++){\n                for(int q=0;q<n;q++){\n                    cost[p][q] = min(cost[p][q], cost[p][r] + cost[r][q]);\n                }\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            ret = min(ret, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 99999999;\n\nvoid solve()\n{\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2)\n\t{\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tint d[101][101];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint From, To, Cost;\n\t\t\tcin >> From >> To >> Cost;\n\t\t\t--From;\n\t\t\t--To;\n\t\t\td[From][To] = Cost;\n\t\t}\n\t\tfor(int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tMin = min(Min, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << Min << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(res, res + 3, dp[v]);\n\t\treturn;\n\t}\n\tfill_n(res, 3, INF);\n\tif (v == g1)\n\t{\n\t\tres[0] = 0;\n\t\treturn;\n\t}\n\telse if (v == g2)\n\t{\n\t\tres[1] = 0;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tmin_swap(res[2], res[0] + res[1]);\n\n\tcopy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tll m[100][100]; fill(m[0], m[100], linf);\n\t\tREP(i, N) m[i][i] = 0;\n\t\tREP(i, M) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tm[a][b] = min(m[a][b], c);\n//\t\t\tm[b][a] = min(m[b][a], c);\n\t\t}\n\t\tREP(k, N) REP(i, N) REP(j, N) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\tll ans = linf;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, m[s][i]+m[i][g1]+m[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define INF (1<<29)\n\nint main()\n{\n    int N, M, s, g1, g2;\n    while (cin >> N >> M >> s >> g1 >> g2, N) {\n        s--; g1--; g2--;\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            d[a][b] = d[b][a] = c;\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        int res = INF;\n        for (int i = 0; i < N; i++) {\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e9;\n\n\n\nint main() {\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tll cost[100][100]; fill(cost[0], cost[100], inf);\n\t\tfor (int i = 0; i < N; ++i) cost[i][i] = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tcost[a][b] = cost[b][a] = c;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\n\nint c[100][100];\nint dp[100][100];\n\nint main()\n{\n\tfor(;;) {\n\t\tint n, m, s, g1, g2;\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2);\n\t\ts--; g1--; g2--;\n\t\tif(n==0) return 0;\n\t\trep(i, 100) rep(j, 100) c[i][j] = -1;\n\t\trep(i, m) {\n\t\t\tint b1, b2, tc;\n\t\t\tscanf(\"%d%d%d\", &b1, &b2, &tc);\n\t\t\tb1--; b2--;\n\t\t\tc[b1][b2] = tc;\n\t\t}\n\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\tif(c[i][k]!=-1 && c[k][j]!=-1) {\n\t\t\t\tint t = c[i][k] + c[k][j];\n\t\t\t\tif(c[i][j]==-1 || c[i][j]>t) c[i][j] = t;\n\t\t\t}\n\t\t}\n\t\tint mn = -1;\n\t\trep(k, n) {\n\t\t\tif(c[s][k]!=-1 && c[k][g1]!=-1 && c[k][g2]!=-1) {\n\t\t\t\tint t = c[s][k] + c[k][g1] + c[k][g2];\n\t\t\t\tif(mn==-1 || mn>t) mn = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", mn);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nconst int kN = 105;\nint atl[kN][kN];\n\nvoid warshallFloyd(int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                atl[i][j] = min(atl[i][j], atl[i][k] + atl[k][j]);\n            }\n        }\n    }\n}\n\nint requestCost(int n, int s, int g1, int g2){\n    int retval = INF;\n    range(i,1,n + 1){\n        int cost = atl[s][i] + atl[i][g1] + atl[i][g2];\n        retval = min(retval, cost);\n    }\n    return retval;\n}\n\nint main(){\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n||m||s||g1||g2){\n        rep(i,kN) rep(j,kN) atl[i][j] = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            atl[a][b] = c;\n        }\n        warshallFloyd(n);\n        cout << requestCost(n, s, g1, g2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    int d[1000][1000];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)d[i][j]=1e9;\n    for(int i=0,a,b,c;i<m;i++)\n      cin>>a>>b>>c,d[a][b]=c;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<n;k++)\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n    int ans=1e9;\n    for(int i=0;i<n;i++)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint main()\n{\n  int n,m,s,g1,g2,a,b,cost,mi;\n  int map[101][101];\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<n+1;i++){\n      for(int j=0;j<n+1;j++){\n    if(i==j)map[i][j]=0;\n    else map[i][j]=1000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>cost;\n      map[a-1][b-1]=cost;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n    for(int k=0;k<n;k++){\n      map[j][k]=min(map[j][k],map[j][i]+map[i][k]);\n    }\n      }\n    }\n    mi=1000000;\n    for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]);\n    cout<<mi<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e5\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n    int i,j,k;\n    int n,m,s,g1,g2;\n    int v[100][100];\n    while(cin >> n >> m >> s >> g1 >> g2, n){\n        s--;g1--;g2--;\n        rep(i,n)rep(j,n){\n            if(i == j) v[i][j] = 0;\n            else v[i][j] = INF;\n        }\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v[a][b] = c;\n            v[b][a] = c;\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n        }\n        int ans = INF;\n\n        rep(i,n){\n            ans = min(ans, v[s][i] + v[i][g1] + v[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint V, E, S, G1, G2, B1, B2, C;\n\nvector<vector<int> > G;\n\nvector<vector<int> > R;\n\nvoid Shortest(int s, int mode, int rev)\n{\n\tvector<bool> u(V, false); R[mode][s] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1, c = 99999999;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[i] && R[mode][i] < c)\n\t\t\t{\n\t\t\t\tc = R[mode][i]; v = i;\n\t\t\t}\n\t\t}\n\n\t\tif (c == 99999999) { break; }\n\n\t\tu[v] = true;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tif (!u[v])\n\t\t\t{\n\t\t\t\tif (R[mode][i] > R[mode][v] + (rev ? G[i][v] : G[v][i]))\n\t\t\t\t{\n\t\t\t\t\tR[mode][i] = R[mode][v] + (rev ? G[i][v] : G[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint V, E, S, G1, G2, B1, B2, C;\n\n\twhile (true)\n\t{\n\t\tcin >> V >> E >> S >> G1 >> G2;\n\n\t\tif (V == 0) { break; }\n\n\t\tG = vector<vector<int> >(V, vector<int>(V, 99999999));\n\n\t\tfor (int i = 0; i < E; i++)\n\t\t{\n\t\t\tcin >> B1 >> B2 >> C;\n\n\t\t\tG[B1 - 1][B2 - 1] = C;\n\t\t}\n\t\t\n\t\tR = vector<vector<int> >(3, vector<int>(V, 99999999));\n\n\t\tShortest(S - 1, 0, 0);\n\t\tShortest(G1 - 1, 1, 1);\n\t\tShortest(G2 - 1, 2, 1);\n\n\t\tint ret = 299999997;\n\n\t\tfor (int i = 0; i < V; i++)\n\t\t{\n\t\t\tret = min(ret, R[0][i] + R[1][i] + R[2][i]);\n\t\t}\n\n\t\tcout << ret << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int inf = 1 << 29;\n\nint n, m, s, g1, g2;\nvector<vector<int> > cost;\n\nint solve(){\n    rep(k, n)rep(i, n)rep(j, n){\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n    int res = inf;\n    for(int i=1; i<n; ++i)res = min(res, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n        n++;\n        cost.assign(n, vector<int>(n, inf));\n        rep(i, m){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            cost[b1][b2] = c;\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\nstatic const int INF = 1e9;\n\nvoid solve()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2)\n\t{\n\t\t--s; --g1; --g2;\n\t\tvector< vector<int> > d(n, vector<int>(n));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\t--from; --to;\n\t\t\td[from][to] = cost;\n\t\t}\n\t\tfor (int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n,m,s,g1,g2,a,b,cost;\n  int map[100][100];\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)map[i][j]=0;\n\telse map[i][j]=10000000;\n      }\n    }\n    for(int i=0;i<5;i++){\n      cin>>a>>b>>cost;\n      map[a-1][b-1]=cost;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  map[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t}\n      }\n    }\n    int mi=10000000;\n    for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]);\n    cout<<mi<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define int ll\n#define INF 999999999\n\nsigned main(){\n    int edge[110][110];\n    int v,e,s,g1,g2;\n    while(cin>>v>>e>>s>>g1>>g2&&v&&e&&s&&g1&&g2){\n        rep(i,110)rep(j,110)edge[i][j]=INF;\n        rep(i,110)edge[i][i]=0;\n        s--,g1--,g2--;\n        rep(i,e){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--,b--;\n            edge[a][b]=c;\n        }\n        \n        \n        rep(k,v){\n            rep(i,v){\n                rep(j,v){\n                    edge[i][j] = min(edge[i][j],edge[i][k]+edge[k][j]);\n                }\n            }\n        }\n        int mini=INF;\n        rep(i,v){\n            mini = min(edge[s][i]+edge[i][g1]+edge[i][g2],mini);\n        }\n        cout<<mini<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nconstexpr int MAX_N = 100;\nconstexpr int INF = (1 << 29);\nint dist[MAX_N][MAX_N];\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2 && n;) {\n\t\t--s; --g1; --g2;\n\t\tfill_n((int *)dist, sizeof(dist) / sizeof(int), INF);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tdist[from - 1][to - 1] = cost;\n\t\t}\n\n\t\tfor(int k = 0; k < n; ++k) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\t\tchmin(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tchmin(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\n\t\tassert(ans != INF);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n;){\n    vector<vector<int>> d(n, vector<int> (n, INF));\n\n    // directed graph\n    for(int i=0,b1,b2,c;i<m;++i){\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    for(int i=0;i<n;++i) d[i][i] = 0;\n\n    for(int k=0;k<n;++k)\n      for(int i=0;i<n;++i)\n        for(int j=0;j<n;++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    int ans = INT_MAX;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 110;\nconst int INF = 1e9;\n\nint n, m, s, g1, g2;\nint cost[MAX_V][MAX_V];\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++)\n    for(int j = 0 ; j < MAX_V ; j++) cost[i][j] = INF;\n}\n\nvoid wf(){\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }    \n}\n\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n    init();\n    s--, g1--, g2--;\n    int from, to, C;\n    for(int i = 0 ; i < m ; i++){\n      cin >> from >> to >> C;\n      cost[from-1][to-1] = C;\n    }\n    \n    wf();\n        \n    int ans = INF;\n    for(int i = 0 ; i < n ; i++){\n      ans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nbool used[128];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tfill_n(res, 3, INF);\n\t\n\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(res, res + 3, dp[v]);\n\t\treturn;\n\t}\n\telse if (v == g1)\n\t{\n\t\tres[0] = 0;\n\t\treturn;\n\t}\n\telse if (v == g2)\n\t{\n\t\tres[1] = 0;\n\t\treturn;\n\t}\n\n\tused[v] = true;\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tif (used[edge[v][i].to])\n\t\t\tcontinue;\n\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tused[v] = false;\n\tmin_swap(res[2], res[0] + res[1]);\n\n\tcopy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2&&n;) {\n\t\ts--, g1--, g2--;\n\t\tstatic const int N = 101;\n\t\tstatic int wf[N][N];\n\t\trep(i, 0, n)rep(j, 0, n)wf[i][j] = INF;\n\t\trep(i, 0, n)wf[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint s, d, w; cin >> s >> d >> w;\n\t\t\ts--, d--;\n\t\t\twf[s][d] = min(wf[s][d], w);\n\t\t}\n\n\t\trep(k, 0, n)rep(i, 0, n)rep(j, 0, n) {\n\t\t\tif (wf[i][k] != INF&&wf[k][j] != INF)\n\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(k, 0, n) {\n\t\t\tif (wf[s][k] != INF&&wf[k][g1] != INF&&wf[k][g2] != INF)\n\t\t\t\tchmin(ans, wf[s][k] + wf[k][g1] + wf[k][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\n  const long long int c_max = 10000000;\n\n  long long int n, m, s, g1, g2, b1, b2, c;\n\n  while( true ) {\n\n    cin >> n >> m >> s >> g1 >> g2;\n\n    if ( n == 0 ) break;\n    s--;\n    g1--;\n    g2--;\n\n    long long int map[100][100];\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tif ( i == j ) {\n\t  map[i][j] = 0;\n\t}else {\n\t  map[i][j] = c_max;\n\t}\n      }\n    }\n\n    for ( long long int i = 0; i < m; i++ ) {\n      cin >> b1 >> b2 >> c;\n      map[b1-1][b2-1] = c;\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tfor ( long long int k = 0; k < n; k++ ) {\n\t  map[j][k] = min( map[j][k], map[j][i] + map[i][k] );\n\t}\n      }\n    }\n\n    /*\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tcout << map[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    long long int ans = c_max;\n\n    for ( long long int i = 0; i < n; i++ ) {\n      ans = min( ans, map[s][i] + map[i][g1] + map[i][g2] );\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\tconst int INF = 1 << 25;\n\t\tint dis[128][128];\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\tdis[i][j] = i == j ? 0 : INF;\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tdis[a][b] = c;\n\t\t}\n\t\tfor (int k = 1; k <= n; ++k)\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t\tfor (int j = 1; j <= n; ++j)\n\t\t\t\t\tmin_swap(dis[i][j], dis[i][k] + dis[k][j]);\n\n\t\tint res = INF;\n\t\tfor (int k = 1; k <= n; ++k)\n\t\t\tmin_swap(res, dis[s][k] + dis[k][g1] + dis[k][g2]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MIN(X,Y) ((X)>(Y) ? (Y) : (X))\n\nint d[200][200];\n\nint main(void) {\n    while(1) {\n        int n,m,s,g1,g2;\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        if(!n) break;\n\n        s--, g1--, g2--;\n        memset(d, 0x3F, sizeof(d));\n\n        for(int i=0;i<m;i++) {\n            int b,e,c;\n            scanf(\"%d%d%d\",&b,&e,&c);\n            b--, e--;\n            d[b][e] = c;\n        }\n\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                for(int k=0; k<n; k++)\n                    d[j][k] = MIN(d[j][k], d[j][i] + d[i][k]);\n\n        int res=0x5FFFFFFF;\n        for(int i=0; i<n; i++)\n            res = MIN(d[s][i]+d[i][g1]+d[i][g2], res);\n        printf(\"%d\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n\n#define INF 1e+9\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define int long long\n\nusing namespace std;\n\nmain(){\n    int n,m,s,g1,g2;\n\n    while(cin >> n >> m >> s >> g1 >> g2){\n        if((n|m|s|g1|g2) == 0) break;\n        int cost[n][n];\n        int ret = 1e+18;\n        int src,dst,c;\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j] = INF;\n            }\n        }\n\n        for(int i=0;i<n;i++) cost[i][i] = 0;\n\n        //load roads lol\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> c;\n            cost[src-1][dst-1] = c;\n        }\n\n        //WF\n        for(int r=0;r<n;r++){\n            for(int p=0;p<n;p++){\n                for(int q=0;q<n;q++){\n                    cost[p][q] = min(cost[p][q], cost[p][r] + cost[r][q]);\n                }\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            ret = min(ret, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, s, g1, g2;\nint matrix[110][110];\n\nint main() {\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n) {\n    MEMSET(matrix, 0x0f);\n    s--; g1--; g2--;\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      f--; t--;\n      matrix[f][t] = c;\n      matrix[t][f] = c;\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      matrix[i][i] = 0;\n      matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n    }\n    int ans = 1 << 30;\n    REP(i, n) {\n      ans = min(ans, matrix[s][i] + matrix[i][g1] + matrix[i][g2]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n){\n\t\tvector<vector<int>> load(n + 1, vector<int>(n + 1, 1000000000));//from back to \n\t\tREP(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tload[b1][b2] = c;\n\t\t\tload[b2][b1] = c;\n\t\t}\n\t\tFOR(i, 1, n + 1){\n\t\t\tFOR(j, 1, n + 1){\n\t\t\t\tFOR(k, 1, n + 1){\n\t\t\t\t\tload[j][k] = min(load[j][k], load[j][i] + load[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\tFOR(i, 1, n + 1){\n\t\t\tans = min(ans,load[s][i]+load[i][g1]+load[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 101\n#define INF 1000000\n\nint main(void){\n  int n, m, s, g1, g2;\n  vector< vector<int> > g(MAX, vector<int>(MAX));\n\n  while(cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2){\n    for(int i=0; i < MAX; i++){\n      for(int j=0; j < MAX; j++){\n\tg[i][j] = INF;\n\tif(i == j) g[i][j] = 0;\n      }\n    }\n    for(int p=0; p < m; p++){\n      int x, y, c;\n      cin >> x >> y >> c;\n      g[x][y] = c;\n    }\n\n    for(int i=1; i < n+1; i++)\n      for(int j=1; j < n+1; j++)\n\tfor(int k=1; k < n+1; k++)\n\t  g[j][k] = min(g[j][k], g[j][i] + g[i][k]);\n\n    int ans = INF;\n    for(int p = 1; p < n+1; p++){\n      ans = min(g[s][p]+g[p][g1]+g[p][g2], ans);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX_N 101\n#define INF (1<<28)\n\nint n, m, s, g1, g2;\nint graph[MAX_N][MAX_N];\nint main() {\n    while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n || m || s || g1 || g2) {\n        for (int i = 0; i <= n; i++) \n            for (int j = 0; j <= n; j++) {\n                if (i == j) graph[i][j] = 0;\n                else graph[i][j] = INF;\n            }\n        for (int i = 0; i < m; i++) {\n            int b1, b2, c;\n            scanf(\"%d %d %d\", &b1, &b2, &c);\n            graph[b1][b2] = c;\n        }\n        for (int k = 1; k <= n; k++) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n                }\n            }\n        }\n\n        int min_cost = graph[s][g1] + graph[s][g2];\n        for (int i = 1; i <= n; i++) { // 分岐する点\n            min_cost = min(min_cost, graph[s][i] + graph[i][g1] + graph[i][g2]);\n        }\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 25)\n\nusing namespace std;\n\nint cost[100][100]; // begin, end\n\nvoid Dijkstra( int n, int s, int *minCost )\n{\n\tbool *end = new bool[n];\n\tminCost[s] = 0;\n\tend[s] = true;\n\twhile(true) {\n\t\tint ii = -1, nn = (INF);\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(end[i] && nn > minCost[i]) {\n\t\t\t\tnn = minCost[i];\n\t\t\t\tii = i;\n\t\t\t}\n\t\t}\n\t\tif(ii == -1) break;\n\t\tend[ii] = false;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(minCost[i] > minCost[ii] + cost[ii][i]) {\n\t\t\t\tminCost[i] = minCost[ii] + cost[ii][i];\n\t\t\t\tend[i] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main( void )\n{\n\tint minCost1[100], minCost2[100], minCost3[100];\n\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2) {\n\t\t--s; --g1; --g2;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tfill(cost[i], cost[i]+n, INF);\n\t\t\tminCost1[i] = minCost2[i] = minCost3[i] = INF;\n\t\t}\n\t\tfor(int i=0; i < m; ++i) {\n\t\t\tint bb, ee, cc;\n\t\t\tcin >> bb >> ee >> cc;\n\t\t\t--bb; --ee;\n\t\t\tcost[bb][ee] = cost[ee][bb] = cc;\n\t\t}\n\t\tDijkstra(n, s, minCost1);\n\t\tDijkstra(n, g1, minCost2);\n\t\tDijkstra(n, g2, minCost3);\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tans = min(ans, minCost1[i] + minCost2[i] + minCost3[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<set>\n\nusing namespace std;\n\nint main()\n{\n\tint n,m,s,g1,g2;\n\twhile(true)\n\t{\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0)break;\n\t\tvector<vector<long long> > dist(n,vector<long long>(n,100000000));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tdist[i][i]=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tb1--;\n\t\t\tb2--;\n\n\t\t\tdist[b1][b2]=c;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tdist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n\n\t\tint ans=100000000;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint tmp=dist[s-1][i]+dist[i][g1-1]+dist[i][g2-1];\n\t\t\tans=min(ans,tmp);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tint d[101][101];\n\t\tREP(i, 101)REP(j, 101) d[i][j] = i == j ? 0 : INF;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tint res = INF;\n\t\tREP(i, n)\n\t\t{\n\t\t\tchmin(res, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[111][111];\n  for(int i=0;i<111;i++){\n    for(int j=0;j<111;j++){\n      road[i][j]=INF;\n    }\n  }\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=1;k<=n;k++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=1;i<=m;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define M 10000\n\nusing namespace std;\n\nint Dijkstra(const vector< vector<int> >& data, int& s, int& g){\n  vector<bool> is_reached(data.size(), false);\n  vector<int> ans(data.size(), M);\n  ans[s] = 0;\n  int i, j;\n  i = s;\n  while(i != g){\n    is_reached[i] = true;\n    for(j=0; j<data[i].size(); ++j){\n      ans[j] = min(ans[j], ans[i] + data[i][j]);\n    }\n    for(i=-1, j=0; j<is_reached.size(); ++j){\n      if(!is_reached[j] && (i < 0 || ans[i] > ans[j])) i = j;\n    }\n  }\n  return ans[g];\n}\n\nint GetMinCost(const vector< vector<int> >& data, int& s, int g1, int g2){\n  int cost = Dijkstra(data, s, g1) + Dijkstra(data, s, g2);\n  for(int i=0; i<data.size(); ++i){\n    cost = min(cost, Dijkstra(data, s, i)\n\t       + Dijkstra(data, i, g1) + Dijkstra(data, i, g2));\n  }\n  return cost;\n}\n\nint main(){\n  int n, m, s, g1, g2;\n  int a, b, c;\n\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\n    --s;\n    --g1;\n    --g2;\n    vector< vector<int> > data(n, vector<int>(n, M));\n\n    for(int i=0; i<m; ++i){\n      cin >> a >> b >> c;\n      data[a-1][b-1] = c;\n    }\n    cout << GetMinCost(data, s, g1, g2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#define INF 1<<21\nusing namespace std;\nint d[128][128];\nint N, M;\n\nvoid warshall_floyd(){\n  for (int k = 0; k < N; k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    int s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n \n    if (!N&&!M&&!s&&!g1&&!g2) break;   \n    s--;g1--;g2--;\n    for (int i = 0; i < N; i++){\n      fill_n(d[i], N, INF);\n    }\n    for (int i = 0; i < M; i++){\n      int u, v, c;\n      cin >> u >> v >> c;\n      u--;v--;\n      d[u][v] = c;\n    }\n\n    warshall_floyd();\n    int res = INF;\n    for (int i = 0; i < N; i++){\n      res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 25;\nint d[100][100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 , n) {\n\t\ts-- , g1-- , g2--;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = (i == j) ? 0 : INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta-- , b--;\n\t\t\td[a][b] = d[b][a] = c;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = d[s][g1] + d[s][g2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == s) continue;\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n||m||s||g1||g2){\n    int i,j,k;\n    int b1,b2,c;\n    int d[105][105];\n    int inf = 1<<20;\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n\tif(i==j) d[i][j]=0;\n\telse d[i][j]=inf;\n      }\n    }\n    for(i=0;i<m;i++) {\n      cin >> b1 >> b2 >> c;\n      d[b1][b2]=c;\n    }\n    for(k=1;k<=n;k++){\n      for(i=1;i<=n;i++){\n\tif(d[i][k]==inf) continue;\n\tfor(j=1;j<=n;j++){\n\t  if(d[k][j]==inf) continue;\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t} \n      } \n    }\n    int o=inf;\n    for(i=1;i<=n;i++){\n      o=min(o,d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout << o << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, m, s, g1, g2;\nint c[101][101];\n\nint main(){\n\tint a1, a2, a3;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n != 0) {\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\t\tc[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a1 >> a2 >> a3;\n\t\t\tc[a1][a2] = a3;\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (c[i][j] > c[i][k] + c[k][j]) {\n\t\t\t\t\t\tc[i][j] = c[i][k] + c[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = c[s][g1] + c[s][g2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (ans > c[s][i] + c[i][g1] + c[i][g2]) {\n\t\t\t\tans = c[s][i] + c[i][g1] + c[i][g2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=101;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n    scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2);\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<=n;i++ ) {\n    for( int j=0;j<=n;j++ ) {\n      pipe[i][j]=INF;\n    }\n    pipe[i][i]=0;\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    scanf(\"%d%d%d\", &b1, &b2, &c);\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main ()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n + m + s + g1 + g2) {\n        vector<vector<int> > d(n + 1, vector<int>(n + 1, INF));\n        for (int i = 0; i <= n; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int gx, gy, c;\n            cin >> gx >> gy >> c;\n            d[gx][gy] = d[gy][gx] = c;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int  k = 1; k <= n; k++) {\n                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 1; i <= n; i++) {\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nvector<pair<int,int> > g[100];\nint ijk[100][100];\nbool v[100][100];\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a+b+c+d+e){\n\t\tfor(int i=0;i<100;i++)g[i].clear();\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q,r;\n\t\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t\tp--;\n\t\t\tq--;\n\t\t\tg[p].push_back(make_pair(q,r));\n\t\t}\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tijk[i][j]=99999999;\n\t\t\t\tv[i][j]=false;\n\t\t\t}\n\t\tijk[c-1][c-1]=0;\n\t\tpriority_queue<pair<int,pair<int,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(c-1,c-1)));\n\t\twhile(Q.size()){\n\t\t\tint cost=-Q.top().first;\n\t\t\tint at1=Q.top().second.first;\n\t\t\tint at2=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[at1][at2])continue;\n\t\t\tv[at1][at2]=true;\n\t\t\tif(at1==at2){\n\t\t\t\tfor(int i=0;i<g[at1].size();i++){\n\t\t\t\t\tif(!v[g[at1][i].first][g[at1][i].first]&&ijk[g[at1][i].first][g[at1][i].first]>cost+g[at1][i].second){\n\t\t\t\t\t\tijk[g[at1][i].first][g[at1][i].first]=cost+g[at1][i].second;\n\t\t\t\t\t\tQ.push(make_pair(-cost-g[at1][i].second,make_pair(g[at1][i].first,g[at1][i].first)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<g[at1].size();i++){\n\t\t\t\tif(!v[g[at1][i].first][at2]&&ijk[g[at1][i].first][at2]>cost+g[at1][i].second){\n\t\t\t\t\tijk[g[at1][i].first][at2]=cost+g[at1][i].second;\n\t\t\t\t\tQ.push(make_pair(-cost-g[at1][i].second,make_pair(g[at1][i].first,at2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<g[at2].size();i++){\n\t\t\t\tif(!v[at1][g[at2][i].first]&&ijk[at1][g[at2][i].first]>cost+g[at2][i].second){\n\t\t\t\t\tijk[at1][g[at2][i].first]=cost+g[at2][i].second;\n\t\t\t\t\tQ.push(make_pair(-cost-g[at2][i].second,make_pair(at1,g[at2][i].first)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ijk[d-1][e-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef int W;\nconst int MAXV = 1005;\nconst int MAXE = 5005;\nconst int INF = 100000000;\nint adj[100][100];\n\nint main() {\n  int n,m,s,g1,g2,b1,b2,c;\n\n  while(cin>>n>>m>>s>>g1>>g2, n|m|s|g1|g2) {\n    s--,g1--,g2--;\n\n\n    for(int i=0; i<100; ++i) {\n      for(int j=0; j<100; ++j)\n        adj[i][j] = INF;\n      adj[i][i] = 0;\n    }\n\n    for(int i=0; i<m; ++i) {\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      adj[b1][b2] = c;\n    }\n\n    for (int k = 0; k < n; ++k)\n      for (int i = 0; i < n; ++i) {\n        const int p = adj[i][k];\n        for (int j = 0; j < n; ++j)\n          adj[i][j] = min(adj[i][j], p + adj[k][j]);\n      }\n\n    int minc = INF;\n    for(int i=0; i<n; ++i)\n      minc = min(minc, (adj[s][i]+adj[i][g1]+adj[i][g2]));\n\n    cout<<minc<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define INF 1000000000\n\nint n,m,s,g1,g2;\nint t[101][101];\n\nint main(void){\n\twhile(cin>>n>>m>>s>>g1>>g2, n){\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=n;j++) t[i][j] = INF;\n\t\tfor(int i=1;i<=n;i++) t[i][i] = 0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,cost;\n\t\t\tcin>>a>>b>>cost;\n\t\t\tt[a][b] = cost;\n\t\t}\n\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tt[i][j] = min(t[i][j],t[i][k] + t[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans = min(ans,t[s][i]+t[i][g1]+t[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int INF = 1 << 28;\n\nint N, M, S, G1, G2;\nint B1[1000], B2[1000], C[1000];\n\nint graph[100][100];\n\nint solve() {\n    assert(N <= 100);\n    int min_dist[100][100];\n    for (int j = 0; j < N; ++j) { fill(min_dist[j], min_dist[j]+N, INF); min_dist[j][j] = 0; }\n    for (int j = 0; j < M; ++j) min_dist[B1[j]][B2[j]] = min_dist[B2[j]][B1[j]] = C[j];\n    \n    for (int l = 0; l < N; ++l) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                int cand = min_dist[j][l] + min_dist[l][k];\n                if (cand < min_dist[j][k]) min_dist[j][k] = cand;\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < N; ++j) {\n        int cand = min_dist[S][j] + min_dist[j][G1] + min_dist[j][G2];\n        if (cand < ans) {\n            ans = cand;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (true) {\n        cin >> N >> M >> S >> G1 >> G2;\n        if (N == 0 && M == 0 && S == 0 && G1 == 0 && G2 == 0) break;\n        --S; --G1; --G2;\n        for (int j = 0; j < M; ++j) {\n            cin >> B1[j] >> B2[j] >> C[j];\n            --B1[j]; --B2[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define ll long long\nconst int INF = 2 << 27;\n\nint main() {\n  while(1){\n    int n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n    s--;\n    g1--;\n    g2--;\n    int cost[n][n];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n        if(i == j) {\n          cost[i][j] = 0;\n        }\n        else {\n          cost[i][j] = INF;\n        }\n      }\n    }\n    for(int i = 0; i < m; i++) {\n      int b1,b2,c;\n      cin >> b1 >> b2 >> c;\n      cost[b1-1][b2-1] = c;\n      cost[b2-1][b1-1] = c;\n    }\n\n\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n        for (int k = 0; k < n; k++)\n          cost[j][k] = std::min(cost[j][k], cost[j][i] + cost[i][k]);\n    int ans = INF;\n    for(int i = 0; i < n; i++) {\n      ans = min(ans,cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    pma(g, n);\n    warshallFloyd(g, n);\n    pma(g, n);\n    \n    int ans = g[s][g1] + g[s][g2];\n    REP(i, n){\n        ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define\tINF 1000000000;\nusing namespace std;\nint mp[1001][1001];\nint d[1001][1001];\nint n,m,s,g1,g2;\n\n\nint main() {\n \n\n\n  while(1) {\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n\n    for(int i=0;i<=n;i++) \n      for(int j=0;j<=n;j++)\n\tif(i == j) mp[i][j] = 0;\n\telse mp[i][j] = INF;\n\n    for(int i=0;i<m;i++) {\n      int b1,b2,c;\n      cin >> b1 >> b2 >> c;\n      mp[b1][b2] = c;\n    }\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++) \n\tfor(int j=1;j<=n;j++)\n\t  mp[i][j] = min(mp[i][j] ,mp[i][k]+mp[k][j]);\n\n    int ans = INF;\n    for(int i=1;i<=n;i++){\n      int sum = 0;\n      sum = mp[s][i];\n      sum += mp[i][g1];\n      sum += mp[i][g2];\n\tif(ans > sum) ans = sum;\n    }\n    cout << ans << endl;\n    \n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF=1<<29;\nint main() {\n\tint n,m,s,g1,g2;\n\twhile(true){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0)\tbreak;\n\t\t--s; --g1; --g2;\n\t\tvector<vector<int> > a(n, vector<int>(n,INF) );\n\t\tfor(int i=0; i<n; ++i)\ta[i][i]=0;\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint f,t,c;\n\t\t\tcin >> f >> t >> c;\n\t\t\t--f; --t;\n\t\t\ta[f][t]=c;\n\t\t}\n\t\tfor(int j=0; j<n; ++j)for(int i=0; i<n; ++i)for(int k=0; k<n; ++k)\ta[i][k]=min(a[i][k], a[i][j]+a[j][k]);\n\t\tint ans=INF;\n\t\tfor(int i=0; i<n; ++i)\tans=min(ans, a[s][i]+a[i][g1]+a[i][g2]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n,m,s,g1,g2;\nint g[111][111];\n\nint main(void)\n{\n  for(;;) {\n    scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2); if(!n) break;\n    int res;\n    int a,b,c;\n    for(int i = 1; i <= n; i++) {\n      for(int j = 1; j <= n; j++) g[i][j] = (i==j?0:(100000000));\n    }\n    for(int i = 0; i < m; i++) {\n      scanf(\"%d%d%d\",&a,&b,&c);\n      g[a][b] = g[b][a] = c;\n    }\n    for(int k = 1; k <= n; k++) {\n      for(int i = 1; i <= n; i++) {\n\tfor(int j = 1; j <= n; j++) {\n\t  g[i][j] = min(g[i][j],g[i][k]+g[k][j]);\n\t}\n      }\n    }\n    res = 1000000000;\n    for(int i = 1; i <= n; i++) {\n      res = min(res,g[g1][i]+g[g2][i]+g[i][s]);\n    }\n    printf(\"%d\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1000000;\n\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool shortestPath(const Graph &g,\n        Matrix &dist, vector<vector<int> > &prev) {\n    int n = g.size();\n    Array h(n+1);\n    REP(k,n) REP(i,n) FOR(e,g[i]) {\n        if (h[e->dst] > h[e->src] + e->weight) {\n            h[e->dst] = h[e->src] + e->weight;\n            if (k == n-1) return false; // negative cycle\n        }\n    }\n    dist.assign(n, Array(n, INF));\n    prev.assign(n, vector<int>(n, -2));\n    REP(s, n) {\n        priority_queue<Edge> Q;\n        Q.push(Edge(s, s, 0));\n        while (!Q.empty()) {\n            Edge e = Q.top(); Q.pop();\n            if (prev[s][e.dst] != -2) continue;\n            prev[s][e.dst] = e.src;\n            FOR(f,g[e.dst]) {\n                if (dist[s][f->dst] > e.weight + f->weight) {\n                    dist[s][f->dst] = e.weight + f->weight;\n                    Q.push(Edge(f->src, f->dst, e.weight + f->weight));\n                }\n            }\n        }\n        REP(u, n) dist[s][u] += h[u] - h[s];\n    }\n}\n\nint main(){\n    while(true){\n        int n, m, s, g1, g2;\n        cin >> n >> m >> s >> g1 >> g2;\n        if(!n && !m) break;\n        s--; g1--; g2--;\n        Graph g(n);\n        REP(i,m) {\n            int a, b, w;\n            cin >> a >> b >> w;\n            g[a-1].push_back(Edge(a-1,b-1,w));\n        }\n\n        vector<vector<int> > prev;\n        Matrix dist;\n        shortestPath(g,dist,prev);\n\n        int min = 100000;\n        REP(i,n){\n            int len = dist[s][i] + dist[i][g1] + dist[i][g2];\n            if(len < min) min = len;\n        }\n        cout << min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint mdx[4]={0,1,0,-1},mdy[4]={-1,0,1,0};\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint n,m,s,g1,g2;\nint b1[1010],b2[1010],c[1010];\nint d[1010][1010];\nvector<int> vv;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n\t\tREP(i,1010)\n\t\t\tREP(j,1010)\n\t\t\t\td[i][j]=1e8;\n\t\tREP(i,1010)d[i][i]=0;\n\t\tREP(i,m){\n\t\t\tcin>>b1[i]>>b2[i]>>c[i];\n\t\t\td[b1[i]][b2[i]]=c[i];\n\t\t\t//d[b2[i]][b1[i]]=c[i];\n\t\t}\n\t\tfor(int k=1;k<=n;k++)\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tint ans=INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint t=d[s][i]+d[i][g1]+d[i][g2];\n\t\t\tans=min(ans,t);\n\t\t}\n\t\tvv.push_back(ans);\n\t}\n\tREP(i,vv.size())\n\t\tcout<<vv[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nint main(){\n    int N,M,s,g1,g2,a,b,c;\n    while(cin >> N >> M >> s >> g1 >> g2, N){\n\ts--; g1--; g2--;\n\tvector<vector<int> > d(N,vector<int>(N,INF));\n\tfor(int i = 0 ; i < N ; i++){\n\t    d[i][i] = 0;\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> a >> b >> c; a--; b--;\n\t    d[a][b] = c;\n\t}\n\tfor(int k = 0 ; k < N ; k++){\n\t    for(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n\t\t}\n\t    }\n\t}\n\tint res = INF;\n\tfor(int i = 0 ; i < N ; i++){\n\t    res = min(res,d[s][i]+d[i][g1]+d[i][g2]);\n\t}\n\tcout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int INF = INT_MAX / 3;\nvector<vector<int>> d;\n\nint main() {\n\twhile(1) {\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n == 0) break;\n\t\td.assign(n, vector<int>(n, INF));\t\n\t\n\t\tint from, to, cost;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tcin >> from >> to >> cost;\n\t\t\td[from][to] = cost;\n\t\t}\n\t\n\t\tfor(int k = 0; k < n; ++k)\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t\tfor(int j = 0; j < n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tint ans = INF;\n\t\tfor(int c = 0; c < n; ++c) {\n\t\t\tif(d[s][c] == INF || d[c][g1] == INF || d[c][g2] == INF) continue;\t\n\t\t\tint tmp = d[s][c] + d[c][g1] + d[c][g2];\t\n\t\t\tans = min(tmp, ans);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nvector<ll> dijkstra(int start, vector<vector<pair<int, ll>>>& graph) {\n    vector<ll> dist(graph.size(), INF); dist[start] = 0;\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq; pq.emplace(0, start);\n    while (!pq.empty()) {\n        ll cost; int idx; tie(cost, idx) = pq.top(); pq.pop();\n        if (dist[idx] < cost) continue;\n        for (auto next : graph[idx]) if (chmin(dist[next.first], cost + next.second)) pq.emplace(dist[next.first], next.first);\n    }\n    return dist;\n}\n\nvoid solve() {\n    int n, m, s, t[2]; scanf(\"%d %d %d %d %d\", &n, &m, &s, &t[0], &t[1]); if (n == 0) exit(0);\n    s--; t[0]--; t[1]--;\n    vector<vector<pair<int, ll>>> g(n);\n    for (int i = 0; i < m; i++) {\n        int u, v, w; scanf(\"%d %d %d\", &u, &v, &w);\n        u--; v--;\n        g[u].emplace_back(v, w);\n    }\n    vector<vector<ll>> d(n); for (int i = 0; i < n; i++) d[i] = dijkstra(i, g);\n    ll res = INF;\n    for (int i = 0; i < n; i++) {\n        ll sm = d[s][i] + d[i][t[0]] + d[i][t[1]];\n        chmin(res, sm);\n    }\n    printf(\"%lld\\n\", res);\n}\nint main()\n{\n    /*\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    */\n\n    int kkt = 89;\n    while (kkt) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ntemplate<typename T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n \ntemplate<typename T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n \n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n \n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n};\n\ntemplate<typename T> vector<T> dijkstra(Graph<T> &gr, int s){\n    using state = pair<T, int>;\n    priority_queue<state, vector<state>, greater<state>> que;\n    vector<T> d(gr.n, numeric_limits<T>::max());\n    d[s] = 0;\n    que.emplace(0, s);\n    while(!que.empty()){\n        state p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(edge<T> &e : gr.G[v]){\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.emplace(d[e.to], e.to);\n            }\n        }\n    }\n    return d;\n}\n\nint n, m, s, g1, g2;\n\nvoid solve(){\n    Graph<int> gr(n), gr_rev(n);\n    rep(i, m){\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        --a; --b;\n        gr.add_edge(a, b, c);\n        gr_rev.add_edge(b, a, c);\n    }\n    auto ds = dijkstra(gr, s), d1 = dijkstra(gr_rev, g1), d2 = dijkstra(gr_rev, g2);\n    lint ans = mod;\n    rep(i, n){\n        chmin(ans, (lint)ds[i] + d1[i] + d2[i]);\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main(){\n    while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n){\n        --s; --g1; --g2;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nconst int INF = 100000000;\nint adj[100][100];\n\nint main() {\n  int n,m,s,g1,g2,b1,b2,c;\n\n  while(cin>>n>>m>>s>>g1>>g2, n|m|s|g1|g2) {\n    s--,g1--,g2--;\n\n\n    for(int i=0; i<100; ++i) {\n      for(int j=0; j<100; ++j)\n\tadj[i][j] = INF;\n      adj[i][i] = 0;\n    }\n\n    for(int i=0; i<m; ++i) {\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      adj[b1][b2] = c;\n    }\n\n\n    for(int k=0; k<n; ++k)\n      for(int i=0; i<n; ++i)\n\tfor(int j=0; j<n; ++j)\n\t  adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\n    int minc = INF;\n    for(int i=0; i<n; ++i)\n      minc = min(minc, (adj[s][i]+adj[i][g1]+adj[i][g2]));\n\n    cout<<minc<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint G[100][100];\nint n;\n\nint solve(int s,int g1,int g2){\n  for(int k=0;k<n;++k)\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n\n  int ret = INF;\n  for(int t=0;t<n;++t)\n    ret = min(ret,G[s][t]+G[t][g1]+G[t][g2]);\n  return ret;\n}\n\nint main(){\n  int m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    for(int i=0;i<n;++i)\n      for(int j=0;j<n;++j)\n\tG[i][j] = 1<<29;\n    s--;g1--;g2--;\n    while(m--){\n      int a,b,c;\n      cin >> a >> b >> c;\n      a--;b--;\n      G[a][b] = c;\n    }\n    cout << solve(s,g1,g2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nsigned main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2) {\n\t\tg1--; g2--; s--;\n\t\tvector<vector<int> >d(n, vector<int>(n, INF));\n\t\trep(i, 0, n)d[i][i] = 0;\n\t\trep(i, 0, m) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c; b1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\trep(k, 0, n) {\n\t\t\trep(i, 0, n) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, 0, n)ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> VI;\ntypedef vector<VI> VVI;\nconst ll INF = numeric_limits<ll>::max() / 4;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tll n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2;\n\t\ts--; g1--; g2--;\n\t\tif (n == 0) break;\n\t\tVVI dis(n, vector<ll>(n, INF));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tdis[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tll tmp = dis[s][i] + dis[i][g1] + dis[i][g2];\n\t\t\tres = min(res, tmp);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2,hoge[101][101],a,b,c;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\thoge[i][j] = 1000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> c;\n      hoge[a][b] = c;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  if(hoge[j][k] > hoge[j][i] + hoge[i][k]){\n\t    hoge[j][k] = hoge[j][i] + hoge[i][k];\n\t  }\n\t}\n      }\n    }\n    int MIN=1000000;\n    for(int i=1;i<=n;i++)\n      MIN = min(MIN,hoge[s][i]+hoge[i][g1]+hoge[i][g2]);\n    cout << MIN << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define NUM_MAX 105\n#define INF INT_MAX/2\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0)return 0;\n\n\t\tint d[NUM_MAX][NUM_MAX];\n\t\trep(i, 0, n + 1) rep(j, 0, n + 1)\n\t\t{\n\t\t\tif (i == j)\n\t\t\t\td[i][j] = 0;\n\t\t\telse\n\t\t\t\td[i][j] = INF;\n\t\t}\n\n\t\trep(i, 0, m)\n\t\t{\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = c;\n\t\t}\n\n\t\trep(k, 0, n + 1) rep(i, 0, n + 1) rep(j, 0, n + 1)\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n\t\tint ans = INF;\n\t\trep(i, 1, n + 1) ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** Problem2005 : Water Pipe Construction **/\nint d[110][110];\nint V;\n\nvoid warshall_floyd()\n{\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint M, S, G1, G2;\n\twhile (cin>>V>>M>>S>>G1>>G2, V||M||S||G1||G2) {\n\t\tS--; G1--; G2--;\n\t\t\n\t\tfill(d[0], d[0]+110*110, INF);\n\t\trep(i, 110) {\n\t\t\td[i][i]=0;\n\t\t}\n\t\t\n\t\trep(i, M) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--; b--;\n\t\t\td[a][b]=c;\n\t\t}\n\t\t\n\t\twarshall_floyd();\n\t\n\t\tint ans=d[S][G1]+d[S][G2];\n\t\trep(i, V) {\n\t\t\t\tint tmp = d[S][i]+d[i][G1]+d[i][G2];\n\t\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF (1<<21)\nusing namespace std;\n\nint main(){\n  int i,j,k,n,m,s,g1,g2,d[101][101],ans;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(!n && !m && !s && !g1 && !g2) break;\n\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tif(i == j) d[i][j] = 0;\n\telse d[i][j] = INF;\n      }\n    }\n\n    for(j=0;j<m;j++){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      d[a][b] = cost;\n    }\n\n    for(k=0;k<=n;k++){\n      for(i=0;i<=n;i++){\n\tfor(j=0;j<=n;j++){\n\t  if(d[i][k] >= INF || d[k][j] >= INF) continue;\n\t  d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n\t}\n      }\n    }\n\n   int ans = INF;\n   for(i=1;i<=n;i++){\n       ans = min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n   }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<string.h>\n#include<map>\n#include<utility>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef vector<string> VS;\nVS wrap(VS v,char c) {\n\tint R = v.size(), C = v[0].size();\n\tVS ret(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)ret[i + 1][j + 1] = v[i][j];\n\treturn ret;\n}\nconst int dr[] = { 0,0,1,-1 };\nconst int dc[] = { 1,-1,0,0 };\ntypedef long long LL;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nconst LL INF = 1e14;\nint main() {\n\tint N, M, S, A, B;\n\twhile (cin>>N >> M >> S >> A >> B, N + M + S + A + B) {\n\t\tVV d(N , V(N,INF));\n\t\tREP(i, N)d[i][i] = 0;\n\t\tREP(i, M) {\n\t\t\tint a, b,c;\n\t\t\tcin >> a >> b>>c;\n\t\t\td[a - 1][b - 1] = d[b-1][a-1]=c;\n\t\t}\n\t\tREP(k, N)REP(i, N)REP(j, N)d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tLL res = INF;\n\t\tREP(i, N)res = min(res, d[S-1][i] + d[A-1][i] + d[B-1][i]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-9;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K >> L >> R;\n\tvector<int>ans;\n\twhile (N) {\n\t\tvector<vector<int>>edge(N, vector<int>(N,MOD));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tedge[i][i] = 0;\n\t\t}\n\t\tK--;\n\t\tL--;\n\t\tR--;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge[a][b] = c;\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (edge[K][i] == MOD || edge[i][L] == MOD || edge[i][R] == MOD)continue;\n\t\t\tret = min(ret, edge[K][i] + edge[i][L] + edge[i][R]);\n\t\t}\n\t\tans.push_back(ret);\n\t\tcin >> N >> M >> K >> L >> R;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    warshallFloyd(g, n);\n    // pma(g, n);\n    \n    int ans = -1;\n    REP(i, n){\n        if(g[s][i] != -1 && g[i][g1] != -1 && g[i][g2] != -1){\n            int cost = g[s][i] + g[i][g1] + g[i][g2];\n            ans = (ans == -1 ? cost : min(ans, cost));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N,M,S,G1,G2;\nint d[110][110] = {};\nint inf = 1e9;\n\nint main(){\n    while(cin >> N >> M >> S >> G1 >> G2 && N>0){\n        int b1,b2,c;\n        for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) d[i][j] = inf;\n        for(int i=0;i<M;i++){\n            cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n        for(int k=1;k<=N;k++){\n            for(int i=1;i<=N;i++){\n                for(int j=1;j<=N;j++){\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        int ans = inf;\n        for(int i=1;i<=N;i++){\n            for(int j=1;j<=N;j++){\n                ans = min({ans,d[S][i]+d[i][G1]+d[j][G2],d[S][j]+d[i][G1]+d[j][G2]});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<climits>\nusing namespace std;\n#define INF INT_MAX\n\nint n,m,s,g1,g2;\nvector< vector<long long> > edge;\n\nvoid init(){\n  n=m=s=g1=g2=0;\n  edge.clear();\n}\n\nbool input(){\n  cin>>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0){\n    return 0;\n  }\n  s--;g1--;g2--;\n  edge.resize(n+1);\n  for(int i=0;i<n+1;i++){\n    edge[i].resize(n+1);\n    for(int j=0;j<n+1;j++){\n      edge[i][j]=INF;\n    }\n  }\n  for(int i=0;i<m;i++){\n    long long  b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--;b2--;\n    edge[b1][b2]=c;\n  }\n  return 1;\n}\n\n\n\n\nint solve(){\n  for(int k=0;k<n+1;k++){\n    for(int i=0;i<n+1;i++){\n      for(int j=0;j<n+1;j++){\n        edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      }\n    }\n  }\n  long long res=INF;\n  for(int i=0;i<n+1;i++){\n    res=min(res,edge[s][i]+edge[i][g1]+edge[i][g2]);\n  }\n  return res;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tint n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tif(n == 0) break;\n\t\tint d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tint b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\n\nint main(){\n  int n, m, s, g1, g2;\n  while(cin >> n >> m >> s >> g1 >> g2 && n != 0){\n    vector< vector<int> > nodes(n, vector<int>(n, 1000001));\n    for(int i = 0; i < m; i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      nodes[a-1][b-1] = c;\n    }\n    for(int i = 0; i < n ; i++){\n      nodes[i][i] = 0;\n    }\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          nodes[i][j] = min(nodes[i][j],nodes[i][k] + nodes[k][j]);\n        }\n      }\n    }\n    int mini = 2000000;\n    for(int i = 0 ; i < n; i++){\n      mini = min(mini, nodes[s-1][i] + nodes[i][g1-1] + nodes[i][g2-1]);\n    }\n    cout << mini << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define BMAX 100\n#define DMAX 1000000\n\nusing namespace std;\n\nstruct data { \n\tint cost;\n\tint where;\n};\n\n//bool bind[BMAX][BMAX];\nint cost[BMAX][BMAX];\nbool check[BMAX];\n\nbool operator<( const data& a, const data& b) {\n\treturn a.cost < b.cost;\n}\n\nbool operator>( const data& a, const data& b) {\n\treturn a.cost > b.cost;\n}\n\nint main () {\n\tint count = 0;\n\twhile ( true ) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m>> s>> g1>> g2;\n\t\t//cout << \"Count: \" << count << endl;\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcost[i][j] = DMAX;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint x,y,c;\n\t\t\tcin >> x >> y >> c;\n\t\t\t//\t\t\tcout << x << \"\\t\" << y << \"\\t\" << c << endl;\n\t\t\tcost[x][y] = c;\n\t\t\tcost[y][x] = c;\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << cost[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\t\n\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tpriority_queue<data> flow;\n\n\t\t\twhile(!flow.empty()) {\n\t\t\t\tflow.pop();\n\t\t\t}\n\n\t\t\tdata now;\n\t\t\tnow.cost = 0;\n\t\t\tnow.where = i;\n\t\t\tflow.push(now);\n\n\t\t\twhile ( !flow.empty() ) {\n\t\t\t\tdata now = flow.top();\n\t\t\t\tflow.pop();\n\n\t\t\t\tdata next;\n\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tcheck[i] = true;\n\t\t\t\t}\n\t\t\t\tcheck[now.where] = false;\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tif ( check[i] ) {\n\t\t\t\t\t\tcheck[i] = false;\n\t\t\t\t\t\tint newCost = cost[i][now.where] + now.cost;\n\t\t\t\t\t\tif ( cost[i][j] >= newCost ) {\n\t\t\t\t\t\t\tif ( cost[i][j] > newCost )\n\t\t\t\t\t\t\t\tcost[i][j] = newCost;\n\t\t\t\t\t\t\tnext.cost = newCost;\n\t\t\t\t\t\t\tnext.where = j;\n\t\t\t\t\t\t\tflow.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min = DMAX;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tif ( min > cost[i][s] + cost[i][g1] + cost[i][g2] )\n\t\t\t\tmin = cost[i][s] + cost[i][g1] + cost[i][g2];\n\t\t}\n\n\t\tcout << min << endl;;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint N,M,s,ga,gb;\nint d[100][100],inf=1e8;\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>s>>ga>>gb;\n\t\tif(N==0) break;\n\t\trep(i,N) rep(j,N) d[i][j]=inf;\n\t\trep(i,N) d[i][i]=0;\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a-1][b-1]=c;\n\t\t}\n\t\trep(i,N) rep(j,N) rep(k,N) d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t\tint ans=inf;\n\t\trep(i,N){\n\t\t\tans=min(ans,d[s-1][i]+d[i][ga-1]+d[i][gb-1]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <fstream>\n \nusing namespace std;\n \n#define INF 100000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\n\n#define MAX_N 102\n#define MAX_M 1002\n\nint N, M, s, g1, g2;\n\nvector<int> ans_list;\n\n\n\nint main(){\n\n  \n  while(true){\n    \n    cin >> N >> M >> s >> g1 >> g2;\n    if(N == 0)\n      break;\n\n    s--;\n    g1--;\n    g2--;\n\n    int d[MAX_N][MAX_N];\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < N; j++){\n\td[i][j] = INF;\n      }\n      d[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--;\n      b2--;\n      d[b1][b2] = c;\n    }\n\n    for(int k = 0; k < N; k++){\n      for(int i = 0; i < N; i++){\n\tfor(int j = 0; j < N; j++){\n\t  d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t}\n      }\n    }\n\n    int ans = INF;\n\n    for(int k = 0; k < N; k++){\n      ans = min(ans, d[s][k] + d[k][g1] + d[k][g2]);\n    }\n    \n    ans_list.push_back(ans);\n\n  }\n\n  \n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint cost[105][105];\nint d[105][105];\t\t\t\t// 頂点 s からの最短距離\n\n// 始点 s から各頂点への最短距離を求める\n//int V;\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ) rep (j, V ) d[i][j] = INF;\n\trep (i, V ) d[i][i] = 0;\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\tif (cost[i][j] != INF ){\n\t\t\t\td[i][j] = cost[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (cost, 0, sizeof (cost) );\n\t\trep (i, n ) rep (j, n ) cost[i][j] = INF;\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\tcost[from][to] = c;\n\t\t\tcost[to][from] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\t\twarshall_floyd (n );\n/*\n\t\trep (i, n ){\n\t\t\trep (j, n ){\n\t\t\t\tif (d[i][j] == INF ){\n\t\t\t\t\tcout << \"INF\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << setw(3) << d[i][j];\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tcout << endl;\n\t\t} // end rep\n*/\n\t\trep (i, n ){\n\t\t\tif (i == s ) continue;\n\t\t\tif (i != g1 && i != g2 )\n\t\t\t\tres = min (res, d[s][i] + d[i][g1] + d[i][g2] );\n\t\t\telse\n\t\t\t\tres = min (res, d[s][i] + d[i][i == g1 ? g2 : g1] );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nint main(void){\n\tint32 n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 && n+m+s+g1+g2){\n\t\tint32 d[110][110];\n\t\tREP(j, n){\n\t\t\tREP(k, n) d[j][k] = INF;\n\t\t\td[j][j] = 0;\n\t\t}\n\t\tREP(i, m){\n\t\t\tint32 u, v, c;\n\t\t\tcin >> u >> v >> c; u--; v--;\n\t\t\td[u][v] = c;\n\t\t}\n\t\tREP(k, n){\n\t\t\tREP(i, n){\n\t\t\t\tREP(j, n){\n\t\t\t\t\tif(d[i][j] > d[i][k]+d[k][j]) d[i][j] = d[i][k]+d[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint32 res = INF;\n\t\ts--; g1--; g2--;\n\t\tREP(i, n){\n\t\t\tres = min(res, d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 99999999\n\nusing namespace std;\n\nint n,d[101][101];\n\nvoid warshall_floyd(void){\n  \n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ )\n\td[i][j] = min(d[i][j] , d[i][k] + d[k][j]);\n      \n\t\n}\n \nint main(void){\n\n    int n, m, s, g1, g2, b1, b2, c, d[101][101];\n\n    while( cin >> n >> m >> s >> g1 >> g2 , n + m + s + g1 + g2 ){\n        for(int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= n; j++ ){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for(int i = 0; i < m; i++ ){\n            cin >> b1 >> b2 >> c; \n            d[b1][b2] = c;\n        }\n\n\twarshall_floyd();\n         \n        int ans = INF;\n        for( int i = 1; i <= n; i++ ){\n\t  ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n#define ll long long\nconst int INF = 2 << 27;\n\nint main() {\n  while(1){\n    int n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n    s--;\n    g1--;\n    g2--;\n    int cost[n][n];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n        if(i == j) {\n          cost[i][j] = 0;\n        }\n        else {\n          cost[i][j] = INF;\n        }\n      }\n    }\n    for(int i = 0; i < m; i++) {\n      int b1,b2,c;\n      cin >> b1 >> b2 >> c;\n      cost[b1-1][b2-1] = c;\n    }\n\n\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n        for (int k = 0; k < n; k++)\n          cost[j][k] = std::min(cost[j][k], cost[j][i] + cost[i][k]);\n\n    int ans = INF;\n    for(int i = 0; i < n; i++) {\n      ans = min(ans,cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst int INF = INT_MAX / 4;\n\nint main(void) {\n\tint n, m, s, g1, g2;\n\t\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\ts--; g1--; g2--;\n\n\t\tVVI es(n, VI(n, INF));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tes[a][b] = c;\n\t\t\tes[b][a] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tes[i][i] = 0;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, es[s][i] + es[i][g1] + es[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1000000\n\n#define MAX_SIZE 100\nlong long g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tfor (int k = 0; k < v; ++k) {\n\t\tfor (int i = 0; i < v; ++i) {\n\t\t\tfor (int j = 0; j < v; ++j) {\n\t\t\t\tg_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\tmemset(g_d, INF, sizeof(g_d));\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tg_d[i][i] = 0;\n\t\t}\n\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\t--b1; --b2;\n\t\t\tg_d[b1][b2] = c;\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tlong long cost = INF;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tvector<vector<int>>data;\n\t\tdata.resize(n);\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[i].resize(n);\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdata[i][j] = INT_MAX / 6;\n\t\t\t}\n\t\t\tdata[i][i] = 0;\n\t\t}\n\t\tint a, b, c;\n\t\tfor (size_t i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdata[a][b] = c;\n\t\t\tdata[b][a] = c;\n\t\t}\n\t\tfor (size_t k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t\tdata[j][i] = data[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INT_MAX;\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tans = min(ans, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t\tdata.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF (1<<21)\nusing namespace std;\n\nint main(){\n  int i,j,k,n,m,s,g1,g2,d[101][101],ans;\n  while(cin >> n >> m >> s >> g1 >> g2 && n && m && s && g1 && g2){\n\n    for(i=0;i<=n;i++){\n      for(j=0;j<=n;j++){\n\tif(i == j) d[i][j] = 0;\n\telse d[i][j] = INF;\n      }\n    }\n\n    for(j=0;j<m;j++){\n      int a,b,cost;\n      cin >> a >> b >> cost;\n      d[a][b] = cost;\n    }\n\n    for(k=0;k<=n;k++){\n      for(i=0;i<=n;i++){\n\tfor(j=0;j<=n;j++){\n\t  if(d[i][k] >= INF || d[k][j] >= INF) continue;\n\t  d[i][j] = min(d[i][j],d[i][k] + d[k][j]);\n\t}\n      }\n    }\n\n   int ans = INF;\n   for(i=1;i<=n;i++){\n       ans = min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n   }\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m,s,t1,t2;\n\twhile(cin>>n>>m>>s>>t1>>t2,n){\n\t\ts--;t1--;t2--;\n\t\tvvi G(n,vi(n,inf));\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;b--;\n\t\t\tG[a][b]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t\tG[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\tint out=inf;\n\t\trep(i,n)out=min(out,G[s][i]+G[i][t1]+G[i][t2]);\n\t\tcout<<out<<endl;\n\t}\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int n,m,s,g1,g2;\n    for(;;){\n        int war[100][100];\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        if(n==0&&m==0&&s==0&&g1==0&&g2==0) break;\n        s--;g1--;g2--;\n        int fr,to,co;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(i==j) war[i][j]=0;\n                else war[i][j]=1000000;\n            }\n        }\n        for(int i=0;i<m;i++){\n            scanf(\"%d%d%d\",&fr,&to,&co);\n            fr--;to--;\n            war[fr][to]=co;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    war[i][j]=min(war[i][j],war[i][k]+war[k][j]);\n                }\n            }\n        }\n        int mi=INT_MAX;\n        for(int i=0;i<n;i++){\n            mi=min(mi,war[s][i]+war[i][g1]+war[i][g2]);\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0) return 0;\n    s--,g1--,g2--;\n    vector<vector<int>> dist(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) dist[i][i]=0;\n    int u,v,c;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> c;\n      dist[u-1][v-1]=c;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n        }\n      }\n    }\n    // for(int i=0;i<n;i++){\n    //   for(int j=0;j<n;j++){\n    //     cout << dist[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    int ans=INF;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dist[s][i]+dist[i][g1]+dist[i][g2]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e7 + 10;\n\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n  int prev[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n    fill(prev, prev + V, -1);\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n          prev[e.to] = v;\n        }\n      }\n    }\n\n    return d;\n  }\n\n  vector<int> GetPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prev[t]) {\n      path.push_back(t);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n + m + s + g1 + g2 == 0) {\n      break;\n    }\n    s--; g1--; g2--;\n    Dijkstra dijkstra(n);\n    for (int i = 0; i < m; i++) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      dijkstra.AddEdge(b1, b2, c);\n    }\n\n\n    int ans = INF;\n    vector<int> sd = dijkstra.Solve(s);\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      ans = min(ans, sd[i] + d[g1] + d[g2]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint V;\nll d[1000][1000];\n\nvoid warshallFloyd() {\n    for (int k = 0; k < V; k++) {\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        int m, s, g1, g2;\n        cin >> V >> m >> s >> g1 >> g2;\n        if (V == 0) {\n            break;\n        }\n        for (int i = 0; i < V; i++) {\n            fill(d[i], d[i] + V, inf);\n        }\n        for (int i = 0; i < V; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            d[x - 1][y - 1] = z;\n        }\n        warshallFloyd();\n        ll ans = inf;\n        for (int i = 0; i < V; i++) {\n            ll num = d[s - 1][i] + d[i][g1 - 1] + d[i][g2 - 1];\n            if (num < ans) {\n                ans = num;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define INF (1 << 25)\n\nusing namespace std;\n\nint cost[100][100]; // begin, end\n\nvoid Dijkstra( int n, int s, int *minCost )\n{\n\tbool *end = new bool[n];\n\tfill(end, end+n, false);\n\tminCost[s] = 0;\n\tend[s] = true;\n\twhile(true) {\n\t\tint ii = -1, nn = (INF);\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(end[i] && nn > minCost[i]) {\n\t\t\t\tnn = minCost[i];\n\t\t\t\tii = i;\n\t\t\t}\n\t\t}\n\t\tif(ii == -1) break;\n\t\tend[ii] = false;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(minCost[i] > minCost[ii] + cost[ii][i]) {\n\t\t\t\tminCost[i] = minCost[ii] + cost[ii][i];\n\t\t\t\tend[i] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main( void )\n{\n\tint minCost1[100], minCost2[100], minCost3[100];\n\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2) {\n\t\t--s; --g1; --g2;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tfill(cost[i], cost[i]+n, INF);\n\t\t\tminCost1[i] = minCost2[i] = minCost3[i] = INF;\n\t\t}\n\t\tfor(int i=0; i < m; ++i) {\n\t\t\tint bb, ee, cc;\n\t\t\tcin >> bb >> ee >> cc;\n\t\t\t--bb; --ee;\n\t\t\tcost[bb][ee] = cost[ee][bb] = cc;\n\t\t}\n\t\tDijkstra(n, s, minCost1);\n\t\tDijkstra(n, g1, minCost2);\n\t\tDijkstra(n, g2, minCost3);\n\n\t\tint ans = INF;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tans = min(ans, minCost1[i] + minCost2[i] + minCost3[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_station;\n  int total_road;\n  int water_source_idx;\n  int main_station1_idx;\n  int main_station2_idx;\n  while(~scanf(\"%d %d %d %d %d\",\n\t       &total_station,\n\t       &total_road,\n\t       &water_source_idx,\n\t       &main_station1_idx,\n\t       &main_station2_idx)){\n    if(total_station == 0) break;\n\n    int nodes[101][101];\n    memset(nodes,0x3f,sizeof(nodes));\n\n    for(int i=0;i<total_road;i++){\n      int from,to,cost;\n      scanf(\"%d %d %d\",&from,&to,&cost);\n      nodes[from][to] = cost;\n    }\n\n    for(int k=1;k<=total_station;k++){\n      for(int i=1;i<=total_station;i++){\n\tfor(int j=1;j<=total_station;j++){\n\t  nodes[i][j] = min(nodes[i][k]+nodes[k][j],nodes[i][j]);\n\t}\n      }\n    }\n\n    int res = INF;\n    for(int i=1;i<=total_station;i++){\n      res = min(nodes[water_source_idx][i]\n\t\t+ nodes[i][main_station1_idx]\n\t\t+ nodes[i][main_station2_idx],res);\n    }\n\n    printf(\"%d\\n\",res);\n  }\n\t       \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 100000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\nlong long int d[101][101];\n//int path[101][101];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2){\n\t\tif(n==0&&m==0&&s==0&&g1==0&&g2==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2]=c;\n\t\t\td[b2][b1]=c;\n\t\t}\n\t\tfor(int k=1; k<=n; ++k){\n\t\t\tfor(int i=1; i<=n; ++i){\n\t\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\t\tif(d[i][j]>d[i][k]+d[k][j]){\n\t\t\t\t\t\td[i][j]=d[i][k]+d[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans=INF;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tif(ans>d[s][i]+d[i][g1]+d[i][g2]) ans=d[s][i]+d[i][g1]+d[i][g2];\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int CMAX = 1<<10;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2;){\n    vector<vector<int>> d(n, vector<int> (n, CMAX));\n\n    for(int i=0,b1,b2,c;i<m;++i){\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    for(int k=0;k<n;++k)\n      for(int i=0;i<n;++i)\n        for(int j=0;j<n;++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    int ans = INF;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, m, s, g, gg, from, to, cost;\n  while(cin >> n >> m >> s >> g >> gg, n){\n    s--;g--;gg--;\n    vector<vector<int> > graph(n, vector<int>(n, 1e8));\n    for(int i = 0; i < m; i++){\n      cin >> from >> to >> cost;\n      from--;to--;\n      graph[from][to] = cost;\n    }\n    for(int i = 0; i < n; i++) graph[i][i] = 0;\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  graph[i][j] = min(graph[i][k] + graph[k][j], graph[i][j]);\n\t}\n      }\n    }\n    int ans = 1e9;\n    for(int i = 0; i < n; i++){\n      ans = min(ans, graph[s][i]+ graph[i][g] + graph[i][gg]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    warshallFloyd(g, n);\n    int ans = g[s][g1] + g[s][g2];\n    REP(i, n){\n        ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        s--; g1--; g2--;\n        if(n == 0) return 0;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint cost[105][105];\nint d[105][105];\t\t\t\t// 頂点 s からの最短距離\n\n// 始点 s から各頂点への最短距離を求める\n//int V;\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ) rep (j, V ) d[i][j] = INF;\n\trep (i, V ) d[i][i] = 0;\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\tif (cost[i][j] != INF ){\n\t\t\t\td[i][j] = cost[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (cost, 0, sizeof (cost) );\n\t\trep (i, n ) rep (j, n ) cost[i][j] = INF;\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\tcost[from][to] = c;\n\t\t\tcost[to][from] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\t\twarshall_floyd (n );\n/*\n\t\trep (i, n ){\n\t\t\trep (j, n ){\n\t\t\t\tif (d[i][j] == INF ){\n\t\t\t\t\tcout << \"INF\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << setw(3) << d[i][j];\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tcout << endl;\n\t\t} // end rep\n*/\n\t\trep (i, n ){\n\t\t\tif (i == s ) continue;\n\t\t\tif (i != g1 && i != g2 )\n\t\t\t\tres = min (res, min (d[s][i] + d[i][g1] + d[g1][g2], d[s][i] + d[i][g2] + d[g2][g1] ) );\n\t\t\telse\n\t\t\t\tres = min (res, d[s][i] + d[i][i == g1 ? g2 : g1] );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\n\nint c[100][100];\nint dp[100][100];\n\nint main()\n{\n\tfor(;;) {\n\t\tint n, m, s, g1, g2;\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2);\n\t\ts--; g1--; g2--;\n\t\tif(n==0) return 0;\n\t\trep(i, 100) rep(j, 100) c[i][j] = -1;\n\t\trep(i, m) {\n\t\t\tint b1, b2, tc;\n\t\t\tscanf(\"%d%d%d\", &b1, &b2, &tc);\n\t\t\tb1--; b2--;\n\t\t\tc[b1][b2] = tc;\n\t\t}\n\t\trep(i, n) c[i][i] = 0;\n\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\tif(c[i][k]!=-1 && c[k][j]!=-1) {\n\t\t\t\tint t = c[i][k] + c[k][j];\n\t\t\t\tif(c[i][j]==-1 || c[i][j]>t) c[i][j] = t;\n\t\t\t}\n\t\t}\n\t\tint mn = -1;\n\t\trep(k, n) {\n\t\t\tif(c[s][k]!=-1 && c[k][g1]!=-1 && c[k][g2]!=-1) {\n\t\t\t\tint t = c[s][k] + c[k][g1] + c[k][g2];\n\t\t\t\tif(mn==-1 || mn>t) mn = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", mn);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define INF (1<<20)\nint n,m,s,g1,g2;\nint G[101][101];\nint main(){\n  while(1){\n    scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2);\n    if(!n && !m && !s && !g1 && !g2) break;\n    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) G[i][j]=INF;\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      scanf(\"%d %d %d\",&b1,&b2,&c);\n      G[b1][b2]=c;\n      G[b2][b1]=c;\n    }\n\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)\n\t  G[j][k] = min(G[j][k],G[j][i]+G[i][k]);\n\n    int res = INF;\n    for(int i=1;i<=n;i++){\n      res = min(res,G[s][i]+G[i][g1]+G[i][g2]);\n    }\n    \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\n#define INF 100000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = table[j][k] < table[j][i] + table[i][k] ?\n\t\t\t\t\ttable[j][k] : table[j][i] + table[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\tif(Min == INF) exit(1);\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 9999999\n#define MAX 101\n\nint main(){\n    int n,m,s,g1,g2,d[MAX+1][MAX+1],a,b,c;\n    while(cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2){\n        fill(d[0],d[MAX],INF);\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            d[a][b] = c;\n        }\n        \n        for(int k = 1 ; k <= n ; k++)\n            for(int i = 1 ; i <= n ; i++)\n                for(int j = 1 ; j <= n ; j++)\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        \n        cout << d[s][g1]+d[s][g2]-1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 100000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\nint d[101][101];\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2){\n\t\tif(n==0&&m==0&&s==0&&g1==0&&g2==0) break;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\td[i][j]=0;\n\t\t\t\t} else {\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2]=c;\n\t\t\td[b2][b1]=c;\n\t\t}\n\t\tfor(int k=1; k<=n; ++k){\n\t\t\tfor(int i=1; i<=n; ++i){\n\t\t\t\tfor(int j=1; j<=n; ++j){\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=1; i<=n; ++i){\n\t\t\tans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=193189311;\n  int road[1111][1111];\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<111;i++){\n      for(int j=0;j<111;j++){\n\troad[i][j]=517821491;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=1948198491;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\nstatic const int INF = 1e8;\n\nvoid solve()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2)\n\t{\n\t\t--s; --g1; --g2;\n\t\tvector< vector<int> > d(n, vector<int>(n));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\t--from; --to;\n\t\t\td[from][to] = cost;\n\t\t}\n\t\tfor (int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** Problem2005 : Water Pipe Construction **/\nint d[110][110];\nint V;\n\nvoid warshall_floyd()\n{\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint M, S, G1, G2;\n\twhile (cin>>V>>M>>S>>G1>>G2, V||M||S||G1||G2) {\n\t\tfill(d[0], d[0]+110*110, INF);\n\t\t\n\t\trep(i, M) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\t\n\t\twarshall_floyd();\n\t\n\t\tint ans=INF;\n\t\trep(i, V) {\n\t\t\tif (i != S && i != G1 && i!=G2) {\n\t\t\t\tint tmp = d[S][i]+d[i][G1]+d[i][G2];\n\t\t\t\tans = min(ans, tmp);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\nstruct P\n{\n\tbool a[101] = {};\n\tint cost=0;\n\tbool operator<(const P &right)const\n\t{\n\t\treturn cost < right.cost;\n\t}\n\tbool operator>(const P &right)const\n\t{\n\t\treturn cost > right.cost;\n\t}\n};\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n, m, s, g1, g2;\n\t\tint cost[101][101];\n\t\tcin >> n >> m >> s >> g1 >> g2; if (!n)break;\n\t\tFOR(i, 101)FOR(j, 101)cost[i][j] = INF;\n\t\tFOR(i, m)\n\t\t{\n\t\t\tint l, r, c;\n\t\t\tcin >> l >> r >> c;\n\t\t\tcost[l][r] = c;\n\t\t}\n\t\tP start; start.a[1] = true;\n\t\tpriority_queue< P, vector<P>, greater<P> >que;\n\t\tque.push(start);\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif(now.a[g1]&&now.a[g2])\n\t\t\t{\n\t\t\t\tcout << now.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tFORI(i,1,n+1)\n\t\t\t{\n\t\t\t\tif (now.a[i])\n\t\t\t\t{\n\t\t\t\t\tFORI(j,1,n+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!now.a[j]&&cost[i][j]!=INF)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP next = now;\n\t\t\t\t\t\t\tnext.a[j] = true;\n\t\t\t\t\t\t\tnext.cost += cost[i][j];\n\t\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tfor (;;) {\n\t\tint n, m, s, g1, g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0) break;\n\t\ts--; g1--; g2--;\n\t\tvector< vector<int> > d(n, vector<int>(n, INT_MAX / 10));\n\t\tfor (int i = 0; i < n; i++) d[i][i] = 0;\n\t\twhile (m--) {\n\t\t\tint b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\td[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\tint mini = INT_MAX / 10;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmini = min(mini, d[s][i] + d[i][g1] + d[i][g2]);\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#define INF 1<<29\n#define MAX 3000\nusing namespace std;\nint cost[MAX][MAX],V,d[MAX];\nbool used[MAX];\n\nvoid dijkstra(int);\n\nint main(){\n  int m,s,g1,g2,b1,b2,c;\n\n  while(true)\n    {\n      cin >> V >> m >> s >> g1 >> g2;\n      if(V == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)break;\n      for(int i=1;i<=V;i++){\nfor(int j=1;j<=V;j++){\ncost[i][j]=INF;\n}\n}\n      for(int i=0;i<m;i++)\n\t{\n\t  cin >> b1 >> b2 >> c;\n\t  cost[b1][b2]=c;\n\t}\n      dijkstra(s);\n      int ans = d[g1]+d[g2];\n      //cout << ans << endl;\n      int dr[MAX];\n      for(int i=1;i<=V;i++)dr[i]=d[i];\n      for(int i=1;i<=V;i++)\n\t{\n\t  if(i == s)continue;\n\t  dijkstra(i);\n\t  ans = min(ans,dr[i]+d[g1]+d[g2]);\n\t}\n      cout << ans << endl;\n    }\n}\n\nvoid dijkstra(int s)\n{\n  for(int i=1;i<=V;i++)\n    {\n      d[i]=INF;\n      used[i]=false;\n    }\n  d[s] = 0;\n  while(true)\n    {\n      int v=-1;\n      for(int u=1;u<=V;u++)\n\t{\n\t  if(!used[u] && (v == -1 || d[u] < d[v]))v = u;\n\t}\n      if(v == -1)break;\n      used[v]=true;\n      for(int u=1;u<=V;u++)\n\t{\n\t  d[u]=min(d[u],d[v]+cost[v][u]);\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tint m[100][100]; fill(m[0], m[100], inf);\n\t\tREP(i, N) m[i][i] = 0;\n\t\tREP(i, M) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tm[a][b] = min(m[a][b], c);\n\t\t}\n\t\tREP(k, N) REP(i, N) REP(j, N) m[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\tint ans = inf;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, m[s][i]+m[i][g1]+m[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define M 1001\nint dist[M][M];\nint main(){\n\tint n,m,s,g1,g2,i,j,k,l;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n;){\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)dist[i][j]=(i!=j)*(1<<29);\n\t\tfor(i=0;i<m;i++)scanf(\"%d%d%d\",&j,&k,&l),dist[j][k]=l;\n\t\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++){\n\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])dist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\t\tfor(m=1<<29,i=1;i<=n;i++){\n\t\t\tif(m>dist[s][i]+dist[i][g1]+dist[i][g2])m=dist[s][i]+dist[i][g1]+dist[i][g2];\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX_V = 101;\nconst int INF=100000000;\n// d[u][v]Íu©çvÖÌRXgBßÉ×Ú·éGbWÌRXgðüêÄ¨¢½è·êÎæ¢Í¸B\nint d[MAX_V][MAX_V];\n// ¸_\nint V;\n// S_ÎÅZoHâèðÆ­O(V^3)AÓª ÁÄà®ì\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\nint main(){\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2&&!(n==0&&m==0&&s==0&&g1==0&&g2==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n            }\n        }\n        s--;\n        g1--;g2--;\n        for(int i = 0; i < m; i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            b1--;\n            b2--;\n            d[b1][b2]=c;\n        }\n        V=n;\n        warshall_floyd();\n        int minCost=INF;\n        // X^[g©çÇ±ÜÅ¯¶¹ðg¤©ÅÎ ¢Ê¯\n        for(int i = 0; i < n; i++)\n            minCost=min(minCost,d[s][i]+d[i][g1]+d[i][g2]);\n        cout<<minCost<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <vector<int> > Vec;\n#define INF 20000000\n\nvoid war(Vec& vec) {\n\tint v = vec.size();\n\t\tfor (int k = 0; k < v; k++) {\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tfor (int j = 0; j < v; j++) {\n\t\t\t\t\tvec[i][j] = min(vec[i][j], vec[i][k] + vec[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\ts--; g1--; g2--;\n\t\tif (!n)break;\n\t\tVec G(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tG[i].push_back(i != j ? INF : 0);\n\t\t\t}\n\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tG[a - 1][b - 1] = c;\n\t\t\t}\n\t\t\twar(G);\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n\t\t\t}\n\t\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define rep(i,n)   for(int i=0;i<n;++i)\n#define rep1(i,n)  for(int i=1;i<=n;++i)\n#define INF        ( 1<<20 )\n#define COST(A,B,C)  ( costs[A][B] + costs[B][C] )\n\nusing namespace std;\n\nint costs[101][101];\n\nint main()\n{\n\tint N,M,S,G1,G2;\n\twhile(cin>>N>>M>>S>>G1>>G2,N|M|S|G1|G2)\n\t{\n\t\trep1(i,N)rep1(j,N)costs[i][j] = INF;\n\t\trep1(i,N)costs[i][i] = 0;\n\n\t\tint b1,b2,c;\n\t\trep(i,M)\n\t\t{\n\t\t\tcin>>b1>>b2>>c;\n\t\t\tcosts[b1][b2] = costs[b2][b1] = c;\n\t\t}\n\n\t\trep1(k,N)rep1(i,N)rep1(j,N)\n\t\t{\n\t\t\tcosts[i][j] = min(costs[i][j], costs[i][k] + costs[k][j]);\n\t\t}\n\n\t\tint m = INF;\n\t\trep1(i,N)\n\t\t{\n\t\t\tm = min(m, costs[S][i] + costs[i][G1] + costs[i][G2]);\n\t\t}\n\t\tcout << m << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define all(c) begin(c), end(c)\nusing ll = long long;\n\nint main(){\n    int n,m,s,g1,g2;\n    while (cin >> n >> m >> s >> g1 >> g2 && n){\n        --s, --g1, --g2;\n        vector<vector<int>> g(n,vector<int>(n,1e8));\n        rep(i,n) g[i][i] = 0;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            --a, --b;\n            g[a][b] = c;\n        }\n        rep(k,n)rep(i,n)rep(j,n) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        int ans = 1e9;\n        rep(i,n) ans = min(ans, g[s][i]+g[i][g1]+g[i][g2]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n#define inf 101010\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while (cin>>n>>m>>s>>g1>>g2 && n) {\n        vector<vector<int> > e(n+1, vector<int>(n+1, inf));\n        for (int i = 0; i < m; i++) {\n            int a,b,c;\n            cin >> a >> b >> c;\n            e[a][b] = c;\n        }\n        for (int i = 1; i < n+1; i++) e[i][i] = 0;\n        \n        for (int k = 1; k < n+1; k++) {\n            for (int i = 1; i < n+1; i++) {\n                for (int j = 1; j < n+1; j++) {\n                    e[i][j] = min(e[i][j], e[i][k]+e[k][j]);\n                }\n            }\n        }\n        \n        int ans = inf;\n        for (int i = 1; i < n+1; i++) {\n            ans = min(ans, e[s][i] + e[i][g1] + e[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nstatic const int INF = 1E9;\nint n, m, s, g1, g2;\nint v, w, c;\nint d[111][111];\n\nint main()\n{\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    rep(i, n) rep(j, n) d[i][j] = INF;\n    rep(i, n) d[i][i] = 0;\n    rep(i, m){\n      cin >> v >> w >> c;\n      d[v - 1][w - 1] = c;\n    }\n    rep(k, n) rep(i, n) rep(j, n) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    int res = INF;\n    rep(i, n) res = min(res, d[s - 1][i] + d[i][g1 - 1] + d[i][g2 - 1]);\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919\nusing namespace std;\n\nint dp[110][110];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(void)\n{\n\tint n, m, s, g1, g2;\n\tint data[128][128];\n\tint a, b, c;\n\t\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n){\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tif (i == j) data[i][j] = 0;\n\t\t\t\telse data[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tcin >> a >> b >> c;\n\t\t\tdata[a-1][b-1] = c;\n\t\t}\n\t\t\n\t\t// わーしゃるふろいど\n\t\tfor (int k = 0; k < n; k++){\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 10000000;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tret = min(ret, data[s - 1][i] + data[i][g1 - 1] + data[i][g2 - 1]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[101][101];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                if(i == j) road[i][j] = 0;\n                else road[i][j] = 1000000000;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int k = 1; k < n + 1; k++){\n            for(int i = 1; i < n + 1; i++){\n                for(int j = 1; j < n + 1; j++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 1; i < n + 1; i++){\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[102][102];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                // if(i == j) road[i][j] = 0;\n                // else\n                    road[i][j] = 1000000000;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int k = 1; k < n + 1; k++){\n            for(int i = 1; i < n + 1; i++){\n                for(int j = 1; j < n + 1; j++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 1; i < n + 1; i++){\n            road[i][i] = 0;\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\n/*bool operator<(const data &d)const{\n\treturn hoge;\n}*/\n\nint N,M,S,G1,G2;\nint d[111][111];\nvoid warshall_floyd(int n) { // nは頂点数\n  for (int i = 0; i < n; i++)      // 経由する頂点\n    for (int j = 0; j < n; j++)    // 開始頂点\n      for (int k = 0; k < n; k++)  // 終端\n        d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n}\n\nint solve(){\n\tS--;G1--;G2--;\n\trep(i,0,101)rep(j,0,101){\n\t\tif(i==j)d[i][j] = 0;\n\t\telse d[i][j] = INF;\n\t}\n\trep(i,0,M){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\td[a][b] = c;\n\t}\n\twarshall_floyd(N);\n\tint ret = INF;\n\trep(i,0,N){\n\t\tint t = 0;\n\t\tt += d[S][i];\n\t\tt += d[i][G1];\n\t\tt += d[i][G2];\n\t\tchmin(ret,t);\n\t}\n\treturn ret;\n}\n \nsigned main(){\n\tIOS();\n\tvector<int>ans;\n\twhile(cin>>N>>M>>S>>G1>>G2,N||M||S||G1||G2){\n\t\tauto t = solve();\n\t\tans.push_back(t);\n\t}\n\tfor(auto e:ans){\n\t\tcout<<e<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nbool used[128];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tfill_n(res, 3, INF);\n\t\n\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(dp[v], dp[v] + 3, res);\n\t\treturn;\n\t}\n\n\tif (v == g1)\n\t\tres[0] = 0;\n\telse if (v == g2)\n\t\tres[1] = 0;\n\n\tbool skip = false;\n\tused[v] = true;\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tif (used[edge[v][i].to])\n\t\t{\n\t\t\tskip = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tused[v] = false;\n\tmin_swap(res[2], res[0] + res[1]);\n\n\tif (!skip)\n\t\tcopy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int CMAX = 1<<10;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2;){\n    vector<vector<int>> d(n, vector<int> (n, CMAX));\n\n    for(int i=0,b1,b2,c;i<m;++i){\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    for(int i=0;i<n;++i) d[i][i] = 0;\n\n    for(int k=0;k<n;++k)\n      for(int i=0;i<n;++i)\n        for(int j=0;j<n;++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    int ans = INF;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(void)\n{\n\tint n, m, s, g1, g2;\n\tint data[128][128];\n\tint a, b, c;\n\t\n\twhile (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n){\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\tif (i == j) data[i][j] = 0;\n\t\t\t\telse data[i][j] = 10000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t\tdata[a][b] = c;\n\t\t}\n\t\t\n\t\t// わーしゃるふろいど\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tfor (int j = 1; j <= n; j++){\n\t\t\t\tfor (int k = 1; k <= n; k++){\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 10000000;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tret = min(ret, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\n#define INF 1e+9\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\n\nint main(){\n    int n,m,s,g1,g2;\n\n    while(cin >> n >> m >> s >> g1 >> g2){\n        if((n|m|s|g1|g2) == 0) break;\n        int cost[n][n];\n        int ret = INF;\n        int src,dst,c;\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j] = INF;\n            }\n        }\n\n        for(int i=0;i<n;i++) cost[i][i] = 0;\n\n        //load roads lol\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> c;\n            cost[src-1][dst-1] = c;\n            cost[dst-1][src-1] = c;\n        }\n\n        //WF\n        for(int r=0;r<n;r++){\n            for(int p=0;p<n;p++){\n                for(int q=0;q<n;q++){\n                    cost[p][q] = min(cost[p][q], cost[p][r] + cost[r][q]);\n                }\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            ret = min(ret, cost[i][s-1] + cost[i][g1-1] + cost[i][g2-1]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<10);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n    scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2);\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<=n;i++ ) {\n    for( int j=0;j<=n;j++ ) {\n      pipe[i][j]=INF;\n    }\n    pipe[i][i]=0;\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    scanf(\"%d%d%d\", &b1, &b2, &c);\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[200][200];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\ts--;g1--;g2--;\n\t\trep(i,n)rep(j,n){\n\t\t\tcost[i][j]=LLONG_MAX/3;\n\t\t}\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);b1--;b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=LLONG_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n#define INF (1<<25)\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n\nusing namespace std;\n\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        --s;--g1;--g2;\n        rep(i,n) rep(j,n) edge[i][j] = (i==j)?0:INF;\n        rep(i,m)\n        {\n            cin >> b1 >> b2 >> c;\n            --b1;--b2;\n            edge[b1][b2] = c;\n        }\n        rep(k,n) rep(i,n) rep(j,n) edge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n        mn = INF;\n        rep(i,n) mn = min(mn, edge[s][i]+edge[i][g1]+edge[i][g2]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n,m,s,g1,g2,a,b,cost,mi;\n  int map[101][101];\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)map[i][j]=0;\n\telse map[i][j]=1000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>cost;\n      map[a-1][b-1]=cost;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  map[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t}\n      }\n    }\n    mi=1000000;\n    for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]);\n    cout<<mi<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 110;\nconst int INF = 1e9;\n\nint n, m, s, g1, g2;\nint cost[MAX_V][MAX_V];\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++)\n    for(int j = 0 ; j < MAX_V ; j++) cost[i][j] = INF;\n  \n  for(int i = 0 ; i < MAX_V ; i++) cost[i][i] = 0;\n}\n\n\nvoid wf(){\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }    \n}\n\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n    init();\n    s--, g1--, g2--;\n    int from, to, C;\n    for(int i = 0 ; i < m ; i++){\n      cin >> from >> to >> C;\n      cost[from-1][to-1] = C;\n    }\n    \n    wf();\n        \n    int ans = INF;\n    for(int i = 0 ; i < n ; i++){\n      ans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tlong long int n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tvector<vector<long long int> >data;\n\t\tdata.resize(n);\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[i].resize(n);\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdata[i][j] = INT_MAX / 6;\n\t\t\t}\n\t\t\tdata[i][i] = 0;\n\t\t}\n\t\tlong long int a, b, c;\n\t\tfor (size_t i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdata[a][b] = c;\n\t\t\tdata[b][a] = c;\n\t\t}\n\t\tfor (size_t k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t\tdata[j][i] = data[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = INT_MAX;\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tans = min(ans, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t\tdata.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e8;\n\nint main() {\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2 && n){\n        s--;\n        g1--;\n        g2--;\n        VVI d(n,VI(n,INF));\n        REP(i,n) d[i][i] = 0;\n        REP(i,m){\n            int x, y, z;\n            cin >> x >> y >> z;\n            x--;\n            y--;\n            d[x][y] = z;\n        }\n        REP(i,n) REP(j,n) REP(k,n){\n            d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        }\n        int ans = INF;\n        REP(i,n) ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1e7\nusing namespace std;\nint main(){\n  int n,m,x,y,z,q,w,e;\n  while(cin>>n>>m>>x>>y>>z,n++){\n    int dp[n][n]={};\n    r(i,n)r(j,n)dp[i][j]=INF;\n    r(i,m){\n      cin>>q>>w>>e;\n      dp[q][w]=dp[w][q]=e;\n    }\n    r(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n    int ans=INF;\n    r(i,n)ans=min(ans,dp[i][x]+dp[i][y]+dp[i][z]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int to, cost; \n    edge(int t, int c): to(t), cost(c) {}\n};\nconst int INF = 1e9;\n\nvoid dijkstra(const vector<vector<edge> > &G, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    typedef pair<int, int> P;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0, s));\n\n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i=0; i<G[v].size(); ++i) {\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<vector<edge> > G(n);\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            G[b1-1].push_back(edge(b2-1, c));\n        }\n        REP(i, n) {\n            dijkstra(G, d[i], i);\n        }\n        int ans = 0;\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#define INF 1<<29\n#define MAX 3000\nusing namespace std;int cost[MAX][MAX],V,d[MAX];bool used[MAX];void dijkstra(int);int main(){int m,s,g1,g2,b1,b2,c;while(true){cin >> V >> m >> s >> g1 >> g2;if(V == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)break;for(int i=1;i<=V;i++){for(int j=1;j<=V;j++){cost[i][j]=INF;}}for(int i=0;i<m;i++){cin >> b1 >> b2 >> c;cost[b1][b2]=c;}dijkstra(s);int ans = d[g1]+d[g2];int dr[MAX];for(int i=1;i<=V;i++)dr[i]=d[i];for(int i=1;i<=V;i++){if(i == s)continue;dijkstra(i);ans = min(ans,dr[i]+d[g1]+d[g2]);}cout << ans << endl;}}void dijkstra(int s){for(int i=1;i<=V;i++){d[i]=INF;used[i]=false;}d[s] = 0;while(true){int v=-1;for(int u=1;u<=V;u++){if(!used[u] && (v == -1 || d[u] < d[v]))v = u;}if(v == -1)break;used[v]=true;for(int u=1;u<=V;u++){d[u]=min(d[u],d[v]+cost[v][u]);}}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nconstexpr int MAX_N = 100, INF = (int)1e8;\n\nint n;\nint dp[MAX_N][MAX_N];\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g[2];\n\t\tstd::cin >> n >> m >> s >> g[0] >> g[1];\n\t\tif (n + m + s + g[0] + g[1] <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\t--s;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t--g[i];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i][i] = 0;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tdp[a][b] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdp[j][k] = std::min(dp[j][k], dp[j][i] + dp[i][k]);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = std::min(ans, dp[s][i] + dp[i][g[0]] + dp[i][g[1]]);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define INF (INT_MAX/3)\n\nint main() {\n    int town_n, road_n, start, goal1, goal2;\n    while (cin >> town_n >> road_n >> start >> goal1 >> goal2, town_n) {\n        start--;\n        goal1--;\n        goal2--;\n\n        vvi E(town_n, vi(town_n, INF));\n        REP(i, town_n) E[i][i] = 0;\n        REP(i, road_n) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            E[a][b] = c;\n        }\n        REP(i, town_n) REP(j, town_n) REP(k, town_n) E[j][k] = min(E[j][k], E[j][i] + E[i][k]);\n\n        int mi = INF;\n        REP(i, town_n) {\n            mi = min(mi, E[start][i] + E[i][goal1] + E[i][goal2]);\n        }\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\nstruct range{\n\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\ntemplate <typename T>\nusing V = vector<T>;\n\nstruct N {\n\tint n, c;\n\tbool operator < (N a) const {\n\t\treturn c > a.c;\n\t}\n};\n\nint main() {\n\tfor (int n, m, s, g1, g2; n = in, m = in, s = in, g1 = in, g2 = in;) {\n\t\ts--, g1--, g2--;\n\t\tV<V<N>> g(n), h(n);\n\t\ttimes(i, m) {\n\t\t\tint s {(int) in - 1}, e {(int) in - 1}, c {in};\n\t\t\tg[s].push_back({e, c});\n\t\t\th[e].push_back({s, c});\n\t\t}\n\t\tauto f = [&](int s, V<V<N>> &x) {\n\t\t\tV<int> d(n, INT_MAX / 4);\n\t\t\td[s] = 0;\n\t\t\tpriority_queue<N> q;\n\t\t\tq.push({s, 0});\n\t\t\twhile (!q.empty()) {\n\t\t\t\tN t = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tfor (N i : x[t.n])\n\t\t\t\t\tif (d[i.n] > d[t.n] + i.c)\n\t\t\t\t\t\tq.push({i.n , d[i.n] = d[t.n] + i.c});\n\t\t\t}\n\t\t\treturn d;\n\t\t};\n\t\tV<int> rs {f(s, g)}, r1 {f(g1, h)}, r2 {f(g2, h)};\n\t\tint r {INT_MAX};\n\t\tfor (int i: range(n))\n\t\t\tr = min(r, rs[i] + r1[i] + r2[i]);\n\t\toutl(r);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) && n!=0) {\n\t\tvvi cost(n,vi(n,INT_MAX/10));\n\n\t\tREP(i, m) {\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\n\t\t\tcost[b1-1][b2-1] = c;\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint minCost=INT_MAX;\n\t\tFOR(i, 0, n) {\n\t\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t\t}\n\n\t\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 100\n#define min(a,b) (a>b?b:a)\n#define INF 10000000\n\nint main() {\n\tint n, m, s, g1, g2, b1, b2, c, ans;\n\tint cost[N+1][N+1];\n\twhile(1) {\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(!n&&!m&&!s&&!g1&&!g2) break;\n\t\tfor(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) {\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tcost[b1][b2] = c;\n\t\t}\n\t\tcout << cost[s][g2] << endl;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tfor(int j=1; j<=n; ++j) {\n\t\t\t\tfor(int k=1; k<=n; ++k) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tans = min(cost[s][i]+cost[i][g1]+cost[i][g2], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e8\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main(void) {\n    int i,j,k;\n    int n,m,s,g1,g2;\n    int v[100][100];\n    while(cin >> n >> m >> s >> g1 >> g2, n){\n        s--;g1--;g2--;\n        rep(i,n)rep(j,n){\n            if(i == j) v[i][j] = 0;\n            else v[i][j] = INF;\n        }\n        rep(i,m){\n            int a,b,c;\n            cin >> a >> b >> c;\n            a--;b--;\n            v[a][b] = c;\n            v[b][a] = c;\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n        }\n        int ans = INF;\n\n        rep(i,n){\n            ans = min(ans, v[s][i] + v[i][g1] + v[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, m, s, g, gg, from, to, cost;\n  while(cin >> n >> m >> s >> g >> gg, n){\n    s--;g--;gg--;\n    vector<vector<int> > graph(n, vector<int>(n, 1e8));\n    for(int i = 0; i < m; i++){\n      cin >> from >> to >> cost;\n      from--;to--;\n      graph[from][to] = cost;\n    }\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  graph[i][j] = min(graph[i][k] + graph[k][j], graph[i][j]);\n\t}\n      }\n    }\n    int ans = 1e9;\n    for(int i = 0; i < n; i++){\n      ans = min(ans, graph[s][i]+ graph[i][g] + graph[i][gg]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e9;\n\n\n\nint main() {\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tll cost[100][100]; fill(cost[0], cost[100], inf);\n\t\tfor (int i = 0; i < N; ++i) cost[i][i] = 0;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tcost[a][b] = c;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define DECIM8  fixed<<setprecision(8) \n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(!n&&!m&&!s&&!g1&&!g2) return 0;\n    int wf[128][128];\n    REP(i,n+1) REP(j,n+1) wf[i][j]=(1<<25);\n    REP(i,n+1) wf[i][i]=0;\n    REP(i,m){\n      int b1,b2,c;\n      cin >> b1 >> b2 >> c;\n      wf[b1][b2]=c;\n    }\n    REP(k,n+1) REP(i,n+1) REP(j,n+1)\n      wf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n    int answer=(1<<25);\n    REP(i,n+1)\n      answer=min(answer,wf[s][i]+wf[i][g1]+wf[i][g2]);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x);\n#define MAX (10000000)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    int n,m,s,g1,g2;\n    n  = getInt();\n    m  = getInt();\n    s  = getInt();\n    g1 = getInt();\n    g2 = getInt();\n\n    if(n+m+s+g1+g2 == 0) break;\n    s--; g1--; g2--;\n\n    int load[n][n];\n    REP(i,n) REP(j,n) load[i][j] = MAX;\n    REP(i,n) load[i][i] = 0;\n\n    REP(i,m){\n      int a = getInt()-1, b = getInt()-1;\n      int c = getInt();\n      load[a][b] = c;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n)\n      load[i][j] = min(load[i][j], load[i][k] + load[k][j]);\n\n    int ans = INT_MAX;\n    REP(i,n)\n      ans = min(ans, load[s][i] + load[i][g1] + load[i][g2]);\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n\nint min(int a, int b){ return a < b ? a : b; }\n\nint main(void){\n  while(true){\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){ break; }\n    --s; --g1; --g2;\n\n    // ??£??\\??????????§????\n    vector<vector<int> > adjmatrix(n, vector<int>(n, INF));\n    for(int i = 0; i < m; i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      --b1; --b2;\n      adjmatrix[b1][b2] = c;\n      //adjmatrix[b2][b1] = c;\n    }\n    for(int i = 0; i < n; i++){ adjmatrix[i][i] = 0; }    \n\n    // ???????????£???\n    for(int k = 0; k < n; k++)\n      for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n          adjmatrix[i][j] = min(adjmatrix[i][j], adjmatrix[i][k] + adjmatrix[k][j]);\n\n    // ???????????±???????????????????????????\n    int mincost = INF;\n    for(int i = 0; i < n; i++){\n      mincost = min(mincost, adjmatrix[s][i] + adjmatrix[i][g1] + adjmatrix[i][g2]);\n    }\n\n    // ??????\n    cout << mincost << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const INF = (int)1e9;\n\nint main() {\n  int N, M, S, g1, g2;\n  \n  while(cin >> N >> M >> S >> g1 >> g2 && N) {\n    int cost[100][100]; fill(cost[0], cost[0]+10000, INF);\n    for(int i=0; i<N; i++) cost[i][i] = 0;\n    S--, g1--, g2--;\n    for(int i=0; i<M; i++) {\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      cost[a][b] = c;\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    \n    int ans = INF;\n    for(int k=0; k<N; k++) {\n      ans = min(ans, cost[S][k] + cost[k][g1] + cost[k][g2]);\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\nstruct Nde{\n    int to, cost;\n};\n\nstruct cmp{\n    bool operator()(const pair<int, int>&a, const pair<int, int> &b){\n        if(a.first == b.first) return a.second < b.second;\n        return a.first < b.first;\n    }\n};\nLL d[110][110];\nint main() {\n    //cout << fixed << setprecision(8);\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2) {\n        if (n == 0) break;\n\n        vector<vector<pair<int, int>>> G(1010);\n\n        s--;\n        g1--;\n        g2--;\n        REP(i,110){\n            REP(j, 110){\n                if(i!=j)\n                    d[i][j] = 1e9;\n                else d[i][j]=0;\n            }\n        }\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            b1--;\n            b2--;\n            d[b1][b2] = c;\n        }\n\n\n        for(int k=0; k<n; ++k){\n            for(int i=0; i<n; ++i){\n                for(int j=0; j<n; ++j){\n                    d[i][j]= min(d[i][j], d[i][k]+d[k][j]);\n                }\n            }\n        }\n\n        LL ans = 1e9;\n        for(int i=0; i<n; ++i){\n            ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n\tint x,y,c,n,m,s,p,q,d[110][110];\n\twhile(cin>>n>>m>>s>>p>>q,n!=0){\n\t\ts--;p--;q--;\n\t\trep(i,n)\n\t\trep(j,n)\n\t\td[i][j]=INF;\n\t\trep(i,n)\n\t\td[i][i]=0;\n\t\trep(i,m){\n\t\t\tcin>>x>>y>>c;\n\t\t\tx--;y--;\n\t\t\td[x][y]=c;\n\t\t}\n\t\trep(k,n)\n\t\trep(i,n)\n\t\trep(j,n)\n\t\td[i][j]=min(d[i][k]+d[k][j],d[i][j]);\n\t\tint ans=INF;\n\t\trep(i,n)\n\t\tans=min(ans,d[s][i]+d[i][p]+d[i][q]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int INF = 1e+7;\n\nint d[MAX_V][MAX_V];\n\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\td[i][j] = (i == j)? 0 : INF ;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile( cin >> n >> m >> s >> g1 >> g2 , n ){\n\t\tinit();\n\t\ts--; g1--; g2--;\n\t\t\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--; v--;\n\t\t\td[u][v] = cost;\n\t\t}\n\t\t\n\t\tfor(int k=0 ; k < n ; k++ ){\n\t\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\t\td[i][j] = min( d[i][j] , d[i][k] + d[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tans = min( ans , d[s][i] + d[i][g1] + d[i][g2] );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define INF 1000000000000\ntypedef long long LL;\nint n,m,s,g1,g2;\nLL d[101][101];\n\nint main(){\n    while(cin>>n>>m>>s>>g1>>g2,n+m+s+g1+g2){\n        s--;g1--;g2--;\n        REP(i,101){\n            REP(j,101){\n                d[i][j]=INF;\n            }\n            d[i][i]=0;\n        }\n        REP(i,m){\n            int a,b,c;\n            cin>>a>>b>>c;\n            a--;b--;\n            d[a][b]=c;\n            d[b][a]=c;\n        }\n        REP(i,n){\n            REP(j,n){\n                REP(k,n){\n                    d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n                }\n            }\n        }\n        LL ans=1e12;\n        REP(i,n){\n            ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define N 100\nconst int infty = 1<<24;\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n};\nstruct State{\n  int now;\n  int cost;\n  State():now(-1),cost(infty){}\n  State(int pos,int c):now(pos),cost(c){}\n  bool operator>(const State &t)const{return cost>t.cost;}\n};\ntypedef vector<Node> Graph;\nint dijkstra(int s, int g, Graph &G)\n{\n  int A[G.size()];\n  bool vis[G.size()];\n  priority_queue<State,vector<State>,greater<State> > qs;\n  fill(A,A+G.size(),infty);\n  fill(vis,vis+G.size(),false);\n  qs.push(State(s,0));\n  while(!qs.empty()){\n    State now=qs.top();qs.pop();\n    if(vis[now.now])continue;\n    vis[now.now]=true;\n    for(int i=0;i<G[now.now].con.size();++i){\n      int next_id=G[now.now].con[i];\n      if(now.cost+G[now.now].cost[i]<A[next_id]){\n\tA[next_id]=now.cost+G[now.now].cost[i];\n\tif(!vis[next_id]){\n\t  qs.push(State(next_id,A[next_id]));\n\t}\n      }\n    }\n  }\n  return A[g];\n}\nint main()\n{\n  int n,m,s,g1,g2;\n  while(cin >> n >> m >> s >> g1 >> g2 && n ){\n    int ans=infty;\n    --s;--g1;--g2;\n    Graph G(n);\n    for(int i = 0; i < m; ++i){\n      int src,dst,cost;\n      cin >> src >> dst>> cost;--src;--dst;\n      G[src].con.push_back(dst);\n      G[src].cost.push_back(cost);\n    }\n    for(int i = 0; i < n; ++i){\n      int tmp=dijkstra(s,i,G)+dijkstra(i,g1,G)+dijkstra(i,g2,G);\n      if(tmp<ans)ans=tmp;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int CMAX = 1<<10;\n\nint main(){\n\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n;){\n    vector<vector<int>> d(n, vector<int> (n, CMAX));\n\n    for(int i=0,b1,b2,c;i<m;++i){\n      cin>>b1>>b2>>c;\n      d[b1-1][b2-1] = c;\n    }\n\n    for(int k=0;k<n;++k)\n      for(int i=0;i<n;++i)\n        for(int j=0;j<n;++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    int ans = INF;\n    for(int i=0;i<n;++i) ans = min(ans, d[s-1][i] + d[i][g1-1] + d[i][g2-1]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[100][100];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\ts--;g1--;g2--;\n\t\tmemset(cost,0x1f,sizeof(cost));\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);b1--;b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=INT_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\nusing namespace std;\n\n\n\nint main(){\n    while(1){\n        \n        \n        \n        \n        \n        \n    const int mx=1e9+7;\n    int n,m,s,go,gt;\n    cin>>n>>m>>s>>go>>gt;\n    if(n==0 && m==0){break;}\n    s--; go--; gt--;\n    int a[1000][1000];\n    fill(&a[0][0],&a[999][1000],mx);\n    for(int i=0;i<n;i++){\n        a[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n        int b,c,d;\n        cin>>b>>c>>d;\n        a[b-1][c-1]=d;\n        a[c-1][b-1]=d;\n    }\n    \n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            for(int k=0;k<n;k++){\n                a[t][k]=min(a[t][i]+a[i][k],a[t][k]);\n            }\n        }\n    }\n    int ans=mx;\n    for(int i=0;i<n;i++){\n        ans=min(a[s][i]+a[i][go]+a[i][gt],ans);\n    }\n        \n        /*\n        cout<<endl;\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                cout<<(a[i][t]==mx? -1:a[i][t])<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n        */\n        \n        \n    //assert(ans!=mx);\n    cout<<ans<<endl;\n    \n    \n    \n    \n    \n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> VI;\ntypedef vector<VI> VVI;\nconst ll INF = numeric_limits<ll>::max() / 4;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (true) {\n\t\tll n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2;\n\t\ts--; g1--; g2--;\n\t\tif (n == 0) break;\n\t\tVVI dis(n, vector<ll>(n, INF));\n\t\tfor (int i = 0; i < n; i++) dis[i][i] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll b1, b2, c; cin >> b1 >> b2 >> c;\n\t\t\tb1--; b2--;\n\t\t\tdis[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tll tmp = dis[s][i] + dis[i][g1] + dis[i][g2];\n\t\t\tres = min(res, tmp);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[100][100];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\tmemset(cost,0x1f,sizeof(cost));\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=INT_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    warshallFloyd(g, n);\n    // pma(g, n);\n    \n    int ans = g[s][g1] + g[s][g2];\n    REP(i, n){\n        ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = -1;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 999999;\n\nint main()\n{\n\tint n, m, s, t, u, a[101][101], p, q, v;\n\t\n\twhile(cin>>n>>m>>s>>t>>u&&n){\n\t\tfill(&a[0][0], &a[100][100], inf);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\twhile(m--){\n\t\t\tcin >> p >> q;\n\t\t\tcin >> a[p][q];\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\ta[i][j] = min(a[i][j], a[i][k]+a[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tm = inf;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tm = min(m, a[s][i]+a[i][t]+a[i][u]);\n\t\t}\n\t\t\n\t\tcout << m << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int INF = 1 << 29;\n\nint main()\n{\n  int n, m, s, g1, g2;\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2) != EOF) {\n    if (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n      break;\n    --s;\n    --g1;\n    --g2;\n\n    int cost[MAX_N][MAX_N];\n    for (int i = 0; i < MAX_N; ++i) {\n      for (int j = 0; j < MAX_N; ++j) {\n\tif (i == j)\n\t  cost[i][j] = 0;\n\telse\n\t  cost[i][j] = INF;\n      }\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int b1, b2, c;\n      scanf(\"%d %d %d\", &b1, &b2, &c);\n      --b1;\n      --b2;\n      cost[b1][b2] = c;\n    }\n\n    for (int k = 0; k < n; ++k)\n      for (int i = 0; i < n; ++i)\n\tfor (int j = 0; j < n; ++j)\n\t  cost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\n    int ans = INF;\n    for (int i = 0; i < n; ++i)\n      ans = min(ans, cost[s][i]+cost[i][g1]+cost[i][g2]);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile( true ){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint b1;\n\t\tint b2;\n\t\tint c;\n\n\t\tvector< vector < int > > map(n + 1, vector< int >(n + 1, INT_MAX / 4));\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tmap[b1][b2] = c;\n\t\t}\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tmap[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor(int k = 0; k < n + 1; k++) {\n\t\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\t\tfor(int j = 0; j < n + 1; j++) {\n\t\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint total = INT_MAX / 2;\n\t\tfor(int k = 0; k < n + 1; k++) {\n\t\t\ttotal = min(total, map[s][k] + map[k][g1] + map[k][g2]);\n\t\t}\n\n\t\tcout << total << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int INF = 1 << 28;\n\nint N, M, S, G1, G2;\nint B1[1000], B2[1000], C[1000];\n\nint graph[1000][1000];\n\nint solve() {\n    int min_dist[1000][1000];\n    for (int j = 0; j < N; ++j) { fill(min_dist[j], min_dist[j]+N, INF); min_dist[j][j] = 0; }\n    for (int j = 0; j < M; ++j) min_dist[B1[j]][B2[j]] = min_dist[B2[j]][B1[j]] = C[j];\n    \n    for (int l = 0; l < N; ++l) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                int cand = min_dist[j][l] + min_dist[l][k];\n                if (cand < min_dist[j][k]) min_dist[j][k] = cand;\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < N; ++j) {\n        if (j == S || j == G1 || j == G2) continue;\n        int cand = min_dist[S][j] + min_dist[j][G1] + min_dist[j][G2];\n        if (cand < ans) {\n            ans = cand;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (true) {\n        cin >> N >> M >> S >> G1 >> G2;\n        if (N == 0 && M == 0 && S == 0 && G1 == 0 && G2 == 0) break;\n        --S; --G1; --G2;\n        for (int j = 0; j < M; ++j) {\n            cin >> B1[j] >> B2[j] >> C[j];\n            --B1[j]; --B2[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\nint T[MAX][MAX];\nint n,m,s,g1,g2;\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++) T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int from, to, cost;\n    cin >> from >> to >> cost;\n    T[from][to] = cost;\n  }\n}\n\nvoid solve(){\n\n  for(int k = 1; k <= n; k++)\n    for(int i = 1; i <= n; i++)\n      for(int j = 1; j <= n; j++) T[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n\n  int ans = INF;\n  for(int i = 1; i <= n; i++) ans = min(ans,T[s][i]+T[i][g1]+T[i][g2]);    \n  cout << ans << endl;\n}\n\nint main(){\n\n\n  while(cin >> n >> m >> s >> g1 >> g2 &&n+m+s+g1+g2){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\tvvi cost(n,vi(n,INT_MAX/10));\n\t\tREP(i,n){\n\t\t\tcost[i][i]=0;\n\t\t}\n\t\tREP(i,m){\n\t\t\tint b1,b2,c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\tcost[b1-1][b2-1]=c;\n\t\t\tcost[b2-1][b1-1]=c;\n\t\t}\n\t\tREP(k,n)\n\t\t\tREP(i,n)\n\t\t\t\tREP(j,n){\n\t\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,n){\n\t\t\tbest=min(best,cost[s-1][i]+cost[i][g1-1]+cost[i][g2-1]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <array>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint main() {\n  while(1){\n    int n,m,p[3];\n    cin>>n>>m>>p[0]>>p[1]>>p[2];\n    if(!n)break;\n    REP(i,3)--p[i];\n    int d[100][100];\n    REP(i,n)REP(j,n)d[i][j]=INF;\n    REP(i,m){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      --b1;--b2;\n      d[b1][b2]=c;\n    }\n    REP(i,n)\n      d[i][i]=0;\n    REP(k,n)REP(i,n)REP(j,n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    int dmin=INF;\n    REP(i,n){\n      int sum=0;\n      sum+=d[p[0]][i];\n      sum+=d[i][p[1]];\n      sum+=d[i][p[2]];\n      dmin=min(dmin,sum);\n    }\n    cout<<dmin<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 0x3FFFFFFF\n#define min(a,b) a > b ? b : a\n\n\nint main(void){\n\tint n, m, s, g1, g2, b1, b2, c, i, j, k, l, path[100][100], mn;\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < n;i++)\n\t\t\tfor(j = 0;j < n;j++) path[i][j] = INF;\n\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tpath[b1 - 1][b2 - 1] = c;\n\t\t\tpath[b2 - 1][b1 - 1] = c;\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t\tpath[i][i] = 0;\n\t\tmn = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tfor(k = 0;k < n;k++)\n\t\t\t\t\tpath[j][k] = min(path[j][i] + path[i][k],path[j][k]);\n\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(path[i][g1] != INF && path[i][g2] != INF && path[i][s] != INF)\n\t\t\t\tmn = min(mn,path[i][g1 - 1] + path[i][g2 - 1] + path[i][s - 1]);\n\t\t}\n\t\tprintf(\"%d\\n\",mn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 100000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = (table[j][k] < (table[j][i] + table[i][k]) ?\n\t\t\t\t\ttable[j][k] : (table[j][i] + table[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n\nusing namespace std;\n\nconst int INF=10000000;\n\nlong int field[101][101];\nlong int costs[101];\nint s,g1,g2;\nint n,m;\nint f,t,c;\n\nvoid root(){\n\tint a,b;\n\tfield[f][t]=c;\n\tfor(b=1;b<=n;b++){\n\t\tfor(a=1;a<=n;a++){\n\t\t\tfield[a][b]=min(field[a][b],field[a][f]+field[f][t]+field[t][b]);\n\t\t}\n\t}\n\tfor(a=1;a<=n;a++){\n\t\tcosts[a]=min(costs[a],min(field[a][f]+field[f][t]+field[t][g1]+field[t][g2],min(field[a][g1]+field[a][g2],field[a][f]+field[f][g1]+field[f][g2])));\n\t}\n}\n\nint main(void){\n\tint a,b;\n\twhile(1){\n\t\tfor(b=0;b<=100;b++){\n\t\t\tcosts[b]=INF;\n\t\t\tfor(a=0;a<=100;a++){\n\t\t\t\tfield[a][b]=INF;\n\t\t\t\tif(a==b)field[a][b]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\t\tfor(a=0;a<m;a++){\n\t\t\tcin >> f >> t >> c;\n\t\t\troot();\n\t\t}\n\t\tcout << costs[s] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tvector<vector<int>>data;\n\t\tdata.resize(n);\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[i].resize(n);\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdata[i][j] = INT_MAX / 6;\n\t\t\t}\n\t\t\tdata[i][i] = 0;\n\t\t}\n\t\tint a, b, c;\n\t\tfor (size_t i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdata[a][b] = c;\n\t\t\tdata[b][a] = c;\n\t\t}\n\t\tfor (size_t k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t\tdata[j][i] = data[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INT_MAX;\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tans = min(ans, data[i][s] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\ntemplate<int inf = std::numeric_limits<Weight>::max() / 8> Matrix warshallFloyd(const Graph &g) {\n  int n = g.size();\n  Matrix d(n, Array(n, inf));\n  rep(i, n) d[i][i] = 0;\n  for (auto &adj : g) {\n    for (auto &e : adj) cmin(d[e.src][e.dst], e.weight);\n  }\n  rep(k, n) rep(i, n) rep(j, n) {\n    if (d[i][k] != inf && d[k][j] != inf) cmin(d[i][j], d[i][k] + d[k][j]);\n  }\n  return d;\n}\n\nmain {\n  int n, m, s, g1, g2;\n  while (cin >> n >> m >> s >> g1 >> g2, n) {\n    --s, --g1, --g2;\n    Graph g(n);\n    while (m--) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      --b1, --b2;\n      g.addArc(b1, b2, c);\n    }\n    Matrix d = warshallFloyd<INF>(g);\n    int mini = INF;\n    rep(i, n) cmin(mini, d[s][i] + d[i][g1] + d[i][g2]);\n    cout << mini << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint d[105][105];\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (d, 0, sizeof (d) );\n\t\trep (i, n ) rep (j, n ) d[i][j] = (i != j ? INF: 0 );\n\t\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\td[from][to] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\n\t\twarshall_floyd (n );\n\n\t\trep (i, n ){\n\t\t\tint curr = d[s][i] + d[i][g1] + d[i][g2];\n\t\t\tres = min (res, curr );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 105;\nconst int INF = 1e9;\n\nint main() {\n  int G[MAX_N][MAX_N], N, M, S, G1, G2;\n  while(cin >>N >>M >>S >>G1 >>G2 && N){\n    --S; --G1; --G2;\n    REP(i, N) REP(j, N) G[i][j] = (i == j ? 0 : INF);\n    REP(i, M){\n      int f, t, c; cin >>f >>t >>c;\n      G[f - 1][t - 1] = c;\n    }\n    int ans = INF;\n    REP(k, N) REP(i, N) REP(j, N) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    REP(i, N) ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint cost[200][200];\nsigned main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s,&g1,&g2),n){\n\t\ts--;g1--;g2--;\n\t\tmemset(cost,0x1f,sizeof(cost));\n\t\trep(i,m){\n\t\t\tint b1,b2,c;scanf(\"%lld%lld%lld\",&b1,&b2,&c);b1--;b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint Min=INT_MAX;\n\t\trep(i,n){\n\t\t\tMin=min(Min,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tprintf(\"%lld\\n\",Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 50000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = (table[j][k] < (table[j][i] + table[i][k]) ?\n\t\t\t\t\ttable[j][k] : (table[j][i] + table[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e8;\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2) {\n\t\ts--, g1--, g2--;\n\t\tvector<vector<int>> G(n, vector<int>(n, INF));\n\t\tfor (int i = 0; i < n; i++) G[i][i] = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c; b1--, b2--;\n\t\t\tG[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nint d[100][100];\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2){\n\t\ts--;g1--;g2--;\n\t\trep(i,n)rep(j,n)d[i][j]=INF;\n\t\trep(i,n)d[i][i]=0;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a-1][b-1]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\tint ans=INF;\n\t\trep(i,n){\n\t\t\tans = min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int to, cost; \n    edge(int t, int c): to(t), cost(c) {}\n};\nconst int INF = 1e8;\n\nvoid dijkstra(const vector<vector<edge> > &G, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    typedef pair<int, int> P;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0, s));\n\n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i=0; i<G[v].size(); ++i) {\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<vector<edge> > G(n);\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            G[b1-1].push_back(edge(b2-1, c));\n        }\n        REP(i, n) {\n            dijkstra(G, d[i], i);\n        }\n        int ans = 0;\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\ntypedef int W;\nconst int MAXV = 1005;\nconst int MAXE = 5005;\nconst int INF = 100000000;\nint adj[100][100];\n\nint main() {\n  int n,m,s,g1,g2,b1,b2,c;\n\n  while(~scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2),\n        n|m|s|g1|g2) {\n    s--,g1--,g2--;\n\n    for(int i = 0; i < 100; ++i) {\n      for (int j = 0; j < 100; ++j)\n        adj[i][j] = INF;\n      adj[i][i] = 0;\n    }\n\n    for(int i=0; i<m; ++i) {\n      scanf(\"%d%d%d\", &b1, &b2, &c);\n      b1--,b2--;\n      adj[b1][b2] = c;\n    }\n\n    for (int k = 0; k < n; ++k)\n      for (int i = 0; i < n; ++i) {\n        const int p = adj[i][k];\n        for (int j = 0; j < n; ++j)\n          adj[i][j] = min(adj[i][j], p + adj[k][j]);\n      }\n\n    int minc = INF;\n    for(int i=0; i<n; ++i)\n      minc = min(minc, adj[s][i]+adj[i][g1]+adj[i][g2]);\n\n    printf(\"%d\\n\", minc);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<MAX;i++ ) {\n    for( int j=0;j<MAX;j++ ) {\n      pipe[i][j]=INF;\n      pipe[i][i]=0;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAX_V = 101;\nconst int INF=100000000;\nint d[MAX_V][MAX_V];\nint V;\nvoid warshall_floyd(){\n    for(int i = 0; i < V; i++)\n        for(int j = 0; j < V; j++)\n            for(int k = 0; k < V; k++)\n                d[j][k] = min(d[j][k],d[j][i]+d[i][k]);\n}\nint main(){\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2&&!(n==0&&m==0&&s==0&&g1==0&&g2==0)){\n        for(int i = 0; i < MAX_V; i++)\n            for(int j = 0; j < MAX_V; j++)\n                if(i==j)\n                    d[i][j]=0;\n                else\n                    d[i][j]=INF;\n        s--;g1--;g2--;\n        for(int i = 0; i < m; i++){\n            int b1,b2,c;\n            cin>>b1>>b2>>c;\n            b1--;b2--;\n            d[b1][b2]=c;\n        }\n        V=n;\n        warshall_floyd();\n        int minCost=INF;\n        for(int i = 0; i < n; i++)\n            minCost=min(minCost,d[s][i]+d[i][g1]+d[i][g2]);\n        cout<<minCost<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int INF = 1 << 28;\n\nint N, M, S, G1, G2;\nint B1[1000], B2[1000], C[1000];\n\nint graph[100][100];\n\nint solve() {\n    assert(N <= 100);\n    int min_dist[100][100];\n    for (int j = 0; j < N; ++j) { fill(min_dist[j], min_dist[j]+N, INF); min_dist[j][j] = 0; }\n    for (int j = 0; j < M; ++j) min_dist[B1[j]][B2[j]] = min_dist[B2[j]][B1[j]] = C[j];\n    \n    for (int l = 0; l < N; ++l) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                int cand = min_dist[j][l] + min_dist[l][k];\n                if (cand < min_dist[j][k]) min_dist[j][k] = cand;\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < N; ++j) {\n        int cand = min_dist[S][j] + min_dist[j][G1] + min_dist[j][G2];\n        if (cand < ans) {\n            ans = cand;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (true) {\n        cin >> N >> M >> S >> G1 >> G2;\n        if (N == 0 && M == 0 && S == 0 && G1 == 0 && G2 == 0) break;\n        --S; --G1; --G2;\n        for (int j = 0; j < M; ++j) {\n            cin >> B1[j] >> B2[j] >> C[j];\n            --B1[j]; --B2[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n#define MP make_pair\n#define umap unordered_map\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef unsigned int uint;\n\nint v[110][110];\nint main(){\n\tios::sync_with_stdio(false);\n\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n){\n\t\t--s, --g1, --g2;\n\t\tMEMSET(v, 0x7f);\n\t\trep(i, n) v[i][i] = 0;\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tv[a - 1][b - 1] = c;\n\t\t}\n\n\t\trep(i, n) rep(j, n) rep(k, n) v[j][k] = min((ll)v[j][k], (ll)v[j][i] + v[i][k]);\n\n\t\tll ans = 1e8;\n\t\trep(i, n){\n\t\t\tans = min(ans, (ll)v[s][i] + v[i][g1] + v[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tvector<vector<vector<ll> > > d(n, vector<vector<ll> >(n, vector<ll>(n, INF)));\n\t\t// ????????°????????§???????°´????????????????????????????????\\????????????????????????\n\t\tREP(i, n) {\t\t// ?????????\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\t\t// ??\\???\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\t// ???????????£???????????????\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 99999999;\n\nvoid solve()\n{\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2, n || m || s || g1 || g2)\n\t{\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tint d[101][101];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint From, To, Cost;\n\t\t\tcin >> From >> To >> Cost;\n\t\t\t--From;\n\t\t\t--To;\n\t\t\td[From][To] = Cost;\n\t\t\td[To][From] = Cost;\n\t\t}\n\t\tfor(int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint Min = INF;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tsum += d[i][s];\n\t\t\tsum += d[i][g1];\n\t\t\tsum += d[i][g2];\n\t\t\tMin = min(Min, sum);\n\t\t}\n\t\tcout << Min << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 10e8\nusing namespace std;\n\nint cost[100][100];\n\nint main(void){\n\tint n,m,s,g1,g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2,n|m|s|g1|g2){\n\t\ts--,g1--,g2--;\n\t\tfor(int i=0;i<100;i++)\n\t\t\tfor(int j=0;j<100;j++)\n\t\t\t\tcost[i][j]=INF;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint b1,b2,c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tb1--,b2--;\n\t\t\tcost[b1][b2]=c;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\n\t\tint ans=INF;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tans=min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\tcout << ans << endl;\n\t}\t\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile( true ){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint b1;\n\t\tint b2;\n\t\tint c;\n\n\t\tvector< vector < int > > map(n + 1, vector< int >(n + 1, INT_MAX / 4));\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tmap[b1][b2] = c;\n\t\t\tmap[b2][b1] = c;\n\t\t}\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tmap[i][i] = 0;\n\t\t}\n\n\t\tint total = INT_MAX / 2;\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\ttotal = min(total, map[s][k] + map[k][g1] + map[k][g2]);\n\t\t}\n\n\t\tcout << total << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,m,s,g1,g2;\n  while(true){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0) break;\n    s--,g1--,g2--;\n    const long long int INF=1e10;\n    vector<vector<long long int>> d(n,vector<long long int>(n,INF));\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      d[b1][b2]=c;\n    }\n    \n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    long long int res=1e10;\n    for(int g=0;g<n;g++){\n      long long int share=d[s][g];\n      long long int cost1=d[g][g1];\n      long long int cost2=d[g][g2];\n      long long int cost=share+cost1+cost2;\n      res=min(res,cost);\n    }\n    \n    cout<<res<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main()\n{\n\tint n,m,s,g1,g2,b1,b2,c,i,j,k,d[101][101],V=INT_MAX/5;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n)\n\t{\n\t\tfor(i=1;i<=n;d[i][i]=0,++i)for(j=1;j<=n;++j)d[i][j]=V;\n\t\twhile(m--)scanf(\"%d%d%d\",&b1,&b2,&c),d[b1][b2]=c;\n\t\tfor(k=1;k<=n;++k)for(i=1;i<=n;++i)for(j=1;j<=n;++j)\n\t\t\tc=d[i][k]+d[k][j],d[i][j]=(d[i][j]<c?d[i][j]:c);\n\t\tfor(c=V,i=1;i<=n;++i)\n\t\t\tk=d[s][i]+d[i][g1]+d[i][g2],c=(c<k?c:k);\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919\nusing namespace std;\n\nint dp[110][110];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(F!=dp[i][k]){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(F!=dp[k][j])\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define MAXNUM 100\n\nint p[MAXNUM], rank[MAXNUM];\n\nstruct edge{\n\tint from;\n\tint to;\n\tint cost;\n};\n\nint cmp(const void *a,const void *b){\n\tedge *t1 = (struct edge *)a;\n\tedge *t2 = (struct edge *)b;\n\treturn t1->cost - t2->cost;\n}\n\nvoid init(void){\n\tfor(int i = 0;i < MAXNUM;i++){\n\t\tp[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(x == p[x])\n\t\treturn x;\n\telse\n\t\treturn p[x] = find(p[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y]){\n\t\tp[x] = y;\n\t}\n\telse{\n\t\tp[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\n\n\nint main(void){\n\tint n, m, s, g1, g2, i, j, max, sum, cnt[100];\n\tstruct edge e[100];\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d\",&e[i].from,&e[i].to,&e[i].cost);\n\t\t\te[i].from--, e[i].to--;\n\t\t}\n\t\tqsort(e,m,sizeof(e[0]),cmp);\n\t\tmax = 1;\n\t\tinit();\n\t\tsum = 0;\n\t\tfor(i = 0;i < m && max < n;i++){\n\t\t\tif(find(e[i].from) != find(e[i].to)){\n\t\t\t\tunite(e[i].from,e[i].to);\n\t\t\t\tsum += e[i].cost;\n\t\t\t}\n\t\t\tmemset(cnt,0,sizeof(cnt));\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tcnt[find(j)]++;\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tif(max < cnt[j]) max = cnt[j];\n\t\t}\n\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 200\n#define INF (1<<26)\n\nint n,m,s,g1,g2,a,b,c;\nint t[MAX][MAX];\n\nvoid init(){\n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      t[i][j]=(i==j?0:INF);\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n    s--,g1--,g2--;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c;\n      a--,b--;\n      t[a][b]=c;\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  t[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n    int ans=INF;\n    for(int i=0;i<n;i++)\n      ans=min(ans,t[s][i]+t[i][g1]+t[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint main(){\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2,n!=0){\n        s--, g1--, g2--;\n\n        vvi G(n, vi(n, 1e8));\n        rep(i, m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--, b--;\n            G[a][b] = G[b][a] = c;\n        }\n\n        rep(k, n)rep(i, n)rep(j, n){\n            G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n\n        int ans = 1e8;\n        rep(i, n){\n            ans = min(ans, G[s][i] + G[i][g1] + G[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=INT_MAX;\nconst int MAX_V=200;\n#define int long long\nsigned main(){\n\n  for(;;){\n  int v,m,s[3];\n  cin>>v>>m;\n  for(int i=0;i<3;i++) cin>>s[i];\n  s[0]--;\n  s[1]--;\n  s[2]--;\n\n  if(!v) break;\n\n  int G[MAX_V][MAX_V];\n\n  for(int i=0;i<v;i++) for(int j=0;j<v;j++) G[i][j]=1e9;\n  for(int i=0;i<v;i++) G[i][i]=0;\n\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--,b2--;\n    G[b1][b2]=c;\n    G[b2][b1]=c;\n  }\n\n  for(int k=0;k<v;k++)\n    for(int i=0;i<v;i++)\n      for(int j=0;j<v;j++) G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n  int r=1e9;\n\n  for(int i=0;i<v;i++) r=min(r,G[i][s[0]]+G[i][s[1]]+G[i][s[2]]);\n\n  cout<<r<<endl;\n\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N = 100, INF = (int)1e8;\n\nint n;\nint dp[MAX_N][MAX_N];\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g[2];\n\t\tstd::cin >> n >> m >> s >> g[0] >> g[1];\n\t\t--s;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t--g[i];\n\t\tif (n + m + s + g[0] + g[1] == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i][i] = 0;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tdp[a][b] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdp[j][k] = std::min(dp[j][k], dp[j][i] + dp[i][k]);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = std::min(ans, dp[s][i] + dp[i][g[0]] + dp[i][g[1]]);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int d[101][101];\n  for(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2;){\n    for(int y=1;y<=n;y++){\n      for(int x=1;x<=n;x++){\n\td[y][x]=(y==x)?0:1<<28;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      d[b1][b2]=c;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int ans=1<<30;\n    for(int i=1;i<=n;i++){\n      ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tll n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tif(n == 0) break;\n\t\tll d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tll b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 100\n#define min(a,b) (a>b?b:a)\n#define INF 100000000\n\nint main() {\n\tint n, m, s, g1, g2, b1, b2, c, ans;\n\tstatic int cost[N+1][N+1][N+1];\n\twhile(1) {\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(!n&&!m&&!s&&!g1&&!g2) break;\n\t\tfor(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) {\n\t\t\tfor(int k=0; k<=n; ++k) cost[i][j][k] = (i==j?0:INF);\n\t\t}\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tcost[b1][b2][0] = c;\n\t\t}\n\t\tfor(int k=1; k<=n; ++k) {\n\t\t\tfor(int i=1; i<=n; ++i) {\n\t\t\t\tfor(int j=1; j<=n; ++j) {\n\t\t\t\t\tcost[i][j][k]= min(cost[i][j][k-1], cost[i][k][k-1]+cost[k][j][k-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tans = min(cost[s][i][n]+cost[i][g1][n]+cost[i][g2][n], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> using namespace std; int main() { int n,m,s,g1,g2,a,b,cost,mi; int map[101][101]; while(1){ cin>>n>>m>>s>>g1>>g2; if(n==0 && m==0 && s==0 && g1==0 && g2==0)break; for(int i=0;i<n+1;i++){ for(int j=0;j<n+1;j++){ if(i==j)map[i][j]=0; else map[i][j]=1000000; } } for(int i=0;i<m;i++){ cin>>a>>b>>cost; map[a-1][b-1]=cost; } for(int i=0;i<n;i++){ for(int j=0;j<n;j++){ for(int k=0;k<n;k++){ map[j][k]=min(map[j][k],map[j][i]+map[i][k]); } } } mi=1000000; for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]); cout<<mi<<endl; } return 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919\nusing namespace std;\n\nint dp[100][100];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(F!=dp[i][j]){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(F!=dp[i][k]&&F!=dp[k][j])\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n,m,s,g1,g2,a,b,cost,mi;\n  int map[101][101];\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<n+1;i++){\n      for(int j=0;j<n+1;j++){\n\tif(i==j)map[i][j]=0;\n\telse map[i][j]=1000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>cost;\n      map[a-1][b-1]=cost;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  map[j][k]=min(map[j][k],map[j][i]+map[i][k]);\n\t}\n      }\n    }\n    mi=1000000;\n    for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]);\n    cout<<mi<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nusing weight = int;\n\nconstexpr weight INF = 1e8;\n\n// warshall-floyd\nvoid warshall_floyd(std::vector<std::vector<weight>>& g) {\n    int V = g.size();\n    for(int k=0; k<V; ++k) {\n        for(int i=0; i<V; ++i) {\n            for(int j=0; j<V; ++j) {\n                g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);\n            }\n        }\n    }\n}\n\n\nint main() {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n) {\n        vector<vector<weight>> d(n, vector<weight>(n, INF));\n        for(int i=0; i<n; ++i) {\n            d[i][i] = 0;\n        }\n        for(int i=0; i<m; ++i) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            d[b1-1][b2-1] = c;\n        }\n        warshall_floyd(d);\n        weight ret = INF;\n        for(int i=0; i<n; ++i) {\n            ret = min(ret, d[s-1][i] + d[i][g1-1] + d[i][g2-1]); // 1e9 * 3 overflow\n        }\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\tvvi cost(n,vi(n,INT_MAX/10));\n\t\tREP(i,n){\n\t\t\tcost[i][i]=0;\n\t\t}\n\t\tREP(i,m){\n\t\t\tint b1,b2,c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\tcost[b1-1][b2-1]=c;\n\t\t}\n\t\tREP(k,n)\n\t\t\tREP(i,n)\n\t\t\t\tREP(j,n){\n\t\t\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint best=INT_MAX;\n\t\tREP(i,n){\n\t\t\tbest=min(best,cost[s-1][i]+cost[i][g1-1]+cost[i][g2-1]);\n\t\t}\n\t\tcout<<best<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <set>\n#include <map>\n#include <string>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nnamespace patch\n{\n    template < typename T > std::string to_string( const T& n )\n    {\n        std::ostringstream stm ;\n        stm << n ;\n        return stm.str() ;\n    }\n}\n\nint n,m,s,g1,g2;\nint d[111][111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n==0)break;\n\t\ts--; g1--; g2--;\n\t\trep(i,111)rep(j,111)d[i][j]=INF;\n\t\trep(i,111)d[i][i]=0;\n\t\trep(i,m){\n\t\t\tint v,u,c;\n\t\t\tcin>>v>>u>>c;\n\t\t\tv--; u--;\n\t\t\td[v][u]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)minch(d[i][j],d[i][k]+d[k][j]);\n\t\tint res=INF;\n\t\trep(i,n)minch(res,d[s][i]+d[i][g1]+d[i][g2]);\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919\nusing namespace std;\n\nint dp[110][110];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 9999999\nint n, m, s, g1, g2;\nint D[100][100];\n\nint cost[100][100];\n\nvoid wf() {\n  for(int m = 0; m < n; ++m) {\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n\tD[i][j] = min(D[i][j], D[i][m] + D[m][j]);\n      }\n    }\n  }\n}\n\nvoid solve() {\n  wf();\n  int ans = INF;\n  for(int i = 0; i < n; ++i) {\n    ans = min(ans, D[s][i] + D[i][g1] + D[i][g2]);\n  }\n  cout << ans << endl;\n}\n\nmain() {\n  while((cin >> n >> m >> s >> g1 >> g2) &&\n\t(n || m || s || g1 || g2)) {\n    s--; g1--; g2--;\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n\tD[i][j] = i == j ? 0 : INF;\n      }\n    }\n    for(int i = 0; i < m; ++i) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      D[b1][b2] = c;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nint d[101][101];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,m,s,a,b;\n\twhile(cin >> n >> m >> s >> a >> b,n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(i==j)d[i][j]=0;\n\t\t\t\telse d[i][j]=1e8;\n\t\t\t}\n\t\t}\n\t\ts--; a--; b--;\n\t\twhile(m--){\n\t\t\tint x,y,z; cin >> x >> y >> z;\n\t\t\tx--; y--;\n\t\t\td[x][y]=z;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=1e9;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres=min(res,d[s][i]+d[i][a]+d[i][b]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\nvoid Dijkstra(int n, int s, int edge[][100], int node[])\n{\n    int close[100]={0};\n    int mn;\n    node[s] = 0;\n    for(int i=0;i<n;++i)\n    {\n        close[s] = 1;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && edge[s][j] && node[j] > node[s]+edge[s][j])\n            {\n                node[j] = node[s]+edge[s][j];\n            }\n        }\n        mn = INT_MAX;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && mn > node[j])\n            {\n                mn = node[j];\n                s = j;\n            }\n        }\n    }\n}\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int node1[100];\n    int node2[100];\n    int node3[100];\n    int close[100]={0};\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;++j) edge[i][j] = 0;\n            node1[i] = INT_MAX;\n            node2[i] = INT_MAX;\n            node3[i] = INT_MAX;\n        }\n        for(int i=0;i<m;++i)\n        {\n            cin >> b1 >> b2 >> c;\n            --b1;--b2;\n            edge[b1][b2] = c;\n            edge[b2][b1] = c;\n        }\n        Dijkstra(n,s-1,edge,node1);\n        Dijkstra(n,g1-1,edge,node2);\n        Dijkstra(n,g2-1,edge,node3);\n        mn = INT_MAX;\n        for(int i=0;i<n;++i) mn = min(mn, node1[i]+node2[i]+node3[i]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+9\nusing namespace std;\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(1){\n\t\tcin >> n >> m >> s >> g1 >> g2; s--;g1--;g2--;\n\t\tif(!n) break;\n\t\tint cost[100][100];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++) cost[i][j] = INF;\n\t\t\tcost[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a - 1][b - 1] = c;\n\t\t}\n\t\tfor(int k = 0;k < n;k++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = min(cost[i][j],cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tmi = min(mi,cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tVV(int) vv;\n\t\tinitvv(vv,n,n);\n\t\trep(i,n) rep(j,n) vv[i][j]=INF;\n\t\tvvint vvr=vv;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tvv[a][b]=c;\n\t\t\tvvr[b][a]=c;\n\t\t}\n\t\t// cout<<0<<endl;\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tvv[i][j]=min(vv[i][j],vv[i][k]+vv[k][j]);\n\t\t\t\t\tvvr[i][j]=min(vvr[i][j],vvr[i][k]+vvr[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tvv[i][i]=0;\n\t\t\tvvr[i][i]=0;\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,n){\n\t\t\tans=min(ans,vvr[i][s]+vv[i][g1]+vv[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t\t/*\n\t\tpriority_queue<pii> pq;\n\t\tvint v(n,-1);\n\t\tpq.push(mkp(0,s));\n\t\twhile(!pq.empty()){\n\t\t\tpii t=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(v[t.S]!=-1) continue;\n\t\t\tcout<<-t.F<<\" \"<<t.S<<endl;\n\t\t\tv[t.S]=-t.F;\n\t\t\trep(i,vv[t.S].size()){\n\t\t\t\t// cout<<vv[t.S][i].F<<endl;\n\t\t\t\tif(v[vv[t.S][i].F]==-1){\n\t\t\t\t\tpq.push(mkp(t.F-vv[t.S][i].S,vv[t.S][i].F));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t// cout<<v[g1]+v[g2]<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1e7\nusing namespace std;\nint main(){\n  int n,m,x,y,z,q,w,e;\n  while(cin>>n>>m>>x>>y>>z,n++){\n    int dp[n][n]={};\n    r(i,n)r(j,n)if(i!=j)dp[i][j]=INF;\n    r(i,m){\n      cin>>q>>w>>e;\n      dp[q][w]=e;\n    }\n    r(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n    int ans=INF;\n    r(i,n)ans=min(ans,dp[i][x]+dp[i][y]+dp[i][z]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1e9\nusing namespace std;\nint n;\nint s;\nint m;\nint g1;\nint g2;\nint cost[101][101];\nint d[101];\nint color[101];\n\nint dijkstra(int S){\n\tint d[101];\n\tint color[101];\n\tint u;\n\tfor(int i = 0;i <= n;i++){\n\t\td[i] = INF;\n\t\tcolor[i] = WHITE;\n\t}\n\td[S] = 0;\n\tcolor[S] = GRAY;\n\twhile(1){\n\t\tu = -1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tif(color[i] == BLACK)continue;\n\t\t\tif(color[i] == GRAY){\n\t\t\t\tif(u == -1 || d[i] < d[u])u = i;\n\t\t\t}\n\t\t}\n\t\tif(u == -1)break;\n\t\tcolor[u] = BLACK;\n\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tif(color[i] == BLACK)continue; \n\t\t\td[i] = min(d[i],d[u] + cost[u][i]);\n\t\t\tcolor[i] = GRAY;\n\t\t}\n\t}\n\t//for(int i = 1;i <= n;i++){\n\t//\tcout << d[i] <<endl;\n\t//}\n\t//cout << d[s] << \" : \" << d[g1] << \" : \" << d[g2] << endl;\n\treturn d[s] + d[g1] + d[g2];\n}\n\nint main(){\n\tint x,y,c,res;\n\twhile(1){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(n == 0)break;\n\t\tres = INF;\n\t\tfor(int i = 0;i <= n;i++){\n\t\t\tfor(int j = 0;j <= n;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin >> x >> y >> c;\n\t\t\tcost[x][y] = cost[y][x] = c;\n\t\t}\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tres = min(res,dijkstra(i));\n\t\t}\n\t\tcout << res <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nusing pii = pair <int, int>;\n\nconst int N = 511;\nvector <pii> e[N], r[N];\nint f[N], g[N], h[N];\n\nvoid dij(int n, int s, vector <pii> *e, int *f) {\n\tfor(int i = 1; i <= n; i ++)\n\t\tf[i] = 1e8L;\n\tf[s] = 0; set <pii> st;\n\tfor(int i = 1; i <= n; i ++)\n\t\tst.insert({f[i], i});\n\twhile(!st.empty()) {\n\t\tpii p = *st.begin(); st.erase(st.begin());\n\t\tint u = p.second;\n\t\tfor(pii i : e[u]) {\n\t\t\tint v = i.first, w = i.second;\n\t\t\tif(f[u] + w < f[v]) {\n\t\t\t\tst.erase({f[v], v});\n\t\t\t\tf[v] = f[u] + w;\n\t\t\t\tst.insert({f[v], v});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(0);\n\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 && n) {\n\t\tfor(int i = 1; i <= n; i ++) {\n\t\t\te[i].clear();\n\t\t\tr[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < m; i ++) {\n\t\t\tint u, v, w; cin >> u >> v >> w;\n\t\t\te[u].pb({v, w});\n\t\t\tr[v].pb({u, w});\n\t\t}\n\t\tdij(n, s, e, f);\n\t\tdij(n, g1, r, g);\n\t\tdij(n, g2, r, h);\n\n\t\tint ans = 1e8L;\n\t\tfor(int i = 1; i <= n; i ++)\n\t\t\tans = min(ans, f[i] + g[i] + h[i]);\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e8\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n, m, s, g1, g2;\nint E[101][101];\nint dp[101][101];\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n){\n    s--; g1--; g2--;\n    rep(i, n) rep(j, n) E[i][j] = INF;\n    rep(i, m){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      E[b1][b2] = c;\n    }\n    //rep(i, n) rep(j, n) dp[i][j] = INF;\n    rep(i, n) rep(j, n) dp[i][j] = E[i][j];\n    rep(i, n) dp[i][i] = 0;\n    bool changed = true;\n    while(changed){\n      changed = false;\n      rep(k, n){      \n\trep(i, n){\n\t  rep(j, n){\n\t    if(dp[i][j] > dp[i][k] + dp[k][j]){\n\t      dp[i][j] = dp[i][k] + dp[k][j];\n\t      changed = true;\n\t    }\n\t  }\n\t}\n      }\n    }\n    int ans = INF;\n    rep(br, n){\n      ans = min(ans, dp[s][br] + dp[br][g1] + dp[br][g2]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int b1,b2,c;\n  int pipe[MAX][MAX];\n  int ans;\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      pipe[i][j]=INF;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      for( int k=0;k<n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  ans=INF;\n  for( int i=0;i<n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REAP(i,a,n) for(int i=(a);i<(n);i++)\n#define YES cout<<\"Yes\"<<endl\n#define NO cout<<\"No\"<<endl\n#define fr first\n#define sc second\n#define pb push_back\n#define All(v) v.begin(),v.end()\ntypedef long long ll;\n\nint rd[101][101];\n\nvoid solve(int n){\n\n    for(int k=0;k<n;k++){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                rd[i][j]=min(rd[i][j],rd[i][k]+rd[k][j]);\n            }\n        }\n    }\n}\n\n\nvoid init(){\n    REP(i,101){\n        REP(j,101){\n            rd[i][j]=1e9;\n            if(i==j)rd[i][j]=0;\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2,n){\n        s--;\n        g1--;\n        g2--;\n        int a,b,c;\n        init();\n        REP(k,m){\n            cin >> a >> b >> c;\n            a--;\n            b--;\n            rd[a][b]=c;\n        }\n        solve(n);\n\n        int res=INT_MAX;\n        for(int i=0;i<n;i++){\n            res = min(res, rd[s][i]+rd[i][g1]+rd[i][g2]);\n        }\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define INF 100000000\n\nint n,m,s,g1,g2;\nint t[101][101];\n\nint main(void){\n\twhile(cin>>n>>m>>s>>g1>>g2, n){\n\t\tfor(int i=0;i<=n;i++) for(int j=0;j<=n;j++) t[i][j] = INF;\n\t\tfor(int i=1;i<=n;i++) t[i][i] = 0;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,cost;\n\t\t\tcin>>a>>b>>cost;\n\t\t\tt[a][b] = cost;\n\t\t}\n\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tt[i][j] = min(t[i][j],t[i][k] + t[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans = min(ans,t[s][i]+t[i][g1]+t[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include <map>\n#include <list>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n#include <time.h>\nusing namespace std;\nclock_t fi, endtime;\n\nconst int r_c = 0;\nconst int r_t = 1;\nconst int MAX_V = 100;\nconst int MAX_E = 1000;\nconst int MAX_D = 1000;\nconst int MIN_D = 0;\n\nconst int INF = MAX_V * MAX_D * 2;\n\nint main()\n{\n\twhile (1) {\n\t\tint n, m, s, g1, g2;\n\t\tint b1, b2, c;\n\t\tint ans = 0;\n\t\tint wf[MAX_V][MAX_V];\n\t\tscanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n\t\tif (!n && !m && !s && !g1 && !g2) break;\n\t\t--s; --g1; --g2;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\twf[i][j] = INF;\n\t\t\t\tif (i == j) { wf[i][j] = 0; }\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tscanf(\"%d %d %d\", &b1, &b2, &c);\n\t\t\t--b1; --b2;\n\t\t\twf[b1][b2] = c;\n\t\t}\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\twf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = wf[s][g1] + wf[s][g2];\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tans = min(ans, wf[s][k] + wf[k][g1] + wf[k][g2]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint main(){\n\tfor(int n,m,a,b,c;scanf(\"%d%d%d%d%d\",&n,&m,&a,&b,&c),n;){\n\t\ta--,b--,c--;\n\t\tint wf[100][100];\n\t\trep(u,n)rep(v,n)\twf[u][v]=(u==v?0:INF);\n\t\trep(i,m){\n\t\t\tint s,d,cost;\tscanf(\"%d%d%d\",&s,&d,&cost);\n\t\t\ts--,d--;\n\t\t\twf[s][d]=cost;\n\t\t}\n\n\t\trep(k,n)rep(i,n)rep(j,n)\twf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\n\t\tint cmin=INF;\n\t\trep(u,n)\tcmin=min(cmin,wf[a][u]+wf[u][b]+wf[u][c]);\n\t\tprintf(\"%d\\n\",cmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MIN(X,Y) ((X)>(Y) ? (Y) : (X))\n\nint d[200][200];\n\nint main(void) {\n    while(1) {\n        int n,m,s,g1,g2;\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        if(!n) break;\n\n        s--, g1--, g2--;\n        memset(d, 0x20, sizeof(d));\n        for(int i=0;i<n;i++)\n            d[i][i] = 0;\n\n        for(int i=0;i<m;i++) {\n            int b,e,c;\n            scanf(\"%d%d%d\",&b,&e,&c);\n            b--, e--;\n            d[b][e] = c;\n        }\n\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                for(int k=0; k<n; k++)\n                    d[j][k] = MIN(d[j][k], d[j][i] + d[i][k]);\n\n        int res=0x5FFFFFFF;\n        for(int i=0; i<n; i++)\n            res = MIN(d[s][i]+d[i][g1]+d[i][g2], res);\n        printf(\"%d\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define inf (1<<27)\n#define rep(i,n)for(int i=0;i<n;i++)\nint cost[100][100];\nint n,m,s,g1,g2,b1,b2,c;\nint main() {\n\twhile(scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2),n) {\n\t\tfill(cost[0],cost[0]+100*100,inf);\n\t\trep(i,n)cost[i][i]=0;\n\t\trep(i,m) {\n\t\t\tscanf(\"%d %d %d\",&b1,&b2,&c);\n\t\t\tcost[b1-1][b2-1]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) {\n\t\t\tcost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t}\n\t\tint res=inf;\n\t\trep(k,n) {\n\t\t\tres=min(res,cost[s-1][k]+cost[k][g1-1]+cost[k][g2-1]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define MAX_V 1000\n\nstruct edge{\n\tlong long int to;\n\tlong long int cost;\n};\n\nlong long int INF = 1000000000000000;\n\ntypedef pair<long long int, long long int> P; // first??????????????¢???second??????????????????\n\nvector<edge> G[MAX_V];\nlong long int d[MAX_V];\n\n// ?????????O(|E|log|V|)\n\nvoid shortest_path(long long int s, long long int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(long long int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tlong long int v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(long long int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tlong long int n, m, s, g1, g2;\n\t\t\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\t\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tedge e1, e2;\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\te1.to = to;\n\t\t\te1.cost = cost;\n\t\t\te2.to = from;\n\t\t\te2.cost = cost;\n\t\t\tG[from].push_back(e1);\n\t\t\tG[to].push_back(e2);\n\t\t}\n\t\t\n\t\tlong long int ans = INF;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tshortest_path(s, n);\n\t\t\tlong long int cost_sum = d[i];\n\t\t\tshortest_path(i, n);\n\t\t\tcost_sum += d[g1] + d[g2];\n\t\t\tif(ans > cost_sum){\n\t\t\t\tans = cost_sum;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconstexpr int MAX_N = 100, INF = (int)1e8;\n\nint n;\nint dp[MAX_N][MAX_N];\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g[2];\n\t\tstd::cin >> n >> m >> s >> g[0] >> g[1];\n\t\t--s;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t\t--g[i];\n\t\tif (n + m + s + g[0] + g[1] == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tdp[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tdp[i][i] = 0;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> b >> c;\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tdp[a][b] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k)\n\t\t\t\t\tdp[j][k] = std::min(dp[j][k], dp[j][i] + dp[i][k]);\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = std::min(ans, dp[s][i] + dp[i][g[0]] + dp[i][g[1]]);\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1<<21\nusing namespace std;\nint d[100][100];\nint N, M;\n\nvoid warshall_floyd(){\n  for (int k = 0; k < N; k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\nint main()\n{\n  while(1){\n    int s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n    if (!N&&!M&&!s&&!g1&&!g2) break;   \n    for (int i = 0; i < N; i++){\n      fill_n(d[i], N, INF);\n    }\n    for (int i = 0; i < M; i++){\n      int u, v, c;\n      cin >> u >> v >> c;\n      d[u][v] = c;\n      d[v][u] = c;\n    }\n    warshall_floyd();\n    int res = INF;\n    for (int i = 0; i < N; i++){\n      res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef vector <vector<ll> > Vec;\n#define INF 10000000\n\nvoid war(Vec& vec) {\n\tint v = vec.size();\n\t\tfor (int k = 0; k < v; k++) {\n\t\t\tfor (int i = 0; i < v; i++) {\n\t\t\t\tfor (int j = 0; j < v; j++) {\n\t\t\t\t\tvec[i][j] = min(vec[i][j], vec[i][k] + vec[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g1, g2, a, b, c;\n\t\tVec G(n);\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\ts--; g1--; g2--;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tG[i].push_back(i != j ? INF : 0);\n\t\t\t}\n\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tcin >> a >> b >> c;\n\t\t\t\tG[a - 1][b - 1] = c;\n\t\t\t}\n\t\t\twar(G);\n\t\t\tll res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = min(res, G[s][i] + G[i][g1] + G[i][g2]);\n\t\t\t}\n\t\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\n#define INF 1e+9\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n\nusing namespace std;\n\nint main(){\n    int n,m,s,g1,g2;\n\n    while(cin >> n >> m >> s >> g1 >> g2){\n        if((n|m|s|g1|g2) == 0) break;\n        int cost[n][n];\n        int ret = 1 << 29;\n        int src,dst,c;\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cost[i][j] = INF;\n            }\n        }\n\n        for(int i=0;i<n;i++) cost[i][i] = 0;\n\n        //load roads lol\n        for(int i=0;i<m;i++){\n            cin >> src >> dst >> c;\n            cost[src-1][dst-1] = c;\n        }\n\n        //WF\n        for(int r=0;r<n;r++){\n            for(int p=0;p<n;p++){\n                for(int q=0;q<n;q++){\n                    cost[p][q] = min(cost[p][q], cost[p][r] + cost[r][q]);\n                }\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            ret = min(ret, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\n\nint d[MAX_N][MAX_N];\nint n,m,s,g1,g2;\n\nvoid warshall_floyd()\n{\n    rep(k,n){\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        s--,g1--,g2--;\n        if(n==0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                d[i][j] = INF;\n            }\n        }\n    \trep(i,m){\n    \t\tint x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);\n            d[x-1][y-1] = z;\n    \t}\n        warshall_floyd();\n        int res = INF;\n        rep(i,n){\n            res = min(res,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[111][111];\n  for(int i=0;i<111;i++){\n    for(int j=0;j<111;j++){\n      road[i][j]=INF;\n    }\n  }\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<n;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n,m,s,g1,g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0) return 0;\n    s--,g1--,g2--;\n    vector<vector<int>> dist(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) dist[i][i]=0;\n    int u,v,c;\n    for(int i=0;i<m;i++){\n      cin >> u >> v >> c;\n      u--,v--;\n      dist[u][v]=dist[v][u]=c;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);\n        }\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dist[s][i]+dist[g1][i]+dist[g2][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    int d[1001][1001]={};\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)if(i!=j)d[i][j]=1e8;\n    for(int i=0,a,b,c;i<m;i++)\n      cin>>a>>b>>c,d[a][b]=c;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n    int ans=1e9;\n    for(int i=1;i<=n;i++)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2,hoge[101][101],a,b,c;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0&&m==0&&s==0&&g1==0&&g2==0)break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\thoge[i][j] = 100000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b >> c;\n      hoge[a][b] = c;\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  if(hoge[j][k] > hoge[j][i] + hoge[i][k]){\n\t    hoge[j][k] = hoge[j][i] + hoge[i][k];\n\t  }\n\t}\n      }\n    }\n    int MIN=1000000000;\n    for(int i=1;i<=n;i++)\n      MIN = min(MIN,hoge[s][i]+hoge[i][g1]+hoge[i][g2]);\n    cout << MIN << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX_V 100\n#define INF 100000000\nusing namespace std;\n\nint V;\nint s, g1, g2;\nint d[MAX_V][MAX_V];\n\nvoid warshall_floyd(){\n  for(int k=0;k<V;k++){\n    for(int i=0;i<V;i++){\n      for(int j=0;j<V;j++){\n\td[i][j]=min(d[i][j], d[i][k]+d[k][j]);\n      }\n    }\n  }\n}\n\nmain(){\n  int n, m;\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n    s--;\n    g1--;\n    g2--;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j) d[i][j]=0;\n\telse d[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--;\n      b2--;\n      d[b1][b2]=c;\n    }\n    V=n;\n    warshall_floyd();\n    int ans=INF+INF;\n    for(int i=0;i<n;i++){\n      int tmp=d[s][i]+d[i][g1]+d[i][g2];\n      if(ans>tmp) ans=tmp;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint cost[105][105];\nint d[105][105];\t\t\t\t// 頂点 s からの最短距離\n\n// 始点 s から各頂点への最短距離を求める\n//int V;\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\td[i][j] = cost[i][j];\n\t\t} // end rep\n\t} // end rep\n\n\trep (i, V ) d[i][i] = 0;\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (cost, 0, sizeof (cost) );\n\t\trep (i, n ) rep (j, n ) cost[i][j] = INF;\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\tcost[from][to] = c;\n\t\t\tcost[to][from] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\t\twarshall_floyd (n );\n/*\n\t\trep (i, n ){\n\t\t\trep (j, n ){\n\t\t\t\tif (d[i][j] == INF ){\n\t\t\t\t\tcout << \"INF\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << setw(3) << d[i][j];\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tcout << endl;\n\t\t} // end rep\n*/\n\t\trep (i, n ){\n\t\t\tint curr1 = d[s][i] + d[i][g1] + d[i][g2];\n\t\t\tres = min (res, curr1 );\n\t\t\tint curr2 = d[s][i] + d[i][g1] + d[g1][g2];\n\t\t\tres = min (res, curr2 );\n\t\t\tint curr3 = d[s][i] + d[i][g2] + d[g2][g1];\n\t\t\tres = min (res, curr3 );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define BMAX 100\n#define DMAX 1000000\n\nusing namespace std;\n\nstruct data { \n\tint cost;\n\tint where;\n};\n\n//bool bind[BMAX][BMAX];\nint cost[BMAX][BMAX];\nbool check[BMAX];\n\nbool operator<( const data& a, const data& b) {\n\treturn a.cost < b.cost;\n}\n\nbool operator>( const data& a, const data& b) {\n\treturn a.cost > b.cost;\n}\n\nint main () {\n\tint count = 0;\n\twhile ( true ) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m>> s>> g1>> g2;\n\t\t//cout << \"Count: \" << count << endl;\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tif ( n == 0 )\n\t\t\tbreak;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcost[i][j] = DMAX;\n\t\t\t}\n\t\t}\n\n\t\tfor ( int i=0; i<m; i++ ) {\n\t\t\tint x,y,c;\n\t\t\tcin >> x >> y >> c;\n\t\t\t//\t\t\tcout << x << \"\\t\" << y << \"\\t\" << c << endl;\n\t\t\tcost[x-1][y-1] = c;\n\t\t\tcost[y-1][x-1] = c;\n\t\t}\n\n\t\t/*\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\tcout << cost[i][j] << \"\\t\";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\t\n\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tpriority_queue<data> flow;\n\n\t\t\twhile(!flow.empty()) {\n\t\t\t\tflow.pop();\n\t\t\t}\n\n\t\t\tdata now;\n\t\t\tnow.cost = 0;\n\t\t\tnow.where = i;\n\t\t\tflow.push(now);\n\n\t\t\twhile ( !flow.empty() ) {\n\t\t\t\tdata now = flow.top();\n\t\t\t\tflow.pop();\n\n\t\t\t\tdata next;\n\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tcheck[i] = true;\n\t\t\t\t}\n\t\t\t\tcheck[now.where] = false;\n\n\t\t\t\tfor ( int j=0; j<n; j++ ) {\n\t\t\t\t\tif ( check[i] ) {\n\t\t\t\t\t\tcheck[i] = false;\n\t\t\t\t\t\tint newCost = cost[i][now.where] + now.cost;\n\t\t\t\t\t\tif ( cost[i][j] >= newCost ) {\n\t\t\t\t\t\t\tif ( cost[i][j] > newCost )\n\t\t\t\t\t\t\t\tcost[i][j] = newCost;\n\t\t\t\t\t\t\tnext.cost = newCost;\n\t\t\t\t\t\t\tnext.where = j;\n\t\t\t\t\t\t\tflow.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint min = DMAX;\n\n\t\tfor ( int i=0; i<n; i++ ) {\n\t\t\tif ( min > cost[i][s] + cost[i][g1] + cost[i][g2] )\n\t\t\t\tmin = cost[i][s] + cost[i][g1] + cost[i][g2];\n\t\t}\n\n\t\tcout << min << endl;;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n#define INF (1<<25)\n\nusing namespace std;\n\nvoid Dijkstra(int n, int s, int edge[][100], int node[])\n{\n    int close[100]={0};\n    int mn;\n    node[s] = 0;\n    for(int i=0;i<n;++i)\n    {\n        close[s] = 1;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && edge[s][j] && node[j] > node[s]+edge[s][j])\n            {\n                node[j] = node[s]+edge[s][j];\n            }\n        }\n        mn = INF;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && mn > node[j])\n            {\n                mn = node[j];\n                s = j;\n            }\n        }\n    }\n}\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int node1[100];\n    int node2[100];\n    int node3[100];\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;++j) edge[i][j] = 0;\n            node1[i] = INF;\n            node2[i] = INF;\n            node3[i] = INF;\n        }\n        for(int i=0;i<m;++i)\n        {\n            cin >> b1 >> b2 >> c;\n            --b1;--b2;\n            edge[b1][b2] = c;\n            edge[b2][b1] = c;\n        }\n        Dijkstra(n,s-1,edge,node1);\n        Dijkstra(n,g1-1,edge,node2);\n        Dijkstra(n,g2-1,edge,node3);\n        /*\n        for(int i=0;i<n;++i) cout << node1[i] << ' ';\n        cout << endl;\n        for(int i=0;i<n;++i) cout << node2[i] << ' ';\n        cout << endl;\n        for(int i=0;i<n;++i) cout << node3[i] << ' ';\n        cout << endl;\n        */\n        mn = INF;\n        for(int i=0;i<n;++i) mn = min(mn, node1[i]+node2[i]+node3[i]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100\n#define INF (1<<29)\n\nint main()\n{\n    int N, M, s, g1, g2;\n    while (cin >> N >> M >> s >> g1 >> g2, N) {\n        s--; g1--; g2--;\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            d[a][b] = c;\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        int res = INF;\n        for (int i = 0; i < N; i++) {\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst D EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** Problem2005 : Water Pipe Construction **/\nint d[100][100];\nint V;\n\nvoid warshall_floyd()\n{\n\trep(k, V) {\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint M, S, G1, G2;\n\twhile (cin>>V>>M>>S>>G1>>G2, V||M||S||G1||G2) {\n\t\tfill(d[0], d[0]+100*100, INF);\n\t\t\n\t\trep(i, M) {\n\t\t\tint a, b, c;\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\t\n\t\twarshall_floyd();\n\t\n\t\tint ans=INF;\n\t\trep(i, V) {\n\t\t\tint tmp = d[S][i]+d[i][G1]+d[i][G2];\n\t\t\tans = min(ans, tmp);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile( true ){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint b1;\n\t\tint b2;\n\t\tint c;\n\n\t\tvector< vector < int > > map(n + 1, vector< int >(n + 1, INT_MAX / 4));\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tmap[b1][b2] = c;\n\t\t\tmap[b2][b1] = c;\n\t\t}\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tmap[i][i] = 0;\n\t\t}\n\n\t\tint total = INT_MAX / 2;\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\ttotal = min(total, map[s][k] + map[k][g1] + map[k][g2]);\n\t\t}\n\n\t\tcout << total << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<vector>\nusing namespace std;\n\nclass state{\npublic:\n\tint now,cost;\n\tstate(int now,int cost):now(now),cost(cost){}\n};\n\nbool operator <(state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint n,m,s,g1,g2;\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint cost_s[101],cost_g1[101],cost_g2[101];\n\nint main()\n{\n\twhile(cin>>n>>m>>s>>g1>>g2 && n!=0){\n\t\tvector<vector<edge> > E(n+1);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint in,out,c; cin>>in>>out>>c;\n\t\t\tE[in].push_back(edge(out,c));\n\t\t\tE[out].push_back(edge(in,c));\n\t\t}\n\t\tint ans=10000000;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tcost_s[i]=cost_g1[i]=cost_g2[i]=10000000;\n\t\t}\n\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(s,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_s[info.now]) continue;\n\t\t\tcost_s[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\t\t\n\t\tQ.push(state(g1,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g1[info.now]) continue;\n\t\t\tcost_g1[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tQ.push(state(g2,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate info=Q.top();\n\t\t\tQ.pop();\n\t\t\tif(info.cost>=cost_g2[info.now]) continue;\n\t\t\tcost_g2[info.now]=info.cost;\n\t\t\tfor(int i=0;i<E[info.now].size();i++){\n\t\t\t\tQ.push(state(E[info.now][i].to,info.cost+E[info.now][i].cost));\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<101;i++){\n\t\t\tans=min(ans,cost_s[i]+cost_g1[i]+cost_g2[i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// bad knowhow\n#define REP(i,n) for(long long i=0;i<(long long)n;++i)\n\n#define INF 10000001\n#define MAX_SIZE 101\nlong long g_d[MAX_SIZE][MAX_SIZE];\nvoid warshall_floyd(int v) {\n\tREP(k, v) REP(i, v) REP(j,v) g_d[i][j] = min(g_d[i][j], g_d[i][k]+g_d[k][j]);\n}\n\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\n\twhile (true) {\n\t\tint n,m,s,g1,g2;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\t--s; --g1; --g2;\n\t\tif (n==0) break;\n\n\t\t// memsetはシングルバイトのみ\n\t\tfill(*g_d, *g_d + MAX_SIZE*MAX_SIZE, INF);\n\t\tREP(i, MAX_SIZE) g_d[i][i] = 0;\n\n\t\tREP(i, m) {\n\t\t\tint b1,b2;\n\t\t\tcin >> b1 >> b2;\n\t\t\t--b1; --b2;\n\t\t\tcin >> g_d[b1][b2];\n\t\t}\n\n\t\twarshall_floyd(n);\n\n\t\tlong long cost = INF;\n\t\tREP(i, n) cost = min(cost, g_d[s][i] + g_d[i][g1] + g_d[i][g2]);\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst int INF = 1e18;\nvoid solve(int N,int M){\n  int s,g1,g2;cin >> s >> g1 >> g2;\n  s--,g1--,g2--;\n  vector<vector<int>> dist(N,vector<int>(N,INF));\n  for(int i=0;i<N;i++) dist[i][i] = 0;\n  for(int i=0;i<M;i++){\n    int a,b,c;cin >> a >> b >> c;\n    a--;b--;\n    dist[a][b]=c;\n  }\n  for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++){\n    chmin(dist[i][j],dist[i][k]+dist[k][j]);\n  }\n  int ans = INF;\n  for(int t=0;t<N;t++){\n    chmin(ans,dist[s][t]+dist[t][g1]+dist[t][g2]);\n  }\n  cout << ans << endl;\n}\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(1){\n    int N,M;cin >> N >> M;\n    if(N==0) break;\n    solve(N,M);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[102][102];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                if(i == j) road[i][j] = 0;\n                else road[i][j] = 1000000000;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int k = 1; k < n + 1; k++){\n            for(int i = 1; i < n + 1; i++){\n                for(int j = 1; j < n + 1; j++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 1; i < n + 1; i++){\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1<<21\nusing namespace std;\nint d[128][128];\nint N, M;\n\nvoid warshall_floyd(){\n  for (int k = 0; k < N; k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    int s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n \n    if (!N&&!M&&!s&&!g1&&!g2) break;   \n    s--;g1--;g2--;\n    for (int i = 0; i < N; i++){\n      fill_n(d[i], N, INF);\n    }\n    for (int i = 0; i < N; i++){\n      d[i][i] = 0;\n    }\n    for (int i = 0; i < M; i++){\n      int u, v, c;\n      cin >> u >> v >> c;\n      u--;v--;\n      d[u][v] = c;\n    }\n\n    warshall_floyd();\n    int res = INF;\n    for (int i = 0; i < N; i++){\n      res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2 && n){\n        s--;\n        g1--;\n        g2--;\n        VVI d(n,VI(n,INF));\n        REP(i,n) d[i][i] = 0;\n        REP(i,m){\n            int x, y, z;\n            cin >> x >> y >> z;\n            x--;\n            y--;\n            d[x][y] = z;\n        }\n        REP(i,n) REP(j,n) REP(k,n){\n            d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        }\n        int ans = INF;\n        REP(i,n) ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dst, cost; \n    edge(int s, int t, int c): src(s), dst(t), cost(c) {}\n    bool operator < (const edge &rhs) const {return cost > rhs.cost;}\n};\nconst int INF = 1e8;\n\nvoid dijkstra(const vector<vector<edge> > &G, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    typedef pair<int, int> P;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0, s));\n\n    while(!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(auto &e : G[v]) {\n            if(d[e.dst] > d[v] + e.cost) {\n                d[e.dst] = d[v] + e.cost;\n                que.push(P(d[e.dst], e.dst));\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<vector<edge> > G(n);\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            G[b1-1].push_back(edge(b1-1, b2-1, c));\n        }\n        REP(i, n) {\n            dijkstra(G, d[i], i);\n        }\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,m,s,t1,t2;\n  while(cin>>n>>m>>s>>t1>>t2,n) {\n    s--;t1--;t2--;\n    int g[n][n], dis[n][n];\n    REP(i,n)REP(j,n)g[i][j] = INF;\n    REP(i,m) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      a--;b--;\n      g[a][b] = c;\n    }\n    memcpy(dis, g, sizeof(g));\n    REP(k,n) REP(i,n) REP(j,n)\n      if (dis[i][j] > dis[i][k]+dis[k][j])\n        dis[i][j] = dis[i][k]+dis[k][j];\n    int res = INF;\n    // REP(i,n) REP(j,n) {\n    //   printf(\"%d,%d %d\\n\",i,j,dis[i][j]);\n    // }\n    REP(i,n) {\n      res = min(res, dis[s][i]+dis[i][t1]+dis[i][t2]);\n    }\n    cout << res <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct Edge {\n\tint t, cost, type;\n\tEdge(int _t, int _c, int _type) : t(_t), cost(_c), type(_type) {}\n};\n\nbool operator > (const Edge& a, const Edge& b) {\n\treturn a.cost > b.cost;\n}\n\nint n, m, s, g1, g2;\nint cost[3][110];\n\nvector< vector< Edge > > edges;\n\nint djk() {\n\tfor_(i,0,3) fill(cost[i], cost[i] + n, iINF / 2);\n\t\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > q;\n\tq.push(Edge(g1, 0, 0));\n\tcost[0][g1] = 0;\n\tq.push(Edge(g2, 0, 1));\n\tcost[1][g2] = 0;\n\t\n\twhile (!q.empty()) {\n\t\tEdge e = q.top(); q.pop();\n\t\t\n\t\tif (cost[e.type][e.t] < e.cost) continue;\n\t\t\n\t\tint e_size = size_of(edges[e.t]);\n\t\tfor_(i,0,e_size) {\n\t\t\tEdge ei = edges[e.t][i];\n\t\t\t\n\t\t\tif (cost[e.type][ei.t] > e.cost + ei.cost) {\n\t\t\t\tcost[e.type][ei.t] = e.cost + ei.cost;\n\t\t\t\tq.push(Edge(ei.t, e.cost + ei.cost, e.type));\n\t\t\t}\n\t\t\t\n\t\t\tif (e.type != 2 && cost[2][ei.t] > e.cost + ei.cost + cost[1 - e.type][e.t]) {\n\t\t\t\tcost[2][ei.t] = e.cost + ei.cost + cost[1 - e.type][e.t];\n\t\t\t\tq.push(Edge(ei.t, e.cost + ei.cost + cost[1 - e.type][e.t], 2));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cost[2][s];\n}\n\nvoid solve() {\n\tedges.assign(n, vector< Edge >());\n\t\n\tfor_(i,0,m) {\n\t\tint v, u, c; cin >> v >> u >> c;\n\t\t--v; --u;\n\t\tedges[v].push_back(Edge(u, c, 0));\n\t\tedges[u].push_back(Edge(v, c, 0));\n\t}\n\t\n\tcout << djk() << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\t--s; --g1; --g2;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint dis[123][123];\nvpint road[123];\nint n,m,s,g1,g2;\n\nint main() {\n\tIL{\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\t--s,--g1,--g2;\n\t\trep(i,n)rep(j,n)dis[i][j]=INF;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t--a,--b;\n\t\t\tdis[a][b]=c;\n\t\t\tdis[b][a]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)chmin(dis[i][j],dis[i][k]+dis[k][j]);\n\t\tint res=INF;\n\t\trep(i,n){\n\t\t\tchmin(res,dis[s][i]+dis[i][g1]+dis[i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct {\n\n};\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n){\n\t\tvector<vector<int>> load(n + 1, vector<int>(n + 1, 1000000000));//from back to \n\t\tREP(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tload[b1][b2] = c;\n\t\t\tload[b2][b1] = c;\n\t\t}\n\t\tFOR(i, 1, n + 1){\n\t\t\tFOR(j, 1, n + 1){\n\t\t\t\tFOR(k, 1, n + 1){\n\t\t\t\t\tload[j][k] = min(load[j][k], load[j][i] + load[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\tFOR(i, 1, n + 1){\n\t\t\tans = min(ans,load[s][i]+load[i][g1]+load[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define fr first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define FOR(i,j,n) for(int i=j;i<n;i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SET(c) memset((c),0,sizeof(c))\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define COPY(arr,to) copy(ALL(arr),back_inserter(to))\n#define BIT(n) ((1 << n) - 1)\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> iP;\ntypedef pair<iP,int> iiP;\ntypedef vector<int> vi;\ntypedef vector<iP> vii;\ntypedef stringstream ss;\n\n//Right,Under,Left,Top\nconst int dx[]={1,0,-1,0,-1,1,1,-1};\nconst int dy[]={0,1,0,-1,-1,1,-1,1}; \nconst int INF = 2 << 28;\nconst double EPS = 1e-9;\n\nstring get(){ string s; cin.ignore(); getline(cin,s); cin.ignore(); return s; }\nint value(){ int v; cin >> v; return v; }\nbool isPrime(int v){ for(int i=2;i*i<=v;i++) if(!(v % i)) return false; return (v >= 2); }\nbool isOver(int x,int y,int w,int h){ return (x >= 0 && x < w && y >= 0 && y < h); }\ninline int toInt(string s){ int f; ss sss; sss << s; sss >> f; return f; }\ntemplate<class T> inline string toStr(T f){ ss sss; sss << f; return sss.str(); }\n\nint main(){\n  int cost[128][128];\n  int n,m,s,g1,g2;\n  while(cin >> n >> m >> s >> g1 >> g2,n||m||s||g1||g2){\n    REP(i,n+1){\n      REP(j,n+1) cost[i][j] = INF;\n    }\n    REP(i,m){\n      int t,m,p; cin >> t >> m >> p;\n      cost[t][m] = p;\n    }\n    FOR(i,1,n+1){\n      FOR(j,1,n+1){\n\tFOR(k,1,n+1) cost[j][k] = min(cost[j][k],cost[j][i] + cost[i][k]);\n      }\n    }\n    int ret = INF;\n    FOR(i,1,n+1) ret = min(ret,cost[s][i] + cost[i][g1] + cost[i][g2]);\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n,m,s,g1,g2,a,b,cost;\n  int map[100][100];\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)map[i][j]=0;\n\telse map[i][j]=10000000;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>cost;\n      map[a-1][b-1]=cost;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  map[i][j]=min(map[i][j],map[i][k]+map[k][j]);\n\t}\n      }\n    }\n    int mi=10000000;\n    for(int i=0;i<n;i++)mi=min(mi,map[s-1][i]+map[i][g1-1]+map[i][g2-1]);\n    cout<<mi<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N_MAX 101\n#define INF (1e9)\nusing namespace std;\nvoid prim();\nint n,m,s,g1,g2,b1,b2,c,cost[N_MAX][N_MAX],mincost[N_MAX];\nbool used[N_MAX];\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) cost[i][j]=INF;\n    for(int i=0;i<m;i++) cin>>b1>>b2>>c,cost[b1][b2]=c;\n    prim();\n  }\n  return 0;\n}\n\nvoid prim(){\n  for(int i=1;i<=n;i++) mincost[i]=INF,used[i]=false;\n  mincost[s]=0;\n  int res=0;\n  while(1){\n    int v=-1;\n    for(int u=1;u<=n;u++)\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=1;u<=n;u++) mincost[u]=min(mincost[u],cost[v][u]);\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++) ans+=mincost[i];\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nconst int INF = 100000000;\n\nvoid solve(int& n, int& m, int& s, int& g1, int& g2) {\n  int graph[105][105];\n  for(int i = 0; i < 105; i++) {\n    for(int j = 0; j < 105; j++) {\n      if(i == j) graph[i][j] = 0;\n      else graph[i][j] = INF;\n    }\n  }\n  int b1, b2, c;\n  for(int i = 0; i < m; i++) {\n    cin >> b1 >> b2 >> c;\n    graph[b1][b2] = c;\n  }\n\n  // wa-syaruhuroidoooooooooooooooooooooooooooooooooooooooo!!!!!!!\n  for(int k = 0; k < 105; k++) {\n    for(int i = 0; i < 105; i++) {\n      for(int j = 0; j < 105; j++) {\n\tgraph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n  \n  // \n  int ans = graph[s][g1] + graph[s][g2];\n  for(int k = 0; k < 105; k++) {\n    for(int i = 0; i < 105; i++) {\n      for(int j = 0; j < 105; j++) {\n\t\n\tans = min(ans, graph[s][k] + graph[k][g1] + graph[k][g2]);\n      }\n    }\n  }\n  cout << ans << endl;\n  return ;\n}\n\nint main(){\n  int n, m, s, g1, g2;\n  while(cin >> n >> m >> s >> g1 >> g2) {\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n    solve(n, m, s, g1, g2);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const INF = 1<<29;\n\nint main() {\n  int N, M, S, g1, g2;\n  \n  while(cin >> N >> M >> S >> g1 >> g2 && N) {\n    int cost[100][100]; fill(cost[0], cost[0]+10000, INF);\n    for(int i=0; i<N; i++) cost[i][i] = 0;\n    S--, g1--, g2--;\n    for(int i=0; i<M; i++) {\n      int a, b, c; cin >> a >> b >> c; a--, b--;\n      cost[a][b] = c;\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    \n    int ans = INF;\n    for(int k=0; k<N; k++) {\n      ans = min(ans, cost[S][k] + cost[k][g1] + cost[k][g2]);\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define INF 100000000\nint d[101][101],n,m,s,g1,g2;\nint min(int a,int b){\n\tif(a<b){\n\t\treturn a;\n\t}else{\n\t\treturn b;\n\t}\n}\nvoid warsall_floyd(){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t}\t\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\twhile(1){\n\t\tint a,b,c,ans=INF;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<101;j++){\n\t\t\t\td[i][j]=INF;\n\t\t\t}\n\t\t\td[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>b>>c;\n\t\t\td[a][b]=c;\n\t\t}\n\t\twarsall_floyd();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e9;\n\n\n\nint main() {\n\tint N, M, s, g1, g2;\n\twhile ( cin >> N >> M >> s >> g1 >> g2, N || M || s || g1 || g2 ) {\n\t\t--s, --g1, --g2;\n\t\tll cost[100][100]; fill(cost[0], cost[100], inf);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b, c; cin >> a >> b >> c; --a, --b;\n\t\t\tcost[a][b] = cost[b][a] = c;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nsigned main() {\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2) {\n\tif (n == 0) break;\n\n\ts--; g1--; g2--;\n\n\tint dist[100][100];\n\trep(i, n) rep(j, n) dist[i][j] = INT_MAX;\n\trep(i, n) dist[i][i] = 0;\n\n\trep(i, m) {\n\t    int a, b, c;\n\t    cin >> a >> b >> c;\n\t    a--; b--;\n\n\t    dist[a][b] = c;\n\t}\n\n\trep(k, n) rep(i, n) rep(j, n) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n\tint ans[100];\n\trep(i, n) ans[i] = dist[i][g1] + dist[i][g2];\n\trep(i, n) {\n\t    rep(j, n) {\n\t\trep(k, n) {\n\t\t    ans[j] = min(ans[j], ans[k] + dist[j][k]);\n\t\t}\n\t    }\n\t}\n\n\tcout << ans[s] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[1111][1111];\n  for(int i=0;i<1111;i++){\n    for(int j=0;j<1111;j++){\n      road[i][j]=INF;\n    }\n  }\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=0;k<m;k++){\n      for(int i=0;i<m;i++){\n\tfor(int j=0;j<m;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 100\n#define min(a,b) (a>b?b:a)\n#define INF 10000000\n\nint main() {\n\tint n, m, s, g1, g2, b1, b2, c, ans;\n\tint cost[N+1][N+1];\n\twhile(1) {\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(!n&&!m&&!s&&!g1&&!g2) break;\n\t\tfor(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) {\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tcost[b1][b2] = c;\n\t\t}\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tfor(int j=1; j<=n; ++j) {\n\t\t\t\tfor(int k=1; k<=n; ++k) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tans = min(cost[s][i]+cost[i][g1]+cost[i][g2], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 999999999\n\nusing namespace std;\n\nint n, d[101][101];\n\nvoid warshall_floyd(void){\n\n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n}\n\n \nint main(void){\n\n    int m, s, g1, g2, b1, b2, c;\n\n    while(cin >> n >> m >> s >> g1 >> g2 ){\n      if( n == m && m == s && s == g1 && g1 == g2 && g2 == 0 ) break;\n\n        for( int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for( int i = 0; i < m; i++ ){\n\t  cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n                  \n        int ans = INF;\n        for( int i = 1; i <= n; i++ ){\n            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int inf = 1 << 29;\n\nint n, m, s, g1, g2;\nvector<vector<int> > cost;\n\nint solve(){\n    rep(k, n)rep(i, n)rep(j, n){\n        cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n    }\n    int res = inf;\n    rep(i, n)res = min(res, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n    return res;\n}\n\nint main(){\n    while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n        cost.assign(n, vector<int>(n, inf));\n        rep(i, n)cost[i][i] = 0;\n        rep(i, m){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            cost[b1-1][b2-1] = c;\n        }\n        cout << solve() << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n#define INF (1<<25)\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n\nusing namespace std;\n\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        --s;--g1;--g2;\n        rep(i,n) rep(j,n) edge[i][j] = (i==j)?0:INF;\n        rep(i,m)\n        {\n            cin >> b1 >> b2 >> c;\n            --b1;--b2;\n            edge[b1][b2] = c;\n            edge[b2][b1] = c;\n        }\n        rep(k,n) rep(i,n) rep(j,n) edge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n        mn = INF;\n        rep(i,n) mn = min(mn, edge[s][i]+edge[i][g1]+edge[i][g2]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef struct {\n    int from, to;\n    int cost;\n} edge;\n\nint main() {\n    while (true) {\n        int b_goal[2];\n        int n_bases, n_roads, b_start;\n        cin >> n_bases >> n_roads >> b_start >> b_goal[0] >> b_goal[1];\n\n        if (n_bases == 0) break;\n\n        map< int, vector<edge> > edges;\n        map< int, vector<edge> > redges;\n\n        while (n_roads--) {\n            int b_from, b_to, cost;\n            cin >> b_from >> b_to >> cost;\n            edge e = { b_from, b_to, cost };\n            edges[b_from].push_back(e);\n            redges[b_to].push_back(e);\n        }\n\n        map<int, int> cost_from_start;\n        for (int b = 1; b <= n_bases; ++b) {\n            cost_from_start[b] = INT_MAX;\n        }\n\n        queue<edge> q;\n\n        {\n            vector<edge> ee = edges[b_start];\n            for (size_t i = 0; i < ee.size(); ++i) {\n                q.push(ee[i]);\n            }\n        }\n\n        cost_from_start[b_start] = 0;\n        for (; !q.empty(); q.pop()) {\n            edge e = q.front();\n\n            int new_cost = cost_from_start[e.from] == INT_MAX ? INT_MAX : cost_from_start[e.from] + e.cost;\n            if (new_cost < cost_from_start[e.to]) {\n                cost_from_start[e.to] = new_cost;\n\n                vector<edge> ee = edges[e.to];\n                for (size_t i = 0; i < ee.size(); ++i) {\n                    q.push(ee[i]);\n                }\n            }\n        }\n\n        map<int, vector<int> > costs_from_goal;\n        for (int b = 1; b <= n_bases; ++b) {\n            costs_from_goal[b] = vector<int>(2, INT_MAX);\n        }\n\n        for (int I = 0; I <= 1; I++) {\n            vector<edge> ee = redges[b_goal[I]];\n            for (size_t i = 0; i < ee.size(); ++i) {\n                q.push(ee[i]);\n            }\n\n            costs_from_goal[b_goal[I]][I] = 0;\n            for (; !q.empty(); q.pop()) {\n                edge e = q.front();\n\n                int new_cost = costs_from_goal[e.to][I] == INT_MAX ? INT_MAX : costs_from_goal[e.to][I] + e.cost;\n                if (new_cost < costs_from_goal[e.from][I]) {\n                    costs_from_goal[e.from][I] = new_cost;\n\n                    vector<edge> ee = redges[e.from];\n                    for (size_t i = 0; i < ee.size(); ++i) {\n                        q.push(ee[i]);\n                    }\n                }\n            }\n        }\n\n        int min = INT_MAX;\n        for (int b = 1; b <= n_bases; ++b) {\n            if (cost_from_start[b] == INT_MAX) continue;\n            if (costs_from_goal[b][0] == INT_MAX) continue;\n            if (costs_from_goal[b][1] == INT_MAX) continue;\n\n            int v = cost_from_start[b] + costs_from_goal[b][0] + costs_from_goal[b][1];\n            if (v < min) {\n                min = v;\n            }\n        }\n        cout << min << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nstruct edge{\n\tint to, cost;\n};\nint n, m, s, g1, g2;\nvector<edge> G[110];\nint mincost[110];\nbool used[110];\n\nvoid prim(){\n\tfor (int i = 0; i < n; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[s] = 0;\n\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\n\twhile (que.size()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (used[v])continue;\n\n\t\tused[v] = 1;\n\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (used[e.to])continue;\n\t\t\tif (mincost[e.to] > e.cost){\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t\tque.push(P(e.cost, e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> n >> m >> s >> g1 >> g2&&n + m + s + g1 + g2){\n\t\tREP(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[a].push_back({ b, c });\n\t\t\tG[b].push_back({ a, c });\n\t\t}\n\t\tprim();\n\t\tll res = 0;\n\t\tREP(i, n){\n\t\t\tres += mincost[i];\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\nbool was_output = false;\ntemplate<class t>\nvoid output(t a){\n\tif(was_output)cout << \" \";\n\tcout << a;\n\twas_output = true;\n}\nvoid outendl(){\n\twas_output = false;\n\tcout << endl;\n}\n\nint n, m, s, g1, g2;\n\nvvector<pii> edges;\nvvector<int> dp;\n\nint cul_cost(int start, int end){\n\tif(dp[start][end]>=0)return dp[start][end];\n\tvector<int> fast(n, INF);\n\tpriority_queuer<pii> pq;\n\tpq.emplace(0, start);\n\tfast[start] = 0;\n\twhile(pq.size()){\n\t\tpii d = pq.top();\n\t\tpq.pop();\n\t\tif(d.first!=fast[d.second])continue;\n\t\tforeach(i, edges[d.second]){\n\t\t\tint next_time = d.first + i.second;\n\t\t\tif(fast[i.first]<next_time)continue;\n\t\t\tfast[i.first]=next_time;\n\t\t\tpq.emplace(next_time, i.first);\n\t\t}\n\t}\n\trep(i, n){\n\t\tdp[start][i] = fast[i];\n\t}\n\treturn dp[start][end];\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>g1>>g2&&n){\n\t\tedges.assign(n, vector<pii>(0));\n\t\tdp.assign(n, vector<int>(n, -1));\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\t--a;\n\t\t\t--b;\n\t\t\tedges[a].emplace_back(b, c);\n\t\t}\n\t\tll ans = INF;\n\t\trep(i, n){\n\t\t\tchmin(ans, (ll)cul_cost(s, i)+cul_cost(i, g1)+cul_cost(i, g2));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main() {\n\twhile(1) {\n\t\tint n, m, s, g1, g2;\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\t--s;\n\t\t--g1;\n\t\t--g2;\n\t\tif(n == 0) break;\n\t\tint d[n][n][n];\n\t\tREP(i, n) REP(j, n) REP(k, n) {\n\t\t\tif(j == k) d[i][j][k] = 0;\n\t\t\telse d[i][j][k] = INF;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tint b1, b2, c;\n\t\t\tcin>>b1>>b2>>c;\n\t\t\t--b1;\n\t\t\t--b2;\n\t\t\td[0][b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\td[i][j][k] = min(d[i - 1][j][k], d[i - 1][j][i] + d[i - 1][i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tREP(i, n) {\n\t\t\tres = min(res, d[n - 1][s][i] + d[n - 1][i][g1] + d[n - 1][i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n#define INF (1<<28)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int graph[100][100], int graph_size){\n    for(int mid_node = 0; mid_node < graph_size; mid_node++)\n        for(int s_node = 0; s_node < graph_size; s_node++)\n            for(int g_node = 0; g_node < graph_size; g_node++)\n                if(s_node == g_node) graph[s_node][g_node] = 0;\n                else graph[s_node][g_node] = min(graph[s_node][g_node], graph[s_node][mid_node] + graph[mid_node][g_node]);\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int graph[1000][1000], int node_count, int start_node, int distances[1000]){\n    REP(i, node_count) distances[i] = -1;\n    distances[start_node] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > dijkstra_pq;\n    dijkstra_pq.push(PII(0, start_node));\n    while (!dijkstra_pq.empty()) {\n        PII p = dijkstra_pq.top(); dijkstra_pq.pop();\n        int i = p.second;\n        if(distances[i] < p.first) continue;\n        for(int j = 0; j < node_count; j++){\n            if(graph[i][j] == -1) continue;\n            if(distances[j] == -1){\n                distances[j] = distances[i] + graph[i][j];\n                dijkstra_pq.push(PII(distances[j], j));\n            }else if(distances[j] > distances[i] + graph[i][j]){\n                distances[j] = distances[i] + graph[i][j];\n                dijkstra_pq.push(PII(distances[j], j));\n            }\n        }\n    }\n};\n\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            if(a[i][j] == INF) cout << -1 << \" \";\n            else cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    warshallFloyd(g, n);\n    \n    int ans = INF;\n    REP(i, n){\n        ans = min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        // if(solve_ans()) return 0;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n){\n            if(i == j) g[i][j] = 0;\n            else g[i][j] = INF;\n        }\n        REP(i, m) {\n            // cout << \"input\" << i << endl;\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<24\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nint cost[105][105];\nint d[105][105];\t\t\t\t// 頂点 s からの最短距離\n\n// 始点 s から各頂点への最短距離を求める\n//int V;\n\nvoid warshall_floyd (int V )\n{\n\trep (i, V ) rep (j, V ) d[i][j] = INF;\n\trep (i, V ) d[i][i] = 0;\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\tif (cost[i][j] != INF ){\n\t\t\t\td[i][j] = cost[i][j];\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end rep\n\n\trep (i, V ){\n\t\trep (j, V ){\n\t\t\trep (k, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ), n ){\n\t\ts--, g1--, g2--;\n\t\tmemset (cost, 0, sizeof (cost) );\n\t\trep (i, n ) rep (j, n ) cost[i][j] = INF;\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\tcost[from][to] = c;\n\t\t\tcost[to][from] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\t\twarshall_floyd (n );\n/*\n\t\trep (i, n ){\n\t\t\trep (j, n ){\n\t\t\t\tif (d[i][j] == INF ){\n\t\t\t\t\tcout << \"INF\";\n\t\t\t\t}else{\n\t\t\t\t\tcout << setw(3) << d[i][j];\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tcout << endl;\n\t\t} // end rep\n*/\n\t\trep (i, n ){\n\t\t\tif (i == s ) continue;\n\t\t\tif (i != g1 && i != g2 )\n\t\t\t\tres = min (res, min (d[s][i] + d[i][g1] + d[g1][g2], d[s][i] + d[i][g1] + d[i][g2] ) );\n\t\t\telse\n\t\t\t\tres = min (res, d[s][i] + d[i][i == g1 ? g2 : g1] );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint main(void){\n    for(int n, m, s, g1, g2, res; cin >> n >> m >> s >> g1 >> g2, n; cout << res << endl){\n        vvi d(n, vi(n, inf));\n        rep(u, n) d[u][u] = 0;\n        rep(i, m){\n            int u, v, c; cin >> u >> v >> c;\n            u--, v--;\n\n            d[u][v] = c;\n        }\n\n        rep(k, n) rep(i, n) rep(j, n){\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        \n        res = inf; s--, g1--, g2--;\n        rep(u, n){\n            res = min(res, d[s][u] + d[u][g1] + d[u][g2]);\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint n,m,s,g1,g2;\nint d[102][102];\nvoid solve() {\n    rep(i,102) rep(j,102) d[i][j]=INF;\n    rep(i,102) d[i][i]=0;\n    rep(i,m) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        d[a][b]=c;\n    }\n    rep(k,n) rep(i,n) rep(j,n) {\n        chmin(d[i][j],d[i][k]+d[k][j]);\n    }\n    int ans=INF;\n    rep(v,n) {\n        int t=d[s][v];\n        t+=d[v][g1]+d[v][g2];\n        chmin(ans,t);\n    }\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>n>>m>>s>>g1>>g2) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nstruct edge {\n    int to, cost;\n    edge(){}\n    edge(int _to, int _cost) : to(_to), cost(_cost) {}\n};\nconst int INF = 1e15;\ntypedef vector<vector<edge>> Graph;\nint dijkstra(const Graph& G, int s, int g) {\n    int N = G.size();\n    priority_queue<Pii, vector<Pii>, greater<Pii>> pq;   // cost, vertex\n    V d(N, INF);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n\n    while (!pq.empty()) {\n        auto p = pq.top(); pq.pop();\n        int v = p.second;\n        if (v == g) break;\n        if (d[v] < p.first) continue;\n        for (const auto& e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n    return d[g];\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n) {\n        s--, g1--, g2--;\n        Graph G(n);\n        rep(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--, b--;\n            G[a].emplace_back(b, c);    // directed\n        }\n\n        int ans = INF;\n        rep(i, n) {\n            ans = min(ans, dijkstra(G, s, i) + dijkstra(G, i, g1) + dijkstra(G, i, g2));\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nbool used[128];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(res, res + 3, dp[v]);\n\t\treturn;\n\t}\n\n\tfill_n(res, 3, INF);\n\tif (v == g1)\n\t{\n\t\tres[0] = 0;\n\t\treturn;\n\t}\n\telse if (v == g2)\n\t{\n\t\tres[1] = 0;\n\t\treturn;\n\t}\n\n\tused[v] = true;\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tused[v] = false;\n\tmin_swap(res[2], res[0] + res[1]);\n\n\tcopy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n||m||s||g1||g2){\n    int i,j,k;\n    int b1,b2,c;\n    int d[105][105];\n    int inf = 1<<20;\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n    if(i==j) d[i][j]=0;\n    else d[i][j]=inf;\n      }\n    }\n    for(i=0;i<m;i++) {\n      cin >> b1 >> b2 >> c;\n      d[b1][b2]=c;\n    }\n    for(k=1;k<=n;k++){\n      for(i=1;i<=n;i++){\n    if(d[i][k]==inf) continue;\n    for(j=1;j<=n;j++){\n      if(d[k][j]==inf) continue;\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    } \n      } \n    }\n    int o=inf;\n    for(i=1;i<=n;i++){\n      o=min(o,d[s][i]+d[i][g1]+d[i][g2]);\n    }\n    cout << o << endl;\n  }\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[101][101];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                if(i == j) road[i][j] = 0;\n                else road[i][j] = 1000000000;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                for(int k = 1; k < n + 1; k++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 1; i < n + 1; i++){\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 9999999\n#define MAX 101\n\nint main(){\n    int n,m,s,g1,g2,d[MAX+1][MAX+1],a,b,c;\n    while(cin >> n >> m >> s >> g1 >> g2 , n+m+s+g1+g2){\n        fill(d[0],d[MAX],INF);\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            d[a][b] = c;\n        }\n        \n        for(int k = 1 ; k <= n ; k++)\n            for(int i = 1 ; i <= n ; i++)\n                for(int j = 1 ; j <= n ; j++)\n                    d[i][j] = min(d[i][j],d[i][k]+d[k][j]);\n        \n        int res = INF;\n        for(int i = 1 ; i <= n ; i++){\n            d[i][i] = 0;\n            res = min(res,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    int n, m, s, g1, g2;\n    while(1){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) break;\n        int road[101][101];\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                if(i == j) road[i][j] = 0;\n                else road[i][j] = 1001;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int a, b, c;\n            cin >> a >> b >> c;\n            road[a][b] = c;\n        }\n        for(int i = 1; i < n + 1; i++){\n            for(int j = 1; j < n + 1; j++){\n                for(int k = 1; k < n + 1; k++){\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                }\n            }\n        }\n        int ans = 1000000000;\n        for(int i = 1; i < n + 1; i++){\n            ans = min(ans, road[s][i] + road[i][g1] + road[i][g2]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 100000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = table[j][k] < table[j][i] + table[i][k] ?\n\t\t\t\t\ttable[j][k] : table[j][i] + table[i][k];\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m, s, g1, g2;\n  while(cin >> n >> m >> s >> g1 >> g2, n) {\n    s--; g1--; g2--;\n    int cost[n][n];\n    rep(i, n)rep(j, n) cost[i][j] = INF;\n    rep(i, m) {\n      int a, b, c;\n      cin >> a >> b >> c; a--, b--;\n      cost[a][b] = cost[b][a] = c;\n    }\n\n    rep(i, n)rep(j, n)rep(k, n) minch(cost[j][k], cost[j][i] + cost[i][k]);\n    int mini = INF;\n    rep(i, n) minch(mini, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    cout << mini << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint INF=1<<21;\nint main(){\n  int n,m,s,g1,g2;\n  int b1,b2,c;\n  int ans=INF;\n  int road[111][111];\n  while(1){\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\troad[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      cin >> b1 >> b2 >> c;\n      road[b1][b2]=c;\n    }\n    for(int k=1;k<=n;k++){\n      for(int i=1;i<=n;i++){\n\tfor(int j=1;j<=n;j++){\n\t  road[i][j]=min(road[i][j],road[i][k]+road[k][j]);\n\t}\n      }\n    }\n    for(int i=1;i<=n;i++){\n      ans=min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n    }\n    cout << ans << endl;\n    ans=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int n, m, s, g1, g2; cin>>n>>m>>s>>g1>>g2;\n        s--, g1--, g2--;\n        if(n == 0) return 0;\n\n        vector<vector<int>> dist(n, vector<int>(n, 1e8));\n        for(int i=0; i<n; i++) dist[i][i] = 0;\n        for(int i=0; i<m; i++){\n            int b1, b2, c; cin>>b1>>b2>>c;\n            b1--, b2--;\n            dist[b1][b2] = c;\n        }\n\n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        int ans = 1e8;\n        for(int i=0; i<n; i++){\n            ans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MIN(X,Y) ((X)>(Y) ? (Y) : (X))\n\nint d[200][200];\n\nint main(void) {\n    while(1) {\n        int n,m,s,g1,g2;\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        if(!n) break;\n\n        s--, g1--, g2--;\n        memset(d, 0x3F, sizeof(d));\n        for(int i=0;i<n;i++)\n            d[i][i] = 0;\n\n        for(int i=0;i<m;i++) {\n            int b,e,c;\n            scanf(\"%d%d%d\",&b,&e,&c);\n            b--, e--;\n            d[b][e] = c;\n        }\n\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                for(int k=0; k<n; k++)\n                    d[j][k] = MIN(d[j][k], d[j][i] + d[i][k]);\n\n        int res=0x5FFFFFFF;\n        for(int i=0; i<n; i++)\n            res = MIN(d[s][i]+d[i][g1]+d[i][g2], res);\n        printf(\"%d\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<climits>\nusing namespace std;\n#define INF INT_MAX/3-2\n\nint n,m,s,g1,g2;\nvector< vector<int> > edge;\n\nvoid init(){\n  n=m=s=g1=g2=0;\n  edge.clear();\n}\n\nbool input(){\n  cin>>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0){\n    return 0;\n  }\n  s--;g1--;g2--;\n  edge.resize(n);\n  for(int i=0;i<n;i++){\n    edge[i].resize(n);\n    for(int j=0;j<n;j++){\n      edge[i][j]=INF;\n    }\n  }\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--;b2--;\n    edge[b1][b2]=c;\n    edge[b2][b1]=c;\n  }\n  return 1;\n}\n\n\n\n\nint solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<n;i++){\n    res=min(res,edge[s][i]+edge[i][g1]+edge[i][g2]);\n  }\n  return res;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nconst int MAX_N = 100;\nconst int MAX_V = 110;\nint n;\nint m;//道路の数\nint s;\nint b1,b2;\nint g1,g2;\nint c;\n\nint d[MAX_V];\nint cost[MAX_V][MAX_V];\n\nint main(){\n\twhile(cin>>n>>m>>s>>g1>>g2,n||m||s||g1||g2){\n\t\trep(i,n+1){\n\t\t\trep(j,n+1){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tif(i==j){\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,m){\n\t\t\tcin>>b1>>b2>>c;\n\t\t\tcost[b1][b2] = c;\n\t\t\tcost[b2][b1] = c;\n\t\t}\n\t\tfor(int k = 1;k <=n;k++){\n\t\t\tfor(int i = 1;i <=n;i++){\n\t\t\t\tfor(int j = 1;j <=n;j++){\n\t\t\t\t\tcost[i][j] =min(cost[i][j],cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i = 1;i <=n;i++){\n\t\t\tans = min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t}\n\t\tcout <<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n\nint min(int a, int b){ return a < b ? a : b; }\n\nint main(void){\n  while(true){\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){ break; }\n    --s; --g1; --g2;\n\n    // ??£??\\??????????§????\n    vector<vector<int> > adjmatrix(n, vector<int>(n, INF));\n    for(int i = 0; i < m; i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      --b1; --b2;\n      adjmatrix[b1][b2] = c;\n      //adjmatrix[b2][b1] = c;\n    }\n    for(int i = 0; i < n; i++){ adjmatrix[i][i] = 0; }    \n\n    // ???????????£???\n    for(int k = 0; k < n; k++)\n      for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n          adjmatrix[i][j] = min(adjmatrix[i][j], adjmatrix[i][k] + adjmatrix[k][j]);\n\n    // ???????????±???????????????????????????\n    int mincost = INF;\n    for(int i = 0; i < n; i++){\n      mincost = min(mincost, adjmatrix[s][i] + adjmatrix[i][g1] + adjmatrix[i][g2]);\n    }\n\n    // ??????\n    cout << mincost << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int INF = 1 << 28;\n\nint N, M, S, G1, G2;\nint B1[1000], B2[1000], C[1000];\n\nint graph[100][100];\n\nint solve() {\n    assert(N <= 100);\n    int min_dist[100][100];\n    for (int j = 0; j < N; ++j) { fill(min_dist[j], min_dist[j]+N, INF); min_dist[j][j] = 0; }\n    for (int j = 0; j < M; ++j) min_dist[B1[j]][B2[j]] = C[j];\n    \n    for (int l = 0; l < N; ++l) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                int cand = min_dist[j][l] + min_dist[l][k];\n                if (cand < min_dist[j][k]) min_dist[j][k] = cand;\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < N; ++j) {\n        int cand = min_dist[S][j] + min_dist[j][G1] + min_dist[j][G2];\n        if (cand < ans) {\n            ans = cand;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (true) {\n        cin >> N >> M >> S >> G1 >> G2;\n        if (N == 0 && M == 0 && S == 0 && G1 == 0 && G2 == 0) break;\n        --S; --G1; --G2;\n        for (int j = 0; j < M; ++j) {\n            cin >> B1[j] >> B2[j] >> C[j];\n            --B1[j]; --B2[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint n,m,s,g1,g2;\nint d[102][102];\nvoid solve() {\n    s--;\n    g1--;\n    g2--;\n    rep(i,102) rep(j,102) d[i][j]=INF;\n    rep(i,102) d[i][i]=0;\n    rep(i,m) {\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;\n        b--;\n        d[a][b]=c;\n    }\n    rep(k,n) rep(i,n) rep(j,n) {\n        chmin(d[i][j],d[i][k]+d[k][j]);\n    }\n    int ans=INF;\n    rep(v,n) {\n        int t=d[s][v];\n        t+=d[v][g1]+d[v][g2];\n        chmin(ans,t);\n    }\n    cout<<ans<<endl;\n}\nint main() {\n    while(cin>>n>>m>>s>>g1>>g2) {\n        if(!n) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MIN(X,Y) ((X)>(Y) ? (Y) : (X))\n\nint d[200][200];\n\nint main(void) {\n    while(1) {\n        int n,m,s,g1,g2;\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        if(!n) break;\n\n        s--, g1--, g2--;\n        memset(d, 0x2F, sizeof(d));\n        for(int i=0;i<n;i++)\n            d[i][i] = 0;\n\n        for(int i=0;i<m;i++) {\n            int b,e,c;\n            scanf(\"%d%d%d\",&b,&e,&c);\n            b--, e--;\n            d[b][e] = c;\n        }\n\n        for(int i=0; i<n; i++)\n            for(int j=0; j<n; j++)\n                for(int k=0; k<n; k++)\n                    d[j][k] = MIN(d[j][k], d[j][i] + d[i][k]);\n\n        int res=0x5FFFFFFF;\n        for(int i=0; i<n; i++)\n            res = MIN(d[s][i]+d[i][g1]+d[i][g2], res);\n        printf(\"%d\\n\", res);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2;\n    s--; g1--; g2--;\n    if(n == 0) break;\n    vector<vector<ll>> d(n, vector<ll>(n, INF));\n    for(int i=0;i<n;++i) {\n      d[i][i] = 0;\n    }\n    for(int i=0;i<m;++i) {\n      int u, v, c; cin >> u >> v >> c;\n      u--; v--;\n      d[u][v] = c;\n    }\n    for(int k=0;k<n;++k) {\n      for(int i=0;i<n;++i) {\n        for(int j=0;j<n;++j) {\n          d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n      }\n    }\n    ll ans = INF;\n    for(int i=0;i<n;++i) {\n      ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=100;\nconst int INF=(1<<21);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int b1,b2,c;\n  int pipe[MAX][MAX];\n  int ans;\n\n  while(1){\n  cin>> n>> m>> s>> g1>> g2;\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      pipe[i][j]=INF;\n    }\n  }\n\n  for( int i=0;i<m;i++ ) {\n    cin>> b1>> b2>> c;\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=0;i<n;i++ ) {\n    for( int j=0;j<n;j++ ) {\n      for( int k=0;k<n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  ans=INF;\n  for( int i=0;i<n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  cout<< ans<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint dis[123][123];\nvpint road[123];\nint n,m,s,g1,g2;\n\nint main() {\n\tIL{\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\t--s,--g1,--g2;\n\t\trep(i,n)rep(j,n)dis[i][j]=INF;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t--a,--b;\n\t\t\tdis[a][b]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)chmin(dis[i][j],dis[i][k]+dis[k][j]);\n\t\tint res=INF;\n\t\trep(i,n){\n\t\t\tchmin(res,dis[s][i]+dis[i][g1]+dis[i][g2]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,0,-1,1,-1,-1,1};\nconst int dy[]={0,1,-1,0,1,1,-1,-1};\nconst int INF = 1e8;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\n\ntypedef unsigned long long ll;\nint main(){\n\tint N,M,s,g1,g2;\n\twhile(scanf(\"%d%d%d%d%d\",&N,&M,&s,&g1,&g2),N){\n\t\t--s;--g1;--g2;\n\t\tint dp[128][128];\n\t\trep(i,128){\n\t\t\trep(j,128){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\t--a;--b;\n\t\t\tdp[a][b] = c;\n\t\t\tdp[b][a] = c;\n\t\t}\n\n\t\trep(k,N){\n\t\t\trep(i,N){\n\t\t\t\trep(j,N){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\n\t\trep(i,N){\n\t\t\tans = min(ans,dp[s][i]+dp[i][g1]+dp[i][g2]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 110;\nconst int INF = 1e9;\n\nint n, m, s, g1, g2;\nint cost[MAX_V][MAX_V];\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++)\n    for(int j = 0 ; j < MAX_V ; j++) cost[i][j] = INF;\n  \n  for(int i = 0 ; i < MAX_V ; i++) cost[i][i] = 0;\n}\n\n\nvoid wf(){\n  for(int k = 0 ; k < n ; k++){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n      }\n    }\n  }    \n}\n\nint main(){\n  while(cin >> n >> m >> s >> g1 >> g2, n|m|s|g1|g2){\n    init();\n    s--, g1--, g2--;\n    int from, to, C;\n    for(int i = 0 ; i < m ; i++){\n      cin >> from >> to >> C;\n      cost[from-1][to-1] = C;\n      cost[to-1][from-1] = C;\n    }\n    \n    wf();\n        \n    int ans = INF;\n    for(int i = 0 ; i < n ; i++){\n      ans = min(ans, cost[s][i] + cost[i][g1] + cost[i][g2]);\n    }\n    cout << ans << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP (i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector <vector<int>>;\nusing vvll = vector <vector<ll>>;\n\n#define inf(T) (numeric_limits<T>::max() / 2)\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-9;\n\ntemplate<typename T>\nvoid warshall_floyd(vector<vector<T>> &g) {\n    const T INF = numeric_limits<T>::max();\n    int n = g.size();\n    for (int k = 0; k < n; ++k) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (g[i][k] == INF or g[k][j] == INF) continue;\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n, m, s, g1, g2;\n        cin >> n >> m >> s >> g1 >> g2;\n        --s, --g1, --g2;\n        if (n == 0) break;\n\n        vvi G(n, vi(n, numeric_limits<int>::max()));\n        REP (i, n) G[i][i] = 0;\n        REP (i, m) {\n            int u, v, c;\n            cin >> u >> v >> c;\n            --u, --v;\n            G[u][v] = c;\n        }\n\n        warshall_floyd(G);\n\n        int ans = inf(int);\n\n        REP (i, n) {\n            if (G[s][i] >= inf(int) or G[i][g1] >= inf(int)\n                or G[i][g2] >= inf(int)) continue;\n\n            chmin(ans, G[s][i] + G[i][g1] + G[i][g2]);\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,a) for (int i = 0; i < (a); i++)\nusing namespace std;\nint const INF = 1 << 28;\nint n, m, s, g1, g2, b1, b2, c;\nint G[101][101];\n\nint main(void){\n    while (cin >> n >> m >> s >> g1 >> g2, n) {\n        s--, g1--, g2--;\n        rep(i, 101) rep(j, 101) G[i][j] = INF;\n        rep(i, m) {\n            cin >> b1 >> b2 >> c;\n            G[b1-1][b2-1] = c;\n        }\n        rep(k, n) rep(i, n) rep(j, n) G[i][j] = min(G[i][j], G[i][k]+G[k][j]);\n        int ans = INF;\n        rep(i, n) {\n            ans = min(ans, G[s][i]+G[i][g1]+G[i][g2]);\n            ans = min(ans, G[s][i]+G[i][g1]+G[g1][g2]);\n            ans = min(ans, G[s][i]+G[i][g2]+G[g2][g1]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    int d[1001][1001]={};\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)if(i!=j)d[i][j]=1e8;\n    for(int i=0,a,b,c;i<m;i++)\n      cin>>a>>b>>c,d[a][b]=c;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n\tfor(int k=1;k<=n;k++)d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n    int ans=1e9;\n    for(int i=1;i<=n;i++)ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\nusing namespace std;\n\ntypedef long long ll;\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nconst int INF = 1 << 28;\n\nint main()\n{\n  int N, M, S, G1, G2;\n  while (N = in(), M = in(), S = in() - 1, G1 = in() - 1, G2 = in() - 1, N){\n    int way[111][111];\n    for (int i = 0; i < N; i++) fill_n(way[i], N, INF), way[i][i] = 0;\n\n    for (int i = 0; i < M; i++){\n      int b1 = in() - 1, b2 = in() - 1, c = in();\n      way[b1][b2] = c;\n    }\n    for (int k = 0; k < N; k++){\n      for (int i = 0; i < N; i++){\n        for (int j = 0; j < N; j++){\n          way[i][j] = min(way[i][j], way[i][k] + way[k][j]);\n        }\n      }\n    }\n    int mini = INF;\n    for (int i = 0; i < N; i++){\n      mini = min(mini, way[S][i] + way[i][G1] + way[i][G2]);\n    }\n    printf(\"%d\\n\", mini);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// 線分の交差判定\nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // 並行な場合\n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n// 外積の計算 AB CD の内積を求める\nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n// 三角形の内部判定 ABCの中にPがあるか判定\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// 三角形の外心\nvoid circumcenter(double ax, double ay, double bx, double by, double cx, double cy, double res[3]){\n    // AB AC を求める\n    double abx = bx - ax; double aby = by - ay;\n    double acx = cx - ax; double acy = cy - ay;\n    double m = abx * acy - acx * aby; // 分母 m = 0 となるのは3点が一直線になるとき\n    double s = (abx * acx + aby * acy - sq(acx) - sq(acy)) / m; // 媒介変数s\n    res[0] = abx / 2 + s * aby / 2; res[1] = aby / 2 - s * abx / 2;\n    // cout << res[0] << \" \" << res[1] << endl;\n    res[2] = sqrt(sqdist(0, 0, res[0], res[1]));\n    res[0] += ax; res[1] += ay;\n};\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // 初期化\n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // 根を求める\n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xとyの集合を結合\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xとyが同じ集合か\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // 集合の数を数える\n    int count(){\n        return (int)set.size();\n    }\n};\n\nvoid pma(int a[100][100], int n){\n    REP(i, n){\n        REP(j, n){\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n};\n\n// ワーシャルフロイド法\nvoid warshallFloyd(int d[100][100], int n){\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(d[i][k] != -1 && d[k][j] != -1){\n                    if(i == j){\n                        d[i][j] = 0;\n                    }else if(d[i][j] == -1){\n                        d[i][j] = d[i][k] + d[k][j];\n                    }else{\n                        d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                    }\n                }\n};\n\n\n// d:隣接行列  n:グラフのサイズ  s:始点  dist:始点からの距離が入る配列\nvoid dijkstra(int d[1000][1000], int n, int s, int dist[1000]){\n    REP(i, n) dist[i] = -1;\n    dist[s] = 0;\n    priority_queue<PII, vector<PII>, greater<PII> > q;\n    q.push(PII(0, s));\n    while (!q.empty()) {\n        PII p = q.top(); q.pop();\n        int i = p.second;\n        if(dist[i] < p.first) continue;\n        for(int j = 0; j < n; j++){\n            if(d[i][j] == -1) continue;\n            if(dist[j] == -1){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }else if(dist[j] > dist[i] + d[i][j]){\n                dist[j] = dist[i] + d[i][j];\n                q.push(PII(dist[j], j));\n            }\n        }\n    }\n};\n\n/**\n * start\n * @author yoshikyoto\n */\n\nint n, m, s, g1, g2;\nint g[100][100];\n\nvoid solve(){\n    // pma(g, n);\n    for(int k = 0; k < n; ++k)\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                if(i == j){\n                        g[i][j] = 0;\n                }else{\n                        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n                }\n    // pma(g, n);\n    \n    int ans = INFINITY;\n    REP(i, n){\n        int cost = g[s][i] + g[i][g1] + g[i][g2];\n        ans = min(ans, cost);\n    }\n    cout << ans << endl;\n}\n\nint main(int argc, const char * argv[]){\n    begin();\n    while(true){\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0) return 0;\n        s--; g1--; g2--;\n        REP(i, n) REP(j, n) g[i][j] = INFINITY;\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            g[a][b] = c;\n            g[b][a] = c;\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e7 + 10;\n\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n  int prev[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n    fill(prev, prev + V, -1);\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n          prev[e.to] = v;\n        }\n      }\n    }\n\n    return d;\n  }\n\n  vector<int> GetPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prev[t]) {\n      path.push_back(t);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n + m + s + g1 + g2 == 0) {\n      break;\n    }\n    s--; g1--; g2--;\n    Dijkstra dijkstra(n);\n    for (int i = 0; i < m; i++) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      dijkstra.AddEdge(b1, b2, c);\n      dijkstra.AddEdge(b2, b1, c);\n    }\n\n\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      ans = min(ans, d[s] + d[g1] + d[g2]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\ntypedef vector<pii> vpii;\n\nstruct Stat {\n  int d, i;\n  Stat() {}\n  Stat(int _d, int _i) { d = _d, i = _i; }\n\n  bool operator<(const Stat& s0) const { return d > s0.d; }\n};\n\n/* global variables */\n\nint n, m, st, g1, g2;\nvpii nbrs[MAX_N], rnbrs[MAX_N];\nint dists[MAX_N];\n\n/* subroutines */\n\nint min_dist(int mp, int gl, vpii *nbrs) {\n  int mind = INF;\n\n  for (int i = 0; i < n; i++) dists[i] = INF;\n  dists[mp] = 0;\n\n  priority_queue<Stat> q;\n  q.push(Stat(0, mp));\n\n  while (! q.empty()) {\n    Stat u = q.top();\n    q.pop();\n\n    //printf(\"u.d=%d, u.i=%d\\n\", u.d, u.i);\n    \n    if (u.d != dists[u.i]) continue;\n\n    if (u.i == gl) {\n      if (mind > u.d) mind = u.d;\n      break;\n    }\n\n    vpii& nbru = nbrs[u.i];\n    for (vpii::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int vi = vit->first;\n      int vd = u.d + vit->second;\n      //printf(\"  vd=%d, vi=%d\\n\", vd, vi);\n\n      if (dists[vi] > vd) {\n\tdists[vi] = vd;\n\tq.push(Stat(vd, vi));\n      }\n    }\n  }\n\n  return mind;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m >> st >> g1 >> g2;\n    if (n == 0) break;\n    st--, g1--, g2--;\n\n    for (int i = 0; i < n; i++)\n      nbrs[i].clear(), rnbrs[i].clear();\n    \n    while (m--) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--, b2--;\n      nbrs[b1].push_back(pii(b2, c));\n      rnbrs[b2].push_back(pii(b1, c));\n    }\n\n    int mind = INF;\n\n    for (int mp = 0; mp < n; mp++) {\n      //printf(\"mp=%d:\\n\", mp);\n\n      int mind_st = min_dist(mp, st, rnbrs);\n      //printf(\"  mind_st=%d\\n\", mind_st);\n      if (mind_st >= INF) continue;\n\n      int mind_g1 = min_dist(mp, g1, nbrs);\n      //printf(\"  mind_g1=%d\\n\", mind_g1);\n      if (mind_g1 >= INF) continue;\n\n      int mind_g2 = min_dist(mp, g2, nbrs);\n      //printf(\"  mind_g2=%d\\n\", mind_g2);\n      if (mind_g2 >= INF) continue;\n\n      int dsum = mind_st + mind_g1 + mind_g2;\n      if (mind > dsum) mind = dsum;\n    }\n\n    cout << mind << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n,m,s,g1,g2;\n  while(true){\n    cin>>n>>m>>s>>g1>>g2;\n    if(n==0) break;\n    s--,g1--,g2--;\n    const long long int INF=1e10;\n    vector<vector<long long int>> d(n,vector<long long int>(n,INF));\n    for(int i=0;i<m;i++){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      b1--,b2--;\n      d[b1][b2]=c;\n    }\n    for(int i=0;i<n;i++) d[i][i]=0;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n      }\n    }\n    long long int res=1e10;\n    for(int g=0;g<n;g++){\n      long long int share=d[s][g];\n      long long int cost1=d[g][g1];\n      long long int cost2=d[g][g2];\n      long long int cost=share+cost1+cost2;\n      res=min(res,cost);\n    }\n    \n    cout<<res<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1<<21\nusing namespace std;\nint d[128][128];\nint N, M;\n\nvoid warshall_floyd(){\n  for (int k = 0; k < N; k++){\n    for (int i = 0; i < N; i++){\n      for (int j = 0; j < N; j++){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n}\nint main()\n{\n  while(1){\n    int s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n\n    if (!N&&!M&&!s&&!g1&&!g2) break;   \n\n    for (int i = 0; i < N; i++){\n      fill_n(d[i], N, INF);\n    }\n    for (int i = 0; i < M; i++){\n      int u, v, c;\n      cin >> u >> v >> c;\n      d[u][v] = c;\n      d[v][u] = c;\n    }\n    warshall_floyd();\n    int res = INF;\n    for (int i = 0; i < N; i++){\n      res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint N, M, s, g1, g2;\nusing pii = pair<int, int>;\nusing Graph = vector< vector<pii> >;\nusing Matrix = vector< vector<int> >;\nconst int INF = 1 << 25;\n\nvoid warshall(Matrix &mat) {\n    int P = mat.size();\n    for(int k=0; k<P; k++) {\n        for(int i=0; i<P; i++) {\n            for(int j=0; j<P; j++) {\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin >> N >> M >> s >> g1 >> g2, N) {\n        s--; g1--; g2--;\n\n        Graph G(N);\n        Matrix gst(N, vector<int>(N, INF));\n        Matrix rev(N, vector<int>(N, INF));\n\n        for(int i=0; i<M; i++) {\n            int u, v, cost; cin >> u >> v >> cost;\n            u--; v--;\n            gst[u][v] = cost;\n            rev[v][u] = cost;\n        }\n\n        warshall(gst);\n        warshall(rev);\n\n        int ans = INF;\n        for(int i=0; i<N; i++) {\n            ans = min(ans, gst[i][g1] + gst[i][g2] + rev[i][s]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define N 100\n#define min(a,b) (a>b?b:a)\n#define INF 100000000\n\nint main() {\n\tint n, m, s, g1, g2, b1, b2, c, ans;\n\tint cost[N+1][N+1];\n\twhile(1) {\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif(!n&&!m&&!s&&!g1&&!g2) break;\n\t\tfor(int i=1; i<=n; ++i) for(int j=1; j<=n; ++j) {\n\t\t\tcost[i][j] = (i==j?0:INF);\n\t\t}\n\t\tfor(int i=0; i<m; ++i) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tcost[b1][b2] = c;\n\t\t}\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tfor(int j=1; j<=n; ++j) {\n\t\t\t\tfor(int k=1; k<=n; ++k) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = INF;\n\t\tfor(int i=1; i<=n; ++i) {\n\t\t\tans = min(cost[s][i]+cost[i][g1]+cost[i][g2], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\nvoid Dijkstra(int n, int s, int edge[][100], int node[])\n{\n    int close[100]={0};\n    int mn;\n    node[s] = 0;\n    for(int i=0;i<n;++i)\n    {\n        close[s] = 1;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && edge[s][j] && node[j] > node[s]+edge[s][j])\n            {\n                node[j] = node[s]+edge[s][j];\n            }\n        }\n        mn = INT_MAX;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && mn > node[j])\n            {\n                mn = node[j];\n                s = j;\n            }\n        }\n    }\n}\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int node1[100];\n    int node2[100];\n    int node3[100];\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;++j) edge[i][j] = 0;\n            node1[i] = INT_MAX/3;\n            node2[i] = INT_MAX/3;\n            node3[i] = INT_MAX/3;\n        }\n        for(int i=0;i<m;++i)\n        {\n            cin >> b1 >> b2 >> c;\n            --b1;--b2;\n            edge[b1][b2] = c;\n            edge[b2][b1] = c;\n        }\n        Dijkstra(n,s-1,edge,node1);\n        Dijkstra(n,g1-1,edge,node2);\n        Dijkstra(n,g2-1,edge,node3);\n        /*\n        for(int i=0;i<n;++i) cout << node1[i] << ' ';\n        cout << endl;\n        for(int i=0;i<n;++i) cout << node2[i] << ' ';\n        cout << endl;\n        for(int i=0;i<n;++i) cout << node3[i] << ' ';\n        cout << endl;\n        */\n        mn = INT_MAX;\n        for(int i=0;i<n;++i) mn = min(mn, node1[i]+node2[i]+node3[i]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define INF 999999\n\nusing namespace std;\n\nint n,d[101][101];\n\nvoid warshall_floyd(void){\n  \n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j] , d[i][k] + d[k][j]);\n      }\n\t\n}\n \nint main(void){\n\n    int n, m, s, g1, g2, b1, b2, c, d[101][101];\n\n    while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2), n){\n        for(int i = 0; i <= n; ++i){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for(int i = 0; i < m; ++i){\n            scanf(\"%d%d%d\", &b1, &b2, &c);\n            d[b1][b2] = c;\n        }\n\n\twarshall_floyd();\n         \n        int ans = INF;\n        for(int i = 1; i <= n; ++i){\n\t  ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst int MAX = 100;\nconst int INF = 1 << 29;\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m, s, g1, g2;\n\t\tint cost[MAX][MAX];\n\t\tint ans = INF;\n\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, MAX) {\n\t\t\trep(j, MAX) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, m) {\n\t\t\tint b1, b2, c;\n\n\t\t\tcin >> b1 >> b2 >> c;\n\n\t\t\tcost[b1 - 1][b2 - 1] = c;\n\t\t}\n\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tans = min(ans, cost[s - 1][i] + cost[i][g1 - 1] + cost[i][g2 - 1]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1<<29\nusing namespace std;\n\nint main(){\nint a,b,c,d,e;\nint f[100][100];\nwhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a||b||c||d||e){\n\tc--;d--;e--;\n\tfor(int g=0;g<a;g++){\n\t\tfor(int h=0;h<a;h++){if(g!=h) f[g][h]=INF;else f[g][h]=0;}\n\t}\n\tint j,k,l;\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d%d%d\",&j,&k,&l);\n\t\tj--;k--;\n\t\tf[j][k]=l;\n\t}\n\tfor(int x=0;x<a;x++){\n\t\tfor(int y=0;y<a;y++){\n\t\t\tfor(int z=0;z<a;z++){\n\t\t\t\tf[y][z]=min(f[y][z],f[y][x]+f[x][z]);\n\t\t\t}\n\t\t}\n\t}\n\tint s=INF;\n\tfor(int o=0;o<a;o++){\n\t\ts=min(s,f[c][o]+f[o][d]+f[o][e]);\n\t}\n\tprintf(\"%d\\n\",s);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 && n){\n\t\tll d[301][301];\n\t\trep(i, 301)rep(j, 301)d[i][j] = (i == j ? 0 : INF);\n\t\t\n\t\trep(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\td[b1][b2] = c;\n\t\t}\n\n\t\tFor(k,1, n+1)For(i,1, n+1)For(j,1, n+1){\n\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t}\n\n\t\tll ans = INF;\n\t\tFor(k, 1, n + 1){\n\t\t\tans = min(ans, d[s][k] + d[k][g1] + d[k][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint main() {\n\twhile (1) {\n\t\tint n, m, s, g1, g2; cin >> n >> m >> s >> g1 >> g2;\n\t\tif (!n)break;\n\t\ts--; g1--; g2--;\n\t\tvector<vector<int>>dis(n, vector<int>(n, 99999999));\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint f, t, c; cin >> f >> t >> c;\n\t\t\tf--; t--;\n\t\t\tdis[f][t] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdis[i][i] = 0;\n\t\t}\n\t\tfor (int k = 0; k < n; ++k) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tdis[i][j] = min(dis[i][k] + dis[k][j], dis[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 99999999;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = min(ans, dis[s][i] + dis[i][g1] + dis[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\ntemplate<typename T> void chmin(T& a,const T& b){a=min(a,b);}\n\nint main()\n{\n\tfor(int n,m,s,g1,g2;cin>>n>>m>>s>>g1>>g2,n|m|s|g1|g2;){\n\t\ts--; g1--; g2--;\n\t\tvvi g(n,vi(n,INFTY));\n\t\trep(i,n) g[i][i]=0;\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c; a--; b--;\n\t\t\tg[a][b]=c;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tchmin(g[i][j],g[i][k]+g[k][j]);\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,n)\n\t\t\tchmin(res,g[s][i]+g[i][g1]+g[i][g2]);\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tint d[101][101];\n\t\tREP(i, 101)REP(j, 101) d[i][j] = i == j ? 0 : INF;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\td[a][b] = c;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n) chmin(d[i][j], d[i][k] + d[k][j]);\n\t\tint res = INF;\n\t\tREP(i, n)\n\t\t{\n\t\t\tchmin(res, d[i][s] + d[i][g1] + d[i][g2]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define N 100\nconst int infty = 1<<28;\nstruct Node{\n  vector<int> con;\n  vector<int> cost;\n};\nstruct State{\n  int now;\n  int cost;\n  State():now(-1),cost(infty){}\n  State(int pos,int c):now(pos),cost(c){}\n  bool operator>(const State &t)const{return cost>t.cost;}\n};\ntypedef vector<Node> Graph;\nint dijkstra(int s, int g, Graph &G)\n{\n  int A[G.size()];\n  bool vis[G.size()];\n  priority_queue< State,vector<State>,greater<State> > qs;\n  fill(A,A+G.size(),infty);\n  fill(vis,vis+G.size(),false);\n  qs.push(State(s,0));\n  while(!qs.empty()){\n    State now=qs.top();qs.pop();\n    //if(vis[now.now])continue;\n    //vis[now.now]=true;\n    for(int i=0;i<G[now.now].con.size();++i){\n      int next_id=G[now.now].con[i];\n      if(now.cost+G[now.now].cost[i]<A[next_id]){\n\tA[next_id]=now.cost+G[now.now].cost[i];\n\t//if(!vis[next_id]){\n\tqs.push(State(next_id,A[next_id]));\n\t  //}\n      }\n    }\n  }\n  return A[g];\n}\nint main()\n{\n  int n,m,s,g1,g2;\n  while( (cin >> n >> m >> s >> g1 >> g2) && n && m && s && g1 && g2 ){\n    int ans=infty;\n    --s;--g1;--g2;\n    Graph G(n);\n    for(int i = 0; i < m; ++i){\n      int src,dst,cost;\n      cin >> src >> dst>> cost;--src;--dst;\n      G[src].con.push_back(dst);\n      G[dst].con.push_back(src);\n      G[src].cost.push_back(cost);\n      G[dst].cost.push_back(cost);\n    }\n    for(int i = 0; i < n; ++i){\n      int tmp=dijkstra(s,i,G)+dijkstra(i,g1,G)+dijkstra(i,g2,G);\n      if(tmp<ans)ans=tmp;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint main(){\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2,n!=0){\n        s--, g1--, g2--;\n\n        vvi G(n, vi(n, 1e8));\n        rep(i, m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--, b--;\n            G[a][b] = G[b][a] = c;\n        }\n\n        rep(k, n)rep(i, n)rep(j, n){\n            G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n        }\n        rep(i, n) G[i][i] = 0;\n\n        int ans = 1e8;\n        rep(i, n){\n            ans = min(ans, G[s][i] + G[i][g1] + G[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst int INF = INT_MAX / 4;\n\nint main(void) {\n\tint n, m, s, g1, g2;\n\t\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\ts--; g1--; g2--;\n\n\t\tVVI es(n, VI(n, INF));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tes[a][b] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tes[i][i] = 0;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tes[i][j] = min(es[i][j], es[i][k] + es[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, es[s][i] + es[i][g1] + es[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, s, g1, g2;\nint matrix[110][110];\n\nint main() {\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n) {\n    MEMSET(matrix, 0x0f);\n    s--; g1--; g2--;\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      f--; t--;\n      matrix[f][t] = c;\n      //matrix[t][f] = c;\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      matrix[i][i] = 0;\n      matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n    }\n    int ans = 1 << 30;\n    REP(i, n) {\n      ans = min(ans, matrix[s][i] + matrix[i][g1] + matrix[i][g2]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nint32_t main() {\n    while (true) {\n        int n,m,s,g1,g2; cin >> n >> m >> s >> g1 >> g2;\n        --s,--g1,--g2;\n        if (n == 0) break;\n        auto d = make_v<int,2>(n,n,INF32);\n        rep (i,n) d[i][i] = 0;\n\n        rep (_,m) {\n            int b1,b2,c; cin >> b1 >> b2 >> c; --b1,--b2;\n            d[b1][b2] = c;\n        }\n\n        rep (k,n) rep (i,n) rep (j,n) chmin(d[i][j], d[i][k] + d[k][j]);\n\n        int ans = INF;\n        rep (x,n) chmin(ans, d[s][x] + d[x][g1] + d[x][g2]);\n        cout << ans << \"\\n\";\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define INF 100000000\n\nint n, m, s, g1, g2;\nint table[128][128];\nint Min;\n\nvoid init() {\n\tfor(int i = 0; i < 128; i++) {\n\t\tfor(int j = 0; j < 128; j++) {\n\t\t\ttable[i][j] = INF;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 128; i++)\n\t\ttable[i][i] = 0;\n\n\tMin = INF;\n}\n\nbool input() {\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif(!n && !m && !s && !g1 && !g2)\n\t\treturn false;\n\tfor(int i = 0; i < m; i++) {\n\t\tint b1, b2, c;\n\t\t\n\t\tcin >> b1 >> b2 >> c;\n\t\ttable[b1 - 1][b2 - 1] = table[b2 - 1][b1 - 1] = c;\n\t}\n\treturn true;\n}\n\nint solve() {\n\t// warshall floyd\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < n; j++) {\n\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\ttable[j][k] = table[j][k] < (table[j][i] + table[i][k]) ?\n\t\t\t\t\ttable[j][k] : (table[j][i] + table[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// search min\n\tfor(int i = 0; i < n; i++) {\n\t\tif(Min > table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1])\n\t\t\tMin = table[s - 1][i] + table[i][g1 - 1] + table[i][g2 - 1];\n\t}\n\n\treturn Min;\n}\n\nint main(void) {\n\tinit();\n\twhile(input()) {\n\t\tcout << solve() << endl;\n\t\tinit();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n  int prev[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n    fill(prev, prev + V, -1);\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n          prev[e.to] = v;\n        }\n      }\n    }\n\n    return d;\n  }\n\n  vector<int> GetPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prev[t]) {\n      path.push_back(t);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n + m + s + g1 + g2 == 0) {\n      break;\n    }\n    s--; g1--; g2--;\n    Dijkstra dijkstra(n);\n    for (int i = 0; i < m; i++) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      dijkstra.AddEdge(b1, b2, c);\n      dijkstra.AddEdge(b2, b1, c);\n    }\n\n\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      ans = min(ans, d[s] + d[g1] + d[g2]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n#define INF 10000000\n\nusing namespace std;\n\nmain(){\n\n  int node, edge, source, dst1, dst2;\n  \n  while(cin >> node >> edge >> source >> dst1 >> dst2){\n    if(node == 0)break;\n    source--;\n    dst1--;\n    dst2--;\n    \n    int d[node][node];\n    fill(&d[0][0], &d[node-1][node], INF);\n\n    for(int i=0; i<node; i++){\n      d[i][i] = 0;\n    }\n\n    for(int i=0; i<edge; i++){\n      int f, t;\n      cin >> f >> t;\n      cin >> d[f-1][t-1];\n    }\n\n    for(int i=0; i<node; i++){\n      for(int j=0; j<node; j++){\n\tfor(int k=0; k<node; k++){\n\t  d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n\t}\n      }\n    }\n\n    int ans = INF;\n\n    for(int i=0; i<node; i++){\n      ans = min(ans, d[source][i] + d[i][dst1] + d[i][dst2]);\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint t[1000][1000];\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 1, sizeof(z));\n\t\tmemset(t, 0, sizeof(t));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (x[i][j] >= 1 && t[i][j] == 0) {\n\t\t\t\t\tx[j][i] = x[i][j];\n\t\t\t\t\tx[i][j] = 0;\n\t\t\t\t\tt[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1e8\nusing namespace std;\nint main(){\n  int n,m,x,y,z,q,w,e;\n  while(cin>>n>>m>>x>>y>>z,n++){\n    int dp[n][n]={};\n    r(i,n)r(j,n)if(i!=j)dp[i][j]=INF;\n    r(i,m){\n      cin>>q>>w>>e;\n      dp[q][w]=e;\n    }\n    r(o,n)r(i,n)r(j,n)dp[i][j]=min(dp[i][j],dp[i][o]+dp[o][j]);\n    int ans=INF;\n    r(i,n)ans=min(ans,dp[x][i]+dp[i][y]+dp[i][z]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define INF 1 << 29\n\nusing namespace std;\n\nint n, m, s, g1, g2;\nint cost[101][101];\n\nint main(){\n\n  while(scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n){\n    s--;g1--;g2--;\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    rep(i, n) cost[i][i] = 0;\n    int a, b, c;\n    rep(i, m){\n      scanf(\"%d%d%d\", &a, &b, &c);\n      a--;b--;\n      cost[a][b] = c;\n    }\n\n    rep(i, n) rep(j, n) rep(k, n)\n      cost[j][k] = min(cost[j][k], cost[j][i] + cost[i][k]);\n\n    /*    rep(i, n){\n      rep(j, n) printf(\"%d \", cost[i][j]);\n      puts(\"\");\n      } */ \n \n    int res = INF;\n    rep(i, n){\n      res = min(res, cost[s][i] + cost[i][g1] + cost[i][g2]);\n      //      printf(\"%d + %d + %d\\n\", cost[s][i], cost[i][g1], cost[i][g2]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1e+8\nusing namespace std;\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(1){\n\t\tcin >> n >> m >> s >> g1 >> g2; s--;g1--;g2--;\n\t\tif(!n) break;\n\t\tint cost[100][100];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++) cost[i][j] = INF;\n\t\t\tcost[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tcost[a - 1][b - 1] = c;\n\t\t}\n\t\tfor(int k = 0;k < n;k++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = min(cost[i][j],cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tmi = min(mi,cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<28\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint d[105][105];\n\nvoid warshall_floyd (int V )\n{\n\trep (k, V ){\n\t\trep (i, V ){\n\t\t\trep (j, V ){\n\t\t\t\td[i][j] = min (d[i][j], d[i][k] + d[k][j] );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.WPC\", \"r\", stdin );\n\tint n, m, s, g1, g2;\n\twhile (scanf (\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2 ) ){\n\t\tif (n == 0 ) break;\n\t\ts--; g1--; g2--;\n\t\trep (i, n ) rep (j, n ) d[i][j] = (i != j ? INF: 0 );\n\t\n\t\trep (i, m ){\n\t\t\tint from, to, c;\n\t\t\tscanf (\"%d %d %d\", &from, &to, &c );\n\t\t\tfrom--; to--;\n\t\t\td[from][to] = c;\n\t\t} // end rep\n\t\tint res = INF;\n\n\t\twarshall_floyd (n );\n\n\t\trep (i, n ){\n\t\t\tint curr = d[s][i] + d[i][g1] + d[i][g2];\n\t\t\tres = min (res, curr );\n\t\t} // end rep\n\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\n\nint N, M, S, G1, G2, A, B, D;\nll d[100][100];\n\nint main(void) {\n  while(cin >> N >> M >> S >> G1 >> G2, N || M || S || G1 || G2) {\n    REP(i, 0, N) REP(j, 0, N) d[i][j] = INF;\n    REP(i, 0, N) d[i][i] = 0;\n    REP(i, 0, M) {\n      cin >> A >> B >> D;\n      d[A - 1][B - 1] = D;\n    }\n\n    REP(k, 0, N) REP(i, 0, N) REP(j, 0, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\n    ll ans = INF;\n    REP(i, 0, N) ans = min(ans, d[S - 1][i] + d[i][G1 - 1] + d[i][G2 - 1]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nusing namespace std;\n\nint main()\n{\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\ts--; g1--; g2--;\n\t\tvector<vector<int> >data;\n\t\tdata.resize(n);\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tdata[i].resize(n);\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdata[i][j] = INT_MAX / 6;\n\t\t\t}\n\t\t\tdata[i][i] = 0;\n\t\t}\n\t\tint a, b, c;\n\t\tfor (size_t i = 0; i < m; i++)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--; b--;\n\t\t\tdata[a][b] = c;\n\t\t\tdata[b][a] = c;\n\t\t}\n\t\tfor (size_t k = 0; k < n; k++)\n\t\t{\n\t\t\tfor (size_t j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (size_t i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tdata[i][j] = min(data[i][j], data[i][k] + data[k][j]);\n\t\t\t\t\tdata[j][i] = data[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INT_MAX;\n\t\tfor (size_t i = 0; i < n; i++)\n\t\t{\n\t\t\tans = min(ans, data[s][i] + data[i][g1] + data[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t\tdata.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//三叉路\n#include <iostream>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nint INF = 1e+8;\nint n, m, s, g1, g2;\nint dist[100][100];\n\nint main() {\n\twhile (cin >> n >> m >> s >> g1 >> g2) {\n\t\tif (!n) break;\n\t\ts--; g1--; g2--;\n\t\t\n\t\tint i, j, k;\n\t\trep(i, n) rep(j, n) dist[i][j] = INF;\n\t\trep(i, n) dist[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint u, v, c;\n\t\t\tcin >> u >> v >> c;\n\t\t\tu--; v--;\n\t\t\tdist[u][v] = c;\n\t\t}\n\t\t\n\t\trep(k, n) rep(i, n) rep(j, n) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\tint ans = INF;\n\t\trep(k, n) {\n\t\t\tint cst = dist[s][k] + dist[k][g1] + dist[k][g2];\n\t\t\tans = min(ans, cst);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\tint b1, b2, c;\n\tint k, i, j;\n\tint minCost;\n\n\tvvi cost;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) && n!=0) {\n\n\tcost.resize(n);\n\t\n\tREP(i, n) {\n\t\tcost[i].resize(n);\n\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tcin >> b1 >> b2 >> c;\n\n\t\tcost[b1-1][b2-1] = c;\n\t}\n\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint minCost=INT_MAX;\n\tFOR(i, s-1, n) {\n\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t}\n\n\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-9;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K >> L >> R;\n\tvector<int>ans;\n\twhile (N) {\n\t\tvector<vector<int>>edge(N, vector<int>(N,MOD));\n\t\tK--;\n\t\tL--;\n\t\tR--;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge[a][b] = c;\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (edge[K][i] == MOD || edge[i][L] == MOD || edge[i][R] == MOD)continue;\n\t\t\tret = min(ret, edge[K][i] + edge[i][L] + edge[i][R]);\n\t\t}\n\t\tans.push_back(ret);\n\t\tcin >> N >> M >> K >> L >> R;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint dis[123][123];\nint n,m,s,g1,g2;\n\nint main() {\n\tIL{\n\t\tcin>>n>>m>>s>>g1>>g2;\n\t\tif(n+m+s+g1+g2==0)break;\n\t\t--s,--g1,--g2;\n\t\trep(i,n)rep(j,n)dis[i][j]=INF;\n\t\trep(i,n)dis[i][i]=0;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\t--a,--b;\n\t\t\tdis[a][b]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)chmin(dis[i][j],dis[i][k]+dis[k][j]);\n\t\tint res=INF;\n\t\trep(i,n)chmin(res,dis[s][i]+dis[i][g1]+dis[i][g2]);\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define inf 1e8\nusing namespace std;\n\nint main(void){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\tint a,b,c;\n\t\tint edge[101][101];\n\t\tREP(i,1,n+1) REP(j,1,n+1) {\n\t\t\tif(i==j) edge[i][j]=0;\n\t\t\telse edge[i][j]=inf;\n\t\t}\n\t\tREP(i,0,m){\n\t\t\tcin>>a>>b>>c;\n\t\t\tedge[a][b]=edge[b][a]=c;\n\t\t}\n\t\tREP(k,1,n+1) REP(i,1,n+1) REP(j,1,n+1)\n    \t\t\t\tedge[i][j]=min(edge[i][k]+edge[k][j],edge[i][j]);\n\t\tint ans=3*1e8;\n    \tREP(i,1,n+1){\n    \t\tans=min(ans,edge[s][i]+edge[i][g1]+edge[i][g2]);\n    \t}\n    \tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=101;\nconst int INF=(1<<9);\n\nint main(){\n  int n,m;\n  int s,g1,g2;\n  int pipe[MAX][MAX];\n\n  while(1){\n    scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2);\n\n  if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\n  for( int i=0;i<=n;i++ ) {\n    for( int j=0;j<=n;j++ ) {\n      pipe[i][j]=INF;\n    }\n    pipe[i][i]=0;\n  }\n\n  for( int i=0;i<m;i++ ) {\n    int b1,b2,c; \n    scanf(\"%d%d%d\", &b1, &b2, &c);\n    pipe[b1][b2]=c;\n  }\n\n  for( int i=1;i<=n;i++ ) {\n    for( int j=1;j<=n;j++ ) {\n      for( int k=1;k<=n;k++ ) {\n\tpipe[j][k]=min(pipe[j][k],pipe[j][i]+pipe[i][k]);\n      }\n    }\n  }\n  int ans=INF;\n  for( int i=1;i<=n;i++ ){\n    ans=min(ans,pipe[s][i]+pipe[i][g1]+pipe[i][g2]);\n  }\n  printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nint N, M, s, g1, g2;\nusing pii = pair<int, int>;\nusing Graph = vector< vector<pii> >;\nusing Matrix = vector< vector<int> >;\nconst int INF = 1 << 25;\n\nvoid warshall(Matrix &mat) {\n    int P = mat.size();\n    for(int k=0; k<P; k++) {\n        for(int i=0; i<P; i++) {\n            for(int j=0; j<P; j++) {\n                mat[i][j] = min(mat[i][j], mat[i][k] + mat[k][j]);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin >> N >> M >> s >> g1 >> g2, N) {\n        s--; g1--; g2--;\n\n        Graph G(N);\n        Matrix gst(N, vector<int>(N, INF));\n        Matrix rev(N, vector<int>(N, INF));\n\n        for(int i=0; i<N; i++) {\n            gst[i][i] = rev[i][i] = 0;\n        }\n\n        for(int i=0; i<M; i++) {\n            int u, v, cost; cin >> u >> v >> cost;\n            u--; v--;\n            gst[u][v] = cost;\n            rev[v][u] = cost;\n        }\n\n        warshall(gst);\n        warshall(rev);\n\n        int ans = INF;\n        for(int i=0; i<N; i++) {\n            ans = min(ans, gst[i][g1] + gst[i][g2] + rev[i][s]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dest, cost; \n    edge(int s, int t, int c): src(s), dest(t), cost(c) {}\n};\nconst int INF = 1e8;\n\nvoid bellman_ford(const vector<edge> &edges, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    for(int i=0; i < edges.size(); ++i) {\n        edge e = edges[i];\n        if (d[e.dest] > d[e.src] + e.cost) {\n            d[e.dest] = d[e.src] + e.cost;\n            i = -1;\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<edge> edges;\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges.push_back(edge(b1-1, b2-1, c));\n        }\n        REP(i, n) {\n            bellman_ford(edges, d[i], i);\n        }\n        int ans = 0;\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define INF (1<<28)\n#define mk make_pair\n#define fs first\n#define sc second\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint n,m,s,g,h;\nvector<vi> v;\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \",\";\n\tout << \"}\" << endl;\n}\n\nint main(){\n\twhile(cin >> n >> m >> s >> g >> h, n){\n\t\tv.resize(n,vi(n,INF));\n\t\tint ans = INF;\n\t\ts--; g--; h--;\n\t\trep(i,m){\n\t\t\tint x, y, c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tv[x-1][y-1] = c;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n) v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n\t\t\n\t\trep(i,n){\n\t\t\tans = min (ans, v[s][i] + v[i][g] + v[i][h]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<20\nusing namespace std;\nstruct node{\n  int cur;\n  int flag;\n  int cost;\n};\nint main(){\n  int n,m,s,g1,g2;\n  while(cin>>n>>m>>s>>g1>>g2,n){\n    g1--,g2--,s--;\n    int d[100][100]={0},a,b,c;\n    rep(i,m){\n      cin>>a>>b>>c;\n      d[a-1][b-1]=d[b-1][a-1]=c;\n    }\n    int cost[4][100];\n    rep(i,4)rep(j,100)cost[i][j]=INF;\n    queue<node> F;\n    node cn;\n    cn.cur=s,cn.flag=0,cn.cost=0;\n    F.push(cn);\n    cost[0][s]=0;\n    while(!F.empty()){\n      int cvis=F.front().flag;\n      int cur=F.front().cur;\n      int ccost=F.front().cost;\n      F.pop();\n      //cout<<\"debug \"<<cvis<<\" \"<<cur<<\" \"<<ccost<<endl;\n      rep(i,n)if(d[cur][i]>0){\n\tint nvis=cvis;\n\tif(i==g1)nvis=cvis|1;\n\tif(i==g2)nvis=cvis|2;\n\tif(cost[nvis][i]>ccost+d[cur][i]){\n\t  cn.cur=i,cn.flag=nvis,cn.cost=ccost+d[cur][i];\n\t  cost[nvis][i]=cn.cost;\n\t  F.push(cn);\n\t}\n\tif(nvis!=cvis){\n\t  cn.cur=cur,cn.flag=nvis,cn.cost=ccost+d[cur][i];\n\t  if(cost[nvis][cur]>cn.cost){\n\t    cost[nvis][cur]=cn.cost;\n\t    F.push(cn);\n\t  }\n\t}\n      }\n    }\n    cout<<cost[3][g1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#define INF (1e9)\n#define N 101\nusing namespace std;\nint n,m,s,g1,g2,b,e,c,d[N][N],ans;\nvoid warshall_floyd();\n\nint main(){\n  while(1){\n    cin>>n>>m>>s>>g1>>g2;\n    if(!n&&!m&&!s&&!g1&&!g2) break;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) d[i][j]=INF;\n    for(int i=0;i<N;i++) d[i][i]=0;\n    while(m--) cin>>b>>e>>c,d[b][e]=c;\n    warshall_floyd();\n    ans=INF;\n    for(int i=1;i<=n;i++) ans=min(ans,d[s][i]+d[i][g1]+d[i][g2]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nvoid warshall_floyd(){\n  for(int k=1;k<=n;k++)\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nclass WarshallFloyd{\n    public:\n        vector<vector<int>> d;\n        WarshallFloyd(vector<vector<int>> g) : d(g){\n            int V=g.size();\n            for(int i=0;i<V;i++) d[i][i]=0;\n\n            for(int k=0;k<V;k++)\n                for(int i=0;i<V;i++)\n                    for(int j=0;j<V;j++)\n                        d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n        }\n\n        int get(int i,int j){\n            return d[i][j];\n        }\n};\n\nvoid solve(int n,int m,int s,int g1,int g2){\n    s--;\n    g1--;\n    g2--;\n    vector<vector<int>> g(n,vector<int>(n,INF));\n    rep(i,m){\n        int b1,b2,c;\n        cin>>b1>>b2>>c;\n        b1--;\n        b2--;\n        g[b1][b2]=c;\n    }\n\n    WarshallFloyd wf(g);\n    int ans = INF;\n    for(int i=0;i<n;i++){\n        int cost = wf.get(s,i) + wf.get(i,g1) + wf.get(i,g2);\n        ans = min(ans,cost);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    int n,m,s,g1,g2;\n    while(cin>>n>>m>>s>>g1>>g2){\n        if(n==0 and m==0 and s==0 and g1==0 and g2==0) break;\n        solve(n,m,s,g1,g2);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int INF = 1e9;\n\nint main() {\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2 && n){\n        s--;\n        g1--;\n        g2--;\n        VVI d(n, VI(n, INF));\n        REP(i,n) d[i][i] = 0;\n        REP(i,m){\n            int x, y, z;\n            cin >> x >> y >> z;\n            x--;\n            y--;\n            d[x][y] = z;\n        }\n        REP(i,n) REP(j,n) REP(k,n) d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n        int ans = INF;\n        REP(i,n){\n            ans = min(ans, d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n#define inf 101010\n\nint main(void) {\n    int n,m,s,g1,g2;\n    while (cin>>n>>m>>s>>g1>>g2 && n) {\n        vector<vector<int> > e(n+1, vector<int>(n+1, inf));\n        for (int i = 0; i < m; i++) {\n            int a,b,c;\n            cin >> a >> b >> c;\n            e[a][b] = c;\n        }\n        \n        for (int k = 1; k < n+1; k++) {\n            for (int i = 1; i < n+1; i++) {\n                for (int j = 1; j < n+1; j++) {\n                    e[i][j] = min(e[i][j], e[i][k]+e[k][j]);\n                }\n            }\n        }\n        \n        int ans = inf;\n        for (int i = 1; i < n+1; i++) {\n            ans = min(ans, e[s][i] + e[i][g1] + e[i][g2]);\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int n,m,s,t,u;\n  while(cin>>n>>m>>s>>t>>u,n||m||s||t||u){\n    --s;\n    --t;\n    --u;\n    int a[100][100];\n    fill(a[0],a[0]+n*100,1<<28);\n    for(i=0;i<n;++i)\n      a[i][i]=0;\n    for(i=0;i<m;++i){\n      int p,q,r;\n      cin>>p>>q>>r;\n      --p;\n      --q;\n      a[p][q]=r;\n    }\n    for(k=0;k<n;++k)\n      for(i=0;i<n;++i)\n\tfor(j=0;j<n;++j)\n\t  a[i][j]=min(a[i][j],a[i][k]+a[k][j]);\n    int mn=1<<30;\n    for(i=0;i<n;++i)\n      mn=min(mn,a[s][i]+a[i][t]+a[i][u]);\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <climits>\n\nusing namespace std;\n\nvoid Dijkstra(int n, int s, int edge[][100], int node[])\n{\n    int close[100]={0};\n    int mn;\n    node[s] = 0;\n    for(int i=0;i<n;++i)\n    {\n        close[s] = 1;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && edge[s][j] && node[j] > node[s]+edge[s][j])\n            {\n                node[j] = node[s]+edge[s][j];\n            }\n        }\n        mn = INT_MAX;\n        for(int j=0;j<n;++j)\n        {\n            if(!close[j] && mn > node[j])\n            {\n                mn = node[j];\n                s = j;\n            }\n        }\n    }\n}\nint main()\n{\n    int n,m,s,g1,g2;\n    int b1,b2,c;\n    int edge[100][100];\n    int node1[100];\n    int node2[100];\n    int node3[100];\n    int mn;\n    while(cin >> n >> m >> s >> g1 >> g2 &&n&&m&&s)\n    {\n        for(int i=0;i<n;++i)\n        {\n            for(int j=0;j<n;++j) edge[i][j] = 0;\n            node1[i] = INT_MAX;\n            node2[i] = INT_MAX;\n            node3[i] = INT_MAX;\n        }\n        for(int i=0;i<m;++i)\n        {\n            cin >> b1 >> b2 >> c;\n            --b1;--b2;\n            edge[b1][b2] = c;\n            edge[b2][b1] = c;\n        }\n        Dijkstra(n,s-1,edge,node1);\n        Dijkstra(n,g1-1,edge,node2);\n        Dijkstra(n,g2-1,edge,node3);\n        /*\n        for(int i=0;i<n;++i) cout << node1[i] << ' ';\n        cout << endl;\n        for(int i=0;i<n;++i) cout << node2[i] << ' ';\n        cout << endl;\n        for(int i=0;i<n;++i) cout << node3[i] << ' ';\n        cout << endl;\n        */\n        mn = INT_MAX;\n        for(int i=0;i<n;++i) mn = min(mn, node1[i]+node2[i]+node3[i]);\n        cout << mn << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint t[1000][1000];\nint x[1000][1000];\nint n, m, a, b, c;\nint s, g1, g2;\nint z[1000][3];\nint minx;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(z, 1, sizeof(z));\n\t\tmemset(t, 0, sizeof(t));\n\t\tminx = 1500000000;\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) { break; }\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tx[a][b] = c;\n\t\t}\n\t\tz[s][0] = 0;\n\t\tz[g1][1] = 0;\n\t\tz[g2][2] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[j][k] >= 1) {\n\t\t\t\t\t\tif (z[j][0] < 100000000) {\n\t\t\t\t\t\t\tz[k][0] = min(z[k][0], z[j][0] + x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[k][j] >= 1) {\n\t\t\t\t\t\tif (z[j][1] < 100000000) {\n\t\t\t\t\t\t\tz[k][1] = min(z[k][1], z[j][1] + x[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tif (x[k][j] >= 1) {\n\t\t\t\t\t\tif (z[j][2] < 100000000) {\n\t\t\t\t\t\t\tz[k][2] = min(z[k][2], z[j][2] + x[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tminx = min(minx, z[i][0] + z[i][1] + z[i][2]);\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 105;\nconst int INF = 1e9;\n\nint main() {\n  int G[MAX_N][MAX_N], N, M, S, G1, G2;\n  while(cin >>N >>M >>S >>G1 >>G2 && N){\n    --S; --G1; --G2;\n    REP(i, N) REP(j, N) G[i][j] = INF;\n    REP(i, M){\n      int f, t, c; cin >>f >>t >>c;\n      G[f - 1][t - 1] = c;\n    }\n    int ans = INF;\n    REP(k, N) REP(i, N) REP(j, N) G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n    REP(i, N) ans = min(ans, G[S][i] + G[i][G1] + G[i][G2]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\n#define MAX_N 101\n#define INF (1<<28)\n\nint n, m, s, g1, g2;\nint graph[MAX_N][MAX_N];\nint main() {\n    while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n || m || s || g1 || g2) {\n        for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) graph[i][j] = INF;\n        for (int i = 0; i < m; i++) {\n            int b1, b2, c;\n            scanf(\"%d %d %d\", &b1, &b2, &c);\n            graph[b1][b2] = c;\n        }\n        for (int k = 1; k <= n; k++) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n                }\n            }\n        }\n\n        int min_cost = graph[s][g1] + graph[s][g2];\n        for (int i = 1; i <= n; i++) { // 分岐する点\n            min_cost = min(min_cost, graph[s][i] + graph[i][g1] + graph[i][g2]);\n        }\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX_N 101\n#define INF (1<<28)\n\nint n, m, s, g1, g2;\nint graph[MAX_N][MAX_N];\nint main() {\n    while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n || m || s || g1 || g2) {\n        for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) graph[i][j] = INF;\n        for (int i = 0; i < m; i++) {\n            int b1, b2, c;\n            scanf(\"%d %d %d\", &b1, &b2, &c);\n            graph[b1][b2] = c;\n        }\n        for (int k = 1; k <= n; k++) {\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);\n                }\n            }\n        }\n\n        int min_cost = graph[s][g1] + graph[s][g2];\n        for (int i = 1; i <= n; i++) { // 分岐する点\n            min_cost = min(min_cost, graph[s][i] + graph[i][g1] + graph[i][g2]);\n        }\n        printf(\"%d\\n\", min_cost);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\n#include<queue>\n#include<climits>\nusing namespace std;\n#define INF INT_MAX/3-2\n\nint n,m,s,g1,g2;\nvector< vector<int> > edge;\n\nvoid init(){\n  n=m=s=g1=g2=0;\n  edge.clear();\n}\n\nbool input(){\n  cin>>n>>m>>s>>g1>>g2;\n  if(n==0&&m==0&&s==0&&g1==0&&g2==0){\n    return 0;\n  }\n  s--;g1--;g2--;\n  edge.resize(n);\n  for(int i=0;i<n;i++){\n    edge[i].resize(n);\n    for(int j=0;j<n;j++){\n      edge[i][j]=INF;\n    }\n  }\n  for(int i=0;i<m;i++){\n    int b1,b2,c;\n    cin>>b1>>b2>>c;\n    b1--;b2--;\n    edge[b1][b2]=c;\n  }\n  return 1;\n}\n\n\n\n\nint solve(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<n;i++){\n    res=min(res,edge[s][i]+edge[i][g1]+edge[i][g2]);\n  }\n  return res;\n}\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vi2;\nconst int INF = 1 << 30;\n\nint solve();\n\nint main(void) {\n\n\n\twhile (solve()){}\n\n\treturn 0;\n\n}\n\nint solve() {\n\n\tint n, m, s, g1, g2;\n\n\tcin >> n >> m >> s >> g1 >> g2;\n\tif (!(n | m | s | g1 | g2)){ return 0; }\n\n\ts--;\n\tg1--;\n\tg2--;\n\n\t//Adjacency matrix\n\tvi2 v(n, vi(n, -1));\n\n\t//distance\n\tvi2 d(n, vi(n, INF));\n\n\t//input\n\tfor (int i = 0; i < m; i++) {\n\n\t\tint b1, b2, c;\n\n\t\tcin >> b1 >> b2 >> c;\n\t\tv[b1 - 1][b2 - 1] = c;\n\n\t}\n\n\t//Floyd???Warshall algorithm\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (v[i][j] > 0) {\n\t\t\t\td[i][j] = v[i][j];\n\t\t\t}\n\t\t\tif (i == j) {\n\t\t\t\td[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ( d[i][k] < INF && d[k][j] < INF )\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\t//s->i,i->g1,i->g2\n\tint ans = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (d[s][i] == INF || d[i][g1] == INF || d[i][g2] == INF) \n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tans = min(d[s][i] + d[i][g1] + d[i][g2], ans);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 1;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 28;\n\nint main ()\n{\n    int n, m, s, g1, g2;\n    while (cin >> n >> m >> s >> g1 >> g2, n + m + s + g1 + g2) {\n        vector<vector<int> > d(n + 1, vector<int>(n + 1, INF));\n        for (int i = 0; i <= n; i++) {\n            d[i][i] = 0;\n        }\n        for (int i = 0; i < m; i++) {\n            int gx, gy, c;\n            cin >> gx >> gy >> c;\n            d[gx][gy] = d[gy][gx] = c;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                for (int  k = 1; k <= n; k++) {\n                    d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n                }\n            }\n        }\n\n        int res = INF;\n        for (int i = 1; i <= n; i++) {\n            res = min(res, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n){\n\t\tvector<vector<int>> load(n + 1, vector<int>(n + 1, 1000000000));//from back to \n\t\tREP(i, m){\n\t\t\tint b1, b2, c;\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tload[b1][b2] = c;\n\t\t}\n\t\tFOR(i, 1, n + 1)load[i][i] = 0;\n\t\tFOR(i, 1, n + 1){\n\t\t\tFOR(j, 1, n + 1){\n\t\t\t\tFOR(k, 1, n + 1){\n\t\t\t\t\tload[j][k] = min(load[j][k], load[j][i] + load[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1000000000;\n\t\tFOR(i, 1, n + 1){\n\t\t\tans = min(ans,load[s][i]+load[i][g1]+load[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\nint n, m, s, g1, g2;\nvector<Edge> edge[128];\nint dp[128][3];\nbool used[128];\nconst int INF = 1 << 25;\nvoid dfs(int v, int* res)\n{\n\tfill_n(res, 3, INF);\n\t\n\tif (dp[v][0] != -1)\n\t{\n\t\tcopy(dp[v], dp[v] + 3, res);\n\t\treturn;\n\t}\n\n\tif (v == g1)\n\t\tres[0] = 0;\n\telse if (v == g2)\n\t\tres[1] = 0;\n\n\tused[v] = true;\n\tfor (int i = 0; i < edge[v].size(); ++i)\n\t{\n\t\tif (used[edge[v][i].to])\n\t\t\tcontinue;\n\n\t\tint c[3];\n\t\tdfs(edge[v][i].to, c);\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t\tmin_swap(res[j], c[j] + edge[v][i].cost);\n\t}\n\tused[v] = false;\n\tmin_swap(res[2], res[0] + res[1]);\n\n\tcopy(res, res + 3, dp[v]);\n}\nint main()\n{\n\twhile (cin >> n >> m >> s >> g1 >> g2, n)\n\t{\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedge[a].push_back(Edge(b, c));\n\t\t}\n\n\t\tCLEAR(dp, -1);\n\t\tint res[3];\n\t\tdfs(s, res);\n\t\tcout << res[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nint main() {\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2, n) {\n\t\ts--; g1--; g2--;\n\n\t\tvvi dist(n, vi(n, INF));\n\t\tREP(i, n) {\n\t\t\tdist[i][i] = 0;\n\t\t}\n\n\t\tint b1, b2, c;\n\t\tREP(i, m) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tdist[b1 - 1][b2 - 1] = c;\n\t\t}\n\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, n) {\n\t\t\tans = min(ans, dist[s][i] + dist[i][g1] + dist[i][g2]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct Edge {\n  int v, w;\n};\n\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<int, int> Pair;\n\nint N, M, S, G1, G2;\nGraph G, rG;\n\nvector<int> dijkstra(int src, const Graph &g) {\n  const int n = g.size();\n  vector<int> cost(n, INF);\n  priority_queue<Pair, vector<Pair>, greater<Pair> > que;\n  cost[src] = 0;\n  que.push(Pair(0, src));\n  while(que.size()) {\n    const Pair s = que.top();\n    que.pop();\n    if(s.first > cost[s.second]) continue;\n    for(int i = 0; i < g[s.second].size(); ++i) {\n      Pair t(s.first + g[s.second][i].w, g[s.second][i].v);\n      if(t.first >= cost[t.second]) continue;\n      cost[t.second] = t.first;\n      que.push(t);\n    }\n  }\n  return cost;\n}\n\nint main() {\n  while(cin >> N >> M >> S >> G1 >> G2 &&\n        (M|N|S|G1|G2)) {\n    --S; --G1; --G2;\n    G = rG = Graph(N);\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      --a; --b;\n      G[a].push_back((Edge){b, c});\n      rG[b].push_back((Edge){a, c});\n    }\n    vector<int> s = dijkstra(S, G);\n    vector<int> t = dijkstra(G1, rG);\n    vector<int> u = dijkstra(G2, rG);\n    int res = INF;\n    for(int i = 0; i < N; ++i) {\n      res = min(res, s[i] + t[i] + u[i]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nint main()\n{\n    const int INF=12345678;\n    int n,m,s,g1,g2;\n    while(scanf(\" %d %d %d %d %d\",&n,&m,&s,&g1,&g2),n)\n    {\n        //Graph\n        vector<vi> G(n,vi(n,INF));\n        rep(i,n) G[i][i]=0;\n\n        rep(i,m)\n        {\n            int a,b,c;\n            scanf(\" %d %d %d\",&a,&b,&c);\n            --a;\n            --b;\n            G[a][b]=c;\n        }\n\n        //Warshall-Floyd\n        rep(k,n)rep(i,n)rep(j,n) G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\n        int ans=INF;\n        rep(i,n) ans=min(ans,G[s-1][i]+G[i][g1-1]+G[i][g2-1]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define INF 999999999\n\nusing namespace std;\n\nint n, d[101][101];\n\nvoid warshall_floyd(void){\n\n  for( int k = 1; k <= n; k++ )\n    for( int i = 1; i <= n; i++ )\n      for( int j = 1; j <= n; j++ ){\n\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n      }\n}\n\n \nint main(void){\n\n    int m, s, g1, g2, b1, b2, c;\n\n    while(cin >> n >> m >> s >> g1 >> g2 ){\n      if( n == m && m == s && s == g1 && g1 == g2 && g2 == 0 ) break;\n\n        for( int i = 0; i <= n; i++ ){\n            for(int j = 0; j <= n; ++j){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n         \n        for( int i = 0; i < m; i++ ){\n\t  cin >> b1 >> b2 >> c;\n            d[b1][b2] = c;\n        }\n                  \n        int ans = INF;\n        for( int i = 1; i <= n; i++ ){\n            ans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 102;\nconst int INF = 1<<27;\nint N;\nint G[MAX_N][MAX_N];\n\nvoid init() {\n  fill(G[0], G[MAX_N], INF);\n  for(int i = 0; i < N; ++i) G[i][i] = 0;\n}\n\nvoid wf() {\n  for(int k = 0; k < N; ++k)\n    for(int i = 0; i < N; ++i)\n      for(int j = 0; j < N; ++j)\n\tG[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n}\n\nint solve(int s, int g1, int g2) {\n  wf();\n\n  int ans = INF;\n  for(int i = 0; i < N; ++i)\n    ans = min(ans, G[s][i] + G[i][g1] + G[i][g2]);\n\n  return ans;\n}\n\nint main() {\n  int m, s, g1, g2;\n  while(cin>>N>>m>>s>>g1>>g2&&(N|m|s|g1|g2)) {\n    --s; --g1; --g2;\n    init();\n    for(int i = 0; i < m; ++i) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      --b1; --b2;\n      G[b1][b2] = c;\n    }\n    cout << solve(s,g1,g2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F 1145141919810\nusing namespace std;\n\nlong long dp[110][110];\nint n,m,s,f,g;\n\nlong long Min(long long a,long long b){\n\tif(a>b)return b;\n\treturn a;\n}\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j]=Min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tlong long ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=Min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <fstream>\n \nusing namespace std;\n \n#define INF 1000000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\n\n#define MAX_N 102\n#define MAX_M 1002\n\nint N, M, s, g1, g2;\n\nvector<int> ans_list;\n\n\n\nint main(){\n\n  while(true){\n    \n    cin >> N >> M >> s >> g1 >> g2;\n    if(N == 0)\n      break;\n\n    s--;\n    g1--;\n    g2--;\n\n    int d[MAX_N][MAX_N];\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < N; j++){\n\td[i][j] = INF;\n      }\n      d[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--;\n      b2--;\n      d[b1][b2] = c;\n    }\n\n    for(int k = 0; k < N; k++){\n      for(int i = 0; i < N; i++){\n\tfor(int j = 0; j < N; j++){\n\t  d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t}\n      }\n    }\n\n    int ans = INF;\n\n    for(int k = 0; k < N; k++){\n      ans = min(ans, d[s][k] + d[k][g1] + d[k][g2]);\n    }\n    \n    ans_list.push_back(ans);\n\n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\tint b1, b2, c;\n\tint k, i, j;\n\tint minCost;\n\n\tvvi cost;\n\n\tcin >> n >> m >> s >> g1 >> g2;\n\n\tcost.resize(n);\n\t\n\tREP(i, n) {\n\t\tcost[i].resize(n);\n\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tcin >> b1 >> b2 >> c;\n\n\t\tcost[b1-1][b2-1] = c;\n\t}\n\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tminCost = cost[s-1][g1-1] + cost[s-1][g2-1];\n\tk = max(g1, g2);\n\n\tFOR(i, s-1, k) {\n\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t}\n\n\tcout << minCost << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\tint b1, b2, c;\n\tint k, i, j;\n\tint minCost;\n\n\tvvi cost;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) != 0) {\n\n\tcost.resize(n);\n\t\n\tREP(i, n) {\n\t\tcost[i].resize(n);\n\t}\n\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tcin >> b1 >> b2 >> c;\n\n\t\tcost[b1-1][b2-1] = c;\n\t\tcost[b2-1][b1-1] = c;\n\t}\n\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tminCost = cost[s-1][g1-1] + cost[s-1][g2-1];\n\tk = max(g1, g2);\n\n\tFOR(i, s-1, k) {\n\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t}\n\n\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\n\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst double EPS = 1e-10;\n\n\nint main() {\n\tint n, m, s, g1, g2;\n\tint b1, b2, c;\n\tint k, i, j;\n\tint minCost;\n\n\tvvi cost;\n\n\twhile((cin >> n >> m >> s >> g1 >> g2) && n!=0) {\n\t\tvvi cost(n,vi(n,INT_MAX/10));\n\n\t\tREP(i, m) {\n\t\t\tcin >> b1 >> b2 >> c;\n\n\t\t\tcost[b1-1][b2-1] = c;\n\t\t}\n\n\t\tREP(k, n) {\n\t\t\tREP(i, n) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint minCost=INT_MAX;\n\t\tFOR(i, 0, n) {\n\t\t\tminCost = min(minCost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t\t}\n\n\t\tcout << minCost << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <array>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint main() {\n  while(1){\n    int n,m,p[3];\n    cin>>n>>m>>p[0]>>p[1]>>p[2];\n    if(!n)break;\n    REP(i,3)--p[i];\n    int d[100][100];\n    REP(i,n)REP(j,n)d[i][j]=INF;\n    REP(i,m){\n      int b1,b2,c;\n      cin>>b1>>b2>>c;\n      --b1;--b2;\n      d[b1][b2]=d[b2][b1]=c;\n    }\n    REP(k,n)REP(i,n)REP(j,n)\n      d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n    int dmin=INF;\n    REP(i,n){\n      int sum=0;\n      REP(j,3) sum+=d[i][p[j]];\n      dmin=min(dmin,sum);\n    }\n    cout<<dmin<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint N, M, S, G1, G2, A, B, D;\nll d[100][100];\n\nint main(void) {\n  while(cin >> N >> M >> S >> G1 >> G2, N || M || S || G1 || G2) {\n    REP(i, 0, N) REP(j, 0, N) d[i][j] = INF;\n    REP(i, 0, N) d[i][i] = 0;\n    REP(i, 0, M) {\n      cin >> A >> B >> D;\n      d[A - 1][B - 1] = D;\n      d[B - 1][A - 1] = D;\n    }\n\n    REP(k, 0, N) REP(i, 0, N) REP(j, 0, N) {\n      d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    }\n\n    ll ans = INF;\n    REP(i, 0, N) ans = min(ans, d[S - 1][i] + d[i][G1 - 1] + d[i][G2 - 1]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main()\n{\n\tint n,m,s,g1,g2,b1,b2,c,i,j,k,d[101][101],V=INT_MAX/2;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n)\n\t{\n\t\tfor(i=1;i<=n;d[i][i]=0,++i)for(j=1;j<=n;++j)d[i][j]=V;\n\t\twhile(m--)scanf(\"%d%d%d\",&b1,&b2,&c),d[b1][b2]=c;\n\t\tfor(k=1;k<=n;++k)for(i=1;i<=n;++i)for(j=1;j<=n;++j)\n\t\t\tc=d[i][k]+d[k][j],d[i][j]=(d[i][j]<c?d[i][j]:c);\n\t\tfor(c=V,i=1;i<=n;++i)\n\t\t\tk=d[s][i]+d[i][g1]+d[i][g2],c=(c<k?c:k);\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<int> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n, m, s, g1, g2;\n        cin >> n >> m >> s >> g1 >> g2;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n+1);\n        for(int i=0; i<m; ++i){\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges[b1].push_back(Edge(b2, c));\n        }\n\n        vector<vector<int> > dist;\n        shortestPath(edges, dist);\n\n        int ret = INF;\n        for(int i=1; i<=n; ++i)\n            ret = min(ret, dist[s][i] + dist[i][g1] + dist[i][g2]);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m, s, g1, g2;\nint matrix[110][110];\n\nint main() {\n  while (scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2), n) {\n    MEMSET(matrix, 0x0f);\n    s--; g1--; g2--;\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      f--; t--;\n      matrix[f][t] = min(matrix[f][t], c);\n      matrix[t][f] = min(matrix[t][f], c);\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      matrix[i][i] = 0;\n      matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n    }\n    int ans = 1 << 30;\n    REP(i, n) {\n      ans = min(ans, matrix[s][i] + matrix[i][g1] + matrix[i][g2]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 101\n#define INF 1000*1000;\n\nint main(void){\n  int n, m, s, g1, g2;\n  int g[MAX][MAX];\n  for(int i=0; i < MAX; i++){\n    for(int j=0; j < MAX; j++){\n      g[i][j] = INF;\n    }\n  }\n  while(cin >> n >> m >> s >> g1 >> g2, n | m | s | g1 | g2){\n    for(int p=0; p < m; p++){\n      int x, y, c;\n      cin >> x >> y >> c;\n      g[x][y] = c; g[y][x] = c;\n    }\n\n    for(int i=0; i < n; i++)\n      for(int j=0; j < n; j++)\n\tfor(int k=0; k < n; k++)\n\t  g[j][k] = min(g[j][k], g[j][i] + g[i][k]);\n\n    int ans = INF;\n    for(int p = 0; p < n; p++){\n      ans = min(g[s][p]+g[p][g1]+g[p][g2], ans);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long int ll;\nusing namespace std;\n\nstruct edge {\n    int src, dest, cost; \n    edge(int s, int t, int c): src(s), dest(t), cost(c) {}\n};\nconst int INF = 1e8;\n\nvoid bellman_ford(const vector<edge> &edges, vector<int> &d, const int s) {\n    d.assign(d.size(), INF);\n    d[s] = 0;\n    for(int i=0; i < d.size(); ++i) {\n        for(int j=0; j < edges.size(); ++j) {\n            edge e = edges[j];\n            if (d[e.dest] > d[e.src] + e.cost) {\n                d[e.dest] = d[e.src] + e.cost;\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2 && n) {\n        vector<edge> edges;\n        vector<vector<int> > d(n, vector<int>(n));\n        --s; --g1; --g2;\n        REP(i, m) {\n            int b1, b2, c;\n            cin >> b1 >> b2 >> c;\n            edges.push_back(edge(b1-1, b2-1, c));\n        }\n        REP(i, n) {\n            bellman_ford(edges, d[i], i);\n        }\n        int ans = 0;\n        int cost = numeric_limits<int>::max();\n        REP(i, n) {\n            cost = min(cost, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        cout << cost << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile( true ){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint b1;\n\t\tint b2;\n\t\tint c;\n\n\t\tvector< vector < int > > map(n + 1, vector< int >(n + 1, INT_MAX / 4));\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> b1 >> b2 >> c;\n\t\t\tmap[b1][b2] = c;\n\t\t}\n\t\tfor(int i = 0; i < n + 1; i++) {\n\t\t\tmap[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor(int k = 0; k <= n; k++) {\n\t\t\tfor(int i = 0; i <= n ; i++) {\n\t\t\t\tfor(int j = 0; j <= n; j++) {\n\t\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint total = INT_MAX / 2;\n\t\tfor(int k = 0; k <= n; k++) {\n\t\t\ttotal = min(total, map[s][k] + map[k][g1] + map[k][g2]);\n\t\t}\n\n\t\tcout << total << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n\tint n, m, s, g1, g2;\n\n\twhile( true ){\n\t\tcin >> n >> m >> s >> g1 >> g2;\n\n\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< int > b1(m);\n\t\tvector< int > b2(m);\n\t\tvector< int > c(m);\n\n\t\tvector< vector < int > > map(n + 1, vector< int >(n + 1, INT_MAX / 4));\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> b1[i] >> b2[i] >> c[i];\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tmap[b1[i]][b2[i]] = c[i];\n\t\t}\n\n\t\tint total = INT_MAX / 2;\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++) {\n\t\t\ttotal = min(total, map[s][k] + map[k][g1] + map[k][g2]);\n\t\t}\n\n\t\tcout << total << endl;\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 25;\nint d[100][100];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, s, g1, g2;\n\twhile (cin >> n >> m >> s >> g1 >> g2 , n) {\n\t\ts-- , g1-- , g2--;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\td[i][j] = (i == j) ? 0 : INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\ta-- , b--;\n\t\t\td[a][b] = c;\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans = min(ans, d[s][i] + d[i][g1] + d[i][g2]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\nint N, M, S, G1, G2;\nint d[100][100];\n\nint main(){\n    while(std::cin >> N >> M >> S >> G1 >> G2, N){\n        --S; --G1; --G2;\n    \n        REP(i, N){\n            REP(j, N){\n                if(i == j){d[i][j] = 0;}\n                else{d[i][j] = INF;}\n            }\n        }\n\n        REP(i, M){\n            int from, to, cost;\n            std::cin >> from >> to >> cost;\n            --from; --to;\n        \n            d[from][to] = cost;\n        }\n\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    d[i][j] = std::min(d[i][j], d[i][k]+d[k][j]);\n                }\n            }\n        }\n\n        int res = INF;\n        REP(i, N){\n            res = std::min(res, d[S][i]+(d[i][G1]+d[i][G2]));\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 29)\nusing namespace std;\n\nconst int kN = 105;\nint atl[kN][kN];\n\nvoid warshallFloyd(int n){\n    range(k,1,n + 1){\n        range(i,1,n + 1){\n            range(j,1,n + 1){\n                atl[i][j] = min(atl[i][j], atl[i][k] + atl[k][j]);\n            }\n        }\n    }\n}\n\nint requestCost(int n, int s, int g1, int g2){\n    int retval = INF;\n    rep(i,n){\n        int cost = atl[s][i] + atl[i][g1] + atl[i][g2];\n        retval = min(retval, cost);\n    }\n    return retval;\n}\n\nint main(){\n    int n, m, s, g1, g2;\n    while(cin >> n >> m >> s >> g1 >> g2, n||m||s||g1||g2){\n        rep(i,kN) rep(j,kN) atl[i][j] = INF;\n        rep(i,m){\n            int a, b, c;\n            cin >> a >> b >> c;\n            atl[a][b] = c;\n        }\n        warshallFloyd(n);\n        cout << requestCost(n, s, g1, g2) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define F 1145141919\nusing namespace std;\n\nint dp[100][100];\nint n,m,s,f,g;\n\nvoid FW(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tdp[i][j]=F;\n\t\t\tif(i==j)dp[i][j]=0;\n\t\t}\n\t}\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\tdp[a-1][b-1]=c;\n\t}\n\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(F!=dp[i][j]){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m>>s>>f>>g&&n){\n\ts--,f--,g--;\n\tFW();\n\tint ans=F;\n\tfor(int i=0;i<n;i++){\n\t\tans=min(ans,dp[s][i]+dp[i][f]+dp[i][g]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 25;\n\nbool solve() {\n    int N, M, s, g1, g2;\n    cin >> N >> M >> s >> g1 >> g2;\n    if (N == 0) return false;\n\n    --s, --g1, --g2;\n\n    vector<vector<int>> dist(N, vector<int>(N, INF));\n    for (int v = 0; v < N; ++v) dist[v][v] = 0;\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cin >> dist[--u][--v];\n    }\n\n    for (int j = 0; j < N; ++j) {\n        for (int i = 0; i < N; ++i) {\n            for (int k = 0; k < N; ++k) {\n                dist[i][k] = min(dist[i][k], dist[i][j] + dist[j][k]);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int v = 0; v < N; ++v) {\n        ans = min(ans, dist[s][v] + dist[v][g1] + dist[v][g2]);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nint dis[101][101];\n\nint main(){\n\tint n, m, s, g1, g2;\n\twhile(cin >> n >> m >> s >> g1 >> g2 && (n || m || s || g1 || g2)){\n\t\ts--;\n\t\tg1--;\n\t\tg2--;\n\t\tfill(&dis[0][0], &dis[100][100], INF);\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from, to, cost;\n\t\t\tcin >> from >> to >> cost;\n\t\t\tfrom--; to--;\n\t\t\tdis[from][to] = cost;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) dis[i][i] = 0;\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j< n; j++){\n\t\t\t\t\tdis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tres = min(res, dis[s][i] + dis[i][g1] + dis[i][g2]);\n\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vl = std::vector<long long>;\n\tusing vvl = std::vector<vl>;\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint n, m, s, g[2];\n\t\tscanf(\"%d%d%d%d%d\", &n, &m, &s, g, g + 1);\n\t\tif (n == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\ts--; g[0]--; g[1]--;\n\t\tvvl distance(n, vl(n, 1 << 30));\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tint b[2], c;\n\t\t\tscanf(\"%d%d%d\", b, b + 1, &c);\n\t\t\tb[0]--; b[1]--;\n\t\t\tdistance[b[0]][b[1]] = c;\n\t\t}\n\t\tfor (int i{}; i < n; i++)\n\t\t\tdistance[i][i] = 0;\n\t\tfor (int med{}; med < n; med++)\n\t\t\tfor (int from{}; from < n; from++)\n\t\t\t\tfor (int to{}; to < n; to++)\n\t\t\t\t\tdistance[from][to] = std::min(distance[from][to], distance[from][med] + distance[med][to]);\n\t\tlong long min{1 << 30};\n\t\tfor (int i{}; i < n; i++)\n\t\t\tmin = std::min(min, distance[s][i] + distance[i][g[0]] + distance[i][g[1]]);\n\t\tprintf(\"%lld\\n\", min);\n\t}\n\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(cin>>n>>m>>s>>g1>>g2,n){\n\t\ts--,g1--,g2--;\n\t\tint a,b,c,d[n][n];\n\t\trep(i,n)rep(j,n)d[i][j]=1<<20;\n\t\trep(i,m){\n\t\t\tcin>>a>>b>>c;a--,b--;\n\t\t\td[a][b]=c;\n\t\t}\n\t\trep(i,n)d[i][i]=0;\n\t\trep(k,n)rep(i,n)rep(j,n)if(d[i][j]>d[i][k]+d[k][j])d[i][j]=d[i][k]+d[k][j];\n\t\t\n\t\tint ans=d[s][g1]+d[s][g2];\n\t\trep(i,n)if(ans>d[s][i]+d[i][g1]+d[i][g2])ans=d[s][i]+d[i][g1]+d[i][g2];\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\nusing ll = long long;\n\nint N, M, s, g1, g2;\nll dist[101][101];\nvoid init() {\n    REP(i, N) {\n        REP(j, N) { dist[i][j] = 1e9; }\n    }\n    REP(i, N) dist[i][i] = 0;\n}\n\nbool solve() {\n    cin >> N >> M >> s >> g1 >> g2;\n    if (N == 0) return false;\n    init();\n    REP(i, M) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        u--, v--;\n        dist[u][v] = c;\n    }\n    s--, g1--, g2--;\n    REP(k, N) REP(i, N) REP(j, N) { dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); }\n    int ans = 1e9;\n    REP(m, N) { ans = min(ans, dist[s][m] + dist[m][g1] + dist[m][g2]); }\n    cout << ans << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 123456789;\n\nstruct Edge{\n  int to, cost;\n  Edge(int t, int c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n};\ntypedef vector< vector<Edge> > Graph;\n\nVI prv(101);\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  const int V = edges.size();\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tPII pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(auto& e:edges[v]){\n\t  if(d[e.to] > d[v] + e.cost){\n\t\tprv[e.to] = v;\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, S, G1, G2;\n  while(cin>>N>>M>>S>>G1>>G2, N){\n\tint cost[101][101];\n\tfill((int*)cost, (int*)cost+101*101, INF);\n\tREP(i,M){\n\t  int a, b, t; cin >> a >> b >> t;\n\t  cost[a][b] = t;\n\t}\n\tREP(i,N+1)\n\t  cost[i][i] = 0;\n\n\tREP(k,N+1) REP(i,N+1) REP(j,N+1){\n\t  cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t}\n\n\tint ans = INF;\n\tREP(i,N+1){\n\t  ans = min(ans, cost[S][i] + cost[i][G1] + cost[i][G2]);\n\t}\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n  int prev[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n    fill(prev, prev + V, -1);\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n          prev[e.to] = v;\n        }\n      }\n    }\n\n    return d;\n  }\n\n  vector<int> GetPath(int t) {\n    vector<int> path;\n    for (; t != -1; t = prev[t]) {\n      path.push_back(t);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m, s, g1, g2;\n    cin >> n >> m >> s >> g1 >> g2;\n    if (n + m + s + g1 + g2 == 0) {\n      break;\n    }\n    s--; g1--; g2--;\n    Dijkstra dijkstra(n);\n    for (int i = 0; i < m; i++) {\n      int b1, b2, c;\n      cin >> b1 >> b2 >> c;\n      b1--; b2--;\n      dijkstra.AddEdge(b1, b2, c);\n      // dijkstra.AddEdge(b2, b1, c);\n    }\n\n\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      ans = min(ans, d[s] + d[g1] + d[g2]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int MAX = 110;\nconst int INF = (1<<25);\nint T[MAX][MAX];\nint n,m,s,g1,g2;\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++) T[i][j] = INF;\n\n  for(int i = 0; i < MAX; i++)\n    T[i][i] = 0;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++){\n    int from, to, cost;\n    cin >> from >> to >> cost;\n    T[from][to] = cost;\n  }\n}\n\nvoid solve(){\n\n  for(int k = 1; k <= n; k++)\n    for(int i = 1; i <= n; i++)\n      for(int j = 1; j <= n; j++) T[i][j] = min(T[i][j],T[i][k]+T[k][j]);\n\n  int ans = INF;\n  for(int i = 1; i <= n; i++) ans = min(ans,T[s][i]+T[i][g1]+T[i][g2]);    \n  cout << ans << endl;\n}\n\nint main(){\n\n\n  while(cin >> n >> m >> s >> g1 >> g2 &&n+m+s+g1+g2){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2005: Water Pipe Construction\n// 2017.9.24 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#include <string.h>\n#define INF 0x7ffffff\n\nint dist[102][102];\nchar buf[50], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, g1, g2, b1, b2, i, j, k, x, ans;\n\n\twhile (fgets(p=buf, 50, stdin) && *p != '0') {\n\t\tn = getint(), p++, m = getint(), p++;\n\t\ts = getint(), p++, g1 = getint(), p++, g2 = getint();\n\t\tmemset(dist, 0x11, sizeof(dist));\n\t\tfor (i = 0; i <= n; i++) dist[i][i] = 0;\n\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tb1 = getint(), p++, b2 = getint(), p++;\n\t\t\tdist[b1][b2] = getint();\n\t\t}\n        for (k = 1; k <= n; k++) for (i = 1; i <= n; i++) for (j = 1; j <= n; j++) {\n\t\t\tx = dist[i][k] + dist[k][j];\n\t        if (dist[i][j] > x) dist[i][j] = x;\n        }\n\t\tfor (ans = INF, i = 1; i <= n; i++) {\n\t\t\tif ((x = dist[s][i] + dist[i][g1] + dist[i][g2]) < ans) ans = x;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 110001000\n#define min(a, b) a<b?a:b\n  \nint n, m, s, g1, g2;\nint gp[100][100];\n  \nint main(void)\n{\n    int i, j, k, f, t, d;\n    scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    while (n) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                gp[i][j] = INF;\n            }\n            gp[i][i] = 0;\n        }\n        for (i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &f, &t, &d);\n            gp[f-1][t-1] = d;\n        }\n        for (k = 0; k < n; k++) {\n            for (i = 0; i < n; i++) {\n                for (j = 0; j < n; j++) {\n                    gp[i][j] = min(gp[i][j], gp[i][k] + gp[k][j]);\n                }\n            }\n        }\n        int ans = INF;\n        for (k = 0; k < n; k++) {\n            ans = min(ans, gp[s-1][k] + gp[k][g1-1] + gp[k][g2-1]);\n        }\n        printf(\"%d\\n\", ans);\n        scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2005: Water Pipe Construction\n// 2017.9.24 bal4u@uu\n// 2017.11.21\n\n#include <stdio.h>\n#include <string.h>\n#define MAX 100000\n\nint dist[102][102];\nchar buf[50], *p;\n\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, s, g1, g2, b1, b2, i, j, k, x, ans;\n\n\twhile (fgets(p=buf, 50, stdin) && *p != '0') {\n\t\tn = getint(), p++, m = getint(), p++;\n\t\ts = getint(), p++, g1 = getint(), p++, g2 = getint();\n\t\tmemset(dist, 0x11, sizeof(dist));\n\t\tfor (i = 0; i <= n; i++) dist[i][i] = 0;\n\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 50, stdin);\n\t\t\tb1 = getint(), p++, b2 = getint(), p++;\n\t\t\tdist[b1][b2] = getint();\n\t\t}\n        for (k = 1; k <= n; k++) for (i = 1; i <= n; i++) {\n\t\t\tif (dist[i][k] > MAX) continue;\n\t\t\tfor (j = 1; j <= n; j++) {\n\t\t\t\tx = dist[i][k] + dist[k][j];\n\t\t        if (dist[i][j] > x) dist[i][j] = x;\n\t\t\t}\n        }\n\t\tfor (ans = 0x7ffffff, i = 1; i <= n; i++) {\n\t\t\tif ((x = dist[s][i] + dist[i][g1] + dist[i][g2]) < ans) ans = x;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 2005: Water Pipe Construction\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define INF 0x7fffff\n\nint dist[102][102];\n\nint main()\n{\n\tint n, m, s, g1, g2, b1, b2, c, i, j, k, x, ans;\n\n\twhile (scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n > 0) {\n\t\tfor (i = 1; i <= n; i++) for (j = 1; j <= n; j++) dist[i][j] = INF;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &b1, &b2, &c);\n\t\t\tdist[b1][b2] = c;\n\t\t}\n        for (k = 1; k <= n; k++) for (i = 1; i <= n; i++) for (j = 1; j <= n; j++) {\n\t\t\tx = dist[i][k] + dist[k][j];\n\t        if (dist[i][j] > x) dist[i][j] = x;\n        }\n\t\tfor (ans = 0x7ffffff, i = 1; i <= n; i++) {\n\t\t\tif ((x = dist[s][i] + dist[i][g1] + dist[i][g2]) < ans) ans = x;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n#define min(a, b) a<b?a:b\n\nint n, m, s, g1, g2;\nint gp[100][100];\n\nint main(void)\n{\n    int i, j, k, f, t, d;\n    scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    while (n) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                gp[i][j] = INF;\n            }\n            gp[i][j] = 0;\n        }\n        for (i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &f, &t, &d);\n            gp[f-1][t-1] = d;\n        }\n        for (k = 0; k < n; k++) {\n            for (i = 0; i < n; i++) {\n                for (j = 0; j < n; j++) {\n                    gp[i][j] = min(gp[i][j], gp[i][k] + gp[k][j]);\n                }\n            }\n        }\n        int ans = INF;\n        for (k = 0; k < n; k++) {\n            ans = min(ans, gp[s-1][k] + gp[k][g1-1] + gp[k][g2-1]);\n        }\n        printf(\"%d\\n\", ans);\n        scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "D[101][101],i,j,k,t;main(n,m,s,g,h){for(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g,&h)*n;printf(\"%d\\n\",k)){memset(D,1,40804);for(;m--;D[i][j]=k,D[i][i]=0)scanf(\"%d%d%d\",&i,&j,&k);for(k=n;k;k--)for(i=n;i;i--)for(j=n;j;j--)t=D[i][k]+D[k][j],t<D[i][j]?D[i][j]=t:0;k=1e9;for(i=n;i;i--)t=D[s][i]+D[i][g]+D[i][h],t<k?k=t:0;}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,ta,tb,s,i,j,k,min,a,b,c;\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&ta,&tb),n){\n    int d[110][110]={0};\n    for(i=0;i<110*110;i++)min=d[i/110][i%110]=100000000;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      d[a-1][b-1]=c;\n    }//printf(\"a\\n\");\n    for(i=0;i<n;i++)d[i][i]=0;\n    for(k=0;k<n;k++){\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++)d[i][j]=MIN(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n    /*for(i=0;i<n;i++){\n      for(j=0;j<n;j++)printf(\"%2d \",d[i][j]);printf(\"\\n\");\n      }//*/\n    for(i=0;i<n;i++)min=MIN(min,d[s-1][i]+d[i][ta-1]+d[i][tb-1]);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "D[124][101],i,j,k,t;main(n,m,s,g,h){for(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g,&h)*n;printf(\"%d\\n\",k)){memset(D,1,5e4);for(;m--;D[i][j]=k,D[i][i]=0)scanf(\"%d%d%d\",&i,&j,&k);for(k=n;k;k--)for(i=n;i;i--)for(j=n;j;j--)t=D[i][k]+D[k][j],t<D[i][j]?D[i][j]=t:0;k=1e9;for(i=n;i;i--)t=D[s][i]+D[i][g]+D[i][h],t<k?k=t:0;}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,ta,tb,s,i,j,k,min,a,b,c;\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&ta,&tb),n){\n    int d[110][110]={0};\n    for(i=0;i<n*n;i++)min=d[i/n][i%n]=1000000000;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      d[a-1][b-1]=d[b-1][a-1]=c;\n      d[a-1][a-1]=d[b-1][b-1]=0;\n    }//printf(\"a\\n\");\n    for(k=1;k<n;k++){\n      for(i=1;i<n;i++){\n\tfor(j=1;j<n;j++)d[i][j]=MIN(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n    /*for(i=0;i<n;i++){\n      for(j=0;j<n;j++)printf(\"%2d \",d[i][j]);printf(\"\\n\");\n      }*/\n    for(i=0;i<n;i++)min=MIN(min,d[i][s-1]+d[i][ta-1]+d[i][tb-1]);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define REP(i, n) for((i) = 0; (i) < (n); (i)++)\n#define READ1(n1) scanf(\"%d\", &(n1))\n#define READ2(n1, n2) scanf(\"%d%d\", &(n1), &(n2))\n#define READ3(n1, n2, n3) scanf(\"%d%d%d\", &(n1), &(n2), &(n3))\n#define P1(n1) printf(\"%d\\n\", (n1))\n#define P2(n1, n2) printf(\"%d, %d\\n\", (n1), (n2))\n#define P3(n1, n2, n3) printf(\"%d, %d, %d\\n\", (n1), (n2), (n3))\n#define CLEAR(p) memset((p), 0, sizeof((p)))\nmain()\n{\n\twhile(1) {\n\t\tint i, j, k;\n\t\tint base_num, road_num, supply, dest1, dest2;\n\t\tint answer = INT_MAX;\n\t\tint cost[100][100];\n\n\t\tREAD2(base_num, road_num);\n\n\t\tREAD3(supply, dest1, dest2);\n\n\t\tif(base_num == 0) break;\n\n\t\tREP(i, base_num) {\n\t\t\tREP(j, base_num) {\n\t\t\t\tcost[i][j] = (INT_MAX - 1) / 3;\n\t\t\t}\n\t\t}\n\n\t\tREP(i, base_num) {\n\t\t\tcost[i][i] = 0;\n\t\t}\n\n\t\tREP(i, road_num) {\n\t\t\tint from, to, value;\n\n\t\t\tREAD3(from, to, value);\n\n\t\t\tcost[from-1][to-1] = value;\n\t\t}\n\n\t\twhile(1) {\n\t\t\tint flag = false;\n\n\t\t\tREP(i, base_num) {\n\t\t\t\tREP(j, base_num) {\n\t\t\t\t\tREP(k, base_num) {\n\t\t\t\t\t\tif(cost[i][j] + cost[j][k] < cost[i][k]) {\n\t\t\t\t\t\t\tcost[i][k] = cost[i][j] + cost[j][k];\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!flag) break;\n\t\t}\n\n\t\tREP(i, base_num) {\n\t\t\tif(cost[supply-1][i] + cost[i][dest1-1] + cost[i][dest2-1] < answer) {\n\t\t\t\tanswer = cost[supply-1][i] + cost[i][dest1-1] + cost[i][dest2-1];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", answer);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define REP(i, n) for((i) = 0; (i) < (n); (i)++)\n#define READ1(n1) scanf(\"%d\", &(n1))\n#define READ2(n1, n2) scanf(\"%d%d\", &(n1), &(n2))\n#define READ3(n1, n2, n3) scanf(\"%d%d%d\", &(n1), &(n2), &(n3))\n#define P1(n1) printf(\"%d\\n\", (n1))\n#define P2(n1, n2) printf(\"%d, %d\\n\", (n1), (n2))\n#define P3(n1, n2, n3) printf(\"%d, %d, %d\\n\", (n1), (n2), (n3))\n#define CLEAR(p) memset((p), 0, sizeof((p)))\nmain()\n{\n\twhile(1) {\n\t\tint i, j, k;\n\t\tint base_num, road_num, supply, dest1, dest2;\n\t\tint answer = INT_MAX;\n\t\tint cost[100][100];\n\n\t\tREAD2(base_num, road_num);\n\n\t\tREAD3(supply, dest1, dest2);\n\n\t\tif(base_num == 0) break;\n\n\t\tREP(i, base_num) {\n\t\t\tREP(j, base_num) {\n\t\t\t\tcost[i][j] = (INT_MAX - 1) / 3;\n\t\t\t}\n\t\t}\n\n\t\tREP(i, road_num) {\n\t\t\tint from, to, value;\n\n\t\t\tREAD3(from, to, value);\n\n\t\t\tcost[from-1][to-1] = value;\n\t\t}\n\n\t\twhile(1) {\n\t\t\tint flag = false;\n\n\t\t\tREP(i, base_num) {\n\t\t\t\tREP(j, base_num) {\n\t\t\t\t\tREP(k, base_num) {\n\t\t\t\t\t\tif(cost[i][j] + cost[j][k] < cost[i][k]) {\n\t\t\t\t\t\t\tcost[i][k] = cost[i][j] + cost[j][k];\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!flag) break;\n\t\t}\n\n\t\tREP(i, base_num) {\n\t\t\tif(cost[supply-1][i] + cost[i][dest1-1] + cost[i][dest2-1] < answer) {\n\t\t\t\tanswer = cost[supply-1][i] + cost[i][dest1-1] + cost[i][dest2-1];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", answer);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 2005: Water Pipe Construction\n// 2017.9.24 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define INF 0x7fffff\n\nint dist[102][102];\n\nint main()\n{\n\tint n, m, s, g1, g2, b1, b2, c, i, j, k, x, ans;\n\n\twhile (scanf(\"%d%d%d%d%d\", &n, &m, &s, &g1, &g2) && n > 0) {\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= n; j++) dist[i][j] = INF;\n\t\t\tdist[i][i] = 0;\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d%d\", &b1, &b2, &c);\n\t\t\tdist[b1][b2] = c;\n\t\t}\n        for (k = 1; k <= n; k++) for (i = 1; i <= n; i++) for (j = 1; j <= n; j++) {\n\t\t\tx = dist[i][k] + dist[k][j];\n\t        if (dist[i][j] > x) dist[i][j] = x;\n        }\n\t\tfor (ans = INF, i = 1; i <= n; i++) {\n\t\t\tif ((x = dist[s][i] + dist[i][g1] + dist[i][g2]) < ans) ans = x;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define minupd(v,x)((x)<v?v=(x):0)\nD[101][101],b1,b2,c,i,j,k,t,ans;\nmain(n,m,s,g1,g2){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2)*n;){\n\t\tmemset(D,1,sizeof(D));\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tD[b1][b2]=c;\n\t\t}\n\t\tfor(k=n;k;k--)\n\t\t\tfor(i=n;i;i--)\n\t\t\t\tfor(j=n;j;j--)\n\t\t\t\t\tminupd(D[i][j],D[i][k]+D[k][j]);\n\t\tans=1e9;\n\t\tfor(i=n;i;i--)\n\t\t\tminupd(ans,D[s][i]+D[i][g1]+D[i][g2]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#define minupd(v,x)((x)<v?v=(x):0)\nD[101][101],b1,b2,c,i,j,k,t,ans;\nmain(n,m,s,g1,g2){\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2)*n;){\n\t\tmemset(D,1,sizeof(D));\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d%d%d\",&b1,&b2,&c);\n\t\t\tD[b1][b2]=c;\n\t\t\tD[b1][b1]=0;\n\t\t}\n\t\tfor(k=n;k;k--)\n\t\t\tfor(i=n;i;i--)\n\t\t\t\tfor(j=n;j;j--)\n\t\t\t\t\tminupd(D[i][j],D[i][k]+D[k][j]);\n\t\tans=1e9;\n\t\tfor(i=n;i;i--)\n\t\t\tminupd(ans,D[s][i]+D[i][g1]+D[i][g2]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 200\n#define INF (1<<26)\n#define min(x,y) ((x)<(y)?(x):(y))\nint n,m,s,g1,g2,a,b,c;\nint t[MAX][MAX];\nvoid init(){\n    for(int i=0;i<MAX;i++){\n        for(int j=0;j<MAX;j++){\n            t[i][j]=(i==j?0:INF);\n        }\n    }\n}\nint main(void){\n    while(1){\n        scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2);\n        if(n==0) break;\n        s--,g1--,g2--;\n        init();\n        for(int i=0;i<m;i++){\n            scanf(\"%d%d%d\",&a,&b,&c);\n            a--,b--;\n            t[a][b]=c;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    t[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n                }\n            }\n        }\n        int ans=INF;\n        for(int i=0;i<n;i++)\n            ans=min(ans,t[s][i]+t[i][g1]+t[i][g2]);\n        printf(\"%d\\n\",ans);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 10000000\nvoid warshall_floyd(void);\nint min(int,int);\nint n,graph[101][101];\n\nint main(void){\n  int m,s,g1,g2,b1,b2,c,i,j,ans;\n  \n    while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2),n,m,s,g1,g2){\n      \n      for(i=0;i<=n;i++){\n\tfor(j=0;j<=n;j++){\n\t  graph[i][j]=INF;\n\t}\n\tgraph[i][i]=0;\n      }\n      \n      for(i=0;i<m;i++){\n\tscanf(\"%d %d %d\",&b1,&b2,&c);\n\tgraph[b1][b2]=c;\n      }\n\n      warshall_floyd();\n      for(i=0;i<=n;i++)\n\tans=min(ans,graph[s][i]+graph[i][g1]+graph[i][g2]);\n\n\tprintf(\"%d\\n\",ans);\n    }\n    \n    return 0;\n}\n\nvoid warshall_floyd(void){\n  int i,j,k;\n  for(k=0;k<=n;k++)\n    for(i=0;i<=n;i++)\n      for(j=0;j<=n;j++)\n\tgraph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n}\n\nint min(int x,int y){\n  return (x<y)?x:y;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 10000000\nint prim(void);\nint min(int,int);\nint n,graph[101][101],used[101],mincost[101];\n\nint main(void){\n  int m,s,g1,g2,b1,b2,c,i,j;\n  \n    while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&g1,&g2),n,m,s,g1,g2){\n      \n      for(i=0;i<=n;i++){\n\tfor(j=0;j<=n;j++){\n\t  graph[i][j]=INF;\n\t}\n\tused[i]=0;\n\tmincost[i]=INF;\n      }\n      \n      for(i=0;i<m;i++){\n\tscanf(\"%d %d %d\",&b1,&b2,&c);\n\tgraph[b1][b2]=c;\n      }\n\n      printf(\"%d\\n\",prim());\n    }\n    \n    return 0;\n}\n\nint prim(void){\n  int i,v,rev=0;\n  mincost[1]=0;\n  while(1){\n    v=-1;\n    for(i=1;i<=n;i++){\n      if(!used[i] && (v==-1 || mincost[i]<mincost[v]))v=i;\n    }\n    \n    if(v==-1)break;\n    used[v]=1;\n    rev+=mincost[v];\n\n    for(i=1;i<=n;i++){\n      mincost[i]=min(mincost[i],graph[v][i]);\n    }\n  }\n  return rev;\n}\n\nint min(int x,int y){\n  return (x<y)?x:y;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define M 1001\nint dist[M][M];\nint main(){\n\tint n,m,s,g1,g2,i,j,k,l;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n;){\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)dist[i][j]=(i!=j)*(1<<29);\n\t\tfor(i=0;i<m;i++)scanf(\"%d%d%d\",&j,&k,&l),dist[j][k]=l;\n\t\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++){\n\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])dist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\t\tfor(m=1<<29,i=1;i<=n;i++){\n\t\t\tif(m>dist[s][i]+dist[i][g1]+dist[i][g2])m=dist[s][i]+dist[i][g1]+dist[i][g2];\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,ta,tb,s,i,j,k,min,a,b,c;\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&ta,&tb),n){\n    int d[110][110]={0};\n    for(i=0;i<n*n;i++)min=d[i/n][i%n]=1000000000;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      d[a-1][b-1]=d[b-1][a-1]=c;\n      d[a-1][a-1]=d[b-1][b-1]=0;\n    }//printf(\"a\\n\");\n    for(k=0;k<n;k++){\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++)d[i][j]=MIN(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n    /*for(i=0;i<n;i++){\n      for(j=0;j<n;j++)printf(\"%2d \",d[i][j]);printf(\"\\n\");\n      }*/\n    for(i=0;i<n;i++)min=MIN(min,d[i][s-1]+d[i][ta-1]+d[i][tb-1]);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1010001000\n#define min(a, b) a<b?a:b\n \nint n, m, s, g1, g2;\nint gp[100][100];\n \nint main(void)\n{\n    int i, j, k, f, t, d;\n    scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    while (n) {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) {\n                gp[i][j] = INF;\n            }\n            gp[i][i] = 0;\n        }\n        for (i = 0; i < m; i++) {\n            scanf(\"%d %d %d\", &f, &t, &d);\n            gp[f-1][t-1] = d;\n        }\n        for (k = 0; k < n; k++) {\n            for (i = 0; i < n; i++) {\n                for (j = 0; j < n; j++) {\n                    gp[i][j] = min(gp[i][j], gp[i][k] + gp[k][j]);\n                }\n            }\n        }\n        int ans = INF;\n        for (k = 0; k < n; k++) {\n            ans = min(ans, gp[s-1][k] + gp[k][g1-1] + gp[k][g2-1]);\n        }\n        printf(\"%d\\n\", ans);\n        scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define M 1001\nint dist[M][M];\nint main(){\n\tint n,m,s,g1,g2,i,j,k,l;\n\tfor(;scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n;){\n\t\tfor(i=1;i<=n;i++)for(j=1;j<=n;j++)dist[i][j]=(i!=j)*(1<<29);\n\t\tfor(i=0;i<m;i++)scanf(\"%d%d%d\",&j,&k,&l),dist[j][k]=dist[k][j]=l;\n\t\tfor(k=1;k<=n;k++)for(i=1;i<=n;i++)for(j=1;j<=n;j++){\n\t\t\tif(dist[i][j]>dist[i][k]+dist[k][j])dist[i][j]=dist[i][k]+dist[k][j];\n\t\t}\n\t\tfor(m=1<<29,i=1;i<=n;i++){\n\t\t\tif(m>dist[s][i]+dist[i][g1]+dist[i][g2])m=dist[s][i]+dist[i][g1]+dist[i][g2];\n\t\t}\n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint ans;\nint sum;\nint n;\nint g1, g2;\nint dcost[100][100];\nvoid dfs(int);\n\n\nmain(){\n  int m, i, j, k, c, b1, b2, s;\n\n  while(1){\n    scanf(\"%d %d %d %d %d\", &n, &m, &s, &g1, &g2);\n    if(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n    s--;\n    g1--;\n    g2--;\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tif(i==j){\n\t  dcost[i][j]=0;\n\t  continue;\n\t}\n\tdcost[i][j]=2000000;\n      }\n    }\n\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\", &b1, &b2, &c);\n      b1--;\n      b2--;\n      dcost[b1][b2]=c;\n    }\n\t  \n    for(k=0;k<n;k++){\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++){\n\t  if(dcost[i][j]>(dcost[i][k]+dcost[k][j])){\n\t    dcost[i][j]=dcost[i][k]+dcost[k][j];\n\t  }\n\t}\n      }\n    }\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tprintf(\"%8d\", dcost[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    ans=2000000;\n    sum=0;\n    dfs(s);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n\nvoid dfs(int now){\n  int i;\n  int temp;\n  if(dcost[now][g1]!=0 && dcost[now][g1]!=2000000 && dcost[now][g2]!=0 && dcost[now][g2]!=2000000){\n    temp=sum+dcost[now][g1]+dcost[now][g2];\n    if(ans>temp) ans=temp;\n  }\n  for(i=0;i<n;i++){\n    if(dcost[now][i]!=0 && dcost[now][i]!=2000000){\n      sum+=dcost[now][i];\n      dfs(i);\n      sum-=dcost[now][i];\n    }\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,s,t,u,i,j,k,d[1010][1010];\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&t,&u),n){\n    for(i=0;i<1010*1010;i++)d[i/1010][i%1010]=1e8;\n    for(i=0;i<1010;i++)d[i][i]=0;\n    while(m--){\n      scanf(\"%d %d %d\",&i,&j,&k);\n      d[i][j]=k;\n    }\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n\tfor(k=1;k<=n;k++)d[j][k]=MIN(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n    j=1e9;\n    for(i=1;i<=n;i++)j=MIN(j,d[s][i]+d[i][t]+d[i][u]);\n    printf(\"%d\\n\",j);\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,s,t,u,i,j,k,d[1010][1010];\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&t,&u),n){\n    for(i=0;i<1010*1010;i++)d[i/1010][i%1010]=1e9;\n    for(i=0;i<1010;i++)d[i][i]=0;\n    while(m--){\n      scanf(\"%d %d %d\",&i,&j,&k);\n      d[i][j]=k;\n    }\n    for(i=1;i<=n;i++){\n      for(j=1;j<=n;j++){\n\tfor(k=1;k<=n;k++)d[j][k]=MIN(d[j][k],d[j][i]+d[i][k]);\n      }\n    }\n    j=1e9;\n    for(i=1;i<=n;i++)j=MIN(j,d[s][i]+d[i][t]+d[i][u]);\n    printf(\"%d\\n\",j);\n  }\n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<61)-(1LL<<31))\n#define min(p,q)((p)<(q)?(p):(q))\n\n//ワーシャルフロイド\n//頂点数（と隣接行列）を引いて全点間最短距離を返す\n//O(V^3)\n//*\nll cost[110][110];\nll dddd[110][110];\nvoid waasharuhuroido(ll n){\n\trep(i,0,n)rep(j,0,n)dddd[i][j]=cost[i][j];//辺が無いところはINFにする前処理が必要\n\trep(k,0,n)rep(i,0,n)rep(j,0,n)dddd[i][j]=min(dddd[i][j],dddd[i][k]+dddd[k][j]);\n}\n//*/\n\nint main(){\n\tint n,m,s,g1,g2;\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s,&g1,&g2),n){\n\t\ts--,g1--,g2--;\n\t\trep(i,0,n)rep(j,0,n)cost[i][j]=(i==j?0:INF);\n\t\trep(_,0,m){\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tx--,y--;\n\t\t\tcost[x][y]=z;\n\t\t}\n\t\twaasharuhuroido(n);\n\t\tll ans=INF;\n\t\trep(i,0,n)ans=min(ans,dddd[s][i]+dddd[i][g1]+dddd[i][g2]);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint zMIN(int a,int b){return a*b?MIN(a,b):a+b;}\nint main(){\n  int n,m,ta,tb,s,i,j,k,min,a,b,c;\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&ta,&tb),n){\n    int d[110][110]={0};\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      d[a][b]=d[b][a]=c;\n    }//printf(\"a\\n\");\n    for(k=0;k<n;k++){\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++)d[i][j]=zMIN(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n    for(i=min=0;i<n;i++)min=zMIN(min,d[i][s]+d[i][ta]+d[i][tb]);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,ta,tb,s,i,j,k,min,a,b,c;\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&ta,&tb),n){\n    int d[110][110]={0};\n    for(i=0;i<n*n;i++)min=d[i/n][i%n]=1000000000;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      d[a-1][b-1]=d[b-1][a-1]=c;\n    }//printf(\"a\\n\");\n    for(i=0;i<n;i++)d[i][i]=0;\n    for(k=0;k<n;k++){\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++)d[i][j]=MIN(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n    /*for(i=0;i<n;i++){\n      for(j=0;j<n;j++)printf(\"%2d \",d[i][j]);printf(\"\\n\");\n      }*/\n    for(i=0;i<n;i++)min=MIN(min,d[i][s-1]+d[i][ta-1]+d[i][tb-1]);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,ta,tb,s,i,j,k,min,a,b,c;\n  while(scanf(\"%d %d %d %d %d\",&n,&m,&s,&ta,&tb),n){\n    int d[110][110]={0};\n    for(i=0;i<110*110;i++)min=d[i/110][i%110]=100000000;\n    for(i=0;i<m;i++){\n      scanf(\"%d %d %d\",&a,&b,&c);\n      d[a-1][b-1]=d[b-1][a-1]=c;\n    }//printf(\"a\\n\");\n    for(i=0;i<n;i++)d[i][i]=0;\n    for(k=0;k<n;k++){\n      for(i=0;i<n;i++){\n\tfor(j=0;j<n;j++)d[i][j]=MIN(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n    /*for(i=0;i<n;i++){\n      for(j=0;j<n;j++)printf(\"%2d \",d[i][j]);printf(\"\\n\");\n      }*/\n    for(i=0;i<n;i++)min=MIN(min,d[i][s-1]+d[i][ta-1]+d[i][tb-1]);\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define REP(i, n) for((i) = 0; (i) < (n); (i)++)\n#define READ1(n1) scanf(\"%d\", &(n1))\n#define READ2(n1, n2) scanf(\"%d%d\", &(n1), &(n2))\n#define READ3(n1, n2, n3) scanf(\"%d%d%d\", &(n1), &(n2), &(n3))\n#define P1(n1) printf(\"%d\\n\", (n1))\n#define P2(n1, n2) printf(\"%d, %d\\n\", (n1), (n2))\n#define P3(n1, n2, n3) printf(\"%d, %d, %d\\n\", (n1), (n2), (n3))\n#define CLEAR(p) memset((p), 0, sizeof((p)))\nint main(void)\n{\n\twhile(1) {\n\t\tint i, j, k;\n\t\tint base_num, road_num, supply, dest1, dest2;\n\t\tint answer = INT_MAX;\n\t\tint cost[200][200];\n\n\t\tREAD2(base_num, road_num);\n\n\t\tREAD3(supply, dest1, dest2);\n\n\t\tif(base_num == 0) break;\n\n\t\tREP(i, base_num) {\n\t\t\tREP(j, base_num) {\n\t\t\t\tcost[i][j] = (INT_MAX - 1) / 3;\n\t\t\t}\n\t\t}\n\n\t\tREP(i, base_num) {\n\t\t\tcost[i][i] = 0;\n\t\t}\n\n\t\tREP(i, road_num) {\n\t\t\tint from, to, value;\n\n\t\t\tREAD3(from, to, value);\n\n\t\t\tcost[from-1][to-1] = value;\n\t\t}\n\n\t\twhile(1) {\n\t\t\tint flag = false;\n\n\t\t\tREP(i, base_num) {\n\t\t\t\tREP(j, base_num) {\n\t\t\t\t\tREP(k, base_num) {\n\t\t\t\t\t\tif(cost[i][j] + cost[j][k] < cost[i][k]) {\n\t\t\t\t\t\t\tcost[i][k] = cost[i][j] + cost[j][k];\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!flag) break;\n\t\t}\n\n\t\tREP(i, base_num) {\n\t\t\tif(cost[supply-1][i] + cost[i][dest1-1] + cost[i][dest2-1] < answer) {\n\t\t\t\tanswer = cost[supply-1][i] + cost[i][dest1-1] + cost[i][dest2-1];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", answer);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit{\n    while (true){\n        val (n, m, s, t1, t2) = readLine()!!.split(' ').map(String::toInt)\n        if (n == 0 && m == 0 && s == 0 && t1 == 0 && t2 == 0) break\n        val minCost = Array(n){from -> Array(n){to -> if (from == to) 0 else Int.MAX_VALUE.toLong()}}\n        repeat(m){\n            val (b1, b2, c) = readLine()!!.split(' ').map(String::toInt)\n            if (minCost[b1 - 1][b2 - 1] > c){\n                minCost[b1 - 1][b2 - 1] = c.toLong()\n            }\n        }\n        for (mid in 0 until n) for (from in 0 until n) for (to in 0 until n){\n            if (minCost[from][to] > minCost[from][mid] + minCost[mid][to])\n                minCost[from][to] = minCost[from][mid] + minCost[mid][to]\n        }\n        println((0 until n).map{mid ->\n            minCost[s - 1][mid] + minCost[mid][t1 - 1] + minCost[mid][t2 - 1]\n        }.min()!!)\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint s = 0;\n\t\tint g1 = 0;\n\t\tint g2 = 0;\n\n\t\tint last_cost = 100000;\n\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tm = scan.nextInt();\n\t\t\ts = scan.nextInt();\n\t\t\tg1 = scan.nextInt();\n\t\t\tg2 = scan.nextInt();\n\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint kithi1[] = new int[m];\n\t\t\tint kithi2[] = new int[m];\n\t\t\tint cost[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tkithi1[i] = scan.nextInt();\n\t\t\t\tkithi2[i] = scan.nextInt();\n\t\t\t\tcost[kithi1[i] - 1][kithi2[i] - 1] = scan.nextInt();\n\t\t\t\t//cost[kithi2[i] - 1][kithi1[i] - 1] = cost[kithi1[i] - 1][kithi2[i] - 1];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i!=j&&cost[i][j] == 0)\n\t\t\t\t\t\tcost[i][j] = 1000000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (last_cost > cost[s][i] + cost[i][g1]+cost[i][g2])\n\t\t\t\t\tlast_cost = cost[s][i] + cost[i][g1]+cost[i][g2];\n\t\t\t}\n\n\t\t\tSystem.out.println(last_cost);\n\t\t}\n\t\tscan.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tint s=in.nextInt(),g1=in.nextInt(),g2=in.nextInt();\n\t\t\tif((n|m|s|g1|g2)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tint war[][]=new int[n+1][n+1];\n\t\t\tint ans=M;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\t\tArrays.fill(war[i], M);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tcost[i][i]=0;\n\t\t\t\twar[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\tcost[in.nextInt()][in.nextInt()]=in.nextInt();\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\twar[i][j]=cost[i][j];\n\t\t\tfor (int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=war[j][i]+war[i][k];\n\t\t\t\t\t\twar[j][k]=Math.min(war[j][k],c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tans=Math.min(ans, war[s][i]+war[i][g1]+war[i][g2]);\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g1 = in.nextInt()-1;\n\t\t\tint g2 = in.nextInt()-1;\n\t\t\tif(n == 0) break;\n\t\t\tint[][] edge = new int[n][n];\n//\t\t\tint[][] root = new int[n][n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n//\t\t\t\t\troot[i][j] = i;\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tedge[i][j] = Integer.MAX_VALUE/2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint b1 = in.nextInt()-1;\n\t\t\t\tint b2 = in.nextInt()-1;\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tedge[b1][b2] = c;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\t\tif(edge[j][k] > edge[j][i]+edge[i][k]){\n\t\t\t\t\t\t\tedge[j][k] = edge[j][i] + edge[i][k];\n//\t\t\t\t\t\t\troot[j][k] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = edge[s][g1] + edge[s][g2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tres = Math.min(res, edge[s][i]+edge[i][g1]+edge[i][g2]);\n\t\t\t}\n//\t\t\tLinkedList<Integer> list = rooting(root, s, g1);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g1] + edge[i][g2]);\n//\t\t\t}\n\t\t\t\n//\t\t\tlist = rooting(root, s, g2);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g2] + edge[i][g1]);\n//\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static LinkedList<Integer> rooting(\n\t\t\tint[][] root, int s, int t){\n\t\tLinkedList<Integer> res = new LinkedList<Integer>();\n\t\trefound(root, s, t, res);\n\t\treturn res;\n\t}\n\t\n\tpublic static void refound(\n\t\t\tint[][] root, int s, int t\n\t\t\t, LinkedList<Integer> res){\n\t\tint center = root[s][t];\n\t\tif(s == center){\n\t\t\tres.add(t);\n\t\t\treturn;\n\t\t}\n\t\trefound(root, s, center, res);\n\t\trefound(root, center, t, res);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], INF);\n\t\t\t\tmap[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tout.println(Arrays.toString(map[i]));\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class WaterPipeConstruction {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\tstreet[y][x] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tstreet[i][i] = 0;\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 1; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint route[] = new int[3];\n\t\t\troute[0] = street[g2][g1];\n\t\t\troute[1] = street[s][g1];\n\t\t\troute[2] = street[s][g2];\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tif(i != 1 && 2 != 0){\n\t\t\t\t\t\tsum = Math.min(sum, route[i] + route[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings({ \"unused\", \"unchecked\" })\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint g1 = scanner.nextInt();\n\t\t\tint g2 = scanner.nextInt();\n\t\t\tif ((n | m | s | g1 | g2) == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tg[i][j] = i == j ? 0 : INF;\n\n\t\t\tList<Pair>[] slist = new List[n];\n\t\t\tList<Pair>[] glist = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tslist[i] = new ArrayList<Main.Pair>();\n\t\t\t\tglist[i] = new ArrayList<Main.Pair>();\n\t\t\t}\n\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint b1 = scanner.nextInt() - 1;\n\t\t\t\tint b2 = scanner.nextInt() - 1;\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tslist[b1].add(new Pair(b2, c));\n\t\t\t\tglist[b2].add(new Pair(b1, c));\n\t\t\t}\n\t\t\tint[] acost = slove(s, slist);\n\t\t\tint[] bcost = slove(g1, glist);\n\t\t\tint[] ccost = slove(g2, glist);\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans = Math.min(ans, acost[i] + bcost[i] + ccost[i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int[] slove(int s, List<Pair>[] lists) {\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tpq.offer(new Pair(s, 0));\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, INF);\n\t\tdp[s] = 0;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.poll();\n\t\t\tif (dp[p.d] < p.cost)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair pair : lists[p.d]) {\n\t\t\t\tint ncost = p.cost+pair.cost;\n\t\t\t\tif(dp[pair.d]<=ncost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[pair.d] = ncost;\n\t\t\t\tpq.offer(new Pair(pair.d, ncost));\n\t\t\t}\n\t\t}\n\t\treturn dp;\n\t}\n\n\tint INF = 1 << 29;\n\tint n;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint d, cost;\n\n\t\tpublic Pair(int d, int cost) {\n\t\t\tsuper();\n\t\t\tthis.d = d;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [d=\" + d + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Water {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=10000;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic int[][] d;\n\tstatic final int INF = Integer.MAX_VALUE/2;\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\t\twhile(true){\n\t\t\tint n = si(),m = si(),s = si()-1,g1 = si()-1,g2 = si()-1;\n\t\t\tif(n==0) break;\n\t\t\td = new int[n][n];\n\t\t\tfor (int i = 0; i < n ; i++) for (int j = 0; j < n ; j++) d[i][j] = i==j ? 0 : INF;\n\t\t\tfor (int i = 0; i < m; i++) d[si()-1][si()-1]=si();\n\t\t\twarshallFloyd(n);\n\t\t\tint mincost = INF;\n\t\t\tfor (int i = 0; i < n; i++) mincost = min(d[s][i]+d[i][g1]+d[i][g2],mincost);\n\t\t\tout.println(mincost);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic void warshallFloyd(int n){\n\t\tfor (int i = 0; i < n ; i++) {\n\t\t\tfor (int j = 0; j < n ; j++) {\n\t\t\t\tfor (int j2 = 0; j2 < n; j2++) {\n\t\t\t\t\td[j][j2] = min(d[j][j2],d[j][i]+d[i][j2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int si() {\n\t\treturn Integer.parseInt(scan.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tint s=in.nextInt(),g1=in.nextInt(),g2=in.nextInt();\n\t\t\tif((n|m|s|g1|g2)==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tint war[][]=new int[n+1][n+1];\n\t\t\tint ans=M;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\t\tArrays.fill(war[i], M);\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tcost[i][i]=0;\n\t\t\t\twar[i][i]=0;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\tcost[in.nextInt()][in.nextInt()]=in.nextInt();\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\twar[i][j]=cost[i][j];\n\t\t\tfor (int i=0;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//j->kへ行くのにiを経由した方が良いかどうか\n\t\t\t\t\t\tint c=war[j][i]+war[i][k];\n\t\t\t\t\t\tif (c<war[j][k]) \n\t\t\t\t\t\t\twar[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\tans=Math.min(ans, war[s][i]+war[i][g1]+war[i][g2]);\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tpublic static int[][][] directedGraph(int n, int[] s, int[] t, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : s) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<s.length; i++) {\n\t\t\tint from = s[i];\n\t\t\tint to = t[i];\n\n\t\t\tg[from][--cnt[from]][0] = to;\n\t\t\tg[from][cnt[from]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tpublic static int[] dijkstra(int[][][] g, int source) {\n\t\tint n = g.length;\n\n\t\tfinal int[] d = new int[n];\n\t\tArrays.fill(d, Integer.MAX_VALUE/2);\n\t\td[source] = 0;\n\n\t\tTreeSet<Integer> pQ = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (d[a] != d[b]) return d[a] - d[b];\n\t\t\t\treturn a - b;\n\t\t\t}\n\t\t});\n\t\tpQ.add(source);\n\n\t\twhile (!pQ.isEmpty()) {\n\t\t\tint cur = pQ.pollFirst();\n\n\t\t\tfor (int i=0; i<g[cur].length; i++) {\n\t\t\t\tint next = g[cur][i][0];\n\t\t\t\tint dist = d[cur] + g[cur][i][1];\n\t\t\t\tif (dist < d[next]) {\n\t\t\t\t\tpQ.remove(next);\n\t\t\t\t\td[next] = dist;\n\t\t\t\t\tpQ.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tstatic boolean solve() {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint s = in.nextInt() - 1;\n\t\tint g1 = in.nextInt() - 1;\n\t\tint g2 = in.nextInt() - 1;\n\t\tif (n + m == 0) return false;\n\n\t\tint[] v1 = new int[m];\n\t\tint[] v2 = new int[m];\n\t\tint[] c = new int[m];\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tv1[i] = in.nextInt() - 1;\n\t\t\tv2[i] = in.nextInt() - 1;\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\n\t\tint[][][] g = directedGraph(n, v1, v2, c);\n\t\tint[] ds = dijkstra(g, s);\n\n\t\tint ans = ds[g1] + ds[g2];\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (i == s) continue;\n\t\t\tint[] d = dijkstra(g, i);\n\t\t\tans = Math.min(ans, ds[i] + d[g1] + d[g2]);\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\tdump((end-start) + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tint s=in.nextInt(),g1=in.nextInt(),g2=in.nextInt();\n\t\t\tif((n|m|s|g1|g2)==0)\n\t\t\t\treturn;\n\t\t\tint war[][]=new int[n+1][n+1];\n\t\t\tint ans=M;\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(war[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\twar[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\twar[in.nextInt()][in.nextInt()]=in.nextInt();\n\t\t\t\n\t\t\t//ワーシャルフロイド j->kと行くのにiを通った方が良いか\n\t\t\tfor (int i=0;i<=n;i++)\n\t\t\t\tfor(int j=0;j<=n;j++)\n\t\t\t\t\tfor(int k=0;k<=n;k++)\t\t\t\t\t\t\n\t\t\t\t\t\twar[j][k]=Math.min(war[j][k], war[j][i]+war[i][k]);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tans=Math.min(ans, war[s][i]+war[i][g1]+war[i][g2]);\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g1 = in.nextInt()-1;\n\t\t\tint g2 = in.nextInt()-1;\n\t\t\tif(n == 0) break;\n\t\t\tint[][] edge = new int[n][n];\n//\t\t\tint[][] root = new int[n][n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n//\t\t\t\t\troot[i][j] = i;\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tedge[i][j] = 1000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint b1 = in.nextInt()-1;\n\t\t\t\tint b2 = in.nextInt()-1;\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tedge[b1][b2] = c;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\t\tif(edge[j][k] > edge[j][i]+edge[i][k]){\n\t\t\t\t\t\t\tedge[j][k] = edge[j][i] + edge[i][k];\n//\t\t\t\t\t\t\troot[j][k] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = edge[s][g1] + edge[s][g2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tres = Math.min(res, edge[s][i]+edge[i][g1]+edge[i][g2]);\n\t\t\t}\n//\t\t\tLinkedList<Integer> list = rooting(root, s, g1);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g1] + edge[i][g2]);\n//\t\t\t}\n\t\t\t\n//\t\t\tlist = rooting(root, s, g2);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g2] + edge[i][g1]);\n//\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static LinkedList<Integer> rooting(\n\t\t\tint[][] root, int s, int t){\n\t\tLinkedList<Integer> res = new LinkedList<Integer>();\n\t\trefound(root, s, t, res);\n\t\treturn res;\n\t}\n\t\n\tpublic static void refound(\n\t\t\tint[][] root, int s, int t\n\t\t\t, LinkedList<Integer> res){\n\t\tint center = root[s][t];\n\t\tif(s == center){\n\t\t\tres.add(t);\n\t\t\treturn;\n\t\t}\n\t\trefound(root, s, center, res);\n\t\trefound(root, center, t, res);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tint d(int n,int m,int s,int g1,int g2){\n    \t\tint cost[][] = new int [n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tif(i == j)continue;\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE/4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tint st = sc.nextInt()-1;\n\t\t\t\tint et = sc.nextInt()-1;\n\t\t\t\tint co = sc.nextInt();\n\t\t\t\tcost[st][et] = co;\n\t\t\t}\n\t\t\tfor(int i=0; i<n;i++){\n\t\t\t\tfor(int j=0; j<n;j++){\n\t\t\t\t\tfor(int k=0; k<n;k++){\n\t\t\t\t\t\tcost[j][k]=Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            int ans = Integer.MAX_VALUE/4;\n//            for(int i = 0;i < n;i++){\n//            \tfor(int j = 0;j < n;j++){\n//            \t\tSystem.out.print(cost[i][j]+\" \");\n//            \t}\n//            \tSystem.out.println();\n//            }\n            for(int i=0; i<n;i++)ans=Math.min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t\treturn ans;\n\t\t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tint m = sc.nextInt();\n    \t\t\tint s = sc.nextInt();\n    \t\t\tint g1 = sc.nextInt();\n    \t\t\tint g2 = sc.nextInt();\n    \t\t\tif(n+m+s+g1+g2 == 0)break;\n    \t\t\tSystem.out.println(d(n,m,s-1,g1-1,g2-1));\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] table = new int[n][n];\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\tint min = 1000000;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt();\n\t\t\t\tint b2 = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\t\ttable[i][j] = 10000;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ttable[i][i] = 0;\n\t\t\tfor (int k = 0; k < n - 1; k++)\n\t\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint s = 0;\n\t\tint g1 = 0;\n\t\tint g2 = 0;\n\n\t\tint last_cost = 100000;\n\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tm = scan.nextInt();\n\t\t\ts = scan.nextInt();\n\t\t\tg1 = scan.nextInt();\n\t\t\tg2 = scan.nextInt();\n\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint kithi1[] = new int[m];\n\t\t\tint kithi2[] = new int[m];\n\t\t\tint cost[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tkithi1[i] = scan.nextInt();\n\t\t\t\tkithi2[i] = scan.nextInt();\n\t\t\t\tcost[kithi1[i] - 1][kithi2[i] - 1] = scan.nextInt();\n\t\t\t\tcost[kithi2[i] - 1][kithi1[i] - 1] = cost[kithi1[i] - 1][kithi2[i] - 1];\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i!=j&&cost[i][j] == 0)\n\t\t\t\t\t\tcost[i][j] = 1000000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (last_cost > cost[s][i] + cost[i][g1]+cost[i][g2])\n\t\t\t\t\tlast_cost = cost[s][i] + cost[i][g1]+cost[i][g2];\n\t\t\t}\n\n\t\t\tSystem.out.println(last_cost);\n\t\t}\n\t\tscan.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic int[][] d;\n\tstatic final int INF = 1 << 24;\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\t\twhile(true){\n\t\t\tint n = si(),m = si(),s = si()-1,g1 = si()-1,g2 = si()-1;\n\t\t\tif(n==0) break;\n\t\t\td = new int[n][n];\n\t\t\tfor (int i = 0; i < n ; i++) for (int j = 0; j < n ; j++) d[i][j] = i==j ? 0 : INF;\n\t\t\tfor (int i = 0; i < m; i++) d[si()-1][si()-1]=si();\n\t\t\twarshallFloyd(n);\n\t\t\tint mincost = INF;\n\t\t\tfor (int i = 0; i < n; i++) mincost = min(d[s][i]+d[i][g1]+d[i][g2],mincost);\n\t\t\tout.println(mincost);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic void warshallFloyd(int n){\n\t\tfor (int i = 0; i < n ; i++) {\n\t\t\tfor (int j = 0; j < n ; j++) {\n\t\t\t\tfor (int j2 = 0; j2 < n; j2++) {\n\t\t\t\t\td[j][j2] = min(d[j][j2],d[j][i]+d[i][j2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int si() {\n\t\treturn Integer.parseInt(scan.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t\tif(i==j){\n\t\t\t\t\troad[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=road[0][s-1]+road[0][g1-1]+road[0][g2-1];\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\tstreet[y][x] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tstreet[i][i] = 0;\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 1; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint route[] = new int[3];\n\t\t\troute[0] = street[g2][g1];\n\t\t\troute[1] = street[s][g1];\n\t\t\troute[2] = street[s][g2];\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tsum = Math.min(sum, route[i] + route[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic int[][] d;\n\tstatic final int INF = 1 << 24;\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\t\twhile(true){\n\t\t\tint n = si(),m = si(),s = si()-1,g1 = si()-1,g2 = si()-1;\n\t\t\tif(n==0) break;\n\t\t\td = new int[n][n];\n\t\t\tfor (int i = 0; i < n ; i++) for (int j = 0; j < n ; j++) d[i][j] = i==j ? 0 : INF;\n\t\t\twhile(m-->0) d[si()-1][si()-1]=si();\n\t\t\twarshallFloyd(n);\n\t\t\tint mincost = INF;\n\t\t\twhile(--n>=0) mincost = min(d[s][n]+d[n][g1]+d[n][g2],mincost);\n\t\t\tout.println(mincost);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic void warshallFloyd(int n){\n\t\tfor (int i = 0; i < n ; i++)\n\t\t\tfor (int j = 0; j < n ; j++)\n\t\t\t\tfor (int j2 = 0; j2 < n; j2++)\n\t\t\t\t\td[j][j2] = min(d[j][j2],d[j][i]+d[i][j2]);\n\n\t}\n\n\tstatic int si() {\n\t\treturn Integer.parseInt(scan.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) Arrays.fill(map[i], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n\n    static int[][] d;\n\n    public static void main(String[] args) {\n        while (true){\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int g1 = sc.nextInt();\n            int g2 = sc.nextInt();\n            if(n==0) break;\n\n            d= new int[n+1][n+1];\n\n            scanLoad(m);\n            warshallFloyd(n);\n            calcCost(n,s,g1,g2);\n\n        }\n\n\n    }\n\n    static void warshallFloyd(int n) { // nは頂点数\n        for (int i = 1; i <= n; i++)      // 経由する頂点\n            for (int j = 1; j <= n; j++)    // 開始頂点\n                for (int k = 1; k <= n; k++)  // 終端\n                    d[j][k] = Math.min(d[j][k], d[j][i] + d[i][k]);\n    }\n\n    static void scanLoad(int m){\n        for(int i=0;i<m;i++){\n            int b1 = sc.nextInt();\n            int b2 = sc.nextInt();\n            int c = sc.nextInt();\n\n            d[b1][b2]=c;\n        }\n    }\n    static void calcCost(int n,int s,int g1,int g2){\n        int min=1000;\n        for(int i=1;i<=n;i++){\n            if((s != i && d[s][i]==0) || (g1 != i && d[i][g1]==0) || (g2 != i && d[i][g2]==0))\n                continue;\n            min=Math.min(min,d[s][i]+d[i][g1]+d[i][g2]);\n        }\n        System.out.println(min);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\tstreet[y][x] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tstreet[i][i] = 0;\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 1; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint route[] = new int[3];\n\t\t\troute[0] = street[g2][g1];\n\t\t\troute[1] = street[s][g1];\n\t\t\troute[2] = street[s][g2];\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tif(i != 1 && 2 != 0){\n\t\t\t\t\t\tsum = Math.min(sum, route[i] + route[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint s = 0;\n\t\tint g1 = 0;\n\t\tint g2 = 0;\n\n\t\tint last_cost = Integer.MAX_VALUE/10;\n\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tm = scan.nextInt();\n\t\t\ts = scan.nextInt();\n\t\t\tg1 = scan.nextInt();\n\t\t\tg2 = scan.nextInt();\n\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint kithi1[] = new int[m];\n\t\t\tint kithi2[] = new int[m];\n\t\t\tint cost[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i!=j)\n\t\t\t\t\t\tcost[i][j] = 1000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tkithi1[i] = scan.nextInt();\n\t\t\t\tkithi2[i] = scan.nextInt();\n\t\t\t\tcost[kithi1[i] - 1][kithi2[i] - 1] = scan.nextInt();\n\t\t\t\t//cost[kithi2[i] - 1][kithi1[i] - 1] = cost[kithi1[i] - 1][kithi2[i] - 1];\n\t\t\t}\n\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (last_cost > cost[s][i] + cost[i][g1]+cost[i][g2])\n\t\t\t\t\tlast_cost = cost[s][i] + cost[i][g1]+cost[i][g2];\n\t\t\t}\n\n\t\t\tSystem.out.println(last_cost);\n\t\t}\n\t\tscan.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) Arrays.fill(map[i], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int times = 0; times < n; times++)\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=1000000;\n\t\t\t\tif(i==j){\n\t\t\t\t\troad[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\tint i,j,cost;\n\t\twhile(num<m){\n\t\t\ti=sc.nextInt();\n\t\t\tj=sc.nextInt();\n\t\t\tcost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=1000000;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[s-1][k]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[s-1][k]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int n,m,s,g1,g2;\n    int[][] d;\n    int INF = 700000000;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    n = sc.nextInt();\n\t    m = sc.nextInt();\n\t    s = sc.nextInt();\n\t    g1 = sc.nextInt();\n\t    g2 = sc.nextInt();\n\t    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\n\t    d = new int[m+1][m+1];\n\t    for(int i=0; i<=m; i++) Arrays.fill(d[i],INF);\n\t    for(int i=0; i<m; i++){\n\t\tint b1 = sc.nextInt();\n\t\tint b2 = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\td[b1][b2] = c;\n\t    }\n\t    for(int i=0; i<=m; i++) d[i][i] = 0;\n\n\t    warshall_floyd();\n\n\t    int min = INF;\n\t    for(int i=1; i<=m; i++){\n\t\tmin = Math.min(min,d[s][i]+d[i][g1]+d[i][g2]);\n\t    }\n\t    System.out.println(min);\n\t}\n    }\n    \n    void warshall_floyd(){\n\tfor(int k=1; k<=m; k++)\n\t    for(int i=1; i<=m; i++)\n\t\tfor(int j=1; j<=m; j++)d[i][j] = Math.min(d[i][j],d[i][k]+d[k][j]);\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAX = Integer.MAX_VALUE/10;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\tint V = in.nextInt();\n\t\tif(V==0) break;\n\t\tint E = in.nextInt();\n\t\tint s = in.nextInt()-1;\n\t\tint g1 = in.nextInt()-1;\n\t\tint g2 = in.nextInt()-1;\n\t\tint[][] road = new int[V][V];\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\troad[i][j] = (i==j)?0:MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\troad[a][b] = c;\n\t\t\troad[b][a] = c;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int k=0;k<V;k++){\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\t\troad[i][j] = Math.min(road[i][j],road[i][k]+road[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tans = Math.min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n\t\t\tSystem.out.println(i +\":\"+ans);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2005();\n\t}\n\t\n\tfinal int INF=Integer.MAX_VALUE/4;\n\t\n\tclass AOJ2005{\n\t\tAOJ2005(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt(),m=sc.nextInt(),s=sc.nextInt(),g1=sc.nextInt(),g2=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\t--s; --g1; --g2;\n\t\t\t\tsolve(n,m,s,g1,g2);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int n,int m,int s,int g1,int g2){\n\t\t\tint[][] g=new int[n][n];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)\tg[i][j]=INF;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();\n\t\t\t\t--a;\t--b;\n\t\t\t\tg[a][b]=c;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashSet<String>> c1=new ArrayList<HashSet<String>>(n);\n\t\t\tfor(int i=0; i<n; ++i)\tc1.add(new HashSet<String>());\n\t\t\t\n\t\t\tLinkedList<S1> o1=new LinkedList<S1>();\n\t\t\to1.add(new S1(s,new String()));\n\t\t\t\n\t\t\twhile(!o1.isEmpty()){\n\t\t\t\tS1 now=o1.poll();\n\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\tif(now.p==i || g[now.p][i]>=INF)\tcontinue;\n\t\t\t\t\tString tmp=now.s+i;\n\t\t\t\t\tif(!c1.get(i).contains(tmp)){\n\t\t\t\t\t\to1.add(new S1(i,tmp));\n\t\t\t\t\t\tc1.get(i).add(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<String> cand=c1.get(g1);\n\t\t\tint ans=INF;\n\t\t\tfor(String str:cand){\n\t\t\t\t\n\t\t\t\tint[][] gg=new int[n][n];\n\t\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)gg[i][j]=g[i][j];\n\t\t\t\t\n\t\t\t\tint prev=s,cost1=0;\n\t\t\t\tfor(int i=0; i<str.length(); ++i){\n\t\t\t\t\tcost1+=gg[prev][str.charAt(i)-'0'];\n\t\t\t\t\tgg[prev][str.charAt(i)-'0']=0;\n\t\t\t\t\tprev=str.charAt(i)-'0';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPriorityQueue<S2> o2=new PriorityQueue<S2>();\n\t\t\t\to2.add(new S2(s,0));\n\t\t\t\tint[] c2=new int[n];\n\t\t\t\tfor(int i=0; i<n; ++i)c2[i]=INF;\n\t\t\t\t\n\t\t\t\tint cost2=0;\n\t\t\t\twhile(!o2.isEmpty()){\n\t\t\t\t\tS2 now=o2.poll();\n\t\t\t\t\tif(now.p==g2){\n//\t\t\t\t\t\tSystem.out.println(\"G2\");\n\t\t\t\t\t\tcost2=now.c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\tif(now.p==i || gg[now.p][i]>=INF)\tcontinue;\n\t\t\t\t\t\tint nc=now.c+gg[now.p][i];\n\t\t\t\t\t\tif(c2[i]<=nc)\tcontinue;\n\t\t\t\t\t\to2.add(new S2(i, nc));\n\t\t\t\t\t\tc2[i]=nc;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tSystem.out.println(cost1+\" \"+cost2);\n\t\t\t\tans=min(ans,cost1+cost2);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t\tclass E{\n\t\t\tint d,c;\n\t\t\tE(int d,int c){\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t}\n\t\tclass S1{\n\t\t\tint p;\n\t\t\tString s;\n\t\t\tS1(int p,String s){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.s=s;\n\t\t\t}\n\t\t}\n\t\tclass S2 implements Comparable<S2>{\n\t\t\tint p,c;\n\t\t\tS2(int p,int c){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(S2 o){\n\t\t\t\treturn this.c-o.c;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Water Pipe Construction\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[][] cost = new int[n+1][n+1];\n\t\t\tfor(int[]c:cost)Arrays.fill(c, Integer.MAX_VALUE);\n\t\t\twhile(m--!=0){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tcost[a][b]=sc.nextInt();\n\t\t\t}\n\t\t\tint[][] wf = new int[n+1][n+1];\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\twf[i][j] = cost[i][j];\n\t\t\tfor(int i=1;i<=n;i++)wf[i][i]=0;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\t\tif(wf[i][k]!=Integer.MAX_VALUE && wf[k][j]!=Integer.MAX_VALUE)\n\t\t\t\t\t\t\twf[i][j] = Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(wf[s][k]!=Integer.MAX_VALUE && wf[k][g1]!=Integer.MAX_VALUE && wf[k][g2]!=Integer.MAX_VALUE){\n\t\t\t\t\tmin = Math.min(min, wf[s][k]+wf[k][g1]+wf[k][g2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt() - 1;\n\t\t\tfinal int g1 = sc.nextInt() - 1;\n\t\t\tfinal int g2 = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == -1 && g1 == -1 && g2 == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint[][] adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(i != j){\n\t\t\t\t\t\tadj[i][j] = Integer.MAX_VALUE / 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int b1 = sc.nextInt() - 1;\n\t\t\t\tfinal int b2 = sc.nextInt() - 1;\n\t\t\t\tfinal int c = sc.nextInt();\n\t\t\t\t\n\t\t\t\tadj[b1][b2] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tadj[i][j] = Math.min(adj[i][j], adj[i][k] + adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfinal int s_cost = adj[s][k];\n\t\t\t\tfinal int g1_cost = adj[k][g1];\n\t\t\t\tfinal int g2_cost = adj[k][g2];\n\t\t\t\t\n\t\t\t\tmin = Math.min(min, s_cost + g1_cost + g2_cost);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt(), s=sc.nextInt(), g1=sc.nextInt(), g2=sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tint[][] map = new int[n+1][n+1];\n\t\t\twhile(m-- > 0){\n\t\t\t\tmap[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tint c1=minCost(i,g1,map);\n\t\t\t\tint c2=minCost(i,g2,map);\n\t\t\t\tint c3=minCost(s,i,map);\n\n\t\t\t\tif(c1==-1 || c2==-1 || c3==-1) continue;\n\t\t\t\tmin = Math.min(min, c1+c2+c3);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static int minCost(int s,int g,int[][] map){\n\t\tQueue<State> open = new PriorityQueue<State>();\n\t\tSet<State> closed = new HashSet<State>();\n\n\t\tState st = null, ans = null;\n\t\topen.add(new State(0,s));\n\t\twhile(!open.isEmpty()){\n\t\t\tst = open.poll();\n\t\t\tif(closed.contains(st)) continue;\n\t\t\tclosed.add(st);\n\t\t\tif(st.n == g){\n\t\t\t\tans = st;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topen.addAll(st.nexts(map));\n\t\t}\n\n\t\tif(ans == null) return -1;\n\t\treturn ans.cost;\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint cost,n;\n\n\tState(int cost, int n){\n\t\tthis.cost = cost;\n\t\tthis.n = n;\n\t}\n\n\tList<State> nexts(int[][] map){\n\t\tList<State> sts = new ArrayList<State>();\n\n\t\tfor(int i=1;i<map.length;i++){\n\t\t\tif(n == i) continue;\n\t\t\tif(map[n][i] > 0) sts.add(new State(cost+map[n][i],i));\n\t\t}\n\n\t\treturn sts;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn this.n == st.n;\n\t}\n\n\tpublic int hashCode(){\n\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt(), s=sc.nextInt(), g1=sc.nextInt(), g2=sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tint[][] map = new int[n+1][n+1];\n\t\t\twhile(m-- > 0){\n\t\t\t\tmap[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tint c1=minCost(i,g1,map);\n\t\t\t\tint c2=minCost(i,g2,map);\n\t\t\t\tint c3=minCost(s,i,map);\n\n\t\t\t\tif(c1==-1 || c2==-1 || c3==-1) continue;\n\t\t\t\tmin = Math.min(min, c1+c2+c3);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static int minCost(int s,int g,int[][] map){\n\t\tQueue<State> open = new PriorityQueue<State>();\n\t\tSet<State> closed = new HashSet<State>();\n\n\t\tState st = null, ans = null;\n\t\topen.add(new State(0,s));\n\t\twhile(!open.isEmpty()){\n\t\t\tst = open.poll();\n\t\t\tif(closed.contains(st)) continue;\n\t\t\tif(st.n == g){\n\t\t\t\tans = st;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\topen.addAll(st.nexts(map));\n\t\t}\n\n\t\tif(ans == null) return -1;\n\t\treturn ans.cost;\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint cost,n;\n\n\tState(int cost, int n){\n\t\tthis.cost = cost;\n\t\tthis.n = n;\n\t}\n\n\tList<State> nexts(int[][] map){\n\t\tList<State> sts = new ArrayList<State>();\n\n\t\tfor(int i=1;i<map.length;i++){\n\t\t\tif(n == i) continue;\n\t\t\tif(map[n][i] > 0) sts.add(new State(cost+map[n][i],i));\n\t\t}\n\n\t\treturn sts;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn this.cost - st.cost;\n\t}\n\n\tpublic boolean equals(Object o){\n\t\tState st = (State)o;\n\t\treturn this.n == st.n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint start = sc.nextInt();\n\t\t\tstart = start - 1;\n\t\t\tint goal1 = sc.nextInt();\n\t\t\tgoal1 = goal1 - 1;\n\t\t\tint goal2 = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tgoal2 = goal2 - 1;\n\t\t\tint road[][] = new int[N][N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\troad[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint j = sc.nextInt();\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\troad[j - 1][k - 1] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\troad[i][i] = 0;\n\t\t\t}\n\n\t\t\t// この三重ループでできる\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\t\tint num = road[i][k] + road[k][j];\n\t\t\t\t\t\troad[i][j] = min(road[i][j], num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = 0;\n\t\t\tmin = road[start][goal1] + road[start][goal2];\n\t\t\tint min_road = min(road[start][goal1] + road[goal1][goal2],\n\t\t\t\t\troad[start][goal2] + road[goal2][goal1]);\n\t\t\tif (min > min_road)\n\t\t\t\tmin = min_road;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tmin_road = road[start][i] + road[i][goal1] + road[i][goal2];\n\t\t\t\tif (min > min_road)\n\t\t\t\t\tmin = min_road;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tprivate static int min(int i, int j) {\n\t\tif (i < j)\n\t\t\treturn i;\n\t\telse\n\t\t\treturn j;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=road[0][s-1]+road[0][g1-1]+road[0][g2-1];\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\t\t\t\n\t\t\tint[][] cost = new int[n+1][n+1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++) cost[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n\t\t\tfor(int i=1;i<=n;i++) cost[i][i] = 0;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\t\tif(cost[j][i]!=Integer.MAX_VALUE && cost[i][k]!=Integer.MAX_VALUE){\n\t\t\t\t\t\t\tcost[j][k] = Math.min(cost[j][k], cost[j][i]+cost[i][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(cost[s][i]!=Integer.MAX_VALUE && cost[i][g1]!=Integer.MAX_VALUE && cost[i][g2]!=Integer.MAX_VALUE){\n\t\t\t\t\tmin = Math.min(min, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAX = 10000;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\tint V = in.nextInt();\n\t\tif(V==0) break;\n\t\tint E = in.nextInt();\n\t\tint s = in.nextInt()-1;\n\t\tint g1 = in.nextInt()-1;\n\t\tint g2 = in.nextInt()-1;\n\t\tint[][] road = new int[V][V];\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\troad[i][j] = (i==j)?0:MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\troad[a][b] = c;\n\t\t\troad[b][a] = c;\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tfor(int k=0;k<V;k++){\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\t\troad[i][j] = Math.min(road[i][j],road[i][k]+road[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tans = Math.min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n\t\t\t//System.out.println(i +\":\"+ans);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tint S = sc.nextInt() - 1;\n\t\t\tint G1 = sc.nextInt() - 1;\n\t\t\tint G2 = sc.nextInt() - 1;\n\t\t\tint[][] dist = new int[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tArrays.fill(dist[i], 1 << 25);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint A = sc.nextInt() - 1;\n\t\t\t\tint B = sc.nextInt() - 1;\n\t\t\t\tint C = sc.nextInt();\n\t\t\t\tdist[A][B] = C;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tdist[j][k] = Math.min(dist[j][k], dist[j][i] + dist[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 1 << 30;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tans = Math.min(ans, dist[S][i] + dist[i][G1] + dist[i][G2]);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\tstreet[y][x] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tstreet[i][i] = 0;\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 1; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tsum = Math.min(sum , street[s][i] + street[i][g1] + street[i][g2]);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint start = sc.nextInt();\n\t\tstart = start - 1;\n\t\tint goal1 = sc.nextInt();\n\t\tgoal1 = goal1 - 1;\n\t\tint goal2 = sc.nextInt();\n\t\tgoal2 = goal2 - 1;\n\t\tint road[][] = new int[N][N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\troad[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m;i++)\n\t\t{\n\t\t\tint j = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\troad[j-1][k-1] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\troad[i][i] = 0;\n\t\t}\n\n\t\t\tfor(int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tfor(int i = 0 ; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num = road[i][k] + road[k][j];\n\t\t\t\t\t\troad[i][j] = min(road[i][j],num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tint min = 0;\n\t\tmin = road[start][goal1] + road[start][goal2];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tint min_road = min(road[start][i] + road[i][goal1],road[start][i] + road[i][goal2]);\n\t\t\tmin_road = min_road + road[goal1][goal2];\n\t\t\tif(min > min_road)min = min(min,road[start][i] + min_road);\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tint min_road = road[start][i] + road[i][goal1] + road[i][goal2];\n\t\t\tif(min > min_road)min = min_road;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tprivate static int min(int i, int j) {\n\t\tif(i < j) return i;\n\t\telse return j;\n\t}\n\t\n\tprivate static int max(int i , int j)\n\t{\n\t\tif(i < j) return j;\n\t\telse return i;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tint[][] cost = new int[100][100];\n\t\tint INF = Integer.MAX_VALUE/3;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), s = sc.nextInt()-1, g1 = sc.nextInt()-1, g2 = sc.nextInt()-1;\n\t\t\tif (n == 0) break;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\tcost[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt()-1, b2 = sc.nextInt()-1, c = sc.nextInt();\n\t\t\t\tcost[b1][b2] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = min(res, cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAX = Integer.MAX_VALUE/10;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\tint V = in.nextInt();\n\t\tif(V==0) break;\n\t\tint E = in.nextInt();\n\t\tint s = in.nextInt()-1;\n\t\tint g1 = in.nextInt()-1;\n\t\tint g2 = in.nextInt()-1;\n\t\tint[][] road = new int[V][V];\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\troad[i][j] = (i==j)?0:MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\troad[a][b] = c;\n\t\t}\n/*\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n*/\t\t\n\t\tfor(int k=0;k<V;k++){\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\t\troad[i][j] = Math.min(road[i][j],road[i][k]+road[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n*/\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tans = Math.min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n//\t\t\tSystem.out.println(i +\":\"+ans);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int s = sc.nextInt() - 1;\n\t\t\tfinal int g1 = sc.nextInt() - 1;\n\t\t\tfinal int g2 = sc.nextInt() - 1;\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == -1 && g1 == -1 && g2 == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint[][] adj = new int[n][n];\n\t\t\tboolean[] visited = new boolean[n];\n\t\t\tint[] cost = new int[n];\n\t\t\tArrays.fill(cost, Integer.MAX_VALUE);\n\t\t\tint[] prev = new int[n];\n\t\t\tArrays.fill(prev, -1);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int b1 = sc.nextInt() - 1;\n\t\t\t\tfinal int b2 = sc.nextInt() - 1;\n\t\t\t\tfinal int c = sc.nextInt();\n\t\t\t\t\n\t\t\t\tadj[b1][b2] = c;\n\t\t\t}\n\t\t\t\n\t\t\tcost[s] = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\tint min_pos = 0;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(!visited[j] && min > cost[j]){\n\t\t\t\t\t\tmin_pos = j;\n\t\t\t\t\t\tmin = cost[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited[min_pos] = true;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(visited[j]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(adj[min_pos][j] == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(cost[j] > adj[min_pos][j]){\n\t\t\t\t\t\tcost[j] = adj[min_pos][j];\n\t\t\t\t\t\tprev[j] = min_pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t{\n\t\t\t\tint pos = g1;\n\t\t\t\twhile(prev[pos] != -1){\n\t\t\t\t\tsum += adj[prev[pos]][pos];\n\t\t\t\t\tadj[prev[pos]][pos] = 0;\n\t\t\t\t\tpos = prev[pos];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpos = g2;\n\t\t\t\twhile(prev[pos] != -1){\n\t\t\t\t\tsum += adj[prev[pos]][pos];\n\t\t\t\t\tadj[prev[pos]][pos] = 0;\n\t\t\t\t\tpos = prev[pos];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main{\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif((n|m|s|g1|g2) == 0) break;\n\t\t\ts--;g1--;g2--;\n\t\t\tint [][]pass = new int[n][n];\n\t\t\tint INF = 1 << 24;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tpass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tint b = sc.nextInt() - 1;\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tpass[a][b] = cost;\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tpass[i][k] = Math.min(pass[i][k], pass[i][j] + pass[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int i = 0; i < n;i++){\n\t\t\t\tint value = pass[s][i] + pass[i][g1] + pass[i][g2];\n\t\t\t\tmin = Math.min(min, value);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 1000000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) Arrays.fill(map[i], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=road[0][s-1]+road[0][g1-1]+road[0][g2-1];\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n,m;\n\tint p[];\n\tint[][] map;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tmap = new int[n][n];\n\t\t\tp = new int[3];\n\t\t\tfor(int i=0;i<3;i++) p[i] = sc.nextInt();\n\t\t\tif( (n|m|p[0]|p[1]|p[2]) == 0 ) break;\n\t\t\tfor(int[] a: map) fill(a, INF);\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int j=0;j<3;j++) sum += map[i][p[j]-1];\n\t\t\t\tmin = min(min, sum);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 0; i < n + 1; i++){\n\t\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\tstreet[y][x] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 0; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 0; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint route[] = new int[3];\n\t\t\troute[0] = street[g1][g2];\n\t\t\troute[1] = street[s][g1];\n\t\t\troute[2] = street[s][g2];\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tsum = Math.min(sum, route[i] + route[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum - 1);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint g1 = scanner.nextInt();\n\t\t\tint g2 = scanner.nextInt();\n\t\t\tif ((n | m | s | g1 | g2) == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tg[i][j] = i == j ? 0 : INF;\n\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint b1 = scanner.nextInt() - 1;\n\t\t\t\tint b2 = scanner.nextInt() - 1;\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tg[b1][b2] = c;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\tg[j][k] = Math.min(g[j][k], g[j][i] + g[i][k]);\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans = Math.min(ans, g[s][i] + g[i][g1] + g[i][g2]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tint INF = 1 << 29;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic final int INF = 1 << 25;\n\tstatic int N, M, S, G1, G2;\n\tstatic int[][] W = new int[101][101];\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tS = sc.nextInt();\n\t\tG1 = sc.nextInt();\n\t\tG2 = sc.nextInt();\n\t\tif (N == 0 && M == 0) return false;\n\t\t\n\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\tfill(W[i], INF);\n\t\t\tW[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint b1, b2, c;\n\t\t\tb1 = sc.nextInt();\n\t\t\tb2 = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tW[b1][b2] = c;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\t// WF\n\t\tfor (int k = 0; k < 101; k++) {\n\t\t\tfor (int i = 0; i < 101; i++) {\n\t\t\t\tfor (int j = 0; j < 101; j++) {\n\t\t\t\t\tW[i][j] = min(W[i][j], W[i][k] + W[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF * 2;\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tans = min(ans, W[S][i] + W[i][G1] + W[i][G2]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tpublic static int[][][] directedGraph(int n, int[] s, int[] t, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : s) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<s.length; i++) {\n\t\t\tint from = s[i];\n\t\t\tint to = t[i];\n\n\t\t\tg[from][--cnt[from]][0] = to;\n\t\t\tg[from][cnt[from]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tpublic static long[] dijkstra(int[][][] g, int source) {\n\t\tint n = g.length;\n\n\t\tfinal long[] d = new long[n];\n\t\tArrays.fill(d, Integer.MAX_VALUE/2);\n\t\td[source] = 0;\n\n\t\tTreeSet<Integer> pQ = new TreeSet<Integer>(new Comparator<Integer>(){\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (d[a] != d[b]) return d[a] > d[b] ? 1 : -1;\n\t\t\t\treturn a > b ? 1 : -1;\n\t\t\t}\n\t\t});\n\t\tpQ.add(source);\n\n\t\twhile (!pQ.isEmpty()) {\n\t\t\tint cur = pQ.pollFirst();\n\n\t\t\tfor (int i=0; i<g[cur].length; i++) {\n\t\t\t\tint next = g[cur][i][0];\n\t\t\t\tlong dist = d[cur] + g[cur][i][1];\n\t\t\t\tif (dist < d[next]) {\n\t\t\t\t\tpQ.remove(next);\n\t\t\t\t\td[next] = dist;\n\t\t\t\t\tpQ.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tstatic boolean solve() {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint s = in.nextInt() - 1;\n\t\tint g1 = in.nextInt() - 1;\n\t\tint g2 = in.nextInt() - 1;\n\t\tif (n + m == 0) return false;\n\n\t\tint[] v1 = new int[m];\n\t\tint[] v2 = new int[m];\n\t\tint[] c = new int[m];\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tv1[i] = in.nextInt() - 1;\n\t\t\tv2[i] = in.nextInt() - 1;\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\n\t\tint[][][] g = directedGraph(n, v1, v2, c);\n\t\tlong[] ds = dijkstra(g, s);\n\n\t\tlong ans = ds[g1] + ds[g2];\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tif (i == s) continue;\n\t\t\tlong[] d = dijkstra(g, i);\n\t\t\tans = Math.min(ans, ds[i] + d[g1] + d[g2]);\n\t\t}\n\n\t\tout.println(ans);\n\n\t\treturn true;\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\tdump((end-start) + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAX = 10000;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\tint V = in.nextInt();\n\t\tif(V==0) break;\n\t\tint E = in.nextInt();\n\t\tint s = in.nextInt()-1;\n\t\tint g1 = in.nextInt()-1;\n\t\tint g2 = in.nextInt()-1;\n\t\tint[][] road = new int[V][V];\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\troad[i][j] = (i==j)?0:MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\troad[a][b] = c;\n\t\t\troad[b][a] = c;\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tfor(int k=0;k<V;k++){\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\t\troad[i][j] = Math.min(road[i][j],road[i][k]+road[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t*/\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tans = Math.min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n\t\t\t//System.out.println(i +\":\"+ans);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=1000000;\n\t\t\t\tif(i==j){\n\t\t\t\t\troad[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=1000000;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[s-1][k]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[s-1][k]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int[][] map;\n\tprivate static int MAX = 1000000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint g1 = sc.nextInt() - 1;\n\t\t\tint g2 = sc.nextInt() - 1;\n\n\t\t\tmap = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt() - 1;\n\t\t\t\tint b2 = sc.nextInt() - 1;\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tmap[b1][b2] = cost;\n\t\t\t}\n\n\t\t\tWarshallFloyd();\n\t\t\t/*\n\t\t\t * それぞれの基地について, 水源からのコストと目的地までのコストの合計値を出す。\n\t\t\t * この時s->iという向きと、i->gという向きに注意する。\n\t\t\t */\n\t\t\tint minCost = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint cost = map[s][i] + map[i][g1] + map[i][g2];\n\t\t\t\tminCost = Math.min(minCost, cost);\n\t\t\t}\n\t\t\tSystem.out.println(minCost);\n\t\t}\n\t}\n\n\tstatic void WarshallFloyd() {\n\t\t// 任意の2点間の最小時間を入れる\n\t\tint n = map.length;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (map[i][j] == 0) {\n\t\t\t\t\tmap[i][j] = MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Iku {\n    int dist;\n    int cost;\n  }\n\n  class Node {\n    int now;\n    int score;\n  }\n\n  int[] daikusutora(int start, int n, ArrayList<LinkedList<Iku>> list) {\n    int[] score = new int[n + 1];\n    boolean[] done = new boolean[n + 1];\n    Arrays.fill(score, INF);\n    PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a.score));\n    Node atom = new Node();\n    atom.now = start;\n    atom.score = 0;\n    queue.add(atom);\n    while (queue.size() > 0) {\n      Node node = queue.poll();\n      if (done[node.now]) {\n        continue;\n      }\n      done[node.now] = true;\n      score[node.now] = node.score;\n      for (Iku iku : list.get(node.now)) {\n        Node next = new Node();\n        next.now = iku.dist;\n        next.score = node.score + iku.cost;\n        if (done[next.now]) {\n          continue;\n        }\n        queue.add(next);\n      }\n    }\n    return score;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      int m = ni();\n      int s = ni();\n      int g1 = ni();\n      int g2 = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<LinkedList<Iku>> list = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        list.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int b1 = ni();\n        int b2 = ni();\n        int c = ni();\n        Iku iku = new Iku();\n        iku.dist = b2;\n        iku.cost = c;\n        list.get(b1).add(iku);\n      }\n      int ans = Integer.MAX_VALUE;\n      for (int i = 1; i <= n; ++i) {\n        int cost = 0;\n        // s -> i\n        cost += daikusutora(s, n, list)[i];\n        // i -> g1, g2\n        int[] t = daikusutora(i, n, list);\n        cost += t[g1];\n        cost += t[g2];\n        ans = Math.min(ans, cost);\n      }\n      System.out.println(ans);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint s = 0;\n\t\tint g1 = 0;\n\t\tint g2 = 0;\n\n\t\tint last_cost = Integer.MAX_VALUE/10;\n\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tm = scan.nextInt();\n\t\t\ts = scan.nextInt();\n\t\t\tg1 = scan.nextInt();\n\t\t\tg2 = scan.nextInt();\n\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint kithi1[] = new int[m];\n\t\t\tint kithi2[] = new int[m];\n\t\t\tint cost[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i!=j)\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE/10;;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tkithi1[i] = scan.nextInt();\n\t\t\t\tkithi2[i] = scan.nextInt();\n\t\t\t\tcost[kithi1[i] - 1][kithi2[i] - 1] = scan.nextInt();\n\t\t\t\t//cost[kithi2[i] - 1][kithi1[i] - 1] = cost[kithi1[i] - 1][kithi2[i] - 1];\n\t\t\t}\n\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (last_cost > cost[s][i] + cost[i][g1]+cost[i][g2])\n\t\t\t\t\tlast_cost = cost[s][i] + cost[i][g1]+cost[i][g2];\n\t\t\t}\n\n\t\t\tSystem.out.println(last_cost);\n\t\t}\n\t\tscan.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint s = 0;\n\t\tint g1 = 0;\n\t\tint g2 = 0;\n\n\t\t\n\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tm = scan.nextInt();\n\t\t\ts = scan.nextInt();\n\t\t\tg1 = scan.nextInt();\n\t\t\tg2 = scan.nextInt();\n\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint last_cost = Integer.MAX_VALUE / 10;\n\t\t\t\n\t\t\tint kithi1[] = new int[m];\n\t\t\tint kithi2[] = new int[m];\n\t\t\tint cost[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i != j)\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tkithi1[i] = scan.nextInt();\n\t\t\t\tkithi2[i] = scan.nextInt();\n\t\t\t\tcost[kithi1[i] - 1][kithi2[i] - 1] = scan.nextInt();\n\t\t\t\t//cost[kithi2[i] - 1][kithi1[i] - 1] = cost[kithi1[i] - 1][kithi2[i] - 1];\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (last_cost > cost[s][i] + cost[i][g1] + cost[i][g2])\n\t\t\t\t\tlast_cost = cost[s][i] + cost[i][g1] + cost[i][g2];\n\t\t\t}\n\n\t\t\tSystem.out.println(last_cost);\n\t\t}\n\t\tscan.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint g1 = scanner.nextInt();\n\t\t\tint g2 = scanner.nextInt();\n\t\t\tif ((n | m | s | g1 | g2) == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\t\t\tint[][] smap = new int[n][n];\n\t\t\tint[][] gmap = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tsmap[i][j] = gmap[i][j] = i == j ? 0 : INF;\n\n\t\t\t\t}\n\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint b1 = scanner.nextInt() - 1;\n\t\t\t\tint b2 = scanner.nextInt() - 1;\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tsmap[b1][b2] = gmap[b2][b1] = c;\n\t\t\t}\n\t\t\tint[] acost = slove(s, smap);\n\t\t\tint[] bcost = slove(g1, gmap);\n\t\t\tint[] ccost = slove(g2, gmap);\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans = Math.min(ans, acost[i] + bcost[i] + ccost[i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int[] slove(int s, int[][] map) {\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tpq.offer(new Pair(s, 0));\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, INF);\n\t\tdp[s] = 0;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.poll();\n\t\t\tif (dp[p.d] < p.cost)\n\t\t\t\tcontinue;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ncost = p.cost + map[p.d][i];\n\t\t\t\tif (dp[i] <= ncost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i] = ncost;\n\t\t\t\tpq.offer(new Pair(i, ncost));\n\t\t\t}\n\t\t}\n\t\treturn dp;\n\t}\n\n\tint INF = 1 << 29;\n\tint n;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint d, cost;\n\n\t\tpublic Pair(int d, int cost) {\n\t\t\tsuper();\n\t\t\tthis.d = d;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [d=\" + d + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g1 = in.nextInt()-1;\n\t\t\tint g2 = in.nextInt()-1;\n\t\t\tif(n == 0) break;\n\t\t\tint[][] edge = new int[n][n];\n//\t\t\tint[][] root = new int[n][n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n//\t\t\t\t\troot[i][j] = i;\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tedge[i][j] = 1000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint b1 = in.nextInt()-1;\n\t\t\t\tint b2 = in.nextInt()-1;\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tedge[b1][b2] = c;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\t\tif(edge[j][k] > edge[j][i]+edge[i][k]){\n\t\t\t\t\t\t\tedge[j][k] = edge[j][i] + edge[i][k];\n//\t\t\t\t\t\t\troot[j][k] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tres = Math.min(res, edge[s][i]+edge[i][g1]+edge[i][g2]);\n\t\t\t}\n//\t\t\tLinkedList<Integer> list = rooting(root, s, g1);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g1] + edge[i][g2]);\n//\t\t\t}\n\t\t\t\n//\t\t\tlist = rooting(root, s, g2);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g2] + edge[i][g1]);\n//\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static LinkedList<Integer> rooting(\n\t\t\tint[][] root, int s, int t){\n\t\tLinkedList<Integer> res = new LinkedList<Integer>();\n\t\trefound(root, s, t, res);\n\t\treturn res;\n\t}\n\t\n\tpublic static void refound(\n\t\t\tint[][] root, int s, int t\n\t\t\t, LinkedList<Integer> res){\n\t\tint center = root[s][t];\n\t\tif(s == center){\n\t\t\tres.add(t);\n\t\t\treturn;\n\t\t}\n\t\trefound(root, s, center, res);\n\t\trefound(root, center, t, res);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2005();\n\t}\n\t\n\tfinal int INF=Integer.MAX_VALUE/4;\n\t\n\tclass AOJ2005{\n\t\tAOJ2005(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt(),m=sc.nextInt(),s=sc.nextInt(),g1=sc.nextInt(),g2=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\t--s; --g1; --g2;\n\t\t\t\tsolve(n,m,s,g1,g2);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int n,int m,int s,int g1,int g2){\n\t\t\tint[][] g=new int[n][n];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)\tg[i][j]=INF;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();\n\t\t\t\t--a; --b;\n\t\t\t\tg[a][b]=c;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashSet<String>> c1=new ArrayList<HashSet<String>>(n);\n\t\t\tfor(int i=0; i<n; ++i)\tc1.add(new HashSet<String>());\n\t\t\t\n\t\t\tLinkedList<S1> o1=new LinkedList<S1>();\n\t\t\to1.add(new S1(s,new String()));\n\t\t\t\n\t\t\twhile(!o1.isEmpty()){\n\t\t\t\tS1 now=o1.poll();\n\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\tif(now.p==i || g[now.p][i]>=INF)\tcontinue;\n\t\t\t\t\tString tmp=now.s+i;\n\t\t\t\t\tif(!c1.get(i).contains(tmp)){\n\t\t\t\t\t\tif(i!=g1)\to1.add(new S1(i,tmp));\n\t\t\t\t\t\tc1.get(i).add(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<String> cand=new HashSet<String>();\n\t\t\tcand.addAll(c1.get(g1));\n\t\t\tc1=null;\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\tfor(String str:cand){\n\t\t\t\t\n\t\t\t\tint[][] gg=new int[n][n];\n\t\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)gg[i][j]=g[i][j];\n\t\t\t\t\n\t\t\t\tint prev=s,cost1=0;\n\t\t\t\tfor(int i=0; i<str.length(); ++i){\n\t\t\t\t\tcost1+=gg[prev][str.charAt(i)-'0'];\n\t\t\t\t\tgg[prev][str.charAt(i)-'0']=0;\n\t\t\t\t\tprev=str.charAt(i)-'0';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPriorityQueue<S2> o2=new PriorityQueue<S2>();\n\t\t\t\to2.add(new S2(s,0));\n\t\t\t\tint[] c2=new int[n];\n\t\t\t\tfor(int i=0; i<n; ++i)c2[i]=INF;\n\t\t\t\t\n\t\t\t\tint cost2=0;\n\t\t\t\twhile(!o2.isEmpty()){\n\t\t\t\t\tS2 now=o2.poll();\n\t\t\t\t\tif(now.p==g2){\n//\t\t\t\t\t\tSystem.out.println(\"G2\");\n\t\t\t\t\t\tcost2=now.c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\tif(now.p==i || gg[now.p][i]>=INF)\tcontinue;\n\t\t\t\t\t\tint nc=now.c+gg[now.p][i];\n\t\t\t\t\t\tif(c2[i]<=nc)\tcontinue;\n\t\t\t\t\t\to2.add(new S2(i, nc));\n\t\t\t\t\t\tc2[i]=nc;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tSystem.out.println(cost1+\" \"+cost2);\n\t\t\t\tans=min(ans,cost1+cost2);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t\tclass E{\n\t\t\tint d,c;\n\t\t\tE(int d,int c){\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t}\n\t\tclass S1{\n\t\t\tint p;\n\t\t\tString s;\n\t\t\tS1(int p,String s){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.s=s;\n\t\t\t}\n\t\t}\n\t\tclass S2 implements Comparable<S2>{\n\t\t\tint p,c;\n\t\t\tS2(int p,int c){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(S2 o){\n\t\t\t\treturn this.c-o.c;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], INF);\n\t\t\t\tmap[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100_000_000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) Arrays.fill(map[i], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int times = 0; times < n; times++)\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\t\t\t\n\t\t\tint[] a = new int[m];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] cost = new int[n+1][n+1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tint p;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tq.offer(i);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t\twhile(q.size()!=0){\n\t\t\t\t\tp = q.poll();\n\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\tif(a[j]==p && cost[i][a[j]]+c[j]<cost[i][b[j]]){\n\t\t\t\t\t\t\tcost[i][b[j]] = cost[i][a[j]] + c[j];\n\t\t\t\t\t\t\tq.offer(b[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(cost[i][g1]!=Integer.MAX_VALUE && cost[i][g2]!=Integer.MAX_VALUE){\n\t\t\t\t\tmin = Math.min(min, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n\n    static int[][] d;\n\n    public static void main(String[] args) {\n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int g1 = sc.nextInt();\n            int g2 = sc.nextInt();\n            if (n == 0) break;\n\n            d = new int[n + 1][n + 1];\n\n            init(n);\n            scanRoad(m);\n            warshallFloyd(n);\n            calcCost(n, s, g1, g2);\n\n        }\n\n\n    }\n\n    static void warshallFloyd(int n) { // nは頂点数\n        for (int i = 1; i <= n; i++)      // 経由する頂点\n            for (int j = 1; j <= n; j++)    // 開始頂点\n                for (int k = 1; k <= n; k++)  // 終端\n                    d[j][k] = Math.min(d[j][k], d[j][i] + d[i][k]);\n    }\n\n    static void scanRoad(int m) {\n        for (int i = 0; i < m; i++) {\n            int b1 = sc.nextInt();\n            int b2 = sc.nextInt();\n            int c = sc.nextInt();\n\n            d[b1][b2] = c;\n        }\n    }\n\n    static void calcCost(int n, int s, int g1, int g2) {\n        int min = 1000;\n        for (int i = 1; i <= n; i++) {\n            if ((s != i && d[s][i] == 0) || (g1 != i && d[i][g1] == 0) || (g2 != i && d[i][g2] == 0))\n                continue;\n            min = Math.min(min, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        System.out.println(min);\n    }\n\n    static void init(int n) {\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++)\n                d[i][j] = Integer.MAX_VALUE/10;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint start = sc.nextInt();\n\t\tstart = start - 1;\n\t\tint goal1 = sc.nextInt();\n\t\tgoal1 = goal1 - 1;\n\t\tint goal2 = sc.nextInt();\n\t\tgoal2 = goal2 - 1;\n\t\tint road[][] = new int[N][N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\troad[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m;i++)\n\t\t{\n\t\t\tint j = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\troad[j-1][k-1] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\troad[i][i] = 0;\n\t\t}\n\n\t\t\tfor(int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tfor(int i = 0 ; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num = road[i][k] + road[k][j];\n\t\t\t\t\t\troad[i][j] = min(road[i][j],num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tint min = 0;\n\t\tmin = road[start][goal1] + road[start][goal2];\n\t\tint min_road = min(road[start][goal1] + road[goal1][goal2],road[start][goal2] + road[goal2][goal1]);\n\t\tif(min > min_road) min = min_road;\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tmin_road = road[start][i] + road[i][goal1] + road[i][goal2];\n\t\t\tif(min > min_road)min = min_road;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tprivate static int min(int i, int j) {\n\t\tif(i < j) return i;\n\t\telse return j;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Water Pipe Construction (Warshall-Floyd)\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\t\t\tStringTokenizer st = new StringTokenizer(line);\n\t\t\tint n = parseInt(st.nextToken());  // ??????????????¨???????????°?????° n (3 <= n <= 100)\n\t\t\tint m = parseInt(st.nextToken());  // ?????°????????¶???????????° m (2 <= m <= 1000)\n\t\t\tint s = parseInt(st.nextToken());  // ?°´?????¨???????????°????????? s\n\t\t\tint g1 = parseInt(st.nextToken()); // ?°??°´??????????????°??¨?????? 2 ?????????????????°????????? g1???g2\n\t\t\tint g2 = parseInt(st.nextToken()); // ????????????????????????\n\n\t\t\tif ((n | m | s | g1 | g2) == 0) break;\n\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint[][] cost = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(cost[i], 1 << 20);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint b1 = parseInt(st.nextToken()); // ??????????§????????????°?????????\n\t\t\t\tint b2 = parseInt(st.nextToken()); // ???????????????????????°?????????\n\t\t\t\tint c = parseInt(st.nextToken());  // ?????° b1 ???????????° b2 ?????????????°??°´??????????¨?????????????????????????????????? (1 <= c <= 1000)\n\t\t\t\tb1--;\n\t\t\t\tb2--;\n\t\t\t\tcost[b1][b2] = c;\n\t\t\t}\n\n\t\t\t// solve\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tcost[i][j] = Math.min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = cost[s][g1] + cost[s][g2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmin = Math.min(min, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\n\t\t} // end while\n\t} // end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2005();\n\t}\n\t\n\tfinal int INF=Integer.MAX_VALUE/4;\n\t\n\tclass AOJ2005{\n\t\tAOJ2005(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt(),m=sc.nextInt(),s=sc.nextInt(),g1=sc.nextInt(),g2=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\t--s; --g1; --g2;\n\t\t\t\tsolve(n,m,s,g1,g2);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int n,int m,int s,int g1,int g2){\n\t\t\tint[][] g=new int[n][n];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)\tg[i][j]=INF;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();\n\t\t\t\t--a;\t--b;\n\t\t\t\tg[a][b]=c;\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashSet<String>> c1=new ArrayList<HashSet<String>>(n);\n\t\t\tfor(int i=0; i<n; ++i)\tc1.add(new HashSet<String>());\n\t\t\t\n\t\t\tLinkedList<S1> o1=new LinkedList<S1>();\n\t\t\to1.add(new S1(s,new String()));\n\t\t\t\n\t\t\twhile(!o1.isEmpty()){\n\t\t\t\tS1 now=o1.poll();\n\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\tif(now.p==i || g[now.p][i]>=INF)\tcontinue;\n\t\t\t\t\tString tmp=now.s+i;\n\t\t\t\t\tif(!c1.get(i).contains(tmp)){\n\t\t\t\t\t\to1.add(new S1(i,tmp));\n\t\t\t\t\t\tc1.get(i).add(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tHashSet<String> cand=c1.get(g1);\n\t\t\tint ans=INF;\n\t\t\tfor(String str:cand){\n\t\t\t\t\n\t\t\t\tint[][] gg=new int[n][n];\n\t\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)gg[i][j]=g[i][j];\n\t\t\t\t\n\t\t\t\tint prev=s,cost1=0;\n\t\t\t\tfor(int i=0; i<str.length(); ++i){\n\t\t\t\t\tcost1+=gg[prev][str.charAt(i)-'0'];\n\t\t\t\t\tgg[prev][str.charAt(i)-'0']=0;\n\t\t\t\t\tprev=str.charAt(i)-'0';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPriorityQueue<S2> o2=new PriorityQueue<S2>();\n\t\t\t\to2.add(new S2(s,0));\n\t\t\t\tint[] c2=new int[n];\n\t\t\t\tfor(int i=0; i<n; ++i)c2[i]=INF;\n\t\t\t\t\n\t\t\t\tint cost2=0;\n\t\t\t\twhile(!o2.isEmpty()){\n\t\t\t\t\tS2 now=o2.poll();\n\t\t\t\t\tif(now.p==g2){\n//\t\t\t\t\t\tSystem.out.println(\"G2\");\n\t\t\t\t\t\tcost2=now.c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\tif(now.p==i || gg[now.p][i]>=INF)\tcontinue;\n\t\t\t\t\t\tint nc=now.c+gg[now.p][i];\n\t\t\t\t\t\tif(c2[i]<=nc)\tcontinue;\n\t\t\t\t\t\to2.add(new S2(i, nc));\n\t\t\t\t\t\tc2[i]=nc;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tSystem.out.println(cost1+\" \"+cost2);\n\t\t\t\tans=min(ans,cost1+cost2);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t\tclass E{\n\t\t\tint d,c;\n\t\t\tE(int d,int c){\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t}\n\t\tclass S1{\n\t\t\tint p;\n\t\t\tString s;\n\t\t\tS1(int p,String s){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.s=s;\n\t\t\t}\n\t\t}\n\t\tclass S2 implements Comparable<S2>{\n\t\t\tint p,c;\n\t\t\tS2(int p,int c){\n\t\t\t\tthis.p=p;\n\t\t\t\tthis.c=c;\n\t\t\t}\n\t\t\t@Override public int compareTo(S2 o){\n\t\t\t\treturn this.c-o.c;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int n,m,s,g1,g2;\n    int[][] d;\n    int INF = 700000000;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    n = sc.nextInt();\n\t    m = sc.nextInt();\n\t    s = sc.nextInt();\n\t    g1 = sc.nextInt();\n\t    g2 = sc.nextInt();\n\t    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\n\t    d = new int[n+1][n+1];\n\t    for(int i=0; i<=n; i++) Arrays.fill(d[i],INF);\n\t    for(int i=0; i<m; i++){\n\t\tint b1 = sc.nextInt();\n\t\tint b2 = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\td[b1][b2] = c;\n\t    }\n\t    for(int i=0; i<=n; i++) d[i][i] = 0;\n\n\t    warshall_floyd();\n\n\t    int min = INF;\n\t    for(int i=1; i<=n; i++){\n\t\tmin = Math.min(min,d[s][i]+d[i][g1]+d[i][g2]);\n\t    }\n\t    System.out.println(min);\n\t}\n    }\n    \n    void warshall_floyd(){\n\tfor(int k=1; k<=n; k++)\n\t    for(int i=1; i<=n; i++)\n\t\tfor(int j=1; j<=n; j++)d[i][j] = Math.min(d[i][j],d[i][k]+d[k][j]);\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\t\t\t\n\t\t\tint[] a = new int[m];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] cost = new int[n+1][n+1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tint p;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tq.offer(i);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t\twhile(q.size()!=0){\n\t\t\t\t\tp = q.poll();\n\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\tif(a[j]==p && cost[i][a[j]]+c[j]<cost[i][b[j]]){\n\t\t\t\t\t\t\tcost[i][b[j]] = cost[i][a[j]] + c[j];\n\t\t\t\t\t\t\tq.offer(b[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(cost[i][g1]!=Integer.MAX_VALUE && cost[i][g2]!=Integer.MAX_VALUE){\n\t\t\t\t\tmin = Math.min(min, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings({ \"unused\", \"unchecked\" })\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint g1 = scanner.nextInt();\n\t\t\tint g2 = scanner.nextInt();\n\t\t\tif ((n | m | s | g1 | g2) == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tg[i][j] = i == j ? 0 : INF;\n\n\t\t\tList<Pair>[] slist = new List[n];\n\t\t\tList<Pair>[] glist = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tslist[i] = new ArrayList<Main.Pair>();\n\t\t\t\tglist[i] = new ArrayList<Main.Pair>();\n\t\t\t}\n\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint b1 = scanner.nextInt() - 1;\n\t\t\t\tint b2 = scanner.nextInt() - 1;\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tslist[b1].add(new Pair(b2, c));\n\t\t\t\tglist[b2].add(new Pair(b1, c));\n\t\t\t}\n\t\t\tint[] acost = slove(s, slist);\n\t\t\tint[] bcost = slove(g1, glist);\n\t\t\tint[] ccost = slove(g2, glist);\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans = Math.min(ans, acost[i] + bcost[i] + ccost[i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int[] slove(int s, List<Pair>[] lists) {\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tpq.offer(new Pair(s, 0));\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, INF);\n\t\tdp[s] = 0;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.poll();\n\t\t\tif (dp[p.d] < p.cost)\n\t\t\t\tcontinue;\n\t\t\tdp[p.d] = p.cost;\n\t\t\tfor (Pair pair : lists[p.d]) {\n\t\t\t\tpq.offer(new Pair(pair.d, p.cost + pair.cost));\n\t\t\t}\n\t\t}\n\t\treturn dp;\n\t}\n\n\tint INF = 1 << 29;\n\tint n;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint d, cost;\n\n\t\tpublic Pair(int d, int cost) {\n\t\t\tsuper();\n\t\t\tthis.d = d;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [d=\" + d + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 1000000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) Arrays.fill(map[i], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n\n    static int[][] d;\n\n    public static void main(String[] args) {\n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int g1 = sc.nextInt();\n            int g2 = sc.nextInt();\n            if (n == 0) break;\n\n            d = new int[n + 1][n + 1];\n\n            init(n);\n            scanRoad(m);\n            warshallFloyd(n);\n            calcCost(n, s, g1, g2);\n\n        }\n\n\n    }\n\n    static void warshallFloyd(int n) { // nは頂点数\n        for (int i = 1; i <= n; i++)      // 経由する頂点\n            for (int j = 1; j <= n; j++)    // 開始頂点\n                for (int k = 1; k <= n; k++)  // 終端\n                    d[j][k] = Math.min(d[j][k], d[j][i] + d[i][k]);\n    }\n\n    static void scanRoad(int m) {\n        for (int i = 0; i < m; i++) {\n            int b1 = sc.nextInt();\n            int b2 = sc.nextInt();\n            int c = sc.nextInt();\n\n            d[b1][b2] = c;\n        }\n    }\n\n    static void calcCost(int n, int s, int g1, int g2) {\n        int min = Integer.MAX_VALUE/10;\n        for (int i = 1; i <= n; i++) {\n            min = Math.min(min, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        System.out.println(min);\n    }\n\n    static void init(int n) {\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++)\n                d[i][j] = Integer.MAX_VALUE/10;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAX = Integer.MAX_VALUE/10;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\tint V = in.nextInt();\n\t\tif(V==0) break;\n\t\tint E = in.nextInt();\n\t\tint s = in.nextInt()-1;\n\t\tint g1 = in.nextInt()-1;\n\t\tint g2 = in.nextInt()-1;\n\t\tint[][] road = new int[V][V];\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\troad[i][j] = (i==j)?0:MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\troad[a][b] = c;\n\t\t\troad[b][a] = c;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int k=0;k<V;k++){\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\t\troad[i][j] = Math.min(road[i][j],road[i][k]+road[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tans = Math.min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n\t\t\tSystem.out.println(i +\":\"+ans);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tStringBuilder ret = new StringBuilder();\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tint s = scanner.nextInt();\n\t\t\tint g1 = scanner.nextInt();\n\t\t\tint g2 = scanner.nextInt();\n\t\t\tif ((n | m | s | g1 | g2) == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\t\t\tint[][] smap = new int[n][n];\n\t\t\tint[][] gmap = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tsmap[i][j] = gmap[i][j] = i == j ? 0 : INF;\n\n\t\t\t\t}\n\n\t\t\twhile (m-- > 0) {\n\t\t\t\tint b1 = scanner.nextInt() - 1;\n\t\t\t\tint b2 = scanner.nextInt() - 1;\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tsmap[b1][b2] = gmap[b2][b1] = c;\n\t\t\t}\n\t\t\tint[] acost = slove(s, smap);\n\t\t\tint[] bcost = slove(g1, gmap);\n\t\t\tint[] ccost = slove(g2, gmap);\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans = Math.min(ans, acost[i] + bcost[i] + ccost[i]);\n\t\t\tret.append(ans).append('\\n');\n\t\t}\n\t\tSystem.out.print(ret);\n\t}\n\n\tprivate int[] slove(int s, int[][] map) {\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tpq.offer(new Pair(s, 0));\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, INF);\n\t\tdp[s] = 0;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair p = pq.poll();\n\t\t\tif (dp[p.d] < p.cost)\n\t\t\t\tcontinue;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint ncost = p.cost + map[p.d][i];\n\t\t\t\tif (dp[i] <= ncost)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i] = ncost;\n\t\t\t\tpq.offer(new Pair(i, ncost));\n\t\t\t}\n\t\t}\n\t\treturn dp;\n\t}\n\n\tint INF = 1 << 29;\n\tint n;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint d, cost;\n\n\t\tpublic Pair(int d, int cost) {\n\t\t\tsuper();\n\t\t\tthis.d = d;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [d=\" + d + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int n,m,s,g1,g2;\n    int[][] d;\n    int INF = 700000000;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    n = sc.nextInt();\n\t    m = sc.nextInt();\n\t    s = sc.nextInt();\n\t    g1 = sc.nextInt();\n\t    g2 = sc.nextInt();\n\t    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\n\t    d = new int[m][m];\n\t    for(int i=0; i<m; i++) Arrays.fill(d[i],INF);\n\t    for(int i=0; i<m; i++){\n\t\tint b1 = sc.nextInt();\n\t\tint b2 = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\td[b1][b2] = c;\n\t    }\n\t    for(int i=0; i<m; i++) d[i][i] = 0;\n\n\t    warshall_floyd();\n\n\t    int min = INF;\n\t    for(int i=0; i<m; i++){\n\t\tmin = Math.min(min,d[s][i]+d[i][g1]+d[i][g2]);\n\t    }\n\t    System.out.println(min);\n\t}\n    }\n    \n    void warshall_floyd(){\n\tfor(int k=0; k<m; k++)\n\t    for(int i=0; i<m; i++)\n\t\tfor(int j=0; j<m; j++)d[i][j] = Math.min(d[i][j],d[i][k]+d[k][j]);\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint start = sc.nextInt();\n\t\tstart = start - 1;\n\t\tint goal1 = sc.nextInt();\n\t\tgoal1 = goal1 - 1;\n\t\tint goal2 = sc.nextInt();\n\t\tgoal2 = goal2 - 1;\n\t\tint road[][] = new int[N][N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\troad[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m;i++)\n\t\t{\n\t\t\tint j = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\troad[j-1][k-1] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\troad[i][i] = 0;\n\t\t}\n\n\t\t\tfor(int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tfor(int i = 0 ; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num = road[i][k] + road[k][j];\n\t\t\t\t\t\troad[i][j] = min(road[i][j],num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tint min = 0;\n\t\tmin = road[start][goal1] + road[start][goal2];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tint min_road = min(road[start][i] + road[i][goal1],road[start][i] + road[i][goal2]);\n\t\t\tmin_road = min_road + road[goal1][goal2];\n\t\t\tif(min > min_road)min = min_road;\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tint min_road = road[start][i] + road[i][goal1] + road[i][goal2];\n\t\t\tif(min > min_road)min = min_road;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tprivate static int min(int i, int j) {\n\t\tif(i < j) return i;\n\t\telse return j;\n\t}\n\t\n\tprivate static int max(int i , int j)\n\t{\n\t\tif(i < j) return j;\n\t\telse return i;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal static int INT_MAX = 100000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] table = new int[n][n];\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\tint min = INT_MAX;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt();\n\t\t\t\tint b2 = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\t\ttable[i][j] = INT_MAX;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ttable[i][i] = 0;\n\t\t\tfor (int k = 0; k < n - 1; k++)\n\t\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n\n    static int[][] d;\n\n    public static void main(String[] args) {\n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int g1 = sc.nextInt();\n            int g2 = sc.nextInt();\n            if (n == 0) break;\n\n            d = new int[n + 1][n + 1];\n\n            init(n);\n            scanRoad(m);\n            warshallFloyd(n);\n            calcCost(n, s, g1, g2);\n\n        }\n\n\n    }\n\n    static void warshallFloyd(int n) { // nは頂点数\n        for (int i = 1; i <= n; i++)      // 経由する頂点\n            for (int j = 1; j <= n; j++)    // 開始頂点\n                for (int k = 1; k <= n; k++)  // 終端\n                    d[j][k] = Math.min(d[j][k], d[j][i] + d[i][k]);\n    }\n\n    static void scanRoad(int m) {\n        for (int i = 0; i < m; i++) {\n            int b1 = sc.nextInt();\n            int b2 = sc.nextInt();\n            int c = sc.nextInt();\n\n            d[b1][b2] = c;\n        }\n    }\n\n    static void calcCost(int n, int s, int g1, int g2) {\n        int min = 1000;\n        for (int i = 1; i <= n; i++) {\n            min = Math.min(min, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        System.out.println(min);\n    }\n\n    static void init(int n) {\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++)\n                d[i][j] = Integer.MAX_VALUE/10;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new aoj1155().doIt();\n    }\n    class aoj1155{\n    \tint d(int n,int m,int s,int g1,int g2){\n    \t\tint cost[][] = new int [n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE/5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tint st = sc.nextInt()-1;\n\t\t\t\tint et = sc.nextInt()-1;\n\t\t\t\tint co = sc.nextInt();\n\t\t\t\tcost[st][et] = co;\n\t\t\t}\n\t\t\tfor(int j=0; j<n;j++){\n\t\t\t\tfor(int i=0; i<n;i++){\n\t\t\t\t\tfor(int k=0; k<n;k++){\n\t\t\t\t\t\tcost[i][k]=Math.min(cost[i][k], cost[i][j]+cost[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            int ans = Integer.MAX_VALUE/5;\n//            for(int i = 0;i < n;i++){\n//            \tfor(int j = 0;j < n;j++){\n//            \t\tSystem.out.print(cost[i][j]+\" \");\n//            \t}\n//            \tSystem.out.println();\n//            }\n            for(int i=0; i<n;i++){\n            \tans=Math.min(ans,cost[s][i]+cost[i][g1]+cost[i][g2]);\n            }\n\t\t\treturn ans;\n\t\t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tint n = sc.nextInt();\n    \t\t\tint m = sc.nextInt();\n    \t\t\tint s = sc.nextInt();\n    \t\t\tint g1 = sc.nextInt();\n    \t\t\tint g2 = sc.nextInt();\n    \t\t\tif(n+m+s+g1+g2 == 0)break;\n    \t\t\tSystem.out.println(d(n,m,s-1,g1-1,g2-1));\n    \t\t}\n    \t}\n     }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tprivate static int[][] map;\n\tprivate static int MAX = 1000000;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint g1 = sc.nextInt() - 1;\n\t\t\tint g2 = sc.nextInt() - 1;\n\n\t\t\tmap = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt() - 1;\n\t\t\t\tint b2 = sc.nextInt() - 1;\n\t\t\t\tint cost = sc.nextInt();\n\t\t\t\tmap[b1][b2] = cost;\n\t\t\t}\n\n\t\t\tWarshallFloyd();\n\t\t\t/*\n\t\t\t * それぞれの基地について, 水源からのコストと目的地までのコストの合計値を出す。\n\t\t\t * この時s->iという向きと、i->gという向きに注意する。\n\t\t\t */\n\t\t\tint minCost = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint cost = map[s][i] + map[i][g1] + map[i][g2];\n\t\t\t\tminCost = Math.min(minCost, cost);\n\t\t\t}\n\t\t\tSystem.out.println(minCost);\n\t\t}\n\t}\n\n\tstatic void WarshallFloyd() {\n\t\t// 任意の2点間の最小時間を入れる\n\t\tint n = map.length;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (map[i][j] == 0 && i != j) {\n\t\t\t\t\tmap[i][j] = MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < n; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\tstreet[y][x] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tstreet[i][i] = 0;\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 1; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tsum = Math.min(sum , street[1][i] + street[i][g1] + street[i][g2]);\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tFS reader = new FS();\n\t\t// write reader\n\t\twhile(true) {\n\t\t\tint n = reader.nextInt();\n\t\t\tint m = reader.nextInt();\n\t\t\tint s = reader.nextInt();\n\t\t\tint g1 = reader.nextInt();\n\t\t\tint g2 = reader.nextInt();\n\t\t\tif (n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\t\t\tint[][] matrix = new int[n][n];\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tmatrix[i][j] = 70000000;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tint b1 = reader.nextInt();\n\t\t\t\tint b2 = reader.nextInt();\n\t\t\t\tint c = reader.nextInt();\n\t\t\t\tmatrix[b1-1][b2-1] = c;\n\t\t\t}\n\t\t\tsolver(n, s, g1, g2, matrix);\n\t\t}\n\t}\n\n\tpublic static void solver(int n, int s, int g1, int g2, int[][] matrix) {\n\t\t// write logic\n\t\tint[][] cost = warshall(n, matrix);\n\t\tint mincost = 70000000;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tmincost = Math.min(mincost, cost[s-1][i] + cost[i][g1-1] + cost[i][g2-1]);\n\t\t}\n\t\tSystem.out.println(mincost);\n\t}\n\n\tpublic static int[][] warshall(int n, int[][]matrix) {\n\t\tint[][] ans = matrix;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tans[i][i] = 0;\n\t\t}\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tfor(int k=0; k<n; k++) {\n\t\t\t\t\tans[j][k] = Math.min(ans[j][k], ans[j][i]+ans[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static int[] dijkstra(int n, int start, int[][] matrix) {\n\t\tboolean[] defnode = new boolean[n];\n\t\tint[] cost = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tdefnode[i] = false;\n\t\t\tcost[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tcost[start] = 0;\n\t\tint node = start;\n\t\tint counter = 0;\n\t\twhile(true) {\n\t\t\tcounter++;\n\t\t\tif(counter == n || node == Integer.MAX_VALUE) return cost;\n\t\t\tdefnode[node] = true;\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(defnode[i]) continue;\n\t\t\t\tif(matrix[node][i] == Integer.MAX_VALUE) continue;\n\t\t\t\tcost[i] = Math.min(cost[i], cost[node]+matrix[node][i]);\n\t\t\t}\n\t\t\tint minnode = Integer.MAX_VALUE;\n\t\t\tint mincost = Integer.MAX_VALUE;\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tif(defnode[i]) continue;\n\t\t\t\tif(cost[i] < mincost) {\n\t\t\t\t\tminnode = i;\n\t\t\t\t\tmincost = cost[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode = minnode;\n\t\t}\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[][] table = new int[n][n];\n\t\tint m = sc.nextInt();\n\t\tint s = sc.nextInt();\n\t\tint g1 = sc.nextInt();\n\t\tint g2 = sc.nextInt();\n\t\tint min = 1000000;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint b1 = sc.nextInt();\n\t\t\tint b2 = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\ttable[i][j] = 10000;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttable[i][i] = 0;\n\t\tfor (int k = 0; k < n - 1; k++)\n\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t}\n\t\tSystem.out.println(min);\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Water {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=1000000;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    while(true) {\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      int s = sc.nextInt();\n      int g1 = sc.nextInt();\n      int g2 = sc.nextInt();\n\n      if(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n\n      s = s-1;\n      g1 = g1-1;\n      g2 = g2-1;\n\n      int[][] cost = new int[n][n];\n\n\n      int b1, b2;\n\n      for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n          if(i == j) cost[i][j] = 0;\n          else cost[i][j] = Integer.MAX_VALUE / 10;\n        }\n      }\n\n      for(int i = 0; i < m; i++) {\n        b1 = sc.nextInt()-1;\n        b2 = sc.nextInt()-1;\n        cost[b1][b2] = sc.nextInt();\n      }\n      \n      for(int k = 0; k < n; k++) {\n        for(int i = 0; i < n; i++) {\n          for(int j = 0; j < n; j++) {\n              cost[i][j] = Math.min(cost[i][j] , cost[i][k] + cost[k][j]);\n          }\n        }\n      }\n\n      int p4 = Integer.MAX_VALUE / 10;\n\n      for(int k = 0; k < n; k++) {\n        p4 = Math.min(p4, cost[s][k] + cost[k][g1] + cost[k][g2]);\n      }\n\n      System.out.println(p4);\n  \n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif ((n | m | s | g1 | g2) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(g[i], 1 << 20);\n\t\t\t\tg[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() - 1;\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tg[u][v] = w;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tg[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = g[s][g1] + g[s][g2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmin = Math.min(min, g[s][i] + g[i][g1] + g[i][g2]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal static int INT_MAX = 10000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] table = new int[n][n];\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\tint min = INT_MAX;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt();\n\t\t\t\tint b2 = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\t\ttable[i][j] = INT_MAX;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ttable[i][i] = 0;\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Water {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=road[0][s-1]+road[0][g1-1]+road[0][g2-1];\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAX = Integer.MAX_VALUE/10;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\tint V = in.nextInt();\n\t\tif(V==0) break;\n\t\tint E = in.nextInt();\n\t\tint s = in.nextInt()-1;\n\t\tint g1 = in.nextInt()-1;\n\t\tint g2 = in.nextInt()-1;\n\t\tint[][] road = new int[V][V];\n\t\tfor (int i=0;i<V;i++) {\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\troad[i][j] = (i==j)?0:MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint a = in.nextInt()-1;\n\t\t\tint b = in.nextInt()-1;\n\t\t\tint c = in.nextInt();\n\t\t\troad[a][b] = c;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int k=0;k<V;k++){\n\t\t\tfor(int i=0;i<V;i++){\n\t\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\t\troad[i][j] = Math.min(road[i][j],road[i][k]+road[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<V;i++){\n\t\t\tfor(int j=0;j<V;j++){\n\t\t\t\tSystem.out.print(road[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tint ans = Integer.MAX_VALUE;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tans = Math.min(ans,road[s][i]+road[i][g1]+road[i][g2]);\n\t\t\tSystem.out.println(i +\":\"+ans);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t\tSystem.gc();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tint s = in.nextInt() - 1, g1 = in.nextInt() - 1, g2 = in.nextInt() - 1;\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], INF);\n\t\t\t\tmap[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tmap[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, map[s][i] + map[i][g1] + map[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\t\t\n\t\twhile(true){\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tif(n==0 && m==0){\n\t\t\tif(s==0 && g1==0){\n\t\t\t\tif(g2==0){break;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=1000000;\n\t\t\t\tif(i==j){\n\t\t\t\t\troad[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tnum=0;\n\t\twhile(num<m){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t\tnum++;\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=road[0][s-1]+road[0][g1-1]+road[0][g2-1];\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main{\n    static Scanner sc = new Scanner(System.in);\n\n    static int[][] d;\n\n    public static void main(String[] args) {\n        while (true) {\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            int s = sc.nextInt();\n            int g1 = sc.nextInt();\n            int g2 = sc.nextInt();\n            if (n == 0) break;\n\n            d = new int[n + 1][n + 1];\n\n            init(n);\n            scanRoad(m);\n            warshallFloyd(n);\n            calcCost(n, s, g1, g2);\n\n        }\n\n\n    }\n\n    static void warshallFloyd(int n) { // nは頂点数\n        for (int i = 1; i <= n; i++)      // 経由する頂点\n            for (int j = 1; j <= n; j++)    // 開始頂点\n                for (int k = 1; k <= n; k++)  // 終端\n                    d[j][k] = Math.min(d[j][k], d[j][i] + d[i][k]);\n    }\n\n    static void scanRoad(int m) {\n        for (int i = 0; i < m; i++) {\n            int b1 = sc.nextInt();\n            int b2 = sc.nextInt();\n            int c = sc.nextInt();\n\n            d[b1][b2] = c;\n        }\n    }\n\n    static void calcCost(int n, int s, int g1, int g2) {\n        int min = Integer.MAX_VALUE/10;\n        for (int i = 1; i <= n; i++) {\n            min = Math.min(min, d[s][i] + d[i][g1] + d[i][g2]);\n        }\n        System.out.println(min);\n    }\n\n    static void init(int n) {\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++) {\n                d[i][j] = Integer.MAX_VALUE / 10;\n                if(i==j) d[i][j]=0;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic int[][] d;\n\tstatic final int INF = 1 << 24;\n\n\tstatic Scanner scan = new Scanner(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\t\twhile(true){\n\t\t\tint n = si(),m = si(),s = si()-1,g1 = si()-1,g2 = si()-1;\n\t\t\tif(n==0) break;\n\t\t\td = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){Arrays.fill(d[i],INF); d[i][i] = 0;}\n\t\t\tfor (int i = 0; i < m; i++) d[si()-1][si()-1]=si();\n\t\t\twarshallFloyd(n);\n\t\t\tint mincost = INF;\n\t\t\tfor (int i = 0; i < n; i++) mincost = min(d[s][i]+d[i][g1]+d[i][g2],mincost);\n\t\t\tout.println(mincost);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic void warshallFloyd(int n){\n\t\tfor (int i = 0; i < n ; i++) {\n\t\t\tfor (int j = 0; j < n ; j++) {\n\t\t\t\tfor (int j2 = 0; j2 < n; j2++) {\n\t\t\t\t\td[j][j2] = min(d[j][j2],d[j][i]+d[i][j2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int si() {\n\t\treturn Integer.parseInt(scan.next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int n,m,s,g1,g2;\n    int[][] d;\n    int INF = 700000000;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    n = sc.nextInt();\n\t    m = sc.nextInt();\n\t    s = sc.nextInt();\n\t    g1 = sc.nextInt();\n\t    g2 = sc.nextInt();\n\t    if(n==0 && m==0 && s==0 && g1==0 && g2==0)break;\n\n\t    d = new int[m+1][m+1];\n\t    for(int i=0; i<m; i++) Arrays.fill(d[i],INF);\n\t    for(int i=0; i<m; i++){\n\t\tint b1 = sc.nextInt();\n\t\tint b2 = sc.nextInt();\n\t\tint c = sc.nextInt();\n\t\td[b1][b2] = c;\n\t    }\n\t    for(int i=0; i<m; i++) d[i][i] = 0;\n\n\t    warshall_floyd();\n\n\t    int min = INF;\n\t    for(int i=0; i<m; i++){\n\t\tmin = Math.min(min,d[s][i]+d[i][g1]+d[i][g2]);\n\t    }\n\t    System.out.println(min);\n\t}\n    }\n    \n    void warshall_floyd(){\n\tfor(int k=0; k<m; k++)\n\t    for(int i=0; i<m; i++)\n\t\tfor(int j=0; j<m; j++)d[i][j] = Math.min(d[i][j],d[i][k]+d[k][j]);\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif(n==0 && m==0 && s==0 && g1==0 && g2==0) break;\n\t\t\t\n\t\t\tint[] a = new int[m];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] c = new int[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] cost = new int[n+1][n+1];\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tint p;\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tq.offer(i);\n\t\t\t\tcost[i][i] = 0;\n\t\t\t\twhile(q.size()!=0){\n\t\t\t\t\tp = q.poll();\n\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\tif(a[j]==p && cost[i][a[j]]+c[j]<cost[i][b[j]]){\n\t\t\t\t\t\t\tcost[i][b[j]] = cost[i][a[j]] + c[j];\n\t\t\t\t\t\t\tq.offer(b[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tif(cost[i][g1]!=0 && cost[i][g2]!=0 && cost[i][g1]!=Integer.MAX_VALUE && cost[i][g2]!=Integer.MAX_VALUE){\n\t\t\t\t\tmin = Math.min(min, cost[s][i] + cost[i][g1] + cost[i][g2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal static int INT_MAX = 10000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] table = new int[n][n];\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\tint min = INT_MAX;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt();\n\t\t\t\tint b2 = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\t\ttable[i][j] = INT_MAX;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ttable[i][i] = 0;\n\t\t\tfor (int k = 0; k < n - 1; k++)\n\t\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tint num=0;\n\t\tint[] cc= new int[5];\n\t\tint n, m, s, g1, g2;\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(num<5){\n\t\t\tcc[num]=sc.nextInt();\n\t\t\tnum++;\n        }\n\t\tn=cc[0];\n\t\tm=cc[1];\n\t\ts=cc[2];\n\t\tg1=cc[3];\n\t\tg2=cc[4];\n\t\t\n\t\tint[][] road= new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\troad[i][j]=10000;\n\t\t\t}\n\t\t}\n\t\tnum=0;\n\t\twhile(true){\n\t\t\tint i=sc.nextInt();\n\t\t\tint j=sc.nextInt();\n\t\t\tint cost=sc.nextInt();\n\t\t\tif(i==0 && j==0){break;}\n\t\t\troad[i-1][j-1]=cost;\n\t\t\troad[j-1][i-1]=cost;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(road[i][j]>road[i][k]+road[k][j]){\n\t\t\t\t\t\troad[i][j]=road[i][k]+road[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r=10000;\n\t\tfor(int k=0;k<n;k++){\n\t\t\tif(r>road[k][s-1]+road[k][g1-1]+road[k][g2-1]){\n\t\t\t\tr=road[k][s-1]+road[k][g1-1]+road[k][g2-1];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(r);\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2005();\n\t}\n\tclass AOJ2005{\n\t\tAOJ2005(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt(),m=sc.nextInt(),s=sc.nextInt(),g1=sc.nextInt(),g2=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\t--s; --g1; --g2;\n\t\t\t\tsolve(n,m,s,g1,g2);\n\t\t\t}\n\t\t}\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tvoid solve(int n,int m,int s,int g1,int g2){\n\t\t\tint[][] g=new int[n][n];\n\t\t\tfor(int i=0; i<n; ++i)for(int j=0; j<n; ++j)\tg[i][j]=(i==j?0 :INF);\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt();\n\t\t\t\t--a; --b;\n\t\t\t\tg[a][b]=c;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0; j<n; ++j)for(int i=0; i<n; ++i)for(int k=0; k<n; ++k)g[i][k]=min(g[i][k], g[i][j]+g[j][k]);\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\tfor(int i=0; i<n; ++i)\tans=min(ans, g[s][i]+g[i][g1]+g[i][g2]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\n\t\tint n = 0;\n\t\tint m = 0;\n\t\tint s = 0;\n\t\tint g1 = 0;\n\t\tint g2 = 0;\n\n\t\tint last_cost = Integer.MAX_VALUE / 10;\n\n\t\twhile (true) {\n\t\t\tn = scan.nextInt();\n\t\t\tm = scan.nextInt();\n\t\t\ts = scan.nextInt();\n\t\t\tg1 = scan.nextInt();\n\t\t\tg2 = scan.nextInt();\n\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\ts--;\n\t\t\tg1--;\n\t\t\tg2--;\n\n\t\t\tint kithi1[] = new int[m];\n\t\t\tint kithi2[] = new int[m];\n\t\t\tint cost[][] = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i != j)\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tkithi1[i] = scan.nextInt();\n\t\t\t\tkithi2[i] = scan.nextInt();\n\t\t\t\tcost[kithi1[i] - 1][kithi2[i] - 1] = scan.nextInt();\n\t\t\t\tcost[kithi2[i] - 1][kithi1[i] - 1] = cost[kithi1[i] - 1][kithi2[i] - 1];\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (last_cost > cost[s][i] + cost[i][g1] + cost[i][g2])\n\t\t\t\t\tlast_cost = cost[s][i] + cost[i][g1] + cost[i][g2];\n\t\t\t}\n\n\t\t\tSystem.out.println(last_cost);\n\t\t}\n\t\tscan.close();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal static int INT_MAX = 10000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] table = new int[n][n];\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0)\n\t\t\t\tbreak;\n\t\t\tint min = INT_MAX;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt();\n\t\t\t\tint b2 = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\t\ttable[i][j] = INT_MAX;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ttable[i][i] = 0;\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tint[][] cost = new int[100][100];\n\t\tint INF = Integer.MAX_VALUE/2;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), s = sc.nextInt()-1, g1 = sc.nextInt()-1, g2 = sc.nextInt()-1;\n\t\t\tif (n == 0) break;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tcost[i][j] = INF;\n\t\t\t\tcost[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt()-1, b2 = sc.nextInt()-1, c = sc.nextInt();\n\t\t\t\tcost[b1][b2] = cost[b2][b1] = c;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = min(res, cost[s][i]+cost[i][g1]+cost[i][g2]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] street = new int[n + 1][n + 1];\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint cost;\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tstreet[j][i] = Integer.MAX_VALUE/10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m ; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tcost = sc.nextInt();\n\t\t\t\tstreet[x][y] = cost;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tstreet[i][i] = 0;\n\t\t\t\tfor(int j = 1; j < n + 1; j++){\n\t\t\t\t\tfor(int k = 1; k < n + 1; k++){\n\t\t\t\t\t\tstreet[j][k] = Math.min(street[j][k], street[j][i] + street[i][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = Integer.MAX_VALUE;\n\t\t\tfor(int i = 1; i < n + 1; i++){\n\t\t\t\tsum = Math.min(sum , street[s][i] + street[i][g1] + street[i][g2]);\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tint m = in.nextInt();\n\t\t\tint s = in.nextInt()-1;\n\t\t\tint g1 = in.nextInt()-1;\n\t\t\tint g2 = in.nextInt()-1;\n\t\t\tif(n == 0) break;\n\t\t\tint[][] edge = new int[n][n];\n//\t\t\tint[][] root = new int[n][n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n//\t\t\t\t\troot[i][j] = i;\n\t\t\t\t\tif(i==j) continue;\n\t\t\t\t\tedge[i][j] = Integer.MAX_VALUE/4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint b1 = in.nextInt()-1;\n\t\t\t\tint b2 = in.nextInt()-1;\n\t\t\t\tint c = in.nextInt();\n\t\t\t\tedge[b1][b2] = c;\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\t\tif(edge[j][k] > edge[j][i]+edge[i][k]){\n\t\t\t\t\t\t\tedge[j][k] = edge[j][i] + edge[i][k];\n//\t\t\t\t\t\t\troot[j][k] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = edge[s][g1] + edge[s][g2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tres = Math.min(res, edge[s][i]+edge[i][g1]+edge[i][g2]);\n\t\t\t}\n//\t\t\tLinkedList<Integer> list = rooting(root, s, g1);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g1] + edge[i][g2]);\n//\t\t\t}\n\t\t\t\n//\t\t\tlist = rooting(root, s, g2);\n//\t\t\tfor(int i: list){\n//\t\t\t\tres = Math.min(res, edge[s][g2] + edge[i][g1]);\n//\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static LinkedList<Integer> rooting(\n\t\t\tint[][] root, int s, int t){\n\t\tLinkedList<Integer> res = new LinkedList<Integer>();\n\t\trefound(root, s, t, res);\n\t\treturn res;\n\t}\n\t\n\tpublic static void refound(\n\t\t\tint[][] root, int s, int t\n\t\t\t, LinkedList<Integer> res){\n\t\tint center = root[s][t];\n\t\tif(s == center){\n\t\t\tres.add(t);\n\t\t\treturn;\n\t\t}\n\t\trefound(root, s, center, res);\n\t\trefound(root, center, t, res);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Water_Pipe {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint start = sc.nextInt();\n\t\tstart = start - 1;\n\t\tint goal1 = sc.nextInt();\n\t\tgoal1 = goal1 - 1;\n\t\tint goal2 = sc.nextInt();\n\t\tgoal2 = goal2 - 1;\n\t\tint road[][] = new int[N][N];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\troad[i][j] = Integer.MAX_VALUE / 10;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m;i++)\n\t\t{\n\t\t\tint j = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\troad[j-1][k-1] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\troad[i][i] = 0;\n\t\t}\n\n\t\t\tfor(int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tfor(int i = 0 ; i < N; i++)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < N;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint num = road[i][k] + road[k][j];\n\t\t\t\t\t\troad[i][j] = min(road[i][j],num);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tint min = 0;\n\t\tmin = road[start][goal1] + road[start][goal2];\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tint min_road = min(road[start][i] + road[i][goal1],road[start][i] + road[i][goal2]);\n\t\t\tmin_road = min_road + road[goal1][goal2];\n\t\t\tif(min > min_road)min = min(min,road[start][i] + min_road);\n\t\t}\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tint min_road = road[start][i] + road[i][goal1] + road[i][goal2];\n\t\t\tif(min > min_road)min = min_road;\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tprivate static int min(int i, int j) {\n\t\tif(i < j) return i;\n\t\telse return j;\n\t}\n\t\n\tprivate static int max(int i , int j)\n\t{\n\t\tif(i < j) return j;\n\t\telse return i;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n,m;\n\tint p[];\n\tint[][] map;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tmap = new int[n][n];\n\t\t\tp = new int[3];\n\t\t\tfor(int i=0;i<3;i++) p[i] = sc.nextInt();\n\t\t\tif( (n|m|p[0]|p[1]|p[2]) == 0 ) break;\n\t\t\tfor(int[] a: map) fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++) map[i][i] = 0;\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1;\n\t\t\t\tint b = sc.nextInt()-1;\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = min(map[i][j], map[i][k] + map[k][j]);\n\t\t\t}\n\t\t\tint min = INF;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint sum = map[p[0]-1][i];\n\t\t\t\tfor(int j=1;j<3;j++) {\n\t\t\t\t\tsum += map[i][p[j]-1];\n\t\t\t\t}\n\t\t\t\tmin = min(min, sum);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt() - 1;\n\t\t\tint g1 = sc.nextInt() - 1;\n\t\t\tint g2 = sc.nextInt() - 1;\n\t\t\tif ((n | m | s | g1 | g2) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] g = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(g[i], 1 << 20);\n\t\t\t\tg[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt() - 1;\n\t\t\t\tint v = sc.nextInt() - 1;\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tg[u][v] = w;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tg[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = g[s][g1] + g[s][g2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmin = Math.min(min, g[s][i] + g[i][g1] + g[i][g2]);\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal static int INT_MAX = 10000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] table = new int[n][n];\n\t\t\tint m = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint g1 = sc.nextInt();\n\t\t\tint g2 = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint min = INT_MAX;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint b1 = sc.nextInt();\n\t\t\t\tint b2 = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\ttable[b1 - 1][b2 - 1] = c;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tif (table[i][j] == 0)\n\t\t\t\t\t\ttable[i][j] = INT_MAX;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ttable[i][i] = 0;\n\t\t\tfor (int k = 0; k < n - 1; k++)\n\t\t\t\tfor (int i = 0; i < n - 1; i++)\n\t\t\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\t\t\ttable[i][j] = Math.min(table[i][j], table[i][k]\n\t\t\t\t\t\t\t\t+ table[k][j]);\n\t\t\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tmin = Math.min(min, table[s - 1][i] + table[i][g1 - 1]\n\t\t\t\t\t\t+ table[i][g2 - 1]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public const int INF = 999999999;\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            var s = int.Parse(line[2]);\n            var g1 = int.Parse(line[3]);\n            var g2 = int.Parse(line[4]);\n            if (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n            s--; g1--; g2--;\n            var dp = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (i != j) dp[i, j] = INF;\n            for (int i = 0; i < m; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                var b1 = int.Parse(line[0]) - 1;\n                var b2 = int.Parse(line[1]) - 1;\n                var c = int.Parse(line[2]);\n                dp[b1, b2] = c;\n            }\n            goWarshall(dp);\n            var ret = INF;\n            for (int i = 0; i < n; i++)\n                ret = Math.Min(ret, dp[s, i] + dp[i, g1] + dp[i, g2]);\n            Console.WriteLine(ret);\n        }\n    }\n    public static void goWarshall(int[,] dp)\n    {\n        var n = dp.GetLength(0);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                    dp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public const int INF = 999999999;\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            var s = int.Parse(line[2]);\n            var g1 = int.Parse(line[3]);\n            var g2 = int.Parse(line[4]);\n            if (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n            s--; g1--; g2--;\n            var dp = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (i != j) dp[i, j] = INF;\n            for (int i = 0; i < m; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                var b1 = int.Parse(line[0]) - 1;\n                var b2 = int.Parse(line[1]) - 1;\n                var c = int.Parse(line[2]);\n                dp[b1, b2] = c;\n            }\n            goWarshall(dp);\n            var ret = INF;\n            for (int i = 0; i < n; i++)\n                if (dp[s, i] != INF && dp[i, g1] != INF && dp[i, g2] != INF)\n                    ret = Math.Min(ret, dp[s, i] + dp[i, g1] + dp[i, g2]);\n            Console.WriteLine(ret);\n        }\n    }\n    public static void goWarshall(int[,] dp)\n    {\n        var n = dp.GetLength(0);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                    dp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public const int INF = 999999999;\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            var s = int.Parse(line[2]);\n            var g1 = int.Parse(line[3]);\n            var g2 = int.Parse(line[4]);\n            if (n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0) break;\n            s--; g1--; g2--;\n            var dp = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (i != j) dp[i, j] = INF;\n            for (int i = 0; i < m; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                var b1 = int.Parse(line[0]) - 1;\n                var b2 = int.Parse(line[1]) - 1;\n                var c = int.Parse(line[2]);\n                dp[b1, b2] = c;\n            }\n            goWarshall(dp);\n            var ret = INF;\n            for (int i = 0; i < n; i++)\n                if (i != s && i != g1 && i != g2 && dp[s, i] != INF && dp[i, g1] != INF && dp[i, g2] != INF)\n                    ret = Math.Min(ret, dp[s, i] + dp[i, g1] + dp[i, g2]);\n            Console.WriteLine(ret);\n        }\n    }\n    public static void goWarshall(int[,] dp)\n    {\n        var n = dp.GetLength(0);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                    dp[j, k] = Math.Min(dp[j, k], dp[j, i] + dp[i, k]);\n    }\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/06.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main() {\n  var temp,\n      n, m, s , g1, g2,\n      d,\n      i, j, k,\n      cost;\n  while (true) {\n    temp = input.shift().split(' ');\n    n = +temp[0];\n    m = +temp[1];\n    s = temp[2] - 1;\n    g1 = temp[3] - 1;\n    g2 = temp[4] - 1;\n    if(n===0 && m===0){\n      break\n    }\n    d = [];\n    for (i = 0; i < n; i++) {\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        d[i][j] = i === j ? 0 : Infinity;\n      }\n    }\n    for (i = 0; i < m; i++) {\n      temp = input.shift().split(' ');\n      d[temp[0] - 1][temp[1] - 1] = +temp[2];\n    }\n\n    for (k = 0; k < n; k++) {\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          d[i][j] = d[i][j] > d[i][k] + d[k][j] ? d[i][k] + d[k][j] : d[i][j];\n        }\n      }\n    }\n    cost = Infinity;\n    for (k = 0; k < n; k++) {\n      cost = Math.min(cost, d[s][k] + d[k][g1] + d[k][g2]);\n    }\n    console.log(cost);\n  }\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/06.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main() {\n  var temp = input.shift().split(' '),\n      n = +temp[0],\n      m = +temp[1],\n      s = temp[2] - 1,\n      g1 = temp[3] - 1,\n      g2 = temp[4] - 1,\n      d = [], i, j,k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : 1e+10;\n    }\n  }\n  for(i=0;i<m;i++){\n    temp = input[i].split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n//  while (m/*input[0] !== '0 0 0 0 0'*/) {\n//    temp = input.shift().split(' ');\n//    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n//  }\n  for (k = 0; k < n; k++){\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if(d[i][j] > d[i][k] + d[k][j]){\n          d[i][j] = d[i][k] + d[k][j];\n        }\n      }\n    }\n  }\n//  console.log(d);\n\n  var cost = 1e+10;\n  for (k = 0; k < n; k++){\n    if(cost > d[s][k] + d[k][g1] + d[k][g2]){\n      cost = d[s][k] + d[k][g1] + d[k][g2];\n    }\n\n  }\n  console.log(cost);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\n//var fs = require('fs'),\n//    length = fs.fstatSync(process.stdin.fd).size,\n//    buffer = new Buffer(length),\n//    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n//    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  var firstLine = input.shift().split(' '),\n      n = +firstLine[0],\n      m = +firstLine[1],\n      s = firstLine[2] - 1,\n      g1 = firstLine[3] - 1,\n      g2 = firstLine[4] - 1,\n      d = [],\n      temp,\n      i, j, k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n\n  while (m--) {\n    temp = input.shift().split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  var res = Infinity;\n  for (i = 0; i < n; i++) {\n    res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n  }\n  console.log(res);\n\n});"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar firstLine = input[0].split(' '),\n    n = +firstLine[0],\n    m = +firstLine[1],\n    s = +firstLine[2] - 1,\n    g1 = +firstLine[3] - 1,\n    g2 = +firstLine[4] - 1,\n    d = new Array(n),\n    temp,\n    i, j, k;\nfor (i = 0; i < n; i++) {\n  d[i] = new Array(n);\n  for (j = 0; j < n; j++) {\n    d[i][j] = i === j ? 0 : Infinity;\n  }\n}\n\ni = 1;\nwhile (i <= m) {\n  temp = input[i].split(' ');\n  d[temp[0] - 1][temp[1] - 1] = d[temp[1] - 1][temp[0] - 1] = +temp[2];\n  i++;\n}\n\nfor (k = 0; k < n; k++) {\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n}\n\nvar res = Infinity;\nfor (i = 0; i < n; i++) {\n  res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n}\nconsole.log(res);"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\n//var fs = require('fs'),\n//    length = fs.fstatSync(process.stdin.fd).size,\n//    buffer = new Buffer(length),\n//    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n//    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  var firstLine = input.shift().split(' '),\n      n = +firstLine[0],\n      m = +firstLine[1],\n      s = firstLine[2] - 1,\n      g1 = firstLine[3] - 1,\n      g2 = firstLine[4] - 1,\n      d = [],\n      temp,\n      i, j, k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n\n  while (input[0] !== '0 0 0 0 0') {\n    temp = input.shift().split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  var res = Infinity;\n  for (i = 0; i < n; i++) {\n    res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n  }\n  console.log(res);\n\n});"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar firstLine = input[0].split(' '),\n    n = +firstLine[0],\n    m = +firstLine[1],\n    s = +firstLine[2] - 1,\n    g1 = +firstLine[3] - 1,\n    g2 = +firstLine[4] - 1,\n    costs,\n    d = new Array(n),\n    temp,\n    i, j, k;\nfor (i = 0; i < n; i++) {\n  d[i] = new Array(n);\n  for (j = 0; j < n; j++) {\n    d[i][j] = i === j ? 0 : Infinity;\n  }\n}\ni = 1;\nwhile (input[i] !== '0 0 0 0 0') {\n  temp = input[i].split(' ');\n  d[temp[0] - 1][temp[1] - 1] = d[temp[1] - 1][temp[0] - 1] = +temp[2];\n  i++;\n}\nfor (k = 0; k < n; k++) {\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n}\nvar res = Infinity;\nfor (i = 0; i < n; i++) {\n  res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n}\nconsole.log(res);"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar firstLine = input.shift().split(' '),\n    n = +firstLine[0],\n    m = +firstLine[1],\n    s = firstLine[2] - 1,\n    g1 = firstLine[3] - 1,\n    g2 = firstLine[4] - 1,\n    d = [],\n    temp,\n    i, j, k;\nfor (i = 0; i < n; i++) {\n  d[i] = [];\n  for (j = 0; j < n; j++) {\n    d[i][j] = i === j ? 0 : Infinity;\n  }\n}\n\nwhile (m--) {\n  temp = input.shift().split(' ');\n  d[temp[0] - 1][temp[1] - 1] = +temp[2];\n}\n\nfor (k = 0; k < n; k++) {\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n}\n\nvar res = Infinity;\nfor (i = 0; i < n; i++) {\n  res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n}\nconsole.log(res);"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar firstLine = input[0].split(' '),\n    n = +firstLine[0],\n    m = +firstLine[1],\n    s = +firstLine[2] - 1,\n    g1 = +firstLine[3] - 1,\n    g2 = +firstLine[4] - 1,\n    d = new Array(n),\n    temp,\n    i, j, k;\nfor (i = 0; i < n; i++) {\n  d[i] = new Array(n);\n  for (j = 0; j < n; j++) {\n    d[i][j] = i === j ? 0 : Infinity;\n  }\n}\n\ni = 1;\nwhile (i <= m) {\n  temp = input[i].split(' ');\n  d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  i++;\n}\n\nfor (k = 0; k < n; k++) {\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n}\n\nvar res = Infinity;\nfor (i = 0; i < n; i++) {\n  res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n}\nconsole.log(res);"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/06.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main() {\n  var temp = input.shift().split(' '),\n      n = +temp[0],\n      m = +temp[1],\n      s = temp[2] - 1,\n      g1 = temp[3] - 1,\n      g2 = temp[4] - 1,\n      d = [], i, j, k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n  for (i = 0; i < m; i++) {\n    temp = input[i].split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n//  while (m/*input[0] !== '0 0 0 0 0'*/) {\n//    temp = input.shift().split(' ');\n//    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n//  }\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j])\n      }\n    }\n  }\n//  console.log(d);\n\n  var cost = Infinity;\n  for (k = 0; k < n; k++) {\n    cost = Math.min(cost, d[s][k] + d[k][g1] + d[k][g2]);\n  }\n  console.log(cost);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\n\nvar firstLine = input.shift().split(' '),\n    n = +firstLine[0],\n    m = +firstLine[1],\n    s = firstLine[2] - 1,\n    g1 = firstLine[3] - 1,\n    g2 = firstLine[4] - 1,\n    d = [],\n    temp,\n    i, j, k;\nfor (i = 0; i < n; i++) {\n  d[i] = [];\n  for (j = 0; j < n; j++) {\n    d[i][j] = i === j ? 0 : Infinity;\n  }\n}\n\nwhile (input[0] !== '0 0 0 0 0') {\n  temp = input.shift().split(' ');\n  d[temp[0] - 1][temp[1] - 1] = +temp[2];\n}\n\nfor (k = 0; k < n; k++) {\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n    }\n  }\n}\n\nvar res = Infinity;\nfor (i = 0; i < n; i++) {\n  res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n}\nconsole.log(res);"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\n//var fs = require('fs'),\n//    length = fs.fstatSync(process.stdin.fd).size,\n//    buffer = new Buffer(length),\n//    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n//    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nvar stdin = '', input;\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function (chunk) {\n  stdin += chunk;\n});\nprocess.stdin.on('end', function () {\n  input = stdin.split('\\n');\n  main();\n});\nfunction main() {\n  var firstLine = input[0].split(' '),\n      n = +firstLine[0],\n      m = +firstLine[1],\n      s = +firstLine[2] - 1,\n      g1 = +firstLine[3] - 1,\n      g2 = +firstLine[4] - 1,\n      d = new Array(n),\n      temp,\n      i, j, k;\n  for (i = 0; i < n; i++) {\n    d[i] = new Array(n);\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n\n  i = 1;\n  while (i <= m) {\n    temp = input[i].split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n    i++;\n  }\n\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  var res = Infinity;\n  for (i = 0; i < n; i++) {\n    res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n  }\n  console.log(res);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/06.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main() {\n  var temp = input.shift().split(' '),\n      n = +temp[0],\n      m = +temp[1],\n      s = temp[2] - 1,\n      g1 = temp[3] - 1,\n      g2 = temp[4] - 1,\n      d = [], i, j,k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : 1e+10;\n    }\n  }\n  while (m--/*input[0] !== '0 0 0 0 0'*/) {\n    temp = input.shift().split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n  for (k = 0; k < n; k++){\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if(d[i][j] > d[i][k] + d[k][j]){\n          d[i][j] = d[i][k] + d[k][j];\n        }\n      }\n    }\n  }\n//  console.log(d);\n\n  var cost = 1e+10;\n  for (k = 0; k < n; k++){\n    if(cost > d[s][k] + d[k][g1] + d[k][g2]){\n      cost = d[s][k] + d[k][g1] + d[k][g2];\n    }\n\n  }\n  console.log(cost);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/06.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main() {\n  var temp = input.shift().split(' '),\n      n = +temp[0],\n      m = +temp[1],\n      s = temp[2] - 1,\n      g1 = temp[3] - 1,\n      g2 = temp[4] - 1,\n      d = [], i, j,k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n  while (m--/*input[0] !== '0 0 0 0 0'*/) {\n    temp = input.shift().split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n  for (k = 0; k < n; k++){\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if(d[i][j] > d[i][k] + d[k][j]){\n          d[i][j] = d[i][k] + d[k][j];\n        }\n      }\n    }\n  }\n//  console.log(d);\n\n  var cost = Infinity;\n  for (k = 0; k < n; k++){\n    if(cost > d[s][k] + d[k][g1] + d[k][g2]){\n      cost = d[s][k] + d[k][g1] + d[k][g2];\n    }\n\n  }\n  console.log(cost);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/03.\n */\n//var fs = require('fs'),\n//    length = fs.fstatSync(process.stdin.fd).size,\n//    buffer = new Buffer(length),\n//    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n//    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  var firstLine = input.shift().split(' '),\n      n = +firstLine[0],\n      m = +firstLine[1],\n      s = firstLine[2] - 1,\n      g1 = firstLine[3] - 1,\n      g2 = firstLine[4] - 1,\n      d = [],\n      temp,\n      i, j, k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n\n  while (input[0] != '0 0 0 0 0') {\n    temp = input.shift().split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n\n  for (k = 0; k < n; k++) {\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);\n      }\n    }\n  }\n\n  var res = Infinity;\n  for (i = 0; i < n; i++) {\n    res = Math.min(res, d[s][i] + d[i][g1] + d[i][g2]);\n  }\n  console.log(res);\n\n});"
  },
  {
    "language": "JavaScript",
    "code": "/**\n * Created by hiroqn on 13/10/06.\n */\nvar fs = require('fs'),\n    length = fs.fstatSync(process.stdin.fd).size,\n    buffer = new Buffer(length),\n    bytesRead = fs.readSync(process.stdin.fd, buffer, 0, length, 0),\n    input = buffer.toString('utf8', 0, bytesRead).split('\\n');\nmain();\nfunction main() {\n  var temp = input.shift().split(' '),\n      n = +temp[0],\n      m = +temp[1],\n      s = temp[2] - 1,\n      g1 = temp[3] - 1,\n      g2 = temp[4] - 1,\n      d = [], i, j,k;\n  for (i = 0; i < n; i++) {\n    d[i] = [];\n    for (j = 0; j < n; j++) {\n      d[i][j] = i === j ? 0 : Infinity;\n    }\n  }\n  while (input[0] !== '0 0 0 0 0') {\n    temp = input.shift().split(' ');\n    d[temp[0] - 1][temp[1] - 1] = +temp[2];\n  }\n  for (k = 0; k < n; k++){\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if(d[i][j] > d[i][k] + d[k][j]){\n          d[i][j] = d[i][k] + d[k][j];\n        }\n      }\n    }\n  }\n//  console.log(d);\n\n  var cost = Infinity;\n  for (k = 0; k < n; k++){\n    if(cost > d[s][k] + d[k][g1] + d[k][g2]){\n      cost = d[s][k] + d[k][g1] + d[k][g2];\n    }\n\n  }\n  console.log(cost);\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                next\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                min = [cost[i][k] + cost[k][j], cost[i][j]].min\n                cost[i][j] = min\n            end\n        end\n    end\n    min = 10000001\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    r\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\nnext\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    min = 10000001\n    p cost\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 2 << 32\nuntil (n, m, s, g1, g2 = gets.split(' ').map(&:to_i)).all?(&:zero?)\n  cost = (n + 1).times.map {|i|\n    a = Array.new(n + 1, INF)\n    a[i] = 0\n    a\n  }\n\n  m.times\n    .lazy\n    .map { gets.split(' ').map(&:to_i) }\n    .each {|(b1, b2, c)| cost[b1][b2] = c }\n\n  nr = 1..n\n  nr.each {|k|\n    nr.each {|i|\n      nr.each {|j|\n        cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n      }\n    }\n  }\n\n  min = INF\n  nr.each {|k|\n    min = [min, cost[s][k] + cost[k][g1] + cost[k][g2]].min\n  }\n  puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    puts -1\n    next\n    for k in 1..n\n        for i in 1..n\n            for j in 1..n\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    next\n    min = 10000001\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    p cost\n    for k in 1..n\n        for i in 1..n\n            for j in 1..n\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    p cost\n    min = 10000001\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(cost)\n    for k in 0..(cost.length - 1)\n        for i in 0..(cost.length - 1)\n            for j in 0..(cost.length - 1)\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    return cost\nend\nloop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 && m == 0 && s == 0\n    cost = Array.new(n+1).map{Array.new(n+1, Float::INFINITY)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    cost = warshall_floyd(cost)\n    min = Float::INFINITY\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 2 << 32\nuntil (n, m, s, g1, g2 = gets.split(' ').map(&:to_i)).all?(&:zero?)\n  cost = (m + 1).times.map {|i|\n    a = Array.new(m + 1, INF)\n    a[i] = 0\n    a\n  }\n\n  m.times\n    .lazy\n    .map { gets.split(' ').map(&:to_i) }\n    .each {|b1, b2, c| cost[b1][b2] = c }\n\n  nr = 1..n\n  nr.each {|i|\n    nr.each {|j|\n      nr.each {|k|\n        cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n      }\n    }\n  }\n\n  min = INF\n  nr.each {|k|\n    min = [min, cost[s][k] + cost[k][g1] + cost[k][g2]].min\n  }\n  puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    for k in 1..n\n        for i in 1..n\n            for j in 1..n\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    puts 1\n    next\n    min = 10000001\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(cost)\n    for k in 0..(cost.length - 1)\n        for i in 0..(cost.length - 1)\n            for j in 0..(cost.length - 1)\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    return cost\nend\nloop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, Float::INFINITY)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    cost = warshall_floyd(cost)\n    min = Float::INFINITY\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, Float::INFINITY)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    p cost\n    for k in 1...cost.length\n        for i in 1...cost.length\n            for j in 1...cost.length\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    min = Float::INFINITY\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(pos, route, cost)\n  arr = [pos]\n  dist = [INF]*($n+1)\n  dist[pos] = 0\n  until arr.empty?\n    a = arr.min{ |x, y| dist[x] <=> dist[y] }\n    arr.delete(a)\n    route[a].each do |b|\n      d = dist[a] + cost[a][b]\n      if (old = dist[b]) > d\n        dist[b] = d\n        if old == INF\n          arr << b \n        end\n      end\n    end\n  end\n  dist\nend\n\nwhile l = gets\n  $n, m, s, g1, g2 = l.split.map(&:to_i)\n  break if $n == 0\n  route = ($n+1).times.map{ [] }\n  r_route = ($n+1).times.map{ [] }\n  cost = ($n+1).times.map{ [0]*($n+1) }\n  m.times do\n    b1, b2, c = gets.split.map(&:to_i)\n    route[b1] << b2; r_route[b2] << b1\n    cost[b1][b2] = cost[b2][b1] = c\n  end\n  dist_s = dijkstra(s, route, cost)\n  dist_g1 = dijkstra(g1, r_route, cost)\n  dist_g2 = dijkstra(g2, r_route, cost)\n  res = INF\n  (1..$n).each{ |i| res = [res, dist_s[i] + dist_g1[i] + dist_g2[i]].min }\n  p res\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                next\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    min = 10000001\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    r\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\nnext\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    min = 10000001\n    p cost\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = cost[i][k] + cost[k][j] if cost[i][k] + cost[k][j] < cost[i][j]\n            end\n        end\n    end\n    min = 10000001\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, Float::INFINITY)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    for k in 1..cost.length\n        for i in 1..cost.length\n            for j in 1..cost.length\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    min = 10000001\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    r\n    g1 -= 1\n    g2 -= 1\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    next\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    min = 10000001\n    p cost\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "MAX_COST = 100000\nuntil (n, m, s, g1, g2 = gets.split.map(&:to_i)).all?(&:zero?)\n  s -= 1\n  g1 -= 1\n  g2 -= 1\n  matrix = Array.new(n){Array.new(n){MAX_COST}}\n  n.times do |i|\n    matrix[i][i] = 0\n  end\n  m.times do\n    b1, b2, c = gets.split.map(&:to_i)\n    b1 -= 1\n    b2 -= 1\n    matrix[b1][b2] = matrix[b2][b1] = c\n  end\n  n.times do |via|\n    n.times do |start|\n      n.times do |goal|\n        matrix[start][goal] = [matrix[start][goal], matrix[start][via] + matrix[via][goal]].min\n      end\n    end\n  end\n  answer = MAX_COST\n  n.times do |via|\n    answer = [answer, matrix[s][via] + matrix[via][g1] + matrix[via][g2]].min\n  end\n  p answer\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    r\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\nnext\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\nnext\n    min = 10000001\n    p cost\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    min = 10000001\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 2 << 32\nuntil (n, m, s, g1, g2 = gets.split(' ').map(&:to_i)).all?(&:zero?)\n  cost = (n + 1).times.map {|i|\n    a = Array.new(n + 1, INF)\n    a[i] = 0\n    a\n  }\n \n  m.times\n    .lazy\n    .map { gets.split(' ').map(&:to_i) }\n    .each {|(b1, b2, c)| cost[b1][b2] = c }\n \n  nr = 1..n\n  nr.each {|k|\n    nr.each {|i|\n      nr.each {|j|\n        cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n      }\n    }\n  }\n \n  min = INF\n  nr.each {|k|\n    min = [min, cost[s][k] + cost[k][g1] + cost[k][g2]].min\n  }\n  puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 && m == 0 && s == 0 && g1 == 0 && g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, Float::INFINITY)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    for k in 1..n\n        for i in 1..n\n            for j in 1..n\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    min = Float::INFINITY\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(pos, route, cost)\n  arr = [pos]\n  dist = [INF]*($n+1)\n  dist[pos] = 0\n  until arr.empty?\n    a = arr.min{ |x, y| dist[x] <=> dist[y] }\n    arr.delete(a)\n    route[a].each do |b|\n      d = dist[a] + cost[a][b]\n      if (old = dist[b]) > d\n        dist[b] = d\n        if old == INF\n          arr << b \n        end\n      end\n    end\n  end\n  dist\nend\n\nwhile l = gets\n  $n, m, s, g1, g2 = l.split.map(&:to_i)\n  break if $n == 0\n  route = ($n+1).times.map{ [] }\n  r_route = ($n+1).times.map{ [] }\n  cost = ($n+1).times.map{ [0]*($n+1) }\n  r_cost = ($n+1).times.map{ [0]*($n+1) }\n  m.times do\n    b1, b2, c = gets.split.map(&:to_i)\n    route[b1] << b2; r_route[b2] << b1\n    cost[b1][b2] = c\n    r_cost[b2][b1] = c\n  end\n  dist_s = dijkstra(s, route, cost)\n  dist_g1 = dijkstra(g1, r_route, r_cost)\n  dist_g2 = dijkstra(g2, r_route, r_cost)\n  res = INF\n  (1..$n).each{ |i| res = [res, dist_s[i] + dist_g1[i] + dist_g2[i]].min }\n  p res\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    cost = Array.new(n+1).map{Array.new(n+1, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]][d[1]] = d[2]\n    end\n    for k in 1..n\n        for i in 1..n\n            for j in 1..n\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n                if i == j\n                    cost[i][j] = 0\n                end\n            end\n        end\n    end\n    min = 10000001\n    1.upto(n) do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    r\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    next\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\n    min = 10000001\n    p cost\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop {\n    n, m, s, g1, g2 = gets.split.map &:to_i\n    break if n == 0\n    cost = (1..n).map{ [Float::INFINITY] * n }  \n    (0..n-1).each{|i| cost[i][i] = 0}\n    m.times {\n        i, j, c = gets.split.map &:to_i\n        cost[i-1][j-1] = c\n    }\n    (0..n-1).each{|k|\n        next_cost = (1..n).map{ Array.new(n) }  \n        (0..n-1).each{|i|\n            (0..n-1).each{|j|\n                x = cost[i][j]\n                y = cost[i][k] + cost[k][j]\n                next_cost[i][j] = (x < y ? x : y)\n            }   \n        }       \n        cost = next_cost\n    }   \n    p (0..n-1).map{|k| cost[s-1][k] + cost[k][g1-1] + cost[k][g2-1]}.min\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                min = [cost[i][k] + cost[k][j], cost[i][j]].min\n                cost[i][j] = min\n            end\n        end\n    end\n    min = 10000001\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    n, m, s, g1, g2 = gets.split.map(&:to_i)\n    break if n == 0 || m == 0 || s == 0 || g1 == 0 || g2 == 0\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    cost = Array.new(n).map{Array.new(n, 10000001)}\n    m.times do\n        d = gets.split.map(&:to_i)\n        cost[d[0]-1][d[1]-1] = d[2]\n    end\n    n.times do |k|\n        n.times do |i|\n            n.times do |j|\n                if i == j\n                    cost[i][j] = 0\n                    next\n                end\n                cost[i][j] = [cost[i][j], cost[i][k] + cost[k][j]].min\n            end\n        end\n    end\nnext\n    min = 10000001\n    n.times do |i|\n        min = [min, cost[s][i] + cost[i][g1] + cost[i][g2]].min\n    end\n    puts min\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj2005_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t        \t//INFだったらスルー。これで劇的に早くなる。\n\t        \tif ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue;\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0 && $m==0 && $s==0 && $g1==0 && $g2==0) break;\n\t\n\t//初期化\n\t$cost = array();\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t//INFのものがあればスルー\n\t\tif ($cost[$s][$i]===INF || $cost[$i][$g1]===INF || $cost[$i][$g2]===INF) continue;\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min;\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj2005_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0 && $m==0 && $s==0 && $g1==0 && $g2==0) break;\n\t\n\t//初期化\n\t$cost = array();\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min;\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj2005_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t        \t//INFだったらスルー\n\t        \tif ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue;\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0 && $m==0 && $s==0 && $g1==0 && $g2==0) break;\n\t\n\t//初期化\n\t$cost = array();\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min;\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj2005_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t        \t//INFだったらスルー。これで劇的に早くなる。\n\t        \tif ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue;\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0) break;\n\t\n\t//初期化\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min.PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t        \t//INFだったらスルー。これで劇的に早くなる。\n\t        \tif ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue;\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0) break;\n\t\n\t//初期化\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$e = explode(' ', $info2);\n\t\t$cost[$e[0]][$e[1]] = $e[2];\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min.PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj2005_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t        \t//INFだったらスルー。これで劇的に早くなる。\n\t        \tif ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue;\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0) break;\n\t\n\t//初期化\n\t$cost = array();\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min;\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t        \t//INFだったらスルー。これで劇的に早くなる。\n\t        \tif ($cost[$j][$i]===INF || $cost[$i][$k]===INF) continue;\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0) break;\n\t\n\t//初期化\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$via = $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2];\n\t\t$min = min($min, $via);\n\t}\n\t\n\t//出力\n\techo $min.PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "PHP",
    "code": "<?php\n//ワーシャルフロイド（全点対最短路問題）\n//スタート地点１つに対してゴールが２つ。流れるものは水\n//故に、単純に $cost[$s][$g1] + $cost[$s][$g2] とするとWA\n//スタート〜ある点までは合流道。ある点〜それぞれのゴールまでは二股に分かれて進むイメージ\n//また、有向グラフ（一方通行）なので注意。\n//と言ってもむしろ$cost[$b][$a] = $cost[$a][$b]というコピーが不要になるので楽。\n\n\n$file_handle = fopen('php://stdin', \"r\");\n//$file_handle = fopen('aoj2005_in.txt', \"r\");\n\n\nfunction warshall_floyd($cost) {\n\tglobal $n;\n\n\tfor ($i = 1; $i <= $n; ++$i) {\n\t    for ($j = 1; $j <= $n; ++$j) {\n\t        for ($k = 1; $k <= $n; ++$k) {\n\t            // j -> kへ行くのにiを経由した方が良いかどうか(cost)\n\t            $via = $cost[$j][$i] + $cost[$i][$k];\n\t            if ($via < $cost[$j][$k]) {\n\t                $cost[$j][$k] = $via;\n\t            }\n\t        }\n\t    }\n\t}\n\treturn $cost;\n}\n\n\nwhile(1){\n\t//ファイル読み込み\n\t$info = trim(fgets($file_handle));\n\t$explode = explode(' ', $info);\n\t$n = $explode[0]; $m = $explode[1]; $s = $explode[2]; $g1 = $explode[3]; $g2 = $explode[4];\n\t//終了条件\n\tif ($n==0 && $m==0 && $s==0 && $g1==0 && $g2==0) break;\n\t\n\t//初期化\n\t$cost = array();\n\n\t//ワーシャルフロイド準備。\n\tfor ($i=1; $i<=$n; ++$i){\n\t\tfor ($j=1; $j<=$n; ++$j){\n\t\t\tif ($i === $j){\n\t\t\t\t$cost[$i][$i] = 0;\n\t\t\t} else {\n\t\t\t\t$cost[$i][$j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\t//辺の情報を格納\n\tfor ($i=1; $i<=$m; ++$i){\n\t\t$info2 = trim(fgets($file_handle));\n\t\t$explode = explode(' ', $info2);\n\t\t$a = $explode[0]; $b = $explode[1]; $c = $explode[2];\n\t\t$cost[$a][$b] = $c;\n\t}\n\n\t//探索。先に全点対最短路を求めておく必要がある\n\t$cost = warshall_floyd($cost);\n\t\n\t//最小値計算\n\t$min = INF;\n\tfor($i=1; $i<=$n; ++$i){\n\t\t//どこで分岐するのが最も総コストが低いか比較\n\t\t$min = min($min, $cost[$s][$i] + $cost[$i][$g1] + $cost[$i][$g2]);\n\t}\n\t\n\t//出力\n\techo $min;\n\techo PHP_EOL;\n}\n\nfclose($file_handle);"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\n\nvoid main() {\n\tauto r1 = readInts();\n\tint n = r1[0];\n\tint m = r1[1];\n\tint s = r1[2];\n\tauto g = r1[3..$];\n\twhile(n) {\n\t\tauto d = new int[][](100,100);\n\t\tforeach(di; d){\n\t\t\tdi.fill(int.max/1000);\n\t\t}\n\t\tforeach(i; 0..m) {\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tforeach(i; 0..m) {\n\t\t\tauto r2 = readInts();\n\t\t\td[r2[0]][r2[1]] = r2[2];\n\t\t}\n\t\tforeach(k; 0..n) {\n\t\t\tforeach(i; 0..n) {\n\t\t\t\tforeach(j; 0..n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = int.max;\n\t\tforeach(i; 0..n) {\n\t\t\tans = min(ans, d[s][i] + d[i][g[0]] + d[i][g[1]]);\n\t\t}\n\t\twriteln(ans);\n\t\tr1 = readInts();\n\t\tn = r1[0];\n\t\tm = r1[1];\n\t\ts = r1[2];\n\t\tg = r1[3..$];\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nbool solve() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto M = s[1];\n    auto S = s[2]-1;\n    auto G1 = s[3]-1;\n    auto G2 = s[4]-1;\n    if (N == 0) return false;\n\n    auto D = new int[][](N, N);\n    foreach (i; 0..N) foreach (j; 0..N) D[i][j] = i == j ? 0 : 1 << 29;\n\n    foreach (i; 0..M) {\n        s = readln.split.map!(to!int);\n        D[s[0]-1][s[1]-1] = s[2];\n    }\n\n    foreach (i; 0..N)\n        foreach (j; 0..N)\n            foreach (k; 0..N)\n                D[j][k] = min(D[j][k], D[j][i] + D[i][k]);\n\n    N.iota.map!(i => D[S][i] + D[i][G1] + D[i][G2]).reduce!min.writeln;\n\n    return true;\n}\n\nvoid main() {\n    while (solve()) {}\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\n\nvoid main() {\n\tauto r1 = readInts();\n\tint n = r1[0];\n\tint m = r1[1];\n\tint s = r1[2];\n\tauto g = r1[3..$];\n\twhile(n) {\n\t\tauto d = new int[][](101,101);\n\t\tforeach(di; d){\n\t\t\tdi.fill(int.max/1000);\n\t\t}\n\t\tforeach(i; 0..n) {\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tforeach(i; 0..m) {\n\t\t\tauto r2 = readInts();\n\t\t\td[r2[0]][r2[1]] = r2[2];\n\t\t}\n\t\tforeach(k; 0..n) {\n\t\t\tforeach(i; 0..n) {\n\t\t\t\tforeach(j; 0..n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = int.max;\n\t\tforeach(i; 0..n) {\n\t\t\tans = min(ans, d[s][i] + d[i][g[0]] + d[i][g[1]]);\n\t\t}\n\t\twriteln(ans);\n\t\tr1 = readInts();\n\t\tn = r1[0];\n\t\tm = r1[1];\n\t\ts = r1[2];\n\t\tg = r1[3..$];\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\n\nvoid main() {\n\tauto r1 = readInts();\n\tr1[2..$] -= 1;\n\tint n = r1[0];\n\tint m = r1[1];\n\tint s = r1[2];\n\tauto g = r1[3..$];\n\twhile(n) {\n\t\tauto d = new int[][](101,101);\n\t\tforeach(di; d){\n\t\t\tdi.fill(int.max/1000);\n\t\t}\n\t\tforeach(i; 0..n) {\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tforeach(i; 0..m) {\n\t\t\tauto r2 = readInts();\n\t\t\tr2[0..2] -= 1;\n\t\t\td[r2[0]][r2[1]] = r2[2];\n\t\t}\n\t\tforeach(k; 0..n) {\n\t\t\tforeach(i; 0..n) {\n\t\t\t\tforeach(j; 0..n) {\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = int.max;\n\t\tforeach(i; 0..n) {\n\t\t\tans = min(ans, d[s][i] + d[i][g[0]] + d[i][g[1]]);\n\t\t}\n\t\twriteln(ans);\n\t\tr1 = readInts();\n\t\tr1[2..$] -= 1;\n\t\tn = r1[0];\n\t\tm = r1[1];\n\t\ts = r1[2];\n\t\tg = r1[3..$];\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n\n    while True:\n        n,m,s,g1,g2 = LI()\n        if n == 0:\n            break\n        e = collections.defaultdict(list)\n        for _ in range(m):\n            a,b,c = LI()\n            e[a].append((b,c))\n            e[b].append((a,c))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        sd = search(s)\n        r = inf\n        for i in range(1,n+1):\n            td = search(i)\n            tr = sd[i] + td[g1] + td[g2]\n            if r > tr:\n                r = tr\n\n        rr.append(r)\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def floyd(n,L):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                L[i][j]=min(L[i][j],L[i][k]+L[k][j])\n\nwhile True:\n    n,m,s,g1,g2=map(int,raw_input().split())\n    if n==0:break\n    s-=1\n    g1-=1\n    g2-=1\n    INF=1e10\n    L=[[INF]*n for i in range(n)]\n    for i in range(n):\n        L[i][i]=0\n    for i in range(m):\n        b1,b2,c=map(int,raw_input().split())\n        b1-=1\n        b2-=1\n        L[b1][b2]=c\n    floyd(n,L)\n    ans=INF\n    for i in range(n):\n        ans=min(ans,L[s][i]+L[i][g1]+L[i][g2])\n    print ans"
  },
  {
    "language": "Python",
    "code": "while True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 10 ** 5\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        b1, b2, c = map(int, input().split())\n        b1, b2 = b1 - 1, b2 - 1\n        D[b1][b2] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if D[i][j] > D[i][k] + D[k][j]:\n                    D[i][j] = D[i][k] + D[k][j]\n    print(min(D[s][i] + D[i][g1] + D[i][g2] for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop,heappush\n\ndef dijkstra(s):\n    d = [float(\"inf\") for i in range(n)]\n    d[s] = 0\n    q = [(0,s)]\n    while q:\n        dx,x = heappop(q)\n        for c,y in v[x]:\n            if dx+c < d[y]:\n                d[y] = dx+c\n                heappush(q,(d[y],y))\n    return d\n\nwhile 1:\n    n,m,s,g1,g2 = map(int, input().split())\n    if n == m == s == g1 == g2 == 0:\n        break\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    v = [[] for i in range(n)]\n    for i in range(m):\n        a,b,c = map(int, input().split())\n        v[a-1].append((c,b-1))\n    d = [dijkstra(i) for i in range(n)]\n    ans = d[s][g1]+d[s][g2]\n    for i in range(n):\n        if d[s][i]+d[i][g1]+d[i][g2] < ans:\n            ans = d[s][i]+d[i][g1]+d[i][g2]\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n\n    while True:\n        n,m,s,g1,g2 = LI()\n        if n == 0:\n            break\n        e = collections.defaultdict(list)\n        for _ in range(m):\n            a,b,c = LI()\n            e[a].append((b,c))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        sd = search(s)\n        r = inf\n        for i in range(1,n+1):\n            td = search(i)\n            tr = sd[i] + td[g1] + td[g2]\n            if r > tr:\n                r = tr\n\n        rr.append(r)\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappop, heappush\nfrom operator import add\n\nSENTINEL = 100000\nwhile True:\n    n, m, s, g1, g2 = map(int, input().split())\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    if not n:\n        break\n    pipes = [set() for _ in range(n)]\n    rpipes = [set() for _ in range(n)]\n    for _ in range(m):\n        b1, b2, c = map(int, input().split())\n        b1 -= 1\n        b2 -= 1\n        pipes[b1].add((c, b2))\n        rpipes[b2].add((c, b1))\n\n    dists = [[SENTINEL] * n for _ in range(2)]\n\n    for i in (0, 1):\n        g = (g1, g2)[i]\n        dist = dists[i]\n        dist[g] = 0\n        queue = list(rpipes[g])\n        heapify(queue)\n        while queue:\n            total_cost, base = heappop(queue)\n            if dist[base] < SENTINEL:\n                continue\n            dist[base] = total_cost\n            for next_cost, next_base in rpipes[base]:\n                if dist[next_base] == SENTINEL:\n                    heappush(queue, (total_cost + next_cost, next_base))\n\n    dists = list(map(add, *dists))\n\n    current_best = dists[s]\n    queue = list(pipes[s])\n    heapify(queue)\n    visited = {s}\n    while queue:\n        total_cost, base = heappop(queue)\n        if base in visited:\n            continue\n        visited.add(base)\n        current_best = min(current_best, total_cost + dists[base])\n        for next_cost, next_base in pipes[base]:\n            if next_base not in visited:\n                next_whole_cost = total_cost + next_cost + dists[next_base]\n                if current_best > next_whole_cost:\n                    heappush(queue, (total_cost + next_cost, next_base))\n\n    print(current_best)"
  },
  {
    "language": "Python",
    "code": "while True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 10 ** 8\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        s, t, c = map(int, input().split())\n        s, t = s - 1, t - 1\n        D[s][t] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j])\n    print(min(D[s][i] + D[i][g1] + D[i][g2] for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nINF = 1 << 30\nwhile True:\n    n, m, s, g1, g2 = map(int, raw_input().split())\n    if n | m | s | g1 | g2 == 0:\n        break\n    G = [[INF] * (n + 1) for _ in xrange(n + 1)]\n    for _ in xrange(m):\n        b1, b2, c = map(int, raw_input().split())\n        G[b1][b2] = c\n    for k, i, j in product(xrange(n + 1), repeat = 3):\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n    print min(G[s][i] + G[i][g1] + G[i][g2] for i in xrange(n + 1))"
  },
  {
    "language": "Python",
    "code": "while True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 10 ** 5\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        s, t, c = map(int, input().split())\n        s, t = s - 1, t - 1\n        D[s][t] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j])\n    print(min(D[s][i] + min(D[i][g1] + D[i][g2], D[i][g1] + D[g1][g2], D[i][g2] + D[g2][g1]) for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nINF = 1 << 30\nwhile True:\n    n, m, s, g1, g2 = map(int, raw_input().split())\n    if n | m | s | g1 | g2 == 0:\n        break\n    G = [[INF] * (n + 1) for _ in xrange(n + 1)]\n    for i in xrange(n + 1):\n        G[i][i] = 0\n    for _ in xrange(m):\n        b1, b2, c = map(int, raw_input().split())\n        G[b1][b2] = c\n    for k, i, j in product(xrange(n + 1), repeat = 3):\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n    print min(G[s][i] + G[i][g1] + G[i][g2] for i in xrange(n + 1))"
  },
  {
    "language": "Python",
    "code": "import sys\nif sys.version[0] == '2':\n    range, input = xrange, raw_input\nwhile True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 1 << 30\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        s, t, c = map(int, input().split())\n        s, t = s - 1, t - 1\n        D[s][t] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j])\n    print(min(D[s][i] + D[i][g1] + D[i][g2] for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappop, heappush\nfrom operator import add\n\nwhile True:\n    n, m, s, g1, g2 = map(int, input().split())\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    if not n:\n        break\n    pipes = [set() for _ in range(n)]\n    for _ in range(m):\n        b1, b2, c = map(int, input().split())\n        b1 -= 1\n        b2 -= 1\n        pipes[b1].add((c, b2))\n        pipes[b2].add((c, b1))\n\n    dists = [[None] * n for _ in range(2)]\n\n    for i in (0, 1):\n        g = (g1, g2)[i]\n        dist = dists[i]\n        dist[g] = 0\n        queue = list(pipes[g])\n        heapify(queue)\n        while queue:\n            total_cost, base = heappop(queue)\n            if dist[base] is not None:\n                continue\n            dist[base] = total_cost\n            for next_cost, next_base in pipes[base]:\n                if dist[next_base] is None:\n                    heappush(queue, (total_cost + next_cost, next_base))\n\n    dists = list(map(add, *dists))\n\n    current_best = dists[s]\n    queue = list(pipes[s])\n    heapify(queue)\n    visited = {s}\n    while queue:\n        total_cost, base = heappop(queue)\n        if base in visited:\n            continue\n        visited.add(base)\n        current_best = min(current_best, total_cost + dists[base])\n        for next_cost, next_base in pipes[base]:\n            if next_base not in visited:\n                next_whole_cost = total_cost + next_cost + dists[next_base]\n                if current_best > next_whole_cost:\n                    heappush(queue, (total_cost + next_cost, next_base))\n\n    print(current_best)"
  },
  {
    "language": "Python",
    "code": "while True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 10 ** 5\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        b1, b2, c = map(int, input().split())\n        b1, b2 = b1 - 1, b2 - 1\n        D[b1][b2] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j])\n    print(min(D[s][i] + D[i][g1] + D[i][g2] for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef cal(x,y,a):\n    return (x+y*W)*4 + a\n\ndef uncal(val):\n    a = val%4\n    vxy = val//4\n    x,y = vxy%W, vxy//W\n    return x,y,a\n\ndef dijkstra(lines,N,s):\n    weight = [INF]*N\n    weight[s] = 0\n    def search(s,w_0,q,weight):\n        for t,w in lines[s]:\n            w += w_0\n            if weight[t] > w:\n                heapq.heappush(q,[w,t])\n                weight[t] = w\n    q = [[0,s]]\n    heapq.heapify(q)\n    while q:\n        w,n = heapq.heappop(q)\n        search(n,w,q,weight)\n    return weight\n\n\n\nwhile True:\n    N,M,s,g1,g2 = inpl()\n    if N == 0 and M == 0:\n        break\n    else:\n        lines1 = defaultdict(set)\n        lines2 = defaultdict(set)\n        for _ in range(M):\n            x,y,c = inpl()\n            x,y = x-1,y-1\n            lines1[x].add((y,c))\n            lines2[y].add((x,c))\n\n        weights_s  = dijkstra(lines1,N,s-1)\n        weights_b1 = dijkstra(lines2,N,g1-1)\n        weights_b2 = dijkstra(lines2,N,g2-1)\n\n        ans = INF\n        for i in range(N):\n            tmp = weights_s[i] + weights_b1[i] + weights_b2[i]\n            ans = min(ans,tmp)\n        print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heapify, heappop, heappush\nfrom operator import add\n\nSENTINEL = 100000\nwhile True:\n    n, m, s, g1, g2 = map(int, input().split())\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n    if not n:\n        break\n    pipes = [set() for _ in range(n)]\n    rpipes = [set() for _ in range(n)]\n    for _ in range(m):\n        b1, b2, c = map(int, input().split())\n        b1 -= 1\n        b2 -= 1\n        pipes[b1].add((c, b2))\n        rpipes[b2].add((c, b1))\n\n    dists = [[SENTINEL] * n for _ in range(2)]\n\n    for i in (0, 1):\n        g = (g1, g2)[i]\n        dist = dists[i]\n        dist[g] = 0\n        queue = list(rpipes[g])\n        heapify(queue)\n        while queue:\n            total_cost, base = heappop(queue)\n            if dist[base] < SENTINEL:\n                continue\n            dist[base] = total_cost\n            for next_cost, next_base in rpipes[base]:\n                if dist[next_base] == SENTINEL:\n                    heappush(queue, (total_cost + next_cost, next_base))\n\n    dists = list(map(add, *dists))\n\n    current_best = dists[s]\n    queue = list(pipes[s])\n    heapify(queue)\n    visited = {s}\n    while queue:\n        total_cost, base = heappop(queue)\n        if base in visited:\n            continue\n        visited.add(base)\n        current_best = min(current_best, total_cost + dists[base])\n        for next_cost, next_base in pipes[base]:\n            if next_base not in visited:\n                heappush(queue, (total_cost + next_cost, next_base))\n\n    print(current_best)"
  },
  {
    "language": "Python",
    "code": "while True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 1 << 30\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        s, t, c = map(int, input().split())\n        s, t = s - 1, t - 1\n        D[s][t] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j])\n    print(min(D[s][i] + D[i][g1] + D[i][g2] for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "from itertools import product\nINF = 1 << 30\nwhile True:\n    n, m, s, g1, g2 = map(int, raw_input().split())\n    if n | m | s | g1 | g2 == 0:\n        break\n    G = [[INF] * (n + 1) for _ in xrange(n + 1)]\n    for _ in xrange(m):\n        b1, b2, c = map(int, raw_input().split())\n        G[b1][b2] = c\n    for k, i, j in product(xrange(n), repeat = 3):\n        G[i][j] = min(G[i][j], G[i][k] + G[k][j])\n    print min(G[s][m] + G[m][g1] + G[m][g2] for m in xrange(n))"
  },
  {
    "language": "Python",
    "code": "while True:\n    N, M, s, g1, g2 = map(int, input().split())\n    if N == M == s == g1 == g2 == 0:\n        break\n    s, g1, g2 = s - 1, g1 - 1, g2 - 1\n    INF = 10 ** 8\n    D = [[INF] * N for _ in range(N)]\n    for i in range(N):\n        D[i][i] = 0\n    for _ in range(M):\n        s, t, c = map(int, input().split())\n        s, t = s - 1, t - 1\n        D[s][t] = c\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                D[i][j] = min(D[i][j], D[i][k] + D[k][j])\n    print(min(D[s][i] + min(D[i][g1] + D[i][g2], D[i][g1] + D[g1][g2], D[i][g2] + D[g2][g1]) for i in range(N)))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef warshall(n, matrix):\n  for i in xrange(n):\n    matrix[i][i] = 0\n  for i in xrange(n):\n    for j in xrange(n):\n      for k in xrange(n):\n        matrix[j][k] = min(matrix[j][k], matrix[j][i]+matrix[i][k])\n  return matrix\n\nwhile True:\n  n,m,s,g1,g2 = map(int, raw_input().split())\n  if n==m==s==g1==g2==0:\n    break\n  matrix = [[10**10] * n for i in xrange(n)]\n  for i in xrange(m):\n    b1,b2,c = map(int, raw_input().split())\n    matrix[b1-1][b2-1] = c\n  costs = warshall(n, matrix)\n  mincost = 10**10\n  for i in xrange(n):\n    mincost = min(mincost, costs[s-1][i]+costs[i][g1-1]+costs[i][g2-1])\n  print mincost"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  while True:\n    n, m, s, g1, g2 = map(int, input().split())\n    if n == 0:\n      break\n    s -= 1\n    g1 -= 1\n    g2 -= 1\n  \n    INF = 10 ** 20\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n      b1, b2, c = map(int, input().split())\n      b1 -= 1\n      b2 -= 1\n      edges[b1].append((b2, c))\n  \n    def dij(start):\n      que = []\n      heappush(que, (0, start))\n      costs = [INF] * n\n      costs[start] = 0\n      \n      while que:\n        total, node = heappop(que)\n        for to, dist in edges[node]:\n          new_total = total + dist\n          if costs[to] > new_total:\n            costs[to] = new_total\n            heappush(que, (new_total, to))\n  \n      return costs\n    \n    from_i = [dij(i) for i in range(n)]\n    print(min([from_i[s][i] + from_i[i][g1] + from_i[i][g2] for i in range(n)]))\n  \nmain()\n"
  },
  {
    "language": "Python",
    "code": "inf = 10**10\nwhile 1:\n    n,m,s,g1,g2 = map(int,raw_input().split())\n    if n == 0: break\n    s,g1,g2 = s-1,g1-1,g2-1\n    G = [[inf]*n for i in xrange(n)]\n    for loop in xrange(m):\n        b1,b2,c = map(int,raw_input().split())\n        G[b1-1][b2-1] = c\n    for k in xrange(n):\n        for i in xrange(n):\n            for j in xrange(n):\n                G[i][j] = min(G[i][j], G[i][k]+G[k][j])\n    ans = inf\n    for i in xrange(n):\n        ans = min(ans, G[s][i]+G[i][g1]+G[i][g2], G[s][i]+G[i][g1]+G[g1][g2], G[s][i]+G[i][g2]+G[g2][g1])\n    print ans"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\nuse std::cmp::min;\n\nstruct StdinReader<'a> {\n    reader: StdinLock<'a>,\n}\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> Self {\n        Self { reader: reader }\n    }\n\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_whitespace(ch: u8) -> bool {\n            ch == 0x20 || ch == 0x0a || ch == 0x0d\n        }\n\n        let token: Vec<u8> = self.reader\n            .by_ref()\n            .bytes()\n            .map(|ch| ch.expect(\"failed to read a byte\"))\n            .skip_while(|ch| is_whitespace(*ch))\n            .take_while(|ch| !is_whitespace(*ch))\n            .collect();\n        let token_str = from_utf8(&token)\n            .unwrap_or_else(|_| panic!(format!(\"invalid utf8 sequence: {:?}\", token)));\n        token_str\n            .parse()\n            .unwrap_or_else(|_| panic!(format!(\"failed to parse input: {}\", token_str)))\n    }\n}\n\ntype Weight = i32;\n\nfn main() {\n    let INF = Weight::max_value() / 10;\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        let n: usize = reader.read();\n        let m: usize = reader.read();\n\n        if n == 0 { break; }\n\n        let source = reader.read::<usize>() - 1;\n        let g1 = reader.read::<usize>() - 1;\n        let g2 = reader.read::<usize>() - 1;\n\n        let mut dist = vec![vec![INF; n]; n];\n\n        for _ in 0..m {\n            let b1 = reader.read::<usize>() - 1;\n            let b2 = reader.read::<usize>() - 1;\n            let c: i32 = reader.read();\n\n            dist[b1][b2] = c;\n        }\n\n        for i in 0..n {\n            dist[i][i] = 0;\n        }\n        for k in 0..n {\n            for i in 0..n {\n                for j in 0..n {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n                }\n            }\n        }\n\n        let mut min_cost = dist[source][g1] + dist[source][g2];\n        for v in 0..n {\n            min_cost = min(min_cost, dist[source][v] + dist[v][g1] + dist[v][g2])\n        }\n\n        println!(\"{}\", min_cost);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  loop {\n    let v: Vec<usize> = read_vec();\n    let n = v[0];\n    let m = v[1];\n\n    if n == 0 { break; }\n    \n    let mut cst: Vec<Vec<u32>> = vec![vec![std::u32::MAX / 4; n]; n];\n\n    for i in 0 .. n {\n      cst[i][i] = 0;\n    }\n    \n    let s = v[2] - 1;\n    let g1 = v[3] - 1;\n    let g2 = v[4] - 1;\n\n    for _ in 0 .. m {\n      let v: Vec<usize> = read_vec();\n      cst[v[0]-1][v[1]-1] = v[2] as u32;\n    }\n\n    wf(&mut cst);\n\n    let mp: u32 = (0 .. n).map(|i| cst[s][i] + cst[i][g1] + cst[i][g2]).min().unwrap();\n\n    println!(\"{}\", mp);\n  }\n}\n\nfn wf<T>(v: &mut Vec<Vec<T>>)\n  where T: Ord + std::ops::Add<Output=T> + Copy\n{\n  let n = v.len();\n  \n  for k in 0 .. n {\n    for i in 0 .. n {\n      for j in 0 .. n {\n        if v[i][j] > v[i][k] + v[k][j] { v[i][j] = v[i][k] + v[k][j]; }\n      }\n    }\n  }\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, StdinLock};\nuse std::str::{from_utf8, FromStr};\nuse std::vec::Vec;\nuse std::cmp::min;\n\nstruct StdinReader<'a> {\n    reader: StdinLock<'a>,\n}\n\nimpl<'a> StdinReader<'a> {\n    pub fn new(reader: StdinLock<'a>) -> Self {\n        Self { reader: reader }\n    }\n\n    pub fn read<T: FromStr>(&mut self) -> T {\n        fn is_whitespace(ch: u8) -> bool {\n            ch == 0x20 || ch == 0x0a || ch == 0x0d\n        }\n\n        let token: Vec<u8> = self.reader\n            .by_ref()\n            .bytes()\n            .map(|ch| ch.expect(\"failed to read a byte\"))\n            .skip_while(|ch| is_whitespace(*ch))\n            .take_while(|ch| !is_whitespace(*ch))\n            .collect();\n        let token_str = from_utf8(&token)\n            .unwrap_or_else(|_| panic!(format!(\"invalid utf8 sequence: {:?}\", token)));\n        token_str\n            .parse()\n            .unwrap_or_else(|_| panic!(format!(\"failed to parse input: {}\", token_str)))\n    }\n}\n\ntype Weight = i32;\nconst INF: Weight = Weight::max_value() / 10;\n\nfn main() {\n    let stdin = std::io::stdin();\n    let mut reader = StdinReader::new(stdin.lock());\n\n    loop {\n        let n: usize = reader.read();\n        let m: usize = reader.read();\n\n        if n == 0 { break; }\n\n        let source = reader.read::<usize>() - 1;\n        let g1 = reader.read::<usize>() - 1;\n        let g2 = reader.read::<usize>() - 1;\n\n        let mut dist = vec![vec![INF; n]; n];\n\n        for _ in 0..m {\n            let b1 = reader.read::<usize>() - 1;\n            let b2 = reader.read::<usize>() - 1;\n            let c: i32 = reader.read();\n\n            dist[b1][b2] = c;\n        }\n\n        for i in 0..n {\n            dist[i][i] = 0;\n        }\n        for k in 0..n {\n            for i in 0..n {\n                for j in 0..n {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n                }\n            }\n        }\n\n        let mut min_cost = dist[source][g1] + dist[source][g2];\n        for v in 0..n {\n            min_cost = min(min_cost, dist[source][v] + dist[v][g1] + dist[v][g2])\n        }\n\n        println!(\"{}\", min_cost);\n    }\n}\n\n"
  }
]