[
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 8192\n\nint dp[NUM+1];\n\n\nvoid dfs(int current,int array[15],int depth){\n\n\tif(depth == 13)return;\n\n\tfor(int i = 0; i <= depth; i++){\n\t\tif(current+array[i] > NUM)continue;\n\n\t\tif(dp[current+array[i]] >= depth+1){\n\t\t\tdp[current+array[i]] = depth+1;\n\t\t\tint next_array[15];\n\t\t\tfor(int k = 0; k <= depth; k++)next_array[k] = array[k];\n\t\t\tnext_array[depth+1] = current+array[i];\n\t\t\tdfs(current+array[i],next_array,depth+1);\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= depth; i++){\n\t\tif(current-array[i] <= 0)continue;\n\n\t\tif(dp[current-array[i]] >= depth+1){\n\t\t\tdp[current-array[i]] = depth+1;\n\t\t\tint next_array[15];\n\t\t\tfor(int k = 0; k <= depth; k++)next_array[k] = array[k];\n\t\t\tnext_array[depth+1] = current-array[i];\n\t\t\tdfs(current-array[i],next_array,depth+1);\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tdp[0] = 0;\n\tdp[1] = 0;\n\tfor(int i = 2; i <= NUM; i++)dp[i] = BIG_NUM;\n\n\tint first_array[15];\n\tfirst_array[0] = 1;\n\n\tdfs(1,first_array,0);\n\n\tint N;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tprintf(\"%d\\n\",dp[N]);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef long long ll;\n\nbool flag[1501];\nint v[1501];\nint p;\nint n;\n\nbool can(int a, int ma, int rest) {\n  a+=ma;\n  while(rest--)a+=a;\n  return a>=n;\n}\n\nbool dfs(int now, int d, int len, int ma) {\n  if (now == n) return 1;\n  if (d == 0) return 0;\n  if (d == 1) return flag[abs(now-n)];\n  // cout << now << \" \" << d << endl;\n  // cout << \"v = \";\n  // REP(i, len) cout << v[i] << \" \";\n  // cout << endl;\n  for (int i=len-1; i>=0; i--) {\n    int next = v[i]+now;\n    if (next<=n*3/2 && !flag[next] && can(next,ma,d)) {\n      v[len] = next;\n      flag[next] = 1;\n      if (dfs(next,d-1,len+1,max(ma, next))) return 1;\n      flag[next] = 0;\n    }\n    next = abs(v[i]-now);\n    if (next > 0 && !flag[next] && can(next,ma,d)) {\n      v[len] = next;\n      flag[next] = 1;\n      if (dfs(next,d-1,len+1,max(ma, next))) return 1;\n      flag[next] = 0;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  \n  while(cin >> n, n) {\n  //for (n=1;n<=1000;++n) {\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n    for (p = 1; ; p++) {\n      //cout << \"p = \" << p << endl;\n      memset(flag,0,sizeof(flag));\n      flag[1] = 1;\n      v[0] = 1;\n      if (dfs(1,p,1,1)) {\n        cout << p << endl;\n        break;\n      }\n    }\n  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nconst int INF=1000000000;\n\nint mincost;\nbool usable[2100];\nint N;\n\nvoid dfs(int nowNum,int ccost,int maxv){\n  if(ccost>=mincost)return;\n  else if(nowNum==N){\n    mincost=ccost;\n    return;\n  }\n  else if(2048<nowNum)return;\n  int cnt=0;\n  int tmp=nowNum;\n  while(tmp<N){\n    cnt++;\n    tmp*=2;\n  }\n  if(cnt+ccost>=mincost)return;\n  for(int i=1;i<=maxv;i++){\n    if(nowNum+i>=2048&&nowNum-i<=1)break;\n    if(usable[i]){\n      int nxtNum=nowNum+i;\n      if(nxtNum<=2048&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\tusable[nxtNum]=false;\n      }\n      nxtNum=nowNum-i;\n      if(nxtNum>=2&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\tusable[nxtNum]=false;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    memset(usable,0,sizeof(usable));\n    usable[1]=true;\n    int popCnt=0;\n    int maxBitPos=0;\n    for(int i=0;i<12;i++){\n      if((N>>i)&1){\n\tpopCnt++;\n\tmaxBitPos=i;\n      }\n    }\n    // initialized with upper bound value\n    mincost=maxBitPos+popCnt-1;\n    dfs(1,0,1);\n    cout<<mincost<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint table[] = { -1, 0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 6, 5, 6, 6, 7, 6, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7, 8, 7, 7, 6, 7, 7, 8, 7, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 8, 9, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 8, 9, 8, 8, 7, 8, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 10, 9, 9, 9, 9, 8, 9, 9, 9, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 9, 8, 9, 9, 10, 9, 10, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10, 10, 10, 10, 9, 10, 10, 10, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 11, 11, 10, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 11, 11, 12, 12, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 12, 11, 11, 12, 12, 11, 12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 11, 11, 11, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 11, 11, 11, 10, 11, 11, 11, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 11, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 12, 11, 12, 12, 13, 12, 13, 13, 13, 12 };\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        cout << table[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst ull p = 1000000007;\null ps[20];\nint N, maxDepth;\nvector<int> xs;\nset<ull> visited;\n\ninline ull hash(const vector<int>& vs){\n\tull ret = 0;\n\tfor(int i=0; i<(int)vs.size(); i++){\n\t\tret += vs[i] * ps[i];\n\t}\n\treturn ret;\n}\n\nint dfs(int depth){\n\tif(depth > maxDepth || (xs.back() << (maxDepth - depth)) < N) return false;\n\tif(binary_search(xs.begin(), xs.end(), N)) return true;\n\tint len = xs.size();\n\tfor(int i=0; i<len; i++){\n\t\tfor(int j=len-1; j<len; j++){\n\t\t\tfor(int k=0; k<(j==i?1:2); k++){\n\t\t\t\tint nx = xs[j] + (k?-xs[i]:xs[i]);\n\t\t\t\tif(!binary_search(xs.begin(), xs.end(), nx)){\n\t\t\t\t\txs.insert(lower_bound(xs.begin(), xs.end(), nx), nx);\n\t\t\t\t\tif(visited.insert(hash(xs)).second && dfs(depth+1)) return true;\n\t\t\t\t\txs.erase(lower_bound(xs.begin(), xs.end(), nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\txs.clear();\n\txs.push_back(1);\n\n\tfor(maxDepth=0; maxDepth<=20; ++maxDepth){\n\t\tvisited.clear();\n\t\tvisited.insert(hash(xs));\n\t\tif(dfs(0)) return maxDepth;\n\t}\n\treturn -1;\n}\n\nint main(){\n\tps[0] = p;\n\tfor(int i=0; i<19; i++){\n\t\tps[i+1] = ps[i] * p;\n\t}\n\twhile(scanf(\"%d\",&N),N){\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint tar;\n\nint hstar(int n,const int *a){\n\tint a_max=*max_element(a,a+n);\n\tint res=0;\n\twhile(a_max<tar) a_max*=2, res++;\n\treturn res;\n}\n\nint ans;\nbool dfs(int n,int *a,int ub){\n\trep(i,n) if(a[i]==tar) {\n\t\tans=n-1;\n\t\treturn true;\n\t}\n\n\tif((n-1)+hstar(n,a)>ub) return false;\n\n\trep(i,n) rep(j,n) {\n\t\tbool ok1=true,ok2=true;\n\t\trep(k,n){\n\t\t\tif(a[i]+a[j]==a[k]) ok1=false;\n\t\t\tif(a[i]-a[j]==a[k]) ok2=false;\n\t\t}\n\t\tif(ok1 && i<=j){\n\t\t\ta[n]=a[i]+a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t\tif(ok2 && a[i]-a[j]>0){\n\t\t\ta[n]=a[i]-a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&tar),tar;){\n\t\tans=77;\n\t\tint a[20]={1};\n\t\tfor(int ub=0;!dfs(1,a,ub);ub++);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\nusing namespace std;\nconstexpr int max_n = 1000;\nconstexpr int used_len = 2 * max_n;\nbool iddfs(vector<int> & s, array<bool,used_len> & used, int mx, int depth, int n) {\n    if (used[n]) return true;\n    if (depth == 0) return false;\n    if ((mx << depth) < n) return false;\n    repeat_reverse (i,s.size()) {\n        repeat_reverse (j,i+1) {\n            for (int x : { s[i] + s[j], abs(s[i] - s[j]) }) {\n                if (x <= 0 or used_len <= x) continue;\n                if (used[x]) continue;\n                used[x] = true;\n                s.push_back(x);\n                if (iddfs(s, used, max(mx, x), depth-1, n)) return true;\n                s.pop_back();\n                used[x] = false;\n            }\n        }\n    }\n    return false;\n}\nint iddfs(int n) {\n    int depth = 0;\n    while (true) {\n        vector<int> s { 1 };\n        array<bool,used_len> used = {};\n        used[1] = true;\n        if (iddfs(s, used, 1, depth, n)) break;\n        depth += 1;\n    }\n    return depth;\n}\nint main() {\n    repeat_from (n,1,max_n+1) {\n        cout << iddfs(n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <cstdio>\n     \n    #define MAX_N 1024\n    #define MAX_D 20\n    int exp[MAX_D] = {1}, ans[MAX_N];\n     \n    void dfs(int d)\n    {\n        if (d > MAX_D)\n        {\n            return;\n        }\n        for (int i = 0; i <= d; i++)\n        {\n            exp[d + 1] = exp[i] + exp[d]; // 乘法\n            if (exp[d + 1] < MAX_N && ans[exp[d + 1]] >= d + 1)\n            {\n                ans[exp[d + 1]] = d + 1;\n                dfs(d + 1);\n            }\n            exp[d + 1] = exp[d] - exp[i]; // 除法\n            if (exp[d + 1] > 0 && ans[exp[d + 1]] >= d + 1)\n            {\n                ans[exp[d + 1]] = d + 1;\n                dfs(d + 1);\n            }\n        }\n    }\n     \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n        for (int i = 2; i < MAX_N; i++)\n        {\n            //每个n的上界=除法+乘法\n            ans[i] = __builtin_popcount(i) + (30 - __builtin_clz(i));\n        }\n        dfs(0);\n     \n        int n;\n        while (~scanf(\"%d\", &n), n)\n        {\n            printf(\"%d\\n\", ans[n]);\n        }\n    #ifndef ONLINE_JUDGE\n        fclose(stdin);\n    #endif\n        return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint emb[] = {0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,2,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,2,1,2,1,2,2,2,1,2,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,2,1,2,1,1,1,1,0,1,1,1,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,1,1,0,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,1,2,1,1,1,1,0,1,1,1,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,1,1,0,0,0,1,0,1,1,1,0,1,1,2,1,2,1,1,0,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,1,1,2,1,2,2,2,1,2,1,2,1,2,1,2,1,2,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,1,2,1,2,1,1,1,1,0,1,1,1,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,3,2,3,2,2,2,3,2,3,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,3,2,3,2,2,1,2,2,3,2,3,2,2,1,2,2,2,1,2,1,1,0,0,0,1,0,1,1,1,0,1,1,2,1,2,1,1,0,1,1,2,1,2,2,1,1,2,2,2,1,2,1,1,0,1,1,2,1,2,2,2,1,1,2,2,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,1,1,2,1,2,2,2,1,2,1,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,1,2,1,2,1,1,1,1,1,1,0,1,1,1,1,1,1,2,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,1,2,2,2,1,2,1,2,1,1,1,1,0,1,1,1,1,2,1,2,1,2,2,2,1,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,3,2,2,2,2,1,2,2,2,2,3,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,2,3,2,3,2,2,2,3,2,2,2,2,2,2,1,2,2,2,2,2,2,3,2,2,2,3,2,3,2,2,2,3,2,3,2,3,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,3,3,2,3,3,3,2,3,2,3,2,3,3,3,2,3,3,3,2,3,2,3,2,2,2,3,2,3,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,3,2,3,2,2,2,2,2,3,2,3,3,3,2,3,3,3,2,3,2,2,1,2,2,3,2,3,3,3,2,};\n\nint main() {\n\tfor (int i = 2; i <= 1000; ++i ){\n\t\temb[i] += 32 - __builtin_clz(i-1);\n\t}\n\tfor (int n;scanf(\"%d\", &n), n; printf(\"%d\\n\", emb[n])) ;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\nusing namespace std;\nconstexpr int max_n = 1000;\nconstexpr int used_len = 2 * max_n;\nbool iddfs(vector<int> & s, array<bool,used_len> & used, int mx, int depth, int n) {\n    if (used[n]) return true;\n    if (depth == 0) return false;\n    if ((mx << depth) < n) return false;\n    repeat_reverse (i,s.size()) {\n        repeat_reverse (j,i+1) {\n            for (int x : { s[i] + s[j], abs(s[i] - s[j]) }) {\n                if (x <= 0 or used_len <= x) continue;\n                if (used[x]) continue;\n                used[x] = true;\n                s.push_back(x);\n                if (iddfs(s, used, max(mx, x), depth-1, n)) return true;\n                s.pop_back();\n                used[x] = false;\n            }\n        }\n    }\n    return false;\n}\nint iddfs(int n) {\n    int depth = 0;\n    while (true) {\n        vector<int> s { 1 };\n        array<bool,used_len> used = {};\n        used[1] = true;\n        if (iddfs(s, used, 1, depth, n)) break;\n        depth += 1;\n    }\n    return depth;\n}\nint main() {\n    while(scanf(\"%d\", &n) && n){\n      cout << iddfs(n) << endl;  \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint X;\nint ANSWER;\nbool exists[1<<13];\nint estimate[1<<13];\nint cur[13], maxi;\n\nbool init() {\n\tscanf(\"%d\", &X);\n\treturn X > 0;\n}\n\n\nbool dfs(int depth) {\n\tif (depth + estimate[maxi] > ANSWER) {\n\t\treturn false;\n\t}\n\tif (exists[X]) {\n\t\treturn true;\n\t}\n\tfor (int i = 0; i <= depth; ++i) {\n\t\tfor (int j = 0; j <= depth; ++j) {\n\t\t\tconst int add = cur[i] + cur[j];\n\t\t\tconst int sub = cur[i] - cur[j];\n\t\t\tif (i <= j && !exists[add]) {\n\t\t\t\tint tmp = maxi;\n\t\t\t\texists[add] = true;\n\t\t\t\tmaxi = max(maxi, add);\n\t\t\t\tcur[depth + 1] = add;\n\t\t\t\tif (dfs(depth + 1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tmaxi = tmp;\n\t\t\t\texists[add] = false;\n\t\t\t}\n\t\t\tif (sub > 0 && !exists[sub]) {\n\t\t\t\texists[sub] = true;\n\t\t\t\tcur[depth + 1] = sub;\n\t\t\t\tif (dfs(depth + 1)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\texists[sub] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve() {\n\tmemset(exists, false, sizeof(exists));\n\tmemset(estimate, 0, sizeof(estimate));\n\tfor (int i = 1; i < 1<<13; ++i) {\n\t\tint t = i;\n\t\tfor (;t < X; t <<= 1, ++estimate[i]);\n\t}\n\texists[1] = true;\n\tcur[0] = 1;\n\tmaxi = 1;\n\tfor (ANSWER = 0; ANSWER <= 12; ++ANSWER) {\n\t\tif (dfs(0)) {\n\t\t\treturn ANSWER;\n\t\t}\n\t}\n\treturn ANSWER;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null expect(int p,int n,ull tar){\n  ull ret=n;\n  while(p--&&ret<tar)ret+=ret;\n  return ret;\n}\n\nint ans;\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar ){\n    ans=min(ans,cnt);\n    return true;\n  }\n  if ( cnt==limit)return false;\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( expect(limit-cnt,findmax,(ull)tar)<(ull)tar){\n    return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited)){\n\tvisited[now+made[i]]=false;\n\treturn true;\n      }\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited)){\n\tvisited[now-made[i]]=false;\n\treturn true;\n      }\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[5002]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    \n    for(int i=upper-1;i>=lower;i--){\n      ans=i;\n      if (solve(1,i,2,n,2,made,visited) ){\n\t//cout << \"solved at \" <<i<<\" with \" << ans << endl;\n\tupper=ans;\n\ti=ans;\n      }\n      //else cout << \"unsolved at \" <<i<<endl;\n\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes puts(\"Yes\")\n#define no puts(\"No\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\nconst int INF=1LL<<55;\nconst int MOD=1000000007;\n\nbool state[1001];\nvi ans(1001);\nint target;\n\n\nvoid dfs(int depth, int pre, int maxv ){\n  if ( pre == target ){\n    ans[target] = min( ans[target], depth );\n    return;\n  }\n  if ( depth >= ans[target] ) return;\n  \n  int next, d = 0, p = maxv;\n  \n  while( p < target ){d++; p *= 2;}\n  if ( depth + d >= ans[target] ) return;\n  \n  for ( int i = 1; i <= maxv; i++ ){\n    if ( !state[i] ) continue;\n    next = pre + i;\n    if ( next <= 1000 && !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n    next = ( pre > i ) ? ( pre - i ) : (i - pre);\n    if ( !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n  }\n}\n\nvoid solve(){\n    for(int i=0;i<=1000;i++) state[i]=false;\n    state[1]=true;\n    dfs(0,1,1);\n    cout<<ans[target]<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    fill(all(ans),13);\n    while(cin>>target,target){\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX = 1001;\nconst int NMAX = 1001;\nconst int LIM = 13;\nconst int inf = 1<<26;\n\n/*\n\n  x x = x^2\n  x^2 x = x^3\n  x^2 x^2 = x^4\n  x^4 x^3? = x^7\n  \n  1 2 4 8 16 32 1 : 31(7)\n  1 2 4 : 7(3?)\n  \n\n  31 = 16 + 15\n  15 = 8 + 7 \n  7 = 4 + 3 4\n  3 = 2 + 1 2\n  2 = 1 + 1 1\n  \n */\n\nbool generated[MAX];\nint res[MAX];\nint goal;\n\nvoid solve(int cur, int depth)\n{\n  res[cur] = min(res[cur], depth);\n  if( cur == goal ){\n    res[goal] = min( res[goal], depth );\n    return ;\n  }\n\n  int max_pred = 1;\n  int pred1 = 1, pred2 = 1;\n  int tcur = cur;\n  while(true){\n    if((tcur<<1)>goal)break;\n    tcur<<=1;\n    ++pred1;\n  }\n  tcur = cur;\n  while(true){\n    if((tcur>>1)<goal)break;\n    tcur>>=1;\n    ++pred2;\n  }\n  max_pred = max( pred1, pred2 );\n  \n  if( max_pred+depth > res[goal] ) return ;\n  if( max_pred+res[cur] > res[goal] ) return ;\n  if( max_pred+depth > LIM ) return ;\n  \n  for(int i = 1; i <= MAX; ++i){\n    if( !generated[i] ) continue;\n\n    if( cur+i < MAX && !generated[cur+i] ){\n      generated[cur+i]=true;\n      solve(cur+i,depth+1);\n      generated[cur+i]=false;\n    }\n\n    if( cur-i >  0  && !generated[cur-i] ){\n      generated[cur-i]=true;\n      solve(cur-i,depth+1);\n      generated[cur-i]=false;\n    }\n\n    if( i-cur >  0  && !generated[i-cur] ){\n      generated[i-cur]=true;\n      solve(i-cur,depth+1);\n      generated[i-cur]=false;\n    }\n  }\n  \n}\n\n//-------------------------\n// emb\n//-------------------------\nconst int ans[1001] = {0,0,1,2,2,3,3,4,3,4,\n4,5,4,5,5,5,4,5,5,6,\n5,6,6,6,5,6,6,6,6,7,\n6,6,5,6,6,7,6,7,7,7,\n6,7,7,7,7,7,7,7,6,7,\n7,7,7,8,7,8,7,8,8,8,\n7,8,7,7,6,7,7,8,7,8,\n8,8,7,8,8,8,8,8,8,8,\n7,8,8,8,8,8,8,9,8,9,\n8,9,8,8,8,8,7,8,8,8,\n8,9,8,9,8,9,9,9,8,9,\n9,9,8,9,9,9,9,9,9,9,\n8,9,9,9,8,9,8,8,7,8,\n8,9,8,9,9,9,8,9,9,9,\n9,9,9,9,8,9,9,9,9,9,\n9,10,9,9,9,9,9,9,9,9,\n8,9,9,9,9,9,9,10,9,10,\n9,10,9,10,10,10,9,10,10,10,\n9,10,10,10,9,10,9,10,9,9,\n9,9,8,9,9,9,9,10,9,10,\n9,10,10,10,9,10,10,10,9,10,\n10,10,10,10,10,10,9,10,10,10,\n10,10,10,10,9,10,10,10,10,10,\n10,10,10,10,10,10,10,10,10,10,\n9,10,10,10,10,10,10,10,9,10,\n10,10,9,10,9,9,8,9,9,10,\n9,10,10,10,9,10,10,11,10,11,\n10,10,9,10,10,11,10,11,10,10,\n10,10,10,10,10,10,10,10,9,10,\n10,10,10,10,10,11,10,10,10,11,\n10,11,11,11,10,11,10,11,10,11,\n10,11,10,11,10,10,10,10,10,10,\n9,10,10,10,10,10,10,11,10,11,\n10,11,10,11,11,11,10,11,11,11,\n10,11,11,11,10,11,11,11,11,11,\n11,11,10,11,11,11,11,11,11,11,\n10,11,11,11,11,11,11,11,10,11,\n11,11,10,11,11,11,10,11,10,11,\n10,10,10,10,9,10,10,10,10,11,\n10,11,10,11,11,11,10,11,11,11,\n10,11,11,11,11,11,11,11,10,11,\n11,11,11,11,11,11,10,11,11,11,\n11,11,11,11,11,11,11,11,11,11,\n11,11,10,11,11,11,11,11,11,11,\n11,11,11,11,11,11,11,11,10,11,\n11,11,11,11,11,11,11,11,11,11,\n11,12,11,12,11,11,11,12,11,12,\n11,11,11,11,11,11,11,11,11,11,\n10,11,11,11,11,11,11,11,11,11,\n11,12,11,12,11,11,10,11,11,12,\n11,12,11,11,10,11,11,11,10,11,\n10,10,9,10,10,11,10,11,11,11,\n10,11,11,12,11,12,11,11,10,11,\n11,12,11,12,12,11,11,12,12,12,\n11,12,11,11,10,11,11,12,11,12,\n12,12,11,11,12,12,11,12,11,12,\n11,11,11,12,11,12,11,11,11,12,\n11,11,11,11,11,11,10,11,11,11,\n11,11,11,12,11,11,11,12,11,12,\n12,12,11,12,11,12,11,12,12,12,\n11,12,12,12,12,12,12,12,11,12,\n12,12,11,12,12,12,11,12,12,12,\n11,12,12,12,11,12,12,12,11,12,\n11,12,11,12,11,11,11,11,11,11,\n10,11,11,11,11,11,11,12,11,12,\n11,12,11,12,12,12,11,12,12,12,\n11,12,12,12,11,12,12,12,12,12,\n12,12,11,12,12,12,12,12,12,12,\n11,12,12,12,12,12,12,12,11,12,\n12,12,12,12,12,12,12,12,12,12,\n12,12,12,12,11,12,12,12,12,12,\n12,12,12,12,12,12,12,12,12,12,\n11,12,12,12,12,12,12,12,12,12,\n12,12,12,12,12,12,11,12,12,12,\n12,12,12,12,11,12,12,12,12,12,\n12,12,11,12,12,12,11,12,12,12,\n11,12,11,12,11,11,11,11,10,11,\n11,11,11,12,11,12,11,12,12,12,\n11,12,12,12,11,12,12,12,12,12,\n12,12,11,12,12,12,12,12,12,12,\n11,12,12,12,12,12,12,12,12,12,\n12,13,12,12,12,12,11,12,12,12,\n12,13,12,12,12,12,12,12,12,12,\n12,12,11,12,12,12,12,12,12,12,\n12,12,12,12,12,12,12,13,12,12,\n12,13,12,13,12,12,12,13,12,12,\n12,12,12,12,11,12,12,12,12,12,\n12,13,12,12,12,13,12,13,12,12,\n12,13,12,13,12,13,12,12,12,12,\n12,12,12,12,12,12,11,12,12,12,\n12,12,12,12,12,12,12,13,12,13,\n12,13,12,13,12,13,12,13,12,13,\n12,13,13,13,12,13,13,13,12,13,\n12,13,12,13,13,13,12,13,13,13,\n12,13,12,13,12,12,12,13,12,13,\n12,12,12,12,12,12,12,12,12,12,\n11,12,12,12,12,12,12,12,12,12,\n12,13,12,13,12,12,12,12,12,13,\n12,13,13,13,12,13,13,13,12,13,\n12,12,11,12,12,13,12,13,13,13,\n12};\nint main()\n{\n  /*\n  for(int i = 0; i < MAX; ++i){\n    res[i] = inf;\n    generated[i] = false;\n  }\n  generated[1] = true;\n  while(true){\n    cin >> goal;\n    if( goal == 0 ) break;\n    \n    solve(1,0);\n    cout << goal << ' ' << res[goal] << endl;\n  }\n  */\n  /*\n  cout << \"const int ans[1001] = {0\";\n  for(int i = 1; i < NMAX; ++i){\n    cout << \",\" << res[i];\n  }\n  cout << \"};\" << endl;\n  */\n\n  while(true){\n    cin >> goal;\n    if( goal == 0 ) break;\n    cout << ans[goal] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nconst int MAX = 1000;\nconst int LIM = 13;\nint ans[MAX+1] = {\n    0,\n    0,1,2,2,3,3,4,3,4,4,5,4,5,5,5,4,5,5,6,5,6,6,6,5,6,6,6,6,7,6,6,5,6,6,7,6,7,7,7,6,7,7,7,7,7,7,7,6,7,7,7,7,8,7,8,7,8,8,8,7,8,7,7,6,7,7,8,7,8,8,8,7,8,8,8,8,8,8,8,7,8,8,8,8,8,8,9,8,9,8,9,8,8,8,8,7,8,8,8,8,\n    9,8,9,8,9,9,9,8,9,9,9,8,9,9,9,9,9,9,9,8,9,9,9,8,9,8,8,7,8,8,9,8,9,9,9,8,9,9,9,9,9,9,9,8,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,8,9,9,9,9,9,9,10,9,10,9,10,9,10,10,10,9,10,10,10,9,10,10,10,9,10,9,10,9,9,9,9,8,9,9,9,9,10,9,10,9,\n    10,10,10,9,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,9,10,9,9,8,9,9,10,9,10,10,10,9,10,10,11,10,11,10,10,9,10,10,11,10,11,10,10,10,10,10,10,10,10,10,10,9,10,10,10,10,10,10,11,10,10,10,11,10,\n    11,11,11,10,11,10,11,10,11,10,11,10,11,10,10,10,10,10,10,9,10,10,10,10,10,10,11,10,11,10,11,10,11,11,11,10,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,10,11,11,11,10,11,10,11,10,10,10,10,9,10,10,10,10,11,10,11,10,11,11,11,10,11,11,11,10,\n    11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,12,11,12,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,10,11,11,12,11,\n    12,11,11,10,11,11,11,10,11,10,10,9,10,10,11,10,11,11,11,10,11,11,12,11,12,11,11,10,11,11,12,11,12,12,11,11,12,12,12,11,12,11,11,10,11,11,12,11,12,12,12,11,11,12,12,11,12,11,12,11,11,11,12,11,12,11,11,11,12,11,11,11,11,11,11,10,11,11,11,11,11,11,12,11,11,11,12,11,12,12,12,11,12,11,12,11,12,12,12,11,\n    12,12,12,12,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,11,12,11,12,11,11,11,11,11,11,10,11,11,11,11,11,11,12,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,\n    12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,11,12,12,12,11,12,11,12,11,11,11,11,10,11,11,11,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,\n    12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,11,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,13,12,12,12,13,12,12,12,12,12,12,11,12,12,12,12,12,12,13,12,12,12,13,12,13,12,12,12,13,12,13,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,\n    12,12,12,12,12,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,13,13,12,13,13,13,12,13,12,13,12,13,13,13,12,13,13,13,12,13,12,13,12,12,12,13,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,13,12,12,12,12,12,13,12,13,13,13,12,13,13,13,12,13,12,12,11,12,12,13,12,13,13,13,12,\n};\nusing State = pair<int,vi>;\n\nset<State> memo;\n\nvoid dfs(const State& st){\n    int dist = st.first + 1;\n    if(dist >= LIM)return;\n    // if(memo.count(st))return;\n    // memo.insert(st);\n    vi cand = st.second;\n    int n = cand.size();\n\n    set<int> used;\n    REP(i,n)REP(j,i+1){\n        int y = cand[i] - cand[j];\n        if(used.count(y) == 0 && find(ALL(cand),y) == cand.end() && i==n-1){\n            used.insert(y);\n            if(y <= MAX)CHMIN(ans[y], dist);\n            if(dist+1 != LIM){\n                vi ncand(n+1);\n                REP(k,n)ncand[k] = cand[k];\n                ncand[n] = y;\n                sort(ALL(ncand));\n                State nstate(dist, ncand);\n                dfs(nstate);\n            }\n        }\n        int x = cand[i] + cand[j];\n        if(used.count(x) == 0 && find(ALL(cand),x) == cand.end() && x > cand.back()){\n            used.insert(x);\n            if(x <= MAX)CHMIN(ans[x], dist);\n            if(dist+1 != LIM){\n                vi ncand(n+1);\n                REP(k,n)ncand[k] = cand[k];\n                ncand[n] = x;\n                sort(ALL(ncand));\n                State nstate(dist, ncand);\n                dfs(nstate);\n            }\n        }\n    }\n}\n\nint main(){\n    // // precalc\n    // fill(ans,ans+MAX+1,LIM);\n    // ans[0] = 0;\n    // ans[1] = 0;\n    // State init(0,vi(1,1));\n    // dfs(init);\n\n    // // output\n    // FOR(i,0,MAX+1){\n    //     printf(\"%d,\",ans[i]);\n    //     if(i%100==0)puts(\"\");\n    // }\n\n    // query\n    while(true){\n        int n;\n        cin>>n;\n        if(n==0)break;\n        int ret = ans[n];\n        cout<<ret<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null mypow(int p,int n){\n  if (p == 1)return n;\n  ull ret =mypow(p/2,n);\n  ret=ret*ret;\n  if (p%2==1)ret*=n;\n  return ret;\n}\n\nint ans;\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar ){\n    ans=min(ans,cnt);\n    return true;\n  }\n  if ( cnt==limit)return false;\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( mypow(1+limit-cnt,findmax)<(ull)tar){\n    return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited)){\n\tvisited[now+made[i]]=false;\n\treturn true;\n      }\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited)){\n\tvisited[now-made[i]]=false;\n\treturn true;\n      }\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[2002]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    cout << lower << \" \" << upper << endl;\n    for(int i=upper-1;i>=lower;i--){\n      ans=i;\n      \n      if (solve(1,i,2,n,2,made,visited)){upper=ans;i=ans;}\n      else cout << \"unsolved at \" <<i<<endl;\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\nint ans=0;\n\nvoid solve(int cnt,int now,int tar,int num,int *made,bool *visited){\n  if( cnt>=ans)return;\n  if ( now>tar*2)return;\n  if (now == tar){\n    ans=min(ans,cnt);\n    return;\n  }\n  \n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      solve(cnt+1,now+made[i],tar,num+1,made,visited);\n      visited[now+made[i]]=false;\n    }\n\n    continue;\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      solve(cnt+1,now-made[i],tar,num+1,made,visited);\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    ans=tmp_cost(n);\n    bool visited[3000]={false};\n    int  made[30];\n    visited[1]=true;\n    made[0]=1;\n    solve(0,1,n,1,made,visited);\n    \n    cout << ans << \" \" << tmp_cost(n)<<endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<queue>\n#include<map>\n#include<sstream>\n#include<set>\n#include<stack>\n#include<iterator>\n#include<cctype>\n#include<cmath>\n#include<cassert>\nusing namespace std;\nconst int maxn=1000+10;\nint n,maxd,a[maxn]={1};\nint h(int d){\n\tint maxc=0;\n\tfor(int i=0;i<=d;i++) maxc=max(maxc,a[i]);\n\treturn maxc;\n}\nbool dfs(int d){\n\t//cout<<a[d]<<endl;\n\tif(a[d]==n) return true;\n\tif(d==maxd) return false;\n\tif(h(d)<<(maxd-d) <n) return false;\n\tfor(int i=d;i>=0;i--){\n\t\ta[d+1]=a[d]+a[i];\n\t\tif(dfs(d+1))return true;\n\t\tif(a[d]>a[i]){\n\t\t\ta[d+1]=a[d]-a[i];\n\t    \tif(dfs(d+1))return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(scanf(\"%d\",&n)&&n){\n\t\tif(n==1) cout<<\"0\"<<endl;\n\t\telse{\n\t\t\tfor(maxd=1;maxd<=13;maxd++){\n\t\t\t\tif(dfs(0)){\n\t\t\t\t\tcout<<maxd<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nPower_Calculus\nhttps://onlinejudge.u-aizu.ac.jp/problems/1271\n01<= n <= 1000\n*/\n\n#include <iostream>\n#include <cmath>\n#include <algorithm>    // \n\nusing namespace std;\n\nint N; //入力の保持\nint dp[10001]; //最初のあたいの保持\n\n/**\n * 再帰関数として深さ優先探索dfsをするメソッド\n * @pram now 現在見ているべき指数\n * @pram isCalced 計算結果を保持する配列\n * @pram depth    深さ\n */\nvoid dfs(int now, int isCalced[15], int depth){\n\n    //もう探索する必要がない\n    if(depth == 13) return;\n\n    /**\n     * 現在探索している深さまでで、計算結果を取得しているものについて\n     * 次(depth+1)計算することができるものを全て探索していく。\n     * ex.[1] -> [1, 2] -> [1,2,3], [1,2,4]\n     * [1,2] -> 1+2 = 3 -> [1,2,3]\n     * [1,2,4] -> 4-1 = 3 -> [1,2,3,4]\n     */\n    for (int i=0; i <= depth; i ++){\n        if(now + isCalced[i] > 10000) continue;\n\n        //すでに求めてあるor未だ求めてないdp[next]より、今探索しているものが小さければ\n\n        //掛け算によって次のものを求める\n        if( dp[now + isCalced[i]] >= depth+1){\n\n            dp[now + isCalced[i]] = depth+1;\n            \n            int nextIsCalced[15];\n            for(int k = 0; k <= depth; k++) nextIsCalced[k] = isCalced[k];\n            nextIsCalced[depth+1] = now + isCalced[i];\n\n            dfs(now + isCalced[i], nextIsCalced, depth+1);\n\n        }\n    }\n\n    for (int i=0; i <= depth; i ++){\n        if(now - isCalced[i] <= 0) continue;\n\n        //割り算によって次のものを求める\n        if( dp[now - isCalced[i]] >= depth+1){\n\n            dp[now - isCalced[i]] = depth+1;\n            \n            int nextIsCalced[15];\n            for(int k = 0; k <= depth; k++) nextIsCalced[k] = isCalced[k];\n            nextIsCalced[depth+1] = now - isCalced[i];\n\n            dfs(now - isCalced[i], nextIsCalced, depth+1);\n\n        }\n    }\n\n}\n\nvoid solve(){\n\n    //dp初期化\n    dp[0] = 0; dp[1] = 0;\n    for(int i = 2; i<10000; i++) dp[i] = 10000;\n\n    int first_exponent = 1;//最初のべき指数\n    int isCalced[15];//計算結果の保持\n    int first_depth = 0;//最初の深さ\n\n    isCalced[0] = 1;\n\n    dfs(first_exponent, isCalced, first_depth );\n\n    return;\n}\n\nint main(){\n    solve();\n    while(cin>>N, N!=0) cout<<dp[N]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\nusing namespace std;\nint n;\nint ret=0;\nset<vector<int> >S;\ninline int ABS(int a){return max(a,-a);}\nvoid dfs(vector<int>a,int b,int last){\n\tif(b>=ret)return;\n\tstd::sort(a.begin(),a.end());\n\tif(S.count(a))return;\n\tS.insert(a);\n\tint sz=a.size();\n\tint mv=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(a[i]==n){ret=b;return;}\n\t\tmv=max(mv,a[i]);\n\t}\n\tif(b==ret-1)return;\n\tif((mv<<(ret-b-1))<n)return;\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=0;j<sz;j++){\n\t\t\tif(a[i]+a[j]==n||ABS(a[i]-a[j])==n){ret=b+1;return;}\n\t\t}\n\t}\n\tvector<int>vis;\n\tfor(int i=0;i<sz;i++)for(int j=i;j<sz;j++){\n\t\tif(a[i]!=last&&a[j]!=last)continue;\n\t\tbool ok=true;\n\t\tfor(int k=0;k<sz;k++)if(a[i]+a[j]==a[k]){ok=false;break;}\n\t\tfor(int k=0;k<vis.size();k++)if(vis[k]==a[i]+a[j]){ok=false;break;}\n\t\tif(ok){\n\t\t\ta.push_back(a[i]+a[j]);\n\t\t\tvis.push_back(a[i]+a[j]);\n\t\t\tdfs(a,b+1,a[i]+a[j]);\n\t\t\ta.pop_back();\n\t\t}\n\t\tok=true;\n\t\tif(a[i]==a[j])continue;\n\t\tfor(int k=0;k<sz;k++)if(ABS(a[i]-a[j])==a[k]){ok=false;break;}\n\t\tfor(int k=0;k<vis.size();k++)if(vis[k]==ABS(a[i]-a[j])){ok=false;break;}\n\t\tif(ok){\n\t\t\ta.push_back(ABS(a[i]-a[j]));\n\t\t\tvis.push_back(ABS(a[i]-a[j]));\n\t\t\tdfs(a,b+1,ABS(a[i]-a[j]));\n\t\t\ta.pop_back();\n\t\t}\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tS.clear();\n\t\tn=a;\n\t\tint c=a;\n\t\tret=0;\n\t\twhile(c){\n\t\t\tif(c%2)ret++;\n\t\t\tret++;\n\t\t\tc/=2;\n\t\t}\n\t\tret-=2;\n\t\tvector<int>st;\n\t\tst.push_back(1);\n\t\tdfs(st,0,1);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint p[1001] = {INT_MAX};\nint n, d = 0, ops;\nbool dfs(int d)\n{ // d := depth\n    int mx = 0;\n    for (int i = 0; i <= d; i++)\n        mx = max(mx, p[i]);\n    if ((mx << (ops - d)) < n)\n        return false;\n\n    if (p[d] == n)\n        return true;\n    if (d == ops)\n        return false;\n\n    for (int i = 0; i <= d; i++)\n    {\n        p[d + 1] = p[d] + p[i];\n        if (dfs(d + 1))\n            return true;\n        p[d + 1] = p[d] - p[i];\n        if (dfs(d + 1))\n            return true;\n    }\n\n    return false;\n}\nint main()\n{\n\n    while (cin >> n && n)\n    {\n        for (int i = 0; i < 1005; i++)\n        {\n            p[i] = INT_MAX;\n        }\n\n        p[0] = 1;\n        for (ops = log2(n);; ops++)\n            if (dfs(0))\n                break;\n        if (n != 0)\n            printf(\"%d\\n\", ops); // 印出題目要求答案\n        else\n            printf(\"0\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null mypow(int p,int n){\n  if (p == 1)return n;\n  ull ret =mypow(p/2,n);\n  ret=ret*ret;\n  if (p%2==1)ret*=n;\n  return ret;\n}\n\n\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar){\n    return true;\n  }\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( mypow(1+limit-cnt,findmax)<(ull)tar){\n    //return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited))return true;\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited))return true;\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[3000]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    //cout << lower << endl;\n    REP(i,lower,upper){\n      if (solve(1,i,2,n,2,made,visited)){upper=i;break;}\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i,a,n) for(ll i=a;i<(ll)(n);i++)\n\n//どうしてもTLEだったので計算済み結果を配列に入れる。1000以下なので書ききることが可能。\n//ルール違反？？？？？？？？\nint ans[] = { -1, 0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 6, 5, 6, 6, 7, 6, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7, 8, 7, 7, 6, 7, 7, 8, 7, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 8, 9, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 8, 9, 8, 8, 7, 8, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 10, 9, 9, 9, 9, 8, 9, 9, 9, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 9, 8, 9, 9, 10, 9, 10, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10, 10, 10, 10, 9, 10, 10, 10, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 11, 11, 10, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 11, 11, 12, 12, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 12, 11, 11, 12, 12, 11, 12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 11, 11, 11, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 11, 11, 11, 10, 11, 11, 11, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 11, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 12, 11, 12, 12, 13, 12, 13, 13, 13, 12 };\n\nint main(){\n   int n;\n   while(cin>>n, n){\n      cout << ans[n] << endl;\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint a[]={0,0,1,2,2,3,3,4,3,4,4,5,4,5,5,5,4,5,5,6,5,6,6,6,5,6,6,6,6,7,6,6,5,6,6,7,6,7,7,7,6,7,7,7,7,7,7,7,6,7,7,7,7,8,7,8,7,8,8,8,7,8,7,7,6,7,7,8,7,8,8,8,7,8,8,8,8,8,8,8,7,8,8,8,8,8,8,9,8,9,8,9,8,8,8,8,7,8,8,8,8,9,8,9,8,9,9,9,8,9,9,9,8,9,9,9,9,9,9,9,8,9,9,9,8,9,8,8,7,8,8,9,8,9,9,9,8,9,9,9,9,9,9,9,8,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,8,9,9,9,9,9,9,10,9,10,9,10,9,10,10,10,9,10,10,10,9,10,10,10,9,10,9,10,9,9,9,9,8,9,9,9,9,10,9,10,9,10,10,10,9,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,9,10,9,9,8,9,9,10,9,10,10,10,9,10,10,11,10,11,10,10,9,10,10,11,10,11,10,10,10,10,10,10,10,10,10,10,9,10,10,10,10,10,10,11,10,10,10,11,10,11,11,11,10,11,10,11,10,11,10,11,10,11,10,10,10,10,10,10,9,10,10,10,10,10,10,11,10,11,10,11,10,11,11,11,10,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,10,11,11,11,10,11,10,11,10,10,10,10,9,10,10,10,10,11,10,11,10,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,12,11,12,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,10,11,11,12,11,12,11,11,10,11,11,11,10,11,10,10,9,10,10,11,10,11,11,11,10,11,11,12,11,12,11,11,10,11,11,12,11,12,12,11,11,12,12,12,11,12,11,11,10,11,11,12,11,12,12,12,11,11,12,12,11,12,11,12,11,11,11,12,11,12,11,11,11,12,11,11,11,11,11,11,10,11,11,11,11,11,11,12,11,11,11,12,11,12,12,12,11,12,11,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,11,12,11,12,11,11,11,11,11,11,10,11,11,11,11,11,11,12,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,11,12,12,12,11,12,11,12,11,11,11,11,10,11,11,11,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,11,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,13,12,12,12,13,12,12,12,12,12,12,11,12,12,12,12,12,12,13,12,12,12,13,12,13,12,12,12,13,12,13,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,13,13,12,13,13,13,12,13,12,13,12,13,13,13,12,13,13,13,12,13,12,13,12,12,12,13,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,13,12,12,12,12,12,13,12,13,13,13,12,13,13,13,12,13,12,12,11,12,12,13,12,13,13,13,12};\nint main()\n{\n     int r;\n     while(scanf(\"%d\",&r),r) printf(\"%d\\n\",a[r]);\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 1000\n#define LIMIT 13\n \nbool state[MAX+1];\nint ans[MAX+1], target;\n \nvoid dfs(int depth, int pre, int maxv ){\n  if ( pre == target ){\n    ans[target] = min( ans[target], depth );\n    return;\n  }\n  if ( depth >= ans[target] ) return;\n \n  int next, d = 0, p = maxv;\n \n  while( p < target ){d++; p *= 2;}\n  if ( depth + d >= ans[target] ) return;\n \n  for ( int i = 1; i <= maxv; i++ ){\n    if ( !state[i] ) continue;\n    next = pre + i;\n    if ( next <= MAX && !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n    next = ( pre > i ) ? ( pre - i ) : (i - pre);\n    if ( !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n  }\n}\n \nmain(){\n  for ( int i = 0; i <= MAX+1; i++ ) ans[i] = LIMIT;\n  while(cin >> target && target){\n    for ( int i = 0; i <= MAX+1; i++ ) state[i] = false;\n    state[1] = true;\n    dfs(0, 1, 1);\n    cout << ans[target] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int inf=1001;\n\n\nint min_res;\nbool used[2048];\n\ninline int hstar(int cmax,int t){\n\tint x=cmax,ret=0;\n\twhile(x<t) x<<=1,ret++;\n\treturn ret;\n}\n\nint ary[1010];\n\nint dfs(int t,int x,int d,int len){\n\tif(used[t]) return min_res=d;\n\tconst int cmax=*max_element(ary,ary+len);\n\n\tif(d+hstar(cmax,t)>=min_res) return inf;\n\n\tint ret=inf;\n\t\n\tbool made[2048];\n\tclr(made,false);\n\t\n\trrep(i,len){\n\t\tconst int s=ary[i];\n\t\tif(0<x+s && x+s<=2*t && used[x+s]==false && made[x+s]==false){\n\t\t\tmade[x+s]=true;\n\t\t\tused[x+s]=true;\n\t\t\tary[len]=x+s;\n\t\t\tchmin(ret,dfs(t,x+s,d+1,len+1));\n\t\t\tused[x+s]=false;\n\t\t}\n\t}\n\n\trep(i,len){\n\t\tconst int s=ary[i];\n\t\tif(0< x-s && x-s<=2*t && used[x-s]==false && made[x-s]==false){\n\t\t\tmade[x-s]=true;\n\t\t\tused[x-s]=true;\n\t\t\tary[len]=x-s;\n\t\t\tchmin(ret,dfs(t,x-s,d+1,len+1));\n\t\t\tused[x-s]=false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tclr(used,false);\n\t\tused[0]=used[1]=true;\n\t\tary[0]=1;\n\t\tmin_res=0;\n\t\twhile(dfs(n,1,0,1)==inf) min_res++;\n\t\tcout << n << \" \" << min_res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef long long ll;\n\nbool flag[1501];\nint v[1501];\nint p;\nint n;\n\nbool can(int a, int ma, int rest) {\n  a+=ma;\n  while(rest--)a+=a;\n  return a>=n;\n}\n\nbool dfs(int now, int d, int len, int ma) {\n  if (now == n) return 1;\n  if (d == 0) return 0;\n  \n  // cout << now << \" \" << d << endl;\n  // cout << \"v = \";\n  // REP(i, len) cout << v[i] << \" \";\n  // cout << endl;\n  REP(i, len) {\n    int next = v[i]+now;\n    if (next<=n*3/2 && !flag[next] && can(next,ma,d)) {\n      v[len] = next;\n      flag[next] = 1;\n      if (dfs(next,d-1,len+1,max(ma, next))) return 1;\n      flag[next] = 0;\n    }\n    next = abs(v[i]-now);\n    if (next > 0 && !flag[next] && can(next,ma,d)) {\n      v[len] = next;\n      flag[next] = 1;\n      if (dfs(next,d-1,len+1,max(ma, next))) return 1;\n      flag[next] = 0;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin >> n, n) {\n    if (n == 1) {\n      cout << 0 << endl;\n      continue;\n    }\n    for (p = 1; ; p++) {\n      //cout << \"p = \" << p << endl;\n      memset(flag,0,sizeof(flag));\n      flag[1] = 1;\n      v[0] = 1;\n      if (dfs(1,p,1,1)) {\n        cout << p << endl;\n        break;\n      }\n    }\n  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint tar;\n\nint hstar(int n,const int *a){\n\tint a_max=*max_element(a,a+n);\n\tint res=0;\n\twhile(a_max<tar) a_max*=2, res++;\n\treturn res;\n}\n\nint ans;\nbool dfs(int n,int *a,int ub){\n\trep(i,n) if(a[i]==tar) {\n\t\tans=min(ans,n-1);\n\t\treturn true;\n\t}\n\n\tif((n-1)+hstar(n,a)>ub) return false;\n\n\trep(i,n) rep(j,n) {\n\t\tbool ok1=true,ok2=true;\n\t\trep(k,n){\n\t\t\tif(a[i]+a[j]==a[k]) ok1=false;\n\t\t\tif(a[i]-a[j]==a[k]) ok2=false;\n\t\t}\n\t\tif(ok1 && i<=j){\n\t\t\ta[n]=a[i]+a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t\tif(ok2 && a[i]-a[j]>0){\n\t\t\ta[n]=a[i]-a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&tar),tar;){\n\t\tans=77;\n\t\tint a[20]={1};\n\t\tfor(int ub=0;!dfs(1,a,ub);ub++);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct State{\n  vector<int> v;\n  State(vector<int> v) : v(v.begin(), v.end()) {}\n  int head() const {\n    return v.back();\n  }\n  bool operator < (const State& s) const {\n    if(v.size() != s.v.size()) return v.size() > s.v.size();\n    return head() > s.head();\n  }\n};\n\nint main(){\n  vector<int> s;\n  s.push_back(1);\n  priority_queue<State> que;\n  que.push(State(s));\n  int ans[2001];\n  int cnt[2001] = {};\n  REP(i, 2001) ans[i] = INF;\n  const int B = 30;\n  while(!que.empty()){\n    State s = que.top(); que.pop();\n    if(cnt[s.head()] >= B) continue;\n    cnt[s.head()]++;\n    ans[s.head()] = min(ans[s.head()], (int)s.v.size());\n    for(int i = 0; i < s.v.size(); i++){\n      int x = s.head() + s.v[i];\n      if(1 < x && x <= 2000 && cnt[x] < B) {\n        State next = s;\n        next.v.push_back(x);\n        que.push(next);\n      }\n      x = s.head() - s.v[i];\n      if(1 < x && x <= 2000 && cnt[x] < B) {\n        State next = s;\n        next.v.push_back(x);\n        que.push(next);\n      }\n    }\n  }\n  int N;\n  while(cin >> N && N) cout << ans[N] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null expect(int p,int n,ull tar){\n  ull ret=n;\n  while(p--&&ret<tar)ret+=ret;\n  return ret;\n}\n\nint ans;\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar ){\n    ans=min(ans,cnt);\n    return true;\n  }\n  if ( cnt==limit)return false;\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( expect(limit-cnt,findmax,(ull)tar)<(ull)tar){\n    return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited)){\n\tvisited[now+made[i]]=false;\n\treturn true;\n      }\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited)){\n\tvisited[now-made[i]]=false;\n\treturn true;\n      }\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[5002]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    \n    REP(i,lower+1,upper){\n      ans=i;\n      if (solve(1,i,2,n,2,made,visited) ){\n\tupper=ans;\n\tbreak;\n      }\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint X;\nint ANSWER;\nbool exists[1<<13];\nbool ignores[1<<13];\nint estimate[1<<13];\nint cur[13], maxi;\n\nbool init() {\n\tscanf(\"%d\", &X);\n\treturn X > 0;\n}\n\n\nbool dfs(int depth) {\n\tif (depth + estimate[maxi] > ANSWER) {\n\t\treturn false;\n\t}\n\tif (exists[X]) {\n\t\treturn true;\n\t}\n\n\tint nums[13*13];\n\tint n = 0;\n\tfor (int i = 0; i <= depth; ++i) {\n\t\tfor (int j = 0; j <= depth; ++j) {\n\t\t\tconst int add = cur[i] + cur[j];\n\t\t\tconst int sub = cur[i] - cur[j];\n\t\t\tif (i <= j && !exists[add] && !ignores[add]) {\n\t\t\t\tnums[n++] = add;\n\t\t\t}\n\t\t\tif (sub > 0 && !exists[sub] && !ignores[sub]) {\n\t\t\t\tnums[n++] = sub;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(nums, nums + n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint tmp = maxi;\n\t\texists[nums[i]] = true;\n\t\tmaxi = max(maxi, nums[i]);\n\t\tcur[depth + 1] = nums[i];\n\t\tif (dfs(depth + 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tmaxi = tmp;\n\t\texists[nums[i]] = false;\n\t\tignores[nums[i]] = true;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tignores[nums[i]] = false;\n\t}\n\n\treturn false;\n}\n\nint solve() {\n\tmemset(exists, false, sizeof(exists));\n\tmemset(estimate, 0, sizeof(estimate));\n\tmemset(ignores, false, sizeof(ignores));\n\tfor (int i = 1; i < 1<<13; ++i) {\n\t\tint t = i;\n\t\tfor (;t < X; t <<= 1, ++estimate[i]);\n\t}\n\texists[1] = true;\n\tcur[0] = 1;\n\tmaxi = 1;\n\tfor (ANSWER = 0; ANSWER <= 12; ++ANSWER) {\n\t\tif (dfs(0)) {\n\t\t\treturn ANSWER;\n\t\t}\n\t}\n\treturn ANSWER;\n}\n\nint main() {\n\tfor (;scanf(\"%d\", &X), X; printf(\"%d\\n\", solve()));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 8192\n\nint dp[NUM+1];\n\n\nvoid dfs(int current,bool check[NUM+1],int depth){\n\n\tif(depth == 13)return;\n\n\tfor(int i = 1; current+i <= NUM; i++){\n\t\tif(check[i]){\n\t\t\tif(dp[current+i] >= depth+1){\n\t\t\t\tdp[current+i] = depth+1;\n\t\t\t\tbool next_check[NUM+1];\n\t\t\t\tfor(int k = 1; k <= NUM; k++)next_check[k] = check[k];\n\t\t\t\tnext_check[current+i] = true;\n\t\t\t\tdfs(current+i,next_check,depth+1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= current-1; i++){\n\t\tif(check[i]){\n\t\t\tif(dp[current-i] >= depth+1){\n\t\t\t\tdp[current-i] = depth+1;\n\t\t\t\tbool next_check[NUM+1];\n\t\t\t\tfor(int k = 1; k <= NUM; k++)next_check[k] = check[k];\n\t\t\t\tnext_check[current-i] = true;\n\t\t\t\tdfs(current-i,next_check,depth+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tdp[0] = 0;\n\tdp[1] = 0;\n\tfor(int i = 2; i <= NUM; i++)dp[i] = BIG_NUM;\n\n\tbool first_check[NUM+1];\n\n\tfirst_check[1] = true;\n\tfor(int i = 2; i <= NUM; i++)first_check[i] =false;\n\n\tdfs(1,first_check,0);\n\n\tint N;\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tprintf(\"%d\\n\",dp[N]);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null expect(int p,int n,ull tar){\n  ull ret=n;\n  while(p--&&ret<tar)ret+=ret;\n  return ret;\n}\n\nint ans;\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar ){\n    ans=min(ans,cnt);\n    return true;\n  }\n  if ( cnt==limit)return false;\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( expect(limit-cnt,findmax,(ull)tar)<(ull)tar){\n    return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited)){\n\tvisited[now+made[i]]=false;\n\treturn true;\n      }\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited)){\n\tvisited[now-made[i]]=false;\n\treturn true;\n      }\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[5002]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    \n    REP(i,lower+1,upper){\n      ans=i;\n      if (solve(1,i,2,n,2,made,visited) ){\n\tupper=ans;\n\tbreak;\n      }\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint tar;\n\nint hstar(int n,const int *a){\n\tint a_max=*max_element(a,a+n);\n\tint res=0;\n\twhile(a_max<tar) a_max*=2, res++;\n\treturn res;\n}\n\nbool dfs(int n,int *a,int ub){\n\trep(i,n) if(a[i]==tar) return true;\n\n\tif((n-1)>=ub || (n-1)+hstar(n,a)>ub) return false;\n\n\trep(i,n) rep(j,n) {\n\t\tbool ok1=true,ok2=true;\n\t\trep(k,n){\n\t\t\tif(a[i]+a[j]==a[k]) ok1=false;\n\t\t\tif(a[i]-a[j]==a[k]) ok2=false;\n\t\t}\n\t\tif(ok1 && i<=j){\n\t\t\ta[n]=a[i]+a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t\tif(ok2 && a[i]-a[j]>0){\n\t\t\ta[n]=a[i]-a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&tar),tar;){\n\t\tint a[20]={1},ub;\n\t\tfor(ub=0;ub<=12&&!dfs(1,a,ub);ub++);\n\t\tprintf(\"%d\\n\",ub);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct State{\n  vector<int> v;\n  State(vector<int> v) : v(v.begin(), v.end()) {}\n  int head() const {\n    return v.back();\n  }\n  bool operator < (const State& s) const {\n    if(v.size() != s.v.size()) return v.size() > s.v.size();\n    return head() > s.head();\n  }\n};\n\nint main(){\n  vector<int> s;\n  s.push_back(1);\n  priority_queue<State> que;\n  que.push(State(s));\n  int ans[1025];\n  int cnt[1025] = {};\n  REP(i, 1025) ans[i] = INF;\n  const int B = 30;\n  while(!que.empty()){\n    State s = que.top(); que.pop();\n    if(cnt[s.head()] >= B) continue;\n    cnt[s.head()]++;\n    ans[s.head()] = min(ans[s.head()], (int)s.v.size());\n    for(int i = 0; i < s.v.size(); i++){\n      int x = s.head() + s.v[i];\n      if(1 < x && x <= 1024 && cnt[x] < B) {\n        State next = s;\n        next.v.push_back(x);\n        que.push(next);\n      }\n      x = s.head() - s.v[i];\n      if(1 < x && x <= 1024 && cnt[x] < B) {\n        State next = s;\n        next.v.push_back(x);\n        que.push(next);\n      }\n    }\n  }\n  int N;\n  while(cin >> N && N) cout << ans[N] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\nusing namespace std;\nint n;\nint ret=0;\nset<vector<int> >S;\ninline int ABS(int a){return max(a,-a);}\nvoid dfs(vector<int>a,int b,int last){\n\tif(b>=ret)return;\n\t//std::sort(a.begin(),a.end());\n\t//if(S.count(a))return;\n\t//S.insert(a);\n\tint sz=a.size();\n\tint mv=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(a[i]==n){ret=b;return;}\n\t\tmv=max(mv,a[i]);\n\t}\n\tif(b==ret-1)return;\n\tif((mv<<(ret-b-1))<n)return;\n\tfor(int i=0;i<sz;i++){\n\t\tfor(int j=0;j<sz;j++){\n\t\t\tif(a[i]+a[j]==n||ABS(a[i]-a[j])==n){ret=b+1;return;}\n\t\t}\n\t}\n\tvector<int>vis;\n\tfor(int i=sz-1;i>=0;i--)for(int j=i;j>=0;j--){\n\t\tif(a[i]!=last&&a[j]!=last)continue;\n\t\tbool ok=true;\n\t\tfor(int k=0;k<sz;k++)if(a[i]+a[j]==a[k]){ok=false;break;}\n\t\tfor(int k=0;k<vis.size();k++)if(vis[k]==a[i]+a[j]){ok=false;break;}\n\t\tif(ok){\n\t\t\ta.push_back(a[i]+a[j]);\n\t\t\tvis.push_back(a[i]+a[j]);\n\t\t\tdfs(a,b+1,a[i]+a[j]);\n\t\t\ta.pop_back();\n\t\t}\n\t\tok=true;\n\t\tif(a[i]==a[j])continue;\n\t\tfor(int k=0;k<sz;k++)if(ABS(a[i]-a[j])==a[k]){ok=false;break;}\n\t\tfor(int k=0;k<vis.size();k++)if(vis[k]==ABS(a[i]-a[j])){ok=false;break;}\n\t\tif(ok){\n\t\t\ta.push_back(ABS(a[i]-a[j]));\n\t\t\tvis.push_back(ABS(a[i]-a[j]));\n\t\t\tdfs(a,b+1,ABS(a[i]-a[j]));\n\t\t\ta.pop_back();\n\t\t}\n\t}\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tS.clear();\n\t\tn=a;\n\t\tint c=a;\n\t\tret=0;\n\t\twhile(c){\n\t\t\tif(c%2)ret++;\n\t\t\tret++;\n\t\t\tc/=2;\n\t\t}\n\t\tret-=2;\n\t\tret=min(ret,13);\n\t\tvector<int>st;\n\t\tst.push_back(1);\n\t\tdfs(st,0,1);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX = 2048;\nconst int NMAX = 1001;\nconst int LIM = 13;\nconst int inf = 1<<26;\n\n/*\n\n  x x = x^2\n  x^2 x = x^3\n  x^2 x^2 = x^4\n  x^4 x^3? = x^7\n  \n  1 2 4 8 16 32 1 : 31(7)\n  1 2 4 : 7(3?)\n  \n\n  31 = 16 + 15\n  15 = 8 + 7 \n  7 = 4 + 3 4\n  3 = 2 + 1 2\n  2 = 1 + 1 1\n  \n */\n\nbool generated[MAX];\nint res[MAX];\nint goal;\n\nvoid solve(int cur, int depth)\n{\n  res[cur] = min(res[cur], depth);\n  if( cur == goal ){\n    res[goal] = min( res[goal], depth );\n    return ;\n  }\n\n  int max_pred = 0;\n  int pred1 = 1, pred2 = 1;\n  int tcur = cur;\n  while(true){\n    if((tcur<<1)>goal)break;\n    tcur<<=1;\n    ++pred1;\n  }\n  tcur = cur;\n  while(true){\n    if((tcur>>1)<goal)break;\n    tcur>>=1;\n    ++pred2;\n  }\n  max_pred = max( pred1, pred2 );\n  \n  if( max_pred+depth >= res[goal] ) return ;\n  if( max_pred+res[cur] >= res[goal] ) return ;\n  if( max_pred+depth > LIM ) return ;\n  \n  for(int i = 1; i <= cur; ++i){\n    if( !generated[i] ) continue;\n    if( cur<goal && cur+i < MAX && !generated[cur+i] ){\n      generated[cur+i]=true;\n      solve(cur+i,depth+1);\n      generated[cur+i]=false;\n    }\n    if( cur>goal && cur-i >  0  && !generated[cur-i] ){\n      generated[cur-i]=true;\n      solve(cur-i,depth+1);\n      generated[cur-i]=false;\n    }\n  }\n  \n}\n\nint main()\n{\n  for(int i = 0; i < MAX; ++i){\n    res[i] = inf;\n    generated[i] = false;\n  }\n  generated[1] = true;\n  while(true){\n    cin >> goal;\n    if( goal == 0 ) break;\n    \n    solve(1,0);\n    cout << res[goal] << endl;\n  }\n  /*\n  for(int i = 1; i < NMAX; ++i){\n    goal = i;\n    solve(1,0);\n    cout << i << \" : \" << res[i] << endl;\n  }\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint N;\nint num[20];\nbool is_exst[3000];\n\nbool dfs(int, int, int);\n\nint main() {\n  while (cin >> N, N) {\n    fill(&num[0], &num[20], -1), num[0] = 1;\n    fill(&is_exst[0], &is_exst[3000], false), is_exst[1] = true;\n    for (int i = 1; i <= 20; ++i)\n      if (dfs(1, i, 1)) {\n        cout << i - 1 << \"\\n\";\n        break;\n      }\n  }\n\n  return 0;\n}\n\nbool dfs(int dpt, int dpt_lim, int max_elem) {\n  if (is_exst[N])         return true;\n  if (dpt >= dpt_lim)     return false;\n  if (max_elem >= 2 * N)  return false;\n\n  int min_stp = 1;\n  for (int i = max_elem; i * 2 < N; i *= 2)\n    ++min_stp;\n\n  if (dpt + min_stp > dpt_lim)  return false;\n\n  for (int i = 0; i < dpt; ++i)\n    if (!is_exst[max_elem + num[i]]) {\n      num[dpt] = max_elem + num[i], is_exst[max_elem + num[i]] = true;\n      if (dfs(dpt + 1, dpt_lim, max_elem + num[i]))\n        return true;\n      is_exst[max_elem + num[i]] = false;\n    }\n\n  for (int i = 0; i < dpt; ++i)\n    if (max_elem - num[i] > 0 && !is_exst[max_elem - num[i]]) {\n      num[dpt] = max_elem - num[i], is_exst[max_elem - num[i]] = true;\n      if (dfs(dpt + 1, dpt_lim, max_elem))\n        return true;\n      is_exst[max_elem - num[i]] = false;\n    }\n\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes puts(\"Yes\")\n#define no puts(\"No\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\nconst int INF=1LL<<55;\nconst int MOD=1000000007;\n\nbool state[1001];\nvi ans(1001);\nint target;\n\n\nvoid dfs(int depth, int pre, int maxv ){\n  if ( pre == target ){\n    ans[target] = min( ans[target], depth );\n    return;\n  }\n  if ( depth >= ans[target] ) return;\n  \n  int next, d = 0, p = maxv;\n  \n  while( p < target ){d++; p *= 2;}\n  if ( depth + d >= ans[target] ) return;\n  \n  for ( int i = 1; i <= maxv; i++ ){\n    if ( !state[i] ) continue;\n    next = pre + i;\n    if ( next <= 1000 && !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n    next = ( pre > i ) ? ( pre - i ) : (i - pre);\n    if ( !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n  }\n}\n\nvoid solve(){\n    for(int i=0;i<=1001;i++) state[i]=false;\n    state[1]=true;\n    dfs(0,1,1);\n    cout<<ans[target]<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    fill(all(ans),13);\n    while(cin>>target,target){\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\n\null expect(int p,int n,ull tar){\n  ull ret=n;\n  while(p--&&ret<tar)ret+=ret;\n  return ret;\n}\n\nint ans=0,tmp=0;\n\nvoid solve(int cnt,int now,int tar,int num,int *made,bool *visited){\n  if(tmp-1==cnt && ans != tmp)return;\n  if (cnt>=ans)return ;\n  if ( now>=tar*2)return;\n\n  if (now == tar){\n    ans=cnt;\n    return;\n  }\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( expect(ans-cnt,findmax,(ull)tar)<(ull)tar){\n    return;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      solve(cnt+1,now+made[i],tar,num+1,made,visited);\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      solve(cnt+1,now-made[i],tar,num+1,made,visited);\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    tmp=ans=tmp_cost(n);\n    bool visited[5000]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n\n\n    solve(1,2,n,2,made,visited);\n    \n    cout << ans << endl;\n\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nconst int inf=1001;\n\n\nint min_res;\nbool used[2048];\n\ninline int hstar(int cmax,int t){\n\tint x=cmax,ret=0;\n\twhile(x<t) x<<=1,ret++;\n\treturn ret;\n}\n\nint ary[1010];\n\nint dfs(int t,int x,int d,int len){\n\tif(used[t]) return min_res=d;\n\tconst int cmax=*max_element(ary,ary+len);\n\n\tif(d+hstar(cmax,t)>=min_res) return inf;\n\n\tint ret=inf;\n\t\n\tbool made[2048];\n\tclr(made,false);\n\t\n\trrep(i,len){\n\t\tconst int s=ary[i];\n\t\tif(0<x+s && x+s<=2*t && used[x+s]==false && made[x+s]==false){\n\t\t\tmade[x+s]=true;\n\t\t\tused[x+s]=true;\n\t\t\tary[len]=x+s;\n\t\t\tchmin(ret,dfs(t,x+s,d+1,len+1));\n\t\t\tused[x+s]=false;\n\t\t}\n\t}\n\n\trep(i,len){\n\t\tconst int s=ary[i];\n\t\tif(0< x-s && x-s<=2*t && used[x-s]==false && made[x-s]==false){\n\t\t\tmade[x-s]=true;\n\t\t\tused[x-s]=true;\n\t\t\tary[len]=x-s;\n\t\t\tchmin(ret,dfs(t,x-s,d+1,len+1));\n\t\t\tused[x-s]=false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tclr(used,false);\n\t\tused[0]=used[1]=true;\n\t\tary[0]=1;\n\t\tmin_res=0;\n\t\twhile(dfs(n,1,0,1)==inf) min_res++;\n\t\tcout  << min_res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint ans, n, a[105];\n\nbool dfs(int dep, int sum)\n{\n    if (dep > ans || sum<<(ans-dep) < n || sum <= 0) return false;\n    a[dep] = sum;\n    if (sum == n || sum<<(ans-dep) == n) return true;\n    for (int i = 0; i <= dep; ++i)\n        if (dfs(dep+1, sum+a[i]) || dfs(dep+1, sum-a[i])) return true;\n    return false;\n}\n\nint main()\n{\n    while (~scanf(\"%d\", &n) && n)\n        for (ans = 0; ; ++ans)\n            if (dfs(0,1)) {printf(\"%d\\n\", ans); break;}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nconst int INF=1000000000;\n\nint mincost;\nbool usable[2100];\nint N;\nset<int> s;\n\nvoid dfs(int nowNum,int ccost,int maxv){\n  if(ccost>=mincost)return;\n  else if(nowNum==N){\n    mincost=ccost;\n    return;\n  }\n  else if(2048<nowNum)return;\n  int cnt=0;\n  int tmp=nowNum;\n  while(tmp<N){\n    cnt++;\n    tmp*=2;\n  }\n  if(cnt+ccost>=mincost)return;\n  for(int i=1;i<=maxv;i++){\n    //for(set<int>::iterator it=s.begin();it!=s.end();it++){\n    //int i=*it;\n    if(nowNum+i>=2048&&nowNum-i<=1)break;\n    if(usable[i]){\n      int nxtNum=nowNum+i;\n      if(!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\t//s.insert(nxtNum);\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\t//s.erase(nxtNum);\n\tusable[nxtNum]=false;\n      }\n      nxtNum=nowNum-i;\n      if(nxtNum>=2&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\t//s.insert(nxtNum);\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\t//s.erase(nxtNum);\n\tusable[nxtNum]=false;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    //s.clear();\n    memset(usable,0,sizeof(usable));\n    //s.insert(1);\n    usable[1]=true;\n    int popCnt=0;\n    int maxBitPos=0;\n    for(int i=0;i<12;i++){\n      if((N>>i)&1){\n\tpopCnt++;\n\tmaxBitPos=i;\n      }\n    }\n    // initialized with upper bound value\n    mincost=maxBitPos+popCnt-1;\n    //cout<<\"#\"<<mincost<<endl;\n    dfs(1,0,1);\n    cout<<mincost<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nstruct State{\n  vector<int> v;\n  State(vector<int> v) : v(v.begin(), v.end()) {}\n  int head() const {\n    return v.back();\n  }\n  bool operator < (const State& s) const {\n    if(v.size() != s.v.size()) return v.size() > s.v.size();\n    return head() > s.head();\n  }\n};\n\nint main(){\n  vector<int> s;\n  s.push_back(1);\n  priority_queue<State> que;\n  que.push(State(s));\n  int ans[2001];\n  int cnt[2001] = {};\n  REP(i, 2001) ans[i] = INF;\n  const int B = 10;\n  while(!que.empty()){\n    State s = que.top(); que.pop();\n    if(cnt[s.head()] >= B) continue;\n    cnt[s.head()]++;\n    ans[s.head()] = min(ans[s.head()], (int)s.v.size());\n    for(int i = 0; i < s.v.size(); i++){\n      int x = s.head() + s.v[i];\n      if(1 < x && x <= 2000 && cnt[x] < B) {\n        State next = s;\n        next.v.push_back(x);\n        que.push(next);\n      }\n      x = s.head() - s.v[i];\n      if(1 < x && x <= 2000 && cnt[x] < B) {\n        State next = s;\n        next.v.push_back(x);\n        que.push(next);\n      }\n    }\n  }\n  int N;\n  while(cin >> N && N) cout << ans[N] - 1 << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \nusing namespace std;  \nconst int MAXN = 1010;  \nconst int INF = 10000007;  \n  \nint arr[MAXN],num;  \n  \nint dfs(int n,int step){  \n    if (num > step)  \n        return 0;  \n    if (arr[num] == n)  \n        return 1;  \n    if (arr[num] << (step-num) < n)  \n        return false;  \n    for (int i = 0; i <= num; i++){  \n        num++;  \n        arr[num] = arr[num-1] + arr[i];  \n        if (arr[num] <= 10000 && dfs(n,step))  \n            return true;  \n        arr[num] = arr[num-1] - arr[i];  \n        if (arr[num] > 0 && dfs(n,step))  \n            return 1;  \n        num--;  \n    }  \n    return 0;  \n}  \n  \nint main(){  \n    int n;  \n    while (scanf(\"%d\",&n) != EOF && n){  \n        int i;  \n        for (i = 0; ; i++){  \n            arr[num = 0] = 1;  \n            if (dfs(n,i))  \n                break;  \n        }  \n        printf(\"%d\\n\",i);  \n    }      \n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null expect(int p,int n,ull tar){\n  ull ret=n;\n  while(p--&&ret<tar)ret+=ret;\n  return ret;\n}\n\nint ans;\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar ){\n    ans=min(ans,cnt);\n    return true;\n  }\n  if ( cnt==limit)return false;\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( expect(limit-cnt,findmax,(ull)tar)<(ull)tar){\n    return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited)){\n\tvisited[now+made[i]]=false;\n\treturn true;\n      }\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited)){\n\tvisited[now-made[i]]=false;\n\treturn true;\n      }\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[5002]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    \n    for(int i=upper-1;i>=lower;i--){\n      ans=i;\n      if (solve(1,i,2,n,2,made,visited) ){\n\t//cout << \"solved at \" <<i<<\" with \" << ans << endl;\n\tupper=ans;\n\ti=ans;\n      }\n      //else cout << \"unsolved at \" <<i<<endl;\n\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null expect(int p,int n,ull tar){\n  ull ret=n;\n  while(p--&&ret<tar)ret+=ret;\n  return ret;\n}\n\nint ans;\nbool solve(int cnt,int limit,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>limit)return false;\n  if ( now>=tar*2)return false;//may not be need?\n  \n  if (now == tar ){\n    ans=min(ans,cnt);\n    return true;\n  }\n  if ( cnt==limit)return false;\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( expect(limit-cnt,findmax,(ull)tar)<(ull)tar){\n    return false;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      if (solve(cnt+1,limit,now+made[i],tar,num+1,made,visited)){\n\tvisited[now+made[i]]=false;\n\treturn true;\n      }\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      if (solve(cnt+1,limit,now-made[i],tar,num+1,made,visited)){\n\tvisited[now-made[i]]=false;\n\treturn true;\n      }\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return false;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    int upper=tmp_cost(n);\n    bool visited[3002]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n        \n    \n    int lower=0,tmp=1;\n    while(tmp<n){\n      tmp*=2;\n      lower++;\n    }\n    \n    for(int i=upper-1;i>=lower;i--){\n      ans=i;\n      if (solve(1,i,2,n,2,made,visited) ){\n\t//cout << \"solved at \" <<i<<\" with \" << ans << endl;\n\tupper=ans;\n\ti=ans;\n      }\n      //else cout << \"unsolved at \" <<i<<endl;\n\n    }\n    cout << upper << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    const int MAX_N = 1000;\n\n    int N;\n    bool input() {\n        cin >> N;\n        return N != 0;\n    }\n\n    int ans[1000] = {\n              0 , 1 , 2 , 2 , 3 , 3 , 4 , 3 , 4 , 4\n            , 5 , 4 , 5 , 5 , 5 , 4 , 5 , 5 , 6 , 5\n            , 6 , 6 , 6 , 5 , 6 , 6 , 6 , 6 , 7 , 6\n            , 6 , 5 , 6 , 6 , 7 , 6 , 7 , 7 , 7 , 6\n            , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 6 , 7 , 7\n            , 7 , 7 , 8 , 7 , 8 , 7 , 8 , 8 , 8 , 7\n            , 8 , 7 , 7 , 6 , 7 , 7 , 8 , 7 , 8 , 8\n            , 8 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 7\n            , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 8 , 9 , 8\n            , 9 , 8 , 8 , 8 , 8 , 7 , 8 , 8 , 8 , 8\n            , 9 , 8 , 9 , 8 , 9 , 9 , 9 , 8 , 9 , 9\n            , 9 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 8\n            , 9 , 9 , 9 , 8 , 9 , 8 , 8 , 7 , 8 , 8\n            , 9 , 8 , 9 , 9 , 9 , 8 , 9 , 9 , 9 , 9\n            , 9 , 9 , 9 , 8 , 9 , 9 , 9 , 9 , 9 , 9\n            , 10 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 8\n            , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 9 , 10 , 9\n            , 10 , 9 , 10 , 10 , 10 , 9 , 10 , 10 , 10 , 9\n            , 10 , 10 , 10 , 9 , 10 , 9 , 10 , 9 , 9 , 9\n            , 9 , 8 , 9 , 9 , 9 , 9 , 10 , 9 , 10 , 9\n            , 10 , 10 , 10 , 9 , 10 , 10 , 10 , 9 , 10 , 10\n            , 10 , 10 , 10 , 10 , 10 , 9 , 10 , 10 , 10 , 10\n            , 10 , 10 , 10 , 9 , 10 , 10 , 10 , 10 , 10 , 10\n            , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 9\n            , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 9 , 10 , 10\n            , 10 , 9 , 10 , 9 , 9 , 8 , 9 , 9 , 10 , 9\n            , 10 , 10 , 10 , 9 , 10 , 10 , 11 , 10 , 11 , 10\n            , 10 , 9 , 10 , 10 , 11 , 10 , 11 , 10 , 10 , 10\n            , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 9 , 10 , 10\n            , 10 , 10 , 10 , 10 , 11 , 10 , 10 , 10 , 11 , 10\n            , 11 , 11 , 11 , 10 , 11 , 10 , 11 , 10 , 11 , 10\n            , 11 , 10 , 11 , 10 , 10 , 10 , 10 , 10 , 10 , 9\n            , 10 , 10 , 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10\n            , 11 , 10 , 11 , 11 , 11 , 10 , 11 , 11 , 11 , 10\n            , 11 , 11 , 11 , 10 , 11 , 11 , 11 , 11 , 11 , 11\n            , 11 , 10 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 10\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 10 , 11 , 11\n            , 11 , 10 , 11 , 11 , 11 , 10 , 11 , 10 , 11 , 10\n            , 10 , 10 , 10 , 9 , 10 , 10 , 10 , 10 , 11 , 10\n            , 11 , 10 , 11 , 11 , 11 , 10 , 11 , 11 , 11 , 10\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 10 , 11 , 11\n            , 11 , 11 , 11 , 11 , 11 , 10 , 11 , 11 , 11 , 11\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11\n            , 11 , 10 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 10 , 11 , 11\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11\n            , 12 , 11 , 12 , 11 , 11 , 11 , 12 , 11 , 12 , 11\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 10\n            , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11\n            , 12 , 11 , 12 , 11 , 11 , 10 , 11 , 11 , 12 , 11\n            , 12 , 11 , 11 , 10 , 11 , 11 , 11 , 10 , 11 , 10\n            , 10 , 9 , 10 , 10 , 11 , 10 , 11 , 11 , 11 , 10\n            , 11 , 11 , 12 , 11 , 12 , 11 , 11 , 10 , 11 , 11\n            , 12 , 11 , 12 , 12 , 11 , 11 , 12 , 12 , 12 , 11\n            , 12 , 11 , 11 , 10 , 11 , 11 , 12 , 11 , 12 , 12\n            , 12 , 11 , 11 , 12 , 12 , 11 , 12 , 11 , 12 , 11\n            , 11 , 11 , 12 , 11 , 12 , 11 , 11 , 11 , 12 , 11\n            , 11 , 11 , 11 , 11 , 11 , 10 , 11 , 11 , 11 , 11\n            , 11 , 11 , 12 , 11 , 11 , 11 , 12 , 11 , 12 , 12\n            , 12 , 11 , 12 , 11 , 12 , 11 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 11 , 12 , 12\n            , 12 , 11 , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 11 , 12 , 11\n            , 12 , 11 , 12 , 11 , 11 , 11 , 11 , 11 , 11 , 10\n            , 11 , 11 , 11 , 11 , 11 , 11 , 12 , 11 , 12 , 11\n            , 12 , 11 , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 11 , 12 , 12\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 11 , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 11\n            , 12 , 11 , 12 , 11 , 11 , 11 , 11 , 10 , 11 , 11\n            , 11 , 11 , 12 , 11 , 12 , 11 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12\n            , 13 , 12 , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12\n            , 13 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 12 , 12 , 12 , 13 , 12 , 12 , 12\n            , 13 , 12 , 13 , 12 , 12 , 12 , 13 , 12 , 12 , 12\n            , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12 , 12 , 12\n            , 13 , 12 , 12 , 12 , 13 , 12 , 13 , 12 , 12 , 12\n            , 13 , 12 , 13 , 12 , 13 , 12 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 12 , 12 , 11 , 12 , 12 , 12 , 12\n            , 12 , 12 , 12 , 12 , 12 , 12 , 13 , 12 , 13 , 12\n            , 13 , 12 , 13 , 12 , 13 , 12 , 13 , 12 , 13 , 12\n            , 13 , 13 , 13 , 12 , 13 , 13 , 13 , 12 , 13 , 12\n            , 13 , 12 , 13 , 13 , 13 , 12 , 13 , 13 , 13 , 12\n            , 13 , 12 , 13 , 12 , 12 , 12 , 13 , 12 , 13 , 12\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 11\n            , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12\n            , 13 , 12 , 13 , 12 , 12 , 12 , 12 , 12 , 13 , 12\n            , 13 , 13 , 13 , 12 , 13 , 13 , 13 , 12 , 13 , 12\n            , 12 , 11 , 12 , 12 , 13 , 12 , 13 , 13 , 13 , 12\n    };\n\n    void solve() {\n        cout << ans[N - 1] << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e3 + 10;\n\nint n, maxd, p[maxn];\n\nbool dfs(int d) {\n\tif(p[d] == n) return true;\n\tif(d == maxd) return false;\n\n\tint maxi = 0;\n\tfor(int i = 0; i <= d; i++) maxi = max(maxi, p[i]);\n\tif(maxi*pow(2, maxd-d) < n) return false;\n\n\tfor(int i = d; i >= 0; i--) {\n\t\tp[d+1] = p[d] + p[i];\n\t\tif(dfs(d+1)) return true;\n\t\tp[d+1] = p[d] - p[i];\n\t\tif(dfs(d+1)) return true;\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tp[0] = 1;\n\n\twhile(scanf(\"%d\", &n) && n) {\n\t\tfor(maxd = log2(n);; maxd++) if(dfs(0)) break;\n\t\tprintf(\"%d\\n\", maxd);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\nint ans=0;\n\nvoid solve(int cnt,int now,int tar,int num,int *made,bool *visited){\n  if( cnt>=ans)return;\n  if (now == tar){\n    ans=min(ans,cnt);\n    return;\n  }\n  \n  rep(i,num){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      solve(cnt+1,now+made[i],tar,num+1,made,visited);\n      visited[now+made[i]]=false;\n    }\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      solve(cnt+1,now-made[i],tar,num+1,made,visited);\n      visited[now-made[i]]=false;\n    }\n\n  }\n\n  return;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    ans=tmp_cost(n);\n    bool visited[3000]={false};\n    int  made[30];\n    visited[1]=true;\n    made[0]=1;\n    solve(0,1,n,1,made,visited);\n    \n    cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint res[] = { 0, 0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 6, 5, 6, 6, 7, 6, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7, 8, 7, 7, 6, 7, 7, 8, 7, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 8, 9, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 8, 9, 8, 8, 7, 8, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 10, 9, 9, 9, 9, 8, 9, 9, 9, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 9, 8, 9, 9, 10, 9, 10, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10, 10, 10, 10, 9, 10, 10, 10, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 11, 11, 10, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 11, 11, 12, 12, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 12, 11, 11, 12, 12, 11, 12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 11, 11, 11, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 11, 11, 11, 10, 11, 11, 11, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 11, 12, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 12, 11, 12, 12, 13, 12, 13, 13, 13, 12 };\n\nint main(void){\n    for(int n; cin >> n, n;){\n        cout << res[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null mypow(int p,int n){\n  if (p == 1)return n;\n  ull ret =mypow(p/2,n);\n  ret=ret*ret;\n  if (p%2==1)ret*=n;\n  return ret;\n}\n\nint ans=0;\nint path[100];\n\nvoid solve(int cnt,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>=ans)return ;\n  if ( now>=tar*2)return;\n\n  if (now == tar){\n    if (cnt<=ans){\n      /*\n      cout << cnt << \" path \" ; \n      rep(i,num)cout<<path[i]<<\" \";\n      cout << endl;\n      */\n    }\n    ans=cnt;\n    return;\n  }\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( mypow(1+ans-cnt,findmax)<(ull)tar){\n    return;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      path[num]=now+made[i];\n      solve(cnt+1,now+made[i],tar,num+1,made,visited);\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      solve(cnt+1,now-made[i],tar,num+1,made,visited);\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    ans=tmp_cost(n);\n    bool visited[3000]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n    path[0]=1;\n    path[1]=2;\n    \n\n\n    solve(1,2,n,2,made,visited);\n    \n    cout << ans << endl;\n\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nconst int INF=1000000000;\n\nint mincost;\nbool usable[2100];\nint N;\nint dp[1001];\n\nvoid dfs(int nowNum,int ccost,int maxv){\n  if(ccost>=mincost)return;\n  else if(nowNum==N){\n    mincost=ccost;\n    return;\n  }\n  else if(2048<nowNum)return;\n  int cnt=0;\n  int tmp=nowNum;\n  while(tmp<N){\n    cnt++;\n    tmp*=2;\n  }\n  if(cnt+ccost>=mincost)return;\n  for(int i=1;i<=maxv;i++){\n    if(nowNum+i>=2048&&nowNum-i<=1)break;\n    if(usable[i]){\n      int nxtNum=nowNum+i;\n      if(nxtNum<=2048&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\tusable[nxtNum]=false;\n      }\n      nxtNum=nowNum-i;\n      if(nxtNum>=2&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\tusable[nxtNum]=false;\n      }\n    }\n  }\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  while(cin>>N&&N){\n    if(dp[N]==-1){\n      memset(usable,0,sizeof(usable));\n      usable[1]=true;\n      int popCnt=0;\n      int maxBitPos=0;\n      for(int i=0;i<12;i++){\n\tif((N>>i)&1){\n\t  popCnt++;\n\t  maxBitPos=i;\n\t}\n      }\n      // initialized with upper bound value\n      mincost=maxBitPos+popCnt-1;\n      dfs(1,0,1);\n      dp[N]=mincost;\n    }\n    else mincost=dp[N];\n    cout<<mincost<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\nclass PowerTree{\n\tset<int> s;\n\tint n;\n\tstruct Node{\n\t\tNode *parent;\n\t\tint val;\n\t\tvector<Node> nodes;\n\t\tint depth;\n\t\tvoid init(){\n\t\t\tnodes.reserve(2000+2);\n\t\t}\n\t};\n\tNode root;\n\tmap<int,int> ans;\n\tvoid dfs(Node *now,vector<int> &res){\n\t\tres.push_back(now->val);\n\t\tif(now->parent){\n\t\t\tdfs(now->parent,res);\n\t\t}\n\t}\npublic:\n\tPowerTree(int n):n(n){\n\t\ts.insert(1);\n\t\troot.val=1;\n\t\tqueue<Node*> que;\n\t\tque.push(&root);\n\t\troot.parent=0;\n\t\troot.depth=0;\n\t\troot.init();\n\t\twhile(!que.empty()){\n\t\t\tNode *node=que.front();que.pop();\n\t\t\tans[node->val]=node->depth;\n\t\t\tvector<int> d;\n\t\t\tdfs(node,d);\n\t\t\tfor(int i=0;i<(int)d.size();i++){\n\t\t\t\tint next=d[i]+node->val;\n\t\t\t\tif(next<n&&s.count(next)==0){\n\t\t\t\t\ts.insert(next);\n\t\t\t\t\tnode->nodes.push_back((Node){node,next,vector<Node>(),node->depth+1});\n\t\t\t\t\tnode->nodes.back().init();\n\t\t\t\t\tque.push(&node->nodes.back());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \t}\n\tint operator()(int x){\n\t\treturn ans[x];\n\t}\n};\n\n\nint main() {\n\tPowerTree pt(1002); //ツつィツつィツづヲツつサツづ個督堋つヲ\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 1 から 1000 まで答えを計算するのに 5 min 30 sec\n/*\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint tar;\n\nint hstar(int n,const int *a){\n\tint a_max=*max_element(a,a+n);\n\tint res=0;\n\twhile(a_max<tar) a_max*=2, res++;\n\treturn res;\n}\n\nbool dfs(int n,int *a,int ub){\n\trep(i,n) if(a[i]==tar) return true;\n\n\tif((n-1)>=ub || (n-1)+hstar(n,a)>ub) return false;\n\n\trep(i,n) rep(j,n) {\n\t\tbool ok1=true,ok2=true;\n\t\trep(k,n){\n\t\t\tif(a[i]+a[j]==a[k]) ok1=false;\n\t\t\tif(a[i]-a[j]==a[k]) ok2=false;\n\t\t}\n\t\tif(ok1 && i<=j){\n\t\t\ta[n]=a[i]+a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t\tif(ok2 && a[i]-a[j]>0){\n\t\t\ta[n]=a[i]-a[j];\n\t\t\tif(dfs(n+1,a,ub)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(tar=1;tar<=1000;tar++){\n\t\tint a[20]={1},ub;\n\t\tfor(ub=0;ub<=12&&!dfs(1,a,ub);ub++);\n\t\tprintf(\"%d,\",ub);\n\t}\n\treturn 0;\n}\n*/\n\n#include<cstdio>\n\nusing namespace std;\n\nconst int emb[1001]={-1,0,1,2,2,3,3,4,3,4,4,5,4,5,5,5,4,5,5,6,5,6,6,6,5,6,6,6,6,7,6,6,5,6,6,7,6,7,7,7,6,7,7,7,7,7,7,7,6,7,7,7,7,8,7,8,7,8,8,8,7,8,7,7,6,7,7,8,7,8,8,8,7,8,8,8,8,8,8,8,7,8,8,8,8,8,8,9,8,9,8,9,8,8,8,8,7,8,8,8,8,9,8,9,8,9,9,9,8,9,9,9,8,9,9,9,9,9,9,9,8,9,9,9,8,9,8,8,7,8,8,9,8,9,9,9,8,9,9,9,9,9,9,9,8,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,8,9,9,9,9,9,9,10,9,10,9,10,9,10,10,10,9,10,10,10,9,10,10,10,9,10,9,10,9,9,9,9,8,9,9,9,9,10,9,10,9,10,10,10,9,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,9,10,10,10,10,10,10,10,9,10,10,10,9,10,9,9,8,9,9,10,9,10,10,10,9,10,10,11,10,11,10,10,9,10,10,11,10,11,10,10,10,10,10,10,10,10,10,10,9,10,10,10,10,10,10,11,10,10,10,11,10,11,11,11,10,11,10,11,10,11,10,11,10,11,10,10,10,10,10,10,9,10,10,10,10,10,10,11,10,11,10,11,10,11,11,11,10,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,10,11,11,11,10,11,10,11,10,10,10,10,9,10,10,10,10,11,10,11,10,11,11,11,10,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,11,12,11,12,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,12,11,12,11,11,10,11,11,12,11,12,11,11,10,11,11,11,10,11,10,10,9,10,10,11,10,11,11,11,10,11,11,12,11,12,11,11,10,11,11,12,11,12,12,11,11,12,12,12,11,12,11,11,10,11,11,12,11,12,12,12,11,11,12,12,11,12,11,12,11,11,11,12,11,12,11,11,11,12,11,11,11,11,11,11,10,11,11,11,11,11,11,12,11,11,11,12,11,12,12,12,11,12,11,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,11,12,11,12,11,11,11,11,11,11,10,11,11,11,11,11,11,12,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,11,12,12,12,11,12,11,12,11,11,11,11,10,11,11,11,11,12,11,12,11,12,12,12,11,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,11,12,12,12,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,13,12,12,12,13,12,12,12,12,12,12,11,12,12,12,12,12,12,13,12,12,12,13,12,13,12,12,12,13,12,13,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,13,13,12,13,13,13,12,13,12,13,12,13,13,13,12,13,13,13,12,13,12,13,12,12,12,13,12,13,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,13,12,13,12,12,12,12,12,13,12,13,13,13,12,13,13,13,12,13,12,12,11,12,12,13,12,13,13,13,12};\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;) printf(\"%d\\n\",emb[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint save[20][20],vis[25][25],n,m,dust,ct,lp,stx,sty,sum,minn;\nint mov[4][2]= {1,0,0,-1,-1,0,0,1};\nchar plate[25][25];\nint visp[20];\n\nstruct status\n{\n    int cnt;\n    int x,y;\n    status(int a,int b,int c)\n    {\n        x = a, y = b, cnt = c;\n    }\n};\nstruct point\n{\n    int x,y;\n}p[20];\n\nqueue<struct status> q;\n\nvoid maek()\n{\n    while(!q.empty())\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n            save[0][ct+1] = q.front().cnt, p[ct+1].x = q.front().x, p[ct+1].y = q.front().y, ct++;\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\nvoid play(int x, int y, int ord)\n{\n    int ctt = 0;\n    vis[q.front().x][q.front().y] = 1;\n    while(ctt != ct)\n    {\n        if(plate[q.front().x][q.front().y]=='*')\n        {\n            int r;\n            for(r=1; r<=ct; r++)\n                if(p[r].x == q.front().x && p[r].y == q.front().y) break;\n            save[ord][r] = q.front().cnt, ctt++;\n        }\n\n        for(int i=0; i<4; i++)\n        {\n            int tx = q.front().x + mov[i][0], ty = q.front().y + mov[i][1];\n            if(tx >= 0 && tx < m && ty >=0 && ty < n && plate[tx][ty] != 'x' && !vis[tx][ty])\n            {\n                struct status temp(tx, ty, q.front().cnt + 1);\n                vis[tx][ty] = 1;\n                q.push(temp);\n            }\n        }\n        q.pop();\n    }\n}\n\n\nvoid dfs(int x,int y,int ore)\n{\n    //printf(\"%d %d %d %d\\n\",x,y,ore,sum);\n\n    if(x==y)\n    {\n        minn = minn > sum ? sum : minn;\n    }\n\n    for(int i=1; i<=ct; i++)\n    {\n        if(!visp[i])\n        {\n            if(sum + save[ore][i] > minn) continue;\n            else\n            {\n                sum += save[ore][i];\n                x++;\n                visp[i] = 1;\n                dfs(x,y,i);\n                visp[i] = 0;\n                sum -= save[ore][i];\n                x--;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n    //freopen(\"C://1140-input.txt\",\"r\",stdin);\n    //freopen(\"C://zout.txt\",\"w\",stdout);\n\n    while(~scanf(\"%d%d\",&n,&m),n+m)\n    {\n\n        memset(plate, 0, sizeof(plate));\n        memset(vis,0,sizeof(vis));\n        memset(save,0,sizeof(save));\n        memset(visp,0,sizeof(visp));\n        memset(p,0,sizeof(p));\n\n        getchar();\n        lp = 0, ct = 0;\n        for(int i=0; i<m; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                scanf(\"%c\",&plate[i][j]);\n                if(plate[i][j]=='o') stx = i, sty = j;\n                if(plate[i][j]=='*') lp++;\n            }\n            getchar();\n        }\n\n        struct status tm(stx,sty,0);\n        q.push(tm);\n        maek();\n\n        if(ct != lp) printf(\"-1\\n\");\n        else\n        {\n            for(int i=1; i<=ct; i++)\n            {\n                memset(vis,0,sizeof(vis));\n                struct status temp(p[i].x, p[i].y, 0);\n                q.push(temp);\n                play(p[i].x, p[i].y, i);\n                while(!q.empty()) q.pop();\n            }\n\n            /*for(int i=0;i<=ct;i++)\n            {\n                for(int j=0;j<=ct;j++)\n                {\n                    printf(\"%3d \",save[i][j]);\n                }\n                printf(\"\\n\");\n            }*/\n            minn = 99999999;\n\n            for(int i=1; i<=ct; i++)\n            {\n                memset(visp,0,sizeof(visp));\n                sum = save[0][i],visp[i] = 1;\n                dfs(1,ct,i);\n            }\n            printf(\"%d\\n\",minn);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define N 11\n\nusing namespace std;\n\nint dp[N];\n\nvoid init(){\n  for(int i=0, j=1; i<N; ++i, j*=2){\n    //    cout << j << endl;\n    dp[i] = j;\n  }\n}\n\nint search_near(int& x){\n  int n=0;\n  int abs_=abs(x - dp[0]);\n  for(int i=0; i<N; ++i){\n    if(abs_ > abs(x - dp[i])){\n      abs_ = abs(x - dp[i]);\n      n = i;\n    }\n  }\n  return n;\n}\n\nint solve(int x){\n  int n, ans;\n  n = search_near(x);\n  ans = n;\n  x = abs(x - dp[n]);\n  //  cout << n  << \" \"<< dp[n] <<\" \"<< x << endl;\n  if(x == 0) return ans;\n  while(1){\n    n = search_near(x);\n    x = abs(x - dp[n]);\n    ++ans;\n    //    cout << dp[n] <<\" \"<< x << endl;\n    if(x == 0) return ans;\n  }\n}\n\nint main(){\n  int x;\n  init();\n  while(1){\n    cin >> x;\n    if(!x) break;\n    cout << solve(x) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string.h>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nclass info{\npublic:\n\tint id,cost;\n\tvector<int> bef;\n\tinfo(int id,int cost,vector<int> bef):bef(bef),id(id),cost(cost){}\n};\n\nint main()\n{\n\tint n;\n\twhile(cin>>n && n!=0){\n\t\tbool done[1001];\n\t\tint ans[1001];\n\t\tfor(int i=0;i<1001;i++)\n\t\t\tans[i]=100000;\n\t\tmemset(done,false,sizeof(done));\n\t\tqueue<info> que;\n\t\tque.push(info(1,0,vector<int>(1,1)));\n\t\twhile(!que.empty()){\n\t\t\tinfo now=que.front();que.pop();\n\t\t\tif(now.id<0 || now.id>1000) continue;\n\t\t\tif(ans[now.id]<now.cost) continue;\n\t\t\tans[now.id]=now.cost;\n\n//\t\t\tnow.bef.push_back(now.id);\n\t\t\tif(now.id==n){cout<<now.cost<<endl; break;}\n\t\t\tfor(int i=0;i<now.bef.size();i++){\n\t\t\t\tvector<int> copy=now.bef;\n\t\t\t\tcopy.push_back(now.id+now.bef[i]);\n\t\t\t\tque.push(info(now.id+now.bef[i],now.cost+1,copy));\n\n\t\t\t\tcopy=now.bef;\n\t\t\t\tcopy.push_back(now.id-now.bef[i]);\n\t\t\t\tque.push(info(now.id-now.bef[i],now.cost+1,copy));\n\t\t\t}\n//\t\t\tque.push(info(now.id*2,now.cost+1,now.bef));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null mypow(int p,int n){\n  if (p == 1)return n;\n  ull ret =mypow(p/2,n);\n  ret=ret*ret;\n  if (p%2==1)ret*=n;\n  return ret;\n}\n\nint ans=0;\nint path[100];\n\nvoid solve(int cnt,int now,int tar,int num,int *made,bool *visited){\n  if (cnt>=ans)return ;\n  if ( now>=tar*2)return;\n\n  if (now == tar){\n    if (cnt<=ans){\n      /*\n      cout << cnt << \" path \" ; \n      rep(i,num)cout<<path[i]<<\" \";\n      cout << endl;\n      */\n    }\n    ans=cnt;\n    return;\n  }\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( mypow(1+ans-cnt,findmax)<(ull)tar){\n    //  return;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      path[num]=now+made[i];\n      solve(cnt+1,now+made[i],tar,num+1,made,visited);\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      solve(cnt+1,now-made[i],tar,num+1,made,visited);\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    ans=tmp_cost(n);\n    bool visited[3000]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n    path[0]=1;\n    path[1]=2;\n    \n\n\n    solve(1,2,n,2,made,visited);\n    \n    cout << ans << endl;\n\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\nusing namespace std;\nconstexpr int max_n = 1000;\nconstexpr int used_len = 2 * max_n;\nbool iddfs(vector<int> & s, array<bool,used_len> & used, int mx, int depth, int n) {\n    if (used[n]) return true;\n    if (depth == 0) return false;\n    if ((mx << depth) < n) return false;\n    repeat_reverse (i,s.size()) {\n        repeat_reverse (j,i+1) {\n            for (int x : { s[i] + s[j], abs(s[i] - s[j]) }) {\n                if (x <= 0 or used_len <= x) continue;\n                if (used[x]) continue;\n                used[x] = true;\n                s.push_back(x);\n                if (iddfs(s, used, max(mx, x), depth-1, n)) return true;\n                s.pop_back();\n                used[x] = false;\n            }\n        }\n    }\n    return false;\n}\nint iddfs(int n) {\n    int depth = 0;\n    while (true) {\n        vector<int> s { 1 };\n        array<bool,used_len> used = {};\n        used[1] = true;\n        if (iddfs(s, used, 1, depth, n)) break;\n        depth += 1;\n    }\n    return depth;\n}\nint main() {\n    repeat_from (n,1,max_n+1) {\n        cout << iddfs(n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef long long ll;\n\nbool flag[1501];\nint v[1501];\nint n;\n\nbool can(int a, int rest) {\n  while(rest--)a+=a;\n  return a>=n;\n}\n\nbool dfs(int now, int d, int len, int ma) {\n  if (d == 0) return flag[n];\n  if (d == 1) return flag[abs(now-n)];\n  if (!can(ma,d)) return 0;\n  // cout << now << \" \" << d << endl;\n  // cout << \"v = \";\n  // REP(i, len) cout << v[i] << \" \";\n  // cout << endl;\n  for (int i=len-1; i>=0; i--) {\n    int next = v[i]+now;\n    if (next<=n*3/2 && !flag[next]) {\n      v[len] = next;\n      flag[next] = 1;\n      if (dfs(next,d-1,len+1,max(ma, next))) return 1;\n      flag[next] = 0;\n    }\n    next = now-v[i];\n    if (next > 0 && !flag[next]) {\n      v[len] = next;\n      flag[next] = 1;\n      if (dfs(next,d-1,len+1,ma)) return 1;\n      flag[next] = 0;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin >> n, n) {\n  //for (n=1;n<=1000;++n) {\n    REP(p,14) {\n      if (p == 13) {\n        cout << p << endl;\n        break;\n      }\n      //cout << \"p = \" << p << endl;\n      memset(flag,0,sizeof(flag));\n      flag[1] = 1;\n      v[0] = 1;\n      if (dfs(1,p,1,1)) {\n        cout << p << endl;\n        break;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nconst int INF=1000000000;\n\nint mincost;\nbool usable[1100];\nint N;\n\nvoid dfs(int nowNum,int ccost,int maxv){\n  if(ccost>=mincost)return;\n  else if(nowNum==N){\n    mincost=ccost;\n    return;\n  }\n  else if(1024<nowNum)return;\n  int cnt=0;\n  int tmp=nowNum;\n  while(tmp<N){\n    cnt++;\n    tmp*=2;\n  }\n  if(cnt+ccost>=mincost)return;\n  for(int i=1;i<=maxv;i++){\n    if(nowNum+i>=1024&&nowNum-i<=1)break;\n    if(usable[i]){\n      int nxtNum=nowNum+i;\n      if(nxtNum<=1024&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\tusable[nxtNum]=false;\n      }\n      nxtNum=nowNum-i;\n      if(nxtNum>=2&&!usable[nxtNum]){\n\tusable[nxtNum]=true;\n\tdfs(nxtNum,ccost+1,max(nxtNum,maxv));\n\tusable[nxtNum]=false;\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    memset(usable,0,sizeof(usable));\n    usable[1]=true;\n    int popCnt=0;\n    int maxBitPos=0;\n    for(int i=0;i<12;i++){\n      if((N>>i)&1){\n\tpopCnt++;\n\tmaxBitPos=i;\n      }\n    }\n    // initialized with upper bound value\n    mincost=maxBitPos+popCnt-1;\n    dfs(1,0,1);\n    cout<<mincost<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef unsigned long long ull;\n\nint tmp_cost(int p){\n  if( p==1)return 0;\n  int ret=tmp_cost(p/2)+1+p%2;\n  return ret;\n}\n\null mypow(int p,int n){\n  if (p == 1)return n;\n  ull ret =mypow(p/2,n);\n  ret=ret*ret;\n  if (p%2==1)ret*=n;\n  return ret;\n}\n\nint ans=0,tmp=0;\nint path[100];\n\nvoid solve(int cnt,int now,int tar,int num,int *made,bool *visited){\n  if(tmp-1==cnt && ans != tmp)return;\n  if (cnt>=ans)return ;\n  if ( now>=tar*2)return;\n\n  if (now == tar){\n    if (cnt<=ans){\n      /*\n      cout << cnt << \" path \" ; \n      rep(i,num)cout<<path[i]<<\" \";\n      cout << endl;\n      */\n    }\n    ans=cnt;\n    return;\n  }\n\n  int findmax=0;\n  REP(i,0,num)findmax=max(findmax,made[i]);\n  if( mypow(1+ans-cnt,findmax)<(ull)tar){\n    return;\n  }\n\n\n\n  for(int i=num-1;i>=0;i--){\n    //mul\n    if ( visited[now+made[i]]==false){\n      visited[now+made[i]]=true;\n      made[num]=now+made[i];\n      path[num]=now+made[i];\n      solve(cnt+1,now+made[i],tar,num+1,made,visited);\n      visited[now+made[i]]=false;\n    }\n\n\n    //div\n    if( now-made[i]>0 && visited[now-made[i]]==false){\n      visited[now-made[i]]=true;\n      made[num]=now-made[i];\n      solve(cnt+1,now-made[i],tar,num+1,made,visited);\n      visited[now-made[i]]=false;\n    }\n\n\n  }\n\n  return;\n}\n\nmain(){\n  int n;\n  while(cin>>n&&n){\n    tmp=ans=tmp_cost(n);\n    bool visited[3000]={false};\n    int  made[30];\n    visited[1]=true;\n    visited[2]=true;\n    made[0]=1;\n    made[1]=2;\n    path[0]=1;\n    path[1]=2;\n    \n\n\n    solve(1,2,n,2,made,visited);\n    \n    cout << ans << endl;\n\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": " \n    #include<iostream>\n     \n    using namespace std;\n     \n    const int N = 1000;\n    int n, ans, now[N + 1];\n     \n    bool idax(int dep)\n    {\n        if(dep > ans)\n            return false;\n        if((now[dep] << (ans - dep)) < n) // 剪枝\n            return false;\n        if(now[dep] == n)\n            return true;\n     \n        for(int i=0; i<=dep; i++) {\n            now[dep + 1] = now[dep] + now[i];\n            if (idax(dep + 1))\n                return true;\n            now[dep + 1] = now[dep] - now[i];\n            if (idax(dep + 1))\n                return true;\n        }\n     \n        return false;\n    }\n     \n    int main()\n    {\n        now[0] = 1;\n     \n        while(cin>>n && n) {\n            ans = 0;\n            while(!idax(0))\n                ans++;\n            cout << ans << endl;\n        }\n     \n        return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[300][300];\nchar field[200][200];\n\nll ans = 0;\nbool dfs(int depth,int x){\n  if(depth > ans || (x << (ans - depth)) < n || x <= 0)return false;\n  d[depth] = x;\n  if(x == n || (x << (ans - depth)) == n)return true;\n  lep(i,0,depth){\n    if(dfs(depth + 1,x + d[i]) || dfs(depth + 1,x-d[i]))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> n,n){\n    ans = 0;\n    while(1){\n      if(dfs(0,1)){\n        print(ans);\n        break;\n      }\n      ans++;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 1000\n#define LIMIT 13\n\nbool state[MAX+1];\nint ans[MAX+1];\nint target;\n\nvoid dfs(int depth, int pre, int maxv ){\n  if ( pre == target ){\n    ans[target] = min( ans[target], depth );\n    return;\n  }\n  if ( depth >= ans[target] ) return;\n\n  int next, d = 0, p = maxv;\n\n  while( p < target ){d++; p *= 2;}\n  if ( depth + d >= ans[target] ) return;\n\n  for ( int i = 1; i <= maxv; i++ ){\n    if ( !state[i] ) continue;\n\n    next = pre + i;\n    if ( next <= MAX && !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n\n    next = ( pre > i ) ? ( pre - i ) : (i - pre);\n    if ( !state[next] ){\n      state[next] = true;\n      dfs(depth+1, next, max(maxv, next));\n      state[next] = false;\n    }\n  }\n}\n\nmain(){\n  for ( int i = 0; i <= MAX+1; i++ ) ans[i] = LIMIT;\n  while(cin >> target && target){\n    for ( int i = 0; i <= MAX+1; i++ ) state[i] = false;\n    state[1] = true;\n    dfs(0, 1, 1);\n    cout << ans[target] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\nusing namespace std;\nconstexpr int max_n = 1000;\nconstexpr int used_len = 2 * max_n;\nbool iddfs(vector<int> & s, array<bool,used_len> & used, int mx, int depth, int n) {\n    if (used[n]) return true;\n    if (depth == 0) return false;\n    if ((mx << depth) < n) return false;\n    repeat_reverse (i,s.size()) {\n        repeat_reverse (j,i+1) {\n            for (int x : { s[i] + s[j], abs(s[i] - s[j]) }) {\n                if (x <= 0 or used_len <= x) continue;\n                if (used[x]) continue;\n                used[x] = true;\n                s.push_back(x);\n                if (iddfs(s, used, max(mx, x), depth-1, n)) return true;\n                s.pop_back();\n                used[x] = false;\n            }\n        }\n    }\n    return false;\n}\nint iddfs(int n) {\n    int depth = 0;\n    while (true) {\n        vector<int> s { 1 };\n        array<bool,used_len> used = {};\n        used[1] = true;\n        if (iddfs(s, used, 1, depth, n)) break;\n        depth += 1;\n    }\n    return depth;\n}\nint main() {\n    while(scanf(\"%d\", &n) && n){\n      cout << iddfs(n) << endl;  \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1271: Power Calculus\n// 2017.10.16 bal4u@uu\n\n#include <stdio.h>\n\nint ans[1001] = { -1,\n0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5,\n6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 6, 5, 6, 6, 7, 6, 7, 7, 7, 6,\n7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7,\n8, 7, 7, 6, 7, 7, 8, 7, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 7,\n8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 8,\n9, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8,\n9, 9, 9, 8, 9, 8, 8, 7, 8, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9,\n9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 8,\n9, 9, 9, 9, 9, 9, 10, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9,\n10, 10, 10, 9, 10, 9, 10, 9, 9, 9, 9, 8, 9, 9, 9, 9, 10, 9, 10, 9,\n10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10,\n10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 9,\n10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 9, 10, 9, 9, 8, 9, 9, 10, 9,\n10, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 10, 10, 10,\n10, 10, 10, 10, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 11, 10,\n11, 11, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 10, 10, 10, 10, 10, 9,\n10, 10, 10, 10, 10, 10, 11, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10,\n11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10,\n11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10, 11, 10, 11, 10,\n10, 10, 10, 9, 10, 10, 10, 10, 11, 10, 11, 10, 11, 11, 11, 10, 11, 11, 11, 10,\n11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11,\n11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11,\n11, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n12, 11, 12, 11, 11, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 10,\n11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11,\n12, 11, 11, 10, 11, 11, 11, 10, 11, 10, 10, 9, 10, 10, 11, 10, 11, 11, 11, 10,\n11, 11, 12, 11, 12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 11, 11, 12, 12, 12, 11,\n12, 11, 11, 10, 11, 11, 12, 11, 12, 12, 12, 11, 11, 12, 12, 11, 12, 11, 12, 11,\n11, 11, 12, 11, 12, 11, 11, 11, 12, 11, 11, 11, 11, 11, 11, 10, 11, 11, 11, 11,\n11, 11, 12, 11, 11, 11, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, \n12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11,\n12, 12, 12, 11, 12, 12, 12, 11, 12, 11, 12, 11, 12, 11, 11, 11, 11, 11, 11, 10, \n11, 11, 11, 11, 11, 11, 12, 11, 12, 11, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, \n12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, \n12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, \n12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, \n12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, \n12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 11, 12, 12, 12, 11, \n12, 11, 12, 11, 11, 11, 11, 10, 11, 11, 11, 11, 12, 11, 12, 11, 12, 12, 12, 11, \n12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 11, \n12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 12, 11, 12, 12, 12, 12, \n13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 12, 12, \n12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 13, 12, 12, 12, \n12, 12, 12, 11, 12, 12, 12, 12, 12, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12,\n13, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, 12, 12, 12, 12, \n12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, 13, 12, \n13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 12, \n13, 12, 13, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 11, \n12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 12, 13, 12, 12, 12, 12, 12, 13, 12, \n13, 13, 13, 12, 13, 13, 13, 12, 13, 12, 12, 11, 12, 12, 13, 12, 13, 13, 13, 12 };\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n) && n > 0) printf(\"%d\\n\", ans[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n#define max_ans 13\n\nint num;\nint cache[max_ans + 1];\n\nint dfs(int depth, int max_depth)\n{\n\tif (cache[depth] == num) // correct ans\n\t\treturn 1;\n\tif (depth == max_depth) // reach max depth,break;\n\t\treturn 0;\n\tint max_value = cache[0];\n\tfor (int i = 1; i <= depth; i++) // find current max power\n\t{\n\t\tmax_value = (((max_value) > (cache[i])) ? (max_value) : (cache[i]));\n\t}\n\tif ((max_value << (max_depth - depth)) < num) //return false if max_value*2^(left depth) still can't reach num.\n\t\treturn 0;                                 //which means impossible to reach target num\n\tfor (int i = depth; i >= 0; i--)\n\t{\n\t\tcache[depth + 1] = cache[depth] + cache[i];\n\t\tif (dfs(depth + 1, max_depth) == 1)\n\t\t\treturn 1;\n\t\tcache[depth + 1] = cache[depth] - cache[i];\n\t\tif (dfs(depth + 1, max_depth) == 1)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor (int input, output; scanf(\"%d\", &input) && input != 0; printf(\"%d\\n\", output))\n\t{\n\t\tnum = input;\n\t\toutput = -1;\n\t\tif (input == 1)\n\t\t\toutput = 0;\n\t\telse\n\t\t{\n\t\t\tcache[0] = 1;\n\t\t\tfor (int i = 0; i < max_ans; i++)\n\t\t\t{\n\t\t\t\tif (dfs(0, i) == 1)\n\t\t\t\t{\n\t\t\t\t\toutput = i;\n\t\t\t\t\tgoto b1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output == -1)\n\t\t\t\toutput = max_ans;\n\t\tb1:\n\t\t\toutput = output;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "    #include <cstdio>\n     \n    #define MAX_N 1024\n    #define MAX_D 20\n    int exp[MAX_D] = {1}, ans[MAX_N];\n     \n    void dfs(int d)\n    {\n        if (d > MAX_D)\n        {\n            return;\n        }\n        for (int i = 0; i <= d; i++)\n        {\n            exp[d + 1] = exp[i] + exp[d]; // 乘法\n            if (exp[d + 1] < MAX_N && ans[exp[d + 1]] >= d + 1)\n            {\n                ans[exp[d + 1]] = d + 1;\n                dfs(d + 1);\n            }\n            exp[d + 1] = exp[d] - exp[i]; // 除法\n            if (exp[d + 1] > 0 && ans[exp[d + 1]] >= d + 1)\n            {\n                ans[exp[d + 1]] = d + 1;\n                dfs(d + 1);\n            }\n        }\n    }\n     \n    int main()\n    {\n    #ifndef ONLINE_JUDGE\n        freopen(\"in.txt\", \"r\", stdin);\n    #endif\n        for (int i = 2; i < MAX_N; i++)\n        {\n            //每个n的上界=除法+乘法\n            ans[i] = __builtin_popcount(i) + (30 - __builtin_clz(i));\n        }\n        dfs(0);\n     \n        int n;\n        while (~scanf(\"%d\", &n), n)\n        {\n            printf(\"%d\\n\", ans[n]);\n        }\n    #ifndef ONLINE_JUDGE\n        fclose(stdin);\n    #endif\n        return 0;\n    }\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Power Calculus\npublic class Main{\n\n\tint n;\n\tint[] k;\n\tboolean[] u;\n\n\tboolean reach(long b, long x, int rest){\n\t\tlong r = b+x;\n\t\twhile(rest--!=0)r+=r;\n\t\treturn n<=r;\n\t}\n\n\tboolean dfs(int d, int x, int max, int len){\n\t\tif(d==0){\n\t\t\treturn u[n];\n\t\t}\n\t\tif(d==1){\n\t\t\treturn u[Math.abs(x-n)];\n\t\t}\n//\t\tif(!reach(x, max, d))return false;\n\t\tfor(int i=len-1;i>=0;i--){\n\t\t\tint s = k[i]+x;\n\t\t\tif(!(2*n<s||u[s]||!reach(s, Math.max(max, s), d-1))){\n\t\t\t\tif(d!=1||u[Math.abs(s-n)]){\n\t\t\t\t\tu[s] = true;\n\t\t\t\t\tk[len] = s;\n\t\t\t\t\tif(dfs(d-1, s, Math.max(max, s), len+1))return true;\n\t\t\t\t\tu[s] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = x-k[i];\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\tif(d!=1||u[Math.abs(s-n)]){\n\t\t\t\t\tu[s] = true;\n\t\t\t\t\tk[len] = s;\n\t\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\t\tu[s] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = k[i] - x;\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\tif(d!=1||u[Math.abs(s-n)]){\n\t\t\t\t\tu[s] = true;\n\t\t\t\t\tk[len] = s;\n\t\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\t\tu[s] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid run(){\n//\t\tlong T = System.currentTimeMillis();\n//\t\tfor(n=1;n<=1000;n++){\n//\t\t\tlong t = System.currentTimeMillis();\n//\t\t\tint x = 1, res = 0;\n//\t\t\twhile(x<n){\n//\t\t\t\tx*=2; res++;\n//\t\t\t}\n//\t\t\tfor(;;){\n//\t\t\t\tu = new boolean[2500];\n//\t\t\t\tk = new int[res+1];\n//\t\t\t\tu[1] = true;\n//\t\t\t\tk[0] = 1;\n//\t\t\t\tif(dfs(res, 1, 1, 1)){\n//\t\t\t\t\tSystem.out.println(\"N:\"+n+\" ANS:\"+res+\" Time:\"+(System.currentTimeMillis()-t)); break;\n//\t\t\t\t}\n//\t\t\t\tres++;\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println(\"Time:\"+(System.currentTimeMillis()-T));\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t\t\t\tfor(;;){\n\t\t\t\t\tn = sc.nextInt();\n\t\t\t\t\tif(n==0)break;\n\t\t\t\t\tint x = 1, res = 0;\n\t\t\t\t\twhile(x<n){\n\t\t\t\t\t\tx*=2; res++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\tu = new boolean[2500];\n\t\t\t\t\t\tk = new int[res+1];\n\t\t\t\t\t\tu[1] = true;\n\t\t\t\t\t\tk[0] = 1;\n\t\t\t\t\t\tif(dfs(res, 1, 1, 1)){\n\t\t\t\t\t\t\tSystem.out.println(res); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tint ans, n;\n\tint [] close ;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Integer> init = new HashSet<Integer>();\n\t\tinit.add(1);\n\t\tclose = new int[1024];\n\t\tArrays.fill(close, 1 << 24);\n\t\tclose[1] = 0;\n\t\tsolve(1, 0, init);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tSystem.out.println(close[n]);\n\t\t}\n\t}\n\t\n\tprivate void solve(int now, int step, HashSet<Integer> record) {\n\t\tif(step == 13){\n\t\t\treturn ;\n\t\t}\n\t\tfor(int value: record){\n\t\t\tfor(int i = -1; i <= 1; i+= 2){\n\t\t\t\tint next = now + value * i;\n\t\t\t\tif(next <= 0) continue;\n\t\t\t\tif(record.contains(next)) continue;\n\t\t\t\tif(next < 1024){\n\t\t\t\t\tif(close[next] < step + 1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tclose[next] = step + 1;\n\t\t\t\t}\n\t\t\t\tHashSet<Integer> nextr = new HashSet<Integer>(record);\n\t\t\t\tnextr.add(next);\n\t\t\t\tsolve(next, step + 1, nextr);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Power Calculus\npublic class AOJ1271 {\n\n\tint n;\n\tint[] k;\n\tboolean[] u;\n\n\tboolean reach(long b, long x, int rest){\n\t\tlong r = b+x;\n\t\twhile(rest--!=0)r+=r;\n\t\treturn n<=r;\n\t}\n\n\tboolean dfs(int d, int x, int max, int len){\n\t\tif(d==0){\n\t\t\treturn u[n];\n\t\t}\n\t\tif(d==1){\n\t\t\treturn u[Math.abs(x-n)];\n\t\t}\n\t\tfor(int i=len-1;i>=0;i--){\n\t\t\tint s = k[i]+x;\n\t\t\tif(!(2*n<s||u[s]||!reach(s, Math.max(max, s), d-1))){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, Math.max(max, s), len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t}\n\t\t\ts = x-k[i];\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t}\n\t\t\ts = k[i] - x;\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint x = 1, res = 0;\n\t\t\twhile(x<n){\n\t\t\t\tx*=2; res++;\n\t\t\t}\n\t\t\tfor(;;){\n\t\t\t\tu = new boolean[2500];\n\t\t\t\tk = new int[res+1];\n\t\t\t\tu[1] = true;\n\t\t\t\tk[0] = 1;\n\t\t\t\tif(dfs(res, 1, 1, 1)){\n\t\t\t\t\tSystem.out.println(res); break;\n\t\t\t\t}\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew AOJ1271().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Power Calculus\npublic class Main{\n\n\tint n;\n\tint[] k;\n\tboolean[] u;\n\n\tboolean reach(long b, long x, int rest){\n\t\tlong r = b+x;\n\t\twhile(rest--!=0)r+=r;\n\t\treturn n<=r;\n\t}\n\n\tboolean dfs(int d, int x, int max, int len){\n\t\tif(d==0){\n\t\t\treturn u[n];\n\t\t}\n\t\tif(d==1){\n\t\t\treturn u[Math.abs(x-n)];\n\t\t}\n\t\tfor(int i=len-1;i>=0;i--){\n\t\t\tint s = k[i]+x;\n\t\t\tif(!(2*n<s||u[s]||!reach(s, Math.max(max, s), d-1))){\n\t\t\t\t//\t\t\t\tif(d!=1||u[Math.abs(s-n)]){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, Math.max(max, s), len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t\t//\t\t\t\t}\n\t\t\t}\n\t\t\ts = x-k[i];\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\t//\t\t\t\tif(d!=1||u[Math.abs(s-n)]){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t\t//\t\t\t\t}\n\t\t\t}\n\t\t\ts = k[i] - x;\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\t//\t\t\t\tif(d!=1||u[Math.abs(s-n)]){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t\t//\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint x = 1, res = 0;\n\t\t\twhile(x<n){\n\t\t\t\tx*=2; res++;\n\t\t\t}\n\t\t\tfor(;;){\n\t\t\t\tu = new boolean[2500];\n\t\t\t\tk = new int[res+1];\n\t\t\t\tu[1] = true;\n\t\t\t\tk[0] = 1;\n\t\t\t\tif(dfs(res, 1, 1, 1)){\n\t\t\t\t\tSystem.out.println(res); break;\n\t\t\t\t}\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Power Calculus\npublic class Main{\n\n\tint n;\n\tint[] k;\n\tboolean[] u;\n\n\tboolean reach(long b, long x, int rest){\n\t\tlong r = b+x;\n\t\twhile(rest--!=0)r+=r;\n\t\treturn n<=r;\n\t}\n\n\tboolean dfs(int d, int x, int max, int len){\n\t\tif(d==0){\n\t\t\treturn u[n];\n\t\t}\n\t\tif(d==1){\n\t\t\treturn u[Math.abs(x-n)];\n\t\t}\n\t\tfor(int i=len-1;i>=0;i--){\n\t\t\tint s = k[i]+x;\n\t\t\tif(!(2*n<s||u[s]||!reach(s, Math.max(max, s), d-1))){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, Math.max(max, s), len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t}\n\t\t\ts = x-k[i];\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t}\n\t\t\ts = k[i] - x;\n\t\t\tif(!(s<0||!reach(s, max, d-1)||u[s])){\n\t\t\t\tu[s] = true;\n\t\t\t\tk[len] = s;\n\t\t\t\tif(dfs(d-1, s, max, len+1))return true;\n\t\t\t\tu[s] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint x = 1, res = 0;\n\t\t\twhile(x<n){\n\t\t\t\tx*=2; res++;\n\t\t\t}\n\t\t\tfor(;;){\n\t\t\t\tu = new boolean[2500];\n\t\t\t\tk = new int[res+1];\n\t\t\t\tu[1] = true;\n\t\t\t\tk[0] = 1;\n\t\t\t\tif(dfs(res, 1, 1, 1)){\n\t\t\t\t\tSystem.out.println(res); break;\n\t\t\t\t}\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_N = 1024\n\n### main\n\ndists = []\nst = 1\ndists[st] = 0\nq = [[st, [st]]]\n\nwhile ! q.empty?\n  u = q.shift\n  ui, uds = u\n\n  ud = dists[ui]\n  nvd = ud + 1\n\n  for d in uds\n    vi = ui + d\n    if vi <= MAX_N\n      if dists[vi].nil?\n        dists[vi] = nvd\n        q << [vi, uds + [vi]]\n      elsif dists[vi] == nvd\n        q << [vi, uds + [vi]]\n      end\n    end\n\n    vi = (ui - d).abs\n    if vi >= 1\n      if dists[vi].nil?\n        dists[vi] = nvd\n        q << [vi, uds + [vi]]\n      elsif dists[vi] == nvd\n        q << [vi, uds + [vi]]\n      end\n    end\n  end\nend\n#p dists\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  puts dists[n]\nend"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nnumber_list = [float(\"inf\") for i in range(1000 + 1)]\nnumber_list[1] = 0\nque = deque([[1, [1], 0]])\n\n\nwhile len(que) > 0:\n    n, array, depth = que.popleft()\n    if depth > 16:\n        continue\n    for i in array:\n        if n + i <= 1000 and number_list[n + i] >= depth + 1:\n            number_list[n + i] = depth + 1\n            que.append([n + i, array + [n + i], depth + 1])\n\n        if n - i > 0 and number_list[n - i] >= depth + 1:\n            number_list[n - i] = depth + 1\n            que.append([n - i, array + [n - i], depth + 1])\n\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    print(number_list[N])\n"
  },
  {
    "language": "Python",
    "code": "def motomeruyuo():\n    d = deque([(0, 1, [1])])\n    num_list = [float('inf') for i in range(2001)]\n    num_list[1] = 0\n    \n    while d:\n        times, now, nums = d.popleft()\n\n        for i in nums:\n            tmp = i + now\n            if tmp > 2000:\n                continue\n            if num_list[tmp] >= times:\n                num_list[tmp] = times\n                d.append((times + 1, tmp, nums + [tmp]))\n\n        for i in nums:\n            tmp = max(now - i, i - now)\n            if tmp <= 0:\n                continue\n            if num_list[tmp] >= times:\n                num_list[tmp] = times\n                d.append((times + 1, tmp, nums + [tmp]))\n        \n    return num_list\n\nfrom collections import deque\n\nans = []\n\nnum_list = motomeruyuo()\nwhile True:\n    a = int(input())\n    if not a:\n        break\n    \n    if a == 1:\n        ans.append(num_list[a])\n    else:\n        ans.append(num_list[a] + 1)\n\n[print(i) for i in ans]\n\n"
  }
]