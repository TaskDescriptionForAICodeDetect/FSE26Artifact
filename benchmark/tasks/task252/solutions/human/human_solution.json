[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n \nusing namespace std;\n \ntypedef pair<vector<string>, int> P;\n \nbool G[4][2][4][2];\nmap<vector<string>, int> dat, dat2;\nint n, m;\n \nvoid init(){\n  fill(G[0][0][0], G[4][0][0], false);\n  dat.clear();\n  dat2.clear();\n}\n \nvoid bfs1(vector<string> &s){\n  queue<P> que;\n  dat[s] = 0;\n  que.push(P(s, 0));\n  while(!que.empty()){\n    vector<string> u = que.front().first;\n    int dist = que.front().second;\n    que.pop();\n    for(int i=0;i<n;i++){\n      for(int j=-1;j<(int)u[i].size();j++){\n        int p1 = i;\n        for(int d1=0;d1<2;d1++){\n          for(int p2=0;p2<n;p2++){\n            for(int d2=0;d2<2;d2++){\n              if(G[p1][d1][p2][d2]){\n                vector<string> v;\n                v.resize(n);\n                string next;\n                for(int k=0;k<n;k++){\n                  if(k == p1){\n                    if(d1 == 0){\n                      next = u[k].substr(j+1);\n                      v[k] = next;\n                    }else{\n                      next = u[k].substr(0, j+1);\n                      v[k] = next;\n                    }\n                  }else{\n                    v[k] = u[k];\n                  }\n                }\n                if(d1 == 0){\n                  if(d2 == 0){\n                    next = u[p1].substr(0, j+1);\n                    reverse(next.begin(), next.end());                  \n                    v[p2] = next + v[p2];\n                  }else{\n                    next = u[p1].substr(0, j+1);\n                    v[p2] = v[p2] + next;\n                  }\n                }else{\n                  if(d2 == 0){\n                    next = u[p1].substr(j+1);\n                    v[p2] = next + v[p2];\n                  }else{\n                    next = u[p1].substr(j+1);\n                    reverse(next.begin(), next.end());                  \n                    v[p2] = v[p2] + next;\n                  }\n                }\n                if(dat.find(v) == dat.end()){\n                  dat[v] = dist + 1;\n                  if(dist + 1 < 2) que.push(P(v, dist + 1));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n \nint bfs2(vector<string> &s){\n  queue<P> que;\n  dat2[s] = 0;\n  que.push(P(s, 0));\n  if(dat.find(s) != dat.end()) return dat[s];\n  int res = 6;\n  while(!que.empty()){\n    vector<string> u = que.front().first;\n    int dist = que.front().second;\n    que.pop();\n    if(dist >= 3) continue;\n    for(int i=0;i<n;i++){\n      for(int j=-1;j<(int)u[i].size();j++){\n        int p1 = i;\n        for(int d1=0;d1<2;d1++){\n          for(int p2=0;p2<n;p2++){\n            for(int d2=0;d2<2;d2++){\n              if(G[p1][d1][p2][d2]){\n                vector<string> v;\n                v.resize(n);\n                string next;\n                for(int k=0;k<n;k++){\n                  if(k == p1){\n                    if(d1 == 0){\n                      next = u[k].substr(j+1);\n                      v[k] = next;\n                    }else{\n                      next = u[k].substr(0, j+1);\n                      v[k] = next;\n                    }\n                  }else{\n                    v[k] = u[k];\n                  }\n                }\n                if(d1 == 0){\n                  if(d2 == 0){\n                    next = u[p1].substr(0, j+1);\n                    reverse(next.begin(), next.end());                  \n                    v[p2] = next + v[p2];\n                  }else{\n                    next = u[p1].substr(0, j+1);\n                    v[p2] = v[p2] + next;\n                  }\n                }else{\n                  if(d2 == 0){\n                    next = u[p1].substr(j+1);\n                    v[p2] = next + v[p2];\n                  }else{\n                    next = u[p1].substr(j+1);\n                    reverse(next.begin(), next.end());                  \n                    v[p2] = v[p2] + next;\n                  }\n                }\n                if(dat2.find(v) == dat2.end()){\n                  if(dat.find(v) != dat.end()){\n                    res = min(res, dist + 1 + dat[v]);\n                    continue;\n                  }\n                  dat2[v] = dist + 1;\n                  if(dist + 1 < 3) que.push(P(v, dist + 1));\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return res;\n}\n \nvector<string> cre(){\n  vector<string> vec;\n  for(int i=0;i<n;i++){\n    string in;\n    cin >> in;\n    if(in == \"-\") in = \"\";\n    vec.push_back(in);\n  }\n  return vec;\n}\n \nmain(){\n  while(cin >> n >> m && (n|m)){\n    init();\n    for(int i=0;i<m;i++){\n      string a, b;\n      cin >> a >> b;\n      int p1 = a[0] - '0';\n      int d1 = (a[1] == 'W' ? 0 : 1);\n      int p2 = b[0] - '0';\n      int d2 = (b[1] == 'W' ? 0 : 1);\n      G[p1][d1][p2][d2] = true;\n      G[p2][d2][p1][d1] = true;\n    }\n    vector<string> s = cre();\n    bfs1(s);\n    vector<string> t = cre();\n    cout << bfs2(t) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<vector<string>, int> VI;\n\nint n;\nvector<P> t[4][2];\nvector<string> start, end;\nmap<vector<string>, int> half;\n\nint ans;\n\nvoid enumerateHalf(){\n  queue<VI> open;\n  open.push(VI(start, 0));\n  half[start] = 0;\n\n  while(!open.empty()){\n    VI vi = open.front();\n    open.pop();\n    vector<string> vec = vi.first;\n    int step = vi.second;\n\n    for(int from = 0; from < n; from++){\n      if(vec[from].size() == 0) continue;\n\n      for(int cut = 0; cut < vec[from].size(); cut++){\n        string cut_str[2] = {\n          vec[from].substr(0, cut),\n          vec[from].substr(cut)\n        };\n        string rev_str[2] = {cut_str[0], cut_str[1]};\n        reverse(rev_str[0].begin(), rev_str[0].end());\n        reverse(rev_str[1].begin(), rev_str[1].end());\n\n        for(int from_dir = 0; from_dir < 2; from_dir++){\n          if(cut_str[from_dir].size() == 0) continue;\n\n          for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n            int to = t[from][from_dir][to_idx].first;\n            int to_dir = t[from][from_dir][to_idx].second;\n            vector<string> nvec = vec;\n\n            if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n            else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n            else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n            else                                  nvec[to] += rev_str[from_dir];\n\n            nvec[from] = cut_str[!from_dir];\n\n            map<vector<string>,int>::iterator tmp_iter = half.find(nvec);\n\n            if(tmp_iter != half.end()) continue;\n            half[nvec] = step + 1;\n\n            if(step == 2) continue;\n            open.push(VI(nvec, step + 1));\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid bfs(){\n  queue<VI> open;\n  open.push(VI(end, 0));\n\n  map<vector<string>,int>::iterator tmp_iter = half.find(end);\n  if(tmp_iter != half.end()) ans = min(ans, tmp_iter->second);\n\n  while(!open.empty()){\n    VI vi = open.front();\n    open.pop();\n    vector<string> vec = vi.first;\n    int step = vi.second;\n\n    for(int from = 0; from < n; from++){\n      if(vec[from].size() == 0) continue;\n\n      for(int cut = 0; cut < vec[from].size(); cut++){\n        string cut_str[2] = {\n          vec[from].substr(0, cut),\n          vec[from].substr(cut)\n        };\n        string rev_str[2] = {cut_str[0], cut_str[1]};\n        reverse(rev_str[0].begin(), rev_str[0].end());\n        reverse(rev_str[1].begin(), rev_str[1].end());\n\n        for(int from_dir = 0; from_dir < 2; from_dir++){\n          if(cut_str[from_dir].size() == 0) continue;\n\n          for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n            int to = t[from][from_dir][to_idx].first;\n            int to_dir = t[from][from_dir][to_idx].second;\n            vector<string> nvec = vec;\n\n            if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n            else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n            else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n            else                                  nvec[to] += rev_str[from_dir];\n\n            nvec[from] = cut_str[!from_dir];\n\n            map<vector<string>,int>::iterator tmp_iter = half.find(nvec);\n\n            if(tmp_iter != half.end()){\n              ans = min(ans, step + 1 + tmp_iter->second);\n              continue;\n            }\n\n            if(step == 2) continue;\n            open.push(VI(nvec, step + 1));\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid solve(){\n  half.clear();\n  enumerateHalf();\n\n  ans = INT_MAX;\n  bfs();\n  cout << ans << endl;\n}\n\nint main(){\n  int m;\n\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 4; i++){\n      for(int j = 0; j < 2; j++){\n        t[i][j].clear();\n      }\n    }\n\n    for(int i = 0; i < m; i++){\n      string from, to;\n      cin >> from >> to;\n\n      int from_line = from[0] - '0';\n      int from_dir = (from[1] == 'W' ? 0 : 1);\n      int to_line = to[0] - '0';\n      int to_dir = (to[1] == 'W' ? 0 : 1);\n\n      t[from_line][from_dir].push_back(P(to_line, to_dir));\n      t[to_line][to_dir].push_back(P(from_line, from_dir));\n    }\n\n    start.clear();\n    end.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      start.push_back(s);\n    }\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      end.push_back(s);\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<vector<int> > to;\n\nvoid solve(vector<string> start, map<vector<string>, int>& history)\n{\n    queue<vector<string> > q1;\n    q1.push(start);\n    history[start] = 0;\n\n    for(int a=1; a<=3; ++a){\n        queue<vector<string> > q2;\n        while(!q1.empty()){\n            vector<string> s = q1.front();\n            q1.pop();\n\n            for(int i=0; i<n*2; ++i){\n                for(unsigned j=0; j<to[i].size(); ++j){\n                    vector<string> t = s;\n                    while(!t[i/2].empty()){\n                        char c;\n                        if(i % 2 == 0){\n                            c = t[i/2][0];\n                            t[i/2] = t[i/2].substr(1);\n                        }else{\n                            c = t[i/2][t[i/2].size()-1];\n                            t[i/2] = t[i/2].substr(0, t[i/2].size()-1);\n                        }\n\n                        if(to[i][j] % 2 == 0){\n                            t[to[i][j]/2] = c + t[to[i][j]/2];\n                        }else{\n                            t[to[i][j]/2] += c;\n                        }\n\n                        if(history.find(t) == history.end()){\n                            q2.push(t);\n                            history[t] = a;\n                        }\n                    }\n                }\n            }\n        }\n        q1 = q2;\n    }\n}\n\nint main()\n{\n    for(;;){\n        int m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        to.resize(2*n);\n        for(int i=0; i<m; ++i){\n            string s, t;\n            cin >> s >> t;\n            int a = (s[0] - '0') * 2;\n            int b = (t[0] - '0') * 2;\n            if(s[1] == 'E')\n                ++ a;\n            if(t[1] == 'E')\n                ++ b;\n            to[a].push_back(b);\n            to[b].push_back(a);\n        }\n\n        vector<string> s(n), t(n);\n        for(int i=0; i<n; ++i){\n            cin >> s[i];\n            if(s[i] == \"-\")\n                s[i] = \"\";\n        }\n        for(int i=0; i<n; ++i){\n            cin >> t[i];\n            if(t[i] == \"-\")\n                t[i] = \"\";\n        }\n\n        map<vector<string>, int> history1, history2;\n        solve(t, history2);\n        solve(s, history1);\n\n        int ret = INT_MAX;\n        map<vector<string>, int>::iterator it1, it2;\n        it1 = history1.begin();\n        it2 = history2.begin();\n        while(it1 != history1.end() && it2 != history2.end()){\n            if(it1->first == it2->first)\n                ret = min(ret, it1->second + it2->second);\n            if(it1->first < it2->first)\n                ++ it1;\n            else\n                ++ it2;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nstring pack(vector<deque<char> > const & s) {\n    ostringstream oss;\n    repeat (i, s.size()) {\n        if (i) oss << ',';\n        for (char c : s[i]) oss << c;\n    }\n    return oss.str();\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    repeat (k,n) {\n                        char c;\n                        if (v.second == W) {\n                            c = t[i].front();\n                            t[i].pop_front();\n                        } else {\n                            c = t[i].back();\n                            t[i].pop_back();\n                        }\n                        if (w.second == W) {\n                            t[j].push_front(c);\n                        } else {\n                            t[j].push_back(c);\n                        }\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nunordered_map<string,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    unordered_map<string,int> ms;\n    ms[pack(s)] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            string t = pack(it);\n            if (not ms.count(t)) {\n                ms[t] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        unordered_map<string,int> ms = steps(s, g, 2);\n        unordered_map<string,int> mt = steps(t, g, 3);\n        int result = 6;\n        for (auto it : ms) {\n            if (mt.count(it.first)) {\n                result = min(result, it.second + mt[it.first]);\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#define ll long long\n#define inf 1000000009\n#define mod 1000000007\n#define N 4\nusing namespace std;\nint n,m;\nint a[N][N][2][2];\nmap<string,int> vis;\nstring v[N],vv[N];\nvoid decode(string s){\n    int p=0;    \n    for(int i=0;i<n;i++){\n        v[i]=\"\";        \n        for(;s[p]&&s[p]!='#';p++) v[i].append(1,s[p]);\n        p++;    \n    }    \n}\nint cnt;\nint bfs(string start,string end){\n    queue<string> Q;\n    string t;\n    cnt=0;\n    vis.clear();\n    vis[start]=0;    \n    Q.push(start);\n    while(!Q.empty()){\n        if(cnt++>=20000) return 6;\n        string p=Q.front();\n        Q.pop();\n        if(p==end) return vis[end];\n        int d=vis[p];\n        if(d==5) return 6;\n        decode(p);\n        for(int i=0;i<n;i++){\n            if(v[i]==\"\") continue;\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                for(int t1=0;t1<2;t1++)\n                    for(int t2=0;t2<2;t2++){\n                        if(!a[i][j][t1][t2]) continue;\n                        for(int k=0;k<v[i].size();k++){\n                            for(int l=0;l<n;l++) vv[l]=v[l];\n                            if(t1){\n                                t=v[i].substr(k,v[i].size());\n                                if(k) vv[i]=v[i].substr(0,k);\n                                else vv[i]=\"\";\n                            }\n                            else{\n                                t=v[i].substr(0,k+1);\n                                if(k<v[i].size()-1) vv[i]=v[i].substr(k+1,v[i].size());\n                                else vv[i]=\"\";\n                            }\n                            if(t1==t2) reverse(t.begin(),t.end());\n                            if(t2) vv[j]=vv[j]+t;\n                            else vv[j]=t+vv[j];                            \n                            t=vv[0];\n                            for(int l=1;l<n;l++) t=t+\"#\"+vv[l];\n                            if(vis.find(t)!=vis.end()) continue;                            \n                            vis[t]=d+1;\n                            if(t==end) return d+1;                            \n                            Q.push(t);\n                        }                       \n                    }\n            }\n        }\n    }\n    return -1;\n}\nint main(){    \n   // freopen(\"in.in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&m),n){\n        memset(a,0,sizeof(a));\n        for(int i=0;i<m;i++){\n            char s[10],e[10];\n            int x,y,t1,t2;\n            scanf(\"%s%s\",s,e);\n            x=s[0]-'0',y=e[0]-'0';\n            t1=(s[1]=='E'),t2=(e[1]=='E');\n            a[x][y][t1][t2]=a[y][x][t2][t1]=1;            \n        }\n        string s=\"\",e=\"\",t;\n        for(int i=0;i<n;i++){\n            cin>>t;\n            if(t==\"-\") t=\"\";\n            if(i) s=s+\"#\";\n            s=s+t;\n        }\n        for(int i=0;i<n;i++){\n            cin>>t;\n            if(t==\"-\") t=\"\";\n            if(i) e=e+\"#\";\n            e=e+t;\n        }\n        //cout<<s<<' '<<e<<endl;\n        printf(\"%d\\n\",bfs(s,e));        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n\n#define REP(i,a,b) for(int i=(a);i < (int)(b); i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(v) begin(v), end(v)\n\nint x, y;\n\nint ans;\nvector<pair<pair<int, int>, pair<int, int>>> exchanges;\nvector<string> lines, goal;\n\nvoid dfs(int moves) {\n  int match = 0;\n  for(int i = 0; i < x; ++i) {\n    if(lines[i] == goal[i]) ++match;\n  }\n\n  if(match == x) {\n    ans = moves;\n    return;\n  }\n\n  if(moves + 1 >= ans) return;\n  if(ans - moves - 1 < (x - match) / 2) return;\n  \n\n  for(const auto &element : exchanges) {\n    const int p1 = element.first.first;\n    const int d1 = element.first.second;\n    const int p2 = element.second.first;\n    const int d2 = element.second.second;\n\n    const string t1 = move(lines[p1]);\n    const string t2 = move(lines[p2]);\n\n    // p1 -> p2\n    for(int num = 1; num <= t1.size(); ++num) {\n      string tmp = (d1 ? t1.substr(0, num) : t1.substr(t1.size() - num));\n      if(d1 == d2) reverse(tmp.begin(), tmp.end());\n      lines[p1] = (d1 ? t1.substr(num) : t1.substr(0, t1.size() - num));\n      lines[p2] = (d2 ? tmp + t2 : t2 + tmp);\n      dfs(moves + 1);\n    }\n\n    // p2 -> p1\n    for(int num = 1; num <= t2.size(); ++num) {\n      string tmp = (d2 ? t2.substr(0, num) : t2.substr(t2.size() - num));\n      if(d1 == d2) reverse(tmp.begin(), tmp.end());\n      lines[p1] = (d1 ? tmp + t1 : t1 + tmp);\n      lines[p2] = (d2 ? t2.substr(num) : t2.substr(0, t2.size() - num));\n      dfs(moves + 1);\n    }\n\n    lines[p1] = move(t1);\n    lines[p2] = move(t2);\n  }\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  while(cin >> x >> y && x) {\n    exchanges.clear();\n    exchanges.reserve(y);\n\n    for(int i = 0; i < y; ++i) {\n      string a, b;\n      cin >> a >> b;\n\n      const int p1 = a[0] - '0';\n      const int d1 = (a[1] == 'W');\n      const int p2 = b[0] - '0';\n      const int d2 = (b[1] == 'W');\n\n      exchanges.emplace_back(make_pair(p1, d1), make_pair(p2, d2));\n    }\n\n    lines.clear();\n    lines.resize(x);\n    for(auto &e : lines) {\n      cin >> e;\n      if(e == \"-\") e = \"\";\n    }\n\n    goal.clear();\n    goal.resize(x);\n    for(auto &e : goal) {\n      cin >> e;\n      if(e == \"-\") e = \"\";\n    }\n\n    ans = 6;\n    dfs(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define ALL(C)     (C).begin(),(C).end()\n#define WEST 0\n#define EAST 1\n\ntypedef unsigned long long ull;\n\nclass state{\npublic:\n  string data[4];\n  ull h[4];\n  int cnt;\n  state(){\n    cnt=0;\n    rep(i,4){data[i]=\"\";h[i]=0;}\n  }\n  bool operator<(const state &a)const{\n    rep(i,4)if (h[i] != a.h[i])return h[i] < a.h[i];\n    return false;\n  }\n  bool operator==(const state &a)const{\n    rep(i,4)if (h[i] != a.h[i])return false;\n    return true;\n  }\n};\n\nbool edge[4][4][2][2];//from to, from w or e, to w or e\n\nconst ull xxx=10007;\null compute_hash(string &a){\n  ull ret=0;\n  rep(i,a.size()){\n    ret=ret*xxx + a[i];\n  }\n  return ret;\n}\n\ninline void get_all_hash(state &a,int n){\n  rep(i,n){\n    a.h[i]=compute_hash(a.data[i]);\n  }\n}\n\ninline void operate(string moveone,string stayone,\n\t\t    state &now,int me,int tar,\n\t\t    int dir,int tdir){\n  if (dir == tdir){\n    reverse(moveone.begin(),moveone.end());\n  }\n  if (tdir == EAST){\n    now.data[tar]+=moveone;\n  }else if (tdir == WEST){\\\n    now.data[tar]=moveone+now.data[tar];\n  }\n  now.data[me]=stayone;\n}\n\nvoid move(int n,state &now,set<state> & S,queue<state> &Q){\n  rep(i,n){\n    rep(j,now.data[i].size()+1){\n      string tmp[2]={now.data[i].substr(0,j),now.data[i].substr(j)};\n      rep(k,2){//which tmp[0] or tmp[1]\n\trep(l,n){//target line\n\t  rep(m,2){//west or east\n\t    if (!edge[i][l][k][m])continue;\n\t    state next=now;\n\t    next.cnt++;\n\t    operate(tmp[k],tmp[1-k],next,i,l,k,m);\n\t    get_all_hash(next,n);\n\t    if (S.find(next) == S.end()){\n\t      S.insert(next);\n\t      Q.push(next);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }  \n}\n\nint bfs(int n,state ini,state goal,set<state> &G,bool fromstart){\n  set<state> S;\n  queue<state> Q;\n  if (fromstart){\n    Q.push(ini);\n    S.insert(ini);\n  }else {\n    Q.push(goal);\n    G.insert(goal);\n  }\n\n  while(!Q.empty()){\n    state now = Q.front();\n    Q.pop();\n    /*\n    cout <<\"debug \"<< fromstart << endl;\n    rep(i,n){\n      cout << now.data[i] << endl;\n    }\n    */\n\n    if (fromstart){\n      set<state>::iterator itr = G.find(now);\n      if (itr != G.end())return now.cnt+(*itr).cnt;\n    }else {\n      if (now == ini)return now.cnt;\n    }\n\n    if (now.cnt ==3)continue;\n    if (fromstart)move(n,now,S,Q);\n    else move(n,now,G,Q);\n  }\n  return -1;\n}\n\nint solve(int n,state &ini,state &goal){\n  set<state> Goal;\n  int ans = bfs(n,ini,goal,Goal,false);\n  if (ans != -1)return ans;\n  ans=bfs(n,ini,goal,Goal,true);\n  return ans;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    rep(i,4)rep(j,4)rep(k,2)rep(l,2)edge[i][j][k][l]=false;\n    rep(i,m){\n      char tfd,ttd;\n      int f,t;\n      int fd,td;\n      cin>>f>>tfd>>t>>ttd;\n      if (tfd == 'W')fd=WEST;\n      else fd=EAST;\n      if (ttd == 'W')td=WEST;\n      else td=EAST;\n      edge[f][t][fd][td]=true;\n      edge[t][f][td][fd]=true;\n    }\n    state ini,goal;\n    rep(i,n){\n      cin>>ini.data[i];\n      if (ini.data[i] == \"-\")ini.data[i]=\"\";\n    }\n    rep(i,n){\n      cin>>goal.data[i];\n      if (goal.data[i] == \"-\")goal.data[i]=\"\";\n    }\n    get_all_hash(ini,n);\n    get_all_hash(goal,n);\n    \n    cout << solve(n,ini,goal) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#define ll long long\n#define inf 1000000009\n#define mod 1000000007\n#define N 4\nusing namespace std;\nint n,m;\nint a[N][N][2][2];\nmap<string,int> vis;\nstring v[N],vv[N];\nvoid decode(string s){\n    int p=0;    \n    for(int i=0;i<n;i++){\n        v[i]=\"\";        \n        for(;s[p]&&s[p]!='#';p++) v[i].append(1,s[p]);\n        p++;    \n    }    \n}\nint cnt;\nint bfs(string start,string end){\n    queue<string> Q;\n    string t;\n    cnt=0;\n    vis.clear();\n    vis[start]=0;    \n    Q.push(start);\n    while(!Q.empty()){\n        //if(cnt++>=100000) return 6;\n        string p=Q.front();\n        Q.pop();\n        if(p==end) return vis[end];\n        int d=vis[p];\n        if(d==5) return 6;\n        decode(p);\n        for(int i=0;i<n;i++){\n            if(v[i]==\"\") continue;\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                for(int t1=0;t1<2;t1++)\n                    for(int t2=0;t2<2;t2++){\n                        if(!a[i][j][t1][t2]) continue;\n                        for(int k=0;k<v[i].size();k++){\n                            for(int l=0;l<n;l++) vv[l]=v[l];\n                            if(t1){\n                                t=v[i].substr(k,v[i].size());\n                                if(k) vv[i]=v[i].substr(0,k);\n                                else vv[i]=\"\";\n                            }\n                            else{\n                                t=v[i].substr(0,k+1);\n                                if(k<v[i].size()-1) vv[i]=v[i].substr(k+1,v[i].size());\n                                else vv[i]=\"\";\n                            }\n                            if(t1==t2) reverse(t.begin(),t.end());\n                            if(t2) vv[j]=vv[j]+t;\n                            else vv[j]=t+vv[j];                            \n                            t=vv[0];\n                            for(int l=1;l<n;l++) t=t+\"#\"+vv[l];\n                            if(vis.find(t)!=vis.end()) continue;                            \n                            vis[t]=d+1;\n                            if(t==end) return d+1;                            \n                            Q.push(t);\n                        }                       \n                    }\n            }\n        }\n    }\n    return -1;\n}\nint main(){    \n    //freopen(\"in.in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&m),n){\n        memset(a,0,sizeof(a));\n        for(int i=0;i<m;i++){\n            char s[10],e[10];\n            int x,y,t1,t2;\n            scanf(\"%s%s\",s,e);\n            x=s[0]-'0',y=e[0]-'0';\n            t1=(s[1]=='E'),t2=(e[1]=='E');\n            a[x][y][t1][t2]=a[y][x][t2][t1]=1;            \n        }\n        string s=\"\",e=\"\",t;\n        for(int i=0;i<n;i++){\n            cin>>t;\n            if(t==\"-\") t=\"\";\n            if(i) s=s+\"#\";\n            s=s+t;\n        }\n        for(int i=0;i<n;i++){\n            cin>>t;\n            if(t==\"-\") t=\"\";\n            if(i) e=e+\"#\";\n            e=e+t;\n        }\n        //cout<<s<<' '<<e<<endl;\n        printf(\"%d\\n\",bfs(s,e));        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class Key, class Value>\nstruct HashMap {\n\n    static const int MAXH = 999983;\n    struct Edge {\n        Key to;\n        Value v;\n        Edge *next;\n    } *head[MAXH];\n\n    void set(const Key &key, const Value &value) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        Edge *p = new Edge;\n        p -> to = key;\n        p -> v = value;\n        p -> next = head[hv];\n        head[hv] = p;\n    }\n\n    const Value &get(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return p -> v;\n    }\n\n    bool exist(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return true;\n        return false;\n    }\n\n    void clear() {\n\n        for (int i = 0; i < MAXH; i++)\n        {\n            for (Edge *p = head[i], *np; p; p = np)\n            {\n                np = p -> next;\n                delete p;\n            }\n            head[i] = NULL;\n        }\n    }\n};\n\nconst int MAXN = 4;\nconst int MAXM = MAXN * MAXN * 2;\nint n, m, mcnt;\nint track[MAXM][2], dir[MAXM][2];\n\nstruct State {\n\n    vector<string> s;\n\n    string &operator[](int x) {\n\n        return s[x];\n    }\n\n    int hash_value() const {\n\n        unsigned int res = 0, res0;\n        for (int i = 0; i < n; i++)\n        {\n            res0 = 0;\n            const string &ref = s[i];\n            string::size_type len = ref.length();\n            for (int j = 0; j < len; j++)\n                res0 = res0 * 131 + ref[j];\n            res = res * 13131 + res0;\n        }\n        return res;\n    }\n\n    bool operator==(const State &b) const {\n\n        for (int i = 0; i < n; i++)\n            if (s[i] != b.s[i]) return false;\n        return true;\n    }\n\n    void go(int n0, int d0, int n1, int d1, int k) {\n\n        string out = s[n0].substr(0, k);\n        s[n0] = s[n0].erase(0, k);\n        if (d0) std::swap(out, s[n0]);\n        if (d0 == d1) reverse(out.begin(), out.end());\n        if (d1) s[n1] += out;\n        else s[n1] = out + s[n1];\n    }\n\n    void push_back(const string &b) {\n\n        s.push_back(b);\n    }\n};\n\nstruct Bfs {\n\n    queue<State> q[2], *old, *new_;\n    HashMap<State, int> hash;\n    int head, tail;\n    Bfs *pair;\n\n    void init() {\n\n        hash.clear();\n        for (int i = 0; i < 2; i++)\n            while (!q[i].empty()) q[i].pop();\n        old = q;\n        new_ = q + 1;\n    }\n\n    int push(const State &ns, int step) {\n\n        if (hash.exist(ns)) return -1;\n        if (pair -> hash.exist(ns))\n        {\n            int t = pair -> hash.get(ns);\n            return step + t; \n        }\n        hash.set(ns, step);\n        new_ -> push(ns);\n        return -1;\n    }\n\n    int next() {\n\n        while (!old -> empty())\n        {\n            State &ref = old -> front();\n            int nstep = hash.get(ref) + 1;\n            for (int i = 0; i < mcnt; i++)\n            {\n                string::size_type len = ref[track[i][0]].length();\n                for (int k = 0; k <= len; k++)\n                {\n                    State v = ref;\n                    v.go(track[i][0], dir[i][0], track[i][1], dir[i][1], k);\n                    int ret = push(v, nstep);\n                    if (ret != -1) return ret;\n                }\n            }\n            old -> pop();\n        }\n        swap(old, new_);\n        return -1;\n    }\n};\n\nBfs ins[2];\n\nint main() {\n\n\n    for (;;)\n    {\n        mcnt = 0;\n        scanf(\"%d %d\", &n, &m);\n        if (!n && !m) break;\n        for (int i = 0; i < m; i++)\n        {\n            int f, t;\n            char fd, td;\n            scanf(\"%d%c %d%c\", &f, &fd, &t, &td);\n            fd = fd == 'E';\n            td = td == 'E';\n            track[mcnt][0] = f; track[mcnt][1] = t;\n            dir[mcnt][0] = fd; dir[mcnt][1] = td;\n            mcnt++;\n\n            track[mcnt][0] = t; track[mcnt][1] = f;\n            dir[mcnt][0] = td; dir[mcnt][1] = fd;\n            mcnt++;\n        }\n\n        State root[2];\n        static char buff[20];\n\n        for (int t = 0; t < 2; t++)\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%s\", buff);\n            root[t].push_back(buff);\n            if (root[t][i] == \"-\") root[t][i] = \"\";\n        }\n\n        for (int i = 0; i < 2; i++) \n        {\n            ins[i].init();\n            ins[i].pair = ins + !i;\n            swap(ins[i].old, ins[i].new_);\n            ins[i].push(root[i], 0);\n        }\n        for (int i = 0; i < 2; i++)\n            swap(ins[i].old, ins[i].new_);\n\n        for (int i = 0;; i ^= 1)\n        {\n            int ret = ins[i].next();\n            if (ret != -1) \n            {\n                printf(\"%d\\n\", ret);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nvector<P> t[4][2];\nvector<string> start, end;\nmap<vector<string>, int> half;\n\nint ans;\n\nstring format(const vector<string> &vec){\n  string res = \"\";\n  for(int i = 0; i < n; i++){\n    if(i != 0) res += \",\";\n    res += vec[i];\n  }\n  return res;\n}\n\nvoid enumerateHalf(int step, vector<string> vec){\n  map<vector<string>,int>::iterator tmp_iter = half.find(vec);\n  if(tmp_iter == half.end()) half[vec] = step;\n  else                       tmp_iter->second = min(tmp_iter->second, step);\n\n  if(step == 3) return;\n\n  for(int from = 0; from < n; from++){\n    if(vec[from].size() == 0) continue;\n\n    for(int cut = 0; cut < vec[from].size(); cut++){\n      string cut_str[2] = {\n        vec[from].substr(0, cut),\n        vec[from].substr(cut)\n      };\n      string rev_str[2] = {cut_str[0], cut_str[1]};\n      reverse(rev_str[0].begin(), rev_str[0].end());\n      reverse(rev_str[1].begin(), rev_str[1].end());\n\n      for(int from_dir = 0; from_dir < 2; from_dir++){\n        if(cut_str[from_dir].size() == 0) continue;\n\n        for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n          int to = t[from][from_dir][to_idx].first;\n          int to_dir = t[from][from_dir][to_idx].second;\n          vector<string> nvec = vec;\n\n          if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n          else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n          else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n          else                                  nvec[to] += rev_str[from_dir];\n\n          nvec[from] = cut_str[!from_dir];\n\n          enumerateHalf(step + 1, nvec);\n        }\n      }\n    }\n  }\n}\n\nvoid rec(int step, vector<string> vec){\n  map<vector<string>,int>::iterator tmp_iter = half.find(vec);\n  if(tmp_iter != half.end()){\n    ans = min(ans, step + tmp_iter->second);\n    return;\n  }\n  if(step == 3) return;\n\n  for(int from = 0; from < n; from++){\n    if(vec[from].size() == 0) continue;\n\n    for(int cut = 0; cut < vec[from].size(); cut++){\n      string cut_str[2] = {\n        vec[from].substr(0, cut),\n        vec[from].substr(cut)\n      };\n      string rev_str[2] = {cut_str[0], cut_str[1]};\n      reverse(rev_str[0].begin(), rev_str[0].end());\n      reverse(rev_str[1].begin(), rev_str[1].end());\n\n      for(int from_dir = 0; from_dir < 2; from_dir++){\n        if(cut_str[from_dir].size() == 0) continue;\n\n        for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n          int to = t[from][from_dir][to_idx].first;\n          int to_dir = t[from][from_dir][to_idx].second;\n          vector<string> nvec = vec;\n\n          if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n          else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n          else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n          else                                  nvec[to] += rev_str[from_dir];\n\n          nvec[from] = cut_str[!from_dir];\n\n          rec(step + 1, nvec);\n        }\n      }\n    }\n  }\n}\n\nvoid solve(){\n  half.clear();\n  enumerateHalf(0, start);\n\n  ans = INT_MAX;\n  rec(0, end);\n  cout << ans << endl;\n}\n\nint main(){\n  int m;\n\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 4; i++){\n      for(int j = 0; j < 2; j++){\n        t[i][j].clear();\n      }\n    }\n\n    for(int i = 0; i < m; i++){\n      string from, to;\n      cin >> from >> to;\n\n      int from_line = from[0] - '0';\n      int from_dir = (from[1] == 'W' ? 0 : 1);\n      int to_line = to[0] - '0';\n      int to_dir = (to[1] == 'W' ? 0 : 1);\n\n      t[from_line][from_dir].push_back(P(to_line, to_dir));\n      t[to_line][to_dir].push_back(P(from_line, from_dir));\n    }\n\n    start.clear();\n    end.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      start.push_back(s);\n    }\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      end.push_back(s);\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<string> const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat (n,s[i].size()+1) {\n            string l = s[i].substr(0, n);\n            string r = s[i].substr(n);\n            for (we_t p : { W, E }) {\n                if ((l.empty() and p == W) or (r.empty() and p == E)) continue;\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int  j = w.first;\n                    we_t q = w.second;\n                    vector<string> t = s;\n                    t[i]     = p == W ? r : l;\n                    string u = p == W ? l : r;\n                    if (p == q) reverse(u.begin(), u.end());\n                    t[j] = q == W ? u + s[j] : s[j] + u;\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nmap<vector<string>,int> steps(vector<string> const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    map<vector<string>,int> ms;\n    ms[s] = 0;\n    vector<vector<string> > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<string> > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            if (not ms.count(it)) {\n                ms[it] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<string> s(x); repeat (i,x) { cin >> s[i]; if (s[i] == \"-\") s[i].clear(); }\n        vector<string> t(x); repeat (i,x) { cin >> t[i]; if (t[i] == \"-\") t[i].clear(); }\n        map<vector<string>,int> s2 = steps(s, g, 2);\n        map<vector<string>,int> t2 = steps(t, g, 2);\n        int result = 6;\n        for (auto it : s2) {\n            if (t2.count(it.first)) {\n                result = min(result, it.second + t2[it.first]);\n            }\n            if (it.second == 2) {\n                vector<vector<string> > s3;\n                step(it.first, g, back_inserter(s3));\n                for (auto that : s3) {\n                    if (t2.count(that)) {\n                        result = min(result, 1 + it.second + t2[that]);\n                    }\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef array<int, 2> A;\ntypedef pair<A, A> E;\ntypedef unsigned hash_t;\n\nhash_t rolling_hash(const string &s) {\n\tstatic constexpr hash_t base = 1000000007;\n\thash_t res = 0;\n\tfor(const auto &c : s) {\n\t\tres = res * base + c;\n\t}\n\treturn res;\n}\n \nstring to_str(const vector<string> &state) {\n\tstring res = \"\";\n\tfor(const auto &s : state) {\n\t\tres += s + \":\";\n\t}\n\treturn res;\n}\n \nunordered_map<hash_t, int> bfs(int limit, const vector<string> &start, const vector<E> &exchanges) {\n\tunordered_map<hash_t, int> res;\n\tqueue<vector<string>> que;\n \n\tres.insert({rolling_hash(to_str(start)), 0});\n\tque.push(start);\n \n\twhile(!que.empty()) {\n\t\tvector<string> state = que.front();\n\t\tque.pop();\n\t\tconst int d = res.at(rolling_hash(to_str(state)));\n \n\t\tif(d == limit) break;\n \n\t\tfor(const auto &element : exchanges) {\n\t\t\tconst A &pos = element.first;\n\t\t\tconst A &dir = element.second;\n\t\t\tconst array<string, 2> train{move(state[pos.front()]), move(state[pos.back()])};\n\n\t\t\tfor(int i = 0; i <= 1; ++i) {\n\t\t\t\tconst int from = i;\n\t\t\t\tconst int to = 1 - i;\n\n\t\t\t\tconst int &p1 = pos[from];\n\t\t\t\tconst int &p2 = pos[to];\n\t\t\t\tconst int &d1 = dir[from];\n\t\t\t\tconst int &d2 = dir[to];\n\t\t\t\tconst string &t1 = train[from];\n\t\t\t\tconst string &t2 = train[to];\n\n\t\t\t\tfor(int num = 1; num <= t1.size(); ++num) {\n\t\t\t\t\tstring tmp = (d1 ? t1.substr(0, num) : t1.substr(t1.size() - num));\n\t\t\t\t\tif(d1 == d2) reverse(tmp.begin(), tmp.end());\n\t\t\t\t\tstate[p1] = (d1 ? t1.substr(num) : t1.substr(0, t1.size() - num));\n\t\t\t\t\tstate[p2] = (d2 ? tmp + t2 : t2 + tmp);\n \n\t\t\t\t\tconst hash_t h = rolling_hash(to_str(state));\n\t\t\t\t\tif(!res.count(h)) {\n\t\t\t\t\t\tres.insert({h, d + 1});\n\t\t\t\t\t\tque.push(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tstate[pos.front()] = move(train.front());\n\t\t\tstate[pos.back()] = move(train.back());\n\t\t}\n\t}\n \n\treturn res;\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n \n\tfor(int x, y; cin >> x >> y && x;) {\n\t\tvector<E> exchanges;\n\t\texchanges.reserve(y);\n \n\t\tfor(int i = 0; i < y; ++i) {\n\t\t\tstring a, b;\n\t\t\tcin >> a >> b;\n \n\t\t\tconst int p1 = a[0] - '0';\n\t\t\tconst int d1 = (a[1] == 'W');\n\t\t\tconst int p2 = b[0] - '0';\n\t\t\tconst int d2 = (b[1] == 'W');\n \n\t\t\texchanges.emplace_back(A{p1, p2}, A{d1, d2});\n\t\t}\n \n\t\tvector<string> lines(x), goal(x);\n \n\t\tfor(auto &e : lines) {\n\t\t\tcin >> e;\n\t\t\tif(e == \"-\") e = \"\";\n\t\t}\n \n\t\tfor(auto &e : goal) {\n\t\t\tcin >> e;\n\t\t\tif(e == \"-\") e = \"\";\n\t\t}\n     \n\t\tconst auto d1 = bfs(3, lines, exchanges);\n\t\tconst auto d2 = bfs(2, goal, exchanges);\n \n\t\tint ans = 6;\n\t\tfor(const auto &e1 : d2) {\n\t\t\tif(ans <= e1.second) continue;\n \n\t\t\tif(d1.count(e1.first)) {\n\t\t\t\tchmin(ans, e1.second + d1.at(e1.first));\n\t\t\t}\n\t\t}\n \n\t\tcout << ans << endl;\n\t}\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef array<int, 2> A;\ntypedef pair<A, A> E;\ntypedef unsigned hash_t;\n\nhash_t rolling_hash(const string &s) {\n\tstatic constexpr hash_t base = 1000000007;\n\thash_t res = 0;\n\tfor(const auto &c : s) {\n\t\tres = res * base + c;\n\t}\n\treturn res;\n}\n \nstring to_str(const vector<string> &state) {\n\tstring res = \"\";\n\tfor(const auto &s : state) {\n\t\tres += s + \":\";\n\t}\n\treturn res;\n}\n \nunordered_map<hash_t, int> bfs(int limit, const vector<string> &start, const vector<E> &exchanges) {\n\tunordered_map<hash_t, int> res;\n\tqueue<vector<string>> que;\n \n\tres.insert({rolling_hash(to_str(start)), 0});\n\tque.push(start);\n \n\twhile(!que.empty()) {\n\t\tvector<string> state = que.front();\n\t\tque.pop();\n\t\tconst int d = res.at(rolling_hash(to_str(state)));\n \n\t\tif(d == limit) break;\n \n\t\tfor(const auto &element : exchanges) {\n\t\t\tconst A &pos = element.first;\n\t\t\tconst A &dir = element.second;\n\t\t\tconst array<string, 2> train{move(state[pos.front()]), move(state[pos.back()])};\n\n\t\t\tfor(int i = 0; i <= 1; ++i) {\n\t\t\t\tconst int from = i;\n\t\t\t\tconst int to = 1 - i;\n\n\t\t\t\tconst int &p1 = pos[from];\n\t\t\t\tconst int &p2 = pos[to];\n\t\t\t\tconst int &d1 = dir[from];\n\t\t\t\tconst int &d2 = dir[to];\n\t\t\t\tconst string &t1 = train[from];\n\t\t\t\tconst string &t2 = train[to];\n\n\t\t\t\tfor(int num = 1; num <= t1.size(); ++num) {\n\t\t\t\t\tstring tmp = (d1 ? t1.substr(0, num) : t1.substr(t1.size() - num));\n\t\t\t\t\tif(d1 == d2) reverse(tmp.begin(), tmp.end());\n\t\t\t\t\tstate[p1] = (d1 ? t1.substr(num) : t1.substr(0, t1.size() - num));\n\t\t\t\t\tstate[p2] = (d2 ? tmp + t2 : t2 + tmp);\n \n\t\t\t\t\tconst hash_t h = rolling_hash(to_str(state));\n\t\t\t\t\tif(!res.count(h)) {\n\t\t\t\t\t\tres.insert({h, d + 1});\n\t\t\t\t\t\tque.push(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tstate[pos.front()] = move(train.front());\n\t\t\tstate[pos.back()] = move(train.back());\n\t\t}\n\t}\n \n\treturn res;\n}\n \nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n \n\tfor(int x, y; cin >> x >> y && x;) {\n\t\tvector<E> exchanges;\n\t\texchanges.reserve(y);\n \n\t\tfor(int i = 0; i < y; ++i) {\n\t\t\tstring a, b;\n\t\t\tcin >> a >> b;\n \n\t\t\tconst int p1 = a[0] - '0';\n\t\t\tconst int d1 = (a[1] == 'W');\n\t\t\tconst int p2 = b[0] - '0';\n\t\t\tconst int d2 = (b[1] == 'W');\n \n\t\t\texchanges.emplace_back(A{p1, p2}, A{d1, d2});\n\t\t}\n \n\t\tvector<string> lines(x), goal(x);\n \n\t\tfor(auto &e : lines) {\n\t\t\tcin >> e;\n\t\t\tif(e == \"-\") e = \"\";\n\t\t}\n \n\t\tfor(auto &e : goal) {\n\t\t\tcin >> e;\n\t\t\tif(e == \"-\") e = \"\";\n\t\t}\n     \n\t\tconst auto d1 = bfs(3, lines, exchanges);\n\t\tconst auto d2 = bfs(2, goal, exchanges);\n \n\t\tint ans = 6;\n\t\tfor(const auto &e1 : d2) {\n\t\t\tif(ans <= e1.second) continue;\n \n\t\t\tif(d1.count(e1.first)) {\n\t\t\t\tchmin(ans, e1.second + d1.at(e1.first));\n\t\t\t}\n\t\t}\n \n\t\tcout << ans << endl;\n\t}\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<deque<char> > const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()+1) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    queue<char> u;\n                    repeat (k,n) {\n                        if (v.second == W) {\n                            u.push(t[i].front());\n                            t[i].pop_front();\n                        } else {\n                            u.push(t[i].back());\n                            t[i].pop_back();\n                        }\n                    }\n                    repeat (k,n) {\n                        if (w.second == W) {\n                            t[j].push_front(u.front());\n                        } else {\n                            t[j].push_back(u.front());\n                        }\n                        u.pop();\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nunordered_map<uint64_t,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    unordered_map<uint64_t,int> ms;\n    ms[pack(s)] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            uint64_t h = pack(it);\n            if (not ms.count(h)) {\n                ms[h] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        unordered_map<uint64_t,int> s3 = steps(s, g, 3);\n        unordered_map<uint64_t,int> t3 = steps(t, g, 3);\n        int result = 6;\n        for (auto it : s3) {\n            if (t3.count(it.first)) {\n                result = min(result, it.second + t3[it.first]);\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<deque<char> > const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()+1) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    queue<char> u;\n                    repeat (k,n) {\n                        if (v.second == W) {\n                            u.push(t[i].front());\n                            t[i].pop_front();\n                        } else {\n                            u.push(t[i].back());\n                            t[i].pop_back();\n                        }\n                    }\n                    repeat (k,n) {\n                        if (w.second == W) {\n                            t[j].push_front(u.front());\n                        } else {\n                            t[j].push_back(u.front());\n                        }\n                        u.pop();\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nmap<uint64_t,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    map<uint64_t,int> ms;\n    ms[pack(s)] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            uint64_t h = pack(it);\n            if (not ms.count(h)) {\n                ms[h] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        map<uint64_t,int> s3 = steps(s, g, 3);\n        map<uint64_t,int> t3 = steps(t, g, 3);\n        int result = 6;\n        for (auto it : s3) {\n            if (t3.count(it.first)) {\n                result = min(result, it.second + t3[it.first]);\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n\n#define repi(i,a,b) for(int i = int(a); i < int(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = int(a); i >= int(b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\nconst double pi = acos(-1.0);\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> state;\n\nvector<vector<int> > G;\n\nint x, y;\nstate s, t;\n\nvoid input()\n{\n    G.assign(2 * x, vector<int>()), s.assign(x, \"\"), t.assign(x, \"\");\n\n    rep(i, y) {\n        int p, q; char P, Q;\n        cin >> p >> P >> q >> Q;\n        int a = P == 'W' ? p : p + x;\n        int b = Q == 'W' ? q : q + x;\n        G[a].pb(b), G[b].pb(a);        \n    }\n    rep(i, x) {\n        cin >> s[i];\n        if (s[i] == \"-\") s[i] = \"\";\n    }\n    rep(i, x) {\n        cin >> t[i];\n        if (t[i] == \"-\") t[i] = \"\";\n    }\n}\n\nmap<state, int> fromS, fromT;\n\nvoid bfs(state start, map<state, int> &mem)\n{\n    mem.clear();\n\n    queue<pair<state, int> > Q;\n    Q.push(mp(start, 0));\n    while (!Q.empty()) {\n        pair<state, int> cur = Q.front(); Q.pop();\n\n        if (mem.find(cur.first) != mem.end() || cur.second > 3)\n            continue;\n        mem[cur.first] = cur.second;\n\n        if (cur.second == 3) continue;\n\n        rep(i, x) rep(cut, cur.first[i].length()) {\n            rep(j, G[i].size()) if (cut) {\n                string west = cur.first[i].substr(0, cut);\n\n                int to = G[i][j];\n                state next = cur.first;\n                next[i].erase(next[i].begin(), next[i].begin() + cut);\n                if (to < x) {\n                    reverse(all(west));\n                    next[to].insert(next[to].begin(), all(west));\n                } else\n                    next[to - x].insert(next[to - x].end(), all(west));\n                Q.push(mp(next, cur.second + 1));\n            }\n            rep(j, G[i + x].size()) if (cut < cur.first[i].length() - 1) {\n                string east = cur.first[i].substr(cut);\n\n                int to = G[i + x][j];\n                state next = cur.first;\n                next[i].erase(next[i].begin() + cut, next[i].end());\n                if (to < x)\n                    next[to].insert(next[to].begin(), all(east));\n                else {\n                    reverse(all(east));\n                    next[to - x].insert(next[to - x].end(), all(east));\n                }\n                Q.push(mp(next, cur.second + 1));\n            }\n        }\n    }\n}\n\nvoid solve()\n{\n    bfs(s, fromS), bfs(t, fromT);\n\n    int ans = 10;\n    repit(it, fromS) {\n        map<state, int>::iterator it1 = fromT.find(it->first);\n        if (it1 != fromT.end())\n            ans = min(ans, it->second + it1->second);\n    }\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    while (cin >> x >> y && x) {\n        input();\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<vector<int> > to;\n\nvoid solve(vector<string> start, map<vector<string>, int>& history)\n{\n    queue<vector<string> > q1;\n    q1.push(start);\n    history[start] = 0;\n\n    for(int a=1; a<=3; ++a){\n        queue<vector<string> > q2;\n        while(!q1.empty()){\n            vector<string> s = q1.front();\n            q1.pop();\n\n            for(int i=0; i<n*2; ++i){\n                for(unsigned j=0; j<to[i].size(); ++j){\n                    vector<string> t = s;\n                    while(!t[i/2].empty()){\n                        char c;\n                        if(i % 2 == 0){\n                            c = t[i/2][0];\n                            t[i/2] = t[i/2].substr(1);\n                        }else{\n                            c = t[i/2][t[i/2].size()-1];\n                            t[i/2] = t[i/2].substr(0, t[i/2].size()-1);\n                        }\n\n                        if(to[i][j] % 2 == 0){\n                            t[to[i][j]/2] = c + t[to[i][j]/2];\n                        }else{\n                            t[to[i][j]/2] += c;\n                        }\n\n                        if(history.find(t) == history.end()){\n                            q2.push(t);\n                            history[t] = a;\n                        }\n                    }\n                }\n            }\n        }\n        q1.swap(q2);\n    }\n}\n\nint main()\n{\n    for(;;){\n        int m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        to.resize(2*n);\n        for(int i=0; i<m; ++i){\n            string s, t;\n            cin >> s >> t;\n            int a = (s[0] - '0') * 2;\n            int b = (t[0] - '0') * 2;\n            if(s[1] == 'E')\n                ++ a;\n            if(t[1] == 'E')\n                ++ b;\n            to[a].push_back(b);\n            to[b].push_back(a);\n        }\n\n        vector<string> s(n), t(n);\n        for(int i=0; i<n; ++i){\n            cin >> s[i];\n            if(s[i] == \"-\")\n                s[i] = \"\";\n        }\n        for(int i=0; i<n; ++i){\n            cin >> t[i];\n            if(t[i] == \"-\")\n                t[i] = \"\";\n        }\n\n        map<vector<string>, int> history1, history2;\n        solve(t, history2);\n        solve(s, history1);\n\n        int ret = INT_MAX;\n        map<vector<string>, int>::iterator it1, it2;\n        it1 = history1.begin();\n        it2 = history2.begin();\n        while(it1 != history1.end() && it2 != history2.end()){\n            if(it1->first == it2->first)\n                ret = min(ret, it1->second + it2->second);\n            if(it1->first < it2->first)\n                ++ it1;\n            else\n                ++ it2;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\n#define MAX 4\n#define LIMIT 6\n#define FORWARD 0\n#define BACK 1\n#define WEST 0\n#define EAST 1\n#define BUFFER 40\n\nusing namespace std;\n\nclass Load{\n public:\n  char buffer[BUFFER];\n  int head, tail, size;\n  Load(){}\n  Load( string str ){\n    head = tail = BUFFER/2;\n    size = 0;\n    for ( int i = 0; i < str.size(); i++ ){\n      buffer[tail++] = str[i];\n      size++;\n    }\n  }\n  \n  void intoW( char ch ){ buffer[--head] = ch; size++; }\n  void intoE( char ch ){ buffer[tail++] = ch; size++; }\n  char fromW(){ char ch = buffer[head]; head++; size--; return ch; }\n  char fromE(){ char ch = buffer[tail-1]; tail--; size--; return ch; }\n  \n  bool operator < ( const Load &l ) const {\n    if ( size != l.size ) return size < l.size;\n    for ( int i = head, j = l.head; i < tail; i++, j++ ){\n      if ( buffer[i] == l.buffer[j] ) continue;\n      return buffer[i] < l.buffer[j];\n    }\n    return false;\n  }\n  \n  bool operator == ( const Load &l ) const {\n    if ( size != l.size ) return false;\n    for ( int i = head, j = l.head; i < tail; i++, j++ ){\n      if ( buffer[i] != l.buffer[j] ) return false;\n    }\n    return true;\n  }\n  \n  bool operator != ( const Load &l ) const {\n    if ( size != l.size ) return true;\n    for ( int i = head, j = l.head; i < tail; i++, j++ ){\n      if ( buffer[i] != l.buffer[j] ) return true;\n    }\n    return false;\n  }\n};\n\nclass Station{\n public:\n  int nload;\n  Load loads[MAX];\n  int id;\n  \n  Station(){}\n  Station( int nload): nload(nload){}\n  \n  bool operator < ( const Station &s ) const {\n    for ( int i = 0; i < nload; i++ ){\n      if ( loads[i] == s.loads[i] ) continue;\n      return loads[i] < s.loads[i];\n    }\n    return false;\n  }\n  \n  bool operator == ( const Station &s ) const {\n    for ( int i = 0; i < nload; i++ ){\n      if ( loads[i] != s.loads[i] ) return false;\n    }\n    return true;\n  }\n};\n\n\nStation initial, goal;\nint nload;\nbool M[MAX][2][MAX][2]; \n\nmap<Station, int> BS; \nmap<Station, int> FS; \n\nStation getNext(Station v, int d, int s, int sd, int t, int td){\n  int nd;\n  \n  if ( sd == WEST ){\n    if ( td == WEST ){\n      for ( int i = 0; i < d; i++  ){\n\tv.loads[t].intoW(v.loads[s].fromW());\n      }\n    } else {\n      for ( int i = 0; i < d; i++  ){\n\tv.loads[t].intoE(v.loads[s].fromW());\n      }\n    }\n  } else {\n    if ( td == WEST ){\n      nd = v.loads[s].size - d;\n      for ( int i = 0; i < nd; i++ ){\n\tv.loads[t].intoW(v.loads[s].fromE());\n      }\n    } else {\n      nd = v.loads[s].size - d;\n      for ( int i = 0; i < nd; i++ ){\n\tv.loads[t].intoE(v.loads[s].fromE());\n      }\n    }\n  }\n  \n  return v;\n}\n\nint bfs( Station source, map<Station, int> &D, int mode ){\n  queue<Station> Q;\n  Q.push(source);\n  D[source] = 0;\n  \n  Station u, v;\n  \n  if ( mode == FORWARD && BS.find(source) != BS.end() ) return BS[source];\n  \n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    int dist = D[u];\n    \n    if ( mode == BACK && dist >= 3 ) return 0;\n    \n    for ( int s = 0; s < nload; s++ ){\n      for ( int d = 0; d < u.loads[s].size; d++ ){\n\tfor ( int t = 0; t < nload; t++ ){\n\t  for ( int sd = 0; sd < 2; sd++ ){\n\t    for ( int td = 0; td < 2; td++ ){\n\t      if ( M[s][sd][t][td] ){\n\t\tv = getNext(u, d, s, sd, t, td );\n\t\tif ( D.find(v) == D.end() ){\n\t\t  D[v] = dist + 1;\n\t\t  if ( mode == FORWARD ){\n\t\t    if ( BS.find(v) != BS.end() ) {\n\t\t      return BS[v] + dist + 1;\n\t\t    }\n\t\t  } \n\t\t  Q.push(v);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nvoid compute(){\n  BS = map<Station, int>();\n  FS = map<Station, int>();\n  bfs(goal, BS, BACK);\n  cout << bfs(initial, FS, FORWARD) << endl;\n}\n\nbool input(){\n  int y;\n  cin >> nload >> y;\n  if ( nload == 0 && y == 0 ) return false;\n  \n  for ( int i = 0; i < nload; i++ ){\n    for ( int j = 0; j < nload; j++ ){\n      M[i][WEST][j][WEST] = false;\n      M[i][WEST][j][EAST] = false;\n      M[i][EAST][j][WEST] = false;\n      M[i][EAST][j][EAST] = false;\n    }\n  }\n  int sl, tl; \n  char sd, td; \n  for ( int i = 0; i < y; i++ ){\n    cin >> sl >> sd >> tl >> td;\n    M[sl][(sd == 'W' ? WEST : EAST)][tl][(td == 'W' ? WEST : EAST)] = true;\n    M[tl][(td == 'W' ? WEST : EAST)][sl][(sd == 'W' ? WEST : EAST)] = true;\n  }\n  \n  initial = Station(nload);\n  goal = Station(nload);\n  \n  string train;\n  for ( int i = 0; i < nload; i++ ) {\n    cin >> train; if ( train == \"-\" ) train = \"\";\n    initial.loads[i] = Load(train);\n  }\n  for ( int i = 0; i < nload; i++ ) {\n    cin >> train; if ( train == \"-\" ) train = \"\";\n    goal.loads[i] = Load(train);\n  }\n  \n  return true;\n}\n\nmain(){\n  while( input() ) compute();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<vector<string>, int> VI;\n\nint n;\nvector<P> t[4][2];\nvector<string> start, end;\nmap<vector<string>, int> half;\n\nint ans;\n\nvoid enumerateHalf(){\n  queue<VI> open;\n  open.push(VI(start, 0));\n  half[start] = 0;\n\n  while(!open.empty()){\n    VI vi = open.front();\n    open.pop();\n    vector<string> vec = vi.first;\n    int step = vi.second;\n\n    for(int from = 0; from < n; from++){\n      if(vec[from].size() == 0) continue;\n\n      for(int cut = 0; cut < vec[from].size(); cut++){\n        string cut_str[2] = {\n          vec[from].substr(0, cut),\n          vec[from].substr(cut)\n        };\n        string rev_str[2] = {cut_str[0], cut_str[1]};\n        reverse(rev_str[0].begin(), rev_str[0].end());\n        reverse(rev_str[1].begin(), rev_str[1].end());\n\n        for(int from_dir = 0; from_dir < 2; from_dir++){\n          if(cut_str[from_dir].size() == 0) continue;\n\n          for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n            int to = t[from][from_dir][to_idx].first;\n            int to_dir = t[from][from_dir][to_idx].second;\n            vector<string> nvec = vec;\n\n            if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n            else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n            else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n            else                                  nvec[to] += rev_str[from_dir];\n\n            nvec[from] = cut_str[!from_dir];\n\n            map<vector<string>,int>::iterator tmp_iter = half.find(nvec);\n\n            if(tmp_iter != half.end()) continue;\n            half[nvec] = step + 1;\n\n            if(step == 2) continue;\n            open.push(VI(nvec, step + 1));\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid rec(int step, vector<string> vec){\n  map<vector<string>,int>::iterator tmp_iter = half.find(vec);\n  if(tmp_iter != half.end()){\n    ans = min(ans, step + tmp_iter->second);\n    return;\n  }\n  if(step == 3) return;\n\n  for(int from = 0; from < n; from++){\n    if(vec[from].size() == 0) continue;\n\n    for(int cut = 0; cut < vec[from].size(); cut++){\n      string cut_str[2] = {\n        vec[from].substr(0, cut),\n        vec[from].substr(cut)\n      };\n      string rev_str[2] = {cut_str[0], cut_str[1]};\n      reverse(rev_str[0].begin(), rev_str[0].end());\n      reverse(rev_str[1].begin(), rev_str[1].end());\n\n      for(int from_dir = 0; from_dir < 2; from_dir++){\n        if(cut_str[from_dir].size() == 0) continue;\n\n        for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n          int to = t[from][from_dir][to_idx].first;\n          int to_dir = t[from][from_dir][to_idx].second;\n          vector<string> nvec = vec;\n\n          if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n          else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n          else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n          else                                  nvec[to] += rev_str[from_dir];\n\n          nvec[from] = cut_str[!from_dir];\n\n          rec(step + 1, nvec);\n        }\n      }\n    }\n  }\n}\n\nvoid solve(){\n  half.clear();\n  enumerateHalf();\n\n  ans = INT_MAX;\n  rec(0, end);\n  cout << ans << endl;\n}\n\nint main(){\n  int m;\n\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 4; i++){\n      for(int j = 0; j < 2; j++){\n        t[i][j].clear();\n      }\n    }\n\n    for(int i = 0; i < m; i++){\n      string from, to;\n      cin >> from >> to;\n\n      int from_line = from[0] - '0';\n      int from_dir = (from[1] == 'W' ? 0 : 1);\n      int to_line = to[0] - '0';\n      int to_dir = (to[1] == 'W' ? 0 : 1);\n\n      t[from_line][from_dir].push_back(P(to_line, to_dir));\n      t[to_line][to_dir].push_back(P(from_line, from_dir));\n    }\n\n    start.clear();\n    end.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      start.push_back(s);\n    }\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      end.push_back(s);\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n\n#define REP(i,a,b) for(int i=(a);i < (int)(b); i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(v) begin(v), end(v)\n\nint x, y;\n\nint ans;\nvector<pair<pair<int, int>, pair<int, int>>> exchanges;\nvector<string> lines, goal;\n\nmap<vector<string>, int> visited;\n\nvoid dfs(int moves) {\n  int match = 0;\n  for(int i = 0; i < x; ++i) {\n    if(lines[i] == goal[i]) ++match;\n  }\n\n  if(match == x) {\n    ans = moves;\n    return;\n  }\n\n  if(moves + 1 >= ans) return;\n  if(ans - moves - 1 < (x - match) / 2) return;\n\n  if(visited.count(lines) && visited[lines] <= moves) return;\n  visited[lines] = moves;\n  \n  for(const auto &element : exchanges) {\n    const int p1 = element.first.first;\n    const int d1 = element.first.second;\n    const int p2 = element.second.first;\n    const int d2 = element.second.second;\n\n    const string t1 = move(lines[p1]);\n    const string t2 = move(lines[p2]);\n\n    // p1 -> p2\n    for(int num = 1; num <= t1.size(); ++num) {\n      string tmp = (d1 ? t1.substr(0, num) : t1.substr(t1.size() - num));\n      if(d1 == d2) reverse(tmp.begin(), tmp.end());\n      lines[p1] = (d1 ? t1.substr(num) : t1.substr(0, t1.size() - num));\n      lines[p2] = (d2 ? tmp + t2 : t2 + tmp);\n      dfs(moves + 1);\n    }\n\n    // p2 -> p1\n    for(int num = 1; num <= t2.size(); ++num) {\n      string tmp = (d2 ? t2.substr(0, num) : t2.substr(t2.size() - num));\n      if(d1 == d2) reverse(tmp.begin(), tmp.end());\n      lines[p1] = (d1 ? tmp + t1 : t1 + tmp);\n      lines[p2] = (d2 ? t2.substr(num) : t2.substr(0, t2.size() - num));\n      dfs(moves + 1);\n    }\n\n    lines[p1] = move(t1);\n    lines[p2] = move(t2);\n  }\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  while(cin >> x >> y && x) {\n    exchanges.clear();\n    exchanges.reserve(y);\n\n    for(int i = 0; i < y; ++i) {\n      string a, b;\n      cin >> a >> b;\n\n      const int p1 = a[0] - '0';\n      const int d1 = (a[1] == 'W');\n      const int p2 = b[0] - '0';\n      const int d2 = (b[1] == 'W');\n\n      exchanges.emplace_back(make_pair(p1, d1), make_pair(p2, d2));\n    }\n\n    lines.clear();\n    lines.resize(x);\n    for(auto &e : lines) {\n      cin >> e;\n      if(e == \"-\") e = \"\";\n    }\n\n    goal.clear();\n    goal.resize(x);\n    for(auto &e : goal) {\n      cin >> e;\n      if(e == \"-\") e = \"\";\n    }\n\n    visited.clear();\n    ans = 6;\n    dfs(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<deque<char> > const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()+1) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    queue<char> u;\n                    repeat (k,n) {\n                        if (v.second == W) {\n                            u.push(t[i].front());\n                            t[i].pop_front();\n                        } else {\n                            u.push(t[i].back());\n                            t[i].pop_back();\n                        }\n                    }\n                    repeat (k,n) {\n                        if (w.second == W) {\n                            t[j].push_front(u.front());\n                        } else {\n                            t[j].push_back(u.front());\n                        }\n                        u.pop();\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nmap<uint64_t,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n, map<uint64_t,int> const & forbidden) {\n    map<uint64_t,int> ms;\n    ms[pack(s)] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            uint64_t h = pack(it);\n            if (not ms.count(h)) {\n                ms[h] = i+1;\n                if (forbidden.count(h)) continue;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        map<uint64_t,int> s3 = steps(s, g, 3, map<uint64_t,int>());\n        map<uint64_t,int> t3 = steps(t, g, 3, s3);\n        int result = 6;\n        for (auto it : s3) {\n            if (t3.count(it.first)) {\n                result = min(result, it.second + t3[it.first]);\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<vector<int> > to;\n\nvoid solve(vector<string> start, map<vector<string>, int>& history)\n{\n    queue<vector<string> > q1;\n    q1.push(start);\n    history[start] = 0;\n\n    for(int a=1; a<=3; ++a){\n        queue<vector<string> > q2;\n        while(!q1.empty()){\n            vector<string> s = q1.front();\n            q1.pop();\n\n            for(int i=0; i<n*2; ++i){\n                for(unsigned j=0; j<to[i].size(); ++j){\n                    vector<string> t = s;\n                    while(!t[i/2].empty()){\n                        char c;\n                        if(i % 2 == 0){\n                            c = t[i/2][0];\n                            t[i/2] = t[i/2].substr(1);\n                        }else{\n                            c = t[i/2][t[i/2].size()-1];\n                            t[i/2] = t[i/2].substr(0, t[i/2].size()-1);\n                        }\n\n                        if(to[i][j] % 2 == 0){\n                            t[to[i][j]/2] = c + t[to[i][j]/2];\n                        }else{\n                            t[to[i][j]/2] += c;\n                        }\n\n                        if(history.find(t) == history.end()){\n                            q2.push(t);\n                            history[t] = a;\n                        }\n                    }\n                }\n            }\n        }\n        q1 = q2;\n    }\n}\n\nint main()\n{\n    for(;;){\n        int m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        to.assign(2*n, vector<int>());\n        for(int i=0; i<m; ++i){\n            string s, t;\n            cin >> s >> t;\n            int a = (s[0] - '0') * 2;\n            int b = (t[0] - '0') * 2;\n            if(s[1] == 'E')\n                ++ a;\n            if(t[1] == 'E')\n                ++ b;\n            to[a].push_back(b);\n            to[b].push_back(a);\n        }\n\n        vector<string> s(n), t(n);\n        for(int i=0; i<n; ++i){\n            cin >> s[i];\n            if(s[i] == \"-\")\n                s[i] = \"\";\n        }\n        for(int i=0; i<n; ++i){\n            cin >> t[i];\n            if(t[i] == \"-\")\n                t[i] = \"\";\n        }\n\n        map<vector<string>, int> history1, history2;\n        solve(t, history2);\n        solve(s, history1);\n\n        int ret = INT_MAX;\n        map<vector<string>, int>::iterator it1, it2;\n        it1 = history1.begin();\n        it2 = history2.begin();\n        while(it1 != history1.end() && it2 != history2.end()){\n            if(it1->first == it2->first)\n                ret = min(ret, it1->second + it2->second);\n            if(it1->first < it2->first)\n                ++ it1;\n            else\n                ++ it2;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<deque<char> > const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    repeat (k,n) {\n                        char c;\n                        if (v.second == W) {\n                            c = t[i].front();\n                            t[i].pop_front();\n                        } else {\n                            c = t[i].back();\n                            t[i].pop_back();\n                        }\n                        if (w.second == W) {\n                            t[j].push_front(c);\n                        } else {\n                            t[j].push_back(c);\n                        }\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nmap<vector<deque<char> >,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    map<vector<deque<char> >,int> ms;\n    ms[s] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            if (not ms.count(it)) {\n                ms[it] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        map<vector<deque<char> >,int> s2 = steps(s, g, 2);\n        map<vector<deque<char> >,int> t2 = steps(t, g, 2);\n        unordered_map<uint64_t,int> t2h;\n        for (auto it : t2) t2h[pack(it.first)] = it.second;\n        int result = 6;\n        for (auto it : s2) {\n            uint64_t ha = pack(it.first);\n            if (t2h.count(ha)) {\n                result = min(result, it.second + t2h[ha]);\n            }\n            if (it.second == 2) {\n                vector<vector<deque<char> > > s3;\n                step(it.first, g, back_inserter(s3));\n                for (auto that : s3) {\n                    uint64_t hb = pack(that);\n                    if (t2h.count(hb)) {\n                        result = min(result, 1 + it.second + t2h[hb]);\n                    }\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n\n#define repi(i,a,b) for(int i = int(a); i < int(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = int(a); i >= int(b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\nconst double pi = acos(-1.0);\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<string> state;\n\nvector<vector<int> > G;\n\nint x, y;\nstate s, t;\n\nvoid input()\n{\n    G.assign(2 * x, vector<int>()), s.assign(x, \"\"), t.assign(x, \"\");\n\n    rep(i, y) {\n        int p, q; char P, Q;\n        cin >> p >> P >> q >> Q;\n        int a = P == 'W' ? p : p + x;\n        int b = Q == 'W' ? q : q + x;\n        G[a].pb(b), G[b].pb(a);        \n    }\n    rep(i, x) {\n        cin >> s[i];\n        if (s[i] == \"-\") s[i] = \"\";\n    }\n    rep(i, x) {\n        cin >> t[i];\n        if (t[i] == \"-\") t[i] = \"\";\n    }\n}\n\nmap<state, int> fromS, fromT;\n\nvoid bfs(state start, map<state, int> &mem)\n{\n    mem.clear();\n\n    queue<pair<state, int> > Q;\n    Q.push(mp(start, 0));\n    while (!Q.empty()) {\n        pair<state, int> cur = Q.front(); Q.pop();\n\n        if (mem.find(cur.first) != mem.end() || cur.second > 3)\n            continue;\n        mem[cur.first] = cur.second;\n\n        rep(i, x) rep(cut, cur.first[i].length()) {\n            rep(j, G[i].size()) if (cut) {\n                string west = cur.first[i].substr(0, cut);\n\n                int to = G[i][j];\n                state next = cur.first;\n                next[i].erase(next[i].begin(), next[i].begin() + cut);\n                if (to < x) {\n                    reverse(all(west));\n                    next[to].insert(next[to].begin(), all(west));\n                } else\n                    next[to - x].insert(next[to - x].end(), all(west));\n                Q.push(mp(next, cur.second + 1));\n            }\n            rep(j, G[i + x].size()) if (cut < cur.first[i].length() - 1) {\n                string east = cur.first[i].substr(cut);\n\n                int to = G[i + x][j];\n                state next = cur.first;\n                next[i].erase(next[i].begin() + cut, next[i].end());\n                if (to < x)\n                    next[to].insert(next[to].begin(), all(east));\n                else {\n                    reverse(all(east));\n                    next[to - x].insert(next[to - x].end(), all(east));\n                }\n                Q.push(mp(next, cur.second + 1));\n            }\n        }\n    }\n}\n\nvoid solve()\n{\n    bfs(s, fromS), bfs(t, fromT);\n\n    int ans = 10;\n    repit(it, fromS) {\n        map<state, int>::iterator it1 = fromT.find(it->first);\n        if (it1 != fromT.end())\n            ans = min(ans, it->second + it1->second);\n    }\n    cout << ans << endl;\n}\n\nsigned main()\n{\n    while (cin >> x >> y && x) {\n        input();\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<vector<int> > to;\n\nvoid solve(vector<string> start, map<vector<string>, int>& history)\n{\n    set<vector<string> > curr;\n    curr.insert(start);\n    history[start] = 0;\n\n    for(int p=1; p<=3; ++p){\n        set<vector<string> > next;\n        while(!curr.empty()){\n            vector<string> s = *curr.begin();\n            curr.erase(curr.begin());\n\n            for(int i=0; i<n; ++i){\n                for(unsigned j=0; j<=s[i].size(); ++j){\n                    for(unsigned k=0; k<to[2*i].size(); ++k){\n                        string a = s[i].substr(0, j);\n                        string b = s[i].substr(j);\n                        vector<string> t = s;\n                        t[i] = b;\n                        if(to[2*i][k] % 2 == 0){\n                            reverse(a.begin(), a.end());\n                            t[to[2*i][k]/2] = a + t[to[2*i][k]/2];\n                        }else{\n                            t[to[2*i][k]/2] += a;\n                        }\n                        if(history.find(t) == history.end()){\n                            next.insert(t);\n                            history[t] = p;\n                        }\n                    }\n                    for(unsigned k=0; k<to[2*i+1].size(); ++k){\n                        string a = s[i].substr(0, j);\n                        string b = s[i].substr(j);\n                        vector<string> t = s;\n                        t[i] = a;\n                        if(to[2*i+1][k] % 2 == 0){\n                            t[to[2*i+1][k]/2] = b + t[to[2*i+1][k]/2];\n                        }else{\n                            reverse(b.begin(), b.end());\n                            t[to[2*i+1][k]/2] += b;\n                        }\n                        if(history.find(t) == history.end()){\n                            next.insert(t);\n                            history[t] = p;\n                        }\n                    }\n                }\n            }\n        }\n        curr.swap(next);\n    }\n}\n\nint main()\n{\n    for(;;){\n        int m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        to.resize(2*n);\n        for(int i=0; i<m; ++i){\n            string s, t;\n            cin >> s >> t;\n            int a = (s[0] - '0') * 2;\n            int b = (t[0] - '0') * 2;\n            if(s[1] == 'E')\n                ++ a;\n            if(t[1] == 'E')\n                ++ b;\n            to[a].push_back(b);\n            to[b].push_back(a);\n        }\n\n        vector<string> s(n), t(n);\n        for(int i=0; i<n; ++i){\n            cin >> s[i];\n            if(s[i] == \"-\")\n                s[i] = \"\";\n        }\n        for(int i=0; i<n; ++i){\n            cin >> t[i];\n            if(t[i] == \"-\")\n                t[i] = \"\";\n        }\n\n        map<vector<string>, int> history1, history2;\n        solve(s, history1);\n        solve(t, history2);\n\n        int ret = INT_MAX;\n        map<vector<string>, int>::iterator it1 = history1.begin();\n        map<vector<string>, int>::iterator it2 = history2.begin();\n        while(it1 != history1.end() && it2 != history2.end()){\n            if(it1->first == it2->first)\n                ret = min(ret, it1->second + it2->second);\n            if(it1->first < it2->first)\n                ++ it1;\n            else\n                ++ it2;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class Key, class Value>\nstruct HashMap {\n\n    static const int MAXH = 999983;\n    struct Edge {\n        Key to;\n        Value v;\n        Edge *next;\n    } *head[MAXH];\n\n    void set(const Key &key, const Value &value) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        Edge *p = new Edge;\n        p -> to = key;\n        p -> v = value;\n        p -> next = head[hv];\n        head[hv] = p;\n    }\n\n    const Value &get(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return p -> v;\n    }\n\n    bool exist(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return true;\n        return false;\n    }\n\n    void clear() {\n\n        for (int i = 0; i < MAXH; i++)\n        {\n            for (Edge *p = head[i], *np; p; p = np)\n            {\n                np = p -> next;\n                delete p;\n            }\n            head[i] = NULL;\n        }\n    }\n};\n\nconst int MAXN = 4;\nconst int MAXM = MAXN * MAXN * 2;\nint n, m, mcnt;\nint track[MAXM][2], dir[MAXM][2];\n\nstruct State {\n\n    vector<string> s;\n\n    string &operator[](int x) {\n\n        return s[x];\n    }\n\n    int hash_value() const {\n\n        unsigned int res = 0, res0;\n        for (int i = 0; i < n; i++)\n        {\n            res0 = 0;\n            const string &ref = s[i];\n            string::size_type len = ref.length();\n            for (int j = 0; j < len; j++)\n                res0 = res0 * 131 + ref[j];\n            res = res * 13131 + res0;\n        }\n        return res;\n    }\n\n    bool operator==(const State &b) const {\n\n        for (int i = 0; i < n; i++)\n            if (s[i] != b.s[i]) return false;\n        return true;\n    }\n\n    void go(int n0, int d0, int n1, int d1, int k) {\n\n        string out = s[n0].substr(0, k);\n        s[n0] = s[n0].erase(0, k);\n        if (d0) std::swap(out, s[n0]);\n        if (d0 == d1) reverse(out.begin(), out.end());\n        if (d1) s[n1] += out;\n        else s[n1] = out + s[n1];\n    }\n\n    void push_back(const string &b) {\n\n        s.push_back(b);\n    }\n};\n\nstruct Bfs {\n\n    queue<State> q[2], *old, *new_;\n    HashMap<State, int> hash;\n    int head, tail;\n    Bfs *pair;\n\n    void init() {\n\n        hash.clear();\n        for (int i = 0; i < 2; i++)\n            while (!q[i].empty()) q[i].pop();\n        old = q;\n        new_ = q + 1;\n    }\n\n    int push(const State &ns, int step) {\n\n        if (hash.exist(ns)) return -1;\n        if (pair -> hash.exist(ns))\n        {\n            int t = pair -> hash.get(ns);\n            return step + t; \n        }\n        hash.set(ns, step);\n        new_ -> push(ns);\n        return -1;\n    }\n\n    int next() {\n\n        while (!old -> empty())\n        {\n            State &ref = old -> front();\n            int nstep = hash.get(ref) + 1;\n            for (int i = 0; i < mcnt; i++)\n            {\n                string::size_type len = ref[track[i][0]].length();\n                for (int k = 0; k <= len; k++)\n                {\n                    State v = ref;\n                    v.go(track[i][0], dir[i][0], track[i][1], dir[i][1], k);\n                    int ret = push(v, nstep);\n                    if (ret != -1) return ret;\n                }\n            }\n            old -> pop();\n        }\n        swap(old, new_);\n        return -1;\n    }\n};\n\nBfs ins[2];\n\nint main() {\n\n    freopen(\"in\", \"r\", stdin);\n\n    for (;;)\n    {\n        mcnt = 0;\n        scanf(\"%d %d\", &n, &m);\n        if (!n && !m) break;\n        for (int i = 0; i < m; i++)\n        {\n            int f, t;\n            char fd, td;\n            scanf(\"%d%c %d%c\", &f, &fd, &t, &td);\n            fd = fd == 'E';\n            td = td == 'E';\n            track[mcnt][0] = f; track[mcnt][1] = t;\n            dir[mcnt][0] = fd; dir[mcnt][1] = td;\n            mcnt++;\n\n            track[mcnt][0] = t; track[mcnt][1] = f;\n            dir[mcnt][0] = td; dir[mcnt][1] = fd;\n            mcnt++;\n        }\n\n        State root[2];\n        static char buff[20];\n\n        for (int t = 0; t < 2; t++)\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%s\", buff);\n            root[t].push_back(buff);\n            if (root[t][i] == \"-\") root[t][i] = \"\";\n        }\n\n        for (int i = 0; i < 2; i++) \n        {\n            ins[i].init();\n            ins[i].pair = ins + !i;\n            swap(ins[i].old, ins[i].new_);\n            ins[i].push(root[i], 0);\n        }\n        for (int i = 0; i < 2; i++)\n            swap(ins[i].old, ins[i].new_);\n\n        for (int i = 0;; i ^= 1)\n        {\n            int ret = ins[i].next();\n            if (ret != -1) \n            {\n                printf(\"%d\\n\", ret);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<deque<char> > const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()+1) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    queue<char> u;\n                    repeat (k,n) {\n                        if (v.second == W) {\n                            u.push(t[i].front());\n                            t[i].pop_front();\n                        } else {\n                            u.push(t[i].back());\n                            t[i].pop_back();\n                        }\n                    }\n                    repeat (k,n) {\n                        if (w.second == W) {\n                            t[j].push_front(u.front());\n                        } else {\n                            t[j].push_back(u.front());\n                        }\n                        u.pop();\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nmap<vector<deque<char> >,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    map<vector<deque<char> >,int> ms;\n    ms[s] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            if (not ms.count(it)) {\n                ms[it] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        map<vector<deque<char> >,int> s2 = steps(s, g, 2);\n        map<vector<deque<char> >,int> t2 = steps(t, g, 2);\n        unordered_map<uint64_t,int> t2h;\n        for (auto it : t2) t2h[pack(it.first)] = it.second;\n        int result = 6;\n        for (auto it : s2) {\n            uint64_t ha = pack(it.first);\n            if (t2h.count(ha)) {\n                result = min(result, it.second + t2h[ha]);\n            }\n            if (it.second == 2) {\n                vector<vector<deque<char> > > s3;\n                step(it.first, g, back_inserter(s3));\n                for (auto that : s3) {\n                    uint64_t hb = pack(that);\n                    if (t2h.count(hb)) {\n                        result = min(result, 1 + it.second + t2h[hb]);\n                    }\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n\n#define REP(i,a,b) for(int i=(a);i < (int)(b); i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(v) begin(v), end(v)\n\nint x, y;\nvector<pair<pair<int, bool>, pair<int, bool>>> exchanges;\n\ntypedef unsigned long long hash_t;\nhash_t rolling_hash(const string &s) {\n  constexpr hash_t base = 1000000007;\n  hash_t res = 0;\n  for(const auto &c : s) {\n    res = res * base + c;\n  }\n  return res;\n}\n\nstring to_str(const vector<string> &state) {\n  string res = \"\";\n  for(const auto &s : state) {\n    res += s + \":\";\n  }\n  return res;\n}\n\nunordered_map<hash_t, int> bfs(int limit, const vector<string> &start) {\n  unordered_map<hash_t, int> res;\n  queue<vector<string>> que;\n\n  res.insert({rolling_hash(to_str(start)), 0});\n  que.push(start);\n\n  while(!que.empty()) {\n    vector<string> state = que.front();\n    que.pop();\n    const int d = res[rolling_hash(to_str(state))];\n\n    if(d == limit) break;\n\n    for(const auto &element : exchanges) {\n      const int p1 = element.first.first;\n      const bool d1 = element.first.second;\n      const int p2 = element.second.first;\n      const bool d2 = element.second.second;\n\n      const string t1 = move(state[p1]);\n      const string t2 = move(state[p2]);\n\n      // p1 -> p2\n      for(int num = 1; num <= t1.size(); ++num) {\n\tstring tmp = (d1 ? t1.substr(0, num) : t1.substr(t1.size() - num));\n\tif(d1 == d2) reverse(tmp.begin(), tmp.end());\n\tstate[p1] = (d1 ? t1.substr(num) : t1.substr(0, t1.size() - num));\n\tstate[p2] = (d2 ? tmp + t2 : t2 + tmp);\n\n\tconst hash_t h = rolling_hash(to_str(state));\n\tif(!res.count(h)) {\n\t  res.insert({h, d + 1});\n\t  que.push(state);\n\t}\n      }\n\n      // p2 -> p1\n      for(int num = 1; num <= t2.size(); ++num) {\n\tstring tmp = (d2 ? t2.substr(0, num) : t2.substr(t2.size() - num));\n\tif(d1 == d2) reverse(tmp.begin(), tmp.end());\n\tstate[p1] = (d1 ? tmp + t1 : t1 + tmp);\n\tstate[p2] = (d2 ? t2.substr(num) : t2.substr(0, t2.size() - num));\n\n\tconst hash_t h = rolling_hash(to_str(state));\n\tif(!res.count(h)) {\n\t  res.insert({h, d + 1});\n\t  que.push(state);\n\t}\n      }\n\n      state[p1] = move(t1);\n      state[p2] = move(t2);\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  while(cin >> x >> y && x) {\n    exchanges.clear();\n    exchanges.reserve(y);\n\n    for(int i = 0; i < y; ++i) {\n      string a, b;\n      cin >> a >> b;\n\n      const int p1 = a[0] - '0';\n      const bool d1 = (a[1] == 'W');\n      const int p2 = b[0] - '0';\n      const bool d2 = (b[1] == 'W');\n\n      exchanges.emplace_back(make_pair(p1, d1), make_pair(p2, d2));\n    }\n\n    vector<string> lines(x), goal(x);\n\n    for(auto &e : lines) {\n      cin >> e;\n      if(e == \"-\") e = \"\";\n    }\n\n    for(auto &e : goal) {\n      cin >> e;\n      if(e == \"-\") e = \"\";\n    }\n    \n    const auto d1 = bfs(3, lines);\n    const auto d2 = bfs(2, goal);\n\n    vector<string> tmp{\"cc\", \"\", \"bbaadee\"};\n\n    int ans = 6;\n    for(const auto &e1 : d2) {\n      if(ans <= e1.second) continue;\n\n      if(d1.count(e1.first)) {\n\tans = min(ans, e1.second + d1.at(e1.first));\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<string> const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<string> const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat (n,s[i].size()+1) {\n            string l = s[i].substr(0, n);\n            string r = s[i].substr(n);\n            for (we_t p : { W, E }) {\n                if ((l.empty() and p == W) or (r.empty() and p == E)) continue;\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int  j = w.first;\n                    we_t q = w.second;\n                    vector<string> t = s;\n                    t[i]     = p == W ? r : l;\n                    string u = p == W ? l : r;\n                    if (p == q) reverse(u.begin(), u.end());\n                    t[j] = q == W ? u + s[j] : s[j] + u;\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nmap<vector<string>,int> steps(vector<string> const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    map<vector<string>,int> ms;\n    ms[s] = 0;\n    vector<vector<string> > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<string> > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            if (not ms.count(it)) {\n                ms[it] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<string> s(x); repeat (i,x) { cin >> s[i]; if (s[i] == \"-\") s[i].clear(); }\n        vector<string> t(x); repeat (i,x) { cin >> t[i]; if (t[i] == \"-\") t[i].clear(); }\n        map<vector<string>,int> s2 = steps(s, g, 2);\n        map<vector<string>,int> t2 = steps(t, g, 2);\n        unordered_map<uint64_t,int> t2h; // required\n        for (auto it : t2) t2h[pack(it.first)] = it.second;\n        int result = 6;\n        for (auto it : s2) {\n            uint64_t ha = pack(it.first);\n            if (t2h.count(ha)) {\n                result = min(result, it.second + t2h[ha]);\n            }\n            if (it.second == 2) {\n                vector<vector<string> > s3;\n                step(it.first, g, back_inserter(s3));\n                for (auto that : s3) {\n                    uint64_t hb = pack(that);\n                    if (t2h.count(hb)) {\n                        result = min(result, 1 + it.second + t2h[hb]);\n                    }\n                }\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class Key, class Value>\nstruct HashMap {\n\n    static const int MAXH = 999983;\n    struct Edge {\n        Key to;\n        Value v;\n        Edge *next;\n    } *head[MAXH];\n\n    void set(const Key &key, const Value &value) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        Edge *p = new Edge;\n        p -> to = key;\n        p -> v = value;\n        p -> next = head[hv];\n        head[hv] = p;\n    }\n\n    const Value &get(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return p -> v;\n    }\n\n    bool exist(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return true;\n        return false;\n    }\n\n    void clear() {\n\n        for (int i = 0; i < MAXH; i++)\n        {\n            for (Edge *p = head[i], *np; p; p = np)\n            {\n                np = p -> next;\n                delete p;\n            }\n            head[i] = NULL;\n        }\n    }\n};\n\nconst int MAXN = 4;\nconst int MAXM = MAXN * MAXN * 2;\nint n, m, mcnt;\nbool trans[MAXN][2][MAXN][2];\n//int track[MAXM][2], dir[MAXM][2];\n\nstruct State {\n\n    vector<string> s;\n\n    string &operator[](int x) {\n\n        return s[x];\n    }\n\n    int hash_value() const {\n\n        unsigned int res = 0, res0;\n        for (int i = 0; i < n; i++)\n        {\n            res0 = 0;\n            const string &ref = s[i];\n            string::size_type len = ref.length();\n            for (int j = 0; j < len; j++)\n                res0 = res0 * 131 + ref[j];\n            res = res * 13131 + res0;\n        }\n        return res;\n    }\n\n    bool operator==(const State &b) const {\n\n        for (int i = 0; i < n; i++)\n            if (s[i] != b.s[i]) return false;\n        return true;\n    }\n\n    void go(int n0, int d0, int n1, int d1, int k) {\n\n        string out = s[n0].substr(0, k);\n        s[n0] = s[n0].erase(0, k);\n        if (d0) std::swap(out, s[n0]);\n        if (d0 == d1) reverse(out.begin(), out.end());\n        if (d1) s[n1] += out;\n        else s[n1] = out + s[n1];\n    }\n\n    void push_back(const string &b) {\n\n        s.push_back(b);\n    }\n};\n\nstruct Bfs {\n\n    queue<State> q[2], *old, *new_;\n    HashMap<State, int> hash;\n    int head, tail;\n    Bfs *pair;\n\n    void init() {\n\n        hash.clear();\n        for (int i = 0; i < 2; i++)\n            while (!q[i].empty()) q[i].pop();\n        old = q;\n        new_ = q + 1;\n    }\n\n    int push(const State &ns, int step) {\n\n        if (hash.exist(ns)) return -1;\n        if (pair -> hash.exist(ns))\n        {\n            int t = pair -> hash.get(ns);\n            return step + t; \n        }\n        hash.set(ns, step);\n        new_ -> push(ns);\n        return -1;\n    }\n\n    int next() {\n\n        while (!old -> empty())\n        {\n            State &ref = old -> front();\n            int nstep = hash.get(ref) + 1;\n     //       for (int i = 0; i < mcnt; i++)\n            for (int f = 0; f < n; f++)\n                for (int t = 0; t < n; t++)\n                    for (int fd = 0; fd < 2; fd++)\n                        for (int td = 0; td < 2; td++)\n                            if (trans[f][fd][t][td])\n            {\n                string::size_type len = ref[f].length();\n                for (int k = 0; k <= len; k++)\n                {\n                    State v = ref;\n                 //   v.go(track[i][0], dir[i][0], track[i][1], dir[i][1], k);\n                    v.go(f, fd, t, td, k);\n                    int ret = push(v, nstep);\n                    if (ret != -1) return ret;\n                }\n            }\n            old -> pop();\n        }\n        swap(old, new_);\n        return -1;\n    }\n};\n\nBfs ins[2];\n\nint main() {\n\n\n    for (;;)\n    {\n        mcnt = 0;\n        scanf(\"%d %d\", &n, &m);\n        if (!n && !m) break;\n        memset(trans, 0, sizeof trans);\n        for (int i = 0; i < m; i++)\n        {\n            int f, t;\n            char fd, td;\n            scanf(\"%d%c %d%c\", &f, &fd, &t, &td);\n            fd = fd == 'E';\n            td = td == 'E';\n/*            track[mcnt][0] = f; track[mcnt][1] = t;\n            dir[mcnt][0] = fd; dir[mcnt][1] = td;\n            mcnt++;\n\n            track[mcnt][0] = t; track[mcnt][1] = f;\n            dir[mcnt][0] = td; dir[mcnt][1] = fd;\n            mcnt++;\n            */\n            trans[f][fd][t][td] = true;\n            trans[t][td][f][fd] = true;\n        }\n\n        State root[2];\n        static char buff[20];\n\n        for (int t = 0; t < 2; t++)\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%s\", buff);\n            root[t].push_back(buff);\n            if (root[t][i] == \"-\") root[t][i] = \"\";\n        }\n\n        for (int i = 0; i < 2; i++) \n        {\n            ins[i].init();\n            ins[i].pair = ins + !i;\n            swap(ins[i].old, ins[i].new_);\n            ins[i].push(root[i], 0);\n        }\n        for (int i = 0; i < 2; i++)\n            swap(ins[i].old, ins[i].new_);\n\n        for (int i = 0;; i ^= 1)\n        {\n            int ret = ins[i].next();\n            if (ret != -1) \n            {\n                printf(\"%d\\n\", ret);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(int)(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) v.begin(),v.end()\n//end template\n\n\ntypedef vector<string> state;\n\nint x,y;\nbool G[8][8]; // [8][8] E:0to3,W:4to7\n\nvoid move_str(string &dest , string & src , size_t idx , size_t len , bool to_head){\n    // cout << \"before\" << endl;\n    // cout << \"\\t\" << src <<endl;\n    // cout << \"\\t\" << dest <<endl;\n\n    string mv;\n    mv = src.substr(idx,len);\n\n    if( (idx==0 && to_head) || (idx!=0 && !to_head) ) reverse(all(mv));\n    \n    if(to_head) dest = mv  + dest;\n    else dest = dest + mv;\n    \n    src = src.substr( (idx==0 ? len : 0) , src.size() - len);\n\n    // cout << \"after\" << endl;\n    // cout << \"\\t\" << src <<endl;\n    // cout << \"\\t\" << dest <<endl;\n}\n\n\nvoid rec(vector<set<state>> &result,state now , int dep){\n    // cout << dep << endl;\n    // for(string str : now){\n    //     cout << \"\\t\" << str << endl;\n    // }\n\n    if(result[dep].insert(now).second == false) return;\n\n    \n    if(dep == 3)return ;\n    \n    rep(src,x){\n        rep(i,now[src].size()){\n            rep(dest,x){\n                if(dest != src){\n                    //W to W\n                    if(G[src][dest]){\n                        state next = now;\n                        move_str(next[dest], next[src], 0, i+1 , true);\n                        rec(result, next, dep+1);\n                    }\n                    //E to E\n                    if(G[src+4][dest+4]){\n                        state next = now;\n                        move_str(next[dest], next[src], i , next[src].size()-i , false);\n                        rec(result, next, dep+1);\n                    }\n                    \n                }\n                //W to E\n                if(G[src][dest+4]){\n                    state next = now;\n                    move_str(next[dest], next[src], 0, i+1 , false);\n                    rec(result, next, dep+1);\n                }\n                //E to W\n                if(G[src+4][dest]){\n                    state next = now;\n                    move_str(next[dest], next[src], i , next[src].size()-i , true);\n                    rec(result, next, dep+1);\n                }\n            }\n        }\n    }\n}\n\nint find_ans(vector<set<state>> &from_start , vector<set<state>> from_goal){\n    int ret = 7;\n    rep(st_dep,4){\n        rep(gl_dep,4){\n            for(state ss : from_start[st_dep]){\n                for(state fs : from_goal[gl_dep]){\n                    if(ss == fs){\n                        ret = min(ret , (int)st_dep + (int)gl_dep );\n                    }\n                }\n            }\n        }\n    }\n    return ret;\n}\n\n\n\nbool solve(){\n    rep(i,8){\n        rep(j,8){\n            G[i][j]=false;\n        }\n    }\n    \n    cin >> x >> y;\n    if(x==0 and y==0){\n        return false;\n    }\n    rep(i,y){\n        int p,q;\n        char P,Q;\n        scanf(\"%d%c %d%c\",&p,&P,&q,&Q);\n        //printf(\"%d%c %d%c\\n\",p,P,q,Q);\n        if(P=='E')p+=4;\n        if(Q=='E')q+=4;\n        G[p][q]=true;\n        G[q][p]=true;\n    }\n\n    state start = vector<string>(x);\n    state goal = vector<string>(x);\n\n    rep(i,x){\n        cin >> start[i];\n        if(start[i]==\"-\")start[i]=\"\";\n    }\n    rep(i,x){\n        cin >> goal[i];\n        if(goal[i]==\"-\")goal[i]=\"\";\n    }\n\n    vector< set<state> > from_start(4);\n    vector< set<state> > from_goal(4);\n    rec(from_start,start,0);\n    rec(from_goal,goal,0);\n\n\n    // rep(i,4){\n    //     cout << \"size : \" << from_start[i].size() <<endl;\n    //     // for(state s : from_start[i]){\n    //     //     cout << i <<endl;\n    //     //     for(string str : s){\n    //     //         cout << \"\\t\" << (str.size()==0 ? \"-\" : str) << endl;\n    //     //     }\n    //     // }\n    // }\n\n    \n    int ans = find_ans(from_start, from_goal);\n    assert(ans<=6);\n    cout << ans << endl;\n    return true;\n}\n\n\nint main()\n{\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#define ll long long\n#define inf 1000000009\n#define mod 1000000007\n#define N 4\nusing namespace std;\nint n,m;\nint a[N][N][2][2];\nmap<string,int> vis;\nstring v[N],vv[N];\nvoid decode(string s){\n    int p=0;    \n    for(int i=0;i<n;i++){\n        v[i]=\"\";        \n        for(;s[p]&&s[p]!='#';p++) v[i].append(1,s[p]);\n        p++;    \n    }    \n}\nint cnt;\nint bfs(string start,string end){\n    queue<string> Q;\n    string t;\n    cnt=0;\n    vis.clear();\n    vis[start]=0;    \n    Q.push(start);\n    while(!Q.empty()){\n        if(cnt++>=300000) return 6;\n        string p=Q.front();\n        Q.pop();\n        if(p==end) return vis[end];\n        int d=vis[p];\n        if(d==5) return 6;\n        decode(p);\n        for(int i=0;i<n;i++){\n            if(v[i]==\"\") continue;\n            for(int j=0;j<n;j++){\n                if(i==j) continue;\n                for(int t1=0;t1<2;t1++)\n                    for(int t2=0;t2<2;t2++){\n                        if(!a[i][j][t1][t2]) continue;\n                        for(int k=0;k<v[i].size();k++){\n                            for(int l=0;l<n;l++) vv[l]=v[l];\n                            if(t1){\n                                t=v[i].substr(k,v[i].size());\n                                if(k) vv[i]=v[i].substr(0,k);\n                                else vv[i]=\"\";\n                            }\n                            else{\n                                t=v[i].substr(0,k+1);\n                                if(k<v[i].size()-1) vv[i]=v[i].substr(k+1,v[i].size());\n                                else vv[i]=\"\";\n                            }\n                            if(t1==t2) reverse(t.begin(),t.end());\n                            if(t2) vv[j]=vv[j]+t;\n                            else vv[j]=t+vv[j];                            \n                            t=vv[0];\n                            for(int l=1;l<n;l++) t=t+\"#\"+vv[l];\n                            if(vis.find(t)!=vis.end()) continue;                            \n                            vis[t]=d+1;\n                            if(t==end) return d+1;                            \n                            Q.push(t);\n                        }                       \n                    }\n            }\n        }\n    }\n    return -1;\n}\nint main(){    \n   // freopen(\"in.in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&n,&m),n){\n        memset(a,0,sizeof(a));\n        for(int i=0;i<m;i++){\n            char s[10],e[10];\n            int x,y,t1,t2;\n            scanf(\"%s%s\",s,e);\n            x=s[0]-'0',y=e[0]-'0';\n            t1=(s[1]=='E'),t2=(e[1]=='E');\n            a[x][y][t1][t2]=a[y][x][t2][t1]=1;            \n        }\n        string s=\"\",e=\"\",t;\n        for(int i=0;i<n;i++){\n            cin>>t;\n            if(t==\"-\") t=\"\";\n            if(i) s=s+\"#\";\n            s=s+t;\n        }\n        for(int i=0;i<n;i++){\n            cin>>t;\n            if(t==\"-\") t=\"\";\n            if(i) e=e+\"#\";\n            e=e+t;\n        }\n        //cout<<s<<' '<<e<<endl;\n        printf(\"%d\\n\",bfs(s,e));        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<vector<int> > to;\n\nvoid solve(vector<deque<char> > start, map<vector<deque<char> >, int>& history)\n{\n    set<vector<deque<char> > > curr;\n    curr.insert(start);\n    history[start] = 0;\n\n    for(int a=1; a<=3; ++a){\n        set<vector<deque<char> > > next;\n        while(!curr.empty()){\n            vector<deque<char> > s = *curr.begin();\n            curr.erase(curr.begin());\n\n            for(int i=0; i<2*n; ++i){\n                for(unsigned j=0; j<to[i].size(); ++j){\n                    vector<deque<char> > t = s;\n                    while(!t[i/2].empty()){\n                        char c;\n                        if(i % 2 == 0){\n                            c = t[i/2].front();\n                            t[i/2].pop_front();\n                        }else{\n                            c = t[i/2].back();\n                            t[i/2].pop_back();\n                        }\n\n                        if(to[i][j] % 2 == 0)\n                            t[to[i][j]/2].push_front(c);\n                        else\n                            t[to[i][j]/2].push_back(c);\n\n                        if(history.find(t) == history.end()){\n                            next.insert(t);\n                            history[t] = a;\n                        }\n                    }\n                }\n            }\n        }\n        curr.swap(next);\n    }\n}\n\nint main()\n{\n    for(;;){\n        int m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        to.resize(2*n);\n        for(int i=0; i<m; ++i){\n            string s, t;\n            cin >> s >> t;\n            int a = (s[0] - '0') * 2;\n            int b = (t[0] - '0') * 2;\n            if(s[1] == 'E')\n                ++ a;\n            if(t[1] == 'E')\n                ++ b;\n            to[a].push_back(b);\n            to[b].push_back(a);\n        }\n\n        vector<deque<char> > s(n), t(n);\n        for(int i=0; i<n; ++i){\n            string u;\n            cin >> u;\n            if(u != \"-\")\n                s[i] = deque<char>(u.begin(), u.end());\n        }\n        for(int i=0; i<n; ++i){\n            string u;\n            cin >> u;\n            if(u != \"-\")\n                t[i] = deque<char>(u.begin(), u.end());\n        }\n\n        map<vector<deque<char> >, int> history1, history2;\n        solve(s, history1);\n        solve(t, history2);\n\n        int ret = INT_MAX;\n        map<vector<deque<char> >, int>::iterator it1 = history1.begin();\n        map<vector<deque<char> >, int>::iterator it2 = history2.begin();\n        while(it1 != history1.end() && it2 != history2.end()){\n            if(it1->first == it2->first)\n                ret = min(ret, it1->second + it2->second);\n            if(it1->first < it2->first)\n                ++ it1;\n            else\n                ++ it2;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n;\nvector<vector<int> > to;\n\nvoid solve(vector<string> start, vector<pair<vector<string>, int> >& history)\n{\n    history.push_back(make_pair(start, 0));\n\n    for(int a=0; ; ++a){\n        if(history[a].second == 3)\n            return;\n\n        vector<string> s = history[a].first;\n\n        for(int i=0; i<n*2; ++i){\n            for(unsigned j=0; j<to[i].size(); ++j){\n                vector<string> s = history[a].first;\n                while(!s[i/2].empty()){\n                    char c;\n                    if(i % 2 == 0){\n                        c = s[i/2][0];\n                        s[i/2] = s[i/2].substr(1);\n                    }else{\n                        c = s[i/2][s[i/2].size()-1];\n                        s[i/2] = s[i/2].substr(0, s[i/2].size()-1);\n                    }\n\n                    if(to[i][j] % 2 == 0){\n                        s[to[i][j]/2] = c + s[to[i][j]/2];\n                    }else{\n                        s[to[i][j]/2] += c;\n                    }\n\n                    history.push_back(make_pair(s, history[a].second + 1));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        to.resize(2*n);\n        for(int i=0; i<m; ++i){\n            string s, t;\n            cin >> s >> t;\n            int a = (s[0] - '0') * 2;\n            int b = (t[0] - '0') * 2;\n            if(s[1] == 'E')\n                ++ a;\n            if(t[1] == 'E')\n                ++ b;\n            to[a].push_back(b);\n            to[b].push_back(a);\n        }\n\n        vector<string> s(n), t(n);\n        for(int i=0; i<n; ++i){\n            cin >> s[i];\n            if(s[i] == \"-\")\n                s[i] = \"\";\n        }\n        for(int i=0; i<n; ++i){\n            cin >> t[i];\n            if(t[i] == \"-\")\n                t[i] = \"\";\n        }\n\n        vector<pair<vector<string>, int> > history1, history2;\n        solve(s, history1);\n        solve(t, history2);\n\n        int ret = INT_MAX;\n        sort(history1.begin(), history1.end());\n        sort(history2.begin(), history2.end());\n        unsigned i = 0;\n        unsigned j = 0;\n        while(i < history1.size() && j < history2.size()){\n            if(history1[i].first == history2[j].first)\n                ret = min(ret, history1[i].second + history2[j].second);\n            if(history1[i].first < history2[j].first)\n                ++ i;\n            else\n                ++ j;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <cstdint>\n#include <algorithm>\n#include <iterator>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nuint64_t pack(vector<deque<char> > const & s) {\n    uint64_t t = 0;\n    repeat (i, s.size()) {\n        t *= 27;\n        for (char c : s[i]) {\n            t *= 27;\n            t += c - 'a' + 1;\n        }\n    }\n    return t;\n}\nenum we_t { W, E };\ntemplate <typename It>\nvoid step(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, It it) {\n    int x = s.size();\n    repeat (i,x) {\n        repeat_from (n,1,s[i].size()) {\n            for (we_t p : { W, E }) {\n                auto v = make_pair(i,p);\n                for (auto w : g.at(v)) {\n                    int j = w.first;\n                    vector<deque<char> > t = s;\n                    repeat (k,n) {\n                        char c;\n                        if (v.second == W) {\n                            c = t[i].front();\n                            t[i].pop_front();\n                        } else {\n                            c = t[i].back();\n                            t[i].pop_back();\n                        }\n                        if (w.second == W) {\n                            t[j].push_front(c);\n                        } else {\n                            t[j].push_back(c);\n                        }\n                    }\n                    *(it ++) = t;\n                }\n            }\n        }\n    }\n}\nunordered_map<uint64_t,int> steps(vector<deque<char> > const & s, map<pair<int,we_t>,vector<pair<int,we_t> > > const & g, int n) {\n    unordered_map<uint64_t,int> ms;\n    ms[pack(s)] = 0;\n    vector<vector<deque<char> > > vs;\n    vs.push_back(s);\n    repeat (i,n) {\n        vector<vector<deque<char> > > ws;\n        for (auto it : vs) {\n            step(it, g, back_inserter(ws));\n        }\n        vs.clear();\n        for (auto it : ws) {\n            uint64_t t = pack(it);\n            if (not ms.count(t)) {\n                ms[t] = i+1;\n                vs.push_back(it);\n            }\n        }\n    }\n    return ms;\n}\nint main() {\n    while (true) {\n        int x, y; cin >> x >> y;\n        if (x == 0 and y == 0) break;\n        map<pair<int,we_t>,vector<pair<int,we_t> > > g;\n        repeat (i,x) for (we_t j : { W, E }) g[make_pair(i,j)];\n        repeat (i,y) {\n            char p, P, q, Q; cin >> p >> P >> q >> Q;\n            auto a = make_pair(p - '0', P == 'W' ? W : E);\n            auto b = make_pair(q - '0', Q == 'W' ? W : E);\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        vector<deque<char> > s(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); s[i] = deque<char>(a.begin(), a.end()); }\n        vector<deque<char> > t(x); repeat (i,x) { string a; cin >> a; if (a == \"-\") a.clear(); t[i] = deque<char>(a.begin(), a.end()); }\n        unordered_map<uint64_t,int> ms = steps(s, g, 2);\n        unordered_map<uint64_t,int> mt = steps(t, g, 3);\n        int result = 6;\n        for (auto it : ms) {\n            if (mt.count(it.first)) {\n                result = min(result, it.second + mt[it.first]);\n            }\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntemplate <class Key, class Value>\nstruct HashMap {\n\n    static const int MAXH = 999983;\n    struct Edge {\n        Key to;\n        Value v;\n        Edge *next;\n    } *head[MAXH];\n\n    void set(const Key &key, const Value &value) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        Edge *p = new Edge;\n        p -> to = key;\n        p -> v = value;\n        p -> next = head[hv];\n        head[hv] = p;\n    }\n\n    const Value &get(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return p -> v;\n    }\n\n    bool exist(const Key &key) {\n\n        int hv = (unsigned int)key.hash_value() % MAXH;\n        for (Edge *p = head[hv]; p; p = p -> next)\n            if (p -> to == key) return true;\n        return false;\n    }\n\n    void clear() {\n\n        for (int i = 0; i < MAXH; i++)\n        {\n            for (Edge *p = head[i], *np; p; p = np)\n            {\n                np = p -> next;\n                delete p;\n            }\n            head[i] = NULL;\n        }\n    }\n};\n\nconst int MAXN = 4;\nconst int MAXM = MAXN * 2 * MAXN * 2 * 2;\nint n, m, mcnt;\nint track[MAXM][2], dir[MAXM][2];\n\nstruct State {\n\n    vector<string> s;\n\n    string &operator[](int x) {\n\n        return s[x];\n    }\n\n    int hash_value() const {\n\n        unsigned int res = 0, res0;\n        for (int i = 0; i < n; i++)\n        {\n            res0 = 0;\n            const string &ref = s[i];\n            string::size_type len = ref.length();\n            for (int j = 0; j < len; j++)\n                res0 = res0 * 131 + ref[j];\n            res = res * 13131 + res0;\n        }\n        return res;\n    }\n\n    bool operator==(const State &b) const {\n\n        for (int i = 0; i < n; i++)\n            if (s[i] != b.s[i]) return false;\n        return true;\n    }\n\n    void go(int n0, int d0, int n1, int d1, int k) {\n\n        string out = s[n0].substr(0, k);\n        s[n0] = s[n0].erase(0, k);\n        if (d0) std::swap(out, s[n0]);\n        if (d0 == d1) reverse(out.begin(), out.end());\n        if (d1) s[n1] += out;\n        else s[n1] = out + s[n1];\n    }\n\n    void push_back(const string &b) {\n\n        s.push_back(b);\n    }\n};\n\nstruct Bfs {\n\n    queue<State> q[2], *old, *new_;\n    HashMap<State, int> hash;\n    int head, tail;\n    Bfs *pair;\n\n    void init() {\n\n        hash.clear();\n        for (int i = 0; i < 2; i++)\n            while (!q[i].empty()) q[i].pop();\n        old = q;\n        new_ = q + 1;\n    }\n\n    int push(const State &ns, int step) {\n\n        if (hash.exist(ns)) return -1;\n        if (pair -> hash.exist(ns))\n        {\n            int t = pair -> hash.get(ns);\n            return step + t; \n        }\n        hash.set(ns, step);\n        new_ -> push(ns);\n        return -1;\n    }\n\n    int next() {\n\n        while (!old -> empty())\n        {\n            State &ref = old -> front();\n            int nstep = hash.get(ref) + 1;\n            for (int i = 0; i < mcnt; i++)\n            {\n                string::size_type len = ref[track[i][0]].length();\n                for (int k = 0; k <= len; k++)\n                {\n                    State v = ref;\n                    v.go(track[i][0], dir[i][0], track[i][1], dir[i][1], k);\n                    int ret = push(v, nstep);\n                    if (ret != -1) return ret;\n                }\n            }\n            old -> pop();\n        }\n        swap(old, new_);\n        return -1;\n    }\n};\n\nBfs ins[2];\n\nint main() {\n\n\n    for (;;)\n    {\n        mcnt = 0;\n        scanf(\"%d %d\", &n, &m);\n        if (!n && !m) break;\n        for (int i = 0; i < m; i++)\n        {\n            int f, t;\n            char fd, td;\n            scanf(\"%d%c %d%c\", &f, &fd, &t, &td);\n            fd = fd == 'E';\n            td = td == 'E';\n            track[mcnt][0] = f; track[mcnt][1] = t;\n            dir[mcnt][0] = fd; dir[mcnt][1] = td;\n            mcnt++;\n\n            track[mcnt][0] = t; track[mcnt][1] = f;\n            dir[mcnt][0] = td; dir[mcnt][1] = fd;\n            mcnt++;\n        }\n\n        State root[2];\n        static char buff[20];\n\n        for (int t = 0; t < 2; t++)\n        for (int i = 0; i < n; i++)\n        {\n            scanf(\"%s\", buff);\n            root[t].push_back(buff);\n            if (root[t][i] == \"-\") root[t][i] = \"\";\n        }\n\n        for (int i = 0; i < 2; i++) \n        {\n            ins[i].init();\n            ins[i].pair = ins + !i;\n            swap(ins[i].old, ins[i].new_);\n            ins[i].push(root[i], 0);\n        }\n        for (int i = 0; i < 2; i++)\n            swap(ins[i].old, ins[i].new_);\n\n        for (int i = 0;; i ^= 1)\n        {\n            int ret = ins[i].next();\n            if (ret != -1) \n            {\n                printf(\"%d\\n\", ret);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nvector<P> t[4][2];\nvector<string> start, end;\nmap<string, int> half;\n\nint ans;\n\nstring format(const vector<string> &vec){\n  string res = \"\";\n  for(int i = 0; i < n; i++){\n    if(i != 0) res += \",\";\n    res += vec[i];\n  }\n  return res;\n}\n\nvoid enumerateHalf(int step, vector<string> vec){\n  string format_str = format(vec);\n  map<string,int>::iterator tmp_iter = half.find(format(vec));\n  if(tmp_iter == half.end()) half[format_str] = step;\n  else                       tmp_iter->second = min(tmp_iter->second, step);\n\n  if(step == 3) return;\n\n  for(int from = 0; from < n; from++){\n    if(vec[from].size() == 0) continue;\n\n    for(int cut = 0; cut < vec[from].size(); cut++){\n      string cut_str[2] = {\n        vec[from].substr(0, cut),\n        vec[from].substr(cut)\n      };\n      string rev_str[2] = {cut_str[0], cut_str[1]};\n      reverse(rev_str[0].begin(), rev_str[0].end());\n      reverse(rev_str[1].begin(), rev_str[1].end());\n\n      for(int from_dir = 0; from_dir < 2; from_dir++){\n        if(cut_str[from_dir].size() == 0) continue;\n\n        for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n          int to = t[from][from_dir][to_idx].first;\n          int to_dir = t[from][from_dir][to_idx].second;\n          vector<string> nvec = vec;\n\n          if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n          else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n          else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n          else                                  nvec[to] += rev_str[from_dir];\n\n          nvec[from] = cut_str[!from_dir];\n\n          enumerateHalf(step + 1, nvec);\n        }\n      }\n    }\n  }\n}\n\nvoid rec(int step, vector<string> vec){\n  map<string,int>::iterator tmp_iter = half.find(format(vec));\n  if(tmp_iter != half.end()){\n    ans = min(ans, step + tmp_iter->second);\n    return;\n  }\n  if(step == 3) return;\n\n  for(int from = 0; from < n; from++){\n    if(vec[from].size() == 0) continue;\n\n    for(int cut = 0; cut < vec[from].size(); cut++){\n      string cut_str[2] = {\n        vec[from].substr(0, cut),\n        vec[from].substr(cut)\n      };\n      string rev_str[2] = {cut_str[0], cut_str[1]};\n      reverse(rev_str[0].begin(), rev_str[0].end());\n      reverse(rev_str[1].begin(), rev_str[1].end());\n\n      for(int from_dir = 0; from_dir < 2; from_dir++){\n        if(cut_str[from_dir].size() == 0) continue;\n\n        for(int to_idx = 0; to_idx < t[from][from_dir].size(); to_idx++){\n          int to = t[from][from_dir][to_idx].first;\n          int to_dir = t[from][from_dir][to_idx].second;\n          vector<string> nvec = vec;\n\n          if     (from_dir == 0 && to_dir == 0) nvec[to] = rev_str[from_dir] + nvec[to];\n          else if(from_dir == 0 && to_dir == 1) nvec[to] += cut_str[from_dir];\n          else if(from_dir == 1 && to_dir == 0) nvec[to] = cut_str[from_dir] + nvec[to];\n          else                                  nvec[to] += rev_str[from_dir];\n\n          nvec[from] = cut_str[!from_dir];\n\n          rec(step + 1, nvec);\n        }\n      }\n    }\n  }\n}\n\nvoid solve(){\n  half.clear();\n  enumerateHalf(0, start);\n\n  ans = INT_MAX;\n  rec(0, end);\n  cout << ans << endl;\n}\n\nint main(){\n  int m;\n\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < 4; i++){\n      for(int j = 0; j < 2; j++){\n        t[i][j].clear();\n      }\n    }\n\n    for(int i = 0; i < m; i++){\n      string from, to;\n      cin >> from >> to;\n\n      int from_line = from[0] - '0';\n      int from_dir = (from[1] == 'W' ? 0 : 1);\n      int to_line = to[0] - '0';\n      int to_dir = (to[1] == 'W' ? 0 : 1);\n\n      t[from_line][from_dir].push_back(P(to_line, to_dir));\n      t[to_line][to_dir].push_back(P(from_line, from_dir));\n    }\n\n    start.clear();\n    end.clear();\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      start.push_back(s);\n    }\n\n    for(int i = 0; i < n; i++){\n      string s;\n      cin >> s;\n      if(s == \"-\") s = \"\";\n      end.push_back(s);\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 sample matched RE\n\t//1510 stop\n\t//TODO substring\n\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < x;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//if(now.step == 3) continue;;\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tString a = \"\";\n\t\tfor(int i = 0; i < a.length(); i++){\n\t\t\tSystem.out.println(a.substring(0, i + 1));\n\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 stop\n\t//TODO substring\n\t\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\t\t\t\t\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < 3;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//if(now.step == 3) continue;;\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\t\t\t\t\t\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num1].length(); j++){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 1; j <= now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Organize Your Train\npublic class Main{\n\n\tboolean[][] adj;\n\tint x, y;\n\tMap<String, Integer> ref, ref2;\n\n\tint trans(char[] s){\n\t\tint res = s[0]-'0';\n\t\tif(s[1]=='E')res+=x;\n\t\treturn res;\n\t}\n\n\tString get(String[] s){\n\t\tString res = \"\";\n\t\tfor(int i=0;i<x;i++)res+=s[i]+\",\";\n\t\treturn res;\n\t}\n\n\tvoid reg(Map<String, Integer> m, String s, List<String> l, int step){\n\t\tif(m.containsKey(s))return;\n\t\tm.put(s, step);\n\t\tl.add(s);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tx = sc.nextInt(); y = sc.nextInt();\n\t\t\tif((x|y)==0)break;\n\t\t\tadj = new boolean[2*x][2*x];\n\t\t\twhile(y--!=0){\n\t\t\t\tint s = trans(sc.next().toCharArray()), t = trans(sc.next().toCharArray());\n\t\t\t\tadj[s][t] = adj[t][s] = true;\n\t\t\t}\n\t\t\tString start = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tstart+=s+\",\";\n\t\t\t}\n\t\t\tString goal = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tgoal+=s+\",\";\n\t\t\t}\n\t\t\tref = new HashMap<String, Integer>(); ref2 = new HashMap<String, Integer>();\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tref.put(start, 0);\n\t\t\tlist.add(start);\n\t\t\tint step = 1;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=0;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tstep = 1;\n\t\t\tref2.put(goal, 0);\n\t\t\tlist = new ArrayList<String>();\n\t\t\tlist.add(goal);\n\t\t\tint min = 6;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tif(ref.containsKey(v)){\n\t\t\t\t\t\tmin = Math.min(min, ref.get(v)+ref2.get(v));\n\t\t\t\t\t}\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=0;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 sample matched RE\n\t//1510 stop\n\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < x;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.step + 1 == 3) break;\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tif(ans!= -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\tLinkedList<C> open2 = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist2 = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist2[i] = new StringBuilder(goal[i]);\n\t\t\t}\n\t\t\topen2.add(new C(0, openlist2));\n\t\t\tHashMap<String , Integer> close2 = new HashMap<String, Integer>();\n\t\t\tclose2.put(tostr(openlist2), 0);\n\t\t\twhile(! open2.isEmpty()){\n\t\t\t\tC now = open2.removeFirst();\n\n\t\t\t\t//\n\t\t\t\tString nowstr = tostr(now.list);\n\t\t\t\tif(close.containsKey(nowstr)){\n\t\t\t\t\tans = now.step + close.get(nowstr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tString a = \"\";\n\t\tfor(int i = 0; i < a.length(); i++){\n\t\t\tSystem.out.println(a.substring(0, i + 1));\n\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Organize Your Train\npublic class Main{\n\n\tboolean[][] adj;\n\tint x, y;\n\tMap<String, Integer> ref, ref2;\n\n\n\tint trans(char[] s){\n\t\tint res = s[0]-'0';\n\t\tif(s[1]=='E')res+=x;\n\t\treturn res;\n\t}\n\n\tString get(String[] s){\n\t\tString res = \"\";\n\t\tfor(int i=0;i<x;i++)res+=s[i]+\",\";\n\t\treturn res;\n\t}\n\n\tvoid reg(Map<String, Integer> m, String s, List<String> l, int step){\n\t\tif(m.containsKey(s))return;\n\t\tm.put(s, step);\n\t\tl.add(s);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tx = sc.nextInt(); y = sc.nextInt();\n\t\t\tif((x|y)==0)break;\n\t\t\tadj = new boolean[2*x][2*x];\n\t\t\twhile(y--!=0){\n\t\t\t\tint s = trans(sc.next().toCharArray()), t = trans(sc.next().toCharArray());\n\t\t\t\tadj[s][t] = adj[t][s] = true;\n\t\t\t}\n\t\t\tString start = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tstart+=s+\",\";\n\t\t\t}\n\t\t\tString goal = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tgoal+=s+\",\";\n\t\t\t}\n\t\t\tref = new HashMap<String, Integer>(); ref2 = new HashMap<String, Integer>();\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tref.put(start, 0);\n\t\t\tlist.add(start);\n\t\t\tint step = 1;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tif(ref.containsKey(goal)){\n\t\t\t\tSystem.out.println(ref.get(goal));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstep = 1;\n\t\t\tref2.put(goal, 0);\n\t\t\tlist = new ArrayList<String>();\n\t\t\tlist.add(goal);\n\t\t\tint min = 6;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tif(ref.containsKey(v)){\n\t\t\t\t\t\tmin = Math.min(min, ref.get(v)+ref2.get(v));\n\t\t\t\t\t}\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Organize Your Train\npublic class Main{\n\n\tboolean[][] adj;\n\tint x, y;\n\tMap<String, Integer> ref, ref2;\n\n\tint trans(char[] s){\n\t\tint res = s[0]-'0';\n\t\tif(s[1]=='E')res+=x;\n\t\treturn res;\n\t}\n\n\tString get(String[] s){\n\t\tString res = \"\";\n\t\tfor(int i=0;i<x;i++)res+=s[i]+\",\";\n\t\treturn res;\n\t}\n\n\tvoid reg(Map<String, Integer> m, String s, List<String> l, int step){\n\t\tif(m.containsKey(s))return;\n\t\tm.put(s, step);\n\t\tl.add(s);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tx = sc.nextInt(); y = sc.nextInt();\n\t\t\tif((x|y)==0)break;\n\t\t\tadj = new boolean[2*x][2*x];\n\t\t\twhile(y--!=0){\n\t\t\t\tint s = trans(sc.next().toCharArray()), t = trans(sc.next().toCharArray());\n\t\t\t\tadj[s][t] = adj[t][s] = true;\n\t\t\t}\n\t\t\tString start = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tstart+=s+\",\";\n\t\t\t}\n\t\t\tString goal = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tgoal+=s+\",\";\n\t\t\t}\n\t\t\tref = new HashMap<String, Integer>(); ref2 = new HashMap<String, Integer>();\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tref.put(start, 0);\n\t\t\tlist.add(start);\n\t\t\tint step = 1;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tif(ref.containsKey(goal)){\n\t\t\t\tSystem.out.println(ref.get(goal));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstep = 1;\n\t\t\tref2.put(goal, 0);\n\t\t\tlist = new ArrayList<String>();\n\t\t\tlist.add(goal);\n\t\t\tint min = 6;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tif(ref.containsKey(v)){\n\t\t\t\t\t\tmin = Math.min(min, ref.get(v)+ref2.get(v));\n\t\t\t\t\t}\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n//\tvoid debug(Object...o){\n//\t\tSystem.out.println(Arrays.deepToString(o));\n//\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Organize Your Train\npublic class Main{\n\n\tboolean[][] adj;\n\tint x, y;\n\tMap<String, Integer> ref, ref2;\n\n\tint trans(char[] s){\n\t\tint res = s[0]-'0';\n\t\tif(s[1]=='E')res+=x;\n\t\treturn res;\n\t}\n\n\tString get(String[] s){\n\t\tString res = \"\";\n\t\tfor(int i=0;i<x;i++)res+=s[i]+\",\";\n\t\treturn res;\n\t}\n\n\tvoid reg(Map<String, Integer> m, String s, List<String> l, int step){\n\t\tif(m.containsKey(s))return;\n\t\tm.put(s, step);\n\t\tl.add(s);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tx = sc.nextInt(); y = sc.nextInt();\n\t\t\tif((x|y)==0)break;\n\t\t\tadj = new boolean[2*x][2*x];\n\t\t\twhile(y--!=0){\n\t\t\t\tint s = trans(sc.next().toCharArray()), t = trans(sc.next().toCharArray());\n\t\t\t\tadj[s][t] = adj[t][s] = true;\n\t\t\t}\n\t\t\tString start = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tstart+=s+\",\";\n\t\t\t}\n\t\t\tString goal = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tgoal+=s+\",\";\n\t\t\t}\n\t\t\tref = new HashMap<String, Integer>(); ref2 = new HashMap<String, Integer>();\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tref.put(start, 0);\n\t\t\tlist.add(start);\n\t\t\tint step = 1;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n//\t\t\tif(ref.containsKey(goal)){\n//\t\t\t\tSystem.out.println(ref.get(goal));\n//\t\t\t\tcontinue;\n//\t\t\t}\n\t\t\tstep = 1;\n\t\t\tref2.put(goal, 0);\n\t\t\tlist = new ArrayList<String>();\n\t\t\tlist.add(goal);\n\t\t\tint min = 6;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tif(ref.containsKey(v)){\n//\t\t\t\t\t\tSystem.out.println(\"V:\"+v+\" Ref1:\"+ref.get(v)+\" Ref2:\"+ref2.get(v));\n\t\t\t\t\t\tmin = Math.min(min, ref.get(v)+ref2.get(v));\n\t\t\t\t\t}\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 sample matched RE\n\t//1510 stop\n\t//0150 restart\n\t//0206 TLE\n\t//0228 MLE\n\t//0230 MLE modified continue to break\n\t//0233 MLE modified presentation error\n\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < x;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.step == 3) break;\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tif(ans!= -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\tLinkedList<C> open2 = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist2 = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist2[i] = new StringBuilder(goal[i]);\n\t\t\t}\n\t\t\topen2.add(new C(0, openlist2));\n\t\t\tHashMap<String , Integer> close2 = new HashMap<String, Integer>();\n\t\t\tclose2.put(tostr(openlist2), 0);\n\t\t\twhile(! open2.isEmpty()){\n\t\t\t\tC now = open2.removeFirst();\n\n\t\t\t\t//\n\t\t\t\tString nowstr = tostr(now.list);\n\t\t\t\tif(close.containsKey(nowstr)){\n\t\t\t\t\tans = now.step + close.get(nowstr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\t\t\t\t\tboolean flg = false;\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tString a = \"\";\n\t\tfor(int i = 0; i < a.length(); i++){\n\t\t\tSystem.out.println(a.substring(0, i + 1));\n\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 sample matched RE\n\t//1510 stop\n\t// restart\n\t//0206 TLE\n\t//0228 MLE\n\t//0230 MLE modified continue to break\n\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < x;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.step == 3) break;\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tif(ans!= -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\tLinkedList<C> open2 = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist2 = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist2[i] = new StringBuilder(goal[i]);\n\t\t\t}\n\t\t\topen2.add(new C(0, openlist2));\n\t\t\tHashMap<String , Integer> close2 = new HashMap<String, Integer>();\n\t\t\tclose2.put(tostr(openlist2), 0);\n\t\t\twhile(! open2.isEmpty()){\n\t\t\t\tC now = open2.removeFirst();\n\n\t\t\t\t//\n\t\t\t\tString nowstr = tostr(now.list);\n\t\t\t\tif(close.containsKey(nowstr)){\n\t\t\t\t\tans = now.step + close.get(nowstr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tString a = \"\";\n\t\tfor(int i = 0; i < a.length(); i++){\n\t\t\tSystem.out.println(a.substring(0, i + 1));\n\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 sample matched RE\n\t//1510 stop\n\t//TODO substring\n\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < x;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.step == 3) continue;\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tif(ans!= -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\tLinkedList<C> open2 = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist2 = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist2[i] = new StringBuilder(goal[i]);\n\t\t\t}\n\t\t\topen2.add(new C(0, openlist2));\n\t\t\tHashMap<String , Integer> close2 = new HashMap<String, Integer>();\n\t\t\tclose2.put(tostr(openlist2), 0);\n\t\t\twhile(! open2.isEmpty()){\n\t\t\t\tC now = open2.removeFirst();\n\n\t\t\t\t//\n\t\t\t\tString nowstr = tostr(now.list);\n\t\t\t\tif(close.containsKey(nowstr)){\n\t\t\t\t\tans = now.step + close.get(nowstr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tString a = \"\";\n\t\tfor(int i = 0; i < a.length(); i++){\n\t\t\tSystem.out.println(a.substring(0, i + 1));\n\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\npublic class Main {\n\t//1330 start\n\t//1430 cording end\n\t//1510 sample matched RE\n\t//1510 stop\n\t//0150 restart\n\t//0206 TLE\n\t//0228 MLE\n\t//0230 MLE modified continue to break\n\t//0233 MLE modified presentation error\n\t//0251 WA modi goal process\n\n\tclass C{\n\t\tint step;\n\t\tStringBuilder [] list;\n\t\tpublic C(int step, StringBuilder[] list) {\n\t\t\tthis.step = step;\n\t\t\tthis.list = list;\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc =new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt(), y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\tchar [][] data = new char[y][4];\n\t\t\tfor(int i = 0 ; i < y; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i][0] = s.charAt(0);\n\t\t\t\tdata[i][1] = s.charAt(1);\n\t\t\t\ts = sc.next();\n\n\t\t\t\tdata[i][2] = s.charAt(0);\n\t\t\t\tdata[i][3] = s.charAt(1);\n\t\t\t}\n\t\t\tString [] start = new String[x];\n\t\t\tString [] goal = new String[x];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tfor(int j = 0; j < x;j++){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tstart[j] = sc.next();\n\t\t\t\t\t\tif(start[j].equals(\"-\")){\n\t\t\t\t\t\t\tstart[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tgoal[j] = sc.next();\n\t\t\t\t\t\tif(goal[j].equals(\"-\")){\n\t\t\t\t\t\t\tgoal[j] = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist[i] = new StringBuilder(start[i]);\n\t\t\t}\n\t\t\topen.add(new C(0, openlist));\n\t\t\tHashMap<String , Integer> close = new HashMap<String, Integer>();\n\t\t\tclose.put(tostr(openlist), 0);\n\t\t\tString goalstr = tostr2(goal);\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.removeFirst();\n\t\t\t\t//System.out.println(\"step = \" + now.step);\n\t\t\t\t//goal\n\t\t\t\tif(tostr(now.list).equals(goalstr)){\n\t\t\t\t\tans = now.step;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(now.step == 3) break;\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\t\t\t\t\tboolean flg = false;\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close.containsKey(nextstr) && close.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//goal\n\t\t\t\t\t\t\tif(nextstr.equals(goalstr)){\n\t\t\t\t\t\t\t\tans = now.step + 1;\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\topen.clear();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tif(ans!= -1){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\tLinkedList<C> open2 = new LinkedList<C>();\n\t\t\tStringBuilder [] openlist2 = new StringBuilder[x];\n\t\t\tfor(int i = 0; i < x; i++){\n\t\t\t\topenlist2[i] = new StringBuilder(goal[i]);\n\t\t\t}\n\t\t\topen2.add(new C(0, openlist2));\n\t\t\tHashMap<String , Integer> close2 = new HashMap<String, Integer>();\n\t\t\tclose2.put(tostr(openlist2), 0);\n\t\t\twhile(! open2.isEmpty()){\n\t\t\t\tC now = open2.removeFirst();\n\n\t\t\t\tfor(int i = 0; i < y; i++){\n\t\t\t\t\tint num1 = data[i][0] - '0';\n\t\t\t\t\tint num2 = data[i][2] - '0';\n\t\t\t\t\tchar op1 = data[i][1];\n\t\t\t\t\tchar op2 = data[i][3];\n\t\t\t\t\tboolean flg = false;\n\n\t\t\t\t\tif(op1 == 'W' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j + 1 );\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num1].insert(0, move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'W' && op2 == 'E'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(0, j + 1);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(0, j + 1);\n\t\t\t\t\t\t\twork[num2].append(temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j =0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j - 1, len);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].insert(0, temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t}\n\t\t\t\t\telse if(op1 == 'E' && op2 == 'W'){\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j - 1, len);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num2].insert(0,temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(0, j+1);\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(0, j+1);\n\t\t\t\t\t\t\twork[num1].append(temp);\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// E, E\n\t\t\t\t\t\t//from to\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num1].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num1].length();\n\t\t\t\t\t\t\tString temp = now.list[num1].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num1].delete(len-j-1, len);\n\t\t\t\t\t\t\twork[num2].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\n\t\t\t\t\t\t//to from\n\t\t\t\t\t\tfor(int j = 0; j < now.list[num2].length(); j++){\n\t\t\t\t\t\t\tint len = now.list[num2].length();\n\t\t\t\t\t\t\tString temp = now.list[num2].substring(len - j-1, len);\n\t\t\t\t\t\t\tStringBuilder move = new StringBuilder(temp);\n\t\t\t\t\t\t\tmove.reverse();\n\n\t\t\t\t\t\t\tStringBuilder [] work = deepcopy(now.list);\n\t\t\t\t\t\t\twork[num2].delete(len-j - 1, len);\n\t\t\t\t\t\t\twork[num1].append(move.toString());\n\t\t\t\t\t\t\tString nextstr = tostr(work);\n\t\t\t\t\t\t\tif(close2.containsKey(nextstr) && close2.get(nextstr) <= now.step + 1){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tif(close.containsKey(nextstr)){\n\t\t\t\t\t\t\t\tans = now.step + close.get(nextstr) + 1;\n\t\t\t\t\t\t\t\topen2.clear();\n\t\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\topen2.add(new C(now.step + 1, work));\n\t\t\t\t\t\t\tclose2.put(nextstr, now.step + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flg) break;\n\t\t\t\t\t} //ifend\n\t\t\t\t} //end i\n\t\t\t}//end while\n\n\t\t\t//\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate StringBuilder[] deepcopy(StringBuilder[] list) {\n\t\tStringBuilder [] sb = new StringBuilder[list.length];\n\t\tfor(int i = 0; i < list.length; i++){\n\t\t\tsb[i] = new StringBuilder(list[i].toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\tprivate String tostr2(String[] goal) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < goal.length; i++){\n\t\t\tsb.append(goal[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String tostr(StringBuilder[] openlist) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < openlist.length; i++){\n\t\t\tsb.append(openlist[i].toString() + \".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Organize Your Train\npublic class Main{\n\n\tboolean[][] adj;\n\tint x, y;\n\tMap<String, Integer> ref, ref2;\n\n\n\tint trans(char[] s){\n\t\tint res = s[0]-'0';\n\t\tif(s[1]=='E')res+=x;\n\t\treturn res;\n\t}\n\n\tString get(String[] s){\n\t\tString res = \"\";\n\t\tfor(int i=0;i<x;i++)res+=s[i]+\",\";\n\t\treturn res;\n\t}\n\n\tvoid reg(Map<String, Integer> m, String s, List<String> l, int step){\n\t\tif(m.containsKey(s))return;\n\t\tm.put(s, step);\n\t\tl.add(s);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tx = sc.nextInt(); y = sc.nextInt();\n\t\t\tif((x|y)==0)break;\n\t\t\tadj = new boolean[2*x][2*x];\n\t\t\twhile(y--!=0){\n\t\t\t\tint s = trans(sc.next().toCharArray()), t = trans(sc.next().toCharArray());\n\t\t\t\tadj[s][t] = adj[t][s] = true;\n\t\t\t}\n\t\t\tString start = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tstart+=s+\",\";\n\t\t\t}\n\t\t\tString goal = \"\";\n\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tgoal+=s+\",\";\n\t\t\t}\n\t\t\tref = new HashMap<String, Integer>(); ref2 = new HashMap<String, Integer>();\n\t\t\tList<String> list = new ArrayList<String>();\n\t\t\tref.put(start, 0);\n\t\t\tlist.add(start);\n\t\t\tint step = 1;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tif(ref.containsKey(goal)){\n\t\t\t\tSystem.out.println(ref.get(goal));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstep = 1;\n\t\t\tref2.put(goal, 0);\n\t\t\tlist = new ArrayList<String>();\n\t\t\tlist.add(goal);\n\t\t\tint min = 6;\n\t\t\twhile(!list.isEmpty()&&step<=3){\n\t\t\t\tList<String> next = new ArrayList<String>();\n\t\t\t\tfor(String v:list){\n\t\t\t\t\tif(ref.containsKey(v)){\n\t\t\t\t\t\tmin = Math.min(min, ref.get(v)+ref2.get(v));\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tString[] s = v.split(\",\");\n\t\t\t\t\tfor(int i=0;i<x;i++){\n\t\t\t\t\t\tif(\"-\".equals(s[i]))continue;;\n\t\t\t\t\t\tString pre = s[i];\n\t\t\t\t\t\tfor(int j=1;j<=s[i].length();j++){\n\t\t\t\t\t\t\tString former = s[i].substring(0, j);\n\t\t\t\t\t\t\tString later = s[i].substring(j);\n\t\t\t\t\t\t\tStringBuffer sb = new StringBuffer(former);\n\t\t\t\t\t\t\tString frev = sb.reverse().toString();\n\t\t\t\t\t\t\tsb = new StringBuffer(later);\n\t\t\t\t\t\t\tString lrev = sb.reverse().toString();\n\t\t\t\t\t\t\t//move former\n\t\t\t\t\t\t\tif(former.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = later.length()>0?later:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?frev:(frev+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?former:(s[k-x]+former);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//move later\n\t\t\t\t\t\t\tif(later.length()>0){\n\t\t\t\t\t\t\t\tfor(int k=0;k<2*x;k++){\n\t\t\t\t\t\t\t\t\tif(!adj[i+x][k])continue;\n\t\t\t\t\t\t\t\t\ts[i] = former.length()>0?former:\"-\";\n\t\t\t\t\t\t\t\t\tif(k<x){\n\t\t\t\t\t\t\t\t\t\tString preK = s[k];\n\t\t\t\t\t\t\t\t\t\ts[k] = \"-\".equals(s[k])?later:(later+s[k]);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\t\tString preK = s[k-x];\n\t\t\t\t\t\t\t\t\t\ts[k-x] = \"-\".equals(s[k-x])?lrev:(s[k-x]+lrev);\n\t\t\t\t\t\t\t\t\t\tString res = get(s);\n\t\t\t\t\t\t\t\t\t\treg(ref2, res, next, step);\n\t\t\t\t\t\t\t\t\t\ts[k-x] = preK;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts[i] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t\tlist = next;\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_D = 6\n\nWEST = 0\nEAST = 1\n\nD_FW = 0\nD_BW = 1\n\nEW2D = { 'W' => WEST, 'E' => EAST }\n\n### main\n\nloop do\n  x, y = gets.split.map(&:to_i)\n  break if (x | y) == 0\n\n  x2 = x * 2\n  \n  edges = x2.times.map{x2.times.map{nil}}\n  nbrs = x2.times.map{[]}\n  y.times do\n    pis, qis = gets.strip.split\n    pi = (pis[0].to_i << 1) + EW2D[pis[1]]\n    qi = (qis[0].to_i << 1) + EW2D[qis[1]]\n    edges[pi][qi] = edges[qi][pi] = true\n    nbrs[pi] << qi\n    nbrs[qi] << pi\n  end\n  #p edges\n\n  st = []\n  x.times do\n    tr = gets.strip\n    st << (tr == '-' ? '' : tr)\n  end\n  #p st\n\n  gl = []\n  x.times do\n    tr = gets.strip\n    gl << (tr == '-' ? '' : tr)\n  end\n  #p gl\n\n  dists = {}\n  dists[st] = 1\n  dists[gl] = -1\n  q = [[st, D_FW], [gl, D_BW]]\n\n  min_d = nil\n  \n  while ! q.empty?\n    u, ufb = q.shift\n    #p [dists[u], ud, u]\n\n    nvd = dists[u] + (ufb == D_FW ? 1 : -1) \n\n    for i in (0...x)\n      tri = u[i]\n      next if tri == ''\n\n      uiw = i * 2 + WEST\n      uie = i * 2 + EAST\n      \n      for j in (0..tri.length)\n        triw = tri[0...j]\n        trie = tri[j...tri.length]\n\n        if triw != ''\n          for view in nbrs[uiw]\n            vi = view >> 1\n            vew = view & 1\n\n            v = u.clone\n            v[i] = trie\n            v[vi] = (vew == WEST) ? triw.reverse + v[vi] : v[vi] + triw\n\n            if dists[v].nil?\n              dists[v] = nvd\n              q << [v, ufb]\n            elsif ufb == D_FW && dists[v] < 0\n              min_d = nvd - dists[v] - 2\n              break\n            elsif ufb == D_BW && dists[v] > 0\n              min_d = -nvd + dists[v] - 2\n              break\n            end\n          end\n        end\n        break if min_d\n        \n        if trie != ''\n          for view in nbrs[uie]\n            vi = view >> 1\n            vew = view & 1\n\n            v = u.clone\n            v[i] = triw\n            v[vi] = (vew == EAST) ? v[vi] + trie.reverse : trie + v[vi]\n\n            if dists[v].nil?\n              dists[v] = nvd\n              q << [v, ufb]\n            elsif ufb == D_FW && dists[v] < 0\n              min_d = nvd - dists[v] - 2\n              break\n            elsif ufb == D_BW && dists[v] > 0\n              min_d = -nvd + dists[v] - 2\n              break\n            end\n          end\n        end\n        break if min_d\n      end\n      break if min_d\n    end\n    break if min_d\n  end\n\n  puts min_d\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_D = 6\n\nWEST = 0\nEAST = 1\n\nEW2D = { 'W' => WEST, 'E' => EAST }\n\n### main\n\nloop do\n  x, y = gets.split.map(&:to_i)\n  break if (x | y) == 0\n\n  x2 = x * 2\n  \n  edges = x2.times.map{x2.times.map{nil}}\n  nbrs = x2.times.map{[]}\n  y.times do\n    pis, qis = gets.strip.split\n    pi = (pis[0].to_i << 1) + EW2D[pis[1]]\n    qi = (qis[0].to_i << 1) + EW2D[qis[1]]\n    edges[pi][qi] = edges[qi][pi] = true\n    nbrs[pi] << qi\n    nbrs[qi] << pi\n  end\n  #p edges\n\n  st = []\n  x.times do\n    tr = gets.strip\n    st << (tr == '-' ? '' : tr)\n  end\n  #p st\n\n  gl = []\n  x.times do\n    tr = gets.strip\n    gl << (tr == '-' ? '' : tr)\n  end\n  #p gl\n\n  dists = Hash.new{MAX_D + 1}\n  dists[st] = 0\n  q = [st]\n\n  while ! q.empty?\n    u = q.shift\n    #p [dists[u], u]\n    \n    if u == gl\n      break\n    end\n\n    for i in (0...x)\n      tri = u[i]\n      next if tri == ''\n\n      uiw = i * 2 + WEST\n      uie = i * 2 + EAST\n      nvd = dists[u] + 1\n      \n      for j in (0..tri.length)\n        triw = tri[0...j]\n        trie = tri[j...tri.length]\n\n        if triw != ''\n          for view in nbrs[uiw]\n            vi = view >> 1\n            vew = view & 1\n\n            v = u.clone\n            v[i] = trie\n            v[vi] = (vew == WEST) ? triw.reverse + v[vi] : v[vi] + triw\n\n            if dists[v] > nvd\n              dists[v] = nvd\n              q << v\n            end\n          end\n        end\n\n        if trie != ''\n          for view in nbrs[uie]\n            vi = view >> 1\n            vew = view & 1\n\n            v = u.clone\n            v[i] = triw\n            v[vi] = (vew == EAST) ? v[vi] + trie.reverse : trie + v[vi]\n\n            if dists[v] > nvd\n              dists[v] = nvd\n              q << v\n            end\n          end\n        end\n      end\n    end\n  end\n\n  puts dists[gl]\nend"
  },
  {
    "language": "Python",
    "code": "def solve(file_input, x, y):\n    exch1 = [] # forward - forward\n    exch2 = [] # forward - reverse\n    exch3 = [] # reverse - forward\n    for i in range(y):\n        p, P, space, q, Q = file_input.readline().rstrip()\n        p = int(p)\n        q = int(q)\n        \n        if P == 'E':\n            if Q == 'W':\n                exch1.append((p, q))\n            else:\n                exch2.append((p, q))\n        else:\n            if Q == 'E':\n                exch1.append((q, p))\n            else:\n                exch3.append((q, p))\n    \n    fwd_init = []\n    for i in range(x):\n        s = file_input.readline().rstrip()\n        if s == '-':\n            fwd_init.append('')\n        else:\n            fwd_init.append(s)\n    fwd_rec = {'|'.join(fwd_init): 0}\n    forwrad = [fwd_init]\n    \n    bk_init = []\n    for i in range(x):\n        t = file_input.readline().rstrip()\n        if t == '-':\n            bk_init.append('')\n        else:\n            bk_init.append(t)\n    bk_rec = {'|'.join(bk_init): 0}\n    backward = [bk_init]\n    \n    for step in range(1, 4):\n        tmp_forward = []\n        for trains in forwrad:\n            for l1, l2 in exch1:\n                tmp_trains = trains[:]\n                coupled = trains[l1] + trains[l2]\n                for i in range(len(coupled) + 1):\n                    tmp_trains[l1] = coupled[:i]\n                    tmp_trains[l2] = coupled[i:]\n                    tmp_state = '|'.join(tmp_trains)\n                    if tmp_state not in fwd_rec:\n                        if tmp_state in bk_rec:\n                            return bk_rec[tmp_state] + step\n                        fwd_rec[tmp_state] = step\n                        tmp_forward.append(tmp_trains[:])\n            for l1, l2 in exch2:\n                tmp_trains = trains[:]\n                coupled = trains[l1] + trains[l2][::-1]\n                for i in range(len(coupled) + 1):\n                    tmp_trains[l1] = coupled[:i]\n                    tmp_trains[l2] = coupled[i:][::-1]\n                    tmp_state = '|'.join(tmp_trains)\n                    if tmp_state not in fwd_rec:\n                        if tmp_state in bk_rec:\n                            return bk_rec[tmp_state] + step\n                        fwd_rec[tmp_state] = step\n                        tmp_forward.append(tmp_trains[:])\n            for l1, l2 in exch3:\n                tmp_trains = trains[:]\n                coupled = trains[l1][::-1] + trains[l2]\n                for i in range(len(coupled) + 1):\n                    tmp_trains[l1] = coupled[:i][::-1]\n                    tmp_trains[l2] = coupled[i:]\n                    tmp_state = '|'.join(tmp_trains)\n                    if tmp_state not in fwd_rec:\n                        if tmp_state in bk_rec:\n                            return bk_rec[tmp_state] + step\n                        fwd_rec[tmp_state] = step\n                        tmp_forward.append(tmp_trains[:])\n        forwrad = tmp_forward\n        \n        if step == 3:\n            return 6\n        \n        tmp_backward = []\n        for trains in backward:\n            for l1, l2 in exch1:\n                tmp_trains = trains[:]\n                coupled = trains[l1] + trains[l2]\n                for i in range(len(coupled) + 1):\n                    tmp_trains[l1] = coupled[:i]\n                    tmp_trains[l2] = coupled[i:]\n                    tmp_state = '|'.join(tmp_trains)\n                    if tmp_state not in bk_rec:\n                        if tmp_state in fwd_rec:\n                            return fwd_rec[tmp_state] + step\n                        bk_rec[tmp_state] = step\n                        tmp_backward.append(tmp_trains[:])\n            for l1, l2 in exch2:\n                tmp_trains = trains[:]\n                coupled = trains[l1] + trains[l2][::-1]\n                for i in range(len(coupled) + 1):\n                    tmp_trains[l1] = coupled[:i]\n                    tmp_trains[l2] = coupled[i:][::-1]\n                    tmp_state = '|'.join(tmp_trains)\n                    if tmp_state not in bk_rec:\n                        if tmp_state in fwd_rec:\n                            return fwd_rec[tmp_state] + step\n                        bk_rec[tmp_state] = step\n                        tmp_backward.append(tmp_trains[:])\n            for l1, l2 in exch3:\n                tmp_trains = trains[:]\n                coupled = trains[l1][::-1] + trains[l2]\n                for i in range(len(coupled) + 1):\n                    tmp_trains[l1] = coupled[:i][::-1]\n                    tmp_trains[l2] = coupled[i:]\n                    tmp_state = '|'.join(tmp_trains)\n                    if tmp_state not in bk_rec:\n                        if tmp_state in fwd_rec:\n                            return fwd_rec[tmp_state] + step\n                        bk_rec[tmp_state] = step\n                        tmp_backward.append(tmp_trains[:])\n        backward = tmp_backward\n\ndef main():\n    from sys import stdin\n    f_i = stdin\n    \n    while True:\n        x, y = map(int, f_i.readline().split())\n        \n        if x == 0:\n            break\n        \n        print(solve(f_i, x, y))\n\nmain()\n"
  }
]