[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 10\n#define MAX_CARS 100\n\ntypedef struct {\n    int cars[MAX_CARS];\n    int count;\n} Line;\n\ntypedef struct {\n    Line parking[MAX_LINES];\n    Line exchange[MAX_LINES];\n    int parking_count;\n    int exchange_count;\n} Station;\n\nvoid init_station(Station *station, int parking_count, int exchange_count) {\n    station->parking_count = parking_count;\n    station->exchange_count = exchange_count;\n    for (int i = 0; i < parking_count; i++) {\n        station->parking[i].count = 0;\n    }\n    for (int i = 0; i < exchange_count; i++) {\n        station->exchange[i].count = 0;\n    }\n}\n\nvoid read_configuration(Line *lines, int count) {\n    for (int i = 0; i < count; i++) {\n        scanf(\"%d\", &lines[i].count);\n        for (int j = 0; j < lines[i].count; j++) {\n            scanf(\"%d\", &lines[i].cars[j]);\n        }\n    }\n}\n\nvoid print_configuration(Line *lines, int count) {\n    for (int i = 0; i < count; i++) {\n        printf(\"%d:\", i);\n        for (int j = 0; j < lines[i].count; j++) {\n            printf(\" %d\", lines[i].cars[j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint is_equal(Line *a, Line *b, int count) {\n    for (int i = 0; i < count; i++) {\n        if (a[i].count != b[i].count) {\n            return 0;\n        }\n        for (int j = 0; j < a[i].count; j++) {\n            if (a[i].cars[j] != b[i].cars[j]) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nvoid move_train(Line *src, Line *dst) {\n    for (int i = 0; i < src->count; i++) {\n        dst->cars[dst->count++] = src->cars[i];\n    }\n    src->count = 0;\n}\n\nint find_car(Line *lines, int count, int car) {\n    for (int i = 0; i < count; i++) {\n        for (int j = 0; j < lines[i].count; j++) {\n            if (lines[i].cars[j] == car) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nint solve(Station *initial, Station *target) {\n    int moves = 0;\n    Line temp;\n    temp.count = 0;\n\n    while (!is_equal(initial->parking, target->parking, initial->parking_count)) {\n        for (int i = 0; i < initial->parking_count; i++) {\n            if (initial->parking[i].count > 0) {\n                int car = initial->parking[i].cars[initial->parking[i].count - 1];\n                int target_line = find_car(target->parking, target->parking_count, car);\n                if (target_line != i) {\n                    move_train(&initial->parking[i], &initial->exchange[0]);\n                    moves++;\n                    if (target_line != -1) {\n                        move_train(&initial->exchange[0], &initial->parking[target_line]);\n                        moves++;\n                    }\n                }\n            }\n        }\n    }\n\n    return moves;\n}\n\nint main() {\n    Station initial, target;\n    int parking_count, exchange_count;\n\n    scanf(\"%d %d\", &parking_count, &exchange_count);\n    init_station(&initial, parking_count, exchange_count);\n    init_station(&target, parking_count, exchange_count);\n\n    read_configuration(initial.parking, parking_count);\n    read_configuration(target.parking, parking_count);\n\n    int moves = solve(&initial, &target);\n    printf(\"%d\\n\", moves);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TrainReconfiguration {\n    private int lines;\n    private List<Deque<Integer>> initialConfig;\n    private List<Deque<Integer>> targetConfig;\n    private boolean[][] exchangeLines;\n\n    public TrainReconfiguration(int lines, List<Deque<Integer>> initial, List<Deque<Integer>> target, boolean[][] exchanges) {\n        this.lines = lines;\n        this.initialConfig = initial;\n        this.targetConfig = target;\n        this.exchangeLines = exchanges;\n    }\n\n    public int minimizeMovements() {\n        return bfs();\n    }\n\n    private int bfs() {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State initialState = new State(initialConfig, 0);\n        queue.offer(initialState);\n        visited.add(stateToString(initialConfig));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            if (isTargetConfiguration(current.configuration)) {\n                return current.moves;\n            }\n\n            for (int from = 0; from < lines; from++) {\n                for (int to = 0; to < lines; to++) {\n                    if (from != to && exchangeLines[from][to] && !current.configuration.get(from).isEmpty()) {\n                        List<Deque<Integer>> newConfig = deepCopyConfiguration(current.configuration);\n                        int car = newConfig.get(from).pollFirst();\n                        newConfig.get(to).offerFirst(car);\n\n                        String configString = stateToString(newConfig);\n                        if (!visited.contains(configString)) {\n                            visited.add(configString);\n                            queue.offer(new State(newConfig, current.moves + 1));\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    private boolean isTargetConfiguration(List<Deque<Integer>> config) {\n        for (int i = 0; i < lines; i++) {\n            if (!config.get(i).equals(targetConfig.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private List<Deque<Integer>> deepCopyConfiguration(List<Deque<Integer>> config) {\n        List<Deque<Integer>> copy = new ArrayList<>();\n        for (Deque<Integer> line : config) {\n            copy.add(new ArrayDeque<>(line));\n        }\n        return copy;\n    }\n\n    private String stateToString(List<Deque<Integer>> config) {\n        StringBuilder sb = new StringBuilder();\n        for (Deque<Integer> line : config) {\n            sb.append(line.toString()).append(\"|\");\n        }\n        return sb.toString();\n    }\n\n    private static class State {\n        List<Deque<Integer>> configuration;\n        int moves;\n\n        State(List<Deque<Integer>> config, int moves) {\n            this.configuration = config;\n            this.moves = moves;\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:18:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> parking;\n    int moves;\n    string hash;\n    \n    State(const vector<vector<int>>& p, int m) : parking(p), moves(m) {\n        hash = generateHash();\n    }\n    \n    string generateHash() {\n        ostringstream oss;\n        for (const auto& line : parking) {\n            for (int car : line) {\n                oss << car << \",\";\n            }\n            oss << \";\";\n        }\n        return oss.str();\n    }\n};\n\nbool isTarget(const State& state, const vector<vector<int>>& target) {\n    return state.parking == target;\n}\n\nvector<State> getNeighbors(const State& state, const vector<pair<int, int>>& exchangeLines) {\n    vector<State> neighbors;\n    \n    for (const auto& line : exchangeLines) {\n        int src = line.first;\n        int dest = line.second;\n        \n        if (state.parking[src].empty()) continue;\n        \n        for (size_t i = 0; i < state.parking[src].size(); ++i) {\n            vector<vector<int>> newParking = state.parking;\n            vector<int> toMove(newParking[src].begin() + i, newParking[src].end());\n            newParking[src].erase(newParking[src].begin() + i, newParking[src].end());\n            newParking[dest].insert(newParking[dest].end(), toMove.begin(), toMove.end());\n            neighbors.emplace_back(newParking, state.moves + 1);\n        }\n    }\n    \n    return neighbors;\n}\n\nint bfs(const vector<vector<int>>& initial, const vector<vector<int>>& target, const vector<pair<int, int>>& exchangeLines) {\n    queue<State> q;\n    unordered_map<string, bool> visited;\n    \n    State start(initial, 0);\n    q.push(start);\n    visited[start.hash] = true;\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (isTarget(current, target)) {\n            return current.moves;\n        }\n        \n        vector<State> neighbors = getNeighbors(current, exchangeLines);\n        for (const State& neighbor : neighbors) {\n            if (!visited[neighbor.hash]) {\n                visited[neighbor.hash] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int P, E;\n    cin >> P >> E;\n    \n    vector<vector<int>> initial(P);\n    for (int i = 0; i < P; ++i) {\n        int C;\n        cin >> C;\n        initial[i].resize(C);\n        for (int j = 0; j < C; ++j) {\n            cin >> initial[i][j];\n        }\n    }\n    \n    vector<vector<int>> target(P);\n    for (int i = 0; i < P; ++i) {\n        int C;\n        cin >> C;\n        target[i].resize(C);\n        for (int j = 0; j < C; ++j) {\n            cin >> target[i][j];\n        }\n    }\n    \n    vector<pair<int, int>> exchangeLines(E);\n    for (int i = 0; i < E; ++i) {\n        cin >> exchangeLines[i].first >> exchangeLines[i].second;\n    }\n    \n    int result = bfs(initial, target, exchangeLines);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_LINES 100\n#define MAX_TRAIN_LENGTH 1000\n\ntypedef struct {\n    int cars[MAX_TRAIN_LENGTH];\n    int length;\n} TrainLine;\n\nint visited[MAX_LINES];\nint min_movements = INT_MAX;\n\nvoid dfs(TrainLine* initial, TrainLine* target, TrainLine* exchange, int lines, int current_movements) {\n    if (current_movements >= min_movements) return;\n\n    int complete = 1;\n    for (int i = 0; i < lines; i++) {\n        if (initial[i].length != target[i].length) {\n            complete = 0;\n            break;\n        }\n        for (int j = 0; j < initial[i].length; j++) {\n            if (initial[i].cars[j] != target[i].cars[j]) {\n                complete = 0;\n                break;\n            }\n        }\n        if (!complete) break;\n    }\n\n    if (complete) {\n        min_movements = current_movements;\n        return;\n    }\n\n    for (int src = 0; src < lines; src++) {\n        if (initial[src].length == 0) continue;\n\n        for (int dest = 0; dest < lines; dest++) {\n            if (src == dest) continue;\n\n            // Move entire train\n            TrainLine temp_initial[MAX_LINES];\n            memcpy(temp_initial, initial, sizeof(TrainLine) * lines);\n\n            TrainLine moving_train = temp_initial[src];\n            temp_initial[src].length = 0;\n            memset(temp_initial[src].cars, 0, sizeof(temp_initial[src].cars));\n\n            for (int k = 0; k < moving_train.length; k++) {\n                temp_initial[dest].cars[temp_initial[dest].length++] = moving_train.cars[k];\n            }\n\n            dfs(temp_initial, target, exchange, lines, current_movements + 1);\n\n            // Move sub-train\n            for (int start = 0; start < initial[src].length; start++) {\n                for (int end = start; end < initial[src].length; end++) {\n                    TrainLine sub_train;\n                    sub_train.length = end - start + 1;\n                    \n                    for (int k = start; k <= end; k++) {\n                        sub_train.cars[k - start] = initial[src].cars[k];\n                    }\n\n                    TrainLine temp_initial2[MAX_LINES];\n                    memcpy(temp_initial2, initial, sizeof(TrainLine) * lines);\n\n                    // Remove sub-train from source\n                    for (int k = end + 1; k < temp_initial2[src].length; k++) {\n                        temp_initial2[src].cars[k - (end - start + 1)] = temp_initial2[src].cars[k];\n                    }\n                    temp_initial2[src].length -= (end - start + 1);\n\n                    // Add sub-train to destination\n                    for (int k = 0; k < sub_train.length; k++) {\n                        temp_initial2[dest].cars[temp_initial2[dest].length++] = sub_train.cars[k];\n                    }\n\n                    dfs(temp_initial2, target, exchange, lines, current_movements + 1);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int lines;\n    TrainLine initial[MAX_LINES];\n    TrainLine target[MAX_LINES];\n    TrainLine exchange[MAX_LINES];\n\n    // Input parsing would go here\n    // Example input processing\n    scanf(\"%d\", &lines);\n    for (int i = 0; i < lines; i++) {\n        scanf(\"%d\", &initial[i].length);\n        for (int j = 0; j < initial[i].length; j++) {\n            scanf(\"%d\", &initial[i].cars[j]);\n        }\n    }\n\n    for (int i = 0; i < lines; i++) {\n        scanf(\"%d\", &target[i].length);\n        for (int j = 0; j < target[i].length; j++) {\n            scanf(\"%d\", &target[i].cars[j]);\n        }\n    }\n\n    dfs(initial, target, exchange, lines, 0);\n\n    printf(\"%d\\n\", min_movements);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass TrainReconfiguration {\nprivate:\n    vector<vector<int>> initialConfig;\n    vector<vector<int>> targetConfig;\n    vector<vector<bool>> exchangeLines;\n    int lines;\n\n    struct State {\n        vector<vector<int>> currentConfig;\n        int moves;\n        string path;\n\n        bool operator<(const State& other) const {\n            return moves > other.moves;\n        }\n    };\n\n    string configToString(const vector<vector<int>>& config) {\n        string result;\n        for (const auto& line : config) {\n            for (int car : line) {\n                result += to_string(car) + \",\";\n            }\n            result += \"|\";\n        }\n        return result;\n    }\n\n    bool isTargetReached(const vector<vector<int>>& config) {\n        return config == targetConfig;\n    }\n\n    vector<State> generateNextStates(const State& currentState) {\n        vector<State> nextStates;\n\n        // Try moving trains between lines\n        for (int from = 0; from < lines; from++) {\n            if (currentState.currentConfig[from].empty()) continue;\n\n            for (int to = 0; to < lines; to++) {\n                if (from == to || !exchangeLines[from][to]) continue;\n\n                State newState = currentState;\n                int car = newState.currentConfig[from].back();\n                newState.currentConfig[from].pop_back();\n                newState.currentConfig[to].push_back(car);\n                newState.moves++;\n                newState.path += \"Move \" + to_string(car) + \" from line \" + to_string(from) + \" to line \" + to_string(to) + \"\\n\";\n\n                nextStates.push_back(newState);\n            }\n        }\n\n        return nextStates;\n    }\n\npublic:\n    TrainReconfiguration(const vector<vector<int>>& initial, const vector<vector<int>>& target, const vector<vector<bool>>& exchanges)\n        : initialConfig(initial), targetConfig(target), exchangeLines(exchanges), lines(initial.size()) {}\n\n    int findOptimalReconfiguration() {\n        priority_queue<State> pq;\n        unordered_map<string, int> visited;\n\n        State initialState{initialConfig, 0, \"\"};\n        pq.push(initialState);\n\n        while (!pq.empty()) {\n            State current = pq.top();\n            pq.pop();\n\n            string configStr = configToString(current.currentConfig);\n            if (visited.count(configStr) && visited[configStr] <= current.moves) continue;\n            visited[configStr] = current.moves;\n\n            if (isTargetReached(current.currentConfig)) {\n                cout << \"Reconfiguration path:\\n\" << current.path;\n                return current.moves;\n            }\n\n            vector<State> nextStates = generateNextStates(current);\n            for (const auto& state : nextStates) {\n                pq.push(state);\n            }\n        }\n\n        return -1; // No solution found\n    }\n};\n\nint main() {\n    vector<vector<int>> initial = {{3, 1, 2}, {4, 5}, {6}};\n    vector<vector<int>> target = {{1, 2, 3}, {4, 5}, {6}};\n    vector<vector<bool>> exchanges = {\n        {false, true, false},\n        {true, false, true},\n        {false, true, false}\n    };\n\n    TrainReconfiguration solver(initial, target, exchanges);\n    int minMoves = solver.findOptimalReconfiguration();\n\n    cout << \"Minimum moves: \" << minMoves << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TrainReconfiguration {\n    static class State {\n        List<List<Integer>> parkingLines;\n        int moves;\n        State parent;\n\n        State(List<List<Integer>> parkingLines, int moves, State parent) {\n            this.parkingLines = new ArrayList<>();\n            for (List<Integer> line : parkingLines) {\n                this.parkingLines.add(new ArrayList<>(line));\n            }\n            this.moves = moves;\n            this.parent = parent;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            State other = (State) obj;\n            return parkingLines.equals(other.parkingLines);\n        }\n\n        @Override\n        public int hashCode() {\n            return parkingLines.hashCode();\n        }\n    }\n\n    public static List<String> findOptimalPlan(List<List<Integer>> initial, List<List<Integer>> target) {\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n        State start = new State(initial, 0, null);\n        queue.add(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.parkingLines.equals(target)) {\n                return reconstructPath(current);\n            }\n\n            for (int i = 0; i < current.parkingLines.size(); i++) {\n                List<Integer> line = current.parkingLines.get(i);\n                if (line.isEmpty()) continue;\n\n                // Move entire line or subtrain to another line\n                for (int j = 0; j < current.parkingLines.size(); j++) {\n                    if (i == j) continue;\n\n                    for (int k = 0; k <= line.size(); k++) {\n                        List<List<Integer>> newParkingLines = new ArrayList<>();\n                        for (List<Integer> pl : current.parkingLines) {\n                            newParkingLines.add(new ArrayList<>(pl));\n                        }\n\n                        List<Integer> subtrain = newParkingLines.get(i).subList(0, k);\n                        List<Integer> newLine = new ArrayList<>(subtrain);\n                        newLine.addAll(newParkingLines.get(j));\n                        newParkingLines.get(i).subList(0, k).clear();\n                        newParkingLines.set(j, newLine);\n\n                        State nextState = new State(newParkingLines, current.moves + 1, current);\n                        if (!visited.contains(nextState)) {\n                            visited.add(nextState);\n                            queue.add(nextState);\n                        }\n                    }\n                }\n            }\n        }\n        return Collections.emptyList();\n    }\n\n    private static List<String> reconstructPath(State state) {\n        List<String> path = new ArrayList<>();\n        while (state.parent != null) {\n            State prev = state.parent;\n            for (int i = 0; i < prev.parkingLines.size(); i++) {\n                for (int j = 0; j < prev.parkingLines.size(); j++) {\n                    if (i == j) continue;\n                    List<Integer> prevLine = prev.parkingLines.get(i);\n                    List<Integer> currLine = state.parkingLines.get(j);\n                    if (currLine.containsAll(prevLine) && !prevLine.isEmpty()) {\n                        path.add(\"Move from line \" + (i + 1) + \" to line \" + (j + 1));\n                        break;\n                    }\n                }\n            }\n            state = state.parent;\n        }\n        Collections.reverse(path);\n        return path;\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> initial = Arrays.asList(\n                new ArrayList<>(Arrays.asList(1, 2, 3)),\n                new ArrayList<>(Arrays.asList(4, 5)),\n                new ArrayList<>()\n        );\n        List<List<Integer>> target = Arrays.asList(\n                new ArrayList<>(Arrays.asList(3, 2, 1)),\n                new ArrayList<>(Arrays.asList(5, 4)),\n                new ArrayList<>()\n        );\n        List<String> plan = findOptimalPlan(initial, target);\n        System.out.println(plan);\n    }\n}",
    "timestamp": "2025-08-05 19:20:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs(initial, target, exchange_lines):\n    visited = set()\n    queue = deque([(initial, 0)])\n    visited.add(tuple(map(tuple, initial)))\n    \n    while queue:\n        config, steps = queue.popleft()\n        \n        if config == target:\n            return steps\n        \n        for i in range(len(config)):\n            for j in range(len(config[i])):\n                if config[i][j] != \"\":  # There is a car here\n                    for exch in exchange_lines:\n                        if i == exch[0] or i == exch[1]:\n                            dest = exch[1] if i == exch[0] else exch[0]\n                            new_config = [list(lst) for lst in config]\n                            # Move sub-train to destination\n                            sub_train = new_config[i][j:]\n                            new_config[i] = new_config[i][:j]\n                            \n                            new_config[dest].extend(sub_train)\n                            new_config_tuple = tuple(map(tuple, new_config))\n                            \n                            if new_config_tuple not in visited:\n                                visited.add(new_config_tuple)\n                                queue.append((new_config, steps + 1))\n    return -1  # If no solution\n\n# Example usage:\ninitial = [[\"A\"], [\"B\"], [\"C\"]]\ntarget = [[\"B\", \"A\"], [\"C\"], []]\nexchange_lines = [(0, 1), (1, 2)]\n\nprint(bfs(initial, target, exchange_lines))",
    "timestamp": "2025-08-13 03:27:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TrainReconfiguration {\n    static class Configuration {\n        List<Deque<Character>> parkingLines;\n        \n        Configuration(List<Deque<Character>> lines) {\n            parkingLines = new ArrayList<>(lines);\n        }\n        \n        boolean isTarget(Configuration target) {\n            for (int i = 0; i < parkingLines.size(); i++) {\n                if (!parkingLines.get(i).equals(target.parkingLines.get(i))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        Configuration move(int from, int to, int count) {\n            List<Deque<Character>> newLines = new ArrayList<>();\n            for (Deque<Character> line : parkingLines) newLines.add(new LinkedList<>(line));\n            Deque<Character> movingPart = new LinkedList<>();\n            for (int i = 0; i < count; i++) movingPart.add(newLines.get(from).removeFirst());\n            newLines.get(to).addAll(movingPart);\n            return new Configuration(newLines);\n        }\n        \n        List<Configuration> getNextConfigurations() {\n            List<Configuration> nextConfigs = new ArrayList<>();\n            for (int from = 0; from < parkingLines.size(); from++) {\n                for (int to = 0; to < parkingLines.size(); to++) {\n                    if (from == to || parkingLines.get(from).isEmpty()) continue;\n                    for (int count = 1; count <= parkingLines.get(from).size(); count++) {\n                        nextConfigs.add(move(from, to, count));\n                    }\n                }\n            }\n            return nextConfigs;\n        }\n    }\n\n    public static int findMinMoves(Configuration start, Configuration target) {\n        Queue<Configuration> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        queue.add(start);\n        visited.add(getStateString(start));\n        \n        int moves = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Configuration current = queue.poll();\n                if (current.isTarget(target)) return moves;\n                \n                for (Configuration next : current.getNextConfigurations()) {\n                    String nextState = getStateString(next);\n                    if (!visited.contains(nextState)) {\n                        visited.add(nextState);\n                        queue.add(next);\n                    }\n                }\n            }\n            moves++;\n        }\n        \n        return -1;\n    }\n    \n    private static String getStateString(Configuration config) {\n        StringBuilder sb = new StringBuilder();\n        for (Deque<Character> line : config.parkingLines) {\n            sb.append(line.toString()).append(\"-\");\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Deque<Character>> initialLines = Arrays.asList(\n            new LinkedList<>(Arrays.asList('A', 'B')),\n            new LinkedList<>(Arrays.asList('C')),\n            new LinkedList<>(List.of())\n        );\n\n        List<Deque<Character>> targetLines = Arrays.asList(\n            new LinkedList<>(Arrays.asList('C')),\n            new LinkedList<>(List.of()),\n            new LinkedList<>(Arrays.asList('A', 'B'))\n        );\n\n        Configuration initialConfig = new Configuration(initialLines);\n        Configuration targetConfig = new Configuration(targetLines);\n        int minMoves = findMinMoves(initialConfig, targetConfig);\n        System.out.println(\"Minimum moves required: \" + minMoves);\n    }\n}",
    "timestamp": "2025-08-13 03:27:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINES 100\n#define MAX_CARS 100\n\ntypedef struct {\n    int cars[MAX_CARS];\n    int count;\n} Line;\n\nint get_car_position(Line *line, int car) {\n    for (int i = 0; i < line->count; i++) {\n        if (line->cars[i] == car) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid move_cars(Line *src, Line *dest, int start_pos, int count) {\n    memmove(dest->cars + dest->count, src->cars + start_pos, count * sizeof(int));\n    dest->count += count;\n    src->count -= count;\n    memmove(src->cars + start_pos, src->cars + start_pos + count, (src->count - start_pos) * sizeof(int));\n}\n\nint reconfigure_trains(Line *initial, Line *target, Line *exchange) {\n    int movements = 0;\n\n    for (int i = 0; i < target->count; i++) {\n        int car = target->cars[i];\n        int pos = get_car_position(initial, car);\n        if (pos != -1) {\n            if (pos > 0) {\n                move_cars(initial, exchange, 0, pos);\n                movements++;\n            }\n            move_cars(initial, &target[i], 0, 1);\n            movements++;\n            exchange->count = 0;\n        } else {\n            int ex_pos = get_car_position(exchange, car);\n            if (ex_pos != -1) {\n                move_cars(exchange, &target[i], ex_pos, 1);\n                movements++;\n            }\n        }\n    }\n\n    return movements;\n}\n\nint main() {\n    Line initial[MAX_LINES], target[MAX_LINES], exchange[MAX_LINES];\n    int num_lines;\n\n    scanf(\"%d\", &num_lines);\n\n    for (int i = 0; i < num_lines; i++) {\n        scanf(\"%d\", &initial[i].count);\n        for (int j = 0; j < initial[i].count; j++) {\n            scanf(\"%d\", &initial[i].cars[j]);\n        }\n    }\n\n    for (int i = 0; i < num_lines; i++) {\n        scanf(\"%d\", &target[i].count);\n        for (int j = 0; j < target[i].count; j++) {\n            scanf(\"%d\", &target[i].cars[j]);\n        }\n    }\n\n    memset(exchange, 0, sizeof(exchange));\n\n    int total_movements = 0;\n    for (int i = 0; i < num_lines; i++) {\n        total_movements += reconfigure_trains(&initial[i], &target[i], &exchange[i]);\n    }\n\n    printf(\"Minimum movements required: %d\\n\", total_movements);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:27:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\n\nclass TrainReconfiguration:\n    def __init__(self, initial_config: List[List[int]], target_config: List[List[int]]):\n        self.initial = initial_config\n        self.target = target_config\n        self.lines = len(initial_config)\n        self.min_moves = float('inf')\n        self.memo = {}\n\n    def solve(self) -> int:\n        def backtrack(current_config, moves):\n            config_key = tuple(tuple(line) for line in current_config)\n            \n            if config_key in self.memo and moves >= self.memo[config_key]:\n                return float('inf')\n            \n            self.memo[config_key] = moves\n            \n            if current_config == self.target:\n                self.min_moves = min(self.min_moves, moves)\n                return moves\n            \n            best_moves = float('inf')\n            \n            for source in range(self.lines):\n                for dest in range(self.lines):\n                    if source != dest:\n                        for i in range(len(current_config[source]) + 1):\n                            for j in range(len(current_config[dest]) + 1):\n                                # Move sub-train\n                                new_config = [line[:] for line in current_config]\n                                sub_train = new_config[source][:i]\n                                new_config[source] = new_config[source][i:]\n                                new_config[dest] = new_config[dest][:j] + sub_train + new_config[dest][j:]\n                                \n                                result = backtrack(new_config, moves + 1)\n                                best_moves = min(best_moves, result)\n            \n            return best_moves\n        \n        backtrack(self.initial, 0)\n        return self.min_moves if self.min_moves != float('inf') else -1\n\ndef train_reconfiguration(initial_config: List[List[int]], target_config: List[List[int]]) -> int:\n    solver = TrainReconfiguration(initial_config, target_config)\n    return solver.solve()",
    "timestamp": "2025-08-13 03:28:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    K = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    initial = []\n    for _ in range(K):\n        line = list(map(int, data[idx:idx+N]))\n        idx += N\n        initial.append(deque(line))\n    \n    target = []\n    for _ in range(K):\n        line = list(map(int, data[idx:idx+N]))\n        idx += N\n        target.append(deque(line))\n    \n    exchange_lines = []\n    for _ in range(M):\n        a, b = map(int, data[idx:idx+2])\n        idx += 2\n        exchange_lines.append((a-1, b-1))\n    \n    from collections import defaultdict\n    visited = set()\n    queue = deque()\n    \n    initial_state = tuple(tuple(line) for line in initial)\n    target_state = tuple(tuple(line) for line in target)\n    \n    if initial_state == target_state:\n        print(0)\n        return\n    \n    queue.append((initial_state, 0))\n    visited.add(initial_state)\n    \n    found = False\n    result = -1\n    \n    while queue:\n        current_state, steps = queue.popleft()\n        current = [deque(line) for line in current_state]\n        \n        if current_state == target_state:\n            found = True\n            result = steps\n            break\n        \n        for a, b in exchange_lines:\n            if not current[a] and not current[b]:\n                continue\n            \n            new_current = [deque(line) for line in current_state]\n            \n            if new_current[a]:\n                car = new_current[a].popleft()\n                new_current[b].appendleft(car)\n            elif new_current[b]:\n                car = new_current[b].popleft()\n                new_current[a].appendleft(car)\n            \n            new_state = tuple(tuple(line) for line in new_current)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((new_state, steps + 1))\n    \n    print(result if found else -1)\n\nsolve()",
    "timestamp": "2025-08-13 03:28:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    vector<vector<int>> parking_lines;\n    int moves;\n\n    bool operator<(const State &other) const {\n        return parking_lines < other.parking_lines;\n    }\n};\n\nint min_moves(const vector<vector<int>> &initial, const vector<vector<int>> &target,\n              const vector<pair<int, int>> &exchange_lines) {\n    set<State> visited;\n    queue<State> q;\n    int n = initial.size();\n\n    q.push({initial, 0});\n    visited.insert({initial, 0});\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        if (current.parking_lines == target) {\n            return current.moves;\n        }\n\n        for (const auto &[from, to] : exchange_lines) {\n            if (!current.parking_lines[from].empty()) {\n                for (int l = 1; l <= current.parking_lines[from].size(); ++l) {\n                    vector<vector<int>> new_config = current.parking_lines;\n                    vector<int> train_to_move(new_config[from].begin(), new_config[from].begin() + l);\n                    new_config[from].erase(new_config[from].begin(), new_config[from].begin() + l);\n\n                    new_config[to].insert(new_config[to].begin(), train_to_move.begin(), train_to_move.end());\n\n                    State new_state = {new_config, current.moves + 1};\n                    if (visited.find(new_state) == visited.end()) {\n                        visited.insert(new_state);\n                        q.push(new_state);\n                    }\n                }\n            }\n        }\n    }\n\n    return -1; // If no solution is found, though the assumptions suggest there always is one.\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> initial(n);\n    vector<vector<int>> target(n);\n    vector<pair<int, int>> exchange_lines(m);\n\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        initial[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> initial[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        int k;\n        cin >> k;\n        target[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> target[i][j];\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        cin >> exchange_lines[i].first >> exchange_lines[i].second;\n        --exchange_lines[i].first;\n        --exchange_lines[i].second;\n    }\n\n    cout << min_moves(initial, target, exchange_lines) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:12:12"
  }
]