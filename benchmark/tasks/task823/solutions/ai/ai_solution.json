[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_M 10\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint solve(int m, Point target, double* lengths, char* modes) {\n    // Try all possible directions and combinations\n    char possible_modes[] = {'L', 'R', 'D', 'U'};\n    \n    // Exhaustive search\n    for (int mode_combo = 0; mode_combo < pow(4, m); mode_combo++) {\n        double curr_x = 0, curr_y = 0;\n        double curr_angle = 0;\n        int valid_config = 1;\n        \n        // Reset arrays\n        memset(lengths, 0, m * sizeof(double));\n        memset(modes, 0, m * sizeof(char));\n        \n        int temp_mode = mode_combo;\n        for (int i = 0; i < m; i++) {\n            // Extract mode for this section\n            int mode_index = temp_mode % 4;\n            temp_mode /= 4;\n            \n            // Length calculation can be done dynamically\n            double section_length = sqrt(pow(target.x - curr_x, 2) + pow(target.y - curr_y, 2)) / m;\n            \n            // Update position based on mode\n            switch(possible_modes[mode_index]) {\n                case 'L':\n                    curr_x += section_length * cos(curr_angle - M_PI/2);\n                    curr_y += section_length * sin(curr_angle - M_PI/2);\n                    curr_angle -= M_PI/2;\n                    break;\n                case 'R':\n                    curr_x += section_length * cos(curr_angle + M_PI/2);\n                    curr_y += section_length * sin(curr_angle + M_PI/2);\n                    curr_angle += M_PI/2;\n                    break;\n                case 'U':\n                    curr_x += section_length * cos(curr_angle);\n                    curr_y += section_length * sin(curr_angle);\n                    break;\n                case 'D':\n                    curr_x += section_length * cos(curr_angle + M_PI);\n                    curr_y += section_length * sin(curr_angle + M_PI);\n                    break;\n            }\n            \n            // Store configuration\n            lengths[i] = section_length;\n            modes[i] = possible_modes[mode_index];\n        }\n        \n        // Check if final point matches target\n        if (fabs(curr_x - target.x) < EPS && fabs(curr_y - target.y) < EPS) {\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    int m;\n    Point target;\n    double lengths[MAX_M];\n    char modes[MAX_M];\n    \n    // Input target point and number of sections\n    scanf(\"%d %lf %lf\", &m, &target.x, &target.y);\n    \n    if (solve(m, target, lengths, modes)) {\n        // Output section lengths and modes\n        for (int i = 0; i < m; i++) {\n            printf(\"%.2f %c\\n\", lengths[i], modes[i]);\n        }\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint main() {\n    int m;\n    scanf(\"%d\", &m);\n    Point *points = malloc(m * sizeof(Point));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    // Check if all points are reachable with the same configuration\n    // This is a simplified approach; actual solution may require more complex logic\n    int possible = 1;\n    for (int i = 1; i < m; i++) {\n        if (abs(points[i].x) % 2 != abs(points[0].x) % 2 || abs(points[i].y) % 2 != abs(points[0].y) % 2) {\n            possible = 0;\n            break;\n        }\n    }\n\n    if (!possible) {\n        printf(\"-1\\n\");\n        free(points);\n        return 0;\n    }\n\n    // Output arm sections (simplified: all lengths 1)\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; i++) {\n        printf(\"1%c\", i == m - 1 ? '\\n' : ' ');\n    }\n\n    // Generate mode sequences for each point\n    for (int i = 0; i < m; i++) {\n        int x = points[i].x;\n        int y = points[i].y;\n        for (int j = 0; j < abs(x); j++) {\n            printf(\"%c\", x > 0 ? 'R' : 'L');\n        }\n        for (int j = 0; j < abs(y); j++) {\n            printf(\"%c\", y > 0 ? 'U' : 'D');\n        }\n        printf(\"\\n\");\n    }\n\n    free(points);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int m;\n    cin >> m;\n    vector<pair<int, int>> points(m + 1);\n    for (int i = 0; i <= m; ++i) {\n        cin >> points[i].first >> points[i].second;\n    }\n\n    // Check if all points are reachable with the same arm configuration\n    // For simplicity, assume the arm is a simple chain with fixed lengths and directions\n    // This is a simplified approach and may not work for all cases\n\n    vector<int> lengths(m);\n    vector<char> modes(m);\n\n    // Calculate differences between consecutive points\n    bool possible = true;\n    for (int i = 0; i < m; ++i) {\n        int dx = points[i + 1].first - points[i].first;\n        int dy = points[i + 1].second - points[i].second;\n        if (dx != 0 && dy != 0 && abs(dx) != abs(dy)) {\n            possible = false;\n            break;\n        }\n        lengths[i] = max(abs(dx), abs(dy));\n        if (dx > 0) modes[i] = 'R';\n        else if (dx < 0) modes[i] = 'L';\n        else if (dy > 0) modes[i] = 'U';\n        else if (dy < 0) modes[i] = 'D';\n        else possible = false;\n    }\n\n    if (!possible) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // Output the configuration\n    cout << m << endl;\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) cout << \" \";\n        cout << lengths[i];\n    }\n    cout << endl;\n    for (int i = 0; i < m; ++i) {\n        cout << modes[i];\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RobotArm {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int[][] points = new int[m + 1][2];\n        for (int i = 0; i <= m; i++) {\n            points[i][0] = sc.nextInt();\n            points[i][1] = sc.nextInt();\n        }\n\n        // Check if all points are reachable with the same configuration\n        boolean possible = true;\n        int[] lengths = new int[m];\n        char[] modes = new char[m];\n        \n        // Calculate differences between consecutive points\n        for (int i = 0; i < m; i++) {\n            int dx = points[i + 1][0] - points[i][0];\n            int dy = points[i + 1][1] - points[i][1];\n            int sum = Math.abs(dx) + Math.abs(dy);\n            if (sum == 0) {\n                possible = false;\n                break;\n            }\n            lengths[i] = sum;\n            \n            if (Math.abs(dx) > Math.abs(dy)) {\n                if (dx > 0) modes[i] = 'R';\n                else modes[i] = 'L';\n            } else {\n                if (dy > 0) modes[i] = 'U';\n                else modes[i] = 'D';\n            }\n        }\n\n        if (!possible) {\n            System.out.println(-1);\n            return;\n        }\n\n        // Verify all points can be reached with the same lengths and modes\n        for (int j = 0; j <= m; j++) {\n            int x = 0, y = 0;\n            for (int i = 0; i < m; i++) {\n                switch (modes[i]) {\n                    case 'L': x -= lengths[i]; break;\n                    case 'R': x += lengths[i]; break;\n                    case 'D': y -= lengths[i]; break;\n                    case 'U': y += lengths[i]; break;\n                }\n            }\n            if (x != points[j][0] || y != points[j][1]) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            System.out.println(-1);\n        } else {\n            System.out.println(m);\n            for (int i = 0; i < m; i++) {\n                System.out.print(lengths[i] + \" \");\n            }\n            System.out.println();\n            for (int i = 0; i < m; i++) {\n                System.out.print(modes[i]);\n            }\n            System.out.println();\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:03:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RobotArmConfiguration {\n    public static String configureRobotArm(int m, List<Point> points) {\n        // Try all possible combinations of section lengths and modes\n        for (int[] lengths : generateLengths(m)) {\n            for (String[] modes : generateModes(m)) {\n                if (checkConfiguration(lengths, modes, points)) {\n                    return formatResult(lengths, modes);\n                }\n            }\n        }\n        return \"-1\";\n    }\n\n    private static List<int[]> generateLengths(int m) {\n        List<int[]> lengthCombinations = new ArrayList<>();\n        // Generate possible section lengths (1 to 10 for example)\n        // Adjust range as needed\n        for (int[] lengths : generateCombinations(m, 1, 10)) {\n            lengthCombinations.add(lengths);\n        }\n        return lengthCombinations;\n    }\n\n    private static List<String[]> generateModes(int m) {\n        List<String[]> modeCombinations = new ArrayList<>();\n        String[] modes = {\"L\", \"R\", \"U\", \"D\"};\n        \n        // Generate all possible mode combinations\n        generateModeCombinations(m, new String[m], 0, modes, modeCombinations);\n        \n        return modeCombinations;\n    }\n\n    private static void generateModeCombinations(int m, String[] current, int index, \n                                                 String[] modes, List<String[]> result) {\n        if (index == m) {\n            result.add(current.clone());\n            return;\n        }\n        \n        for (String mode : modes) {\n            current[index] = mode;\n            generateModeCombinations(m, current, index + 1, modes, result);\n        }\n    }\n\n    private static boolean checkConfiguration(int[] lengths, String[] modes, List<Point> points) {\n        // Simulate robot arm movement\n        double x = 0, y = 0;\n        double angle = 0;\n        \n        for (int i = 0; i < lengths.length; i++) {\n            switch (modes[i]) {\n                case \"L\": angle -= Math.PI / 2; break;\n                case \"R\": angle += Math.PI / 2; break;\n                case \"U\": angle = 0; break;\n                case \"D\": angle = Math.PI; break;\n            }\n            \n            x += lengths[i] * Math.cos(angle);\n            y += lengths[i] * Math.sin(angle);\n        }\n        \n        // Check if final position matches target\n        return matches(x, y, points.get(points.size() - 1));\n    }\n\n    private static boolean matches(double x, double y, Point target) {\n        // Allow small floating-point error\n        return Math.abs(x - target.x) < 1e-6 && Math.abs(y - target.y) < 1e-6;\n    }\n\n    private static String formatResult(int[] lengths, String[] modes) {\n        StringBuilder result = new StringBuilder();\n        \n        // Append lengths\n        for (int length : lengths) {\n            result.append(length).append(\" \");\n        }\n        result.append(\"\\n\");\n        \n        // Append modes\n        for (String mode : modes) {\n            result.append(mode).append(\" \");\n        }\n        \n        return result.toString().trim();\n    }\n\n    private static List<int[]> generateCombinations(int m, int min, int max) {\n        List<int[]> combinations = new ArrayList<>();\n        generateCombinationsHelper(m, min, max, new int[m], 0, combinations);\n        return combinations;\n    }\n\n    private static void generateCombinationsHelper(int m, int min, int max, \n                                                   int[] current, int index, \n                                                   List<int[]> result) {\n        if (index == m) {\n            result.add(current.clone());\n            return;\n        }\n        \n        for (int i = min; i <= max; i++) {\n            current[index] = i;\n            generateCombinationsHelper(m, min, max, current, index + 1, result);\n        }\n    }\n\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int m = 3;\n        List<Point> points = Arrays.asList(\n            new Point(0, 0),\n            new Point(3, 4)\n        );\n        \n        System.out.println(configureRobotArm(m, points));\n    }\n}",
    "timestamp": "2025-08-05 23:03:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nbool isEqual(double a, double b) {\n    return abs(a - b) < EPS;\n}\n\nbool canReachPoint(int m, vector<double>& lengths, vector<char>& modes, \n                   double targetX, double targetY) {\n    double currX = 0, currY = 0;\n    double currAngle = 0;\n\n    for (int i = 0; i < m; i++) {\n        double len = lengths[i];\n        char mode = modes[i];\n\n        if (mode == 'L') currAngle -= M_PI / 2;\n        else if (mode == 'R') currAngle += M_PI / 2;\n        else if (mode == 'U') currAngle = 0;\n        else if (mode == 'D') currAngle = M_PI;\n\n        currX += len * cos(currAngle);\n        currY += len * sin(currAngle);\n    }\n\n    return isEqual(currX, targetX) && isEqual(currY, targetY);\n}\n\nint main() {\n    int m;\n    cin >> m;\n\n    vector<pair<double, double>> targets(m+1);\n    for (int j = 0; j <= m; j++) {\n        cin >> targets[j].first >> targets[j].second;\n    }\n\n    // Try all possible lengths and mode configurations\n    vector<double> bestLengths(m);\n    vector<char> bestModes(m);\n    bool foundSolution = false;\n\n    for (double totalLen = 1; totalLen <= 1000; totalLen += 0.1) {\n        for (int config = 0; config < pow(4, m); config++) {\n            vector<double> lengths(m);\n            vector<char> modes(m);\n            \n            // Distribute total length equally\n            for (int i = 0; i < m; i++) {\n                lengths[i] = totalLen / m;\n            }\n\n            // Generate mode sequence\n            int tempConfig = config;\n            for (int i = 0; i < m; i++) {\n                int mode = tempConfig % 4;\n                tempConfig /= 4;\n                \n                if (mode == 0) modes[i] = 'L';\n                else if (mode == 1) modes[i] = 'R';\n                else if (mode == 2) modes[i] = 'U';\n                else modes[i] = 'D';\n            }\n\n            // Check if configuration reaches target points\n            bool valid = true;\n            for (int j = 1; j <= m; j++) {\n                if (!canReachPoint(j, lengths, modes, \n                                   targets[j].first, targets[j].second)) {\n                    valid = false;\n                    break;\n                }\n            }\n\n            if (valid) {\n                bestLengths = lengths;\n                bestModes = modes;\n                foundSolution = true;\n                break;\n            }\n        }\n        if (foundSolution) break;\n    }\n\n    if (!foundSolution) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // Output solution\n    for (double len : bestLengths) {\n        cout << len << \" \";\n    }\n    cout << endl;\n\n    for (char mode : bestModes) {\n        cout << mode << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:03:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def configure_robot_arm(m, lengths, targets):\n    def can_reach(x, y, remaining_lengths):\n        if len(remaining_lengths) == 0:\n            return (x, y) == (0, 0)\n        length = remaining_lengths[0]\n        for dx, dy, mode in [(length, 0, 'R'), (-length, 0, 'L'), \n                             (0, length, 'U'), (0, -length, 'D')]:\n            if can_reach(x - dx, y - dy, remaining_lengths[1:]):\n                return mode\n        return None\n\n    result = []\n    for (target_x, target_y) in targets:\n        current_x, current_y = 0, 0\n        configuration = []\n\n        for length in lengths:\n            move = can_reach(target_x - current_x, target_y - current_y, lengths[len(configuration)+1:])\n            if move is None:\n                return -1\n            \n            if move == 'R':\n                current_x += length\n            elif move == 'L':\n                current_x -= length\n            elif move == 'U':\n                current_y += length\n            elif move == 'D':\n                current_y -= length\n            configuration.append(move)\n\n        if (current_x, current_y) != (target_x, target_y):\n            return -1\n\n        result.append((lengths, ''.join(configuration)))\n    \n    return result\n\n# Example usage:\nm = 3\nlengths = [1, 2, 3]\ntargets = [(2, 2), (4, 0), (0, -4)]\nprint(configure_robot_arm(m, lengths, targets))",
    "timestamp": "2025-08-13 13:23:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RobotArm {\n\n    static class Joint {\n        int x, y;\n        String modes;\n        \n        Joint(int x, int y, String modes) {\n            this.x = x;\n            this.y = y;\n            this.modes = modes;\n        }\n    }\n    \n    public static String findConfiguration(int m, int[] lengths, int[][] targets) {\n        String[] directions = {\"L\", \"R\", \"U\", \"D\"};\n        int[][] moves = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n        List<List<Joint>> dp = new ArrayList<>();\n        \n        dp.add(Collections.singletonList(new Joint(0, 0, \"\")));\n        \n        for (int i = 0; i < m; i++) {\n            List<Joint> current = dp.get(i);\n            List<Joint> next = new ArrayList<>();\n            \n            for (Joint j : current) {\n                for (int d = 0; d < 4; d++) {\n                    int newX = j.x + moves[d][0] * lengths[i];\n                    int newY = j.y + moves[d][1] * lengths[i];\n                    next.add(new Joint(newX, newY, j.modes + directions[d]));\n                }\n            }\n            \n            dp.add(next);\n        }\n        \n        StringBuilder result = new StringBuilder();\n        boolean possible = true;\n        \n        for (int[] target : targets) {\n            boolean found = false;\n            for (Joint j : dp.get(m)) {\n                if (j.x == target[0] && j.y == target[1]) {\n                    result.append(j.modes).append(\" \");\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                possible = false;\n                break;\n            }\n        }\n        \n        if (!possible) {\n            return \"-1\";\n        }\n        \n        return result.toString().trim();\n    }\n\n    public static void main(String[] args) {\n        int m = 2;\n        int[] lengths = {2, 3};\n        int[][] targets = {{2, 3}, {-1, 0}};\n\n        String configuration = findConfiguration(m, lengths, targets);\n        System.out.println(configuration);\n    }\n}",
    "timestamp": "2025-08-13 13:23:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_M 100\n\nint target_x[MAX_M+1], target_y[MAX_M+1];\nchar result[MAX_M+1];\n\n// Function to check if a configuration is possible for a given target\nint is_possible(int m, int target_x, int target_y) {\n    int rx = 0, ry = 0;\n    for (int i = 0; i < m; ++i) {\n        if (rx + (i+1) <= target_x) {\n            rx += (i+1);\n            result[i] = 'R';\n        } else if (rx - (i+1) >= target_x) {\n            rx -= (i+1);\n            result[i] = 'L';\n        } else if (ry + (i+1) <= target_y) {\n            ry += (i+1);\n            result[i] = 'U';\n        } else if (ry - (i+1) >= target_y) {\n            ry -= (i+1);\n            result[i] = 'D';\n        } else {\n            return 0; // Not possible to configure to reach the target\n        }\n    }\n    return rx == target_x && ry == target_y;\n}\n\nint main() {\n    int m, n;\n\n    // Input number of sections and targets\n    scanf(\"%d %d\", &m, &n);\n\n    for(int i = 0; i < n; ++i) {\n        scanf(\"%d %d\", &target_x[i], &target_y[i]);\n    }\n\n    for(int i = 0; i < n; ++i) {\n        memset(result, 0, sizeof(result));\n        if (is_possible(m, target_x[i], target_y[i])) {\n            // output the configuration\n            printf(\"%d\\n\", m);\n            for(int j = 0; j < m; ++j) {\n                printf(\"%c \", result[j]);\n            }\n            printf(\"\\n\");\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:24:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\nstruct Target {\n    int x, y;\n};\n\nbool isPossible(int x, int y, int m, int lengths) {\n    int maxDistance = lengths * m;\n    return abs(x) + abs(y) <= maxDistance && (x + y + m) % 2 == 0;\n}\n\nstring findConfiguration(int x, int y, int m) {\n    string config = \"\";\n    int currX = 0, currY = 0;\n    \n    for (int i = 0; i < m; i++) {\n        if (currX < x) {\n            config += \"R\";\n            currX++;\n        } else if (currX > x) {\n            config += \"L\";\n            currX--;\n        } else if (currY < y) {\n            config += \"U\";\n            currY++;\n        } else if (currY > y) {\n            config += \"D\";\n            currY--;\n        }\n    }\n    \n    return config;\n}\n\nint main() {\n    int m, n, lengths;\n    cin >> m >> n >> lengths;\n    \n    vector<Target> targets(n);\n    for (int i = 0; i < n; i++) {\n        cin >> targets[i].x >> targets[i].y;\n    }\n    \n    vector<string> configurations;\n    for (int i = 0; i < n; i++) {\n        string result;\n        if (isPossible(targets[i].x, targets[i].y, m, lengths)) {\n            result = findConfiguration(targets[i].x, targets[i].y, m);\n        } else {\n            result = \"-1\";\n        }\n        configurations.push_back(result);\n    }\n    \n    for (const auto& config : configurations) {\n        cout << config << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:24:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_robot_arm(target_points):\n    def can_reach(x, y, sections):\n        # Check if target point is reachable with given section lengths\n        max_length = sum(sections)\n        min_length = abs(max(0, abs(x) - max_length), abs(y) - max_length)\n        direct_distance = (x**2 + y**2)**0.5\n        return min_length <= direct_distance <= max_length\n\n    def generate_configurations(m):\n        # Generate all possible section configurations\n        modes = ['L', 'R', 'U', 'D']\n        from itertools import product\n        return product(modes, repeat=m)\n\n    def calculate_endpoint(sections, mode_sequence):\n        # Calculate final joint position based on sections and modes\n        x, y = 0, 0\n        for section, mode in zip(sections, mode_sequence):\n            if mode == 'L':\n                x -= section\n            elif mode == 'R':\n                x += section\n            elif mode == 'U':\n                y += section\n            else:  # 'D'\n                y -= section\n        return x, y\n\n    def generate_section_lengths(m):\n        # Generate possible section length combinations\n        from itertools import product\n        lengths = range(1, 10)  # Adjust range as needed\n        return product(lengths, repeat=m)\n\n    m = len(target_points)\n    for sections in generate_section_lengths(m):\n        for mode_sequence in generate_configurations(m):\n            for j, (target_x, target_y) in enumerate(target_points):\n                endpoint_x, endpoint_y = calculate_endpoint(sections, mode_sequence)\n                if abs(endpoint_x - target_x) < 1e-6 and abs(endpoint_y - target_y) < 1e-6:\n                    return {\n                        'sections': sections,\n                        'modes': mode_sequence,\n                        'point_index': j\n                    }\n    return -1\n\n# Example usage\ntarget_points = [(3, 4), (5, 6)]\nresult = solve_robot_arm(target_points)\nprint(result)",
    "timestamp": "2025-08-13 13:24:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    points = []\n    for _ in range(N):\n        X = int(data[idx])\n        Y = int(data[idx+1])\n        points.append((X, Y))\n        idx += 2\n    \n    # Check parity\n    parity = (abs(points[0][0]) + abs(points[0][1])) % 2\n    for X, Y in points[1:]:\n        if (abs(X) + abs(Y)) % 2 != parity:\n            print(-1)\n            return\n    \n    m = 0\n    arms = []\n    if parity == 0:\n        arms.append(1)\n        m += 1\n    max_coord = max(max(abs(x) + abs(y) for x, y in points), 1)\n    max_power = 1\n    while max_power <= max_coord:\n        max_power <<= 1\n    max_bit = max_power.bit_length() - 1\n    for i in range(max_bit):\n        arms.append(1 << (max_bit - 1 - i))\n    m += max_bit\n    \n    print(m)\n    print(' '.join(map(str, arms)))\n    \n    for X, Y in points:\n        if parity == 0:\n            X -= 1\n        u = X + Y\n        v = X - Y\n        path = []\n        for d in arms:\n            if u >= 0 and v >= 0:\n                path.append('R')\n                u -= d\n                v -= d\n            elif u >= 0 and v < 0:\n                path.append('U')\n                u -= d\n                v += d\n            elif u < 0 and v >= 0:\n                path.append('D')\n                u += d\n                v -= d\n            else:\n                path.append('L')\n                u += d\n                v += d\n        if parity == 0:\n            path[-1] = 'R'  # adjust for the extra 1 arm\n        print(''.join(path))\n\nsolve()",
    "timestamp": "2025-08-13 13:24:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function configureRobotArm(m, targetPoints) {\n    const directions = {\n        L: [-1, 0],\n        R: [1, 0],\n        U: [0, 1],\n        D: [0, -1]\n    };\n\n    function canReach(targetX, targetY) {\n        let x = 0, y = 0;\n        let steps = '';\n\n        for (let i = 0; i < Math.abs(targetX); i++) {\n            if (targetX < 0) {\n                steps += 'L';\n                x -= 1;\n            } else {\n                steps += 'R';\n                x += 1;\n            }\n        }\n\n        for (let i = 0; i < Math.abs(targetY); i++) {\n            if (targetY < 0) {\n                steps += 'D';\n                y -= 1;\n            } else {\n                steps += 'U';\n                y += 1;\n            }\n        }\n\n        return (x === targetX && y === targetY) ? steps : null;\n    }\n\n    let solutions = [];\n\n    for (let [targetX, targetY] of targetPoints) {\n        let steps = canReach(targetX, targetY);\n        if (!steps) return -1;\n        solutions.push({\n            length: steps.length,\n            modes: steps\n        });\n    }\n\n    return solutions;\n}\n\n// Example usage\nconst m = 1;\nconst targetPoints = [[3, 2], [-1, -1]];\nconsole.log(configureRobotArm(m, targetPoints));",
    "timestamp": "2025-08-13 13:24:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveRobotArmConfiguration(targetPoints) {\n    const m = targetPoints.length;\n    \n    function backtrack(sections, modes, currentPoint, pointIndex) {\n        if (pointIndex === m) {\n            return sections.length > 0 ? { sections, modes } : null;\n        }\n        \n        const target = targetPoints[pointIndex];\n        \n        const directions = ['L', 'R', 'D', 'U'];\n        for (let direction of directions) {\n            const length = calculateSectionLength(currentPoint, target, direction);\n            if (length < 0) continue;\n            \n            const newPoint = updatePoint(currentPoint, direction, length);\n            const result = backtrack(\n                [...sections, length], \n                [...modes, direction], \n                newPoint, \n                pointIndex + 1\n            );\n            \n            if (result) return result;\n        }\n        \n        return null;\n    }\n    \n    function calculateSectionLength(current, target, direction) {\n        switch (direction) {\n            case 'L':\n                return current[0] > target[0] ? current[0] - target[0] : -1;\n            case 'R':\n                return target[0] > current[0] ? target[0] - current[0] : -1;\n            case 'D':\n                return current[1] > target[1] ? current[1] - target[1] : -1;\n            case 'U':\n                return target[1] > current[1] ? target[1] - current[1] : -1;\n        }\n    }\n    \n    function updatePoint(current, direction, length) {\n        switch (direction) {\n            case 'L':\n                return [current[0] - length, current[1]];\n            case 'R':\n                return [current[0] + length, current[1]];\n            case 'D':\n                return [current[0], current[1] - length];\n            case 'U':\n                return [current[0], current[1] + length];\n        }\n    }\n    \n    const result = backtrack([], [], [0, 0], 0);\n    \n    return result ? {\n        sections: result.sections,\n        modes: result.modes.join('')\n    } : -1;\n}",
    "timestamp": "2025-08-13 13:24:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveRobotArm(m, points) {\n    const n = points.length;\n    const results = [];\n    \n    // Check if all points are reachable with the same configuration\n    // We need to find lengths l1, l2, ..., lm and directions for each point\n    \n    // The idea is to have the sum of lengths in x and y directions match the target\n    // For each point (X, Y), we need to find a combination of directions and lengths\n    \n    // Since the problem is complex, we simplify by assuming that all sections have length 1\n    // and only directions vary. This is a common approach in such problems.\n    \n    // For each point, we can represent the directions as follows:\n    // The sum of U - D = Y\n    // The sum of R - L = X\n    \n    // Since m sections can have directions U, D, L, R, we need to find a combination\n    // where the counts satisfy the above equations.\n    \n    // However, with m sections, the maximum possible sum is m (all R or all U)\n    // and minimum is -m (all L or all D)\n    // So, if any |X| + |Y| > m, it's impossible\n    \n    for (const [X, Y] of points) {\n        if (Math.abs(X) + Math.abs(Y) > m) {\n            return -1;\n        }\n    }\n    \n    // Now, we can proceed to find directions for each point\n    // We can use a greedy approach to assign directions\n    \n    const lengths = Array(m).fill(1); // All lengths are 1\n    \n    for (const [X, Y] of points) {\n        let x = X;\n        let y = Y;\n        let directions = [];\n        \n        let remaining = m;\n        \n        // Assign U/D first\n        let u = 0, d = 0;\n        if (y > 0) {\n            u = y;\n            remaining -= u;\n        } else {\n            d = -y;\n            remaining -= d;\n        }\n        \n        // Assign R/L\n        let r = 0, l = 0;\n        if (x > 0) {\n            r = x;\n            remaining -= r;\n        } else {\n            l = -x;\n            remaining -= l;\n        }\n        \n        // Remaining sections can be any direction, but we need to balance\n        // So we assign them in pairs to cancel out\n        if (remaining % 2 !== 0) {\n            return -1; // Not possible to balance\n        }\n        \n        // Add pairs of U/D or L/R to cancel out\n        const pairs = remaining / 2;\n        u += pairs;\n        d += pairs;\n        \n        // Now, construct the directions\n        directions.push(...Array(u).fill('U'));\n        directions.push(...Array(d).fill('D'));\n        directions.push(...Array(r).fill('R'));\n        directions.push(...Array(l).fill('L'));\n        \n        // Shuffle to make sure the order doesn't matter (since the problem allows any order)\n        // But for simplicity, we just return the directions as is\n        results.push({\n            lengths: [...lengths],\n            directions: directions\n        });\n    }\n    \n    return results;\n}\n\n// Example usage:\n// const m = 3;\n// const points = [[1, 2], [0, -1]];\n// console.log(solveRobotArm(m, points));",
    "timestamp": "2025-08-13 13:25:11"
  }
]