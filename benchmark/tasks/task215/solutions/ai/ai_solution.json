[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* uncompress(const char* compressed) {\n    int len = strlen(compressed);\n    char* result = malloc(1);\n    result[0] = '\\0';\n    int capacity = 1;\n    int size = 0;\n\n    for (int i = 0; i < len; ) {\n        if (compressed[i] == '(') {\n            int j = i + 1;\n            while (j < len && compressed[j] != ')') {\n                j++;\n            }\n            if (j >= len) break;\n\n            int num = 0;\n            int k = i + 1;\n            while (k < j && compressed[k] >= '0' && compressed[k] <= '9') {\n                num = num * 10 + (compressed[k] - '0');\n                k++;\n            }\n            int seq_len = j - k - 1;\n            char* seq = malloc(seq_len + 1);\n            strncpy(seq, compressed + k + 1, seq_len);\n            seq[seq_len] = '\\0';\n\n            int new_size = size + num * seq_len;\n            while (capacity <= new_size) {\n                capacity *= 2;\n                result = realloc(result, capacity);\n            }\n            for (int l = 0; l < num; l++) {\n                strcat(result, seq);\n            }\n            size = new_size;\n            free(seq);\n            i = j + 1;\n        } else {\n            if (size + 1 >= capacity) {\n                capacity *= 2;\n                result = realloc(result, capacity);\n            }\n            result[size++] = compressed[i];\n            result[size] = '\\0';\n            i++;\n        }\n    }\n    return result;\n}\n\nchar get_ith_letter(const char* compressed, int i) {\n    char* uncompressed = uncompress(compressed);\n    char result = uncompressed[i - 1];\n    free(uncompressed);\n    return result;\n}\n\nint main() {\n    char compressed[1001];\n    int i;\n    scanf(\"%s\", compressed);\n    scanf(\"%d\", &i);\n    printf(\"%c\\n\", get_ith_letter(compressed, i));\n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GenomeUncompressor {\n    public static String uncompress(String compressed) {\n        StringBuilder result = new StringBuilder();\n        int i = 0;\n        \n        while (i < compressed.length()) {\n            if (Character.isDigit(compressed.charAt(i))) {\n                int j = i;\n                while (j < compressed.length() && Character.isDigit(compressed.charAt(j))) {\n                    j++;\n                }\n                int repeatCount = Integer.parseInt(compressed.substring(i, j));\n                char repeatChar = compressed.charAt(j);\n                \n                for (int k = 0; k < repeatCount; k++) {\n                    result.append(repeatChar);\n                }\n                \n                i = j + 1;\n            } else {\n                result.append(compressed.charAt(i));\n                i++;\n            }\n        }\n        \n        return result.toString();\n    }\n    \n    public static char getIthLetter(String compressed, int index) {\n        String uncompressed = uncompress(compressed);\n        \n        if (index < 0 || index >= uncompressed.length()) {\n            throw new IndexOutOfBoundsException(\"Index out of range\");\n        }\n        \n        return uncompressed.charAt(index);\n    }\n}",
    "timestamp": "2025-08-05 19:07:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\nstring uncompress(const string& s) {\n    string res;\n    int i = 0;\n    int n = s.size();\n    while (i < n) {\n        if (isalpha(s[i])) {\n            res += s[i];\n            i++;\n        } else {\n            int num = 0;\n            while (i < n && isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n                i++;\n            }\n            string sub;\n            while (i < n && isalpha(s[i])) {\n                sub += s[i];\n                i++;\n            }\n            for (int j = 0; j < num; j++) {\n                res += sub;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    string uncompressed = uncompress(s);\n    if (k > 0 && k <= uncompressed.size()) {\n        cout << uncompressed[k - 1] << endl;\n    } else {\n        cout << \"Invalid index\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar findIthLetter(char* compressedSequence, int i) {\n    int length = 0;\n    int index = 0;\n    \n    while (compressedSequence[index] != '\\0') {\n        if (compressedSequence[index] >= '0' && compressedSequence[index] <= '9') {\n            int repeat = 0;\n            while (compressedSequence[index] >= '0' && compressedSequence[index] <= '9') {\n                repeat = repeat * 10 + (compressedSequence[index] - '0');\n                index++;\n            }\n            char currentChar = compressedSequence[index];\n            \n            for (int j = 0; j < repeat; j++) {\n                length++;\n                if (length == i) {\n                    return currentChar;\n                }\n            }\n            index++;\n        } else {\n            length++;\n            if (length == i) {\n                return compressedSequence[index];\n            }\n            index++;\n        }\n    }\n    \n    return '\\0';\n}\n\nint main() {\n    char compressedSequence[1000];\n    int i;\n    \n    scanf(\"%s %d\", compressedSequence, &i);\n    \n    char result = findIthLetter(compressedSequence, i);\n    \n    if (result != '\\0') {\n        printf(\"%c\\n\", result);\n    } else {\n        printf(\"Invalid index\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring uncompressGenome(const string& compressed) {\n    string result;\n    int n = compressed.length();\n    \n    for (int i = 0; i < n; i++) {\n        if (isdigit(compressed[i])) {\n            int j = i;\n            while (j < n && isdigit(compressed[j])) j++;\n            \n            int repeat = stoi(compressed.substr(i, j - i));\n            string seq = \"\";\n            \n            int k = j;\n            int bracketCount = 1;\n            k++;\n            \n            while (bracketCount > 0) {\n                if (compressed[k] == '[') bracketCount++;\n                if (compressed[k] == ']') bracketCount--;\n                \n                if (bracketCount > 0) seq += compressed[k];\n                k++;\n            }\n            \n            for (int r = 0; r < repeat; r++) {\n                result += seq;\n            }\n            \n            i = k - 1;\n        } else {\n            result += compressed[i];\n        }\n    }\n    \n    return result;\n}\n\nchar findIthLetter(const string& compressed, int i) {\n    string uncompressed = uncompressGenome(compressed);\n    \n    if (i < 1 || i > uncompressed.length()) {\n        return '\\0';\n    }\n    \n    return uncompressed[i - 1];\n}\n\nint main() {\n    string compressed;\n    int i;\n    \n    cin >> compressed >> i;\n    \n    char result = findIthLetter(compressed, i);\n    \n    if (result != '\\0') {\n        cout << result << endl;\n    } else {\n        cout << \"Invalid index\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:07:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class GenomeUncompressor {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String compressed = scanner.next();\n        int i = scanner.nextInt();\n        scanner.close();\n\n        System.out.println(getCharacterAt(compressed, i - 1));\n    }\n\n    private static char getCharacterAt(String compressed, int index) {\n        Stack<Object> stack = new Stack<>();\n        long currentLength = 0;\n\n        for (int j = 0; j < compressed.length(); ) {\n            char c = compressed.charAt(j);\n            if (c == '(') {\n                stack.push(currentLength);\n                stack.push('(');\n                j++;\n            } else if (c == ')') {\n                long lengthBeforeRepeat = 0;\n                StringBuilder pattern = new StringBuilder();\n                while (stack.peek() != '(') {\n                    Object top = stack.pop();\n                    if (top instanceof Long) {\n                        lengthBeforeRepeat += (Long) top;\n                    } else {\n                        pattern.insert(0, (String) top);\n                        lengthBeforeRepeat += ((String) top).length();\n                    }\n                }\n                stack.pop(); // Remove '('\n                j++;\n                int numStart = j;\n                while (j < compressed.length() && Character.isDigit(compressed.charAt(j))) {\n                    j++;\n                }\n                int repeat = Integer.parseInt(compressed.substring(numStart, j));\n                long totalLength = lengthBeforeRepeat * repeat;\n                if (index < currentLength + totalLength) {\n                    long posInPattern = (index - currentLength) % lengthBeforeRepeat;\n                    return getCharInPattern(pattern.toString(), posInPattern);\n                }\n                currentLength += totalLength;\n                stack.push(totalLength);\n            } else {\n                int start = j;\n                while (j < compressed.length() && Character.isLetter(compressed.charAt(j))) {\n                    j++;\n                }\n                String segment = compressed.substring(start, j);\n                if (index < currentLength + segment.length()) {\n                    return segment.charAt((int) (index - currentLength));\n                }\n                currentLength += segment.length();\n                stack.push(segment);\n            }\n        }\n\n        return ' ';\n    }\n\n    private static char getCharInPattern(String pattern, long pos) {\n        for (int i = 0; i < pattern.length(); i++) {\n            if (pos < pattern.length()) {\n                return pattern.charAt((int) pos);\n            }\n            pos -= pattern.length();\n        }\n        return ' ';\n    }\n}",
    "timestamp": "2025-08-05 19:08:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def uncompress_and_retrieve(genome_string, i):\n    def decompress(s):\n        stack = []\n        num = ''\n        seq = ''\n        \n        for ch in s:\n            if ch.isdigit():\n                num += ch\n            elif ch == '(':\n                stack.append((seq, int(num) if num else 1))\n                seq = ''\n                num = ''\n            elif ch == ')':\n                pre_seq, multiplier = stack.pop()\n                seq = pre_seq + seq * multiplier\n            else:\n                seq += ch\n        \n        return seq\n\n    expanded_genome = decompress(genome_string)\n    if 1 <= i <= len(expanded_genome):\n        return expanded_genome[i - 1]\n    else:\n        return 'Index out of range'\n\n# Example usage:\ngenome_string = \"3(AG)2(CTG)\"\ni = 10\nresult = uncompress_and_retrieve(genome_string, i)\nprint(result)",
    "timestamp": "2025-08-13 02:34:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class GenomeSequence {\n\n    public static char getIthLetter(String compressed, int index) {\n        StringBuilder uncompressed = new StringBuilder();\n        Pattern pattern = Pattern.compile(\"(\\\\d+)?([A-Z])\");\n        Matcher matcher = pattern.matcher(compressed);\n        \n        while (matcher.find()) {\n            String number = matcher.group(1);\n            String letter = matcher.group(2);\n            int repeatCount = number == null ? 1 : Integer.parseInt(number);\n            for (int i = 0; i < repeatCount; i++) {\n                uncompressed.append(letter);\n            }\n        }\n        \n        return uncompressed.charAt(index - 1);\n    }\n\n    public static void main(String[] args) {\n        String compressedSequence = \"3A2B1C4D\";\n        int i = 6;\n        System.out.println(getIthLetter(compressedSequence, i)); // Output should be 'C'\n    }\n}",
    "timestamp": "2025-08-13 02:34:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_INPUT_SIZE 1000\n\n// Function to uncompress the genome sequence and retrieve the i-th letter\nchar findIthLetter(char *compressedSequence, int index) {\n    int n = strlen(compressedSequence);\n    int i = 0, uncompressedLen = 0;\n    char result;\n\n    while (i < n) {\n        char currentChar = compressedSequence[i];\n        int repeat = 0;\n\n        // Check if the current character is a digit (part of the repeat count)\n        if (isdigit(compressedSequence[i])) {\n            while (i < n && isdigit(compressedSequence[i])) {\n                repeat = repeat * 10 + (compressedSequence[i] - '0');\n                i++;\n            }\n            currentChar = compressedSequence[i];\n            i++; // Move to the next character after the repeat count\n        } else {\n            repeat = 1;\n            i++;\n        }\n\n        // Scan the uncompressed sequence and retrieve the i-th letter\n        uncompressedLen += repeat;\n        if (index < uncompressedLen) {\n            result = currentChar;\n            break;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    char compressedSequence[MAX_INPUT_SIZE];\n    int index;\n\n    // Input the compressed sequence and the index\n    printf(\"Enter the compressed sequence: \");\n    scanf(\"%s\", compressedSequence);\n    printf(\"Enter the index: \");\n    scanf(\"%d\", &index);\n\n    // Get the i-th letter\n    char ithLetter = findIthLetter(compressedSequence, index);\n\n    // Output the i-th letter\n    printf(\"The %d-th letter in the uncompressed sequence is: %c\\n\", index, ithLetter);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:34:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decompress_genome(compressed_sequence):\n    result = []\n    i = 0\n    while i < len(compressed_sequence):\n        if compressed_sequence[i].isalpha():\n            result.append(compressed_sequence[i])\n            i += 1\n        else:\n            # Extract number\n            num_str = ''\n            while i < len(compressed_sequence) and compressed_sequence[i].isdigit():\n                num_str += compressed_sequence[i]\n                i += 1\n            \n            # Extract repeated sequence\n            repeat_seq = ''\n            bracket_count = 1\n            while bracket_count > 0:\n                repeat_seq += compressed_sequence[i]\n                if compressed_sequence[i] == '(':\n                    bracket_count += 1\n                elif compressed_sequence[i] == ')':\n                    bracket_count -= 1\n                i += 1\n            \n            # Remove outer brackets\n            repeat_seq = repeat_seq[1:-1]\n            \n            # Expand repeated sequence\n            num = int(num_str)\n            expanded_seq = decompress_genome(repeat_seq) * num\n            result.extend(expanded_seq)\n    \n    return result\n\ndef get_ith_letter(compressed_sequence, i):\n    decompressed = decompress_genome(compressed_sequence)\n    return decompressed[i-1] if 1 <= i <= len(decompressed) else ''",
    "timestamp": "2025-08-13 02:34:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def uncompress_genome(compressed, i):\n    stack = []\n    current_str = []\n    num = 0\n    \n    for char in compressed:\n        if char.isdigit():\n            num = num * 10 + int(char)\n        elif char == '[':\n            stack.append((''.join(current_str), num))\n            current_str = []\n            num = 0\n        elif char == ']':\n            prev_str, repeat = stack.pop()\n            current_str = [prev_str + ''.join(current_str) * repeat]\n        else:\n            current_str.append(char)\n    \n    uncompressed = ''.join(current_str)\n    return uncompressed[i] if i < len(uncompressed) else ''",
    "timestamp": "2025-08-13 02:34:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n\nstd::string uncompressGenome(const std::string& compressed) {\n    std::string uncompressed;\n    int n = compressed.size();\n    for (int i = 0; i < n;) {\n        if (std::isupper(compressed[i])) {\n            uncompressed += compressed[i];\n            ++i;\n        } else {\n            int j = i;\n            while (j < n && std::isdigit(compressed[j])) {\n                ++j;\n            }\n            int repeatCount = std::stoi(compressed.substr(i, j - i));\n            std::string toRepeat = uncompressed.substr(uncompressed.size() - 1);\n            for (int k = 0; k < repeatCount - 1; ++k) {\n                uncompressed += toRepeat;\n            }\n            i = j;\n        }\n    }\n    return uncompressed;\n}\n\nint main() {\n    std::string compressedGenome;\n    int queryIndex;\n    std::cin >> compressedGenome >> queryIndex;\n    \n    std::string uncompressedGenome = uncompressGenome(compressedGenome);\n    \n    if (queryIndex >= 0 && queryIndex < uncompressedGenome.size()) {\n        std::cout << uncompressedGenome[queryIndex] << std::endl;\n    } else {\n        std::cout << \"Index out of bounds\" << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:06:43"
  }
]