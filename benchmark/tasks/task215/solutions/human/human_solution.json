[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nobject Main extends App {\n\n  import scala.io.StdIn._\n\n  solve\n  def solve: Unit = {\n    val Array(expression, i) = readLine.split(' ')\n    if (expression == \"0\") return\n    expression.toList match {\n      case g Genome Nil ⇒ g.nThGenome(i.toInt) match {\n        case Right(c) ⇒ println(c)\n        case Left(_) ⇒ println(0)\n      }\n      case g Genome t ⇒ println(g, t)\n    }\n    solve\n  }\n  object Genome {\n    def unapply(arg: List[Char]): Option[(Genome, List[Char])] = {\n      arg match {\n        case l Term rest ⇒ rest match {\n          case g Genome t ⇒ Some(SequenceGenome(l, g), t)\n          case _ ⇒ Some(l, rest)\n        }\n        case _ ⇒ None\n      }\n    }\n  }\n  object Term{\n    def unapply(arg: List[Char]): Option[(Genome, List[Char])] = {\n      arg match {\n        case '('::(g Genome ')'::t) ⇒ Some(g, t)\n        case n Number (g Term t) ⇒ Some(RepeatGenome(g, n), t)\n        case h::t if h.isLetter ⇒ Some(SingleGenome(h), t)\n        case _ ⇒ None\n      }\n    }\n  }\n  trait Genome {\n    def nThGenome(n: Int): Either[Int, Char]\n    def length: Int\n  }\n  case class SingleGenome(char: Char) extends Genome {\n    override def nThGenome(n: Int): Either[Int, Char] = if (n == 0) Right(char) else Left(n - 1)\n    override def length: Int = 1\n  }\n  case class SequenceGenome(head: Genome, tail: Genome) extends Genome {\n    override def nThGenome(n: Int): Either[Int, Char] = if (n >= length) Left(n - length) else head.nThGenome(n) match {\n      case Left(l) ⇒ tail.nThGenome(l)\n      case r ⇒ r\n    }\n    override val length: Int = (head.length + tail.length).let{i ⇒ if (i > 1000001) 1000001 else i}\n  }\n  case class RepeatGenome(genome: Genome, repeat: Int) extends Genome {\n    override def nThGenome(n: Int): Either[Int, Char] = if (n >= length) Left(n - length) else genome.nThGenome(n % genome.length)\n    override val length: Int = (genome.length.toLong * repeat).let{i ⇒ if (i > 1000001) 1000001 else i.toInt}\n  }\n  object Number {\n    def unapply(arg: List[Char]): Option[(Int, List[Char])] = {\n      arg.span(_.isDigit) match {\n        case (Nil, _) ⇒ None\n        case (number, t) ⇒ Some(number.mkString.toInt, t)\n      }\n    }\n  }\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nint idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(string str,int from,int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\t//if(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t//\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t//\tif(sum<idx){\n\t\t\t\t\t//\t\tcp=sum;\n\t\t\t\t\t//\t\tif(cp>idx){\n\t\t\t\t\t//\t\t\tfin=true;\n\t\t\t\t\t//\t\t\treturn 0;\n\t\t\t\t\t//\t\t}\n\t\t\t\t\t//\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t//\t\tcontinue;\n\t\t\t\t\t//\t}\n\t\t\t\t\t//}\t\t\t\t\t\t\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint n;\nstring dfs(int x){\n  int a=1,t=0;\n  string str,res;\n  for(int i=x;0<a;i++){\n    if('0'<=s[i]&&s[i]<='9')\n      t*=10,t+=s[i]-'0';\n    else if(s[i]=='('){\n      res=dfs(x+1);\n      a++;\n    }\n    else if(s[i]==')')a--;\n    else if(a==1)res+=s[i];\n  }\n  if(t==0)t=1;\n  for(int i=0;i<t;i++)str+=res;\n  return str;\n}\nint main(){\n  while(cin>>s>>n){\n    s+=\")\";\n    string ans=dfs(0);\n    cout<<ans<<endl;\n    if(ans.size()>n)\n      cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define fi first\n#define se second\n\n#define LINE /*cout << \"LINE : \" << __LINE__ << endl*/\n#define dumpln(X) /*cout << \"LINE:\" << __LINE__ << \", \"<<#X << \" : \" << X << endl*/\n#define dumpVln(X) /*{cout << \"LINE:\" << __LINE__ << \", \" << #X << \" [\";for(auto&& x : X) cout << x << \", \"; cout << \"]\" << endl;}*/\n\n\nusing ll = long long;\n\nbool isNum(char c) {\n    return c >= '0' && c <= '9';\n}\nbool isAlpha(char c) {\n    return c >= 'A' && c <= 'Z';\n}\n\nstring S;\nll L;\n\nstruct Node {\n    int id;\n    vector<int> chils;\n    string s;\n    int num = 1;\n    bool isLeaf() {return chils.empty();};\n    Node() : num(1), id(-1) {}\n};\n\nconst int MAX_NODE_SIZE = 101;\nNode nodes[MAX_NODE_SIZE];\nint nodes_sz;\n\nll dp[MAX_NODE_SIZE];\nll None = -1e18;\n\nint getNum(int& idx) {\n    int num = 0;\n    while (isNum(S[idx])) {\n        num *= 10;\n        num += (S[idx] - '0');\n        ++idx;\n    }\n    return num;\n}\n\nNode calc(int& idx) {\n    int id = nodes_sz++;\n    Node& node = nodes[id];\n    node.id = id;\n    if (isAlpha(S[idx])) {\n        while (idx < S.size() && isAlpha(S[idx])) {\n            node.s += S[idx];\n            ++idx;\n        }\n    } else {\n        node.num = getNum(idx);\n        if (S[idx] == '(') {\n            ++idx;\n            while (S[idx] != ')') {\n                node.chils.push_back(calc(idx).id);\n            }\n            ++idx;\n        } else {\n            node.chils.push_back(calc(idx).id);\n        }\n    }\n    return nodes[id];\n}\n\n\nll dfs(int idx) {\n    if (dp[idx] != None) return dp[idx];\n    ll& ret = dp[idx];\n    Node& node = nodes[idx];\n    ll len = 0;\n    if (node.isLeaf()) {\n        len = node.s.size();\n    } else {\n        for (auto && id : node.chils) {\n            ll tmp = dfs(id);\n            if (tmp == -1) return ret = -1;\n            len += tmp;\n        }\n        if (len * node.num > L) return ret = -1;\n        len *= node.num;\n    }\n    return ret = len;\n}\n\nstring getStr(int id) {\n    Node& node = nodes[id];\n    if (node.isLeaf()) {\n        return node.s;\n    }\n    string ret, s;\n    for (auto && id : node.chils) {\n        s += getStr(id);\n        if(s.size() > L) return s;\n    }\n    rep(i, node.num) {\n        ret += s;\n        if(ret.size() > L) return ret;\n    }\n    return ret;\n}\n\nchar dfs2(int idx) {\n    char ret;\n    Node& node = nodes[idx];\n    if(node.chils.size() > 0 && dfs(node.chils.front()) == -1) {\n        return dfs2(node.chils.front());\n    }\n    auto s = getStr(idx);\n    return s[L%s.size()];\n}\n\nchar solve() {\n    rep(i, MAX_NODE_SIZE) dp[i] = None;\n    int idx = 0;\n    while (idx < S.size()) {\n        int par = calc(idx).id;\n        auto len = dfs(par);\n        if (len == -1 || len > L) return dfs2(par);\n        else L -= len;\n    }\n    return '0';\n}\n\nint main() {\n    while (cin >> S >> L) {\n        if (S == \"0\" && L == 0) break;\n        dumpln(S);\n        dumpln(L);\n        nodes_sz = 0;\n        rep(i, MAX_NODE_SIZE) nodes[i] = Node();\n        cout << solve() << endl;\n        LINE;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define IDXMAX 1000000\nstring str;\nll idx;\nll extendex_length;\nll pos;\n\nll a();\nstring b();\nll c();\nll number();\nstring alpha();\n\nll a(){\n  ll numofalpha = alpha().length();\n  while(pos < str.length() && isdigit(str[pos])){\n    ll num = number();\n    if(str[pos] == '('){\n      pos++;   //'('\n      ll subnumofalpha = 0;\n      subnumofalpha += a();\n      if(subnumofalpha > IDXMAX) return subnumofalpha;\n      subnumofalpha += alpha().length();\n      if(subnumofalpha > IDXMAX) return subnumofalpha;\n      numofalpha += num * subnumofalpha;\n      if(numofalpha > IDXMAX) return numofalpha;\n      pos++;   //')'\n    }else{\n      numofalpha += num;\n      pos++;\n    }\n  }\n  return numofalpha;\n}\n\nstring b(){\n  string res = alpha();\n  while(pos < str.length() && isdigit(str[pos])){\n    ll num = number();\n    if(str[pos] == '('){\n      pos++;  //'('\n      string subres;\n      subres += b();\n      subres += alpha();\n      for(ll i=0; i < num; i++){\n        res += subres;\n        if(res.length() > idx) return res;\n      }\n      pos++;\n    }else{\n      string subres = string(1, str[pos]);\n      for(ll i=0; i < num; i++){\n        res += subres;\n      }\n      pos++;\n    }\n  }\n  return res;\n}\n\nll number(){\n  ll res = 0;\n  if(pos < str.length()){\n    while(isdigit(str[pos])){\n      res *= 10;\n      res += str[pos] - '0';\n      pos++;\n    }\n  }\n  return res;\n}\n\nstring alpha(){\n  string res;\n  while(isalpha(str[pos])){\n    res += string(1, str[pos]);\n    pos++;\n  }\n  return res;\n}\n\nint main(void){\n  while(cin >> str >> idx, str[0]-'0' || idx){\n    pos = 0;\n    extendex_length = a();\n    pos = 0;\n    string extended;\n    extended = b();\n    //cout << \"extendex_length=\" << extendex_length << \" str=\" << extended << endl;\n    if(idx >= extendex_length){\n      cout << 0 << endl;\n    }else{\n      cout << extended[idx] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,pos,cnt;\nstring str;\nchar ans;\n\nvoid factor();\n\nvoid exp(){\n  while(str[pos] >= 'A' && str[pos] <= 'Z' && pos < str.size()){\n    if(n == cnt) ans = str[pos];\n    pos++;\n    cnt++;\n  }\n}\n\nvoid factor(){\n  while(pos < str.size() && ans == '0' && cnt <= 1000010 && str[pos] != ')'){\n    int num = 0;\n    //cout << pos << '-';\n    while(str[pos] >= '0' && str[pos] <= '9' && pos < str.size()){\n      num *= 10;\n      num += str[pos++] - '0';\n    }    \n    //cout << pos << ' ' << num << endl;\n    if(str[pos] == '('){\n      pos++;\n      int prev = pos;\n      for(int i=0;i<num;i++) {\n        //if(str[pos] >= 'A' && str[pos] <= 'Z') factor(); //\n        /*else*/ factor();\n        if(i != num - 1) pos = prev;\n      }\n      pos++;\n    } else {\n      //cout << pos << '-';\n      if(num == 0) exp();\n      else {\n        if(cnt <= n && n < cnt + num) ans = str[pos];\n        cnt += num;\n        pos++;\n        //cout << pos;\n      }\n      //cout << endl;\n    }\n  }\n}\n\nvoid solve(){\n  pos = cnt = 0;\n  ans = '0';\n  factor();\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> str >> n && (str != \"0\" || n)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nbool out;\nbool output(string s, ll I, ll mult, bool f){\n    if(!f && s.size() * mult < I) return false;\n    out = 1;\n    I %= s.size();\n    cout << s[I] << endl;\n    return true;\n}\nint main(){\n    while(1){\n        string s;\n        ll I;\n        cin >> s >> I;\n        if(s == \"0\" && !I) break;\n        stack<ll> st;\n        string now = \"\";\n        ll num = 0;\n        ll mult = 1;\n        bool f = 0;\n        for(char c : s){\n            if('0' <= c && c <= '9'){\n                num = num * 10 + (c - '0');\n            }else if(c == '('){\n                st.push(num);\n                mult *= num;\n                num = 0;\n                if(mult >= I){\n                    mult = 1;\n                    f = 1;\n                }\n            }else if('A'<= c && c <= 'Z'){\n                for(ll i = 0; i < max<ll>(1, num); i++) now += c;\n                num = 0;\n            }else if(c == ')'){\n                ll tmp = st.top();\n                st.pop();\n                if(output(now, I, mult, f)){\n                    break;\n                }else{\n                    I -= now.size() * mult;\n                    now = \"\";\n                }\n                mult /= tmp;\n            }\n        }\n        if(!out){\n            if(I < now.size()) cout << now[I] << endl;\n            else cout << 0 << endl;\n        }\n        out = 0;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    string pattern;\n    int start,end,factor;\n    ll len;\n    vector<Node*> child;\n};\n\nint p;\n\nNode *parse(string &s) {\n    if(isdigit(s[p])) {\n        int r = 0;\n        while(isdigit(s[p])) {\n            r *= 10;\n            r += s[p] -'0';\n            p++;\n        }\n\n        Node *node = new Node();\n        node->factor = r;\n        if(s[p] == '(') {\n            p++;\n            while(s[p] != ')') {\n                Node *nr = parse(s);\n                node->child.push_back(nr);\n            }\n            p++;\n            node->len = 0;\n            for(int i=0; i<node->child.size(); ++i) {\n                node->len += node->child[i]->len;\n            }\n            node->len *= node->factor;\n            return node;\n        }else{\n            node->pattern = string(1,s[p]);\n            p++;\n            node->len = r;\n            return node;\n        }\n    }\n\n    Node *node = new Node();\n    string pattern = \"\";\n    while(p < s.length() && s[p] != ')') {\n        pattern += string(1,s[p]);\n        p++;\n    }\n    node->pattern = pattern;\n    node->len = pattern.length();\n    node->factor = 1;\n    return node;\n}\n\nvoid dff(Node *v) {\n    cout<<v->len<<\" -> \"<<v->pattern<<endl;\n    for(int i=0; i<v->child.size(); ++i)\n        dff(v->child[i]);\n}\n\nchar dfs(Node *v,int idx) {\n//    cout<<idx<<\" : \"<<v->len<<\" -> \"<<v->pattern<<endl;\n    if(v->child.empty()) {\n        idx %= (v->pattern).length();\n        return (v->pattern)[idx];\n    }\n    int s = 0;\n    for(int i=0; i<(v->child).size(); ++i) {\n        if(s + (v->child[i]->len)*(v->factor) > idx) {\n            return dfs(v->child[i],(idx-s)%(v->child[i]->len));\n        }\n//        cout<<idx<<\" \"<<v->child[i]->len<<endl;\n        s += (v->child[i]->len)*(v->factor);\n    }\n}\n\nint main() {\n    int n;\n    string s;\n    while(cin>>s) {\n        cin>>n;\n        if(s == \"0\" && n == 0) break;\n        p = 0;\n        s += \")\";\n        s = \"1(\" + s;\n        Node *root = parse(s);\n\n        if(n >= root->len) {\n            cout<<\"0\"<<endl;\n            continue;\n        }\n//        dff(root);\n        cout<<dfs(root,n)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s,an;\nint n;\nvoid dfs(int x){\n  int t=0;\n  for(int i=x,c=0;i<s.size()&&0<=c;i++){\n    if(s[i]=='('){\n      while(!c&&t>0&&t--&&an.size()<=n)dfs(i+1);\n      c++;\n    }\n    if(s[i]==')')c--;\n    if(!c&&'0'<=s[i]&&s[i]<='9')t*=10,t+=s[i]-'0';\n    if(!c&&'A'<=s[i]&&s[i]<='Z')an+=s[i];\n  }\n}\n\nint main(){\n  while(cin>>s>>n&&s[0]!='0'){\n    an.clear();\n    for(int i=0;i<s.size();i++)\n      if('0'<=s[i]&&s[i]<='9'&&'A'<=s[i+1]&&s[i+1]<='Z')\n    \ts=s.substr(0,i+1)+'('+s[i+1]+')'+s.substr(i+2,s.size());\n     dfs(0);\n    if(an.size()>n)cout<<an[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() noexcept = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1000000) { num = 1000000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[200], v[200], w[200];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (pos == s.size()) {\n\t\t\t\tpos = -1, printf(\"0\\n\"); break;\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tpos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pos != -1) cout << s[pos - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        curr->children.push_back(c);\n        c->num = ck;\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      if(!s.empty() && !isdigit(s[0])) { return; }\n    }\n  }\n}\n\nstring ans;\n\nvoid visit(tree_ptr curr) {\n  if(ans.size() >= 1000000) { return; }\n  rep(i, curr->num) {\n    if (curr->children.empty()) {\n      ans += curr->s;\n      if(ans.size() >= 1000000) { return; }\n    }\n\n    rep(i, curr->children.size()) {\n      visit(curr->children[i]);\n    }\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  ans.clear();\n  visit(root);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans << endl;cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nconst LL INF=(LL)1e+9;\nLL sz(string s){\n  if(s==\"\") return 0;\n  else if('0'<=s[0] && s[0] <='9'){\n    int i=0;\n    while('0'<=s[i] && s[i] <='9') ++i;\n    LL re=stoi(string(s.begin(),s.begin()+i));\n    if(s[i]=='('){\n      int j=i;\n      int tmp=1;\n      do{\n\t++j;\n\tif(s[j]=='(') ++tmp;\n\tif(s[j]==')') --tmp;\n      }while(tmp);\n      return min(re*sz(string(s.begin()+i+1,s.begin()+j))+sz(string(s.begin()+j+1,s.end())),INF);\n    }\n    else return min(re*1+sz(string(s.begin()+i+1,s.end())),INF);\n  }else{\n    return min(1+sz(string(s.begin()+1,s.end())),INF);\n  }\n}\nchar solve(string s,LL n){\n  if(s==\"\") return '0';\n  else if('0'<=s[0] && s[0] <='9'){\n    int i=0;\n    while('0'<=s[i] && s[i] <='9') ++i;\n    LL re=stoi(string(s.begin(),s.begin()+i));\n    if(s[i]=='('){\n      int j=i;\n      int tmp=1;\n      do{\n\t++j;\n\tif(s[j]=='(') ++tmp;\n\tif(s[j]==')') --tmp;\n      }while(tmp);\n      LL szp=sz(string(s.begin()+i+1,s.begin()+j));\n      if(n<re*szp) return solve(string(s.begin()+i+1,s.begin()+j),n%szp);\n      else return solve(string(s.begin()+j+1,s.end()),n-re*szp);\n    }\n    else if(n<re) return s[i];\n    else return solve(string(s.begin()+i+1,s.end()),n-re);\n  }else{\n    if(n==0) return s[0];\n    else return solve(string(s.begin()+1,s.end()),--n);\n  }\n}\nint main(void)\n{\n  for(;;){\n    string s;\n    LL n;\n    cin >> s >> n;\n    if(s==\"0\") return 0;\n    cout << solve(s,n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\n#include<cstdlib>\n#define inf 1<<29\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nstring s;\nchar ans;\nvector<string> v;\nmap<int,int> mp;\n\nll rec(int,int);\n\nvoid rec2(int a,int b,int sum){\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1]);\n\tif(sum<tmp*atoi(v[i].c_str()))rec2(i+2,mp[i+1],sum%tmp);\n\telse sum-=tmp*atoi(v[i].c_str());\n\tif(ans!='0')return;\n        i=mp[i+1];\n      }\n      else {\n        ll tmp=atoi(v[i].c_str());\n        if(sum<tmp){\n\t  ans=v[i+1][0];\n\t  return;\n\t}\n\telse {\n\t  sum-=tmp;\n\t  i++;\n\t}\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      if(sum<v[i].length())ans=v[i][sum];\n      else sum-=v[i].length();\n    }\n    else {}\n  }\n}\n\nll rec(int a,int b){\n  ll sum=0;\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1]);\n\tif(ans!='0')return inf;\n\tsum+=atoi(v[i].c_str())*tmp;\n\ti=mp[i+1];\n      }\n      else {\n\tsum+=atoi(v[i].c_str())*v[i+1].length();\n\ti++;\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      sum+=v[i].length();\n    }\n    else {}\n  }\n  if(n<=sum)rec2(a,b,n);\n  return sum;\n}\n\nint main()\n{\n  while(1){\n    cin>>s>>n;\n    if(s[0]=='0' && n==0)break;\n    ans='0';\n    v.clear();mp.clear();\n    string tmp1=\"\",tmp2=\"\";\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tif(tmp2!=\"\")v.push_back(tmp2);\n\ttmp2=\"\";\n\ttmp1+=s[i];\n      }\n      if('A'<=s[i] && s[i]<='Z'){\n\tif(tmp1!=\"\")v.push_back(tmp1);\n\ttmp1=\"\";\n\ttmp2+=s[i];\n      }\n      if(s[i]=='('){\n\tv.push_back(tmp1);\n\ttmp1=\"\";\n\tv.push_back(\"(\");\n      }\n      if(s[i]==')'){\n        v.push_back(tmp2);\n        tmp2=\"\";\n        v.push_back(\")\");\n      }\n      if(i==s.length()-1 && tmp2!=\"\")v.push_back(tmp2);\n    }\n    stack<int> st;\n    for(int i=0;i<v.size();i++){\n      if(v[i]==\"(\")st.push(i);\n      if(v[i]==\")\"){\n\tmp[st.top()]=i;\n\tst.pop();\n      }\n    }\n    rec(0,v.size());\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n//#include<time.h>\nvoid judge_str(int start, int end,int coefficient);\nint count, flag, n;\nchar genome[101];\n\nint main()\n{\n\tint start, end;\n\t//clock_t START, END;\n\twhile (1)\n\t{\n\t\tscanf(\"%s %d\",genome,&n);\n\t\tif (genome[0] == '0'&&n == 0) break;\n\t\t//START = clock();\n\t\tcount = 0;\n\t\tflag = 1;\n\t\tfor (end = 0; genome[end] != '\\0'; end++);\n\t\tjudge_str(0, end, 1);\n\t\tif (count-1 < n)printf(\"0\\n\");\n\t\t//END = clock();\n\t\t//printf(\"%.2f秒かかりました\\n\", (double)(END - START) / CLOCKS_PER_SEC);\n\t}\n\treturn 0;\n}\nvoid judge_str(int start, int end, int coefficient)\n{\n\tint i, t,brackets=0;\n\tint c_coef[20] = {0}, start2[20], end2[20], count_str = 0;\n\n\tfor (i=0;i<coefficient && flag;i++)\n\t{\n\t\tfor (t = start; t < end && flag; t++)\n\t\t{\n\t\t\tif ('0' <= genome[t] && genome[t] <= '9')\n\t\t\t{\n\t\t\t\tc_coef[count_str] = c_coef[count_str] * 10 + genome[t]-'0';\n\t\t\t}\n\t\t\telse if (genome[t] == '(')\n\t\t\t{\n\t\t\t\tstart2[count_str] = t+1;\n\t\t\t\tt++;\n\t\t\t\tfor (brackets = 1; brackets; t++)\n\t\t\t\t{\n\t\t\t\t\tif (genome[t] == '(')brackets++;\n\t\t\t\t\tif (genome[t] == ')')brackets--;\n\t\t\t\t}\n\t\t\t\tt--;\n\t\t\t\tend2[count_str] = t;\n\t\t\t\tjudge_str(start2[count_str],end2[count_str],c_coef[count_str]);\n\t\t\t\tcount_str++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (c_coef[count_str] != 0) judge_str(t, t + 1, c_coef[count_str]);\n\t\t\t\tcount++;\n\t\t\t\tif (count - 1 == n)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%c\\n\", genome[t]);\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n//#include<time.h>\nvoid judge_str(int start, int end,int coefficient);\nint count, flag, n;\nchar genome[101];\n\nint main()\n{\n\tint start, end;\n\t//clock_t START, END;\n\twhile (1)\n\t{\n\t\tscanf(\"%s %d\",genome,&n);\n\t\tif (genome[0] == '0'&&n == 0) break;\n\t\t//START = clock();\n\t\tcount = 0;\n\t\tflag = 1;\n\t\tfor (end = 0; genome[end] != '\\0'; end++);\n\t\tjudge_str(0, end, 1);\n\t\tif (count-1 < n)printf(\"0\\n\");\n\t\t//END = clock();\n\t\t//printf(\"%.2f秒かかりました\\n\", (double)(END - START) / CLOCKS_PER_SEC);\n\t}\n\treturn 0;\n}\nvoid judge_str(int start, int end, int coefficient)\n{\n\tint i, t,brackets=0;\n\tint c_coef[500000] = {0}, start2[500000], end2[500000], count_str = 0;\n\n\tfor (i=0;i<coefficient && flag;i++)\n\t{\n\t\tfor (t = start; t < end && flag; t++)\n\t\t{\n\t\t\tif ('0' <= genome[t] && genome[t] <= '9')\n\t\t\t{\n\t\t\t\tc_coef[count_str] = c_coef[count_str] * 10 + genome[t]-'0';\n\t\t\t}\n\t\t\telse if (genome[t] == '(')\n\t\t\t{\n\t\t\t\tstart2[count_str] = t+1;\n\t\t\t\tt++;\n\t\t\t\tfor (brackets = 1; brackets; t++)\n\t\t\t\t{\n\t\t\t\t\tif (genome[t] == '(')brackets++;\n\t\t\t\t\tif (genome[t] == ')')brackets--;\n\t\t\t\t}\n\t\t\t\tt--;\n\t\t\t\tend2[count_str] = t;\n\t\t\t\tjudge_str(start2[count_str],end2[count_str],c_coef[count_str]);\n\t\t\t\tcount_str++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (c_coef[count_str] != 0) judge_str(t, t + 1, c_coef[count_str++]);\n\t\t\t\telse count++;\n\t\t\t\t if (count - 1 == n && flag)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%c\\n\", genome[t]);\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nstd::string times(const std::string &s, size_t n) {\n  std::string res;\n  for (std::string dbl=s; n; n>>=1) {\n    if (n & 1) res += dbl;\n    dbl += dbl;\n  }\n  return res;\n}\n\nstd::string parse(const std::string &s, size_t &i, size_t n) {\n  std::string res;\n  while (i < s.length()) {\n    intmax_t k=1;\n    if (isdigit(s[i])) {\n      k = s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        k = 10*k+s[i]-'0';\n    }\n    std::string t;\n    if (s[i] == '(') {\n      t = parse(s, ++i, n);\n      assert(s[i] == ')');\n      ++i;\n    } else if (isupper(s[i])) {\n      t = s[i++];\n    } else {\n      return res;\n    }\n\n    if (t.length()*k > n) throw t[n%t.length()];\n    n -= t.length()*k;\n    res += times(t, k);\n  }\n  throw '0';\n}\n\nint testcase_ends() {\n  char buf[128];\n  size_t n;\n  scanf(\"%s %zu\", buf, &n);\n  std::string s=buf;\n  if (s == \"0\" && n == 0) return 1;\n\n  size_t i=0;\n  try {\n    parse(s, i, n);\n    printf(\"0\\n\");\n  } catch (char c) {\n    printf(\"%c\\n\", c);\n  }\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nstring ans, str;\nint n, p;\n\nstring dfs(){\n    int res = 0;\n    string st = \"\";\n    while (p < str.size()) {\n        if (isdigit(str[p])) {\n            res = 0;\n            while (isdigit(str[p])) {\n                res *= 10;\n                res += str[p] - '0';\n                p++;\n            }\n        }else if (isalpha(str[p])){\n            st = \"\";\n            while (isalpha(str[p])) {\n                st += str[p];\n                p++;\n            }\n        }else if (str[p] == '('){\n            p++;\n            string tmp = dfs();\n            for (int i = 0; i < res; i++) {\n                if (st.size() > n){\n                    return st;\n                }\n                st += tmp;\n            }\n        }else if (str[p] == ')'){\n            p++;\n            return st;\n        }else{\n            break;\n        }\n    }\n    return st;\n}\n\nstring complement(string s){\n    int p = 0;\n    string expanded_string = \"\";\n    while (p < s.size()) {\n        if (isdigit(s[p]) && isalpha(s[p+1])) {\n            expanded_string += s[p++];\n            expanded_string += '(';\n            while (isalpha(s[p])) {\n                expanded_string += s[p++];\n            }\n            expanded_string += ')';\n        }else{\n            expanded_string += s[p++];\n        }\n    }\n    return expanded_string;\n}\n\nint main()\n{\n    while (true) {\n        p = 0;\n        cin >> str >> n;\n        if (str == \"0\") {\n            break;\n        }\n        str = complement(str);\n        ans = dfs();\n        if (ans.size() <= n) {\n            cout << \"0\" << endl;\n        }else{\n            cout << ans[n] << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long id, nowend = 0;\nstring s;\nchar ans;\n\nlong long solve(long long now, long long req);\nvoid solve2();\n\nint main() {\n  while(1) {\n    cin >> s >> id;\n    if(s == \"0\" && id == 0) break;\n    ans = '0';\n    solve2();\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nlong long solve(long long now, long long req) {\n  long long cnt = 0, charcnt = 1;\n  string nows;\n  if(s[now] >= '0' && s[now] <= '9') {\n    while(s[now] >= '0' && s[now] <= '9') {\n      cnt *= 10;\n      cnt += s[now++] - '0';\n    }\n    charcnt = solve(now, req);\n    cnt *= charcnt;\n    if(cnt > req) {\n      if(solve(now, req % charcnt) != -1) assert(0);\n      return -1;\n    }\n  }\n  else if(s[now] == '(') {\n    nowend = now;\n    while(nowend < s.size() && s[nowend] != ')') {\n      charcnt = solve(nowend, req - cnt);\n      if(charcnt == -1) return -1;\n      cnt += charcnt;\n    }\n    ++nowend;\n  }\n  else {\n    while(now < s.size() && s[now] >= 'A' && s[now] <= 'Z')\n      nows += s[now++];\n    if(req < nows.size()) {\n      ans = nows[req];\n      return -1;\n    }\n    nowend = now;\n    cnt = nows.size();\n  }\n  return cnt;\n}\n\nvoid solve2() {\n  nowend = 0;\n  while(nowend < s.size()) {\n    long long x = solve(nowend, id);\n    if(x < 0) return;\n    id -= x;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(pos < str.size() && isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[s1.pos] == '(') pos++;\n      State s2 = expr(str,pos);\n      \n      string tmp = \"\";\n      for(int i = 0; i < s1.int_result; i++){\n        tmp += s2.str_result;\n        if(tmp.size() > 1000000) break;\n      }\n      result += tmp;\n      pos = s2.pos + 1;\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    if(genome == \"0\" && pos == 0) break;\n    string result = expr(genome,0).str_result;\n    if(pos < result.size()){\n      cout << result[pos] << endl;      \n    }\n    else{\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\nint lenmemo[SIZE];\nint endmemo[SIZE];\n\nint len(char *s, int *pos);\n\nbool isNum(char c){\n  return '0' <= c && c <= '9';\n}\n\nbool isAlp(char c){\n  return 'A' <= c && c <= 'Z';\n}\n\nint len_factor(char *s, int *pos){\n  int res, start = *pos;\n  \n  if (s[*pos] == '(') {\n    (*pos)++;\n    res = len(s, pos);\n    (*pos)++;\n  } else {\n    res = len(s, pos);\n  }\n\n  lenmemo[start] = res;\n  endmemo[start] = (*pos);\n  \n  return res;\n}\n\nint len_num(char *s, int *pos){\n  int res = 0, start = *pos;\n  int num = 0;\n  \n  while(isNum(s[*pos])){\n    num = num * 10 + s[*pos] - '0';\n    (*pos)++;\n  }\n  \n  if (s[*pos] == '('){\n    //(*pos)++;\n    res = min((ll)num * len_factor(s, pos), 100000000LL);\n  } else {\n    (*pos)++;\n    res = min(num, 100000000);\n  }\n\n  lenmemo[start] = res;\n  endmemo[start] = *pos;\n  \n  return res;\n}\n\nint len_str(char *s, int *pos){\n  int res = 0;\n  while(1){\n    if (isNum(s[*pos])) {\n      res += len_num(s, pos);\n    } else if(isAlp(s[*pos])){\n      res++;\n      (*pos)++;\n    } else {\n      return min(res, 100000000);\n    }\n  }\n}\n\nint len(char *s, int *pos){\n  int res = 0;\n  \n  while(1){\n    if (isNum(s[*pos])) {\n      res += len_num(s,pos);\n    }else if (isAlp(s[*pos])){\n      res += len_str(s,pos);\n    }else{\n      // (*pos)++;\n      return min(res, 100000000);\n    }\n  }\n}\n\n\n\nbool solve(){\n  char s[SIZE];\n  int X;\n\n  scanf(\"%s%d\", s, &X);\n\n  if(s[0] == '0') return false;\n  \n  int pos = 0;\n  int slen = len(s, &pos);\n\n  if (slen <= X) {\n    puts(\"0\");\n    return true;\n  }\n\n  for(int i=0;i<slen;i++){\n    if(isNum(s[i])){\n      if(lenmemo[i] <= X){\n        X -= lenmemo[i];\n        i = endmemo[i] - 1;\n      } else {\n        while(!(isAlp(s[i]) || s[i] == '(')) i++;\n\n        if(s[i] == '('){\n          X %= lenmemo[i];\n        }else{\n          printf(\"%c\\n\",s[i]);\n          return true;\n        }\n      }\n    }else if(isAlp(s[i])){\n      if(X == 0){\n        printf(\"%c\\n\",s[i]);\n        return true;\n      }\n      X--;\n    }\n  }\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint number(string &s,int cur,int end){\n  // cerr << \"number: \" << s.substr(cur,end-cur+1) << endl;\n  int ret = 0;\n  for(int i=cur;i<=end;i++){\n    ret*=10;\n    ret += s[i]-'0';\n  }\n  return ret;\n}\n\nstring str(string &s,int cur,int end){\n  // cerr << \"str: \" << s.substr(cur,end-cur+1) << endl;\n  string ret = \"\";\n  for(int i=cur;i<=end;i++){\n    ret += s[i];\n  }\n  return ret;\n}\n\n// string dfs(s, cur, end)\nstring parse(string &s,int start,int end){\n  // cerr << \"parse: \" << s.substr(start,end-start+1) << endl;\n  string ret = \"\";\n  int num = 1;\n  int cur = start;\n  while(cur<=end){\n    // cerr << cur << endl;\n    if(s[cur]=='('){\n      int c = 1;\n      string str = \"\";\n      for(int i=cur+1;i<=end;i++){\n        if(s[i]=='('){\n          c++;\n        }else if(s[i]==')'){\n          c--;\n        }\n        if(c==0){\n          str = parse(s,cur+1,i-1);\n          cur = i+1;\n          break;\n        }\n      }\n      for(int i=0;i<num;i++){\n        if(ret.size()>1000100)break;\n        ret+=str;\n      }\n      num = 1;\n    }else if(isupper(s[cur])){\n      string tmp = \"\";\n      for(int i=cur;i<=end;i++){\n        if(i+1>end||!isupper(s[i+1])){\n          tmp = str(s,cur,i);\n          cur = i+1;\n          break;\n        }\n      }\n      for(int i=0;i<num;i++){\n        if(ret.size()>1000100)break;        \n        ret+=tmp;\n      }\n      num = 1;\n    }else{\n      for(int i=cur;i<=end;i++){\n        if(i+1>end||!isdigit(s[i+1])){\n          num = number(s,cur,i);\n          cur = i+1;\n          break;\n        }\n      }\n    }  \n  }\n  return ret;\n}\n\n\n\n\n\nint main(){\n  string S;\n  int num;\n  while(cin >> S >> num,S!=\"0\"){\n    string res = parse(S,0,S.size()-1);\n    // cout << res << endl;\n    if(num<res.size()){\n      cout << res[num] << endl;\n    }else{\n      cout << 0 << endl;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s,an;\nint n;\nvoid dfs(int x){\n  int t=0;\n  for(int i=x,c=0;i<s.size()&&0<=c;i++){\n    if(s[i]=='('){\n      while(!c&&t>0&&t--&&an.size()<=n)dfs(i+1);\n      c++;\n    }\n    if(s[i]==')')c--;\n    if(!c&&'0'<=s[i]&&s[i]<='9')t*=10,t+=s[i]-'0';\n    if(!c&&'A'<=s[i]&&s[i]<='Z')an+=s[i];\n  }\n}\n\nint main(){\n  while(cin>>s>>n&&s[0]!='0'){\n    an.clear();\n    for(int i=0;i<s.size();i++)\n      if('0'<=s[i]&&s[i]<='9'&&'A'<=s[i+1]&&s[i+1]<='Z')\n    \ts=s.substr(0,i+1)+'('+s[i+1]+')'+s.substr(i+2,s.size());\n     dfs(0);\n    if(an.size()>n)cout<<an[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[5000];\nint len;\n\nint solve(int const k, int l, int r)\n{\n    int cur = 0;\n    dump(k);\n    dump(l);\n    dump(r);\n    int res = 0;\n    while (s[l] && l < r)\n    {\n        while (isalpha(s[l]))\n        {\n            if (cur == k)\n            {\n                dump(k);\n                dump(s[l]);\n                throw s[l];\n            }\n            res++;\n            l++;\n            cur++;\n        }\n        int times = 0;\n        while (isdigit(s[l]))\n        {\n            times = times * 10 + s[l] - '0';\n            l++;\n        }\n        dump(l);\n        dump(times);\n        if (s[l] == '(')\n        {\n            int d = 0;\n            int i = l;\n            while (1)\n            {\n                if (s[i] == '(') d++;\n                else if (s[i] == ')') d--;\n                if (d == 0) break;\n                i++;\n            }\n            int rangelen = solve(k, l + 1, i);\n            for (int j = 0; j < times; j++)\n            {\n                res += solve(k - cur, l + 1, i);\n                cur += rangelen;\n            }\n            l = i + 1;\n        }\n        else if (isalpha(s[l]))\n        {\n            abort();\n            for (int j = 0; j < times; j++)\n            {\n\n                res += solve(k - cur, l, l + 1);\n                cur += 1;\n            }\n            l = l + 1;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    static char t[5000];\n    int k;\n    while (cin >> t >> k && t[0] != '0')\n    {\n        int tlen = strlen(t);\n        len = 0;\n        for (int i = 0; i < tlen; i++)\n        {\n            if (i>0 && isdigit(t[i - 1]) && isalpha(t[i]))\n            {\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            }\n            else\n            {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n\n        try\n        {\n            solve(k, 0, len);\n            puts(\"0\");\n        }\n        catch (char e)\n        {\n            cout << e << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n\n#define MAX_LEN 1000002\n\nusing namespace std;\n\ntypedef pair<string,int> parsed;\nparsed parse(const string &expr, int i)\n{\n  parsed ret;\n  string s;\n\n  int d=1;\n  if( isdigit( expr[i] ) ){\n    d=0;\n    while( isdigit( expr[i] ) ){\n      int t = expr[i++]-'0';\n      d*=10;\n      d+=t;\n    }\n  }\n\n  if( expr[i] == '(' ){\n    ++i;\n    while(expr[i]!=')'){\n      parsed p = parse(expr,i);\n      s += p.first;\n      i = p.second;\n    }\n    ++i;\n  }else{\n    while( isalpha( expr[i] ) ){\n      s+=expr[i++];\n    }\n  }\n\n  for(int j = 0; j < d; ++j){\n    ret.first+=s;\n    if( ret.first.length() > MAX_LEN )\n      break;\n  }\n\n  ret.second = i;\n  return ret;\n}\n\nchar solve(const string &expr, int n)\n{\n  parsed ans;\n\n  while(ans.second<expr.size()){\n    parsed p = parse(expr,ans.second);\n    ans.first += p.first;\n    if(ans.first.length()>MAX_LEN)break;\n    ans.second = p.second;\n  }\n  //if(ans.first.length()<500)\n    //cout<<\"RESULT:\"<<ans.first<<endl;\n\n  if(n<0||n>=ans.first.length())\n    return '0';\n  else\n    return ans.first[n];\n\n}\n\nint main()\n{\n  while(true){\n    string expr;\n    int n;\n    cin>>expr>>n;\n    if(expr==\"0\"&&n==0)\n      break;\n    cout << solve(expr,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nlong long int getlen(string s)\n{\n\tlong long int ans = 0;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(isdigit(s[i])){\n\t\t\tlong long int num = s[i] - '0';\n\t\t\ti++;\n\t\t\twhile(isdigit(s[i])){\n\t\t\t\tnum = num * 10 + (s[i] - '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(s[i] != '('){\n\t\t\t\tans += num;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint kakko = 1;\n\t\t\tint tmp = i + 1;\n\t\t\twhile(kakko > 0){\n\t\t\t\tif(s[tmp] == '(') kakko++;\n\t\t\t\telse if(s[tmp] == ')') kakko--;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tstring tmps = s.substr(i + 1, tmp - 1 - (i + 1));\n\t\t\tans += num * getlen(tmps);\n\t\t\ti = tmp - 1;\n\t\t} else {\n\t\t\tans++;\n\t\t}\n\t\tif(ans > mod) ans = mod;\n\t}\n\t// cout << s << \" \" << ans << endl;\n\treturn ans;\n}\n\nchar solve(string s, int n)\n{\n\t// cout << s << n << endl;\n\tlong long int nowlen = 0;\n\tbool allchar = true;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(isdigit(s[i])){\n\t\t\tallchar = false;\n\t\t\tlong long int num = s[i] - '0';\n\t\t\ti++;\n\t\t\twhile(isdigit(s[i])){\n\t\t\t\tnum = num * 10 + (s[i] - '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(s[i] != '('){\n\t\t\t\t// cout << s[i] << nowlen + num << endl;\n\t\t\t\tif(nowlen + num > n) return s[i];\n\t\t\t\telse {\n\t\t\t\t\tnowlen += num;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint kakko = 1;\n\t\t\tint tmp = i + 2;\n\t\t\twhile(kakko > 0){\n\t\t\t\tif(s[tmp] == '(') kakko++;\n\t\t\t\telse if(s[tmp] == ')') kakko--;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tstring tmps = s.substr(i + 1, tmp - 1 - (i + 1));\n\t\t\tlong long int tmpl = getlen(tmps);\n\t\t\t// cout << tmps << \" \" << tmpl << \" \" << nowlen << \" \" << n << \" \" << num << endl;\n\t\t\tif(nowlen + num * tmpl > n) return solve(tmps, (n - nowlen) % tmpl);\n\t\t\ti = tmp - 1;\n\t\t\tnowlen += num * tmpl;\n\t\t\t// cout << nowlen << endl;\n\t\t} else {\n\t\t\tnowlen++;\n\t\t}\n\t}\n\tif(allchar && n < s.length()) return s[n];\n\treturn '0';\n}\n\nint main()\n{\n\tstring s;\n\tint n;\n\twhile(1){\n\t\tcin >> s >> n;\n\t\tif(s == \"0\") break;\n\t\tcout << solve(s, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem1145 : The Genome Database of All Space Life**/\nstring s, ret;\nint pos, idx;\n// <code> := <num> <c> | <num> ( <code> ) | <num> ( <code> <code> ) | ...\n// <num> := <digit> | <digit> <num>\n// <c> := A | B | ... | Z\n\nstring factor()\n{\n\tif ('A' <= s[pos] && s[pos] <='Z') {\n\t\t\n\t}\n}\n\nstring formula()\n{\n\tstring ret=\"\";\n\t\n\tif ('A' <= s[pos] && s[pos] <= 'Z') {\n\t\tret = s[pos];\n\t\tpos++;\n\t} else if (isdigit(s[pos])) {\n\t\tint num = 0;\n\t\twhile (isdigit(s[pos])) {\n\t\t\tnum*=10;\n\t\t\tnum+=s[pos]-'0';\n\t\t\tpos++;\n\t\t}\n\t\tstring ss = formula();\n\t\trep(i, num) {\n\t\t\tret += ss;\n\t\t\tif (ret.size()>idx)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (s[pos] == '(') {\n\t\tpos++;\n\t\twhile (s[pos] != ')') {\n\t\t\tret += formula();\n\t\t}\n\t\tpos++;\n\t}\n\t\n\treturn ret;\n}\n\nint main()\n{\n\twhile (cin>>s>>idx, s!=\"0\"||idx) {\n\t\tpos = 0;\n\t\tret = \"\";\n\t\t\n\t\twhile (pos != s.size()) {\n\t\t\tret += formula();\n\t\t\tif (ret.size() > idx)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (idx>=ret.size())\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << ret[idx] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[2];\nint n,ima;\n\n\nint stoi(int &i){\n  int res=0;\n  while('0'<=str[ima][i]&&str[ima][i]<='9')res=res*10+str[ima][i]-'0',i++;\n  return res;\n}\n\n\nint main(){\n  while(1){\n\n    cin>>str[1]>>n;\n    if(str[1]==\"0\"&&n==0)break;\n    str[0].clear();\n    for(int i=0;i<str[1].size();i++) {\n      if(str[1][i]=='('&&str[1][i+2]==')') str[0]+=str[1][i+1],i+=2;\n      else str[0]+=str[1][i];\n    }\n    str[1].clear();    \n\n    ima=0;\n    int f=1;\n    int flg=1;\n    while(f){\n      f=0;\n      str[!ima].clear();\n      for(int i=0;i<(int)str[ima].size();i++){\n\tif(!('0'<=str[ima][i]&&str[ima][i]<='9')) str[!ima]+=str[ima][i];\n\telse {\n\t  f=1;\n\t  int num=stoi(i);\n\t  string pls;\n\t  if(str[ima][i]!='(') pls+=str[ima][i];\n\t  else {\n\t    int c=1;\n\t    while(c){\n\t      i++;\n\t      if(str[ima][i]=='(')c++;\n\t      if(str[ima][i]==')')c--;\n\t      if(c) pls+=str[ima][i];\n\t    }\n\t  }\n\t  while(num--&&(int)str[!ima].size()<=n) str[!ima]+=pls;\n\t}\n      }\n      \n      ima=!ima;\n    }\n    //cout <<str[ima]<<endl;\n    if((int)str[ima].size()<=n&&flg) cout <<0<<endl;\n    else cout << str[ima][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint n;\nstring dfs(int x){\n  int a=1,t=0;\n  string str,res;\n  for(int i=x;0<a;i++){\n    if('0'<=s[i]&&s[i]<='9')t*=10,t+=s[i]-'0';\n    else if(s[i]=='('&&a==1){\n      res=dfs(i+1);\n      t=max(1,t);\n      while(t--)str+=res;\n      a++;\n    }\n    else if(s[i]==')')a--;\n    else if(a==1)str+=s[i];\n  }\n  return str;\n}\nint main(){\n  while(cin>>s>>n){\n    s+=\")\";\n    string ans=dfs(0);\n    cout<<ans<<endl;\n    if(ans.size()>n)\n      cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint n;\nint len;\nchar loop(string s){\n\tint num = 0;\n\tstring ss = \"\";\n\tREP(i, s.length()){\n\t\tif (isdigit(s[i])){\n\t\t\tnum *= 10;\n\t\t\tnum += s[i] - '0';\n\t\t}\n\n\t\tif (s[i] == '('){\n\t\t\tchar c;\n\t\t\tREP(j, num){\n\t\t\t\tc = loop(s.substr(i + 1));\n\t\t\t\tif (c != '0')\n\t\t\t\t\treturn c;\n\t\t\t}\n\t\t\tnum = 0;\n\t\t\tint nu = 0;\n\t\t\twhile (1){\n\t\t\t\tif (s[i] == ')')nu--;\n\t\t\t\tif (s[i] == '(')nu++;\n\t\t\t\tif (nu == 0)break;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')'){\n\t\t\tif (n-len < ss.length()){\n\t\t\t\t\n\t\t\t\treturn ss[(n - len)];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tlen += ss.length();\n\t\t\t\treturn '0';\n\t\t\t}\t\n\t\t}\n\t\tif ('A' <= s[i] && s[i] <= 'Z'){\n\t\t\tREP(j,num)\n\t\t\t\tss += s[i];\n\t\t\tif (num==0)\n\t\t\t\tss += s[i];\n\t\t}\n\t}\n\n\tif (n-len < ss.length()){\n\t\treturn ss[(n - len)];\n\t}\n\telse{\n\t\t\n\t\tlen += ss.length();\n\t\treturn '0';\n\t}\n}\n\n\nint main() {\n\tstring s;\n\twhile (cin>>s>>n,s!=\"0\"){\n\t\tlen = 0;\n\n\t\tcout << loop(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nstring s;\nint id;\n\nstruct Node {\n    int v;\n    string s;\n    vector<Node> children;\n    Node(int v_, string s_) : v(v_), s(s_){}\n    void print() {\n        if (children.size() == 0) {\n            cout << s;\n            return;\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                this->children[j].print();\n            }\n        }\n    }\n\n    int sum_v() {\n        int res = 0;\n        if (children.size() == 0) return s.size();\n        rep(i, (int)children.size()) {\n            res += children[i].sum_v();\n        }\n        return res * v;\n    }\n\n    char ans(int& cur_id) {\n        if (children.size() == 0) {\n            if (id - cur_id < (int)s.size()) {\\\n                return s[id - cur_id];\n            }\n            else {\n                cur_id += s.size();\n                return '0';\n            }\n        }\n        if (not (id - cur_id < sum_v()) ) {\n            cur_id += sum_v();\n            return '0';\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                char res = children[j].ans(cur_id);\n                if (isalpha(res)) return res;\n            }\n        }\n        return '0';\n    }\n};\n\nNode make_tree(int& i) {\n    Node cur_node(1, \"\");\n    while (s[i] != ')' && s[i] != '\\0') {\n        if (isdigit(s[i])) {\n            char *e;\n            int v = strtol(&s[i], &e, 10);\n            if (test) dump(e);\n            i += (e - &s[i]);\n            if (s[i] == '(') i++;\n            if (test) dump(s[i]);\n            Node child = make_tree(i);\n            child.v = v;\n            cur_node.children.push_back(child);\n            if (i < (int)s.size() && s[i] == ')') i++;\n            if (test) cout << \"2:\";\n            if (test) dump(s[i]);\n        }\n        else {\n            int start = i;\n            while (isalpha(s[i])) i++;\n            int end = i;\n            cur_node.children.push_back(Node(1, s.substr(start, end-start)));\n            if (test) dump(cur_node.children.back().s);\n        }\n    }\n    return cur_node;\n}\n\nvoid solve() {\n    cin >> s >> id;\n    if (s == \"0\") exit(0);\n    int id = 0;\n    Node root = make_tree(id);\n\n    if (false) {\n        root.print();\n        cout << endl;\n    }    \n    dump(root.sum_v());\n    \n    id = 0;\n    cout << root.ans(id) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nconst int MAX=1e6+1;\n\ntypedef long long Int;\n\nInt cnt(int& p);\n\nInt get_num(int& p){\n  int res=0;\n  while(isdigit(s[p])){\n    res*=10;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nInt cnt_large(int& p){\n  Int res=0;\n  while(s[p]!=')'){\n    Int val=cnt(p);\n    res+=val;\n    if(res>MAX) return MAX;\n  }\n  return res;\n}\n\n\nInt cnt(int& p){\n  if(isalpha(s[p])){\n    p++;\n    return 1;\n  }\n  if(isdigit(s[p])){\n    Int num=get_num(p);\n    if(isalpha(s[p])){\n      p++;\n      return num;\n    }\n    assert(s[p]=='(');\n    p++;\n    Int val=cnt_large(p);\n    assert(s[p]==')');\n    p++;\n    if(val>MAX){\n      return MAX;\n    }\n    if(num*val>MAX) return MAX;\n    return num*val;\n  }\n  return -1000000;\n}\n\nchar target(int &p,Int x){\n  while(p<s.size()){\n    int prep=p;\n    Int val=cnt(p);\n    if(val>=x){\n      p=prep;\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      Int num=get_num(p);\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      assert(s[p]=='(');\n      p++;\n      int prep2=p;\n      Int val2=cnt_large(p);\n      p=prep2;\n      return target(p,(x%val2==0) ? val2 : x%val2);\n    }\n    x-=val;\n  }\n  return '0';\n}\n\nint main(){\n  int n;\n  while(cin>>s>>n,s!=\"0\"){\n\n  int p=0;\n  cout<<target(p,n+1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\n\nconst int MAX = 1000001;\n\n/*\n  <DNA> := (<string>) || <char> || <number><DNA> || <number><DNA> <number><DNA>\n  <string> := <string> <char> || <char>\n  <char> := 'A'-'Z'\n  <number> := 0-1000\n */\n\nbool isNum(char c){return '0' <= c && c <= '9';}\nbool isAlf(char c){return 'A' <= c && c <= 'Z';}\n\nbool isChar(string s){\n  if(s.length() != 1) return false;\n  return isAlf(s[0]);\n}\n\nbool isString(string s){\n  for(int i = 0; i < s.length(); i++)\n    if(!isAlf(s[i])) return false;\n  return true;\n}\n\nbool isNumberDNA(string s){\n  int pos=0;\n  for(int i = 0; i < s.length() && isNum(s[i]); i++) pos++;\n  string tmp = s.substr(pos);\n\n  if(tmp.length() == 1) return isAlf(tmp[0]);\n  \n  int p = 0;\n\n  for(int i = 0; i < tmp.length()-1; i++){\n    if(tmp[i] == '(') p++;\n    if(tmp[i] == ')') p--;\n    if(p == 0) return false;\n  }\n  return true;\n}\n\nstring rmPara(string s){\n  int st = 0, en = s.length()-1;\n  if(s[st] != '(' || s[en] != ')') return s;\n  int p = 0;\n  for(int i = 0; i < en; i++){\n    if(s[i] == '(') p++;\n    if(s[i] == ')') p--;\n    if(p == 0) return s;\n  }\n  return s.substr(1,s.length()-2);\n}\n\n\nstring parse(string s){\n\n  s = rmPara(s);\n\n  if(isString(s) || isChar(s)) return s;\n\n  // cout << \"s \" << s << endl;\n   if(isNumberDNA(s)){\n    int pos = 0;\n    for(int i = 0; i < s.length() && isNum(s[i]); i++) pos++;\n    string nums = s.substr(0,pos);\n    string other = s.substr(pos);\n  \n    stringstream ss(nums);\n    int num;\n    ss >> num;\n    string ret = \"\";\n    string tmp = parse(other);\n    for(int i = 0; i < num; i++){\n      if(ret.length() > MAX) return ret.substr(0,MAX);\n      ret += tmp;\n    }\n    return ret;    \n  }else{\n   \n    int pos = 0;\n    for(int i = 0; i < s.length() && isNum(s[i]); i++) pos++;\n\n    int p = 0;\n\n    for(int i = pos; i < s.length(); i++){\n      if(s[i] == '(') p++;\n      if(s[i] == ')') p--;\n      pos++;\n      if(!isNum(s[i]) && p == 0) break;\n    }\n    \n    string A = s.substr(0,pos);\n    string B = s.substr(pos);\n    string C = parse(A)+parse(B);\n    int len = min((int)C.length(),MAX);\n    return C.substr(0,len);\n  }\n}\n\n\nint main(){\n  string s;\n  int n;\n\n  while(cin >> s >> n && s != \"0\"){\n    string ans = parse(s);\n    if(ans.length() > n) cout << ans[n] << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n\nstruct Node{\n    ll size;\n    ll repeat;\n    string s;\n    vector<Node> v;\n    Node(){\n        size = 0;\n        repeat = 0;\n        s = \"\";\n    }\n    Node(ll size, ll repeat, string s){\n        this->size = size;\n        this->repeat = repeat;\n        this->s = s;\n    }\n};\n\nll fetch(const string &s, ll index){\n    ll po = 1;\n    for(ll i = index + 1; i < s.size(); i++){\n        if(s[i] == '(') po++;\n        else if(s[i] == ')') po--;\n        if(!po) return i;\n    }\n}\n\nNode dfs(const string &s){\n    ll num = 0;\n    string t = \"\";\n    Node ret(0, 1, \"\");\n    auto f = [&]{\n        if(t != \"\"){\n            ret.v.push_back(Node(t.size(), 1, t));\n            t = \"\";\n        }\n    };\n\n    for(ll i = 0; i < s.size(); i++){\n        if('0' <= s[i] && s[i] <= '9'){\n            f();\n            num = 10 * num + s[i] - '0';\n        }else if('A' <= s[i] && s[i] <= 'Z'){\n            for(ll j = 0; j < max<ll>(1, num); j++) t += s[i];\n            num = 0;\n        }else if(s[i] == '('){\n            f();\n            ll fe = fetch(s, i);\n            Node tmp = dfs(s.substr(i + 1, (fe - 1) - (i + 1) + 1));\n            tmp.repeat = max<ll>(1, num);\n            i = fe;\n            num = 0;\n            ret.v.push_back(tmp);\n        }\n    }\n    if(t != \"\") f();\n    for(auto child : ret.v){\n        ret.size += child.size * child.repeat;\n        if(ret.size > 1000002) ret.size = 1000002;\n    }\n    if(ret.size < 1000002) ret.size = ret.repeat * (ret.size + ret.s.size());\n    return ret;\n}\n\nchar solve(const Node &n, ll i){\n    if(n.s.size() > i) return n.s[i];\n    for(auto child : n.v){\n        if(child.size * child.repeat <= i){\n            i -= child.size * child.repeat;\n        }else{\n            return solve(child, i % child.size);\n        }\n    }\n    //return n.s[i];\n}\n\nint main(){\n    while(1){\n        string S;\n        ll I;\n        cin >> S >> I;\n        if(S == \"0\" && !I) break;\n        S = \"(\" + S + \")\";\n        auto node = dfs(S);\n        if(node.size <= I) cout << 0 << endl;\n        else cout << solve(node, I) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstring s;\nint pos;\n\nstruct NODE{\n\tstring s;\n\tlong long size;\n\tvector< pair<NODE*,int> > ch;\n};\n\n\nNODE* getStringNode(){\n\tNODE *ans = new NODE();\n\twhile(s[pos] >= 'A' && s[pos] <= 'Z'){\n\t\tans->s += s[pos++];\n\t}\n\tans->size = (ans->s).size();\n\treturn ans;\n}\nint getNumber(){\n\tint ans = 0;\n\twhile(s[pos] >= '0' && s[pos] <= '9'){\n\t\tans = ans * 10 + s[pos++]-'0';\n\t}\n\treturn ans;\n}\n\nNODE* parse(){ \n\tNODE *mine = new NODE();\n\t\n\tmine->size = 0;\n\t\n\tint coef = 1;\n\twhile(s[pos] != ')'){\n\t\t//cout << s[pos] << \" < \" << pos << \" \" << s << endl;\n\t\tif( s[pos] == '('){\n\t\t\tpos++;\n\t\t\tmine->ch.push_back(make_pair(parse(),coef));\n\t\t\tcoef = 1;\n\t\t}else if('1' <= s[pos] && s[pos] <= '9'){\n\t\t\tcoef = getNumber();\n\t\t}else{\n\t\t\t(mine->ch).push_back(make_pair(getStringNode(),coef));\n\t\t\tcoef = 1;\n\t\t}\n\t}\n\t\n\t//cout << mine->ch.size() << endl;\n\tfor(int i = 0 ; i < (mine->ch).size() ; i++){\n\t\t//cout << \" \" << (mine->ch)[i].second << \" \" << mine->ch[i].first->size << endl;\n\t\tmine->size += (mine->ch)[i].second * mine->ch[i].first->size;\n\t\tmine->size = min(2000000ll,mine->size);\n\t}\n\tpos++;\n\treturn mine;\n}\nchar f(NODE *root,int K){\n\tif( root->s.size() != 0 ){\n\t\treturn root->s[K];\n\t}\n\t\n\tfor(int i = 0 ; i < root->ch.size() ; i++){\n\t\tlong long C = (root->ch)[i].second * root->ch[i].first->size;\n\t\tif( K < C ){\n\t\t\tK %= root->ch[i].first->size;\n\t\t\treturn f(root->ch[i].first,K);\n\t\t}else{\n\t\t\tK -= C;\n\t\t}\n\t}\n\treturn '0';\n}\n\nint main(){\n\tint n;\n\twhile(cin >> s >> n && s != \"0\"){\n\t\tpos = 0;\n\t\ts += \")\";\n\t\tNODE *root = parse();\n\t\t//cout << root->size << endl;\n\t\tcout << f(root,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\nll dp[101][101];\n\nint cp=-1;\nint idx;\nchar result=0;\n\n\n// ツ嘉ーツ静債つオツづ按つェツづァツカツウツδ督トツつオツづつ「ツつュ\nvoid dfs(string str){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tdfs(subs);\n\t\t\t\t\tif(result!=0){\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//resCnt+=an*cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//return pos-1;\n\t\t}\n\t}\n}\n\n\n\t\nint main(){\n\n\tstring str;\n\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tcp=-1;\n\t\t//char r=rec(str,idx);\n\t\tresult=0;\n\t\tdfs(str);\n\t\tif(result==0){\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<result<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\n#include<string.h>\n\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef long long LL;\ntemplate<typename T>\nbool chmin(T &l, T r) {\n\tbool f = l > r; if (f)l = r; return f;\n}\ntemplate<typename T>\nbool chmax(T &l, T r) {\n\tbool f = l < r; if (f)l = r; return f;\n}\nVV wrap(VV vs, int c) {\n\tint R = vs.size();\n\tint C = vs[0].size();\n\tVV ret(R + 2, V(C + 2, c));\n\tREP(i, R)REP(j, C)ret[i + 1][j + 1] = vs[i][j];\n\treturn ret;\n}\nconst int dr[] = { 0,0,-1,1 ,1,1,-1,-1 };\nconst int dc[] = { -1,1,0,0, -1,1,-1,1 };\nstring S;\nint id;\nVV g;\nLL rep[1123];\nLL len[1123];\nchar type[1123];\nLL parseInt() {\n\tLL ret = 0;\n\twhile (isdigit(S[id])) {\n\t\tret *= 10;\n\t\tret += S[id] - '0';\n\t\tid++;\n\t}\n\treturn ret;\n}\nV parse() {\n\tV ret;\n\tid++;\n\twhile (S[id] != ')') {\n\t\tg.push_back({});\n\t\tint v = g.size();\n\t\tret.push_back(v);\n\t\tif (isdigit(S[id])) {\n\t\t\trep[v] = parseInt();\n\t\t\tif (S[id] == '(') {\n\t\t\t\ttype[v] = '-';\n\t\t\t\tg[v] = parse();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype[v] = S[id++];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trep[v] = 1;\n\t\t\ttype[v] = S[id++];\n\t\t}\n\t}\n\tid++;\n\treturn ret;\n}\nconst LL INF = 1e9;\nLL dfs(int v) {\n\tif (type[v] == '-') {\n\t\tlen[v] = 0;\n\t\tfor (auto &it : g[v])len[v] += dfs(it);\n\t\tchmin(len[v], INF);\n\t}\n\telse {\n\t\tlen[v]=1;\n\t}\n\treturn min(len[v]*rep[v],INF);\n}\nchar f(int v,LL x){\n\tif (type[v] == '-') {\n\t\tx %= len[v];\n\t\tfor (auto &u : g[v])\n\t\t\tif (x < len[u] * rep[u])return f(u, x);\n\t\t\telse x -= len[u] * rep[u];\n\t}\n\telse {\n\t\treturn type[v];\n\t}\n\n}\nint main() {\n\tLL x;\n\twhile (cin >> S >> x, S != \"0\") {\n\t\tS = \"(\" + S + \")\";\n\t\tid = 0;\n\t\tg.clear();\n\t\tg.push_back({});\n\t\trep[0] = 1;\n\t\ttype[0] = '-';\n\t\tg[0] = parse();\n\t\tLL all=dfs(0);\n\t\tif (all <= x)cout << 0 << endl;\n\t\telse cout << f(0,x) << endl;\n\t}\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tchar c;\n\tint num;\n\tint total;\n\tvector<Node> child;\n\tNode(int num0, char c0){\n\t\tnum = num0;\n\t\tc = c0;\n\t\ttotal = 0;\n\t}\n};\n\nvoid solve(string s, int a)\n{\n\tNode root(1, '(');\n\tNode* pNode = &root;\n\tstack<Node*> stkNode;\n\tistringstream iss(s);\n\n\tfor(;;){\n\t\tint tmp;\n\t\tif(!(iss >> tmp)){\n\t\t\tif(iss.eof())\n\t\t\t\tbreak;\n\t\t\ttmp = 1;\n\t\t\tiss.clear();\n\t\t}\n\t\tchar c;\n\t\tiss >> c;\n\t\tif(c == ')'){\n\t\t\tpNode = stkNode.top();\n\t\t\tstkNode.pop();\n\t\t\tpNode->total += pNode->num * pNode->child.rbegin()->total;\n\t\t\tif(pNode->total > 1000001)\n\t\t\t\tpNode->total = 1000001;\n\t\t}else{\n\t\t\tpNode->child.push_back(Node(tmp, c));\n\t\t\tif(c == '('){\n\t\t\t\tstkNode.push(pNode);\n\t\t\t\tpNode = &(*pNode->child.rbegin());\n\t\t\t}else{\n\t\t\t\tpNode->child.rbegin()->total = tmp;\n\t\t\t\tpNode->total += pNode->num * tmp;\n\t\t\t\tif(pNode->total > 1000001)\n\t\t\t\t\tpNode->total = 1000001;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(pNode->total <= a){\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\n\tfor(;;){\n\t\ta %= pNode->total / pNode->num;\n\t\tfor(int i=0; ; ++i){\n\t\t\tif(a < pNode->child[i].total){\n\t\t\t\tpNode = &(pNode->child[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta -= pNode->child[i].total;\n\t\t}\n\t\tif(pNode->c != '('){\n\t\t\tcout << pNode->c << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring s;\n\t\tint a;\n\t\tcin >> s >> a;\n\t\tif(s == \"0\" && a == 0)\n\t\t\tbreak;\n\n\t\tsolve(s, a);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nInt g(string s){\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s))return sz(s);\n\tInt c=0,q,r,times=0;\n\trepn0(q,p,sz(s)-1){\n\t\tif(!isdigit(s[q]))break;\n\t\ttimes=times*10+s[q]-'0';\n\t}\n\tif(s[q]!='('){\n\t\ts=s.substr(0,q)+\"(\"+s.substr(q,1)+\")\"+s.substr(q+1);\n\t}\n\trep0(r,sz(s)){\n\t\tif(s[r]=='(')++c;\n\t\tif(s[r]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\treturn min(1000001LL,p+times*g(s.substr(q+1,r-q-1))+g(s.substr(r+1)));\n}\n\nchar f(string s,Int i){\n//cout<<s<<\" \"<<i<<endl;\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s)){\n\t\tif(i<p)return s[i];\n\t\telse return '0';\n\t}\n\tif(i<p)return s[i];\n\ts=s.substr(p);\n\ti-=p;\n\tInt c=0,q,times=0;\n\trep0(p,sz(s)){\n\t\tif(!isdigit(s[p]))break;\n\t\ttimes=times*10+s[p]-'0';\n\t}\n\tif(s[p]!='('){\n\t\ts=s.substr(0,p)+\"(\"+s.substr(p,1)+\")\"+s.substr(p+1);\n\t}\n\trep0(q,sz(s)){\n\t\tif(s[q]=='(')++c;\n\t\tif(s[q]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\tInt len=g(s.substr(p+1,q-p-1));\n\tif(len*times>i){\n\t\ti%=len;\n\t\treturn f(s.substr(p+1,q-p-1),i);\n\t}else{\n\t\ti-=len*times;\n\t\treturn f(s.substr(q+1),i);\n\t}\n}\n\nint main() {\n\tstring s;\n\tInt i;\n\tIL{\n\t\tcin>>s>>i;\n\t\tif(s==\"0\"&&i==0)break;\n\t\tcout<<f(s,i)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef string::const_iterator State;\nstring s;\nint ref;\nstring expr(State& be){\n\tstring ret;\n\twhile(true){\n\t\tint x=1;\n\t\tif(isdigit(*be)){\n\t\t\tx=0;\n\t\t\twhile(isdigit(*be)){\n\t\t\t\tx*=10;\n\t\t\t\tx+=(*be)-'0';\n\t\t\t\tbe++;\n\t\t\t}\n\t\t}\n\t\tif(*be=='('){\n\t\t\tbe++;\n\t\t\tstring t=expr(be);\n\t\t\trep(i,x){\n\t\t\t\tif(ret.size()>ref) break;\n\t\t\t\tret+=t;\n\t\t\t}\n\t\t\tbe++;\n\t\t}else if('A'<=*be && *be<='Z'){\n\t\t\trep(i,x){\n\t\t\t\tif(ret.size()>ref) break;\n\t\t\t\tret+=(*be);\n\t\t\t}\n\t\t\tbe++;\n\t\t}else break;\n\t\tif(ret.size()>ref) break;\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tcin>>s>>ref;\n\t\tif(s[0]=='0') break;\n\t\tState be=s.begin();\n\t\tstring t=expr(be);\n\t\tif(t.size()<=ref) cout << \"0\\n\";\n\t\telse cout << t[ref]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse {\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  int j;\n\t  for(j=0;j<dig&&s[!c].size()+pls.size()<n+200;j++)s[!c]+=pls;\n\t  if(s[!c].size()<n&&j<dig)assert(1);\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if((int)s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nint length(const string& s,int begin,int end)\n{\n\tll res=0;\n\tfor(int i=begin;i<end;i++){\n\t\tif(isdigit(s[i])){\n\t\t\tint r=0;\n\t\t\twhile(isdigit(s[i]))\n\t\t\t\tr=r*10+s[i++]-'0';\n\t\t\tif(s[i]=='('){\n\t\t\t\tint j=i;\n\t\t\t\tfor(int k=0;j<s.size();j++){\n\t\t\t\t\tif(s[j]=='(') k++;\n\t\t\t\t\tif(s[j]==')') k--;\n\t\t\t\t\tif(k==0) break;\n\t\t\t\t}\n\t\t\t\tres+=(ll)r*length(s,i+1,j);\n\t\t\t\ti=j;\n\t\t\t}\n\t\t\telse\n\t\t\t\tres+=r;\n\t\t}\n\t\telse\n\t\t\tres++;\n\t\tres=min<ll>(res,INFTY);\n\t}\n\treturn res;\n}\n\nchar solve(const string& s,int index,int ci)\n{\n\tfor(;ci<s.size();){\n\t\tif(isdigit(s[ci])){\n\t\t\tint r=0,i=ci;\n\t\t\twhile(isdigit(s[i]))\n\t\t\t\tr=r*10+s[i++]-'0';\n\t\t\tif(s[i]=='('){\n\t\t\t\tint j=i;\n\t\t\t\tfor(int k=0;j<s.size();j++){\n\t\t\t\t\tif(s[j]=='(') k++;\n\t\t\t\t\tif(s[j]==')') k--;\n\t\t\t\t\tif(k==0) break;\n\t\t\t\t}\n\t\t\t\tint len=length(s,i+1,j);\n\t\t\t\tif((ll)r*len>index)\n\t\t\t\t\treturn solve(s,index%len,i+1);\n\t\t\t\telse{\n\t\t\t\t\tindex-=r*len;\n\t\t\t\t\tci=j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(r>index)\n\t\t\t\t\treturn s[i];\n\t\t\t\telse{\n\t\t\t\t\tindex-=r;\n\t\t\t\t\tci=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(index==0)\n\t\t\t\treturn s[ci];\n\t\t\telse{\n\t\t\t\tindex--;\n\t\t\t\tci++;\n\t\t\t}\n\t\t}\n\t}\n\treturn '0';\n}\n\nint main()\n{\n\tfor(string s;cin>>s && s!=\"0\";){\n\t\tint index; cin>>index;\n\t\tcout<<solve(s,index,0)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nstring s;\nint x;\nbool done;\nint p;\n\nbool exec(){\n  if(isdigit(s[p])){\n    int n = 0;\n    while(isdigit(s[p])){\n      n = n*10 + s[p] - '0';\n      p++;\n    }\n    if(isalpha(s[p])){\n      if(x > n){\n        x -= n;\n        p++;\n      }\n      else {\n        cout << s[p] << endl;\n        return true;\n      }\n    }\n    else {\n      p++; // (\n      int f = p;\n      rep(i,n){\n        p = f;\n        if(exec()) return true;\n      }\n      p++; // )\n    }\n  }\n  while(isalpha(s[p])){\n    x--;\n    if(x==0){\n      cout << s[p] << endl;\n      return true;\n    }\n    p++;\n  }\n\n  if(s[p]==')' || p==s.size()) return false;\n  else return exec();\n}\n\nint main(){\n  while(cin>>s>>x, s!=\"0\"){\n    done = false;\n    p = 0;\n    x++;\n    if( ! exec() ){\n      cout << 0 << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[s1.pos] == '(') pos++;\n      State s2 = expr(str,pos);\n      \n      string tmp = \"\";\n      for(int i = 0; i < s1.int_result; i++){\n        tmp += s2.str_result;\n        if(tmp.size() > 1000000) break;\n      }\n      result += tmp;\n      pos = s2.pos + 1;\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    cout << expr(genome,0).str_result[pos] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma comment (linker, \"/STACK:526000000\")\n#define  _CRT_SECURE_NO_WARNINGS\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\nint k;\n\nint num(State& begin) {\n\tint geko = 0;\n\twhile (*begin >= '0' && *begin <= '9') {\n\t\tgeko *= 10;\n\t\tgeko += *begin - '0';\n\t\tbegin++;\n\t}\n\tif (geko == 0) geko = 1;\n\treturn geko;\n}\n\nstring solve(State& begin) {\n\tstring ans;\n\twhile (*begin != ')') {\n\t\tint now = num(begin);\n\t\tif (*begin == '(') {\n\t\t\tbegin++;\n\t\t\tstring b = solve(begin);\n\t\t\tREP(q, now) {\n\t\t\t\tans += b;\n\t\t\t\tif (ans.length() >= k) break;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tREP(q, now) {\n\t\t\t\tans.push_back(*begin);\n\t\t\t}\n\t\t\tbegin++;\n\t\t}\n\t\twhile (ans.length() > k) {\n\t\t\tans.pop_back();\n\t\t}\n\t}\n\tbegin++;\n\treturn ans;\n}\n\nvoid solve(){\n\twhile(true){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s == \"0\") return;\n\t\ts.push_back(')');\n\t\tcin >> k;\n\t\tk++;\n\t\tState begin = s.begin();\n\t\tstring ans = \"0\" + solve(begin);\n\t\tif (ans.size() - 1 >= k) {\n\t\t\tcout << ans[k] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n\n#define\trep(i,n)\tfor(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid GENOME(int &,int &);\n\nint p,len;\nchar s[101],s2[1000001];\n\nvoid MOLECULE(int &idx,int &idx2){\n\tif(p<idx2)\treturn;\n\ts2[idx2++]=s[idx++];\n}\n\nint NUMBER(int &idx){\n\tint num=0;\n\twhile(idx<len && isdigit(s[idx]))\tnum=num*10+(s[idx++]-'0');\n\treturn num;\n}\n\nvoid UNIT(int &idx,int &idx2){\n\tif(isalpha(s[idx]))\tMOLECULE(idx,idx2);\n\telse{\n\t\tint num=NUMBER(idx);\n\t\tint bef,aft;\n\t\tif(s[idx]!='('){\n\t\t\tbef=idx2;\n\t\t\tMOLECULE(idx,idx2);\n\t\t\taft=idx2;\n\t\t}\n\t\telse{\n\t\t\tidx++;\n\t\t\tbef=idx2;\n\t\t\tGENOME(idx,idx2);\n\t\t\taft=idx2;\n\t\t\tidx++;\n\t\t}\n\t\tint dif=aft-bef;\n\t\trep(i,num-1)rep(j,dif){\n\t\t\tif(p<idx2)\treturn;\n\t\t\ts2[idx2++]=s2[bef+j];\n\t\t}\n\t}\n}\n\nvoid GENOME(int &idx,int &idx2){\n\twhile(idx<len && isalnum(s[idx])){\n\t\tif(p<idx2)\treturn;\n\t\tUNIT(idx,idx2);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%s%d\",s,&p),strcmp(s,\"0\")||p){\n\t\tlen=strlen(s);\n\t\tint idx=0,idx2=0;\n\t\tGENOME(idx,idx2);\n\t\tprintf(\"%c\\n\",p<idx2?s2[p]:'0');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <stack>\n#define DEBUG false\nusing namespace std;\n\nstruct P {\n  unsigned int i; // JèÔµêÌæªÌindex\n  int n;          // JèÔµñ\n};\n\nbool isDigit( char c ){\n  if( '0'<= c && c <= '9' ) return true;\n  return false;\n}\n\nstring rev(string s ){ // 1¶ÌJèÔµÉ'('')' ðÂ¯é\n  for( unsigned int i=0;i<s.length();i++ ){\n    while( i<s.length() && !isDigit(s[i]) ) ++i;\n    if( isDigit(s[i]) ){\n      while( isDigit(s[i]) ) ++i;\n      if( s[i]!='(' ){\n\tstring bc=\"\";\n\tif( i+1<s.length() ) bc = s.substr(i+1);\n\ts = s.substr( 0,i ) + \"(\" + s[i] + \")\" + bc;\n\t++i;\n      }\n    }\n    ++i;\n  }\n  if( DEBUG )  cout << \"rev : \" << s << endl;\n  return s;\n}\n\n/* ið®©µÄ¢«A¶ð©½ñ¾¯nð¸ç· */\nchar parse( string s, unsigned int n ){\n  const char *c = s.c_str();\n  unsigned int i=0;\n  stack<P> st;   // '('ÌÊuðL^\n  P p;\n  if( DEBUG ) cout << \"parse : \" << s << \" len=\" << s.length() << endl;\n\n  while( i<s.length() ){\n    if( false && DEBUG ) cout << \"while : i=\"<<i<<\" n=\"<<n<< \" s[i]=\"<<s[i] \n\t\t     << \" stack:\"<< st.size() << \" p.n=\" << p.n << endl;\n    if( isDigit( s[i] ) ){\n      int num = atoi( c+i );\n      if(  DEBUG ) cout << \"num=\" << num << endl;\n      while( isDigit( s[i] ) ) ++i;\n      i++;  // '(' ÌªðCNg·é\n      p.i=i; p.n=num;\n      st.push( p ); // JèÔµÌÅÌ¶ðÇÁ\n    }else if( s[i]==')' ){\n      p = st.top(); st.pop();\n      if( --p.n != 0 ){  st.push( p ); i=p.i; }\n      else ++i;\n    }else {\n      if( n==0 )\n\treturn s[i];\n      --n;\n      ++i;\n    }\n  }\n  return '0';\n}\n\nint main(){\n  string s;\n  unsigned int n;\n  while( cin>>s>>n && (s!=\"0\"|| n ) ){\n    if( DEBUG ){\n      cout << \"\\nn=\" << n << \" in : \" << s << endl;\n    }\n   \n    if( DEBUG )\n      cout << \"answer=\";\n    cout << parse( rev(s),n ) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse = \"\",int x = 0):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt()\n  {\n    return StringToInt(getCnt());\n  }\n\n  string decode()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    else \n      {\n\tstring mes,ret;\n\twhile('A' <= parse[pos] && parse[pos] <= 'Z')\t\n\t  mes += parse[pos++];\n\t\n\tfor(int i=0;i<power;i++)\n\t  {\n\t    ret += mes;\n\t    if(ret.size() >= x)\n\t      break;\n\t  }\n\treturn ret;\t  \n      }\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+1);\n      string message = par.exp();\n      message.size() <= pos?cout << 0 << endl:cout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define int long long \nconst int INF = 1e9;\n\nclass Parser{\npublic:\n  int i, j, k;\n  string s;\n  char parse(){\n    i = 0;\n    j = 0;\n    return solve();\n  }\n  char solve(){\n    //cout << \"solve  : i = \" << i << \", k = \" << k << endl;\n    while(i < s.size() && s[i] != ')'){\n      int n = number(), t = expr();\n      //cout << \"n, t = \" << n << \", \" << t << endl;\n      if(t >= k){\n        i = j;\n        number();\n        if(s[i] == '(') ++i;\n        j = i;\n        char ret = expr2();\n        if(s[i] == ')') ++i;\n        return ret;\n      }else if(n*t > k){\n        k %= t;\n        i = j;\n        number();\n        if(s[i] == '(') ++i;\n        j = i;\n        //cout << \"k = \" << k << \", i = \" << j << endl;\n        char ret = expr2();\n        if(s[i] == ')') ++i;\n        return ret;\n      }else{\n        j = i;\n        k -= n*t;\n      }\n    }\n    return '0';\n  }\n  int expr(){\n    //cout << \"expr   : i = \" << i  << \", k = \" << k << endl;\n    int ret = number();\n    ret = min(ret, INF);\n    if(i >= s.length()) return 0;\n    if(s[i] == '('){\n      ++i;\n      int t = 0;\n      while(i < s.size() && s[i] != ')'){\n        t += expr();\n        t = min(t, INF);\n      }\n      ++i;\n      ret *= t;\n    }else{\n      int l = str();\n      ret *= l;\n    }\n    ret = min(ret, INF);\n    return ret;\n  }\n  int number(){\n    //cout << \"number : i = \" << i << \", k = \" << k << endl;\n    if(i >= s.size() || s[i] < '0' || s[i] > '9') return 1;\n    int ret = 0;\n    while(i < s.size() && s[i] >= '0' && s[i] <= '9'){\n      ret *= 10;\n      ret += s[i] - '0';\n      ++i;\n    }\n    return ret;\n  }\n  int str(){\n    //cout << \"str    : i = \" << i << \", k = \" << k << endl;\n    int ret = 0;\n    while(i < s.size() && s[i] >= 'A' && s[i] <= 'Z'){\n      ++ret;\n      ++i;\n    }\n    return ret;\n  }\n  char expr2(){\n    //cout << \"expr2  : i = \" << i << \", k = \" << k << endl;\n    if(i >= s.length()) return '0';\n    int n = number(), t;\n    //cout << \"n = \" << n << endl;\n    if(s[i] == '('){\n      ++i;\n      j = i;\n      int t = expr();\n      k %= t;\n      i = j;\n      char ret = expr2();\n      ++i;\n      return ret;\n    }else{\n      j = i;\n      t = str();\n      if(t*n > k) return s[j+k%t];\n      else{\n        k -= t*n;\n        //return expr2();\n        return solve();\n      }\n    }\n    return '0';\n  }\n};\n\nsigned main(){\n  string s;\n  int n;\n  Parser p;\n  while(cin >> s >> n, s != \"0\"){\n    p.s = s;\n    p.k = n;\n    cout << p.parse() << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n//I referred to other's code.\nconst int MAX_L = 10000001;\nstring s;\nint needidx;\nstring expr(int& p);\nint num(int& p){\n  int res = 0;\n  while(isdigit(s[p])){\n    res = res * 10 + (s[p++] - '0');\n  }\n  return res;\n}\nstring chara(int& p){\n  string res = \"\";\n  while(isalpha(s[p])){\n    res += s[p++];\n  }\n  return res;\n}\nstring term(int& p){\n  string res;\n  if(isalpha(s[p])){\n    res =  chara(p);\n  }else{\n    int n = num(p);\n    string t;\n    if(s[p]=='('){\n      p++;\n      t = expr(p);\n      p++;\n    }else{\n      t = chara(p);\n    }\n    REP(i,n){\n      if(res.size() > needidx) break;\n      res += t;\n    }\n  }\n  return res;\n}\nstring expr(int& p){\n  string res = term(p);\n  while(p < s.size() && s[p] != ')'){\n    if(res.size() > needidx) break;\n    res += term(p);\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>s>>needidx, s!=\"0\"){\n    int p = 0;\n    string ans = expr(p);\n    if(ans.size() > needidx){\n      cout<<ans[needidx]<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool flag = false;\n\nstring kansu( string s, long long int i, long long int k ) {\n\n  string b = \"\";\n  long long int rep = 0;\n  while( true ) {\n\n    //    cout << \"i = \" << i << \" : k = \" << k << endl;\n\n    if ( s[i] >= '0' && s[i] <= '9' ) {\n\n      rep = rep * 10 + s[i] - '0';\n\n    }else if ( s[i] == '(' ) {\n\n      i++;\n      string r = kansu( s, i, k );\n      if ( flag == true ) return \"\";\n\n      for ( long long int j = 0; j < rep; j++ ) {\n\n\tif ( k < r.size() ) {\n\t  cout << r[k] << endl;\n\t  flag = true;\n\t  return \"\";\n\t}\n\tb += r;\n\tk -= r.size();\n\n      }\n\n      rep = 0;\n\n      for ( long long int j = 0; j >= 0; i++ ) {\n\tif ( s[i] == '(' ) {\n\t  j++;\n\t}else if ( s[i] == ')' ) {\n\t  j--;\n\t}\n      }\n\n    }else if ( s[i] == ')' ) {\n\n      return b;\n\n    }else {\n\n      if ( rep == 0 ) rep = 1;\n      for ( long long int j = 0; j < rep; j++ ) {\n\tif ( k == 0 ) {\n\t  cout << s[i] << endl;\n\t  flag = true;\n\t  return \"\";\n\t}\n\tb += s[i];\n\tk--;\n      }\n      rep = 0;\n\n    }\n\n    i++;\n\n  }\n\n}\n\nint main() {\n\n  while( true ) {\n\n    string s;\n    long long int k;\n    cin >> s >> k;\n    if ( s == \"0\" ) break;\n\n    flag = false;\n\n    kansu( s + \")\", 0, k );\n\n    if ( flag == false ) {\n      cout << 0 << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n\nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n\nvoid dfs(int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    while('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int x=r.first,num=r.second;\n      int y=r.first,z=r.first;\n      if(s[x]=='('){\n\tint c=1;\n\ty=x+1;\n\tfor(z=y;z<=e&&c;z++){\n\t  if(s[z]=='(')c++;\n\t  if(s[z]==')')c--;\n\t}\n\tp=z;\n\tz-=2;\n\twhile(num--)dfs(y,z);\n      }else{\n\twhile(num--)ans+=s[x];\n\tp=x+1;\n      }\n    }\n    while('A'<=s[p]&&s[p]<='Z')\n      ans+=s[p++];\n  }\n}\n\nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,s.size()-1);\n    if(ans.size()<n+1)\n      printf(\"0\\n\");\n    else printf(\"%c\\n\",ans[n]);\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse = \"\",int x = 0):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt()\n  {\n    return StringToInt(getCnt());\n  }\n\n  string decode()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\t//cout << \"ret -> \" << ret << endl; \n\t//cout << \"retsize -> \" << size << endl;\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos);\n      string message = par.exp();\n      //cout << message << endl;\n      //cout << \"size = \" << par.getSize() << endl;\n      if(message.size() <= pos)\n\tcout << 0 << endl;\n      else\n\tcout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n\nstring s;\nint K;\n\nstring mul(string str, int n){\n    string res;\n    rep(i,n){\n        res += str;\n        if((int)res.size() > K) break;\n    }\n    return res.substr(0,K+1);\n}\n\n// T := c..c | Nc | N(T) | TT\nstring read(int &i){\n    if((int)s.size() == i || s[i] == ')'){\n        return \"\";\n    }\n\n    string str;\n\n    // c..c\n    if(isalpha(s[i])){\n        while(isalpha(s[i])){\n            str += s[i];\n            i++;\n        }\n    }else{\n        int num = 0;\n        assert(isdigit(s[i]));\n        while(isdigit(s[i])){\n            num = num*10+(s[i]-'0');\n            i++;\n        }\n\n        // Nc\n        if(isalpha(s[i])){\n            str = string(num,s[i]);\n            i++;\n        }\n        // N(T)\n        else{\n            assert(s[i] == '(');\n            i++;\n            str = mul(read(i),num);\n            assert(s[i] == ')');\n            i++;        \n        }\n    }\n    // TT\n    return mul(str+read(i),1);\n}\n\nint main(void){\n    while(cin>>s>>K, !(s==\"0\" && K==0)){\n        int i = 0;\n        string res = read(i);\n        if((int)res.size() <= K){\n            cout<<0<<endl;\n        }else{\n            cout<<char(res[K])<<endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nInt g(string s){\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s))return sz(s);\n\tInt c=0,q,r,times=0;\n\trepn0(q,p,sz(s)-1){\n\t\tif(!isdigit(s[q]))break;\n\t\ttimes=times*10+s[q]-'0';\n\t}\n\trep0(r,sz(s)){\n\t\tif(s[r]=='(')++c;\n\t\tif(s[r]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\treturn min(1000000LL,p+times*g(s.substr(q+1,r-q-1))+g(s.substr(r+1)));\n}\n\nchar f(string s,Int i){\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s)){\n\t\tif(i<p)return s[i];\n\t\telse return '0';\n\t}\n\tif(i<p)return s[i];\n\ts=s.substr(p);\n\ti-=p;\n\tInt c=0,q,times=0;\n\trep0(p,sz(s)){\n\t\tif(!isdigit(s[p]))break;\n\t\ttimes=times*10+s[p]-'0';\n\t}\n\tif(s[p]!='('){\n\t\ts=s.substr(0,p)+\"(\"+s.substr(p,1)+\")\"+s.substr(p+1);\n\t}\n\trep0(q,sz(s)){\n\t\tif(s[q]=='(')++c;\n\t\tif(s[q]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\tInt len=g(s.substr(p+1,q-p-1));\n\tif(len*times>i){\n\t\ti%=len;\n\t\treturn f(s.substr(p+1,q-p-1),i);\n\t}else{\n\t\ti-=len*times;\n\t\treturn f(s.substr(q+1),i);\n\t}\n}\n\nint main() {\n\tstring s;\n\tInt i;\n\tIL{\n\t\tcin>>s>>i;\n\t\tif(s==\"0\"&&i==0)break;\n\t\tcout<<f(s,i)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nstring s; int n;\n\n\nint calc(int count, int idx){\n\tif(count == -1) return -1;\n\tidx++; //(\n\twhile(s[idx] != ')'){\n\t\tif(count == -1) return -1;\n\t\tif(isalpha(s[idx])){\n\t\t\tif(count == n){cout << s[idx] << endl; return -1;}\n\t\t\tcount++; idx++;\n\t\t}\n\t\telse {\n\t\t\tint m = 0;\n\t\t\twhile(isdigit(s[idx])){m*=10; m += s[idx]-'0'; idx++;}\n\t\t\trep(i, m) count = calc(count, idx);\n\n\t\t\tidx++;\n\t\t\tint b = 1;\n\t\t\twhile(b != 0){\n\t\t\t\tif(s[idx] == '(') b++;\n\t\t\t\telse if(s[idx] == ')') b--;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\twhile(cin >> s >> n){\n\t\tfor(int i=0; i < s.size(); i++){\n\t\t\tif(isdigit(s[i]) && isalpha(s[i+1])) s = s.substr(0, i+1) + \"(\" + s.substr(i+1, 1) + \")\" + s.substr(i+2);\n\t\t}\n\n\t\tint count = 0;\n\n\t\tif(s == \"0\" && n == 0) break;\n\t\tfor(int i=0; i< s.size();){\n\t\t\tif(count == -1) break;\n\t\t\tif(isalpha(s[i])){\n\t\t\t\tif(count == n){cout << s[i] << endl; count = -1; break;}\n\t\t\t\tcount++; i++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint m = 0;\n\t\t\t\twhile(isdigit(s[i])){m*=10; m += s[i]-'0'; i++;}\n\n\t\t\t\trep(j, m) count = calc(count, i);\n\n\t\t\t\ti++;\n\t\t\t\tint b = 1;\n\t\t\t\twhile(b != 0){\n\t\t\t\t\tif(s[i] == '(') b++;\n\t\t\t\t\telse if(s[i] == ')') b--;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count != -1) cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\n#define DEB 0\n#define SIZE 1000000\n\nint d;\n\nstring parse(char *p){\n#if DEB\nprintf(\"start:%c\\n\",*p);\n#endif\n\tif( *p=='\\0' ) return \"\";\n\tif( isdigit(*p) ){\n\t\tint num=0;\n\t\tfor(;*p!='\\0' && isdigit(*p);p++){\n\t\t\tnum = 10*num + (*p-'0');\n\t\t}\n\t\tchar *tp = p;\n\t\tint x = 0;\n\t\tif( *tp=='(' ){\n\t\t\tfor(;;){\n\t\t\t\tif( *tp=='(' )x++;\n\t\t\t\telse if( *tp==')' )x--;\n\t\t\t\ttp++;\n\t\t\t\tif( x==0 )break;\n#if DEB\nprintf(\"x:%d  %c\\n\",x,*tp);\n#endif\n\t\t\t}\n\t\t}\n\t\t\n#if DEB\nprintf(\"p:%c  tp:%c\\n\",*(p+1),*tp);\n#endif\n\t\tstring tmp;\n\t\tif( p!=tp ){\n\t\t\tstring sub = parse(p+1);\n\t\t\tif( sub.size()>d ) return sub;\n\t\t\trep(i,num){\n\t\t\t\ttmp += sub;\n\t\t\t\tif( tmp.size()>d ) return tmp;\n\t\t\t}\n\t\t\treturn tmp + parse(tp);\n\t\t}else{\n\t\t\ttmp = string(num,*p);\n\t\t\treturn tmp + parse(tp+1);\n\t\t}\n\t\t\n\t}else if( isalpha(*p) ){\n\t\treturn string(1,*p)+parse(p+1);\n\t}else if( *p==')' ){\n\t\treturn \"\";\n\t}\n#if DEB\nprintf(\"error : %c\\n\",*p);\n#endif\n\treturn \"\";\n}\n\nint main(){\n\tchar in[128];\n\twhile(scanf(\" %s %d \",in,&d),strcmp(in,\"0\")|d){\n\t\tstring ans = parse(in);\n\t\tif( d>=ans.size() ){\n\t\t\tputs(\"0\");\n\t\t}else{\n\t\t\tprintf(\"%c\\n\",ans[d]);\n\t\t}\n#if DEB\n\t\tcout << \"ans: \" << ans << endl;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint n;\nstring dfs(int x){\n  int a=1,t=0;\n  string str,res;\n  for(int i=x;0<a;i++){\n    if('0'<=s[i]&&s[i]<='9')t*=10,t+=s[i]-'0';\n    else if(s[i]=='('&&a==1){\n      res=dfs(i+1);\n      t=max(1,t);\n      while(t--)str+=res;\n      a++;\n    }\n    else if(s[i]==')')a--;\n    else if(a==1)str+=s[i];\n  }\n  return str;\n}\nint main(){\n  while(cin>>s>>n){\n    s+=\")\";\n    string ans=dfs(0);\n    if(ans.size()>n)\n      cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint solve(stringstream &ss, int remains, char &result){\n\tint length = 0;\n\twhile(ss.tellg() < ss.str().size() && remains >= 0){\n\t\tif(isdigit(ss.peek())){\n\t\t\tint loop;\n\t\t\tss >> loop;\n\t\t\tchar c = ss.get();\n\t\t\tif(c == '('){\n\t\t\t\tstreampos pos = ss.tellg();\n\t\t\t\tint len = solve(ss, remains, result);\n\t\t\t\tif(len < 0){ return -1; }\n\t\t\t\tif(len * loop > remains){\n\t\t\t\t\tss.seekg(pos, ios_base::beg);\n\t\t\t\t\tsolve(ss, remains % len, result);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tremains -= len * loop;\n\t\t\t\tlength += len * loop;\n\t\t\t}else{\n\t\t\t\tif(loop > remains){\n\t\t\t\t\tresult = c;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tremains -= loop;\n\t\t\t\tlength += loop;\n\t\t\t}\n\t\t}else{\n\t\t\tchar c = ss.get();\n\t\t\tif(c == ')'){\n\t\t\t\tbreak;\n\t\t\t}else if(remains-- == 0){\n\t\t\t\tresult = c;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t++length;\n\t\t}\n\t}\n\treturn length;\n}\n\nint main(){\n\twhile(true){\n\t\tstring s;\n\t\tint pos;\n\t\tcin >> s >> pos;\n\t\tif(s == \"0\" && pos == 0){ break; }\n\t\tchar answer = '0';\n\t\tstringstream ss(s);\n\t\tsolve(ss, pos, answer);\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000200\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e;\n\t}\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    if(flg2) idx=s[c].size();\n\t    if(idx==s[c].size())flg2=1;\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<n+200;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nint num(Cursol&);\nstring calc(Cursol&);\nstring expr(Cursol&);\n\nint pos ;\n\nint num(Cursol& p){\n  int ret = 0;\n  while(isdigit(*p)){\n    ret = ret * 10 + *p - '0';\n    p++;\n  }\n  return ret;\n}\n\nstring calc(Cursol& p){\n  string ret;\n  if(isdigit(*p)){\n    int number = num(p);\n    if( *p == '(') {\n      string res = expr(++p);\n      p++;\n      while(number--){\n        ret += res;\n        if(pos < ret.size()) break;\n      }\n    } else {\n      char c = *p++;\n      while(number--){\n        ret += c;\n        if(pos < ret.size()) break;\n      }\n    }\n  }else{\n    while(isalpha(*p)){\n      ret += *p++;\n      if(pos < ret.size()) break;\n    }\n  }\n  return ret;\n}\n\n\nstring expr(Cursol& p){\n  string ret;\n  while( isalpha(*p) || isdigit(*p)){\n    ret += calc(p);\n    if(pos < ret.size()) break;\n  }\n  return ret;\n}\nint main(){\n  string str;\n  while(cin >> str >> pos, str!=\"0\"||pos){\n    Cursol idx = str.begin();\n    string ret = expr(idx);\n    if(pos < ret.size()) cout << ret[pos] << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nbool out;\nbool output(string s, ll I, ll mult, bool f){\n    if(!f && s.size() * mult < I) return false;\n    out = 1;\n    I %= s.size();\n    cout << s[I] << endl;\n    return true;\n}\nint main(){\n    while(1){\n        string s;\n        ll I;\n        cin >> s >> I;\n        if(s == \"0\" && !I) break;\n        stack<ll> st;\n        string now = \"\";\n        ll num = 0;\n        ll mult = 1;\n        bool f = 0;\n        for(char c : s){\n            if('0' <= c && c <= '9'){\n                num = num * 10 + (c - '0');\n            }else if(c == '('){\n                st.push(num);\n                mult *= num;\n                num = 0;\n                if(mult >= I){\n                    mult = 1;\n                    f = 1;\n                }\n            }else if('A'<= c && c <= 'Z'){\n                for(ll i = 0; i < max<ll>(1, num); i++) now += c;\n            }else if(c == ')'){\n                ll tmp = st.top();\n                st.pop();\n                if(output(now, I, mult, f)){\n                    break;\n                }else{\n                    I -= now.size() * mult;\n                    now = \"\";\n                }\n                mult /= tmp;\n            }\n        }\n        if(!out){\n            if(I < now.size()) cout << now[I] << endl;\n            else cout << 0 << endl;\n        }\n        out = 0;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nchar solve(string str, int &index, size_t &pos){\n\t//cout << \"solve : \" << str << endl;\n\tint cnt = 1, len = str.length();\n\tif( str[0] == '(' ){\n\t\tstr = str.substr(1);\n\t\tcnt = -1;\n\t}\n\twhile( !str.empty() && cnt-- ){\n\t\tif( str[0] >= '0' && str[0] <= '9' ){\n\t\t\tsize_t i, p;\n\t\t\tint num = stoi( str, &i );\n\t\t\tstring s = str.substr(i);\n\t\t\trep(k, num){\n\t\t\t\tchar res = solve( s, index, p );\n\t\t\t\tif( res != '0' ) return res;\n\t\t\t}\n\t\t\tstr = s.substr(p);\n\t\t}else if( str[0] == ')' ){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tint i=0;\n\t\t\twhile(str[i] < '0' || str[i] > '9'){\n\t\t\t\tif( str[i] == ')' ) break;\n\t\t\t\tif( index-- == 0 ) return str[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr = str.substr(i);\n\t\t}\n\t}\n\tpos = len - str.length() + 1;\n\treturn '0';\n}\n\nint main(){\n\tstring s;\n\tint i;\n\twhile(cin>>s>>i, s != \"0\" ){\n\t\tstring ss = \"1(\" + s + \")\";\n\t\tsize_t p;\n\t\tcout << solve(ss, i, p) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nconst int MAX_LEN = 1000005;\n\nstring s;\n\nvoid dfs(int& cur, string& t)\n{\n    if(cur >= len(s)-1){\n        return;\n    }\n    while(cur < len(s)-1){\n        if(isdigit(s[cur])){\n            int st = cur;\n            while(isdigit(s[cur])){\n                cur++;\n            }\n            int num = stoi(s.substr(st,cur-st));\n            if(isalpha(s[cur])){\n                rep(i,num){\n                    t.pb(s[cur]);\n                }\n            }else{\n                if(cur >= len(s)-1){\n                    return;\n                }\n                cur++;\n                string u;\n                dfs(cur,u);\n                rep(i,num){\n                    t += u;\n                    if(len(t) >= MAX_LEN){\n                        return;\n                    }\n                }\n            }\n        }else{\n            while(isalpha(s[cur])){\n                t.pb(s[cur]);\n                cur++;\n            }\n            if(s[cur] == ')'){\n                cur++;\n                return;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> s >> n;\n        if(s == \"0\" && n == 0){\n            break;\n        }\n        s.pb('%');\n        string t;\n        int num = 0;\n        dfs(num,t);\n        if(len(t) <= n){\n            cout << \"0\\n\";\n        }else{\n            cout << t[n] << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// syakyo http://mikecat.6.ql.bz/aojcode/V11/1145/\n\n#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\nstring input;\n\nchar result;\nint current;\nint target;\n\nvoid go_next(int repeat, int start, int end){\n    for(int repeating = 0; repeating < repeat && current < target; repeating++){\n        for(int i = start; i < end && current < target; i++){\n            if(isdigit(input[i])){\n                // repeat\n                int next_repeat = input[i]-'0';\n                int j;\n                for(j=i+1; j < end && isdigit(input[j]); j++){\n                    next_repeat = next_repeat*10 + input[j]-'0';\n                }\n                int k, depth;\n                if(input[j] == '('){\n                    for(k=j+1, depth=1; k < end && depth > 0; k++){\n                        if(input[k]=='(') depth++;\n                        else if(input[k]==')') depth--;\n                    }\n                    go_next(next_repeat,j+1,k-1);\n                    i=k-1;\n                } else {\n                    k=j+1;\n                    go_next(next_repeat,j,j+1);\n                    i=j;\n                }\n            } else {\n                current++;\n                if(current >= target) result = input[i];\n            }\n        }\n    }\n}\n\nint main(){\n    while(cin >> input >> target && input!=\"0\"){\n        result = '0';\n        current = -1;\n        go_next(1,0,input.size());\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll id;\nint N, c;\nstring s;\n\nconst ll MAX = 2000000;\n\nstruct Node {\n\tll v, len;\n\tstring s;\n\tvector<Node*> children;\n\tNode() : v(1), len(0), s(string()) {}\n};\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nNode* f(){\n\tNode* node = new Node();\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\tnode->v = n;\n\n\t\tif(s[c] != '(') {\n\t\t\tNode* res = f();\n\t\t\tnode->children.push_back(res);\n\t\t\tnode->len = min(MAX, node->len + res->len * res->v);\n\t\t\treturn node;\n\t\t}\n\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tNode* res = f();\n\t\t\tnode->children.push_back(res);\n\t\t\tnode->len = min(MAX, node->len + res->len * res->v);\n\n\t\t\tif(c < N && s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tassert('A' <= s[c] && s[c] <= 'Z');\n\n\tnode->s = readS();\n\tnode->len = min(MAX, (ll)node->s.size());\n\n\treturn node;\n}\n\nvoid g(Node* node){\n\tif(node->children.size() == 0) {\n\t\tassert(id < node->s.size());\n\t\tans = node->s[id];\n\t\treturn;\n\t}\n\n\twhile(!(id < node->len)) id -= node->len;\n\n\tfor(auto child : node->children) {\n\t\tif(child->len * child->v <= id) {\n\t\t\tid -= child->len * child->v;\n\t\t}\n\t\telse{\n\t\t\tg(child);\n\t\t\tassert(ans);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0){\n\t\t\tNode* res = f();\n\t\t\tif(res->len * res->v <= id) {\n\t\t\t\tid -= res->len * res->v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg(res);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nchar s[125];\nint n;\nint idx;\n\nconst int INF = 1000025;\n\nstruct EE{\n  int id;\n  int size;\n  int mult;\n  int csizesum;\n  bool leaf;\n  char c;\n  vector<int> children;\n};\n\nEE E[125252];\nint id;\nint it;\nvoid cl(int id){\n  E[id].id = 0;\n  E[id].size = 0;\n  E[id].mult = 0;\n  E[id].csizesum = 0;\n  E[id].leaf = false;\n  E[id].c = '\\0';\n  E[id].children.clear();\n}\n\nint dfs(){\n  int nid = id++;\n  cl(nid);\n  E[nid].id = nid;\n  if(isdigit(s[it])){\n    // multiplier\n    int mult = 0;\n    while(isdigit(s[it])){\n      mult *= 10;\n      mult += s[it]-'0';\n      it++;\n    }\n    E[nid].leaf = false;\n    E[nid].mult = mult;\n    if(s[it]=='('){\n      it++;\n      while(s[it] != ')'){\n        int child = dfs();\n        E[nid].children.push_back(child);\n        E[nid].csizesum += E[child].size;\n        if(E[nid].csizesum > INF)E[nid].csizesum = INF;\n      }\n      it++;\n    }else{\n      int child = dfs();\n      E[nid].children.push_back(child);\n      E[nid].csizesum += E[child].size;\n      if(E[nid].csizesum > INF)E[nid].csizesum = INF;\n    }\n    E[nid].size = min(INF, E[nid].csizesum * mult);\n    return nid;\n  }else{\n    E[nid].size = 1;\n    E[nid].leaf = true;\n    E[nid].c = s[it++];\n    return nid;\n  }\n}\n\nvoid debug(int root){\n  if(E[root].leaf){\n    printf(\"%c \",E[root].c);\n  }else{\n    printf(\"%dx [ \",E[root].mult);\n    for(int c : E[root].children){\n      debug(c);\n    }\n    printf(\"]\");\n  }\n  return;\n}\n\nint main(){\n  while(true){\n    REP(i,125)s[i] = '\\0';\n    s[0] = '1';\n    s[1] = '(';\n    scanf(\"%s%d\",s+2,&idx);\n    n = strlen(s);\n    s[n++] = ')';\n    s[n] = '\\0';\n    if(n==4 && s[2]=='0' && idx==0)break;\n    id = 0;\n    it = 0;\n    int root = dfs();\n    if(E[root].size <= idx){\n      puts(\"0\");\n      continue;\n    }\n    // debug(root);puts(\"\");\n    while(!E[root].leaf){\n      int csizesum = E[root].csizesum;\n      idx %= csizesum;\n      int nxt = -1;\n      for(int c : E[root].children){\n        int sz = E[c].size;\n        if(idx < sz){\n          nxt = c;\n          break;\n        }\n        idx -= sz;\n      }\n      root = nxt;\n    }\n    printf(\"%c\\n\",E[root].c);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nstring str,s;\nint pos,cnt,n;\nchar ans;\nbool f;\n\nint term();\nint factor();\n\nint exp(){\n   int x = term();\n   if(x <= MAX){\n      if(str[pos] == '+'){\n\t pos++;\n\t x += term();\n\t if(!f && x >= n){\n\t    ans = s[(x-n)%s.size()];\n\t    f = true;\n\t }\n      }\n      cnt = x;\n      return x;\n   }\n}\n\nint term(){\n   int x = factor();\n   if(x <= MAX){\n      if(str[pos] == '*'){\n\t pos++;\n\t x *= factor();\n\t if(!f && x >= n){\n\t    ans = s[(x-n)%s.size()];\n\t    f = true;\n\t }\n      }\n      cnt = x;\n      return x;\n   }\n}\n\nint factor(){\n   int x = 0;\n   if(str[pos] == '('){\n      pos++;\n      x = exp();\n      pos++;\n   } else if(str[pos] >= '0' && str[pos] <= '9'){\n      while(str[pos] >= '0' && str[pos] <= '9'){\n\t x *= 10;\n\t x += str[pos++] - '0';\n\t if(pos == n) break;\n      }\n   } else if(str[pos] >= 'A' && str[pos] <= 'Z'){\n      s.clear();\n      while(str[pos] >= 'A' && str[pos] <= 'Z'){\n\t s += str[pos++];\n\t if(pos == n) break;\n      }\n      if(!f && cnt >= n){\n\t ans = s[(cnt-n)%s.size()];\n\t f = true;\n      }\n      x = s.size();\n   }\n   if(x <= MAX) return x;\n}\n\nint main(){\n   while(cin >> str >> n){\n      if(str == \"0\" && n == 0) break;\n      pos = cnt = 0;\n      f = false;\n      ans = '0';\n\n      for(int i=0;i<str.size();i++){\n\t if(str[i] == '(' ||\n\t    i > 0 && str[i-1] >= '0' && str[i-1] <= '9' && str[i] >= 'A' && str[i] <= 'Z'){\n\t    str.insert(str.begin()+i,'*');\n\t    i++;\n\t } else if(i > 0 && str[i-1] == ')'){\n\t    if(str[i] >= '0' && str[i] <= '9' || str[i] >= 'A' && str[i] <= 'Z'){\n\t       str.insert(str.begin()+i,'+');\n\t       i++;\n\t    }\n\t }\n      }\n\n      exp();\n      cout << ans << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse {\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&(int)s[!c].size()<n+200;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if((int)s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll id;\nint N, c;\nstring s;\n\nconst ll MAX = 2000000;\n\nstruct Node {\n\tll v, len;\n\tstring s;\n\tvector<Node*> children;\n\tNode() : v(1), len(0), s(string()) {}\n};\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nNode* f(){\n\tNode* node = new Node();\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\tnode->v = n;\n\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tNode* res = f();\n\t\t\tnode->children.push_back(res);\n\t\t\tnode->len = min(MAX, node->len + res->len * res->v);\n\n\t\t\tif(s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tif(res->s.size() == 1) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tassert('A' <= s[c] && s[c] <= 'Z');\n\n\tnode->s = readS();\n\tnode->len = min(MAX, (ll)node->s.size());\n\n\t//if(ans == 0) {\n\t//\tif(ss.size() * v <= id) {\n\t//\t\tid -= ss.size() * v;\n\t//\t\treturn;\n\t//\t}\n\n\t//\twhile(id >= ss.size()) id -= ss.size();\n\t//\tans = ss[id];\n\t//}\n\treturn node;\n}\n\nvoid g(Node* node){\n\tif(node->children.size() == 0) {\n\t\tassert(id < node->s.size());\n\t\tans = node->s[id];\n\t\treturn;\n\t}\n\n\twhile(!(id < node->len)) id -= node->len;\n\n\tfor(auto child : node->children) {\n\t\tif(child->len * child->v <= id) {\n\t\t\tid -= child->len * child->v;\n\t\t}\n\t\telse{\n\t\t\tg(child);\n\t\t\tassert(ans);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0){\n\t\t\tNode* res = f();\n\t\t\tif(res->len * res->v <= id) {\n\t\t\t\tid -= res->len * res->v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg(res);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef pair<ll,ll> pll;\n\n#define reps(i,f,n) for(int i = int(f); i <= int(n); i++)\n#define rep(i,n) reps(i,0,int(n)-1)\n#define rrep(i,n) for(int i = n-1; i >= 0; i--)\n\n#define all(x) (x).begin(),(x).end()\n#define X first\n#define Y second\n\n#define sz size()\n#define eb emplace_back\n\nvector<int> x[1024];\nstring y[1024];\nint cnt;\n\nvoid parse(string s){\n  int ind = 0;\n  int l = s.size();\n  int num = 0;\n  cnt = 0;\n  vector<int> nums;\n  rep(i,1024)x[i].clear();\n  rep(i,1024)y[i] = \"\";\n\n  while(ind<l){\n    //cout << \"num\" << num << endl;\n    if(s[ind] == '('){\n      nums.push_back(num);\n      num = 0;\n    }else if('0' <= s[ind] && s[ind] <= '9'){\n      num *= 10;\n      num += s[ind]-'0';\n    }else if(s[ind] == ')'){\n      rep(i, nums.size()) x[cnt].push_back(nums[i]);\n      if(nums.size() == 0)x[cnt].push_back(1);\n      cnt++;\n      nums.pop_back();\n    }else{\n      y[cnt] += s[ind];\n      if(num != 0){\n        rep(i, nums.size()) x[cnt].push_back(nums[i]);\n        x[cnt].push_back(num);\n        num = 0;\n        cnt++;\n      }\n    }\n    ind++;\n  }\n  if(y[cnt] != \"\"){\n    rep(i, nums.size()) x[cnt].push_back(nums[i]);\n    if(num != 0)x[cnt].push_back(num);\n    if(nums.size() == 0)x[cnt].push_back(1);\n    cnt++;\n  }\n}\n\nint main(void){\n  string s;\n  int p;\n  while(1){\n    cin >> s >> p;\n    if(s[0] == '0')break;\n    parse(s);\n    /*\n    rep(i,cnt){\n      cout << y[i] << endl;\n      rep(j,x[i].size()){\n        cout << x[i][j] << \",\";\n      }cout << endl;\n    }\n    /**/\n\n    rep(i,cnt){\n      int q = y[i].size();\n      rep(j, x[i].size()){\n        q *= x[i][j];\n        if(p < q){\n          cout << y[i][p%y[i].size()] << endl;\n          p -= q;\n          break;\n        }\n      }\n      p -=q;\n      if(p < 0)break;\n    }\n    if(p >= 0)cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Term\n{\n    using Ptr = shared_ptr<Term>;\n    Term(const int rep, const vector<Ptr>& child, const int unit, const string& s) : rep{rep}, child{child}, unit{unit}, s{s} {}\n    int rep;\n    vector<Ptr> child;\n    int unit;\n    string s;\n};\nusing Ptr = Term::Ptr;\nstring S;\nstring::iterator c;\nPtr parse()\n{\n    if (not isdigit(*c)) {\n        string s;\n        for (; 'A' <= *c and *c <= 'Z'; c++) { s.push_back(*c); }\n        return make_shared<Term>(1, vector<Ptr>{}, (int)s.size(), s);\n    }\n    string d;\n    for (; isdigit(*c); c++) { d.push_back(*c); }\n    const int D = d == \"\" ? 1 : stoi(d);\n    Ptr ans = make_shared<Term>(D, vector<Ptr>{}, 0, \"\");\n    bool hasb = false;\n    if (*c == '(') { hasb = true, c++; }\n    if (not hasb) { return (ans->unit = 1, ans->s = string(1, *c), c++, ans); }\n    for (; *c != ')';) {\n        const auto p = parse();\n        ans->child.push_back(p);\n        ans->unit = min(ans->unit + (p->unit) * (p->rep), 1000001);\n    }\n    c++;\n    return ans;\n}\nint main()\n{\n    while (true) {\n        int N;\n        cin >> S >> N;\n        if (S == \"0\" and N == 0) { break; }\n        S = \"1(\" + S + \")\";\n        c = S.begin();\n        const Ptr root = parse();\n        if (N >= root->unit * root->rep) {\n            cout << 0 << endl;\n            continue;\n        }\n        Ptr p = root;\n        while (true) {\n            if (p->child.empty()) {\n                cout << p->s[N] << endl;\n                break;\n            } else {\n                for (const auto& c : p->child) {\n                    if (N >= c->rep * c->unit) {\n                        N -= c->rep * c->unit;\n                    } else {\n                        N %= c->unit;\n                        p = c;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\n\nstring rec(string s, int repeat) {\n  repeat = min(repeat,1000000);\n  int f = 0;                 // f : 0.ÈñÅàÈ¢ 1.ÊíÌ¶ñ 2. 3.Êà\n  int start = 0;\n  int re = 0;\n  int nest = 0;\n  string res;\n  REP(i,s.size()) {\n    if (f == 0) {\n      if (isalpha(s[i])) {\n        start = i;\n        f = 1;\n      } else if (isdigit(s[i])) {\n        start = i;\n        f = 2;\n      }\n    } else if (f == 1) {\n      if (isdigit(s[i])) {\n        res += s.substr(start, i-start);\n        f = 2;\n        start = i;\n      }\n    } else if (f == 2) {\n      if (isalpha(s[i])) {\n        re = atoi(s.substr(start, i-start).c_str());\n        res += string(re,s[i]);\n        f = 0;\n      } else if (s[i] == '(') {\n        re = atoi(s.substr(start, i-start).c_str());\n        f = 3;\n        start = i;\n        nest = 1;\n      }\n    } else if (f == 3) {\n      if (s[i] == '(') nest++;\n      else if (s[i] == ')') nest--;\n      if (nest == 0) {\n        res += rec(s.substr(start+1, i-start-1), re);\n        f = 0;\n      }\n    }\n    if (res.size() > n) return res;\n  }\n  if (f == 1) {\n    res += s.substr(start, s.size()-start);\n  }\n  string tmp = res;\n  REP(i, repeat-1) {\n    if (res.size() > n) return res;\n    res += tmp;\n  }\n  return res;\n}\n\nint main() {\n  string s;\n  while(cin>>s>>n,s!=\"0\"||n) {\n    string res = rec(s,1);\n    if (res.size() > n) {\n      cout << res[n] << endl;\n    }else\n      cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iter;\ntypedef ostringstream SS;\n\nstring express(Iter &p);\nstring factor(Iter &p);\nstring term(Iter &p);\nint number(Iter &p);\n\nstring express(Iter &p) {\n\tSS r;\n\twhile(isalpha(*p) || isdigit(*p)) {\n\t\tstring rs = term(p);\n\t\tr << rs;\n\t}\n\n\treturn r.str();\n}\n\n\nstring term(Iter &p) {\n\tif(isdigit(*p)) {\n\t\tSS r;\n\t\tint num = number(p);\n\t\tif(*p == '(') {\n\t\t\tp++;\n\t\t\tstring rs = express(p);\n\t\t\tp++;\n\n\t\t\tfor(int i = 0; i < num; i++)\n\t\t\t\tr << rs;\n\t\t\treturn r.str();\n\t\t}\n\t\telse {\n\t\t\tchar c = *p;\n\t\t\tp++;\n\n\t\t\tfor(int i = 0; i < num; i++) {\n\t\t\t\tr << c;\n\t\t\t}\n\t\t\treturn r.str();\n\t\t}\n\t}\n\telse {\n\t\treturn factor(p);\n\t}\n}\n\nstring factor(Iter &p) {\n\tSS r;\n\twhile(isalpha(*p)) {\n\t\tr << *p;\n\t\tp++;\n\t}\n\treturn r.str();\n}\n\nint number(Iter &p) {\n\tint r = 0;\n\twhile(isdigit(*p)) {\n\t\tr *= 10;\n\t\tr += (*p) - '0';\n\t\tp++;\n\t}\n\treturn r;\n}\n\nint main() {\n\tfor(;;) {\n\t\tstring line;\n\t\tint i;\n\t\tcin >> line >> i;\n\t\tif(line == \"0\" && i == 0) break;\n\t\tstring source = line + \"|\";\n\t\tIter begin = source.begin();\n\t\tstring s = express(begin);\n\t\tcerr << \"-----\" << endl;\n\t\tcerr << s << endl;\n\t\tcerr << \"-----\" << endl;\n\t\tif(i >= s.length())\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << s[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nstring s;\nint p,n,c=0;\nstring bnf1();\nstring get(){\n  string res;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])||isalpha(s[p])){\n    while(isdigit(s[p])||isalpha(s[p])){\n      res+=s[p++];\n      if(res.size()>1000000)return res.substr(0,1000000);\n    }\n  }\n  return res;\n}\nstring bnf2(){\n  string res=get();\n  while(s[p]=='*'){\n    if(res.size()>1000000)return res.substr(0,1000000);\n    p++;\n    string res2=get();\n    int num=0;\n    r(i,res.size())num=num*10+(res[i]-'0');\n    res=res2;\n    r(i,num-1){\n      res+=res2;\n      if(res.size()>1000000)return res.substr(0,1000000);\n    }\n  }\n  return res;\n}\nstring bnf1(){\n  string res=bnf2();\n  while(s[p]=='+'){\n    if(res.size()>1000000)return res.substr(0,1000000);\n    p++;\n    string res2=bnf2();\n    res+=res2;\n    if(res.size()>1000000)return res.substr(0,1000000);\n  }\n  return res;\n}\nint main(){\n  while(cin>>s>>n,s!=\"0\"){\n    p=0;\n    r(i,(int)s.size()-1){\n      if(isdigit(s[i])&&s[i+1]=='('||isdigit(s[i])&&isalpha(s[i+1])){\n        s=s.substr(0,i+1)+\"*\"+s.substr(i+1);\n        i--;\n      }\n      else if(s[i]==')'&&isalpha(s[i+1])||s[i]==')'&&isdigit(s[i+1])||isdigit(s[i+1])&&isalpha(s[i])){\n        s=s.substr(0,i+1)+\"+\"+s.substr(i+1);\n        i--;\n      }\n    }\n    string ans=bnf1();\n    if(n<ans.size())cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nstring str;\nbool over;string ans;\nint p;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\n//\t\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\n\tclass ParseError{};\n\t\n\tstring expression(Cursor&);int number(Cursor&);\n\tstring seq(Cursor&);\n\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\tstring expression(Cursor &c){\n\t\tstring res=\"\";\n\t\tif(over)return res;\n\t\tint v=1;\n\t\twhile(c!=str.end() && *c!=')'){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;// (\n\t\t\t\tstring data=expression(c);\n\t\t\t\tREP(i,v){\n\t\t\t\t\tres+=data;\n\t\t\t\t\tif(p<(int)res.size()-1){\n\t\t\t\t\t\tover=true;ans=res[p];\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc++;// )\n\t\t\t\tv=1;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\tv=number(c);\n\t\t\t}else{//文字\n\t\t\t\tstring data(1,*c);c++;\n\t\t\t\tREP(i,v){\n\t\t\t\t\tres+=data;\n\t\t\t\t\tif(p<(int)res.size()-1){\n\t\t\t\t\t\tover=true;ans=res[p];\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv=1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\tint number(Cursor &c){\n\t    stringstream ss;\n\t    while(isdigit(*c)){\n\t        ss << *c;c++;\n\t    }\n\t    int ret;ss >> ret;\n\t    return ret;\n\t}\n\n\t// <文字>\n\tstring seq(Cursor &c){\n\t    stringstream ss;\n\t    while(isupper(*c)){\n\t        ss << *c;c++;\n\t    }\n\t    return ss.str();\n\t}\n\n}\nusing namespace SyntaxAnalysis;\n\nclass Main{\n\tpublic:\n\n\tint N;\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tover=false;ans=\"\";\n\t\t\tcin >> str;if(str==\"0\")break;\n\t\t\tcin >> p;\n\t\t\tCursor c=str.begin();\n\t\t\texpression(c);\n\t\t\tif(!over)cout << 0 <<endl;\n\t\t\telse cout <<ans <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse = \"\",int x = 0):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt()\n  {\n    return StringToInt(getCnt());\n  }\n\n  string decode()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n\t//cout << \"ret = \" << ret << endl;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+100);\n      string message = par.exp();\n      //cout << \"message = \" << message.substr(0,10) << endl;\n      if(message.size() <= pos)\n\tcout << 0 << endl;\n      else\n\tcout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int t;\nconst long long int MAX_T=1e8;\nlong long int read(int& i,string& s);\nlong long int counta(int &i,string &s);\nchar solve(int &i,string &s){\n  int prei=i;\n  long long int ret;\n  while(ret=read(i,s)){\n    prei=i;\n    if(ret==-1){\n      t--;\n      if(t==0) return s[i-1];\n    }\n    else{\n      long long int val=counta(i,s);\n      if(val*ret>=t){\n\tt%=val;\n\tif(t==0) t=val;\n\ti=prei;\n\treturn solve(i,s);\n      }\n      else{\n\tt-=val*ret;\n      }\n    }\n  }\n  return '0';\n  \n}\n\nlong long int counta(int &i,string &s){\n  long long int ret;\n  long long int res=0;\n  while(ret=read(i,s)){\n    if(ret==-1){\n      res++;\n    }\n    else{\n      res+=counta(i,s)*ret;\n      res=min(res,MAX_T);\n    }\n  }\n  return min(MAX_T,res);\n}\n\nlong long int read(int& i,string& s){\n  if(i>=s.size() || s[i]==')'){\n    i++;\n    return 0;\n  }\n  if(isalpha(s[i])){\n    i++;\n    return -1;\n  }\n\n  long long int prei=i;\n  for(;i<s.size() && isdigit(s[i]);i++);\n  long long int res=(i-prei>8 ? MAX_T :stoi(s.substr(prei,i-prei)));\n  i++;\n  return res;\n}\n\n\nint main(){\n  string s;\n  while(cin>>s>>t,s!=\"0\"){\n    int i=0;\n    t++;\n    string s2=\"\";\n    s2+=s[0];\n    for(int i=1;i<s.size();i++){\n      if(isdigit(s[i-1]) && !isdigit(s[i]) && s[i]!='('){\n\ts2+='(';\n\ts2+=s[i];\n\ts2+=')';\n      }\n      else{\n\ts2+=s[i];\n      }\n\n    }\n    s=s2;\n\n    cout<<solve(i,s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i=j;i<k;i++)\n#define rep(i,j) reps(i,0,j)\n#define InumF 1<<30\n#define fr first\n#define sc second\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\ntypedef pair<int,int> Pii;\n\nint main(){\n\tstring str;\n\tint n;\n\twhile(true){\n\t\tcin >> str;\n\t\tscanf(\"%d\",&n);\n\t\tif(str == \"0\" && n == 0)break;\n\t\tint len = str.size();\n\t\tstring numew=\"\";\n\t\tnumew += str[0];\n\t\treps(i,1,len){\n\t\t\tif(isdigit(str[i-1]) && isalpha(str[i])){\n\t\t\t\tnumew += \"(\";\n\t\t\t\tnumew += str[i];\n\t\t\t\tnumew += \")\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnumew += str[i];\n\t\t\t}\n\t\t}\n\t\tstr = numew;\n\t\tstack < int > S;\n\t\tvector<int> par(1280,-1);\n\t\tvector<int> num(1280,-1);\n\t\trep(i,str.size()){\n\t\t\tif(isdigit(str[i])){\n\t\t\t\tstring tmp = \"\";\n\t\t\t\tint j;\n\t\t\t\tfor(j = i; str[j] != '(' ;j++){\n\t\t\t\t\ttmp += str[j];\n\t\t\t\t}\n\t\t\t\tnum[i] = atoi(tmp.c_str());\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\n\t\trep(i,str.size()){\n\t\t\tif(str[i] == '('){\n\t\t\t\tfor(int j = i-1; j >= 0; j--){\n\t\t\t\t\tif(num[j] != -1){\n\t\t\t\t\t\tS.push(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[i] == ')'){\n\t\t\t\tpar[i] = S.top();\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\t//cout << num[i] << \" \";\n\t\t}\n\n\n\t\tint now = 0;\n\t\tint cnt = 0;\n\t\tvector<int> nex = num;\n\t\t\n\t\twhile(true){\n\t\t\t//cout<<now<<\"(\"<<cnt<<\")\"<<\" \";\n\t\t\tif(isalpha(str[now])){\n\t\t\t\t//cout<<str[now];\n\t\t\t\tif(cnt == n){\n\t\t\t\t\tcout<<str[now]<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnow++,cnt++;\n\t\t\t}\n\t\t\telse if(isdigit(str[now])){\n\t\t\t\tnex[now]--;\n\t\t\t\tif(nex[now] == 0)nex[now] = num[now];\n\t\t\t\tint j = now;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(str[j] == '(')break;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tnow = j;\n\t\t\t}\n\t\t\telse if(str[now] == '(')now++;\n\t\t\telse if(str[now] == ')'){\n\t\t\t\tif(nex[par[now]] == num[par[now]])now++;\n\t\t\t\telse now = par[now];\n\t\t\t}\n\t\t\tif(now == str.size()){\n\t\t\t\tcout<<0<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring str;\nll idx;\nll extendex_length;\nll pos;\n\nll a();\nstring b();\nll c();\nll number();\nstring alpha();\n\nll a(){\n  ll numofalpha = alpha().length();\n  while(pos < str.length() && isdigit(str[pos])){\n    ll num = number();\n    if(str[pos] == '('){\n      pos++;   //'('\n      ll subnumofalpha = 0;\n      subnumofalpha += a();\n      subnumofalpha += alpha().length();\n      numofalpha += num * subnumofalpha;\n      pos++;   //')'\n    }else{\n      numofalpha += num;\n      pos++;\n    }\n  }\n  return numofalpha;\n}\n\nstring b(){\n  string res = alpha();\n  while(pos < str.length() && isdigit(str[pos])){\n    ll num = number();\n    if(str[pos] == '('){\n      pos++;  //'('\n      string subres;\n      subres += b();\n      subres += alpha();\n      for(ll i=0; i < num; i++){\n        res += subres;\n        if(res.length() > idx) return res;\n      }\n      pos++;\n    }else{\n      string subres = string(1, str[pos]);\n      for(ll i=0; i < num; i++){\n        res += subres;\n      }\n      pos++;\n    }\n  }\n  return res;\n}\n\nll number(){\n  ll res = 0;\n  if(pos < str.length()){\n    while(isdigit(str[pos])){\n      res *= 10;\n      res += str[pos] - '0';\n      pos++;\n    }\n  }\n  return res;\n}\n\nstring alpha(){\n  string res;\n  while(isalpha(str[pos])){\n    res += string(1, str[pos]);\n    pos++;\n  }\n  return res;\n}\n\nint main(void){\n  while(cin >> str >> idx, str[0]-'0' || idx){\n    pos = 0;\n    extendex_length = a();\n    pos = 0;\n    string extended;\n    extended = b();\n    //cout << \"extendex_length=\" << extendex_length << \" str=\" << extended << endl;\n    if(idx >= extendex_length){\n      cout << 0 << endl;\n    }else{\n      cout << extended[idx] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nchar str[101];\n\nint seg_length(int a,int b){\n\tint len=0;\n\twhile('A'<=str[a]&&str[a]<='Z'&&a<=b){\n\t\tlen++;\n\t\ta++;\n\t}\n\tint n=0,t;\n\twhile('0'<=str[a]&&str[a]<='9'&&a<=b){\n\t\tt= str[a]-'0';\n\t\tn= n*10+t;\n\t\ta++;\n\t}\n\tif(n){\n\t\tif(str[a]=='('){\n\t\t\tint tozi=a, level=1;\n\t\t\twhile(level){\n\t\t\t\ttozi++;\n\t\t\t\tif(str[tozi]=='(')level++;\n\t\t\t\telse if(str[tozi]==')')level--;\n\t\t\t}\n\t\t\tlen+= n*seg_length(a+1,tozi-1);\n\t\t\tlen+= seg_length(tozi+1,b);\n\t\t}\n\t\telse{\n\t\t\tlen+= n+ seg_length(a+1,b);\n\t\t}\n\t}\n\tif(1000000<len)len= 1000001;\n\treturn len;\n}\nchar search(int a,int b,int target){\n\twhile('A'<=str[a]&&str[a]<='Z'&&a<=b){\n\t\tif(target==0)return str[a];\n\t\ttarget--;\n\t\ta++;\n\t}\n\tint n=0,t;\n\twhile('0'<=str[a]&&str[a]<='9'&&a<=b){\n\t\tt= str[a]-'0';\n\t\tn= n*10+t;\n\t\ta++;\n\t}\n\tif(n){\n\t\tif(str[a]=='('){\n\t\t\tint tozi=a, level=1;\n\t\t\twhile(level){\n\t\t\t\ttozi++;\n\t\t\t\tif(str[tozi]=='(')level++;\n\t\t\t\telse if(str[tozi]==')')level--;\n\t\t\t}\n\t\t\tint len= seg_length(a+1,tozi-1);\n\t\t\tif(target<n*len){\n\t\t\t\treturn search(a+1,tozi-1, target%len);\n\t\t\t}\n\t\t\treturn search(tozi+1,b, target-n*len);\n\t\t}\n\t\telse{\n\t\t\tif(target<n)return str[a];\n\t\t\treturn search(a+1,b, target-n);\n\t\t}\n\t}\n\treturn '0';\n}\nint main(){\n\tint index,len;\n\twhile(cin>>str>>index, str[0]!='0'||index!=0){\n\t\tcout<<search(0,strlen(str)-1, index)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring str;\nint pos;\nint loc;\nll now;\n\nint number() {\n\tint res = 0;\n\twhile ( pos < str.size() && isdigit(str[pos]) ) {\n\t\tres = res * 10 + (int)(str[pos] - '0');\n\t\t++pos;\n\t}\n\treturn res;\n}\nstring alp() {\n\tstring res = \"\";\n\twhile ( pos < str.size() && 'A' <= str[pos] && str[pos] <= 'Z' ) {\n\t\tres += str[pos];\n\t\t++pos;\n\t}\n\treturn res;\n}\nstring expr2() {\n\tstring res = \"\";\n\twhile (pos < str.size() && str[pos] != ')') {\n\t\tint n = 1;\n\t\tif (isdigit(str[pos])) {\n\t\t\tn = number();\n\t\t}\n\n\t\tstring a;\n\t\tif (str[pos] == '(') {\n\t\t\t++pos;\n\t\t\ta = expr2();\n\t\t\t++pos;\n\t\t}\n\t\telse {\n\t\t\ta = alp();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tres += a;\n\t\t}\n\t}\n\treturn res;\n}\nll expr() {\n\tll res = 0;\n\twhile (pos < str.size() && str[pos] != ')') {\n\t\tint n = 1;\n\t\tif (isdigit(str[pos])) {\n\t\t\tn = number();\n\t\t}\n\n\t\tint op = pos;\n\n\t\tll l;\n\t\tif (str[pos] == '(') {\n\t\t\t++pos;\n\t\t\tl = expr();\n\t\t\t++pos;\n\t\t\tnow -= l;\n\t\t}\n\t\telse {\n\t\t\tl = alp().size();\n\t\t}\n\n\t\tif (now <= loc && loc < now+l*n) {\n\t\t\tpos = op;\n\t\t\tthrow expr2()[(loc-now)%l];\n\t\t}\n\n\t\tnow += l * n;\n\t\tres += l * n;\n\t\tif (now > loc+1) now = loc+1;\n\t\tif (res > loc+1) res = loc+1;\n\t}\n\n\treturn res;\n}\n\n\nchar parse() {\n\tpos = 0;\n\n\ttry {\n\t\tnow = 0;\n\t\tpos = 0;\n\t\texpr();\n\t}\n\tcatch (char c) {\n\t\treturn c;\n\t}\n\treturn '0';\n}\n\nint main() {\n\twhile (cin >> str >> loc, str != \"0\" || loc != 0) {\n\t\tcout << parse() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[200], v[200], w[200];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\twhile (true) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tpos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << s[pos - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nint num(Cursol&);\nstring calc(Cursol&);\nstring expr(Cursol&);\n\nint pos ;\n\nint num(Cursol& p){\n  int ret = 0;\n  while(isdigit(*p)){\n    ret = ret * 10 + *p - '0';\n    p++;\n  }\n  return ret;\n}\n\nstring calc(Cursol& p){\n  string ret;\n  if(isdigit(*p)){\n    int number = num(p);\n    if( *p == '(') {\n      string res = expr(++p);\n      p++;\n      while(number--){\n        ret += res;\n        if(pos < ret.size()) break;\n      }\n    } else {\n      ret.insert(ret.end(), min( pos, number), *p++);\n    }\n  }else{\n    while(isalpha(*p)){\n      ret += *p++;\n      if(pos < ret.size()) break;\n    }\n  }\n  return ret;\n}\n\n\nstring expr(Cursol& p){\n  string ret;\n  while( isalpha(*p) || isdigit(*p)){\n    ret += calc(p);\n    if(pos < ret.size()) break;\n  }\n  return ret;\n}\nint main(){\n  string str;\n  while(cin >> str >> pos, str!=\"0\"||pos){\n    Cursol idx = str.begin();\n    string ret = expr(idx);\n    if(pos < ret.size()) cout << ret[pos] << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse,int x):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt(){return StringToInt(getCnt());}\n\n  string decode()\n  {\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    else \n      {\n\tstring mes,ret;\n\twhile('A' <= parse[pos] && parse[pos] <= 'Z')\t\n\t  mes += parse[pos++];\n\t\n\tfor(int i=0;i<power;i++)\n\t  {\n\t    ret += mes;\n\t    if(ret.size() >= x)\n\t      break;\n\t  }\n\treturn ret;\t  \n      }\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n  \n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+1);\n      string message = par.exp();\n      if(message.size() <= pos)\n\tcout << 0 << endl;\n\telse\n\t  cout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n#define ll long long\n#define INITIAL 0\n#define NUMBER 1\n#define TYPE_CHAR 0\n#define TYPE_NUM 1\n#define TYPE_OPEN 2\n#define TYPE_CLOSE 3\n#define NODE_NUM 0\n#define NODE_STR 1\n#define NODE_PLUS 2\n#define NODE_MUL 3\n#define NODE_FUNC 4\n\nstruct Node{\n  int type;\n  int counts;\n  string str;\n  vector<Node> childs;\n  ll size;\n  ll sum_size;\n  Node(int _type,int _counts,string _str){\n    type=_type;\n    counts=_counts;\n    str=_str;\n    size=0;\n    sum_size=0;\n    childs=vector<Node>();\n  }\n  ll set_size(){\n    if(type==NODE_STR){\n      size=str.size();\n    }else if(type==NODE_MUL){\n      ll sum=0;\n      for(int i=0;i<childs.size();++i){\n        sum+=childs[i].set_size();\n      }\n      if(sum>1<<30){\n        sum=1e9;\n      }\n      sum_size=sum;\n      size=sum*counts;\n    }\n    return size;\n  }\n  char find_char(ll i){\n    if(i>=size){\n      return '0';\n    }\n    if(type==NODE_STR){\n      return str[i%size];\n    }else if(type==NODE_MUL){\n      i%=sum_size;\n      for(int j=childs.size()-1;j>=0;--j){\n        Node child=childs[j];\n        if(child.size>i){\n          return child.find_char(i);\n        }else{\n          i-=child.size;\n        }\n      }\n    }\n    return 'A';\n  }\n};\n\nint char_type(char c){\n  if('0'<=c&&c<='9'){\n    return TYPE_NUM;\n  }else if('A'<=c&&c<='Z'){\n    return TYPE_CHAR;\n  }else if(c=='('){\n    return TYPE_OPEN;\n  }else if(c==')'){\n    return TYPE_CLOSE;\n  }\n}\n\nint main(){\n  string s;\n  int i;\n  cin>>s>>i;\n  while(s!=\"0\"||i!=0){\n    int n=s.size();\n    int state=INITIAL;\n    string token=\"\";\n    int times=0;\n    stack<Node> nodes;\n    for(int i=0;i<n;++i){\n      char c=s[i];\n      int type=char_type(c);\n      if(state==INITIAL){\n        if(type==TYPE_CHAR){\n          token+=c;\n        }else if(type==TYPE_NUM){\n          nodes.push(Node(NODE_STR,0,token));\n          token=\"\";\n          times=c-'0';\n          state=NUMBER;\n        }else if(type==TYPE_CLOSE){\n          Node node=Node(NODE_MUL,0,\"\");\n          node.childs.push_back(Node(NODE_STR,0,token));\n          while(nodes.top().type!=NODE_NUM){\n            node.childs.push_back(nodes.top());\n            nodes.pop();\n          }\n          node.counts=nodes.top().counts;\n          nodes.pop();\n          nodes.push(node);\n          token=\"\";\n        }\n      }else if(state==NUMBER){\n        if(type==TYPE_CHAR){\n          token+=c;\n          Node node=Node(NODE_MUL,times,\"\");\n          node.childs.push_back(Node(NODE_STR,0,token));\n          nodes.push(node);\n          times=0;\n          token=\"\";\n          state=INITIAL;\n        }else if(type==TYPE_NUM){\n          times=times*10+c-'0';\n        }else if(type==TYPE_OPEN){\n          nodes.push(Node(NODE_NUM,times,\"\"));\n          times=0;\n          state=INITIAL;\n        }\n      }\n      //cout<<i<<\" \"<<state<<\" \"<<times<<\" \"<<token<<endl;\n    }\n    if(token!=\"\"){\n      nodes.push(Node(NODE_STR,0,token));\n    }\n    Node root(NODE_MUL,0,\"\");\n    root.counts=1;\n    while(!nodes.empty()){\n      Node node=nodes.top();\n      nodes.pop();\n      root.childs.push_back(node);\n      //cout<<node.type<<\" \"<<node.counts<<\" \"<<node.str<<endl;\n    }\n    root.set_size();\n    cout<<root.find_char(i)<<endl;\n    cin>>s>>i;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(pos < str.size() && isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[pos] == '('){\n        pos++;\n        State s2 = expr(str,pos);\n        string tmp = \"\";\n        for(int i = 0; i < s1.int_result; i++){\n          tmp += s2.str_result;\n          if(tmp.size() > 1000000) break;\n        }\n        result += tmp;\n        pos = s2.pos + 1;\n      }\n      else{\n        State s2 = alphas(str,pos);\n        string tmp = \"\";\n        for(int i = 0; i < s1.int_result; i++){\n          tmp += s2.str_result;\n          if(tmp.size() > 1000000) break;\n        }\n        result += tmp;\n        pos = s2.pos;\n      }\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    if(genome == \"0\" && pos == 0) break;\n    string result = expr(genome,0).str_result;\n    if(pos < result.size()){\n      cout << result[pos] << endl;      \n    }\n    else{\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define DEBUG false\nusing namespace std;\n\nunsigned int n; // oÍ·é¶\n\nstring tab=\"\";\nstring tabN=\"  \";\n\nstring parse( string s ){\n  string r=\"\", num, tmp;\n  if( DEBUG)  tab += tabN;\n  if( s.length()>n ) return s;\n\n  for( unsigned int i=0;i<s.length();i++ ){\n    if( '0'<=s[i] && s[i]<='9' ){\n      num=\"\";\n      unsigned int j=i;\n      for( j=i;j<s.length();j++ )\n\tif( '0'<=s[j] && s[j]<='9' ) num = num + s[j];\n\telse                         break;\n      if( s[j]!='(' ){\n\ttmp = s[j];\n      }else{\n\tint a=0; // Ê\"(\"Ì - \")\"Ì\n\ttmp=\"\";\n\twhile( j<s.length() ){\n\t  if( s[j]=='(' )      ++a;\n\t  else if( s[j]==')' ) --a;\n\t  tmp = tmp + s[j++];\n\t  if( a==0 )\n\t    break;\n\t}\n\ttmp = tmp.substr( 1,tmp.length()-2 );\n      }\n      // ±Ì_Å num(tmp) ÌÅãÌ) ÌÊuªj\n      j++;\n\n      if( DEBUG )\n\tcout << tab << \"num=\"<<num << \" tmp=\" << tmp << endl;\n\n      tmp = parse( tmp );\n      string rp=\"\";\n      int rpN = atoi( num.c_str() );\n      for( int k=0;k<rpN ;k++ ){\n\trp = rp + tmp;\n\tif( i+rp.length() > n )\n\t  return s.substr( 0,i ) + rp;\n      }\n\n      string bef = s.substr( 0,i );\n      string back = \"\";\n      if( j<s.length() ) back = s.substr( j-1 );\n      s = bef + rp + back;\n      if( bef.length() > n )\n\treturn s;\n      \n      if( DEBUG ){\n\tcout << tab << \"bef =\"<<bef<<endl;\n\tcout << tab << \"rp =\"<<rp << endl;\n\tcout << tab << \"back =\"<<back << endl;\n\tcout << tab << \"s =\" << s << endl;\n      }\n    }else{\n      r = r + s[i];\n    }\n    if( r.length() > n )\n      break;\n  }\n  if( DEBUG )\n    tab = tab.substr( tabN.length() );\n\n  return r;\n}\n\nint main(){\n  string s, ans;\n\n  while( true ){\n    cin >> s >> n;\n    if( s==\"0\" && !n )\n      break;\n\n    if( DEBUG ){\n      cout << \"in : \" << s << endl;\n      cout << \"num=\" << n << endl << endl;\n    }\n    ans = parse( s );\n    if( DEBUG )\n      cout << \"return : \" << ans << endl;\n\n    if( n < ans.length() )\n      cout << ans[n] << endl;\n    else\n      cout << \"0\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nstring s;\nint index;\n\nint cur;\nbool endf;\n\nstring rec()\n{\n    string res;\n\n    while(cur < s.size() && !endf) {\n        while('A' <= s[cur] && s[cur] <= 'Z') {\n            res += s[cur];\n            cur++;\n        }\n\n        if('0' <= s[cur] && s[cur] <= '9') {\n            int n = s[cur++] - '0';\n            while('0' <= s[cur] && s[cur] <= '9') {\n                n = 10 * n + s[cur++] - '0';\n            }\n\n            string pattern;\n            if(s[cur] == '(') {\n                cur++;\n                pattern = rec();\n            } else {\n                pattern = s[cur++];\n            }\n\n            if(pattern.size() > index) {\n                res += pattern;\n                endf = true;\n                break;\n            }\n\n            for(int i = 0; i < n; ++i) {\n                res += pattern;\n            }\n        }\n\n        if(s[cur] == ')') {\n            cur++;\n            return res;\n        }\n    }\n\n    return res;\n}\n\n\nint main()\n{\n    while(true){\n        cin >> s >> index;\n        if(s == \"0\" && index == 0) break;\n\n        cur = 0;\n        endf = false;\n        string res = rec();\n        //cout << res << endl;\n        if(res.size() <= index) {\n            cout << 0 << endl;\n        } else {\n            cout << res[index] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[300], v[300], w[300];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tfor (int i = 0; i < 300; i++) p[i] = 0, v[i] = 0, w[i] = 0;\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\twhile (pos < s.size()) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tif(i != n) pos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (pos < s.size() ? s[pos] : '0') << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n#include <vector>\n#include <map>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n\nstring Str;\nint Index;\n\nclass Node {\npublic:\n  int num;\n  string s;\n  vector<Node> v;\n  Node() { num = -1; }\n};\n\nNode root;\n\nint getNum(int &pos, string s) {\n  int st = pos;\n  int length = 0;\n  while(isdigit(s[pos])) { ++length; ++pos; }\n  //cout << s << \" => \" << s.substr(st, length) << endl;\n  return atoi(s.substr(st, length).c_str());\n}\n\nchar rec(int &i, int j, Node node) {\n  //cout << node.s << \" :: \" << node.num << endl;\n  if(node.s.size()) {\n    for(int l = 0; l < node.num; ++l) {\n      for(int k = 0; k < node.s.size(); ++k) {\n\t//cout << node.s[k];\n\tif(i == j) return node.s[k];\n\t++i;\n      }\n    }\n    return '0';\n  }\n\n  for(int k = 0; k < node.num; ++k) {\n    for(int l = 0; l < node.v.size(); ++l) {\n      char c = rec(i, j, node.v[l]);\n      if(c != '0') return c;\n    }\n  }\n  return '0';\n}\n\nvector<string> sep(string s)\n{\n  string t = \"\";\n  vector<string> v, u;\n  t += s[0];\n\n  for(int i=1; i<s.size(); ++i){\n    if(s[i-1] == ')') {\n      v.push_back(t);\n      t = \"\";\n    }\n    /*\n    if( s[i-1] == ')' && isalpha(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( s[i-1] == ')' && isdigit(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( isdigit(s[i]) && isalpha(s[i-1])){\n      v.push_back(t);\n      t = \"\";\n      }*/\n    t += s[i];\n  }\n  if(t.size()) {\n    v.push_back(t);\n  }\n\n  int o, c;\n  o = c = 0;\n  t = \"\";\n  for(int i = 0; i < v.size(); ++i) {\n    if(o + c && o == c) {\n      u.push_back(t);\n      o = c = 0;\n      t = \"\";\n    }\n    t += v[i];\n    o += count(v[i].begin(), v[i].end(), '(');\n    c += count(v[i].begin(), v[i].end(), ')');\n  }\n  if(t.size()) u.push_back(t);\n  return u;\n  for(int i=0; i<u.size(); ++i){\n    cout << u[i] << \"_\";\n  }\n  cout << endl;\n  return u;\n}\n\nvoid conv(string &s) {\n  {\n    bool flag = true;\n    for(int i = 0; i < s.size(); ++i) {\n      if(!isalpha(s[i])) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    s.insert(0, \"1(\");\n    s.insert(s.size(), \")\");\n    if(flag) {\n      return;\n    }\n  }\n  for(int i = 1; i < s.length(); ++i) {\n    if((s[i-1] == ')' || s[i-1] == '(' ) && isalpha(s[i])) {\n      int p = i;\n      while(true) {\n\tif(!isalpha(s[p])) {\n\t  if(s[i-1] == '(' && s[p] == ')') break;\n\t  s.insert(i, \"1(\");\n\t  s.insert(p+2, \")\");\n\t  i = p+2;\n\t  break;\n\t}\n\t++p;\n      }\n    }\n  }\n  for(int i = 1; i+1 < s.length(); ++i) {\n    if(isdigit(s[i-1]) && isalpha(s[i])) {\n      s.insert(i, \"(\");\n      s.insert(i+2, \")\");\n    }\n  }\n}\n\nNode build(string s) {\n  //cout << s << endl;\n  Node node;\n  int num;\n  if(isalpha(s[0])) {\n    node.num = 1;\n    node.s = s;\n    return node;\n  } else {\n    int pos = 0;\n    num = getNum(pos, s);\n    /*\n    if(s[pos] != '(') {\n      node.num = num;\n      node.s = \"\";//(pos < s.size()) ? \"####\" : \"@@@\";\n      node.s += s[pos];\n      return node;\n      }*/\n    ++pos;\n    s.erase(s.begin(), s.begin()+pos);\n    s.erase(s.begin() + s.size() - 1);\n\n    /*if(count(s.begin(), s.end(), '(') == 0) {\n      node.num = num;\n      node.s = s;\n      return node;\n      }*/\n    int o, c;\n    string t = \"\";\n    o = c = 0;\n    vector<string> v = sep(s);\n    for(int i=0; i<v.size(); ++i){\n      node.v.push_back( build(v[i]) );\n    }\n  }  \n  node.num = num;\n  return node;\n  cout << node.s << endl;\n  for(int i = 0; i < node.v.size(); ++i) {\n    cout << node.v[i].s << \" \";\n  }\n  cout << endl << endl;\n  return node;\n}\n\nvoid solve() {\n  conv(Str);\n  //cout << Str << endl;\n  root = build(Str);\n  int i = 0;\n  char c  = rec(i, Index, root);\n  cout << c << endl;\n}\n\nmain() {\n  while(cin >> Str >> Index) {\n    if(Str == \"0\" && Index == 0) break;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[200], v[200], w[200];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\twhile (true) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tpos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << s[pos - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nstring str;\nbool over;string ans;\nint p;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\n//\t\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\n\tclass ParseError{};\n\t\n\tstring expression(Cursor&);int number(Cursor&);\n\tstring seq(Cursor&);\n\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\tstring expression(Cursor &c){\n\t\tstring res=\"\";\n\t\tif(over)return res;\n\t\tint v=1;\n\t\twhile(c!=str.end() && *c!=')'){\n\t\t\tif(*c=='('){\n\t\t\t\tc++;// (\n\t\t\t\tstring data=expression(c);\n\t\t\t\tREP(i,v){\n\t\t\t\t\tres+=data;\n\t\t\t\t\tif(p<=(int)res.size()-1){\n\t\t\t\t\t\tover=true;ans=res[p];\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc++;// )\n\t\t\t\tv=1;\n\t\t\t}else if(isdigit(*c)){\n\t\t\t\tv=number(c);\n\t\t\t}else{//文字\n\t\t\t\tstring data(1,*c);c++;\n\t\t\t\tREP(i,v){\n\t\t\t\t\tres+=data;\n\t\t\t\t\tif(p<=(int)res.size()-1){\n\t\t\t\t\t\tover=true;ans=res[p];\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv=1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\tint number(Cursor &c){\n\t    stringstream ss;\n\t    while(isdigit(*c)){\n\t        ss << *c;c++;\n\t    }\n\t    int ret;ss >> ret;\n\t    return ret;\n\t}\n\n\t// <文字>\n\tstring seq(Cursor &c){\n\t    stringstream ss;\n\t    while(isupper(*c)){\n\t        ss << *c;c++;\n\t    }\n\t    return ss.str();\n\t}\n\n}\nusing namespace SyntaxAnalysis;\n\nclass Main{\n\tpublic:\n\n\tint N;\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tover=false;ans=\"\";\n\t\t\tcin >> str;if(str==\"0\")break;\n\t\t\tcin >> p;\n\t\t\tCursor c=str.begin();\n\t\t\texpression(c);\n\t\t\tif(!over)cout << 0 <<endl;\n\t\t\telse cout <<ans <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <algorithm>\n#include <iostream>\n#include <cctype>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\nstring s;\n\nint number(size_t &c){\n  int res = 0;\n  while(c < s.size() && isdigit(s[c])){\n    res = res * 10 + s[c++] - '0';\n  }\n  return res;\n}\n\nchar expr(int n, int &rest, size_t &cur){\n  size_t end;\n  size_t  cur2 = cur;\n  \n  while(n--){\n \n    while(cur2 < s.size() && s[cur2] != ')'){\n  \n      if(!isdigit(s[cur2])){\n\tif(rest == 0) {\n\t  return s[cur2];\n\t}else{\n\t  cur2++;\n\t  rest--;\n\t}\n      }else{\n\tint num = number(cur2);\n\tif(s[cur2] == '('){\n\t  cur2++;\n\t  char ch = expr(num, rest, cur2);\n\t  if(ch != '*') return ch;\n\t  assert(s[cur2] == ')');\n\t  cur2++;\n\t}else{\n\t  if(rest < num){\n\t    return s[cur2];\n\t  }else{\n\t    rest -= num;\n\t    cur2++;\n\t  }\n\t}\n      }\n    }\n    end = cur2;\n    cur2 = cur;\n  }\n  cur = end;\n  return '*';\n}\n  \nint main(){\n  size_t cur;\n  int ind;\n  while(cin >> s >> ind && (s != \"0\" || ind != 0)){\n    cur = 0;\n    char res = expr(1, ind, cur);\n    if(res != '*') cout << res << endl;\n    else cout << 0 << endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m;\nchar ans;\nbool flag = false;\nstring dfs(string s) {\n\t//cout << s << endl;\n\tif(flag) return \"\";\n\tif('A' <= s[0] && s[0] <= 'Z') {\n\t\treturn s;\n\t}\n\t//10C??????????????????????¢????\n\tbool h = false;\n\tstring tt = \"\";\n\tint idx = 0;\n\tREP(i, s.size()) {\n\t\tif(i >= 5) break;\n\t\tif(s[i] == '(') h = true;\n\t\tif(isdigit(s[i])) tt += s[i], idx = i;\n\t}\n\tstring ret = \"\";\n\tif(!h) {\n\t\tstring tmp = dfs(s.substr(idx+1));\n\t\tint itt = stoi(tt);\n\t\t//cout << \"tmp\" << tmp << \"itt\" << itt << endl;\n\t\tREP(i, itt) {\n\t\t\tret += tmp;\n\t\t\t//cout << ret << endl;\n\t\t\tif((int)ret.size() > m) {\n\t\t\t\tans = ret[m];\n\t\t\t\tflag = true;\n\t\t\t\t//cout << ans << endl;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstring num = \"\", para = \"\";\n\tint now = 0;\n\tbool f = true, g = false;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '(') {\n\t\t\tg = true;\n\t\t\tnow++;\n\t\t} else if(s[i] == ')') {\n\t\t\tnow--;\n\t\t} else if(isdigit(s[i])){\n\t\t\tf = false;\n\t\t} else {\n\t\t\tf = true;\n\t\t}\n\t\tif(g) para += s[i];\n\t\telse num += s[i];\n\t\tif(now == 0 && f) {\n\t\t\t//tmp???dfs?????????????????°?????????????????????ret????????????\n\t\t\tint ttmp = stoi(num);\n\t\t\tstring dret = dfs(para.substr(1, para.size()-2));\n\t\t\tREP(j, ttmp) {\n\t\t\t\tret += dret;\n\t\t\t\tif((int)ret.size() > m) {\n\t\t\t\t\tans = ret[m];\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tnum = \"\", para = \"\";\n\t\t\tf = true, g = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\n\t\tflag = false;\n\n\t\tbool f = true;\n\t\tint now = 0;\n\t\tstring tmp = \"\";\n\t\tREP(i, s.size()) {\n\t\t\t//cout << \"i:\" << i << \" \" << s[i] << endl;\n\t\t\tif(s[i] == '(') now++;\n\t\t\telse if(s[i] == ')') now--;\n\t\t\telse if(isdigit(s[i])) f = false;\n\t\t\telse f = true;\n\t\t\ttmp += s[i];\n\t\t\t//cout << tmp << \" \" << m << endl;\n\t\t\tif(now == 0 && f) {\n\t\t\t\tstring t = dfs(tmp);\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif(flag) {cout << ans << endl; goto e;}\n\t\t\t\telse if((int)t.size() <= m) {\n\t\t\t\t\tm -= t.size();\n\t\t\t\t}\telse {cout << t[m] << endl; goto e;}\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t\te:\n\t\tint a;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint k;\nstring s, ans;\n\ntypedef string::const_iterator State;\n\nint number(State& p){\n\tint res = 0;\n\twhile(isdigit(*p)){\n\t\tres *= 10;\n\t\tres += *p - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nstring expr(State& p){\n\tstring res;\n\twhile(true){\n\t\tif(p == s.end()) break;\n\t\tif(res.size() > k) break;\n\n\t\tif(isdigit(*p)){\n\t\t\tint loop = number(p);\n\n\t\t\tstring tmp;\n\t\t\tif(*p == '('){\n\t\t\t\tp++;\n\t\t\t\ttmp = expr(p);\n\t\t\t\tp++;\n\t\t\t}else{\n\t\t\t\ttmp += *p;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\trep(i,loop){\n\t\t\t\tif(res.size() > k) break;\n\t\t\t\tres += tmp;\n\t\t\t}\n\t\t}else if(isupper(*p)){\n\t\t\tres += *p;\n\t\t\tp++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> s >> k, s != \"0\"){\n\t\tState tmp = s.begin();\n\t\tstring t = expr(tmp);\n\t\tif(t.size() - 1 < k) cout << 0 << endl;\n\t\telse cout << t[k] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000100\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n\n    int flg2=0;\n    while(f){\n      f=0;\n      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e;\n\t}\n\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    if(flg2) idx=s[c].size();\n\t    if(idx==s[c].size())flg2=1;\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<N;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nclass Node\n{\npublic:\n\tchar c;\n\tint num;\n\tint total;\n\tvector<Node> child;\n\tNode(int num0, char c0){\n\t\tnum = num0;\n\t\tc = c0;\n\t\ttotal = 0;\n\t}\n};\n\nvoid solve(string s, int a)\n{\n\tNode root(1, '(');\n\tNode* pNode = &root;\n\tstack<Node*> stkNode;\n\tistringstream iss(s);\n\n\tfor(;;){\n\t\tint tmp;\n\t\tif(!(iss >> tmp)){\n\t\t\tif(iss.eof())\n\t\t\t\tbreak;\n\t\t\ttmp = 1;\n\t\t\tiss.clear();\n\t\t}\n\t\tchar c;\n\t\tiss >> c;\n\t\tif(c == ')'){\n\t\t\tpNode = stkNode.top();\n\t\t\tstkNode.pop();\n\t\t\tpNode->total += pNode->child.rbegin()->total * pNode->child.rbegin()->num;\n\t\t\tif(pNode->total > MAX)\n\t\t\t\tpNode->total = MAX;\n\t\t}else{\n\t\t\tpNode->child.push_back(Node(tmp, c));\n\t\t\tif(c == '('){\n\t\t\t\tstkNode.push(pNode);\n\t\t\t\tpNode = &(*pNode->child.rbegin());\n\t\t\t}else{\n\t\t\t\tpNode->child.rbegin()->total = 1;\n\t\t\t\tpNode->total += tmp;\n\t\t\t\tif(pNode->total > MAX)\n\t\t\t\t\tpNode->total = MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(pNode->total <= a){\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\n\tfor(;;){\n\t\ta %= pNode->total;\n\t\tfor(int i=0; ; ++i){\n\t\t\tif(a < pNode->child[i].total * pNode->child[i].num){\n\t\t\t\tpNode = &(pNode->child[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta -= pNode->child[i].total * pNode->child[i].num;\n\t\t}\n\t\tif(pNode->c != '('){\n\t\t\tcout << pNode->c << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring s;\n\t\tint a;\n\t\tcin >> s >> a;\n\t\tif(s == \"0\" && a == 0)\n\t\t\tbreak;\n\n\t\tsolve(s, a);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring expr;\nint p,s,l;\nchar ans;\n\nint parseInt()\n{\n\tint ret=0;\n\twhile(p<expr.size())\n\t{\n\t\tif(!isdigit(expr[p])) break;\n\t\tret*=10;\n\t\tret+=expr[p]-'0';\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nstring parseStr()\n{\n\tstring ret;\n\twhile(p<expr.size())\n\t{\n\t\tif(!isupper(expr[p])) break;\n\t\tret+=expr[p];\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nbool parse()\n{\n\tint lp=parseInt(), tp=p;\n\tstring str;\n\tif(expr[p]=='(')\n\t{\n\t\twhile(lp--)\n\t\t{\n\t\t\tp=tp;\n\t\t\tp++;\n\t\t\tif(parse()) return true;\n\t\t}\n\t\tp++;\n\t}\n\telse\n\t{\n\t\tif(lp==0) lp++;\n\t\tstr=parseStr();\n\t\t\n\t\tfor(int i=0; i<lp; i++) \n\t\t{\n\t\t\tif(s+str.size() > l)\n\t\t\t{\n\t\t\t\tint ex=l-s;\n\t\t\t\tans=str[ex];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts+=str.size();\n\t\t}\n\t}\n\n\tif(p<expr.size() && expr[p]!=')') return parse();\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> expr >> l, (expr!=\"0\"||l))\n\t{\n\t\tp=0; s=0; ans='0';\n\t\t\n\t\tparse();\n\t\tprintf(\"%c\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    string pattern;\n    ll len,factor;\n    vector<Node*> child;\n};\n\nint p;\n\nNode *parse(string &s) {\n    if(isdigit(s[p])) {\n        int r = 0;\n        while(isdigit(s[p])) {\n            r *= 10;\n            r += s[p] -'0';\n            p++;\n        }\n\n        Node *node = new Node();\n        node->factor = r;\n        if(s[p] == '(') {\n            p++;\n            while(s[p] != ')') {\n                Node *nr = parse(s);\n                node->child.push_back(nr);\n            }\n            p++;\n            node->len = 0;\n            for(int i=0; i<node->child.size(); ++i) {\n                node->len += node->child[i]->len;\n            }\n            node->len *= node->factor;\n            return node;\n        }else{\n            node->pattern = string(1,s[p]);\n            p++;\n            node->len = r;\n            return node;\n        }\n    }\n\n    Node *node = new Node();\n    string pattern = \"\";\n    while(p < s.length() && isalpha(s[p])) {\n        pattern += string(1,s[p]);\n        p++;\n    }\n    node->pattern = pattern;\n    node->len = pattern.length();\n    node->factor = 1;\n    return node;\n}\n\nvoid dff(Node *v) {\n    cout<<v->len<<\" -> \"<<v->pattern<<endl;\n    for(int i=0; i<v->child.size(); ++i)\n        dff(v->child[i]);\n}\n\nchar dfs(Node *v,ll idx) {\n    if(v->child.empty()) {\n        string pat = v->pattern;\n//        cout<<pat.length()<<\" \"<<v->factor<<\" \"<<idx<<\" \"<<pat<<endl;\n        if(idx < v->factor*pat.length()) return pat[idx%(pat.length())];\n        v->len = pat.length()*(v->factor);\n        return '-';\n    }\n\n    ll offset = 0;\n    for(int i=0; i<v->child.size(); ++i) {\n        char c = dfs(v->child[i],idx-offset);\n        if(c != '-') return c;\n        offset += v->child[i]->len;\n    }\n    if(idx/offset < v->factor) {\n        idx %= offset;\n        return dfs(v,idx);\n    }\n    v->len = offset*v->factor;\n    return '-';\n}\n\nint main() {\n    int n;\n    string s;\n    while(cin>>s) {\n        cin>>n;\n        if(s == \"0\" && n == 0) break;\n        p = 0;\n        s += \")\";\n        s = \"1(\" + s;\n        Node *root = parse(s);\n\n//        dff(root);\n        char ans = dfs(root,n);\n        if(ans == '-') cout<<\"0\"<<endl;\n        else cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstring s;\nstring res;\nll K;\n\nbool dfs(int l,int r){\n  bool is_str=true;\n  repl(i,l,r){\n      if(s[i]=='('||s[i]==')'||isdigit(s[i]))is_str=false;\n  }\n  if(is_str){\n    res+=s.substr(l,r-l);\n    return res.length()>K;\n  }\n\n  if(isdigit(s[l])){\n    int i=l;\n    while(i<r&&isdigit(s[i]))i++;\n    int cnt=stoi(s.substr(l,i-l));\n    if(s[i]=='('){\n      int j=i+1;\n      int level=1;\n      while(j<r&&level!=0){\n        if(s[j]=='(')level++;\n        if(s[j]==')')level--;\n        j++;\n      }\n      rep(c,cnt){\n        if(dfs(i+1,j-1))return true;\n      }\n      if(dfs(j,r))return true;\n    }else{\n      rep(c,cnt){\n        if(dfs(i,i+1))return true;\n      }\n      if(dfs(i+1,r))return true;\n    }\n  }else{\n    if(dfs(l,l+1))return true;\n    if(dfs(l+1,r))return true;\n  }\n  return false;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>s>>K;\n    if(s==\"0\")break;\n    res=\"\";\n    int n=s.length();\n    if(!dfs(0,n))cout<<0<<endl;\n    else cout<<res[K]<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <stack>\n#define DEBUG false\nusing namespace std;\n\nunsigned int n; // oÍ·é¶\n\nstruct P {\n  unsigned int i; // JèÔµêÌæªÌindex\n  int n;          // JèÔµñ\n};\n\nbool isDigit( char c ){\n  if( '0'<= c && c <= '9' ) return true;\n  return false;\n}\n\nstring rev(string s ){ // 1¶ÌJèÔµÉ'('')' ðÂ¯é\n  for( unsigned int i=0;i<s.length();i++ ){\n    while( i<s.length() && !isDigit(s[i]) ) ++i;\n    if( isDigit(s[i]) ){\n      while( isDigit(s[i]) ) ++i;\n      if( s[i]!='(' ){\n\tstring bc=\"\";\n\tif( i+1<s.length() ) bc = s.substr(i+1);\n\ts = s.substr( 0,i ) + \"(\" + s[i] + \")\" + bc;\n      }\n      ++i;\n    }\n    ++i;\n  }\n  if( DEBUG )  cout << \"rev : \" << s << endl;\n  return s;\n}\n\n/* ið®©µÄ¢«A¶ð©½ñ¾¯nð¸ç· */\nchar parse( string s ){\n  const char *c = s.c_str();\n  unsigned int i=0;\n  stack<P> st;   // '('ÌÊuðL^\n  P p;\n  if( DEBUG ) cout << \"parse : \" << s << \" len=\" << s.length() << endl;\n\n  while( i<s.length() ){\n    if( DEBUG ) cout << \"while : i=\"<<i<<\" n=\"<<n<< \" s[i]=\"<<s[i] \n\t\t     << \" stack:\"<< st.size() << \" p.n=\" << p.n << endl;\n    if( isDigit( s[i] ) ){\n      int num = atoi( c+i );\n      if( DEBUG ) cout << \"num=\" << num << endl;\n      while( isDigit( s[i] ) ) ++i;\n      i++;  // '(' ÌªðCNg·é\n      p.i=i; p.n=num;\n      st.push( p ); // JèÔµÌÅÌ¶ðÇÁ\n    }else if( s[i]==')' ){\n      p = st.top(); st.pop();\n      if( --p.n != 0 ){  st.push( p ); i=p.i; }\n      else ++i;\n    }else {\n      if( n==0 )\n\treturn s[i];\n      --n;\n      ++i;\n    }\n  }\n  return '0';\n}\n\nint main(){\n  string s;\n  while( cin>>s>>n && (s!=\"0\"|| n ) ){\n    if( DEBUG ){\n      cout << \"\\nn=\" << n << \" in : \" << s << endl;\n    }\n   \n    if( DEBUG )\n      cout << \"answer=\";\n    cout << parse( rev(s) ) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e13 + 9;\n\n#define int ll\n#define double ld\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\t\n\tstring s; int I;\n\twhile (cin >> s >> I && s != \"0\") {\n\t\tstruct node {\n\t\t\tint sum;\n\t\t\tvector<int> to;\n\t\t\tstring s;\n\t\t};\n\t\ts = s + \")\";\n\t\tmap<int, char, greater<int>> add;\n\t\tFor(i,1, s.size()) {\n\t\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\t\tif (s[i - 1] != '(' && !(s[i-1] >= 'A' && s[i-1] <= 'Z')) {\n\t\t\t\t\tadd[i] = '(';\n\t\t\t\t\tadd[i+1] = ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\teach(i, add) {\n\t\t\ts.insert(s.begin() + i.first, i.second);\n\t\t}\n\n\t\tvector<node> nd;\n\t\tnd.push_back(node());\n\t\tfunction<int(int, int)> make_node = [&](int n, int t) {\n\t\t\tint sn = n;\n\t\t\twhile (s[n] >= 'A' && s[n] <= 'Z') {\n\t\t\t\tnd[t].s.push_back(s[n]); n++;\n\t\t\t}\n\t\t\tnd[t].sum = nd[t].s.size();\n\t\t\tfor (;; n++) {\n\t\t\t\tif (s[n] == '(') {\n\t\t\t\t\tint tp = toint(s.substr(sn, n - sn));\n\t\t\t\t\tnd.push_back(node());\n\t\t\t\t\tint tt = nd.size() - 1;\n\t\t\t\t\tn = make_node(n + 1, tt);\n\t\t\t\t\tnd[tt].sum *= tp;\n\t\t\t\t\tnd[tt].sum = min(INF, nd[tt].sum);\n\t\t\t\t\tnd[t].sum += nd[tt].sum;\n\t\t\t\t\tnd[t].sum = min(INF, nd[t].sum);\n\t\t\t\t\tnd[t].to.push_back(tt);\n\t\t\t\t\tsn = n + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s[n] == ')') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmake_node(0, 0);\n\n\t\tfunction<bool(int, int)> search = [&](int t,int c) {\n\t\t\tif (nd[t].s.size()) {\n\t\t\t\tc %= nd[t].s.size();\n\t\t\t\tcout << nd[t].s[c] << endl;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tint minus = 0;\n\t\t\twhile (1) {\n\t\t\t\teach(to, nd[t].to) {\n\t\t\t\t\tif (nd[to].sum > c) {\n\t\t\t\t\t\tif (search(to, c))return true;\n\t\t\t\t\t}\n\t\t\t\t\tc -= nd[to].sum;\n\t\t\t\t\tminus += nd[to].sum;\n\t\t\t\t\tif (minus > nd[t].sum)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (nd[0].sum <= I || search(0, I) == false) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint n;\n\nstring rec(string s, int repeat) {\n  repeat = min(repeat,1000000);\n  int f = 0;                 // f : 0.ÈñÅàÈ¢ 1.ÊíÌ¶ñ 2. 3.Êà\n  int start = 0;\n  int re = 0;\n  int nest = 0;\n  string res;\n  REP(i,s.size()) {\n    if (f == 0) {\n      if (isalpha(s[i])) {\n        start = i;\n        f = 1;\n      } else if (isdigit(s[i])) {\n        start = i;\n        f = 2;\n      }\n    } else if (f == 1) {\n      if (isdigit(s[i])) {\n        res += s.substr(start, i-start);\n        f = 2;\n      }\n    } else if (f == 2) {\n      if (isalpha(s[i])) {\n        re = atoi(s.substr(start, i-start).c_str());\n        res += string(re,s[i]);\n      } else if (s[i] == '(') {\n        re = atoi(s.substr(start, i-start).c_str());\n        f = 3;\n        start = i;\n        nest = 1;\n      }\n    } else if (f == 3) {\n      if (s[i] == '(') nest++;\n      else if (s[i] == ')') nest--;\n      if (nest == 0) {\n        res += rec(s.substr(start+1, i-start-1), re);\n        f = 0;\n      }\n    }\n    if (res.size() > n) return res;\n  }\n  if (f == 1) {\n    res += s.substr(start, s.size()-start);\n  }\n  string tmp = res;\n  REP(i, repeat-1) {\n    if (res.size() > n) return res;\n    res += tmp;\n  }\n  return res;\n}\n\nint main() {\n  string s;\n  while(cin>>s>>n,s!=\"0\"||n) {\n    string res = rec(s,1);\n    // cout << res << endl;\n    if (res.size() > n) {\n      cout << res[n] << endl;\n    }else\n      cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nconst int MAX_LEN = 1000005;\n\nstring s;\n\nvoid dfs(int& cur, string& t)\n{\n    if(cur >= len(s)-1){\n        return;\n    }\n    while(cur < len(s)-1){\n        if(isdigit(s[cur])){\n            int st = cur;\n            while(isdigit(s[cur])){\n                cur++;\n            }\n            int num = stoi(s.substr(st,cur-st));\n            if(isalpha(s[cur])){\n                rep(i,num){\n                    t.pb(s[cur]);\n                }\n            }else{\n                if(cur >= len(s)-1){\n                    return;\n                }\n                cur++;\n                string u;\n                dfs(cur,u);\n                rep(i,num){\n                    t += u;\n                    if(len(t) >= MAX_LEN){\n                        return;\n                    }\n                }\n            }\n        }else{\n            while(isalpha(s[cur])){\n                t.pb(s[cur]);\n                cur++;\n            }\n            if(s[cur] == ')'){\n                cur++;\n                return;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> s >> n;\n        if(s == \"0\" && n == 0){\n            break;\n        }\n        s.pb('%');\n        string t;\n        int num = 0;\n        dfs(num,t);\n        if(len(t) <= n){\n            cout << \"0\\n\";\n        }else{\n            cout << t[n] << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[300], v[300], w[300];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tmemset(p, 0, sizeof(p));\n\t\tmemset(w, 0, sizeof(w));\n\t\tmemset(v, 0, sizeof(v));\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\twhile (pos < s.size()) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tif(i != n) pos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (pos < s.size() ? s[pos] : '0') << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nint n, p;\nstring str;\n\nstring dfs(){\n    int res = 0;\n    string st = \"\";\n    while (p < str.size()) {\n        if (isdigit(str[p])) {\n            res = 0;\n            while (isdigit(str[p])) {\n                res *= 10;\n                res += str[p] - '0';\n                p++;\n            }\n        }else if (isalpha(str[p])){\n            st = \"\";\n            while (isalpha(str[p])) {\n                st += str[p++];\n            }\n        }else if (str[p] == '('){\n            p++;\n            string s = dfs();\n            for (int i = 0; i < res; i++) {\n                if (st.size() > n) {\n                    return st;\n                }\n                st += s;\n            }\n        }else if (str[p] == ')'){\n            p++;\n            return st;\n        }\n    }\n    return st;\n}\n\nstring gen_new_str(){\n    int p = 0;\n    string st = \"\";\n    while (p < str.size()) {\n        if (!isalpha(str[p]) && isalpha(str[p+1])) {\n            st += str[p];\n            if (isdigit(str[p])) {\n                st += \"(\";\n            }else{\n                st += \"1(\";\n            }\n            p++;\n            while (isalpha(str[p])) {\n                st += str[p++];\n            }\n            st += \")\";\n        }else{\n            st += str[p++];\n        }\n    }\n    return st;\n}\n\nint main()\n{\n    while (true) {\n        cin >> str >> n;\n        if (str == \"0\") {\n            break;\n        }\n        p = 0;\n        str = gen_new_str();\n        string ans = dfs();\n        if (ans.size() <= n) {\n            cout << 0 << endl;\n        }else{\n            cout << ans[n] << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool flag;\nlong long solve(const string s,long long I)\n{\n\t//cout<<s<<\" \"<<I<<endl;\n\tlong long cnt=0;\n\tfor(int f=0;!flag&&f<s.size();f++)\n\t{\n\t\tif(s[f]>='A'&&s[f]<='Z')\n\t\t{\n\t\t\twhile(!flag&&f<s.size()&&s[f]>='A'&&s[f]<='Z')\n\t\t\t{\n\t\t\t\tf++,cnt++;\n\t\t\t\tif(I==cnt)\n\t\t\t\t{\n\t\t\t\t\tcout<<s[f-1]<<endl;\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf--;\n\t\t}\n\t\telse if(s[f]>='0'&&s[f]<='9')\n\t\t{\n\t\t\tlong long now=0;\n\t\t\twhile(s[f]>='0'&&s[f]<='9')now=now*10+s[f]-'0',f++;\n\t\t\tif(s[f]>='A'&&s[f]<='Z')\n\t\t\t{\n\t\t\t\tcnt+=now;\n\t\t\t\tif(I<=cnt&&!flag)\n\t\t\t\t{\n\t\t\t\t\tcout<<s[f]<<endl;\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint l=f+1;\n\t\t\t\tint d=1;\n\t\t\t\twhile(d)\n\t\t\t\t{\n\t\t\t\t\tif(s[l]=='(')d++;\n\t\t\t\t\telse if(s[l]==')')d--;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tl--;\n\t\t\t\tlong long A=solve(s.substr(f+1,l-f-1),I-cnt);//(I-cnt+now-1)%now+1);\n\t\t\t\tif(I<=cnt+A*now&&!flag)\n\t\t\t\t{\n\t\t\t\t\tsolve(s.substr(f+1,l-f-1),(I-cnt+A-1)%A+1);\n\t\t\t\t}\n\t\t\t\tcnt+=A*now;\n\t\t\t\tf=l;\n\t\t\t}\n\t\t}\n\t}\t\n\treturn cnt;\n}\nmain()\n{\n\tstring s;long long I;\n\twhile(cin>>s>>I,s!=\"0\")\n\t{\n\t\tflag=false;\n\t\tsolve(s,I+1);\n\t\tif(!flag)cout<<0<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <vector>\n#include <ctype.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Node {\n  ll length;\n  ll size;\n  ll loop;\n  char c;\n  vector<Node> child;\n  Node() : length(0), size(0), loop(1), c(0) {;}\n};\n\nchar str[1000];\n\nNode parse(ll &index, ll loop) {\n  Node ret;\n  if (isalpha(str[index])) {\n    ret.length = 1;\n    ret.c = str[index];\n    index++;\n  } else if (isdigit(str[index])) {\n    ll nloop = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n    if (isalpha(str[index])) {\n      ret.child.push_back(parse(index, nloop));\n      ret.length += ret.child[ret.child.size() - 1].size;\n    } else {\n      assert(str[index] == '(');\n      index++;\n      while (str[index] != ')') {\n        ret.child.push_back(parse(index, nloop));\n        ret.length += ret.child[ret.child.size() - 1].size;\n      }\n      assert(str[index] == ')');\n      index++;\n    }\n  }\n  ret.size = ret.length * loop;\n  ret.length = min(ret.length, 1000000000LL);\n  ret.size = min(ret.size, 1000000000LL);\n  ret.loop = loop;\n  return ret;\n}\n\nchar nodechar(const Node &node, int n) {\n  if (node.size <= n) { return '0'; }\n  n %= node.length;\n  if (n == 0 && node.c != 0) { return node.c; }\n  REP(i, node.child.size()) {\n    const Node &target = node.child[i];\n    if (target.size > n) {\n      return nodechar(target, n);\n    }\n    n -= target.size;\n  }\n  assert(false);\n  return 0;\n}\n\nint main() {\n  ll n;\n  while (scanf(\"%s %lld\", str, &n), str[0] != '0' || n) {\n    ll index = 0;\n    Node root;\n    while (str[index] != '\\0') {\n      root.child.push_back(parse(index, 1));\n      root.size += root.child[root.child.size() - 1].size;\n      root.length += root.child[root.child.size() - 1].size;\n    }\n    printf(\"%c\\n\", nodechar(root, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse = \"\",int x = 0):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt()\n  {\n    return StringToInt(getCnt());\n  }\n\n  string decode()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    else \n      {\n\tstring mes,ret;\n\twhile('A' <= parse[pos] && parse[pos] <= 'Z')\t\n\t  mes += parse[pos++];\n\t\n\tfor(int i=0;i<power;i++)\n\t  {\n\t    ret += mes;\n\t    if(ret.size() >= x)\n\t      break;\n\t  }\n\treturn ret;\t  \n      }\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n\t//cout << \"ret = \" << ret << endl;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+10);\n      string message = par.exp();\n      //cout << \"message = \" << message << endl;\n      if(message.size() <= pos)\n\tcout << 0 << endl;\n      else\n\tcout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar buf[111];\nint I;\nint N;\n\n\nint cnt;\nbool FLAG;\nstring Character();\nstring String();\nint Number();\n\nstring Character(){\n  string ret = \"\";\n  if( 'A' <= buf[cnt]  && buf[cnt] <= 'Z' ) return ret+buf[cnt++];\n  else return \"\";\n}\n\nstring String(){\n  string ret = \"\";\n  while( 'A' <= buf[cnt] && buf[cnt] <= 'Z' ) {\n    ret += buf[cnt];\n    cnt++;\n  }\n  return ret;\n}\n\nint Number(){\n  int it = cnt;\n  int ret = 0;\n  while( '0' <= buf[cnt] && buf[cnt] <= '9' ) {\n    ret *= 10;\n    ret += buf[cnt]-'0';\n    cnt++;\n  }\n  if( it == cnt ) return -1;\n  return ret;\n}\n\nvoid output( int strnum, string ret ){\n  if(FLAG) return;\n  int rd = (I-strnum)%(int)ret.size();\n  cout << ret[rd] << endl;\n  FLAG = true;\n}\n\nstring Genom(int strnum){\n  string rets=\"\";\n  while( !FLAG && cnt < N ){\n    int num = Number();\n\n    // cout << num <<\" \"<< cnt << \" \"<< strnum << \" \" << buf[cnt]<< \" \" << rets <<  endl;\n    if( buf[cnt] == ')' ) break;\n    string ret;\n    if( num == -1 ){\n      ret = String();\n      if( strnum + (int)ret.size() > I ){\n\toutput( strnum, ret );\n\treturn \"-\";\n      }\n      rets+=ret;\n      strnum += ret.size();\n    } else {\n      if( buf[cnt] == '(' ){\n\tcnt++;\n\tret = Genom(strnum);\n\tif( strnum + (int)ret.size() * num > I ){\n\t  output( strnum, ret );\n\t  return \"-\";\n\t}\n\tfor(int i=0;i<num;i++) rets+=ret;\n\tstrnum += ret.size()*num;\n\tcnt++;\n      } else {\n\tret = Character();\n\tif( strnum + (int)ret.size() * num > I ){\n\t  output( strnum, ret );\n\t  return \"-\";\n\t}\n\tfor(int i=0;i<num;i++) rets+=ret;\n\tstrnum += ret.size()*num;\n      }\n    } \n  }\n  return rets;\n}\n\nint solve(){\n  cnt = 0;\n  N = strlen(buf);\n  FLAG = false;\n  Genom(0);\n  if( !FLAG ) cout << 0 << endl;\n}\n\nint main(){\n  while( 1 ){\n    cin >> buf >> I;\n    if( buf[0] == '0' && I == 0 ) break;\n    solve(); \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstring st;\nint now = 0;\n\nstring getst(bool isone=false) {\n\tstring genom;\n\twhile (isalpha(st[now])) {\n\t\tgenom += st[now];\n\t\tnow++;\n\t\tif (isone)break;\n\t}\n\treturn genom;\n}\nint getcount() {\n\tlong long int num = 0;\n\twhile (isdigit(st[now])) {\n\t\tnum = num * 10 + st[now] - '0';\n\t\tnow++;\n\t}\n\treturn num;\n}\n\npair<string,char> check(long long int rest,long long int kakeru) {\n\tif (kakeru > 1e8) {\n\t\tkakeru = 1e8;\n\t}\n\tlong long int num = 1;\n\tstring nst;\n\tbool isstart = true;\n\tbool prenum = false;\n\twhile (1) {\n\t\tif (st.size() <= now)break;\n\t\tif (st[now] == '(') {\n\t\t\tnow++;\n\t\t\tpair<string,char>p=check(rest,num);\n\t\t\tif (p.second == '0') {\n\t\t\t\tnst += p.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn make_pair(\"\",p.second);\n\t\t\t}\n\t\t\tprenum = false;\n\t\t}\n\t\telse if (st[now] == ')') {\n\t\t\tnow++;\n\t\t\tbreak;\n\t\t}\n\t\telse if(isalpha(st[now])){\n\t\t\tstring genom;\n\t\t\tif (!prenum) {\n\t\t\t\tgenom = getst();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgenom = getst(true);\n\t\t\t}\n\t\t\tif (genom.size()*kakeru*num > rest) {\n\t\t\t\treturn make_pair(\"\", genom[rest%genom.size()]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//rest -= genom.size()*kakeru*num;\n\t\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\t\tnst += genom;\n\t\t\t\t\tif (nst.size() > 1e6)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = 1;\n\t\t\tprenum = false;\n\t\t}\n\t\telse {\n\t\t\tassert(isdigit(st[now]));\n\t\t\tnum = getcount();\n\t\t\tprenum = true;\n\t\t}\n\n\t\tisstart = false;\n\t}\n\tstring finst;\n\tfor (int i = 0; i < kakeru; ++i) {\n\t\tfinst += nst;\n\t\tif (finst.size() > 1e6)break;\n\t}\n\tif (finst.size() > rest)return make_pair(\"\",finst[rest]);\n\treturn make_pair(finst, '0');\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"0\")break;\n\t\tnow = 0;\n\t\tint n; cin >> n;\n\t\tpair<int, char>p;\n\t\tchar ans=check(n,1).second;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1000000) { num = 1000000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str,ans;\nint n,pos;\n\nstring saiki(int S){\n  int k=1;\n  string res,s;\n  while(pos<(int)str.size()&&str[pos]!=')'&&res.size()+S>n){\n    if('0'<=str[pos]&&str[pos]<='9') {\n      k=0;\n      while('0'<=str[pos]&&str[pos]<='9')k=k*10+str[pos++]-'0';\n    }\n    else if(str[pos]=='('){\n      pos++;\n      s=saiki(res.size()+S);\n      pos++;\n      for(int i=0;i<k&&res.size()+S<=n;i++)res+=s;\n      k=1;\n    }\n    else {\n      for(int i=0;i<k;i++) res+=str[pos];\n      pos++;\n      k=1;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>str>>n;\n    if(str==\"0\"&&n==0)break;\n    pos=0;\n    ans=\"\";\n    ans=saiki(0);\n    if(ans.size()<=n)cout<<0<<endl;\n    else cout <<ans[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstring S;\nint N;\n\nint main(void) {\n  while(cin >> S >> N) {\n    if(S[0] == '0' && N == 0) break;\n    int p = 0, cnt = 0;\n    stack<pii> stk;\n\n    char ans = '0';\n    while(p < S.length()) {\n      if('0' <= S[p] && S[p] <= '9') {\n        int itr = 0;\n        for(; '0' <= S[p] && S[p] <= '9'; p++) itr = itr * 10 + (S[p] - '0');\n        if(S[p] == '(') {\n          p++;\n          stk.push(pii(itr, p));\n        } else {\n          while(itr--) {\n            // cout << S[p];\n            if(cnt == N) {\n              ans = S[p];\n              break;\n            }\n            cnt++;\n          }\n          p++;\n        }\n      } else if('A' <= S[p] && S[p] <= 'Z') {\n        // cout << S[p];\n        if(cnt == N) {\n          ans = S[p];\n          break;\n        }\n        p++, cnt++;\n      } else if(S[p] == ')') {\n        stk.top().first--;\n        if(stk.top().first > 0) p = stk.top().second;\n        else {\n          stk.pop();\n          p++;\n        }\n      }\n    }\n\n    // cout << endl;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  int last_par = 0;\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        assert(last_par==0); last_par = 1;\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n  if (last_par) consume(s, ')');\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint k;\nstring s, ans;\n\ntypedef string::const_iterator State;\nint number(State&);\nstring factor(State&);\nstring expression(State&);\n\nint number(State& begin){\n\tint res = 0;\n\twhile(isdigit(*begin)){\n\t\tres *= 10;\n\t\tres += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn res;\n}\n\nstring factor(State &begin){\n\tbegin++;\n\tstring ret = expression(begin);\n\tbegin++;\n\treturn ret;\n}\n\nstring expression(State& begin){\n\tstring res;\n\twhile(begin != s.end() or res.size() > k){\n\t\tif(isdigit(*begin)){\n\t\t\tint loop = number(begin);\n\n\t\t\tstring tmp;\n\t\t\tif(*begin == '('){\n\t\t\t\ttmp = factor(begin);\n\t\t\t}else{\n\t\t\t\ttmp = *begin;\n\t\t\t\tbegin++;\n\t\t\t}\n\n\t\t\trep(i,loop){\n\t\t\t\tif(res.size() > k) break;\n\t\t\t\tres += tmp;\n\t\t\t}\n\t\t}else if(isupper(*begin)){\n\t\t\tres += *begin;\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> s >> k, s != \"0\"){\n\t\tState tmp = s.begin();\n\t\tstring t = expression(tmp);\n\t\tif(t.size() - 1 < k) cout << 0 << endl;\n\t\telse cout << t[k] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\nstring s;\nint K;\n\nstring mul(string str, int n){\n    string res;\n    rep(i,n){\n        res += str;\n        if((int)res.size() > K) break;\n    }\n    return res.substr(0,K+1);\n}\n\n// T := c..c | Nc | N(T) | TT\nstring read(int &i){\n    if((int)s.size() == i || s[i] == ')') return \"\";\n\n    string str;\n    // c..c\n    if(isalpha(s[i])){\n        while(isalpha(s[i])){\n            str += s[i];\n            i++;\n        }\n    }else{\n        int num = 0;\n        while(isdigit(s[i])){\n            num = num*10+(s[i]-'0');\n            i++;\n        }\n\n        // Nc\n        if(isalpha(s[i])){\n            str = string(num,s[i]);\n            i++;\n        }\n        // N(T)\n        else{\n            i++;\n            str = mul(read(i),num);\n            i++;        \n        }\n    }\n    // TT\n    return mul(str+read(i),1);\n}\n\n\nint main(void){\n    while(cin>>s>>K, !(s==\"0\" && K==0)){\n        int i = 0;\n        string res = read(i);\n        if((int)res.size() <= K){\n            cout<<0<<endl;\n        }else{\n            cout<<res[K]<<endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nchar check_front(istringstream& is) {\n  char c; is >> c; is.unget(); return c;\n}\n\nll read_num(istringstream& is) {\n  ll x; assert(is >> x);\n  return x;\n}\n\nstring read_alphas(istringstream& is) {\n  string ret;\n  for (char c; is >> c;) {\n    if (!isalpha(c)) { is.unget(); break; }\n    ret += c;\n  }\n  return std::move(ret);\n}\n\nvoid consume(istringstream& is, char expected) {\n  char c; is >> c;\n  if (c != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \"; cout << c;\n    while(is >> c) cout << c; cout << endl;\n    assert(0);\n  }\n}\n\nvoid dfs(istringstream& is, tree_ptr curr) {\n  for (; !is.eof();) {\n    if (isdigit(check_front(is))) {\n      ll ck = read_num(is);\n      if (isalpha(check_front(is))) {\n        auto child = make_shared<tree>();\n        child->num = ck;\n        child->s = read_alphas(is);\n        curr->children.push_back(child);\n      }\n      else {\n        consume(is, '(');\n        auto child = make_shared<tree>();\n        curr->children.push_back(child);\n        child->num = ck;\n        dfs(is, child);\n        consume(is, ')');\n      }\n    }\n    else {\n      auto child = make_shared<tree>();\n      child->s = read_alphas(is);\n      child->num = 1;\n      curr->children.push_back(child);\n      if(!is.eof() && !isdigit(check_front(is))) { return; }\n    }\n  }\n}\n\nstring ans;\n\nvoid visit(tree_ptr curr) {\n  if(ans.size() >= 1000001) { return; }\n  rep(i, curr->num) {\n    if (curr->children.empty()) {\n      ans += curr->s;\n      if(ans.size() >= 1000001) { return; }\n    }\n\n    rep(i, curr->children.size()) {\n      visit(curr->children[i]);\n    }\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  istringstream is(s);\n  dfs(is, root);\n  ans.clear();\n  visit(root);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans << endl;cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\n#include<cstdlib>\n#define inf 1<<29\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\nstring s;\nchar ans;\nvector<string> v;\nmap<int,int> mp;\n\nll rec(int,int,ll);\n\nvoid rec2(int a,int b,ll sum){\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],0);\n\tif(sum<tmp*atoi(v[i].c_str()))rec2(i+2,mp[i+1],sum%tmp);\n\telse sum-=tmp*atoi(v[i].c_str());\n\tif(ans!='0')return;\n        i=mp[i+1];\n      }\n      else {\n        ll tmp=atoi(v[i].c_str());\n        if(sum<tmp){\n\t  ans=v[i+1][0];\n\t  return;\n\t}\n\telse {\n\t  sum-=tmp;\n\t  i++;\n\t}\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      if(sum<v[i].length()){\n\tans=v[i][sum];\n\treturn;\n      }\n      else sum-=v[i].length();\n    }\n    else {}\n  }\n  return;\n}\n\nll rec(int a,int b,ll c){\n  ll sum=0;\n  if(ans!='0')return inf;\n\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return inf;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],sum);\n\tif(ans!='0')return inf;\n\tsum+=atoi(v[i].c_str())*tmp;\n\ti=mp[i+1];\n      }\n      else {\n\tsum+=atoi(v[i].c_str())*v[i+1].length();\n\ti++;\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      sum+=v[i].length();\n    }\n    else {}\n  }\n  if(n<sum && c<n)rec2(a,b,n-c);\n  return sum;\n}\n\nint main()\n{\n  while(1){\n    cin>>s>>n;\n    if(s[0]=='0' && n==0)break;\n    ans='0';\n    v.clear();mp.clear();\n    string tmp1=\"\",tmp2=\"\";\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tif(tmp2!=\"\")v.push_back(tmp2);\n\ttmp2=\"\";\n\ttmp1+=s[i];\n      }\n      if('A'<=s[i] && s[i]<='Z'){\n\tif(tmp1!=\"\")v.push_back(tmp1);\n\ttmp1=\"\";\n\ttmp2+=s[i];\n      }\n      if(s[i]=='('){\n\tv.push_back(tmp1);\n\ttmp1=\"\";\n\tv.push_back(\"(\");\n      }\n      if(s[i]==')'){\n        v.push_back(tmp2);\n        tmp2=\"\";\n        v.push_back(\")\");\n      }\n      if(i==s.length()-1 && tmp2!=\"\")v.push_back(tmp2);\n    }\n    stack<int> st;\n    for(int i=0;i<v.size();i++){\n      if(v[i]==\"(\")st.push(i);\n      if(v[i]==\")\"){\n\tmp[st.top()]=i;\n\tst.pop();\n      }\n    }\n    \n    rec(0,v.size(),0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nstruct Token {\n  int ty;\n  int val;\n  string str;\n  Token() {}\n  Token(int ty, int val, string str): ty(ty) {\n    if(ty == 2) {\n      this->val = val;\n      this->str = \"\";\n    } else if(ty == 3) {\n      this->val = -1;\n      this->str = str;\n    } else {\n      this->val = -1;\n      this->str = \"\";\n    }\n  }\n};\nvoid lex(string s, vector<Token> &tokens) {\n  int nowval = 0;\n  string nowstr = \"\";\n  for(int i=0;i<(int)(s.size());++i) {\n    if(s[i] == '(') {\n      if(nowval != 0) {\n        tokens.emplace_back(Token(2, nowval, nowstr));\n        nowval = 0;\n      } else if(nowstr != \"\") {\n        tokens.emplace_back(Token(3, nowval, nowstr));\n        nowstr = \"\";\n      }\n      tokens.emplace_back(Token(0, -1, \"\"));\n    } else if(s[i] == ')') {\n      if(nowval != 0) {\n        tokens.emplace_back(Token(2, nowval, nowstr));\n        nowval = 0;\n      } else if(nowstr != \"\") {\n        tokens.emplace_back(Token(3, nowval, nowstr));\n        nowstr = \"\";\n      }\n      tokens.emplace_back(Token(1, -1, \"\"));\n    } else if('0' <= s[i] && s[i] <= '9') {\n      if(nowstr != \"\") {\n        tokens.emplace_back(Token(3, nowval, nowstr));\n        nowstr = \"\";\n      }\n      nowval *= 10;\n      nowval += s[i] - '0';\n    } else {\n      if(nowval != 0) {\n        tokens.emplace_back(Token(2, nowval, nowstr));\n        nowval = 0;\n      }\n      nowstr.push_back(s[i]);\n    }\n  }\n  if(nowval != 0) {\n    tokens.emplace_back(Token(2, nowval, nowstr));\n  } else if(nowstr != \"\") {\n    tokens.emplace_back(Token(3, nowval, nowstr));\n  }\n}\npair<int, char> solve(const vector<Token> &tokens, int now, int &cnt, int k) {\n  for(int i=now;i<(int)(tokens.size());++i) {\n    if(tokens[i].ty == 1) {\n      return {i, '*'};\n    } else if(tokens[i].ty == 2) {\n      int sz = tokens[i].val;\n      int nxt = i;\n      for(int j=0;j<sz;++j) {\n        auto res = solve(tokens, i+1, cnt, k);\n        if(res.second != '*') {\n          return {-1, res.second};\n        } else {\n          nxt = res.first;\n        }\n      }\n      i = nxt;\n    } else if(tokens[i].ty == 3) {\n      if(cnt + (int)(tokens[i].str.size()) > k) {\n        return {-1, tokens[i].str[k - cnt]};\n      } else {\n        cnt += (int)(tokens[i].str.size());\n      }\n    }\n  }\n  return {1000000, '*'};\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    string s; cin >> s;\n    int k; cin >> k;\n    if(s == \"0\" && k == 0) break;\n    vector<Token> tokens;\n    lex(s, tokens);\n    vector<Token> tokens2;\n    tokens2.emplace_back(2, 1, \"\");\n    tokens2.emplace_back(0, 0, \"\");\n    for(int i=0;i<(int)(tokens.size());++i) {\n      if(tokens[i].ty == 3 && (i == 0 || (tokens[i-1].ty != 0 && tokens[i-1].ty != 2))) {\n        tokens2.emplace_back(2, 1, \"\");\n        tokens2.emplace_back(0, 0, \"\");\n        tokens2.emplace_back(tokens[i]);\n        tokens2.emplace_back(1, 0, \"\");\n      } else if(tokens[i].ty == 3 && (i == 0 || (tokens[i-1].ty == 2))) {\n        tokens2.emplace_back(0, 0, \"\");\n        tokens2.emplace_back(tokens[i]);\n        tokens2.emplace_back(1, 0, \"\");\n      } else {\n        tokens2.emplace_back(tokens[i]);\n      }\n    }\n    tokens2.emplace_back(1, 0, \"\");\n    int cnt = 0;\n    auto res = solve(tokens2, 0, cnt, k);\n    if(res.second == '*') {\n      cout << 0 << endl;\n    } else {\n      cout << res.second << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef pair<ll,ll> pll;\n\n#define reps(i,f,n) for(int i = int(f); i <= int(n); i++)\n#define rep(i,n) reps(i,0,int(n)-1)\n#define rrep(i,n) for(int i = n-1; i >= 0; i--)\n\n#define all(x) (x).begin(),(x).end()\n#define X first\n#define Y second\n\n#define sz size()\n#define eb emplace_back\n\nvector<int> x[1024];\nstring y[1024];\nint cnt;\n\nvoid parse(string s){\n  int ind = 0;\n  int l = s.size();\n  int num = 0;\n  cnt = 0;\n  vector<int> nums;\n  rep(i,1024)x[i].clear();\n  rep(i,1024)y[i] = \"\";\n\n  while(ind<l){\n    //cout << \"num\" << num << endl;\n    if(s[ind] == '('){\n      nums.push_back(num);\n      num = 0;\n    }else if('0' <= s[ind] && s[ind] <= '9'){\n      num *= 10;\n      num += s[ind]-'0';\n    }else if(s[ind] == ')'){\n      rep(i, nums.size()) x[cnt].push_back(nums[i]);\n      if(nums.size() == 0)x[cnt].push_back(1);\n      cnt++;\n      nums.pop_back();\n    }else{\n      y[cnt] += s[ind];\n      if(num != 0){\n        rep(i, nums.size()) x[cnt].push_back(nums[i]);\n        x[cnt].push_back(num);\n        num = 0;\n        cnt++;\n      }\n    }\n    ind++;\n  }\n  if(y[cnt] != \"\"){\n    rep(i, nums.size()) x[cnt].push_back(nums[i]);\n    if(nums.size() == 0)x[cnt].push_back(1);\n    cnt++;\n  }\n}\n\nint main(void){\n  string s;\n  int p;\n  while(1){\n    cin >> s >> p;\n    if(s[0] == '0')break;\n    parse(s);\n    /*\n    rep(i,cnt){\n      cout << y[i] << endl;\n      rep(j,x[i].size()){\n        cout << x[i][j] << \",\";\n      }cout << endl;\n    }\n    /**/\n\n    rep(i,cnt){\n      int q = y[i].size();\n      rep(j, x[i].size()){\n        q *= x[i][j];\n        if(p < q){\n          cout << y[i][p%y[i].size()] << endl;\n          p -= q;\n          break;\n        }\n      }\n      p -=q;\n      if(p < 0)break;\n    }\n    if(p >= 0)cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring in;\nint n, idx;\n\nint parse(int sum){\n    // cerr << \">>>> \" << sum << \", \" << in.substr(idx) << endl;\n    char cur = in[idx];\n    if(isdigit(cur)){\n        int mul = 0;\n        while(isdigit(in[idx])){\n            mul = 10 * mul + (int)(in[idx] - '0');\n            idx++;\n        }\n        \n        if(isupper(in[idx])){\n            if(sum + mul >= n){\n                throw in[idx];\n            }\n            idx++;\n            return mul * 1;\n        }\n\n        idx++; // read '('\n        int head = idx;\n        int len = 0;\n        while(in[idx] != ')'){\n            len += parse(sum + len);\n        }\n        idx++;\n        if(sum + mul * len >= n){\n            n = (n - sum) % len;\n            if(n == 0) n = len;\n\n            idx = head;\n            len = 0;\n            while(in[idx] != ')'){\n                len += parse(sum + len);\n            }\n        }\n        return mul * len;\n    }\n    else if(isupper(cur)){\n        int len = 0;\n        while(isupper(in[idx])){\n            len++;\n            if(sum + len == n){\n                throw in[idx];\n            }\n            idx++;\n        }\n        return len;\n    }\n}\n\nsigned main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> in >> n, in != \"0\";){\n        n++;\n        in = \"1(\" + in + \")\";\n        idx = 0;\n        char res = '0';\n\n        try { parse(0); }\n        catch(char c) { res = c; }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring expr;\nint p,s,l;\nchar ans;\n\nint parseInt()\n{\n\tint ret=0;\n\twhile(p<expr.size())\n\t{\n\t\tif(!isdigit(expr[p])) break;\n\t\tret*=10;\n\t\tret+=expr[p]-'0';\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nstring parseStr()\n{\n\tstring ret;\n\twhile(p<expr.size())\n\t{\n\t\tif(!isupper(expr[p])) break;\n\t\tret+=expr[p];\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nbool parse()\n{\n\tint lp=parseInt(), tp=p;\n\tstring str;\n\tif(expr[p]=='(')\n\t{\n\t\tint ts=s;\n\t\tfor(int i=0; i<lp; i++)\n\t\t{\n\t\t\tp=tp;\n\t\t\tp++;\n\t\t\tif(parse()) return true;\n\t\t\tif(i==0 && s+(s-ts)*(lp-1) < l)\n\t\t\t{\n\t\t\t\ts+=(s-ts)*(lp-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n\telse\n\t{\n\t\tif(lp==0) lp++;\n\t\tstr=parseStr();\n\t\t\n\n\t\tif(s+str.size()*lp > l)\n\t\t{\n\t\t\tint ex=(l-s+str.size()*lp)%(str.size());\n\t\t\tans=str[ex];\n\t\t\treturn true;\n\t\t}\n\t\ts+=str.size()*lp;\n\t\t\n\t}\n\n\tif(p<expr.size() && expr[p]!=')') return parse();\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> expr >> l, (expr!=\"0\"||l))\n\t{\n\t\tp=0; s=0; ans='0';\n\t\t\n\t\tparse();\n\t\tprintf(\"%c\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nstring s;\nint p,n;\nstring bnf1();\nstring get(){\n  string res;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])||isalpha(s[p])){\n    while(isdigit(s[p])||isalpha(s[p])){\n      res+=s[p++];\n      if(res.size()>1000000)return res;\n    }\n  }\n  return res;\n}\nstring bnf2(){\n  string res=get();\n  while(s[p]=='*'){\n    if(res.size()>1000000)return res;\n    p++;\n    string res2=get();\n    int num=0;\n    r(i,res.size())num=num*10+(res[i]-'0');\n    res=res2;\n    r(i,num-1){\n      res+=res2;\n      if(res.size()>1000000)return res;\n    }\n  }\n  return res;\n}\nstring bnf1(){\n  string res=bnf2();\n  while(s[p]=='+'){\n    if(res.size()>1000000)return res;\n    p++;\n    string res2=bnf2();\n    res+=res2;\n    if(res.size()>1000000)return res;\n  }\n  return res;\n}\nint main(){\n  while(cin>>s>>n,s!=\"0\"){\n    p=0;\n    r(i,(int)s.size()-1){\n      if(isdigit(s[i])&&s[i+1]=='('||isdigit(s[i])&&isalpha(s[i+1])){\n        s=s.substr(0,i+1)+\"*\"+s.substr(i+1);\n        i--;\n      }\n      else if(s[i]==')'&&isalpha(s[i+1])||s[i]==')'&&isdigit(s[i+1])){\n        s=s.substr(0,i+1)+\"+\"+s.substr(i+1);\n        i--;\n      }\n    }\n    string ans=bnf1();\n    if(n<ans.size())cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[5000];\nint len;\n\nint length(int const k, int const l, int const r)\n{\n    int cur = 0, res = 0, p = l;\n    while (s[p] && p < r)\n    {\n        if (isalpha(s[p]))\n        {\n            while (s[p] && p < r && isalpha(s[p]))\n            {\n                //printf(\" %c\\n\", s[p]);\n                if (cur == k)\n                {\n                    throw s[p];\n                }\n                res++;\n                p++;\n                cur++;\n            }\n        }\n        else if (isdigit(s[p]))\n        {\n            int times = 0;\n            while (s[p] && p < r && isdigit(s[p]))\n            {\n                times = times * 10 + s[p] - '0';\n                p++;\n            }\n            int d = 0, i = p;\n            p++;\n            assert(s[i] == '(');\n            while (1)\n            {\n                if (s[i] == '(') d++;\n                else if (s[i] == ')') d--;\n                if (d == 0) break;\n                i++;\n            }\n            for (int j = 0; j < times; j++)\n            {\n                int d = length(k - cur, p, i);\n                res += d;\n                cur += d;\n            }\n            p = i + 1;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    static char t[5000];\n    int k;\n    while (cin >> t >> k && t[0] != '0')\n    {\n        int tlen = strlen(t);\n        len = 0;\n        for (int i = 0; i < tlen; i++)\n        {\n            if (i > 0 && isdigit(t[i - 1]) && isalpha(t[i]))\n            {\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            }\n            else\n            {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n        //cout << s << endl;\n        try\n        {\n            length(k, 0, len);\n            puts(\"0\");\n        }\n        catch (char e)\n        {\n            cout << e << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nconst int MAX=1e6+1;\n\ntypedef long long Int;\n\nInt cnt(int& p);\n\nInt get_num(int& p){\n  int res=0;\n  while(isdigit(s[p])){\n    res*=10;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nInt cnt_large(int& p){\n  Int res=0;\n  while(s[p]!=')'){\n    Int val=cnt(p);\n    res+=val;\n    if(res>MAX) return MAX;\n  }\n  return res;\n}\n\nInt cnt(int& p){\n  if(isalpha(s[p])){\n    p++;\n    return 1;\n  }\n  if(isdigit(s[p])){\n    Int num=get_num(p);\n    if(isalpha(s[p])){\n      p++;\n      return num;\n    }\n    assert(s[p]=='(');\n    p++;\n    Int val=cnt_large(p);\n    assert(s[p]==')');\n    p++;\n    if(val>MAX){\n      return MAX;\n    }\n    return num*val;\n  }\n}\nchar target(int &p,Int x){\n  while(p<s.size()){\n    int prep=p;\n    Int val=cnt(p);\n    if(val>=x){\n      p=prep;\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      Int num=get_num(p);\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      if(0)assert(s[p]=='(');\n      p++;\n      int prep2=p;\n      Int val2=cnt_large(p);\n      p=prep2;\n      return target(p,(x%val2==0) ? val2 : x%val2);\n    }\n    x-=val;\n  }\n  return '0';\n}\n\nint main(){\n  int n;\n  while(cin>>s>>n,s!=\"0\"){\n\n  int p=0;\n  cout<<target(p,n+1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    if (isdigit(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring s;\nint pos;\n\nint length(){\n\tlong long ret = 0;\n\twhile(isdigit(s[pos])){\n\t\tret *= 10;\n\t\tret += s[pos++] - '0';\n\t} \n\tif(!ret){\n\t\twhile(s[pos]!=')'&&!isdigit(s[pos])&&pos<s.length()) { ret++; pos++;}\n\t\treturn ret;\n\t}\n\tlong long tmp = 0;\n\tif(s[pos++] == '('){\n\t\twhile(s[pos] != ')') tmp += length();\n\t\tpos++;\n\t\tif(ret*tmp>1000000) return 1000001;\n\t\treturn (int)(ret*tmp);\n\t}\n\treturn ret;\n}\n\nvoid print(int p, int n){\n\tif(p==s.length()) {\n\t\tcout << 0 << endl;;\n\t\treturn;\n\t}\n\tpos = p;\n\tint L = length();\n\tif(n < L){\n\t\tif(isdigit(s[p])){\n\t\t\twhile(isdigit(s[p])){ p++; }\n\t\t\tint L2 = 0;\n\t\t\tif(s[p]=='('){\n\t\t\t\tp++;\n\t\t\t\tpos = p;\n\t\t\t\twhile(pos<s.length()&&s[pos]!=')') L2 += length();\n\t\t\t} else {\n\t\t\t\tpos = p;\n\t\t\t\tL2 = length();\n\t\t\t}\n\t\t\tprint(p, n%L2);\n\t\t} else {\n\t\t\tcout << s[p+n] << endl;\n\t\t}\n\t} else {\n\t\tprint(pos, n-L);\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> s >> n){\n\t\tif(s==\"0\"&&n==0) break;\n\t\tprint(0,n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef pair<int,string> P;\n\nstring str;\nint p;\n\nstruct Node {\n  Node(char c) : \n    leaf(true), v(c), repeat(0), car(NULL), cdr(NULL) {;}\n  Node(int r, Node* x, Node* y) : \n    leaf(false), v('a'), repeat(r), car(x), cdr(y) {;}\n  ~Node() {\n    if (car != NULL) delete car;\n    if (cdr != NULL) delete cdr;\n  }\n  bool leaf;\n  char v; // leaf\n  lli repeat;\n  Node *car, *cdr;\n};\n\nlli length(Node* n) {\n  if (n == NULL) return 0;\n  return (n->leaf ? 1 : n->repeat * length(n->car) + length(n->cdr));\n}\n\n/*\n * expr = e \n *      | num \"(\" expr \")\" expr\n *      | num char expr\n *      | char expr\n */\n\nlli number() {\n  lli res = 0;\n  while (p < (int)str.length() and isdigit(str[p])) {\n    res = res * 10 + (str[p] - '0');\n    ++p; // read [0-9]\n  }\n  return res;\n}\n\nNode* expr() {\n  if (p >= (int)str.length() || str[p] == ')') return NULL;\n  if (isalpha(str[p])) {\n    Node* car = new Node(str[p]);\n    ++p; // read [a-z]\n    Node* cdr = expr();\n    Node* pair = new Node(1, car, cdr);\n    return pair;\n  } else if (isdigit(str[p])) {\n    int num = number();\n    Node *car, *cdr;\n    if (str[p] == '(') {\n      ++p; // read (\n      car = expr();\n      ++p; // read )\n    } else {\n      car = new Node(str[p]);\n      ++p; // read [a-z]\n    }\n    cdr = expr();\n    Node* pair = new Node(num, car,cdr);\n    return pair;\n  }\n  assert(false);\n}\n\nNode* parse() {\n  p = 0;\n  Node* tree = expr();\n  return tree; \n}\n\nchar solve(Node* n, lli i) {\n  if (n == NULL) return '0';\n  if (i == 0 && n->leaf) return n->v;\n  if (i < n->repeat * length(n->car)) return solve(n->car, i % length(n->car));\n  else return solve(n->cdr, i - n->repeat * length(n->car));\n}\n\nint main() { \n  lli idx;\n  while (cin >> str >> idx and !(str == \"0\" && idx == 0)) {\n    Node* tree = parse();\n    cout << solve(tree, idx) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000100\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    while(f){\n      f=0;\n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse{\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<N;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstring st;\nint now = 0;\n\nstring getst(bool isone=false) {\n\tstring genom;\n\twhile (isalpha(st[now])) {\n\t\tgenom += st[now];\n\t\tnow++;\n\t\tif (isone)break;\n\t}\n\treturn genom;\n}\nint getcount() {\n\tlong long int num = 0;\n\twhile (isdigit(st[now])) {\n\t\tnum = num * 10 + st[now] - '0';\n\t\tnow++;\n\t}\n\treturn num;\n}\n\npair<string,char> check(long long int rest,long long int kakeru) {\n\tif (kakeru > 1e8) {\n\t\tkakeru = 1e8;\n\t}\n\tlong long int num = 1;\n\tstring nst;\n\tbool isstart = true;\n\tbool prenum = false;\n\twhile (1) {\n\t\tif (nst.size() > rest)return make_pair(\"\",nst[rest]);\n\t\tif (st.size() <= now)break;\n\t\tif (st[now] == '(') {\n\t\t\tnow++;\n\t\t\tpair<string,char>p=check(rest-nst.size(),num);\n\t\t\tif (p.second == '0') {\n\t\t\t\tnst += p.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn make_pair(\"\",p.second);\n\t\t\t}\n\t\t\tprenum = false;\n\t\t\tnum = 1;\n\t\t}\n\t\telse if (st[now] == ')') {\n\t\t\tnow++;\n\t\t\tbreak;\n\t\t}\n\t\telse if(isalpha(st[now])){\n\t\t\tstring genom;\n\t\t\tif (!prenum) {\n\t\t\t\tgenom = getst();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgenom = getst(true);\n\t\t\t}\n\t\t\tif (genom.size()*num > rest) {\n\t\t\t\treturn make_pair(\"\", genom[rest%genom.size()]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//rest -= genom.size()*kakeru*num;\n\t\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\t\tnst += genom;\n\t\t\t\t\tif (nst.size() > 1e6)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = 1;\n\t\t\tprenum = false;\n\t\t}\n\t\telse {\n\t\t\tassert(isdigit(st[now]));\n\t\t\tnum = getcount();\n\t\t\tprenum = true;\n\t\t}\n\n\t\tisstart = false;\n\t}\n\tstring finst;\n\tfor (int i = 0; i < kakeru; ++i) {\n\t\tfinst += nst;\n\t\tif (finst.size() > 1e6)break;\n\t}\n\tif (finst.size() > rest)return make_pair(\"\",finst[rest]);\n\treturn make_pair(finst, '0');\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"0\")break;\n\t\tnow = 0;\n\t\tint n; cin >> n;\n\t\tpair<int, char>p;\n\t\tchar ans=check(n,1).second;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nbool isnum(char t) {\n\tif ('0' <= t && t <= '9')return true;\n\telse return false;\n}\nbool isalf(char t) {\n\tif ('A' <= t && t <= 'Z')return true;\n\telse return false;\n}\n\nstring s; int c;\n\nvoid solve() {\n\tc++;\n\tstack<int> num;\n\n\tstack<string> st;\n\n\tint n = s.length();\n\tstring cur;\n\trep(i, n) {\n\t\t//cout << i << \" \";\n\t\t//cout << cur << endl;\n\t\tif (isnum(s[i])) {\n\t\t\tint le = i;\n\t\t\twhile (isnum(s[i + 1]))i++;\n\t\t\tint len = i - le + 1;\n\t\t\tint z = stoi(s.substr(le, len));\n\t\t\ti++;\n\t\t\tif (isalf(s[i])) {\n\t\t\t\t//add\n\t\t\t\trep(j, z)cur.push_back(s[i]);\n\t\t\t\tif (cur.size() >= c) {\n\t\t\t\t\tcout << cur[c - 1] << endl; return;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnum.push(z); st.push(cur);\n\t\t\t\tc -= cur.size();\n\t\t\t\tcur.clear();\n\t\t\t}\n\t\t}\n\t\telse if (isalf(s[i])) {\n\t\t\tcur.push_back(s[i]);\n\t\t\tif (cur.size() >= c) {\n\t\t\t\tcout << cur[c - 1] << endl; return;\n\t\t\t}\n\t\t}\n\t\telse if(s[i]==')'){\n\t\t\tif (st.empty()) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\tint u = num.top(); num.pop();\n\t\t\tstring ori = cur;\n\t\t\trep(j, u - 1) {\n\t\t\t\tcur += ori;\n\t\t\t\tif (cur.size() >= c) {\n\t\t\t\t\tcout << cur[c - 1] << endl; return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring past = st.top(); st.pop();\n\t\t\tc += past.size();\n\t\t\tcur = past + cur;\n\t\t}\n\t}\n\tcout << 0 << endl; return;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >> s >> c) {\n\t\tif (s == \"0\")break;\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstring parse(string V, int w) {\n\twhile (V.size() >= 2 && V[0] == '(' && V[V.size() - 1] == ')')V = V.substr(1, V.size() - 2);\n\tif (V.size() == 1)return V;\n\tint depth = 0;\n\tstring E = \"\", F = \"\"; vector<pair<int, string>>v;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '(')depth++;\n\t\tif (V[i] == ')')depth--; F += V[i];\n\t\tif (depth == 0 && ((V[i] >= 'A' && V[i] <= 'Z') || V[i] == ')')) {\n\t\t\tstring Y = \"\"; int c = 0; while (F[c] >= '0' && F[c] <= '9') { Y += F[c]; c++; }\n\t\t\tint D = 1; if (Y.size() >= 1)D = stoi(Y);\n\t\t\tv.push_back(make_pair(D, F.substr(c, F.size() - c))); F = \"\";\n\t\t}\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (E.size() >= w)break;\n\t\tfor (int j = 0; j < v[i].first; j++) {\n\t\t\tif (E.size() >= w)break;\n\t\t\tE += parse(v[i].second, w - E.size());\n\t\t}\n\t}\n\treturn E.substr(0, min((int)E.size(), w));\n}\nint main() {\n\twhile (true) {\n\t\tstring S; int T; cin >> S >> T; if (S == \"0\" && T == 0)break;\n\t\tstring U = parse(S, T + 1);\n\t\tif (U.size() <= T) { cout << \"0\" << endl; }\n\t\telse cout << U[T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[s1.pos] == '(') pos++;\n      State s2 = expr(str,pos);\n      \n      string tmp = \"\";\n      for(int i = 0; i < s1.int_result; i++){\n        tmp += s2.str_result;\n        if(tmp.size() > 1000000) break;\n      }\n      result += tmp;\n      pos = s2.pos + 1;\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    if(genome == \"0\" && pos == 0) break;\n    string result = expr(genome,0).str_result;\n    if(pos < result.size()){\n      cout << result[pos] << endl;      \n    }\n    else{\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 1000000000\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tdouble capacity;\n\tPath(int from = 0, int to = 0, double cost = 0, double capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nstring substrByParenthesis(string str, int open)\n{\n\tint st = 0;\n\tif (str[open] != '(') throw 1;\n\tFOR(i, open, str.size())\n\t{\n\t\tif (str[i] == ')' && --st == 0) { return str.substr(open + 1, i - open - 1); }\n\t\telse if (str[i] == '(') { st++; }\n\t}\n\tthrow 0;\n}\n\npair<int, char> decompressAndFind(const string &str, int r)\n{\n\tint p = 0;\n\tint produced = 0;\n\twhile (p < str.size())\n\t{\n\t\tint x = atoi(str.c_str() + p);\n\t\tif (x == 0) x = 1;\n\t\twhile (isdigit((unsigned int)str[p])) p++;\n\n\t\tif (str[p] == '(')\n\t\t{\n\t\t\tstring subs = substrByParenthesis(str, p);\n\t\t\tp += subs.size() + 2;\n\n\t\t\tpair<int, char> ret = decompressAndFind(subs, r);\n\t\t\tif (ret.second) { return ret; }\n\t\t\tif (ret.first * x > r) { return decompressAndFind(subs, r % ret.first); }\n\t\t\telse { r -= ret.first * x; produced += ret.first * x; }\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (r == 0) { return make_pair(0, str[p]); }\n\t\t\tr--;\n\t\t\tp++;\n\t\t\tproduced++;\n\t\t}\n\t}\n\treturn make_pair(produced, 0);\n}\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tstring input = read<string>();\n\t\tinput = regex_replace(input, regex(\"(\\\\d+)([A-Z])\"), string(\"$1($2)\"));\n\t\tint r = read<int>();\n\t\tif (input == \"0\") { break; }\n\t\tchar c = decompressAndFind(input, r).second;\n\t\tif (!c)  c = '0';\n\t\twrite(c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n#include <vector>\n#include <map>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n\nstring Str;\nint Index;\n\nclass Node {\npublic:\n  int num;\n  string s;\n  vector<Node> v;\n  Node() { num = -1; }\n};\n\nNode root;\n\nint getNum(int &pos, string s) {\n  int st = pos;\n  int length = 0;\n  while(isdigit(s[pos])) { ++length; ++pos; }\n  //cout << s << \" => \" << s.substr(st, length) << endl;\n  return atoi(s.substr(st, length).c_str());\n}\n\nchar rec(int &i, int j, Node node) {\n  //cout << node.s << \" :: \" << node.num << endl;\n  if(node.s.size()) {\n    for(int l = 0; l < node.num; ++l) {\n      for(int k = 0; k < node.s.size(); ++k) {\n\t//cout << node.s[k];\n\tif(i == j) return node.s[k];\n\t++i;\n      }\n    }\n    return '0';\n  }\n\n  for(int k = 0; k < node.num; ++k) {\n    for(int l = 0; l < node.v.size(); ++l) {\n      char c = rec(i, j, node.v[l]);\n      if(c != '0') return c;\n    }\n  }\n  return '0';\n}\n\nvector<string> sep(string s)\n{\n  string t = \"\";\n  vector<string> v, u;\n  t += s[0];\n\n  for(int i=1; i<s.size(); ++i){\n    if(s[i-1] == ')') {\n      v.push_back(t);\n      t = \"\";\n    }\n    /*\n    if( s[i-1] == ')' && isalpha(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( s[i-1] == ')' && isdigit(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( isdigit(s[i]) && isalpha(s[i-1])){\n      v.push_back(t);\n      t = \"\";\n      }*/\n    t += s[i];\n  }\n  if(t.size()) {\n    v.push_back(t);\n  }\n\n  int o, c;\n  o = c = 0;\n  t = \"\";\n  for(int i = 0; i < v.size(); ++i) {\n    if(o + c && o == c) {\n      u.push_back(t);\n      o = c = 0;\n      t = \"\";\n    }\n    t += v[i];\n    o += count(v[i].begin(), v[i].end(), '(');\n    c += count(v[i].begin(), v[i].end(), ')');\n  }\n  if(t.size()) u.push_back(t);\n  return u;\n  for(int i=0; i<u.size(); ++i){\n    cout << u[i] << \"_\";\n  }\n  cout << endl;\n  return u;\n}\n\nvoid conv(string &s) {\n  for(int i = 1; i < s.length(); ++i) {\n    if(s[i-1] == ')' && isalpha(s[i])) {\n      s.insert(i, \"1(\");\n      int p = i+2;\n      while(isalpha(s[p])) {\n\t++p;\n      }\n      s.insert(p, \")\");\n    }\n\n  }\n  for(int i = 1; i < s.length(); ++i) {\n    if(isdigit(s[i-1]) && isalpha(s[i]) && !isalpha(s[i+1])) {\n      s.insert(i, \"(\");\n      s.insert(i+2, \")\");\n    }\n  }\n  //cout << s << endl;\n}\n\nNode build(string s) {\n  //cout << s << endl;\n  Node node;\n  int num;\n  if(isalpha(s[0])) {\n    node.num = 1;\n    node.s = s;\n    return node;\n  } else {\n    int pos = 0;\n    num = getNum(pos, s);\n    /*\n    if(s[pos] != '(') {\n      node.num = num;\n      node.s = \"\";//(pos < s.size()) ? \"####\" : \"@@@\";\n      node.s += s[pos];\n      return node;\n      }*/\n    ++pos;\n    s.erase(s.begin(), s.begin()+pos);\n    s.erase(s.begin() + s.size() - 1);\n\n    /*if(count(s.begin(), s.end(), '(') == 0) {\n      node.num = num;\n      node.s = s;\n      return node;\n      }*/\n    int o, c;\n    string t = \"\";\n    o = c = 0;\n    vector<string> v = sep(s);\n    for(int i=0; i<v.size(); ++i){\n      node.v.push_back( build(v[i]) );\n    }\n  }  \n  node.num = num;\n  return node;\n  cout << node.s << endl;\n  for(int i = 0; i < node.v.size(); ++i) {\n    cout << node.v[i].s << \" \";\n  }\n  cout << endl << endl;\n  return node;\n}\n\nvoid solve() {\n  Str.insert(0, \"1(\");\n  Str.insert(Str.size(), \")\");\n  conv(Str);\n  //cout << Str << endl;\n  root = build(Str);\n  int i = 0;\n  char c  = rec(i, Index, root);\n  cout << c << endl;\n}\n\nmain() {\n  while(cin >> Str >> Index) {\n    if(Str == \"0\" && Index == 0) break;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < a; i++)\n\nusing namespace std;\n\nstruct expr;\n\nstruct term\n{\n  bool flg;\n  string str;\n  int n;\n  expr *inner;\n\n  term(bool flg, string str, int n, expr *inner);\n  int length();\n  char charAt(int pos);\n};\n\nostream& operator <<(ostream& out, expr e);\n\nostream& operator <<(ostream& out, term t)\n{\n  if (t.flg)\n    out << *t.inner << ' ' << t.n << \" times\" << endl;\n  else\n    out << t.str << endl;\n  return out;\n}\n\nstruct expr\n{\n  vector<term> inner;\n\n  expr(vector<term> inner) : inner(inner) {}\n\n  int length() {\n    int ret = 0;\n    for (int i = 0; i < inner.size(); ++i)\n      ret += inner[i].length();\n    return ret;\n  }\n\n  char charAt(int pos) {\n    int cur = 0;\n    for (int i = 0; i < inner.size(); ++i) {\n      int next = cur + inner[i].length();\n      if (pos < next)\n\treturn inner[i].charAt(pos - cur);\n      cur = next;\n    }\n    return '0';\n  }\n};\n\nostream& operator <<(ostream& out, expr e)\n{\n  out << \"expr {\";\n  for (int i = 0; i < e.inner.size(); ++i)\n    out << e.inner[i] << endl;\n  return out << '}';\n}\n\nterm::term(bool flg, string str, int n, expr *inner)\n  : flg(flg), str(str), n(n), inner(inner) {}\n\nint term::length() {\n  return flg ? min((long long) n * inner->length(), 100000000LL) : str.length();\n}\n\nchar term::charAt(int pos) {\n  return flg ? inner->charAt(pos % inner->length()) : str[pos];\n}\n\nint parsenum(string s, int pos, int& next)\n{\n  int ret = 0;\n  while ('0' <= s[pos] && s[pos] <= '9') {\n    ret *= 10;\n    ret += s[pos] & 15;\n    ++pos;\n  }\n  next = pos;\n  return ret;\n}\n\nexpr *parseexpr(string s, int pos, int& next);\n\nterm parseterm(string s, int pos, int& next)\n{\n  if ('0' <= s[pos] && s[pos] <= '9') {\n    int n = parsenum(s, pos, next);\n    if (s[next] == '(') {\n      expr *inner = parseexpr(s, next + 1, next);\n      ++next;\n      return term(true, \"\", n, inner);\n    } else {\n      string str;\n      str.push_back(s[next]);\n      vector<term> inner;\n      inner.push_back(term(false, str, 0, NULL));\n      ++next;\n      return term(true, \"\", n, new expr(inner));\n    }\n  } else {\n    string ret;\n    while ('A' <= s[pos] && s[pos] <= 'Z') {\n      ret.push_back(s[pos]);\n      ++pos;\n    }\n    next = pos;\n    return term(false, ret, 0, NULL);\n  }\n}\n\nexpr *parseexpr(string s, int pos, int& next)\n{\n  vector<term> ret;\n  while (pos < s.length() && s[pos] != ')') {\n    term inner = parseterm(s, pos, next);\n    ret.push_back(inner);\n    pos = next;\n  }\n  return new expr(ret);\n}\n\nvoid solve(string s, int i)\n{\n  int dummy;\n  expr *e = parseexpr(s, 0, dummy);\n  cout << e->charAt(i) << endl;\n}\n\nint main()\n{\n  string s;\n  int i;\n  while (cin >> s >> i && s[0] != '0')\n    solve(s, i);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n\nstring genome() {\n\tstring res = \"\";\n\tif(s[roc] == '(') {\n\t\t++roc;\n\t\twhile(s[roc] != ')' && !found) {\n\t\t\tif(s[roc] >= 'A' && s[roc] <= 'Z') {\n\t\t\t\tres += s[roc];\n\t\t\t\t++t;\n\t\t\t\tif(t == i && ans == '#') {\n\t\t\t\t\tans = s[roc];\n\t\t\t\t\tfound = true;\n\t\t\t\t\t++roc;\n\t\t\t\t\tt = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++roc;\n\t\t\t} else {\n\t\t\t\tll roc_buf = roc;\n\t\t\t\twhile(s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\t\t\tint roop = stoi(s.substr(roc_buf, roc - roc_buf));\n\t\t\t\tstring rooped = genome();\n\t\t\t\tif(!found) {\n\t\t\t\t\tREP(j, roop - 1) {\n\t\t\t\t\t\tif(t + rooped.size() < i) {\n\t\t\t\t\t\t\tt += rooped.size();\n\t\t\t\t\t\t\tres += rooped;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(ans == '#') {\n\t\t\t\t\t\t\t\tans = rooped[(i - t) - 1];\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tt = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t} else {\n\t\tres += s[roc];\n\t\t++t;\n\t\tif(t == i) {\n\t\t\tans = s[roc];\n\t\t\tfound = true;\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s>>i;\n\t\tif(s == \"0\" && i == 0) break;\n\t\troc = 0;\n\t\tt = -1;\n\t\tfound = false;\n\t\tans = '#';\n\t\ts = \"(\" + s;\n\t\ts += \")\";\n\t\tgenome();\n\t\tif(ans == '#') cout<<0<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring in;\nint n, idx;\n\nint parse(int sum){\n    // cerr << \">>>> \" << sum << \", \" << in.substr(idx) << endl;\n    char cur = in[idx];\n    if(isdigit(cur)){\n        int mul = 0;\n        while(isdigit(in[idx])){\n            mul = 10 * mul + (int)(in[idx] - '0');\n            idx++;\n        }\n        \n        if(isupper(in[idx])){\n            if(sum + mul >= n){\n                throw in[idx];\n            }\n            idx++;\n            return mul * 1;\n        }\n\n        idx++; // read '('\n        int head = idx;\n        int len = 0;\n        while(in[idx] != ')'){\n            len += parse(sum + len);\n        }\n        idx++; // read ')'\n\n        if(sum + mul * len >= n){\n            n = (n - sum) % len;\n            if(n == 0) n = len;\n\n            idx = head;\n            len = 0;\n            while(in[idx] != ')'){\n                len += parse(len);\n            }\n        }\n        return mul * len;\n    }\n    else if(isupper(cur)){\n        int len = 0;\n        while(isupper(in[idx])){\n            len++;\n            if(sum + len == n){\n                throw in[idx];\n            }\n            idx++;\n        }\n        return len;\n    }\n}\n\nsigned main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> in >> n, in != \"0\";){\n        n++;\n        in = \"1(\" + in + \")\";\n        idx = 0;\n        char res = '0';\n\n        try { parse(0); }\n        catch(char c) { res = c; }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m;\nchar ans;\nbool flag = false;\nstring dfs(string s) {\n\t//cout << s << endl;\n\tif(flag) return \"\";\n\tif('A' <= s[0] && s[0] <= 'Z') {\n\t\treturn s;\n\t}\n\t//10C??????????????????????¢????\n\tbool h = false;\n\tstring tt = \"\";\n\tint idx = 0;\n\tREP(i, s.size()) {\n\t\tif(i >= 5) break;\n\t\tif(s[i] == '(') h = true;\n\t\tif(isdigit(s[i])) tt += s[i], idx = i;\n\t}\n\tstring ret = \"\";\n\tif(!h) {\n\t\tstring tmp = dfs(s.substr(idx+1));\n\t\tint itt = stoi(tt);\n\t\tREP(i, itt) {\n\t\t\tret += tmp;\n\t\t\tif((int)ret.size() > m) {\n\t\t\t\tans = ret[m];\n\t\t\t\tflag = true;\n\t\t\t\t//cout << ans << endl;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tstring num = \"\", para = \"\";\n\tint now = 0;\n\tbool f = true, g = false;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '(') {\n\t\t\tg = true;\n\t\t\tnow++;\n\t\t} else if(s[i] == ')') {\n\t\t\tnow--;\n\t\t} else if(isdigit(s[i])){\n\t\t\tf = false;\n\t\t} else {\n\t\t\tf = true;\n\t\t}\n\t\tif(g) para += s[i];\n\t\telse num += s[i];\n\t\tif(now == 0 && f) {\n\t\t\t//tmp???dfs?????????????????°?????????????????????ret????????????\n\t\t\tint ttmp = stoi(num);\n\t\t\tstring dret = dfs(para.substr(1, para.size()-2));\n\t\t\tREP(j, ttmp) {\n\t\t\t\tret += dret;\n\t\t\t\tif((int)ret.size() > m) {\n\t\t\t\t\tans = ret[m];\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tnum = \"\", para = \"\";\n\t\t\tf = true, g = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\n\t\tflag = false;\n\n\t\tbool f = true;\n\t\tint now = 0;\n\t\tstring tmp = \"\";\n\t\tREP(i, s.size()) {\n\t\t\t//cout << \"i:\" << i << \" \" << s[i] << endl;\n\t\t\tif(s[i] == '(') now++;\n\t\t\telse if(s[i] == ')') now--;\n\t\t\telse if(isdigit(s[i])) f = false;\n\t\t\telse f = true;\n\t\t\ttmp += s[i];\n\t\t\t//cout << tmp << \" \" << m << endl;\n\t\t\tif(now == 0 && f) {\n\t\t\t\tstring t = dfs(tmp);\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif(flag) {cout << ans << endl; goto e;}\n\t\t\t\telse if((int)t.size() <= m) {\n\t\t\t\t\tm -= t.size();\n\t\t\t\t}\telse {cout << t[m] << endl; goto e;}\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t\te:\n\t\tint a;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000100\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nstring str_pow(string str,int y){\n  string res=\"\";\n  while(y){\n    if(y%2) res+=str;\n    str+=str;\n    y/=2;\n    if(res.size()>=N) break;\n      }\n  return res;\n}\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    while(f){\n      f=0;\n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse{\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t      pls+=s[c][idx];\n\t    }\n\t    i=idx;\n\t  }\n\t  //string res=str_pow(pls,dig);\n\t  //s[!c]+=res.substr(0,N-s[!c].size()-1);\n\t   for(int j=0;j<dig&&s[!c].size()+pls.size()<N;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s,an;\nint n;\nvoid dfs(int x){\n  int c=0,t=0;\n  string str;\n  while('0'<=s[x]&&s[x]<='9')t*=10,t+=s[x++]-'0';\n  while(t--&&an.size()<=n)dfs(x+1);\n  while('A'<=s[x]&&s[x]<='Z')an+=s[x++];\n}\n\nint main(){\n  while(cin>>s>>n&&s[0]!='0'){\n    an.clear();\n    for(int i=0;i<s.size();i++)\n      if('0'<=s[i]&&s[i]<='9'&&'A'<=s[i+1]&&s[i+1]<='Z')\n\ts=s.substr(0,i+1)+'('+s[i+1]+')'+s.substr(i+2,s.size());\n    dfs(0);\n     if(an.size()>n)\n      cout<<an[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n\nstring genome() {\n\tstring res = \"\";\n\tif(s[roc] == '(') {\n\t\t++roc;\n\t\twhile(s[roc] != ')' && !found) {\n\t\t\tif(s[roc] >= 'A' && s[roc] <= 'Z') {\n\t\t\t\tres += s[roc];\n\t\t\t\t++t;\n\t\t\t\tif(t == i) {\n\t\t\t\t\tans = s[roc];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++roc;\n\t\t\t} else {\n\t\t\t\tll roc_buf = roc;\n\t\t\t\twhile(s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\t\t\tint roop = stoi(s.substr(roc_buf, roc - roc_buf));\n\t\t\t\tstring rooped = genome();\n\t\t\t\tif(!found) {\n\t\t\t\t\tREP(j, roop - 1) {\n\t\t\t\t\t\tif(t + rooped.size() < i) {\n\t\t\t\t\t\t\tt += rooped.size();\n\t\t\t\t\t\t\tres += rooped;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tans = rooped[(i - t) - 1];\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t} else {\n\t\tres += s[roc];\n\t\t++t;\n\t\tif(t == i) {\n\t\t\tans = s[roc];\n\t\t\tfound = true;\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s>>i;\n\t\tif(s == \"0\" && i == 0) break;\n\t\troc = 0;\n\t\tt = -1;\n\t\tfound = false;\n\t\tans = '#';\n\t\ts = \"(\" + s;\n\t\ts += \")\";\n\t\tgenome();\n\t\tif(ans == '#') cout<<0<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstruct Node{\npublic:\n  long long int size, left_repeat;\n  string str;\n  Node* left;\n  Node* right;\n};\n\nclass GenomeTree{\npublic:\n  GenomeTree(string s){\n    root = (Node *)malloc(sizeof(Node));\n    func(s.begin(), s.end(), root);\n  }\n  char search(long long int n){\n    if(n >= root->size){ return '0'; }\n    return sea(n, root);\n  }\n  void destruction(){ dest(root); }\n\nprivate:\n  Node* root;\n  int c2i(char c){\n    int ans = c - '0';\n    if(0 <= ans && ans <= 9){ return ans; }\n    return -1;\n  }\n\n  void dest(Node* now){\n    if(now == NULL){ return; }\n    dest(now->left);\n    dest(now->right);\n    free(now);\n    return;\n  }\n\n  char sea(long long int n, Node *now){\n    if(now->str != \"\"){ return now->str[n]; }\n    if(n <= now->left->size * now->left_repeat)\n      return sea(n % now->left->size, now->left);\n    else\n      return sea(n - (now->left->size * now->left_repeat), now->right);\n  }\n\n  void NodeInit(Node *now){\n    now->size = now->left_repeat = 0;\n    now->left = now->right = NULL;\n    now->str = \"\";\n  }\n  \n  void func(string::iterator a, string::iterator b, Node* now){\n    NodeInit(now);\n    \n    if(a >= b){\n      now->size = 0;\n      return;\n    }\n    \n    if(*a == '('){ ++a; }\n    if(c2i(*a) < 0){\n      string::iterator size;\n      for(string::iterator it = a; it != b; it++){ now->str += *it; }\n      now->size = b - a;\n      return;\n    }\n    \n    while(c2i(*a) >= 0){\n      now->left_repeat *= 10;\n      now->left_repeat += c2i(*a);\n      ++a;\n    }\n    \n    if(*a != '('){\n      now->size = now->left_repeat;\n      now->left = (Node *)malloc(sizeof(Node));\n      NodeInit(now->left);\n      now->left->size = 1;\n      now->left->str += *a;\n    }\n    else{\n      int cout = 0;\n      string::iterator next_b;\n      for(string::iterator it = a; ; it++){\n        if(*it == '('){ ++cout; }\n        if(*it == ')'){ --cout; }\n        if(cout == 0){\n          next_b = it;\n          break;\n        }\n      }\n\n      now->left = (Node *)malloc(sizeof(Node));\n      now->right = (Node *)malloc(sizeof(Node));\n      func(a, next_b, now->left);\n      func(next_b + 1, b, now->right);\n      now->size = now->left->size * now->left_repeat + now->right->size;\n    }\n    return;\n  }\n};\n\n\nint main(void){\n  while(true){\n    string s;\n    int n;\n    cin >> s >> n;\n    if(s == \"0\" && n == 0){ break; }\n    \n    GenomeTree g(s);\n    cout << g.search(n) << endl;\n    g.destruction();\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint cket(std::string &str, int i)\n{\n\tint n = 1;\n\n\tfor ( ; i < str.size(); ++i ) {\n\t\tif ( str[i] == '(' ) n++;\n\t\tif ( str[i] == ')' ) n--;\n\n\t\tif ( n == 0 ) break;\n\t}\n\treturn i;\n}\n\nint n;\nchar expand(std::string str)\n{\n\tfor ( int i = 0; i < str.size(); ++i ) {\n\t\tif ( isdigit( str[i] ) ) {\n\t\t\tint j = 1;\n\t\t\twhile ( isdigit(str[i + j] ) ) j++;\n\t\t\tint num = std::atoi(str.substr(i, j).c_str());\n\t\t\t\n\t\t\tint s, e;\n\t\t\tif ( str[i + j] == '(' ) {\n\t\t\t\tint k;\n\t\t\t\tk = cket(str, i + j + 1);\n\t\t\t\ts = i + j + 1;\n\t\t\t\te = k - (i+j+1);\n\t\t\t\ti = k;\n\t\t\t} else {\n\t\t\t\ts = i + j;\n\t\t\t\te = 1;\n\t\t\t\ti = i + j;\n\t\t\t}\n\t\t\tfor ( int l = 0; l < num; ++l ){\n\t\t\t\tchar a = expand(str.substr(s, e));\n\t\t\t\tif ( a != '0' ) return a;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( n == 0 ) {\n\t\t\t\treturn str[i];\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\treturn '0';\n}\n\nint main(void)\n{\n\twhile ( true ) {\n\t\tstd::string str;\n\n\t\tstd::cin >> str >> n;\n\t\tif ( str == \"0\" && n == 0 ) break;\n\n\t\tstd::cout << expand(str) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\nstring s;\nint n;\nvoid calc(string &p,int k){\n    //cout << p << \" \" << k << endl;\n    if(k>=s.size())return;\n    if(p.size()>n)return;\n    if(s[k]==')')return;\n    if(s[k]<='Z'&&s[k]>='A'){\n        p.push_back(s[k]);\n        calc(p,k+1);\n        return;\n    }\n    string x;\n    int z = k;\n    bool flag = 0;\n    for(int i=k;;i++){\n        if(s[i]=='('){\n            z = i;\n            flag = 1;\n            break;\n        }\n        if(s[i]<='Z'&&s[i]>='A'){\n            z = i-1;\n            break;\n        }\n        x.push_back(s[i]);\n    }\n    int d=0;\n        if(s[z]=='(')d++;\n        int r;\n        for(int i=z+1;;i++){\n            if(s[i]=='('){\n                d++;\n            }\n            if(s[i]==')'){\n                d--;\n            }\n            if(d==0){\n                r = i;  \n                break;\n            }\n        }\n    if(flag){\n        int y = stoi(x);\n        for(int j=0;j<y;j++){\n            if(p.size()>n)return;\n            calc(p,z+1);\n        }\n        if(p.size()>n)return;\n        if(p.size()<n){\n            calc(p,r+1);\n        }\n    }else{\n        int y = stoi(x);\n        for(int i=0;i<y;i++){\n            p.push_back(s[r]);\n        }\n        if(p.size()<n){\n            calc(p,r+1);\n        }\n    }\n   \n    return;\n}\n\n\nint main(){   \n    while(cin >> s >> n&&s!=\"0\"){\n        string p;\n        calc(p,0);\n        if(p.size()<=n){\n            cout << 0 << endl;\n        }else{\n            cout << p[n] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int t;\nconst long long int MAX_T=1e8;\nlong long int read(int& i,string& s);\nlong long int counta(int &i,string &s);\nchar solve(int &i,string &s){\n  int prei=i;\n  long long int ret;\n  while(ret=read(i,s)){\n    prei=i;\n    if(ret==-1){\n      t--;\n      if(t==0) return s[i-1];\n    }\n    else{\n      long long int val=counta(i,s);\n      if(val*ret>=t){\n\tt%=val;\n\tif(t==0) t=val;\n\ti=prei;\n\treturn solve(i,s);\n      }\n      else{\n\tt-=val*ret;\n      }\n    }\n  }\n  return '0';\n  \n}\n\nlong long int counta(int &i,string &s){\n  long long int ret;\n  long long int res=0;\n  while(ret=read(i,s)){\n    if(ret==-1){\n      res++;\n    }\n    else{\n      res+=counta(i,s)*ret;\n      res=min(res,MAX_T);\n    }\n  }\n  return min(MAX_T,res);\n}\n\nlong long int read(int& i,string& s){\n  if(i>=s.size() || s[i]==')'){\n    i++;\n    return 0;\n  }\n  if(isalpha(s[i])){\n    i++;\n    return -1;\n  }\n  if(!isdigit(s[i])){\n    for(;;);\n  }\n  long long int prei=i;\n  for(;i<s.size() && isdigit(s[i]);i++);\n  long long int res=(i-prei>8 ? MAX_T :stoi(s.substr(prei,i-prei)));\n  if(s[i]=='(') i++;\n  return res;\n}\n\n\nint main(){\n  string s;\n  while(cin>>s>>t,s!=\"0\"){\n    int i=0;\n    t++;\n    string s2=\"\";\n    s2+=s[0];\n    for(int i=1;i<s.size();i++){\n      if(isdigit(s[i-1]) && s[i]!='('){\n\ts2+='(';\n\ts2+=s[i];\n\ts2+=')';\n      }\n      else{\n\ts2+=s[i];\n      }\n\n    }\n    s=s2;\n\n    cout<<solve(i,s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nstruct Term\n{\n    using Ptr = shared_ptr<Term>;\n    Term(const int rep, const vector<Ptr>& child, const int unit, const string& s) : rep{rep}, child{child}, unit{unit}, s{s} {}\n    int rep;\n    vector<Ptr> child;\n    int unit;\n    string s;\n};\nusing Ptr = Term::Ptr;\nstring S;\nstring::iterator c;\nPtr parse()\n{\n    if (not isdigit(*c)) {\n        string s;\n        for (; 'A' <= *c and *c <= 'Z'; c++) { s.push_back(*c); }\n        return make_shared<Term>(1, vector<Ptr>{}, (int)s.size(), s);\n    }\n    string d;\n    for (; isdigit(*c); c++) { d.push_back(*c); }\n    const int D = d == \"\" ? 1 : stoi(d);\n    Ptr ans = make_shared<Term>(D, vector<Ptr>{}, 0, \"\");\n    bool hasb = false;\n    if (*c == '(') { hasb = true, c++; }\n    for (; *c != ')';) {\n        const auto p = parse();\n        ans->child.push_back(p);\n        ans->unit = min(ans->unit + (p->unit) * (p->rep), 1000001);\n    }\n    if (hasb) { c++; }\n    return ans;\n}\nstring toString(const Ptr p)\n{\n    if (p->child.empty()) { return p->s; }\n    string s = to_string(p->rep) + \"(\";\n    for (const auto& c : p->child) { s += toString(c); }\n    s += \")\";\n    return s;\n}\nint main()\n{\n    while (true) {\n        int N;\n        cin >> S >> N;\n        if (S == \"0\" and N == 0) { break; }\n        S = \"1(\" + S + \")\";\n        c = S.begin();\n        const Ptr root = parse();\n        if (N >= root->unit * root->rep) {\n            cout << 0 << endl;\n            continue;\n        }\n        Ptr p = root;\n        while (true) {\n            if (p->child.empty()) {\n                cout << p->s[N] << endl;\n                break;\n            } else {\n                for (const auto& c : p->child) {\n                    if (N >= c->rep * c->unit) {\n                        N -= c->rep * c->unit;\n                    } else {\n                        N %= c->unit;\n                        p = c;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nstruct node {\n\tint repeat;\n\tlong long len;\n\tvector<node> children;\n\tchar c;\n\n\tnode(int r):len(0ll), repeat(r){}\n\tnode(int r, char c):len(1ll), repeat(r), c(c){}\n\n\tlong long size() const {\n\t\treturn len * repeat;\n\t}\n\n\tvoid add(const node& n) {\n\t\tchildren.push_back(n);\n\t\tlen += n.size();\n\t}\n\n\tchar get(int idx) const {\n\t\tconst long long sum = len * repeat;\n\t\tif(idx < sum) {\n\t\t\tif(children.size()) {\n\t\t\t\tidx %= len;\n\t\t\t\tfor(int i = 0; i < (int)children.size(); ++i) {\n\t\t\t\t\tconst long long tmp = children[i].size();\n\t\t\t\t\tif(idx < tmp)\n\t\t\t\t\t\treturn children[i].get(idx);\n\n\t\t\t\t\tidx -= tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\n\t\treturn '0';\t\t\n\t}\n};\n\nint idx;\nstring s;\n\nint number() {\n\tint res = 0;\n\twhile(isdigit(s[idx])) {\n\t\tres *= 10;\n\t\tres += s[idx++] - '0';\n\t}\n\n\treturn res;\n}\n\nnode parse(int repeat) {\n\tnode res(repeat);\n\twhile(idx < (int)s.size() && s[idx] != ')') {\n\t\tif(isdigit(s[idx])) {\n\t\t\tconst int r = number();\n\t\t\tif(s[idx] == '(') {\n\t\t\t\t++idx;\n\t\t\t\tres.add(parse(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.add(node(r, s[idx]));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tres.add(node(1, s[idx]));\n\t\t}\n\n\t\t++idx;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint target;\n\n\twhile(cin >> s >> target, s != \"0\") {\n\t\tidx = 0;\n\t\tconst node root = parse(1);\n\t\tcout << root.get(target) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(const string str,const int from,const int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\t//if(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t//\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t//\tif(sum<idx){\n\t\t\t\t\t//\t\tcp=sum;\n\t\t\t\t\t//\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t//\t\tcontinue;\n\t\t\t\t\t//\t}\n\t\t\t\t\t//}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n\n#define MAX_LEN 1000000\n\nusing namespace std;\n\ntypedef pair<string,int> parsed;\nparsed parse(const string &expr, int i){\n  parsed ret;\n  string s;\n\n  int d=0;\n  if( isdigit( expr[i] ) ){\n    while( isdigit( expr[i] ) ){\n      int t = expr[i++]-'0';\n      d*=10;\n      d+=t;\n    }\n  }\n\n  if( expr[i] == '(' ){\n    parsed p = parse(expr,i+1);\n    s = p.first;\n    i = p.second;\n  }else{\n    while( isalpha( expr[i] ) ){\n      s+=expr[i++];\n    }\n  }\n\n  if( d==0 )d=1;\n  for(int j = 0; j < d; ++j){\n    ret.first+=s;\n    if( ret.first.length() > MAX_LEN )\n      break;\n  }\n\n  if( i < expr.size() && expr[i] == ')' )++i;\n\n  ret.second = i;\n  return ret;\n}\n\nchar solve(const string &expr, int n){\n  parsed ans;\n  while(ans.second<expr.size()){\n    parsed p = parse(expr,ans.second);\n    ans.first += p.first;\n    ans.second = p.second;\n  }\n  if(n<0||n>=ans.first.length())return '0';\n  return ans.first[n];\n}\n\nint main(){\n  while(true){\n    string expr;\n    int n;\n    cin>>expr>>n;\n    if(expr==\"0\"&&n==0)\n      break;\n    cout << solve(expr,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring str;\nstring ans;\nint N;\n\nint cal(string s) {\n    if (s == \"\") return 1;\n    stringstream ss;\n    ss << s;\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nstring make_str(string s, int left) {\n    if (s.size() == 1) return s;\n\n    string ret;\n    string ch;\n    string num;\n    for (int i = 0, len = s.size(), count = 0; i < len; i++) {\n        if (ret.size() + left > N + 1) break;\n        if (s[i] == '(') count++;\n        else if (s[i] == ')') count--;\n        else {\n            if (!('0' <= s[i] && s[i] <= '9')) ch += s[i];\n        }\n        if (!count && '0' <= s[i] && s[i] <= '9') num += s[i];\n        else if (count == 0){\n            string tmp = make_str(ch, left + ret.size());\n            for (int j = 0, len = cal(num); j < len; j++) {\n                if (ret.size() + left > N + 1) break;\n                ret += tmp;\n            }\n            ch = \"\";\n            num = \"\";\n        }\n    }\n\n    return ret;\n}\n\nvoid calc_char(int c, string s, int sum) {\n    string ans_str = make_str(s, 0);\n    string ans_;\n    for (int i = 0; i < c; i++) {\n        if (ans_.size() > N + 1) break;\n        ans_ += ans_str;\n    }\n    ans = ans_[sum];\n}\n\nint dfs(string s, int left) {\n    if (s.size() == 1) return 1;\n    int sum = 0;\n\n    string num;\n    string ch;\n    for (int i = 0, len = s.size(), count = 0; i < len; i++) {\n        if (!count && '0' <= s[i] && s[i] <= '9') num += s[i];\n        else {\n            ch += s[i];\n            if (s[i] == '(') count++;\n            if (s[i] == ')') count--;\n            if (count == 0) {\n                int c = cal(num);\n                if(ch[0] == '(') {\n                    ch.erase(ch.begin());\n                    ch.erase(ch.end()-1);\n                }\n\n                int tmp = dfs(ch, sum + left);\n                if (tmp < 0) return -1;\n                sum += c * tmp;\n                if (sum + left > N) {\n                    calc_char(c, ch, N - (sum - c * tmp));\n                    return -1;\n                }\n                ch = \"\";\n                num = \"\";\n            }\n        }\n    }\n\n    return sum;\n}\n\nvoid solve() {\n    ans = \"0\";\n\n    dfs(str, 0);\n\n    cout <<  ans << endl;\n}\n\nint main() {\n    while (cin >> str >> N, str != \"0\" || N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\nint get_int(const string &S, int &pos) {\n    int beg = pos;\n    for(; isdigit(S[pos]); pos++);    \n    return stoi(S.substr(beg, pos - beg + 1));\n}\n\nclass Solver {\n  public:\n    string S, buf;\n    int pos, N;\n    \n    void solve2() {\n        // cerr << \"-> \" << S.substr(0, pos + 1) << endl;\n        bool paren = S[pos] == '(';\n        if(paren) pos++;\n        do {\n            if(isdigit(S[pos])) {\n                int rec = get_int(S, pos);\n                if(S[pos] == '(') {\n                    int now = pos;\n                    rep(i, rec) {\n                        pos = now;\n                        solve2();                        \n                        if(buf.size() > N) return;\n                    }\n                } else {\n                    rep(i, rec) {\n                        buf.push_back(S[pos]);\n                        if(buf.size() > N) return;\n                    }\n                    pos++;\n                }\n            } else if(isalpha(S[pos])) {\n                do {\n                    buf.push_back(S[pos++]);\n                } while(paren and isalpha(S[pos]) and buf.size() <= N);\n            } else assert(0);\n        } while(paren and S[pos] != ')' and buf.size() <= N);\n        // cerr << \"<- \" << S.substr(0, pos + 1) << endl;\n        if(paren) pos++;\n    }\n    \n    bool solve() {\n        cin >> S >> N;\n        if(S == \"0\" and N == 0) return false;\n        pos = 0;\n        buf.reserve(N * 2);\n        while(buf.size() <= N and pos < S.size()) solve2();\n        \n        cout << (buf.size() <= N ? \"0\" : buf.substr(N, 1)) << endl;        \n        return true;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int i = 0;\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long id, nowend = 0;\nstring s;\nchar ans;\n\nlong long solve(long long now, long long req);\nvoid solve2();\n\nint main() {\n  while(1) {\n    cin >> s >> id;\n    if(s == \"0\" && id == 0) break;\n    ans = '0';\n    solve2();\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nlong long solve(long long now, long long req) {\n  long long cnt = 0, charcnt = 1;\n  string nows;\n  if(s[now] >= '0' && s[now] <= '9') {\n    while(s[now] >= '0' && s[now] <= '9') {\n      cnt *= 10;\n      cnt += s[now++] - '0';\n    }\n    charcnt = solve(now, inf);\n    cnt *= charcnt;\n    if(cnt > req) return solve(now, req % charcnt);\n  }\n  else if(s[now] == '(') {\n    nowend = now + 1;\n    while(nowend < s.size() && s[nowend] != ')') {\n      charcnt = solve(nowend, req - cnt);\n      if(charcnt == -1) return -1;\n      cnt += charcnt;\n    }\n    ++nowend;\n  }\n  else {\n    while(now < s.size() && s[now] >= 'A' && s[now] <= 'Z')\n      nows += s[now++];\n    if(req < nows.size()) {\n      ans = nows[req];\n      return -1;\n    }\n    nowend = now;\n    cnt = nows.size();\n  }\n  return cnt;\n}\n\nvoid solve2() {\n  nowend = 0;\n  while(nowend < s.size()) {\n    long long x = solve(nowend, id);\n    if(x < 0) return;\n    id -= x;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nll a,t;\nchar out;\nstring f(int a){\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(out!='0')return \"\";\n\t\tif(isalpha(s[t])){\n\t\t\tw+=s[t];\n\t\t\tt++;\n\t\t\tif(a<w.size()){\n\t\t\t\tout=w[a];return \"\";\n\t\t\t}\n\t\t}else if(s[t]==')'){\n\t\t\treturn w;\n\t\t}else{\n\t\t\tint co=0;\n\t\t\twhile(isdigit(s[t])){\n\t\t\t\tco*=10;\n\t\t\t\tco+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tstring tmp;\n\t\t\tif(isalpha(s[t])){\n\t\t\t\ttmp=s[t];\n\t\t\t}else{\n\t\t\t\tt++;\n\t\t\t\ttmp=f(a);\n\t\t\t}\n\t\t\tif(a<w.size()+tmp.size()*co){\n\t\t\t\tout=tmp[(a-w.size())%co];\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\trep(i,co)w+=tmp;\n\t\t\tt++;\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\twhile(cin>>s>>a,s!=\"0\"){\n\t\tout='0';\n\t\tt=0;\n\t\tf(a);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(const string str,const int from,const int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e10\nusing namespace std;\n\nstring s;\nlong long idx, n;\n\nchar solve();\nlong long parse(long long &id);\nstring parsestring(long long &id);\nchar calc(long long &id);\n\nint main() {\n  while(1) {\n    cin >> s >> idx;\n    if(s == \"0\" && idx == 0) break;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nchar solve() {\n  n = s.size();\n  long long id = 0;\n  while(id < n) {\n    long long nowsize, nowid = id;\n    nowsize = parse(id);\n    if(nowsize > idx)\n      return calc(nowid);\n    else\n      idx -= nowsize;\n  }\n  return '0';\n}\n\nlong long parse(long long &id) {\n  long long now = 0, res = 0;\n  while(isdigit(s[id])) {\n    now *= 10;\n    now += s[id++] - '0';\n  }\n  if(now == 0) now = 1;\n  if(s[id] >= 'A' && s[id] <= 'Z')\n    return now * parsestring(id).size();\n  assert(s[id] == '(');\n  ++id;\n  while(s[id] != ')') res = min(now * parse(id) + res, inf);\n  assert(s[id] == ')');\n  ++id;\n  return res;\n}\n\nstring parsestring(long long &id) {\n  string res;\n  while(id < n && s[id] >= 'A' && s[id] <= 'Z')\n    res += s[id++];\n  return res;\n}\n\nchar calc(long long &id) {\n  while(isdigit(s[id])) ++id;\n  if(s[id] >= 'A' && s[id] <= 'Z') {\n    string nows = parsestring(id);\n    return nows[idx % nows.size()];\n  }\n  vector<long long> len, idv;\n  long long sum = 0;\n  assert(s[id] == '(');\n  ++id;\n  while(s[id] != ')') {\n    idv.push_back(id);\n    len.push_back(sum + parse(id));\n    sum = len.back();\n  }\n  assert(s[id] == ')');\n  idx %= sum;\n  long long nextid =\n      upper_bound(len.begin(), len.end(), idx) -\n      len.begin();\n  if(nextid != 0) idx -= len[nextid - 1];\n  return calc(idv[nextid]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nstring s;\nint id;\n\nstruct Node {\n    int v;\n    string s;\n    vector<Node> children;\n    Node(int v_, string s_) : v(v_), s(s_){}\n    void print() {\n        if (children.size() == 0) {\n            cout << s;\n            return;\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                this->children[j].print();\n            }\n        }\n    }\n\n    int sum_v() {\n        int res = 0;\n        if (children.size() == 0) return s.size();\n        rep(i, (int)children.size()) {\n            res += children[i].sum_v();\n            if (res > (int)1e9) return (int)1e9;\n        }\n        return res * v;\n    }\n\n    char ans(int& cur_id) {\n        if (children.size() == 0) {\n            if (id - cur_id < (int)s.size()) {\\\n                return s[id - cur_id];\n            }\n            else {\n                cur_id += s.size();\n                return '0';\n            }\n        }\n        if (not (id - cur_id < sum_v()) ) {\n            cur_id += sum_v();\n            return '0';\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                char res = children[j].ans(cur_id);\n                if (isalpha(res)) return res;\n            }\n        }\n        return '0';\n    }\n};\n\nNode make_tree(int& i) {\n    Node cur_node(1, \"\");\n    while (s[i] != ')' && s[i] != '\\0') {\n        if (isdigit(s[i])) {\n            char *e;\n            int v = strtol(&s[i], &e, 10);\n            if (test) dump(e);\n            i += (e - &s[i]);\n            if (s[i] == '(') i++;\n            if (test) dump(s[i]);\n            Node child = make_tree(i);\n            child.v = v;\n            cur_node.children.push_back(child);\n            if (i < (int)s.size() && s[i] == ')') i++;\n            if (test) cout << \"2:\";\n            if (test) dump(s[i]);\n        }\n        else {\n            int start = i;\n            while (isalpha(s[i])) i++;\n            int end = i;\n            cur_node.children.push_back(Node(1, s.substr(start, end-start)));\n            if (test) dump(cur_node.children.back().s);\n        }\n    }\n    return cur_node;\n}\n\nvoid solve() {\n    cin >> s >> id;\n    if (s == \"0\") exit(0);\n    int id = 0;\n    Node root = make_tree(id);\n\n    if (false) {\n        root.print();\n        cout << endl;\n    }    \n    dump(root.sum_v());\n    \n    id = 0;\n    cout << root.ans(id) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[200];\nchar *p;\nint k;\nint len;\n\nchar ans;\n\nint solve(int k, int l, int r){\n    int cur = k;\n    dump(k);\n    dump(l);\n    dump(r);\n    int res = 0;\n    while(s[l] && l<r){\n        while(isalpha(s[l])){\n            if(cur==0){\n                dump(k);\n                dump(s[l]);\n                ans = s[l];\n                throw \"\";\n            }\n            res++;\n            l++;\n            cur--;\n        }\n        int times = 0;\n        while(isdigit(s[l])){\n            times = times*10 + s[l]-'0';\n            l++;\n        }\n        if(s[l]=='('){\n            int d = 0;\n            int i = l;\n            while(1){\n                if(s[i]=='(') d++;\n                else if(s[i]==')') d--;\n                if(d==0) break;\n                i++;\n            }\n            int rangelen = solve(k,l+1,i);\n            for(int j=0;j<times;j++){\n                res += solve(k,l+1,i);\n                k -= rangelen;\n            }\n            l = i+1;\n        } else if(isalpha(s[l])){\n            for(int j=0;j<times;j++){\n                res += solve(k,l,l+1);\n                k -= 1;\n            }\n            l = l+1;\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> s >> k && s[0]!='0'){\n        len = strlen(s);\n        int l = 0;\n        ans = '0';\n        try {\n            solve(k,l,len);\n            cout << ans << endl;\n        } catch(...){\n            cout << ans << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstring parse(string V, int w) {\n\twhile (V.size() >= 2 && V[0] == '(' && V[V.size() - 1] == ')')V = V.substr(1, V.size() - 2);\n\tif (V.size() == 1)return V;\n\tint depth = 0;\n\tstring E = \"\", F = \"\"; vector<pair<int, string>>v;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '(')depth++;\n\t\tif (V[i] == ')')depth--; F += V[i];\n\t\tif (depth == 0 && ((V[i] >= 'A' && V[i] <= 'Z') || V[i] == ')')) {\n\t\t\tstring Y = \"\"; int c = 0; while (F[c] >= '0' && F[c] <= '9') { Y += F[c]; c++; }\n\t\t\tint D = 1; if (Y.size() >= 1)D = stoi(Y);\n\t\t\tv.push_back(make_pair(D, F.substr(c, F.size() - c))); F = \"\";\n\t\t}\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (E.size() >= w)break;\n\t\tstring Z = parse(v[i].second, w);\n\t\tfor (int j = 0; j < v[i].first; j++) {\n\t\t\tif (E.size() >= w)break;\n\t\t\tE += Z;\n\t\t}\n\t}\n\treturn E.substr(0, min((int)E.size(), w));\n}\nint main() {\n\twhile (true) {\n\t\tstring S; int T; cin >> S >> T; if (S == \"0\" && T == 0)break;\n\t\tstring U = parse(S, T + 1);\n\t\tif (U.size() <= T) { cout << \"0\" << endl; }\n\t\telse cout << U[T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n#include <vector>\n#include <map>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n\nstring Str;\nint Index;\n\nclass Node {\npublic:\n  int num;\n  string s;\n  vector<Node> v;\n  Node() { num = -1; }\n};\n\nNode root;\n\nint getNum(int &pos, string s) {\n  int st = pos;\n  int length = 0;\n  while(isdigit(s[pos])) { ++length; ++pos; }\n  //cout << s << \" => \" << s.substr(st, length) << endl;\n  return atoi(s.substr(st, length).c_str());\n}\n\nchar rec(int &i, int j, Node node) {\n  //cout << node.s << \" :: \" << node.num << endl;\n  if(node.s.size()) {\n    for(int l = 0; l < node.num; ++l) {\n      for(int k = 0; k < node.s.size(); ++k) {\n\t//cout << node.s[k];\n\tif(i == j) return node.s[k];\n\t++i;\n      }\n    }\n    return '0';\n  }\n\n  for(int k = 0; k < node.num; ++k) {\n    for(int l = 0; l < node.v.size(); ++l) {\n      char c = rec(i, j, node.v[l]);\n      if(c != '0') return c;\n    }\n  }\n  return '0';\n}\n\nvector<string> sep(string s)\n{\n  string t;\n  vector<string> v, u;\n  t += s[0];\n\n  for(int i=1; i<s.size(); ++i){\n    if( s[i-1] == ')' && isalpha(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( s[i-1] == ')' && isdigit(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( isdigit(s[i]) && isalpha(s[i-1])){\n      v.push_back(t);\n      t = \"\";\n    }\n    t += s[i];\n  }\n  if(t.size()) {\n    v.push_back(t);\n  }\n\n  int o, c;\n  o = c = 0;\n  t = \"\";\n  for(int i = 0; i < v.size(); ++i) {\n    if(o + c && o == c) {\n      u.push_back(t);\n      o = c = 0;\n      t = \"\";\n    }\n    t += v[i];\n    o += count(v[i].begin(), v[i].end(), '(');\n    c += count(v[i].begin(), v[i].end(), ')');\n  }\n  if(t.size()) u.push_back(t);\n  return u;\n  for(int i=0; i<u.size(); ++i){\n    cout << u[i] << \"_\";\n  }\n  cout << endl;\n  return u;\n}\n\nNode build(string s) {\n  //cout << s << endl;\n  Node node;\n  int num;\n  if(isalpha(s[0])) {\n    node.num = 1;\n    node.s = \"\" + s;\n    return node;\n  } else {\n    int pos = 0;\n    num = getNum(pos, s);\n    if(s[pos] != '(') {\n      node.num = num;\n      node.s = \"\";//(pos < s.size()) ? \"####\" : \"@@@\";\n      node.s += s[pos];\n      return node;\n    }\n    ++pos;\n    s.erase(s.begin(), s.begin()+pos);\n    s.erase(s.begin() + s.size() - 1);\n    if(count(s.begin(), s.end(), '(') == 0) {\n      node.num = num;\n      node.s = s;\n      return node;\n    }\n    int o, c;\n    string t = \"\";\n    o = c = 0;\n    vector<string> v = sep(s);\n    for(int i=0; i<v.size(); ++i){\n      node.v.push_back( build(v[i]) );\n    }\n  }  \n  node.num = num;\n  return node;\n  cout << node.s << endl;\n  for(int i = 0; i < node.v.size(); ++i) {\n    cout << node.v[i].s << \" \";\n  }\n  cout << endl << endl;\n  return node;\n}\n\nvoid solve() {\n  Str.insert(0, \"1(\");\n  Str.insert(Str.size(), \")\");\n  root = build(Str);\n  int i = 0;\n  char c  = rec(i, Index, root);\n  cout << c << endl;\n}\n\nmain() {\n  while(cin >> Str >> Index) {\n    if(Str == \"0\" && Index == 0) break;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        curr->children.push_back(c);\n        c->num = ck;\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      auto c = make_shared<tree>();\n      c->s = read_s(s);\n      c->num = 1;\n      curr->children.push_back(c);\n      if(!s.empty() && !isdigit(s[0])) { return; }\n    }\n  }\n}\n\nstring ans;\n\nvoid visit(tree_ptr curr) {\n  if(ans.size() >= 1000000) { return; }\n  rep(i, curr->num) {\n    if (curr->children.empty()) {\n      ans += curr->s;\n      if(ans.size() >= 1000000) { return; }\n    }\n\n    rep(i, curr->children.size()) {\n      visit(curr->children[i]);\n    }\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  ans.clear();\n  visit(root);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans << endl;cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring s;\nint i;\nint idx;\nchar ans;\n\nint getNum()\n{\n  string ret = \"\";\n  while(idx < s.size() && isdigit(s[idx])) ret += s[idx++];\n  return stoi(ret);\n}\n\n// ()????????????/?????¨?????????\nint solve(int len)\n{\n  int ret = 0;\n  if(idx == s.size()) return 0;\n  if(s[idx] == ')') return 0;\n  if(s[idx] == '(') {\n    idx++; // skip '('\n    ret = solve(len);\n    if(ret == -1) return -1;\n    idx++; // skip ')'\n    return ret;\n  } else if(isalpha(s[idx])) {\n    if(len == i) {\n      ans = s[idx];\n      return -1;\n    }\n    idx++;\n    ret = solve(len+1);\n    if(ret == -1) return -1;\n    return ret + 1;\n  } else {\n    int k = getNum(), l = 1;\n    int re = idx;\n    if(s[idx] == '(') l = solve(len);\n    else if(isalpha(s[idx])) idx++;\n    if(i < len + k*l) { // ??¶????????????\n      idx = re;\n      i = (i - len) % l;\n      return solve(0); // -1\n    }\n    ret = solve(len + k*l);\n    if(ret == -1) return -1;\n    return ret + k*l;\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> s >> i, s != \"0\") {\n    idx = 0;\n    ans = '0';\n    solve(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cassert>\n#include <string>\nusing namespace std;\n\nchar s[5000];\nint len;\n\nint length(int const k, int const l, int const r){\n    int cur = 0, res = 0, p = l;\n    while(s[p] && p < r){\n        if(isalpha(s[p])){\n            while(isalpha(s[p])){\n                if(cur == k) throw s[p];\n                res++;\n                p++;\n                cur++;\n            }\n        } else if(isdigit(s[p])){\n            int mul = 0;\n            while(isdigit(s[p])){\n                mul = mul * 10 + s[p] - '0';\n                p++;\n            }\n            int d = 0, i = p++;\n            while(1){\n                if(s[i] == '(') d++;\n                else if(s[i] == ')') d--;\n                if(d == 0) break;\n                i++;\n            }\n            for(int j = 0; j < mul; j++){\n                int d = length(k - cur, p, i);\n                res += d;\n                cur += d;\n            }\n            p = i + 1;\n        }\n    }\n    return res;\n}\n\nint main(){\n    static char t[5000];\n    int k;\n    while(scanf(\"%s%d\",t,&k), t[0] != '0'){\n        int tlen = strlen(t);\n        len = 0;\n        for(int i = 0; i < tlen; i++){\n            if(i > 0 && isdigit(t[i - 1]) && isalpha(t[i])){\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            } else {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n        try{\n            length(k, 0, len);\n            putchar('0');putchar('\\n');\n        } catch (char e) {\n            putchar(e);putchar('\\n');\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\n\nusing namespace std;\n\nint solve(stringstream &ss, int remains, char &result){\n\tint length = 0;\n\twhile(ss.tellg() < ss.str().size() && remains >= 0){\n\t\tif(isdigit(ss.peek())){\n\t\t\tint loop;\n\t\t\tss >> loop;\n\t\t\tchar c = ss.get();\n\t\t\tif(c == '('){\n\t\t\t\tstreampos pos = ss.tellg();\n\t\t\t\tint len = solve(ss, remains, result);\n\t\t\t\tif(len * loop > remains){\n\t\t\t\t\tss.seekg(pos, ios_base::beg);\n\t\t\t\t\tsolve(ss, remains % len, result);\n\t\t\t\t}\n\t\t\t\tremains -= len * loop;\n\t\t\t\tlength += len * loop;\n\t\t\t}else{\n\t\t\t\tif(loop > remains){ result = c; }\n\t\t\t\tremains -= loop;\n\t\t\t\tlength += loop;\n\t\t\t}\n\t\t}else{\n\t\t\tchar c = ss.get();\n\t\t\tif(c == ')'){\n\t\t\t\tbreak;\n\t\t\t}else if(remains-- == 0){\n\t\t\t\tresult = c;\n\t\t\t}\n\t\t\t++length;\n\t\t}\n\t}\n\treturn length;\n}\n\nint main(){\n\twhile(true){\n\t\tstring s;\n\t\tint pos;\n\t\tcin >> s >> pos;\n\t\tif(s == \"0\" && pos == 0){ break; }\n\t\tchar answer = '0';\n\t\tstringstream ss(s);\n\t\tsolve(ss, pos, answer);\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\nclass Node\n{\npublic:\n\tchar c;\n\tint num;\n\tint total;\n\tvector<Node> child;\n\tNode(int num0, char c0){\n\t\tnum = num0;\n\t\tc = c0;\n\t\ttotal = 0;\n\t}\n};\n\nvoid solve(string s, int a)\n{\n\tNode root(1, '(');\n\tNode* pNode = &root;\n\tstack<Node*> stkNode;\n\tistringstream iss(s);\n\n\tfor(;;){\n\t\tint tmp;\n\t\tif(!(iss >> tmp)){\n\t\t\tif(iss.eof())\n\t\t\t\tbreak;\n\t\t\ttmp = 1;\n\t\t\tiss.clear();\n\t\t}\n\t\tchar c;\n\t\tiss >> c;\n\t\tif(c == ')'){\n\t\t\tpNode = stkNode.top();\n\t\t\tstkNode.pop();\n\t\t\tpNode->total += pNode->num * pNode->child.rbegin()->total;\n\t\t\tif(pNode->total > 1000000)\n\t\t\t\tpNode->total = 1000000;\n\t\t}else{\n\t\t\tpNode->child.push_back(Node(tmp, c));\n\t\t\tif(c == '('){\n\t\t\t\tstkNode.push(pNode);\n\t\t\t\tpNode = &(*pNode->child.rbegin());\n\t\t\t}else{\n\t\t\t\tpNode->child.rbegin()->total = tmp;\n\t\t\t\tpNode->total += pNode->num * tmp;\n\t\t\t\tif(pNode->total > 1000000)\n\t\t\t\t\tpNode->total = 1000000;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(pNode->total <= a){\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\n\tfor(;;){\n\t\tif(pNode->total <= 1000000)\n\t\t\ta %= pNode->total / pNode->num;\n\t\tfor(int i=0; ; ++i){\n\t\t\tif(a < pNode->child[i].total){\n\t\t\t\tpNode = &(pNode->child[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta -= pNode->child[i].total;\n\t\t}\n\t\tif(pNode->c != '('){\n\t\t\tcout << pNode->c << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring s;\n\t\tint a;\n\t\tcin >> s >> a;\n\t\tif(s == \"0\" && a == 0)\n\t\t\tbreak;\n\n\t\tsolve(s, a);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\n\nstring factor(State &begin,int &n,int x);\nint number(State &begin);\nstring seq(State &begin);\n\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nstring seq(State &begin){\n\tstring ret=\"\";\n\twhile(*begin>='A' && *begin<='Z'){\n\t\tret+=*begin;\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nstring factor(State &begin,int &n,int x){\n\tint k=1;\n\tstring str=\"\";\n\twhile(1){\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tstring ret=factor(begin,n,x);\n\t\t\t//cout << ret << endl;\n\t\t\tbegin++;\n\t\t\tif(n>x)return ret;\n\t\t\tstr+=ret;\n\t\t\tfor(int i=1;i<k;i++){\n\t\t\t\tstr+=ret;\n\t\t\t\tn+=ret.size();\n\t\t\t\tif(n>x){\n\t\t\t\t\tstring res=\"\";\n\t\t\t\t\tres+=ret[ret.size()-(n-x)];\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=1;\n\t\t}else if(*begin>='0' && *begin<='9'){\n\t\t\tk=number(begin);\n\t\t}else if(*begin>='A' && *begin<='Z'){\n\t\t\t//string ret=seq(begin);\n\t\t\tfor(int i=0;i<k;i++){\n\t\t\t\tstr+=*begin;\n\t\t\t\tn++;\n\t\t\t\tif(n>x){\n\t\t\t\t\tstring res=\"\";\n\t\t\t\t\tres+=*begin;\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=1;\n\t\t\tbegin++;\n\t\t}else break;\n\t}\n\treturn str;\n}\n\nint main(void){\n\twhile(1){\n\t\tint x;\n\t\tstring str;\n\t\tcin >> str >> x;\n\t\tif(str==\"0\" && x==0)break;\n\t\tState begin=str.begin();\n\t\tint d=0;\n\t\tstring res=factor(begin,d,x);\n\t\tif(d<=x)res=\"0\";\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\ntypedef string::const_iterator Iter;\ntypedef ostringstream SS;\n\nstring express(Iter &p);\nstring factor(Iter &p);\nstring term(Iter &p);\nint number(Iter &p);\n\nint N;\n\nstring express(Iter &p) {\n\tSS r;\n\twhile(isalpha(*p) || isdigit(*p)) {\n\t\tstring rs = term(p);\n\t\tr << rs;\n\t\tif(r.str().length() > N) break;\n\t}\n\n\treturn r.str();\n}\n\n\nstring term(Iter &p) {\n\tif(isdigit(*p)) {\n\t\tSS r;\n\t\tint num = number(p);\n\t\tif(*p == '(') {\n\t\t\tp++;\n\t\t\tstring rs = express(p);\n\t\t\tp++;\n\n\t\t\tfor(int i = 0; i < num; i++) {\n\t\t\t\tr << rs;\n\t\t\t\tif(r.str().size() > N) break;\n\t\t\t}\n\t\t\treturn r.str();\n\t\t}\n\t\telse {\n\t\t\tchar c = *p;\n\t\t\tp++;\n\n\t\t\tfor(int i = 0; i < num; i++) {\n\t\t\t\tr << c;\n\t\t\t\tif(r.str().size() > N) break;\n\t\t\t}\n\t\t\treturn r.str();\n\t\t}\n\t}\n\telse {\n\t\treturn factor(p);\n\t}\n}\n\nstring factor(Iter &p) {\n\tSS r;\n\twhile(isalpha(*p)) {\n\t\tr << *p;\n\t\tp++;\n\t\tif(r.str().size() > N) break;\n\t}\n\treturn r.str();\n}\n\nint number(Iter &p) {\n\tint r = 0;\n\twhile(isdigit(*p)) {\n\t\tr *= 10;\n\t\tr += (*p) - '0';\n\t\tp++;\n\t}\n\treturn r;\n}\n\nint main() {\n\tfor(;;) {\n\t\tstring line;\n\t\tint i;\n\t\tcin >> line >> i;\n\t\tN = i;\n\t\tif(line == \"0\" && i == 0) break;\n\t\tstring source = line + \"|\";\n\t\tIter begin = source.begin();\n\t\tstring s = express(begin);\n\t\tif(i >= s.length())\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << s[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "a"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<string>\n#include<cstring>\n#include<iostream>\n\n#define\trep(i,n)\tfor(int i=0;i<(n);i++)\n\nusing namespace std;\n\n/*\nGENOME ::= UNIT | UNIT GENOME\nUNIT ::= MOLECULE | NUMBER MOLECULE | NUMBER '(' GENOME ')'\nMOLECULE ::= A | B | .. | Z\nNUMBER ::= 1 | 2 | .. | 1000\n*/\n\nvoid GENOME(int &,int &);\nvoid UNIT(int &,int &);\nvoid MOLECULE(int &,int &);\nint NUMBER(int &);\n\nstring s;\nint p,len;\nchar s2[1000001];\n\nvoid GENOME(int &idx,int &idx2){\n\twhile(idx<len && isalnum(s[idx])){\n\t\tif(p<idx2)\treturn;\n\t\tUNIT(idx,idx2);\n\t}\n}\n\nvoid UNIT(int &idx,int &idx2){\n\tif(isalpha(s[idx]))\tMOLECULE(idx,idx2);\n\telse{\n\t\tint num=NUMBER(idx);\n\t\tint bef,aft;\n\t\tif(s[idx]!='('){\n\t\t\tbef=idx2;\n\t\t\tMOLECULE(idx,idx2);\n\t\t\taft=idx2;\n\t\t}\n\t\telse{\n\t\t\tidx++;\n\t\t\tbef=idx2;\n\t\t\tGENOME(idx,idx2);\n\t\t\taft=idx2;\n\t\t\tidx++;\n\t\t}\n\t\tint dif=aft-bef;\n\t\trep(i,num-1)rep(j,dif){\n\t\t\tif(p<idx2)\treturn;\n\t\t\ts2[idx2++]=s2[bef+j];\n\t\t}\n\t}\n}\n\nvoid MOLECULE(int &idx,int &idx2){\n\tif(p<idx2)\treturn;\n\ts2[idx2++]=s[idx++];\n}\n\nint NUMBER(int &idx){\n\tint num=0;\n\twhile(idx<len && isdigit(s[idx]))\tnum=num*10+(s[idx++]-'0');\n\treturn num;\n}\n\nint main(){\n\twhile(cin>>s>>p,s!=\"0\"||p!=0){\n\t\tmemset(s2,0,sizeof(s2));\n\t\tlen=s.length();\n\t\tint idx=0,idx2=0;\n\t\tGENOME(idx,idx2);\n\t\tcout<<(p<idx2?s2[p]:'0')<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring str;\nll idx;\nll extendex_length;\nll pos;\n\nll a();\nstring b();\nll c();\nll number();\nstring alpha();\n\nll a(){\n  ll numofalpha = alpha().length();\n  while(pos < str.length() && isdigit(str[pos])){\n    ll num = number();\n    if(str[pos] == '('){\n      pos++;   //'('\n      ll subnumofalpha = 0;\n      subnumofalpha += a();\n      subnumofalpha += alpha().length();\n      numofalpha += num * subnumofalpha;\n      pos++;   //')'\n    }else{\n      numofalpha += alpha().length() * num;\n    }\n  }\n  return numofalpha;\n}\n\nstring b(){\n  string res = alpha();\n  while(pos < str.length() && isdigit(str[pos])){\n    ll num = number();\n    if(str[pos] == '('){\n      pos++;  //'('\n      string subres;\n      subres += b();\n      subres += alpha();\n      for(ll i=0; i < num; i++){\n        res += subres;\n        if(res.length() > idx) return res;\n      }\n      pos++;\n    }else{\n      string subres = alpha();\n      for(ll i=0; i < num; i++){\n        res += subres;\n      }\n    }\n  }\n  return res;\n}\n\nll number(){\n  ll res = 0;\n  if(pos < str.length()){\n    while(isdigit(str[pos])){\n      res *= 10;\n      res += str[pos] - '0';\n      pos++;\n    }\n  }\n  return res;\n}\n\nstring alpha(){\n  string res;\n  while(isalpha(str[pos])){\n    res += string(1, str[pos]);\n    pos++;\n  }\n  return res;\n}\n\nint main(void){\n  while(cin >> str >> idx, str[0]-'0' || idx){\n    pos = 0;\n    extendex_length = a();\n    pos = 0;\n    string extended;\n    extended = b();\n    if(idx >= extendex_length){\n      cout << 0 << endl;\n    }else{\n      cout << extended[idx] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    string get_foo(const string &S, int &pos, function<int(int)> isfoo) {\n        int len = 0;\n        for(; isfoo(S[pos + len]); len++);\n        string ret = S.substr(pos, len);\n        pos += ret.size();\n        return ret;\n    }\n    string calc(const string &S, int &pos, int N) {\n        bool paren = S[pos] == '(';\n        if(S[pos] == '(') pos++;\n        string res = \"\";        \n        do {\n            if(isdigit(S[pos])) {\n                int rec = stoi(get_foo(S, pos, [](int a) { return isdigit(a); }));\n                int need = N - res.size();\n                string ss = calc(S, pos, need);\n                if(rec * ss.size() > need) rec = need / ss.size() + 1;\n                rep(i, rec) res += ss;\n            } else if(isalpha(S[pos])) {\n                res = get_foo(S, pos, [](int a) { return isalpha(a); });\n            } else assert(0);\n        } while(paren and S[pos] != ')');\n        if(paren) pos++;\n        return res;\n    }\n    \n    bool solve() {\n        string S; cin >> S;\n        if(S == \"0\") return false;\n        int N; cin >> N;\n        int pos = 0;\n        string s = \"\";\n\n        while(pos < S.size() and s.size() <= N) {\n            s += calc(S, pos, N - s.size() + 1);\n        }\n        cout << (s.size() <= N ? \"0\" : s.substr(N, 1)) << endl;        \n        return true;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nstring ans, str;\nint p;\n\nstring dfs(){\n    int res;\n    string st = \"\";\n    while (p < str.size()) {\n        if (isdigit(str[p])) {\n            res = 0;\n            while (isdigit(str[p])) {\n                res *= 10;\n                res += str[p] - '0';\n                p++;\n            }\n        }else if (isalpha(str[p])){\n            st = \"\";\n            while (isalpha(str[p])) {\n                st += str[p];\n                p++;\n            }\n        }else if (str[p] == '('){\n            p++;\n            string tmp = dfs();\n            for (int i = 0; i < res; i++) {\n                st += tmp;\n            }\n        }else if (str[p] == ')'){\n            p++;\n            return st;\n        }\n    }\n    return st;\n}\n\nstring complement(string s){\n    int p = 0;\n    string expanded_string = \"\";\n    while (p < s.size()) {\n        if (isdigit(s[p]) && isalpha(s[p+1])) {\n            expanded_string += s[p++];\n            expanded_string += '(';\n            while (isalpha(s[p])) {\n                expanded_string += s[p++];\n            }\n            expanded_string += ')';\n        }else{\n            expanded_string += s[p++];\n        }\n    }\n    return expanded_string;\n}\n\nint main()\n{\n    int n;\n    while (true) {\n        p = 0;\n        cin >> str >> n;\n        if (str == \"0\") {\n            break;\n        }\n        str = complement(str);\n        ans = dfs();\n        if (ans.size() <= n) {\n            cout << \"0\" << endl;\n        }else{\n            cout << ans[n] << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n\nstring genome() {\n\tstring res = \"\";\n\tif(s[roc] == '(') {\n\t\t++roc;\n\t\twhile(s[roc] != ')' && !found) {\n\t\t\tif(s[roc] >= 'A' && s[roc] <= 'Z') {\n\t\t\t\tres += s[roc];\n\t\t\t\t++t;\n\t\t\t\tif(t == i) {\n\t\t\t\t\tans = s[roc];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++roc;\n\t\t\t} else {\n\t\t\t\tll roc_buf = roc;\n\t\t\t\twhile(s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\t\t\tint roop = stoi(s.substr(roc_buf, roc - roc_buf));\n\t\t\t\tstring rooped = genome();\n\t\t\t\tif(!found) {\n\t\t\t\t\tREP(j, roop - 1) {\n\t\t\t\t\t\tif(t + rooped.size() < i) {\n\t\t\t\t\t\t\tt += rooped.size();\n\t\t\t\t\t\t\tres += rooped;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tans = rooped[(i - t) - 1];\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t} else {\n\t\tres += s[roc];\n\t\t++t;\n\t\tif(t == i) {\n\t\t\tans = s[roc];\n\t\t\tfound = true;\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s>>i;\n\t\tif(s == \"0\" && i == 0) break;\n\t\troc = 0;\n\t\tt = -1;\n\t\tfound = false;\n\t\tans = '#';\n\t\ts = \"(\" + s;\n\t\ts += \")\";\n\t\tgenome();\n\t\tif(ans == '#') cout<<0<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nll k;\nstring s;\nint p;\nvoid cat(string& a, const string& b)\n{\n    if (a.size() <= k)\n        a += b;\n}\nstring seq();\nstring parse()\n{\n    string res;\n    while (p < s.size())\n    {\n        if (isalpha(s[p]))\n        {\n            res += s[p];\n            ++p;\n        }\n        else if (isdigit(s[p]))\n        {\n            ll num = 0;\n            while (isdigit(s[p]))\n            {\n                num = 10*num + (s[p] - '0');\n                ++p;\n            }\n            string t = seq();\n            while (num--)\n                cat(res, t);\n        }\n        else if (s[p] == ')')\n            break;\n        else\n            assert(false);\n    }\n    return res;\n}\nstring seq()\n{\n    if (isalpha(s[p]))\n        return string() + s[p++];\n    else\n    {\n        ++p;\n        string res = parse();\n        ++p;\n        return res;\n    }\n}\n\nint main()\n{\n    while (cin >> s >> k, s[0] != '0')\n    {\n        p = 0;\n        string t = parse();\n        cout << (k < t.size() ? t[k] : '0') << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse {\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t      pls+=s[c][idx];\n\t    }\n\t    //pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&(int)s[!c].size()<n+200;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n\n    if((int)s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse,int x):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt(){return StringToInt(getCnt());}\n\n  string decode()\n  {\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    else \n      {\n\tstring mes,ret;\n\twhile('A' <= parse[pos] && parse[pos] <= 'Z')\t\n\t  mes += parse[pos++];\n\t\n\tfor(int i=0;i<power;i++)\n\t  {\n\t    ret += mes;\n\t    if(ret.size() >= x)\n\t      break;\n\t  }\n\treturn ret;\t  \n      }\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n  \n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+1);\n      string message = par.exp();\n      if(message.size() <= pos)\n\tcout << 0 << endl\n\telse\n\t  cout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < a; i++)\n\nusing namespace std;\n\nstruct expr;\n\nstruct term\n{\n  bool flg;\n  string str;\n  int n;\n  expr *inner;\n\n  term(bool flg, string str, int n, expr *inner);\n  int length();\n  char charAt(int pos);\n};\n\nstruct expr\n{\n  vector<term> inner;\n\n  expr(vector<term> inner) : inner(inner) {}\n\n  int length() {\n    int ret = 0;\n    for (int i = 0; i < inner.size(); ++i)\n      ret += inner[i].length();\n    return ret;\n  }\n\n  char charAt(int pos) {\n    int cur = 0;\n    for (int i = 0; i < inner.size(); ++i) {\n      int next = cur + inner[i].length();\n      if (pos < next)\n\treturn inner[i].charAt(pos - cur);\n      cur = next;\n    }\n    return '0';\n  }\n};\n\nterm::term(bool flg, string str, int n, expr *inner)\n  : flg(flg), str(str), n(n), inner(inner) {}\n\nint term::length() {\n  return flg ? min((long long) n * inner->length(), 100000000LL) : str.length();\n}\n\nchar term::charAt(int pos) {\n  return flg ? inner->charAt(pos % inner->length()) : str[pos];\n}\n\nint parsenum(string s, int pos, int& next)\n{\n  int ret = 0;\n  while ('0' <= s[pos] && s[pos] <= '9') {\n    ret *= 10;\n    ret += s[pos] & 15;\n    ++pos;\n  }\n  next = pos;\n  return ret;\n}\n\nexpr *parseexpr(string s, int pos, int& next);\n\nterm parseterm(string s, int pos, int& next)\n{\n  if ('0' <= s[pos] && s[pos] <= '9') {\n    int n = parsenum(s, pos, next);\n    if (s[next] == '(') {\n      expr *inner = parseexpr(s, next + 1, next);\n      ++next;\n      return term(true, \"\", n, inner);\n    } else {\n      string str;\n      str.push_back(s[next]);\n      vector<term> inner;\n      inner.push_back(term(false, str, 0, NULL));\n      ++next;\n      return term(true, \"\", n, new expr(inner));\n    }\n  } else {\n    string ret;\n    while ('A' <= s[pos] && s[pos] <= 'Z') {\n      ret.push_back(s[pos]);\n      ++pos;\n    }\n    next = pos;\n    return term(false, ret, 0, NULL);\n  }\n}\n\nexpr *parseexpr(string s, int pos, int& next)\n{\n  vector<term> ret;\n  while (pos < s.length() && s[pos] != ')') {\n    term inner = parseterm(s, pos, next);\n    ret.push_back(inner);\n    pos = next;\n  }\n  return new expr(ret);\n}\n\nvoid solve(string s, int i)\n{\n  int dummy;\n  expr *e = parseexpr(s, 0, dummy);\n  cout << e->charAt(i) << endl;\n}\n\nint main()\n{\n  string s;\n  int i;\n  while (cin >> s >> i && s[0] != '0')\n    solve(s, i);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\n\n\ntypedef string::const_iterator State;\nclass ParseError {};\n\n// beginがexpectedを指していたらbeginを一つ進める。\nvoid consume(State &begin, char expected) {\n\tif (*begin == expected) {\n\t\tbegin++;\n\t} else {\n\t\tcerr << \"Expected '\" << expected << \"' but got '\" << *begin << \"'\" << endl;\n\t\tcerr << \"Rest string is '\";\n\t\twhile (*begin) {\n\t\t\tcerr << *begin++;\n\t\t}\n\t\tcerr << \"'\" << endl;\n\t\tthrow ParseError();\n\t}\n}\n\nstruct Genom{\n\tint type;\n\tchar c;\n\tint rec;\n\tvector<Genom> child;\n};\nvector<Genom> parse(State &begin);\n\nGenom factor(State &begin) {\n\tGenom ret;\n\tif (isalpha(*begin)) {\n\t\tret.type = 0;\n\t\tret.c = *begin++;\t\n\t}else if (isdigit(*begin)) {\n\t\tret.type = 1;\n\t\tret.rec = 0;\n\t\twhile(isdigit(*begin)) ret.rec = ret.rec*10 + *begin++ - '0';\n\t\tif(*begin == '(') ret.child = parse(begin);\n\t\telse ret.child.push_back(factor(begin));\n\t}\n\treturn ret;\n}\nvector<Genom> parse(State &begin) {\n\tvector<Genom> ret;\n\tconsume(begin, '(');\n\twhile(*begin!=')') ret.push_back(factor(begin));\n\tconsume(begin, ')');\n\treturn ret;\n}\nchar dfs(vector<Genom> g, int &n){\n\tfor(int i=0;i<g.size();i++){\n\t\tif(g[i].type == 0){\n\t\t\tif(!n--) return g[i].c;\n\t\t//\tcout << g[i].c;\n\t\t}else{\n\t\t\tfor(int j=g[i].rec;j;j--){\n\t\t\t\tchar ret = dfs(g[i].child, n);\n\t\t\t\tif(n < 0) return ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn '0';\n}\nmain(){\n\tint i,j;\n\tint n;\n\tstring s;\n\twhile(cin >> s >> n, s!=\"0\"){\n\t\ts = '(' + s + ')';\n\t\tState begin = s.begin();\n\t\tcout << dfs(parse(begin), n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int t;\nconst long long int MAX_T=1e8;\nlong long int read(int& i,string& s);\nlong long int counta(int &i,string &s);\nchar solve(int &i,string &s){\n  int prei=i;\n  long long int ret;\n  while(ret=read(i,s)){\n    prei=i;\n    if(ret==-1){\n      t--;\n      if(t==0) return s[i-1];\n    }\n    else{\n      long long int val=counta(i,s);\n      if(val*ret>=t){\n\tt%=val;\n\tif(t==0) t=val;\n\ti=prei;\n\treturn solve(i,s);\n      }\n      else{\n\tt-=val*ret;\n      }\n    }\n  }\n  return '0';\n  \n}\n\nlong long int counta(int &i,string &s){\n  long long int ret;\n  long long int res=0;\n  while(ret=read(i,s)){\n    if(ret==-1){\n      res++;\n    }\n    else{\n      res+=counta(i,s)*ret;\n      res=min(res,MAX_T);\n    }\n  }\n  return min(MAX_T,res);\n}\n\nlong long int read(int& i,string& s){\n  if(i>=s.size() || s[i]==')'){\n    i++;\n    return 0;\n  }\n  if(isalpha(s[i])){\n    i++;\n    return -1;\n  }\n  long long int prei=i;\n  for(;i<s.size() && isdigit(s[i]);i++);\n  long long int res=(i-prei>8 ? MAX_T :stoi(s.substr(prei,i-prei)));\n  if(s[i]=='(') i++;\n  return res;\n}\n\n\nint main(){\n  string s;\n  while(cin>>s>>t,s!=\"0\"){\n    int i=0;\n    t++;\n    string s2=\"\";\n    s2+=s[0];\n    for(int i=1;i<s.size();i++){\n      if(isdigit(s[i-1]) && s[i]!='('){\n\ts2+='(';\n\ts2+=s[i];\n\ts2+=')';\n      }\n      else{\n\ts2+=s[i];\n      }\n\n    }\n    s=s2;\n\n    cout<<solve(i,s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n \nchar s[5000];\nint len;\n \nint length(int const k, int const l, int const r){\n    int cur = 0, res = 0, p = l;\n    while(s[p] && p < r){\n        if(isalpha(s[p])){\n            while(isalpha(s[p])){\n                if(cur == k) throw s[p];\n                res++;\n                p++;\n                cur++;\n            }\n        } else if(isdigit(s[p])){\n            int mul = 0;\n            while(isdigit(s[p])){\n                mul = mul * 10 + s[p] - '0';\n                p++;\n            }\n            int d = 0, i = p++;\n            while(1){\n                if(s[i] == '(') d++;\n                else if(s[i] == ')') d--;\n                if(d == 0) break;\n                i++;\n            }\n            int memo = -1;\n            for(int j = 0; j < mul; j++){\n                if(memo != -1 && cur + memo < k){\n                    res += memo;\n                    cur += memo;\n                } else {\n                    int x = length(k - cur, p, i);\n                    res += x;\n                    cur += x;\n                    memo = x;\n                }\n            }\n            p = i + 1;\n        }\n    }\n    return res;\n}\n \nint main(){\n    static char t[5000];\n    int k;\n    while(scanf(\"%s%d\",t,&k), t[0] != '0'){\n        int tlen = strlen(t);\n        len = 0;\n        for(int i = 0; i < tlen; i++){\n            if(i > 0 && isdigit(t[i - 1]) && isalpha(t[i])){\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            } else {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n        try{\n            length(k, 0, len);\n            putchar('0');putchar('\\n');\n        } catch (char e) {\n            putchar(e);putchar('\\n');\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cassert>\nusing namespace std;\n\nchar s[5000];\nint len;\n\nint length(int const k, int const l, int const r){\n    int cur = 0, res = 0, p = l;\n    while(s[p] && p < r){\n        if(isalpha(s[p])){\n            while(isalpha(s[p])){\n                if(cur == k) throw s[p];\n                res++;\n                p++;\n                cur++;\n            }\n        } else if(isdigit(s[p])){\n            int mul = 0;\n            while(isdigit(s[p])){\n                mul = mul * 10 + s[p] - '0';\n                p++;\n            }\n            int d = 0, i = p++;\n            while(1){\n                if(s[i] == '(') d++;\n                else if(s[i] == ')') d--;\n                if(d == 0) break;\n                i++;\n            }\n            int memo = -1;\n            for(int j = 0; j < mul; j++){\n                if(memo != -1 && cur + memo < k){\n                    res += memo;\n                    cur += memo;\n                } else {\n                    int x = length(k - cur, p, i);\n                    res += x;\n                    cur += x;\n                    memo = x;\n                }\n            }\n            p = i + 1;\n        }\n    }\n    return res;\n}\n\nint main(){\n    static char t[5000];\n    int k;\n    while(scanf(\"%s%d\",t,&k), t[0] != '0'){\n        int tlen = strlen(t);\n        len = 0;\n        for(int i = 0; i < tlen; i++){\n            if(i > 0 && isdigit(t[i - 1]) && isalpha(t[i])){\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            } else {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n        try{\n            length(k, 0, len);\n            putchar('0');putchar('\\n');\n        } catch (char e) {\n            putchar(e);putchar('\\n');\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint pos;\nstruct Node;\nvector<Node> global;\nstruct Node {\n  string pat;\n  vector<P> xs;\n  bool leaf;\n  char chr;\n  long long len;\n\n  Node(char c) {\n    leaf = true;\n    chr = c;\n    len = 1;\n    pat=chr;\n  }\n  Node(string s) {\n    pat = s;\n    leaf = false;\n    len = 0;\n\n    int num = 0;\n    rep(i, s.length()) {\n      char c = s[i];\n      if ('0' <= c && c <= '9') num = 10*num + (int)(c-'0');\n      else {\n        if (num > 0) {\n          if (c == '(') {\n            int state = 1;\n            string t = \"\";\n            i++;\n            while (true) {\n              if (s[i] == '(') state++;\n              else if (s[i] == ')') {\n                state--;\n                if (state == 0) break;\n              }\n              t += s[i];\n              i++;\n            }\n            global.pb(Node(t));\n            xs.pb(P(global.size()-1, num));\n            len += 1LL * num * global.back().len;\n          }\n          else {\n            xs.pb(P(c-'A', num));\n            len += num;\n          }\n          num = 0;\n        }\n        else {\n          xs.pb(P(c-'A', 1));\n          len += 1;\n        }\n      }\n      if (len > pos) return;\n    }\n  }\n\n  char get(int offset) {\n    assert(offset < len);\n    if (leaf) return chr;\n    long long l = 0;\n    for (P p : xs) {\n      long long u = global[p._1].len * p._2;\n      if (l+u > offset) {\n        return global[p._1].get((offset - l) % global[p._1].len);\n      }\n      l+=u;\n    }\n    return '0';\n  }\n};\n\nchar parse(string s, int _pos) {\n  pos = _pos;\n  rep(i, 26) global.pb(Node((char)('A'+i)));\n  Node top(s);\n  if (top.len <= pos) return '0';\n  return top.get(pos);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  string s;\n  int i;\n  while (cin >> s >> i) {\n    if (s == \"0\") break;\n    cout << parse(s, i) << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\n#include<cstdlib>\n#define inf 1<<29\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nstring s;\nchar ans;\nvector<string> v;\nmap<int,int> mp;\n\nll rec(int,int);\n\nvoid rec2(int a,int b,int sum){\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1]);\n\tif(sum<=tmp*atoi(v[i].c_str()))rec2(i+2,mp[i+1],sum%tmp);\n\telse sum-=tmp*atoi(v[i].c_str());\n        i=mp[i+1];\n      }\n      else {\n        ll tmp=atoi(v[i].c_str())*v[i+1].length();\n        if(sum<=tmp){\n\t  ans=v[i+1][0];\n\t  return;\n\t}\n\telse {\n\t  sum-=tmp;\n\t  i++;\n\t}\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      if(sum<v[i].length())ans=v[i][sum];\n    }\n    else {}\n  }\n}\n\nll rec(int a,int b){\n  ll sum=0;\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1]);\n\tif(ans!='0')return inf;\n\tsum+=atoi(v[i].c_str())*tmp;\n\ti=mp[i+1];\n      }\n      else {\n\tsum+=atoi(v[i].c_str())*v[i+1].length();\n\ti++;\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      sum+=v[i].length();\n    }\n    else {}\n  }\n  if(n<=sum)rec2(a,b,n);\n  return sum;\n}\n\nint main()\n{\n  while(1){\n    cin>>s>>n;\n    if(s[0]=='0' && n==0)break;\n    ans='0';\n    v.clear();mp.clear();\n    string tmp1=\"\",tmp2=\"\";\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9')tmp1+=s[i];\n      if('A'<=s[i] && s[i]<='Z'){\n\tif(tmp1!=\"\")v.push_back(tmp1);\n\ttmp1=\"\";\n\ttmp2+=s[i];\n      }\n      if(s[i]=='('){\n\tv.push_back(tmp1);\n\ttmp1=\"\";\n\tv.push_back(\"(\");\n      }\n      if(s[i]==')'){\n        v.push_back(tmp2);\n        tmp2=\"\";\n        v.push_back(\")\");\n      }\n      if(i==s.length()-1 && tmp2!=\"\")v.push_back(tmp2);\n    }\n    stack<int> st;\n    for(int i=0;i<v.size();i++){\n      if(v[i]==\"(\")st.push(i);\n      if(v[i]==\")\"){\n\tmp[st.top()]=i;\n\tst.pop();\n      }\n    }\n    rec(0,v.size());\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n\n//string solve(int times,string s){\n//    string ret=\"\";\n//    string part=\"\";\n//    \n//    int len=s.size();\n//\n//    rep(i,len){\n//        if( isalpha(s[i]) ){\n//            part+=s[i];\n//        }\n//        else if( isdigit(s[i]) ){\n//            string num;\n//            for(int j=i;j<len;j++){\n//                if(j>1000010)return part;\n//                if( isdigit(s[j]) )num+=s[j];\n//                else{\n//                    break;\n//                }\n//            }\n//            i+=num.size();\n//            \n//            if( s[i]!='(' ){\n//                part+=solve( stoi(num) , string( 1,s[i] ) );\n//            }else{\n//                i++;\n//                string repeat=\"\";\n//                int brackets=1;\n//                for(int j=i;j<len;j++){\n//                    if( s[j]==')' ){\n//                        repeat+=')';\n//                        brackets--;\n//                        \n//                    }else if( s[j]=='(' ){\n//                        brackets++;\n//                        repeat+='(';\n//                        \n//                    }else{\n//                        if(j==len-1)return \"invalid2\";\n//                        \n//                        repeat+=s[j];\n//                    }\n//                    if(brackets<=0)break;\n//                }\n//                \n//                repeat.erase(repeat.size()-1);\n//                i+=repeat.size();\n//                \n//                part+=solve( stoi(num) , repeat );\n//            }\n//            \n//            \n//        }else return \"invalid1\";\n//    }\n//    \n//    \n//    rep(i,times)ret+=part;\n//    \n////    cout<<ret<<endl;\n//    return ret;\n//}\n\n\nstring getDigit(int n,string s){\n    string ret=\"\";\n    \n    for(int i=n;i<s.size();i++){\n        if( isdigit(s[i]) )ret+=s[i];\n        else break;\n    }\n    return ret;\n}\n\n\nstring solve(int num,string s){\n//    cout<<s<<endl;\n    string part=\"\";\n    \n    int len=s.size();\n    rep(i,len){\n        if( isalpha(s[i]) )part+=s[i];\n        if(part.size()>1000100)return part;\n        \n        else if( isdigit(s[i]) ){\n            string deg=getDigit(i,s);\n            i+=deg.size();\n            \n            if(s[i]=='('){\n                int bra=1;\n                i++;\n                string repeat=\"\";\n                for(int j=i;j<len;j++){\n                    if( s[j]=='(' )bra++;\n                    if( s[j]==')' )bra--;\n                    \n                    if( bra==0 )break;\n                    else{\n                        repeat+=s[j];\n                        if(repeat.size()>1000100)break;\n                    }\n                }\n                part+=solve( stoi(deg) , repeat );\n                if(part.size()>1000100)return part;\n                i+=repeat.size();\n                \n            }else{\n                part+=solve( stoi(deg) , string(1,s[i]) );\n                \n            }\n        }\n    }\n    \n    if(part.size()>1000100)return part;\n    string ret=\"\";\n    int limit=1000100/part.size()+2;\n    num=min(num,limit);\n    for(int i=0;i<num;i++){\n        ret+=part;\n        \n    }\n    return ret;\n}\n\n\nint main(){\n    string s;\n    int n;\n    while(cin>>s>>n){\n        if(s==\"0\"&& n==0)break;\n        \n        string res = solve(1,s);\n        \n        if(res.size()<=n)cout<<\"0\"<<endl;\n        else cout<<res[n]<<endl;\n        \n//        cout<<res.size()<<endl;\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nint pos,n;\nstring s;\nstring f();\nstring expr(){\n\tstring a=f();\n\twhile(isdigit(s[pos])||isalpha(s[pos])){\n\t\tif(a.size()>n)\n\t\treturn a;\n\t\ta+=f();\n\t}\n\treturn a;\n}\nstring f(){\n\tstring t;\n\tif(isdigit(s[pos])){\n\t\tint ret=0;\n\t\tfor(;isdigit(s[pos]);pos++){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t}\n\t\tt=\"\";\n\t\tstring p=f();\n\t\tfor(int i=0;i<ret;i++){\n\t\t\tt+=p;\n\t\t\tif(t.size()>n)\n\t\t\t\treturn t;\n\t\t\n\t\t}\n\t}else if(s[pos]=='('){\n\t\tpos++;\n\t\tt=expr();\n\t\tpos++;\n\t}else{\n\t\tt=\"\";\n\t\tfor(;isalpha(s[pos]);pos++){\n\t\t\tt+=s[pos];\n\t\t\tif(t.size()>n)\n\t\t\t\treturn t;\n\t\t}\n\t}\n\treturn t;\n}\nint main(){\n\twhile(cin>>s>>n,s!=\"0\"||n){\n\t\tpos=0;\n\t\ts+=\"#\";\n\t\tstring t=expr();\n\t\tif(t.size()-1<n)\n\t\tcout<<0<<endl;\n\t\telse\n\t\tcout<<t[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nint cp=-1;\nint idx;\nchar result=0;\n\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(string str,int from,int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tint sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n\nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n\nvoid dfs(int dd,int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    while('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int ss=r.first,num=r.second;\n      int idx=r.first,z=r.first;\n      if(s[ss]=='('){\n\tint c=1;\n\tidx=ss+1;\n\tfor(z=idx;z<=e&&c;z++){\n\t  if(s[z]=='(')c++;\n\t  if(s[z]==')')c--;\n\t}\n\tp=z;\n\tz-=2;\n\tfor(int i=0;i<num;i++)dfs(dd+1,idx,z);\n      }else{\n\tfor(int i=0;i<num;i++)ans+=s[ss];\n\tp++;\n      }\n    }\n    while('A'<=s[p]&&s[p]<='Z')ans+=s[p],p++;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,0,s.size()-1);\n    if(ans.size()>=n+1)cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nint idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(string str,int from,int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nstring s;\nint p,n,c=0;\nstring bnf1();\nstring get(){\n  string res;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])||isalpha(s[p])){\n    while(isdigit(s[p])||isalpha(s[p])){\n      res+=s[p++];\n      if(res.size()>1000000)return res.substr(0,1000000);\n    }\n  }\n  return res;\n}\nstring bnf2(){\n  string res=get();\n  while(s[p]=='*'){\n    if(res.size()>1000000)return res.substr(0,1000000);\n    p++;\n    string res2=get();\n    int num=0;\n    r(i,res.size())num=num*10+(res[i]-'0');\n    res=res2;\n    r(i,num-1){\n      res+=res2;\n      if(res.size()>1000000)return res.substr(0,1000000);\n    }\n  }\n  return res;\n}\nstring bnf1(){\n  string res=bnf2();\n  while(s[p]=='+'){\n    if(res.size()>1000000)return res.substr(0,1000000);\n    p++;\n    string res2=bnf2();\n    res+=res2;\n    if(res.size()>1000000)return res.substr(0,1000000);\n  }\n  return res;\n}\nint main(){\n  while(cin>>s>>n,s!=\"0\"){\n    p=0;\n    r(i,(int)s.size()-1){\n      if(isdigit(s[i])&&s[i+1]=='('||isdigit(s[i])&&isalpha(s[i+1])){\n        s=s.substr(0,i+1)+\"*\"+s.substr(i+1);\n        i--;\n      }\n      else if(s[i]==')'&&isalpha(s[i+1])||s[i]==')'&&isdigit(s[i+1])){\n        s=s.substr(0,i+1)+\"+\"+s.substr(i+1);\n        i--;\n      }\n    }\n    string ans=bnf1();\n    if(n<ans.size())cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct expr\n{\n  typedef enum { NODE, LEAF } expr_type;\n  expr_type type;\n  int len;\n  vector<expr> cs;\n  string genom;\n};\n\ntypedef string::const_iterator Iterator;\npair<expr,Iterator> parse_one(Iterator it, const Iterator& last)\n{\n  if (it == last) {\n    throw \"eof\";\n  }\n  if ('A' <= *it &&  *it <= 'Z') {\n    string genom;\n    while (it != last && 'A' <= *it &&  *it <= 'Z') {\n      genom += *it;\n      ++it;\n    }\n    expr e;\n    e.type = expr::LEAF;\n    e.len = 1;\n    e.genom = genom;\n    return make_pair(e, it);\n  } else {\n    int len = 0;\n    while (it != last && '0' <= *it && *it <= '9') {\n      len = 10*len + (*it - '0');\n      ++it;\n    }\n    if (*it == '(') {\n      ++it;\n      expr e;\n      e.type = expr::NODE;\n      e.len = len;\n      while (*it != ')') {\n        pair<expr,Iterator> p = parse_one(it, last);\n        e.cs.push_back(p.first);\n        it = p.second;\n      }\n      ++it;\n      return make_pair(e, it);\n    } else {\n      expr e;\n      e.type = expr::LEAF;\n      e.len = len;\n      e.genom = *it;\n      ++it;\n      return make_pair(e, it);\n    }\n  }\n}\n\nexpr parse(Iterator it, const Iterator& last)\n{\n  expr e;\n  e.type = expr::NODE;\n  e.len = 1;\n  while (it != last) {\n    const pair<expr,Iterator> p = parse_one(it, last);\n    e.cs.push_back(p.first);\n    it = p.second;\n  }\n  return e;\n}\n\nstring expand(const expr& e, unsigned idx)\n{\n  if (e.type == expr::NODE) {\n    string t = \"\";\n    for (vector<expr>::const_iterator it(e.cs.begin()); it != e.cs.end(); ++it) {\n      t += expand(*it, idx);\n      if (t.size() > idx) {\n        return t.substr(0, idx+1);\n      }\n    }\n    string g = \"\";\n    for (int i = 0; i < e.len; i++) {\n      g += t;\n      if (g.size() > idx) {\n        return g.substr(0, idx+1);\n      }\n    }\n    return g.substr(0, idx+1);\n  } else {\n    string g = \"\";\n    for (int i = 0; i < e.len; i++) {\n      g += e.genom;\n    }\n    return g.substr(0, idx+1);\n  }\n}\n\nint main()\n{\n  string s;\n  unsigned idx;\n  while (cin >> s >> idx && s != \"0\") {\n    const expr e = parse(s.begin(), s.end());\n    const string t = expand(e, idx);\n    if (idx < t.size()) {\n      cout << t[idx] << endl;\n    } else {\n      cout << \"0\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n\nint n;\nconst char *p;\n\nstring parse(){\n\tstring s;\n\twhile(1){\n\t\tif(isalpha(*p)){\n\t\t\ts += *p++;\n\t\t}\n\t\telse if(isdigit(*p)){\n\t\t\tchar *endp;\n\t\t\tint k = strtol(p, &endp, 10);\n\t\t\tp = endp;\n\n\t\t\tstring t(1, 0);\n\t\t\tif(*p == '('){\n\t\t\t\t++p;\n\t\t\t\tt = parse();\n\t\t\t\t++p;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt[0] = *p++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < k && s.size() <= n; ++i){\n\t\t\t\ts += t;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(s.size() > n + 1){\n\t\t\ts.resize(n + 1);\n\t\t}\n\t}\n\treturn s;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> s >> n, s != \"0\"){\n\t\tp = s.c_str();\n\t\ts = parse();\n\t\tcout << (n < s.size() ? s[n] : '0') << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <vector>\n#include <ctype.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const long long BASE = 1000000;\nstatic const int  BW = 6;\nstatic const int MAXDIGIT = 20;\n\nstruct Long {\n  long long digit[MAXDIGIT];\n  int size;\n  Long(int size = 1, long long a = 0) : size(size) {\n    memset(digit, 0, sizeof(digit));\n    digit[0] = a;\n  }\n};\nconst Long ZERO(1, 0), ONE(1, 1);\n\n// Comparators\nbool operator<(const Long &x, const Long &y) {\n  if (x.size != y.size) { return x.size < y.size; }\n  for (int i = x.size - 1; i >= 0; --i) {\n    if (x.digit[i] != y.digit[i]) { return x.digit[i] < y.digit[i]; }\n  }\n  return false;\n}\nbool operator> (const Long &x, const Long &y) { return y < x; }\nbool operator<=(const Long &x, const Long &y) { return !(y < x); }\nbool operator>=(const Long &x, const Long &y) { return !(x < y); }\nbool operator!=(const Long &x, const Long &y) { return x < y || y < x; }\nbool operator==(const Long &x, const Long &y) { return !(x < y) && !(y < x); }\n\n// Input/Output\nostream &operator<<(ostream &os, const Long &x) {\n  os << x.digit[x.size - 1]; \n  for (int i = x.size - 2; i >= 0; i--) {\n    os << setw(BW) << setfill('0') << x.digit[i];\n  }\n  return os; \n}\nvoid print(const Long &x) {\n  printf(\"%lld\", x.digit[x.size - 1]);\n  for (int i = x.size - 2; i >= 0; --i) {\n    printf(\"%04lld\", x.digit[i]);\n  }\n}\n\n// Utilities\nLong normal(Long x) {\n  long long c = 0;\n  for (int i = 0; i < x.size; i++) {\n    while (x.digit[i] < 0) { x.digit[i + 1] -= 1; x.digit[i] += BASE; }\n    long long a = x.digit[i] + c;\n    x.digit[i] = a % BASE;\n    c = a / BASE;\n  }\n  for (; c > 0; c /= BASE) { x.digit[x.size++] = c % BASE; }\n  while (x.size > 1 && x.digit[x.size - 1] == 0) { --x.size; }\n  return x;\n}\n\nLong convert(long long a) {\n  return normal(Long(1, a));\n}\n\nLong convert(const string &s) {\n  Long x;\n  int i = s.size() % BW;\n  if (i > 0) i -= BW;\n  for (; i < (int)s.size(); i += BW) {\n    long long a = 0;\n    for (int j = 0; j < BW; j++) {\n      a = 10 * a + (i + j >= 0 ? s[i + j] - '0' : 0);\n    }\n    x.digit[x.size++] = a;\n  }\n  reverse(x.digit, x.digit + x.size);\n  return normal(x);\n}\n\n// Basic Operations\nLong operator+(Long x, const Long &y) {\n  if (x.size < y.size) { x.size = y.size; }\n  for (int i = 0; i < y.size; i++) { x.digit[i] += y.digit[i]; }\n  return normal(x);\n}\n\nLong operator-(Long x, const Long &y) {\n  assert(x >= y);\n  for (int i = 0; i < y.size; i++) { x.digit[i] -= y.digit[i]; }\n  return normal(x);\n}\n\nLong operator*(const Long &x, const Long &y) {\n  Long z(x.size + y.size);\n  for (int i = 0; i < x.size; i++) {\n    for (int j = 0; j < y.size; j++) {\n      z.digit[i+j] += x.digit[i] * y.digit[j];\n    }\n  }\n  return normal(z);\n}\n\nLong operator*(Long x, long long a) {\n  for (int i = 0; i < x.size; i++) { x.digit[i] *= a; }\n  return normal(x);\n}\n\npair<Long, long long> divmod(Long x, const long long &a) {\n  long long c = 0, t;\n  for (int i = x.size - 1; i>= 0; --i) {\n    t = BASE * c + x.digit[i];\n    x.digit[i] = t / a;\n    c = t % a;\n  }\n  return make_pair(normal(x), c);\n}\n\nLong operator/(const Long &x, const long long &a) {\n  return divmod(x, a).first;\n}\nlong long operator%(const Long &x, const long long &a) {\n  return divmod(x, a).second;\n}\n\npair<Long, Long> divmod(Long x, Long y) {\n  if (x.size < y.size) { return pair<Long, Long>(ZERO, x); }\n  int F = BASE / (y.digit[y.size - 1] + 1);  // multiplying good-factor\n  x = x * F; y = y * F;\n  Long z(x.size - y.size + 1);\n  for (int k = z.size - 1, i = x.size - 1; k >= 0; k--, i--) {\n    z.digit[k] = (i + 1 < x.size ? x.digit[i + 1] : 0) * BASE + x.digit[i];\n    z.digit[k] /= y.digit[y.size - 1];\n    Long t(k + y.size);\n    for (int m = 0; m < y.size; m++) {\n      t.digit[k + m] = z.digit[k] * y.digit[m];\n    }\n    t = normal(t);\n    while (x < t) {\n      z.digit[k] -= 1;\n      for (int m = 0; m < y.size; m++) {\n        t.digit[k + m] -= y.digit[m];\n      }\n      t = normal(t);\n    }\n    x = x - t;\n  }\n  return make_pair(normal(z), x / F);\n}\nLong operator/(Long x, Long y) {\n  return divmod(x, y).first;\n}\nLong operator%(Long x, Long y) {\n  return divmod(x, y).second;\n}\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Node {\n  Long length;\n  Long size;\n  ll loop;\n  char c;\n  vector<Node> child;\n  Node() : loop(1), c(0) {;}\n};\n\nchar str[1000];\n\nNode parse(ll &index, ll loop) {\n  Node ret;\n  if (isalpha(str[index])) {\n    ret.length = convert(1);\n    ret.c = str[index];\n    index++;\n  } else if (isdigit(str[index])) {\n    ll nloop = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n    if (isalpha(str[index])) {\n      ret.child.push_back(parse(index, nloop));\n      ret.length = ret.length + ret.child[ret.child.size() - 1].size;\n    } else {\n      assert(str[index] == '(');\n      index++;\n      while (str[index] != ')') {\n        ret.child.push_back(parse(index, nloop));\n        ret.length = ret.length + ret.child[ret.child.size() - 1].size;\n      }\n      assert(str[index] == ')');\n      index++;\n    }\n  }\n  ret.size = ret.length * loop;\n  ret.loop = loop;\n  return ret;\n}\n\nchar nodechar(const Node &node, Long &n) {\n  if (node.size <= n) { return '0'; }\n  n = n % node.length;\n  if (n == convert(0) && node.c != 0) { return node.c; }\n  REP(i, node.child.size()) {\n    const Node &target = node.child[i];\n    if (target.size > n) {\n      return nodechar(target, n);\n    }\n    n = n - target.size;\n  }\n  assert(false);\n  return 0;\n}\n\nint main() {\n  ll n;\n  while (scanf(\"%s %lld\", str, &n), str[0] != '0' || n) {\n    ll index = 0;\n    Node root;\n    while (str[index] != '\\0') {\n      root.child.push_back(parse(index, 1));\n      root.size = root.size + root.child[root.child.size() - 1].size;\n      root.length = root.length + root.child[root.child.size() - 1].size;\n    }\n    Long longn = convert(n);\n    printf(\"%c\\n\", nodechar(root, longn));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool flag;\nlong long solve(const string s,long long I)\n{\n\t//cout<<s<<\" \"<<I<<endl;\n\tlong long cnt=0;\n\tfor(int f=0;!flag&&f<s.size();f++)\n\t{\n\t\tif(s[f]>='A'&&s[f]<='Z')\n\t\t{\n\t\t\twhile(!flag&&f<s.size()&&s[f]>='A'&&s[f]<='Z')\n\t\t\t{\n\t\t\t\tf++,cnt++;\n\t\t\t\tif(I==cnt)\n\t\t\t\t{\n\t\t\t\t\tcout<<s[f-1]<<endl;\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf--;\n\t\t}\n\t\telse if(s[f]>='0'&&s[f]<='9')\n\t\t{\n\t\t\tlong long now=0;\n\t\t\twhile(s[f]>='0'&&s[f]<='9')now=now*10+s[f]-'0',f++;\n\t\t\tif(s[f]>='A'&&s[f]<='Z')\n\t\t\t{\n\t\t\t\tcnt+=now;\n\t\t\t\tif(I<=cnt&&!flag)\n\t\t\t\t{\n\t\t\t\t\tcout<<s[f]<<endl;\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint l=f+1;\n\t\t\t\tint d=1;\n\t\t\t\twhile(d)\n\t\t\t\t{\n\t\t\t\t\tif(s[l]=='(')d++;\n\t\t\t\t\telse if(s[l]==')')d--;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t\tl--;\n\t\t\t\tlong long A=solve(s.substr(f+1,l-f-1),I);//(I-cnt+now-1)%now+1);\n\t\t\t\tif(I<=cnt+A*now&&!flag)\n\t\t\t\t{\n\t\t\t\t\tsolve(s.substr(f+1,l-f-1),(I-cnt+A-1)%A+1);\n\t\t\t\t}\n\t\t\t\tcnt+=A*now;\n\t\t\t\tf=l;\n\t\t\t}\n\t\t}\n\t}\t\n\treturn cnt;\n}\nmain()\n{\n\tstring s;long long I;\n\twhile(cin>>s>>I,s!=\"0\")\n\t{\n\t\tflag=false;\n\t\tsolve(s,I+1);\n\t\tif(!flag)cout<<0<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1145&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint getnum(int&pos, const string& str) {\n\tint ret = 0;\n\twhile (true) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\tret = ret * 10 + (str[pos] - '0');\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstring gennom(int&pos, int& len, const string& str, const int& n) {\n\tint roop = getnum(pos, str);\n\tif (str[pos] == '(') pos++;\n\telse {\n\t\tstring ret;\n\t\tchar c = str[pos++];\n\t\tfor (int i = 0; i < roop;i++) {\n\t\t\tret += c;\n\t\t\tif (ret.length() > n)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tstring s;\n\tstring ret;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\ts += gennom(pos,len, str, n);\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\ts += str[pos++];\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] == ')') {\n\t\t\tpos++; break;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < roop; i++) {\n\t\tret += s; len += ret.length();\n\t\tif (ret.length() > n)break;\n\t}\n\treturn ret;\n}\n\nstring solve(const string& str,int& n) {\n\tstring ret;\n\tint pos = 0;\n\tint len = 0;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\tret += str[pos++]; len++;\n\t\t}\n\t\telse {\n\t\t\tret += gennom(pos, len, str, n);\n\t\t}\n\t\tif (len > n)return ret;\n\t}\n\treturn ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring str; int n;\n\twhile (cin >> str >> n) {\n\t\tif (str == \"0\" && n == 0) break;\n\t\tstring ans = solve(str, n);\n\t\tif (ans.length() > n) {\n\t\t\tcout << ans[n] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n#include<assert.h>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tStage(){\n\t\tcin >> s >> id;\n\t}\n\t\n\tbool is_end(){\n\t\treturn s == \"0\";\n\t}\n\t\n\tvoid action(){\n\t\tstack<Gram> st;\n\t\tauto grams = trans_gram();\n\t\tfor (auto gram : grams)\n\t\t{\n\t\t\t//解凍\n\t\t\tif (gram.kind == 'p' && gram.par == ')')\n\t\t\t{\n\t\t\t\tauto alpha = st.top(); st.pop();\n\t\t\t\tauto parL = st.top(); st.pop();\n\t\t\t\tauto roop = st.top(); st.pop();\n\t\t\t\tgram = roop_modify(roop, alpha);\n\t\t\t}\n\n\n\t\t\t//結合\n\t\tstart:;\n\t\t\tif(!st.empty() && gram.kind=='a')\n\t\t\t{\n\t\t\t\tif (st.top().kind == 'a') {\n\t\t\t\t\tauto alL = st.top(); st.pop();\n\t\t\t\t\tgram = append(alL, gram);\n\t\t\t\t\tgoto start;\n\t\t\t\t}\n\t\t\t\telse if (st.top().kind == 'n') {\n\t\t\t\t\tauto roop = st.top(); st.pop();\n\t\t\t\t\tgram = roop_modify(roop, gram);\n\t\t\t\t\tgoto start;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(gram);\n\t\t}\n\t\tif (id >= st.top().s.size()) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << st.top().s[id] << endl;\n\t\t}\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tint num;\n\t\tstring s;\n\t\tchar par;\n\t};\n\n\tint id;\n\tstring s;\n\t\n\tvector<Gram> trans_gram()const\n\t{\n\t\tvector<Gram> grams;\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tGram gram;\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.par = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.par = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (is_num(s[i])) {\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnum *= 10;\n\t\t\t\t\t\tnum += s[i] - '0';\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} while (is_num(s[i]));\n\t\t\t\t\ti--;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = num;\n\t\t\t\t}\n\t\t\t\telse if (is_alpha(s[i])) {\n\t\t\t\t\tstring tmp{ s[i] };\n\t\t\t\t\twhile (i < s.size() - 1 && is_alpha(s[i + 1])) {\n\t\t\t\t\t\ttmp += {s[i + 1]};\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tgram.kind = 'a';\n\t\t\t\t\tgram.s = tmp;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tbool is_num(const char& c) const{\n\t\treturn '0' <= c && c <= '9';\n\t}\n\tbool is_alpha(const char& c)const {\n\t\treturn 'A' <= c && c <= 'Z';\n\t}\n\tGram roop_modify(const Gram& roop, const Gram& alpha)const\n\t{\n\t\tassert(roop.kind == 'n');\n\t\tassert(alpha.kind == 'a');\n\n\t\tGram gram;\n\t\tgram.kind = 'a';\n\t\tREP(i, roop.num)\n\t\t{\n\t\t\tgram.s += alpha.s;\n\t\t\tif (gram.s.size() >= id)break;\n\t\t}\n\t\treturn gram;\n\t}\n\tGram append(Gram l, const Gram& r)const \n\t{\n\t\tassert(l.kind == 'a');\n\t\tassert(r.kind == 'a');\n\t\tl.s += r.s;\n\t\treturn l;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile(true){\n\t\tStage stage;\n\t\tif(stage.is_end())break;\n\t\tstage.action();\n\t}\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_LEN = 1100010;\nconst int MAX_N_LEN = 500;\n\nchar ans;\nbool end_flg = false;\nint I;\nchar N[MAX_N_LEN];\n\npair<string, char *> getStr(char *p){\n  stringstream ss;\n  while(isalpha(*p)){\n    ss << (*p);\n    ++p;\n  }\n  return pair<string, char *>(ss.str(), p);\n}\n\npair<int, char *> getInt(char *p){\n  int ret = 0;\n  while(isdigit((*p))){\n      ret *= 10;\n      ret += ((*p) - '0');\n      ++p;\n  }\n  return pair<int, char *>(ret, p);\n}\n\npair<string, char *> check(char *p){\n  if(end_flg) return pair<string, char *>(\"\", p);\n  pair<int, char *> tmpi = getInt(p);\n  int num = tmpi.first;\n  p = tmpi.second;\n  string str = \"\";\n  while(isdigit(*(p + 1))){\n    pair<string, char *> tmpc = check(p + 1);\n    if(end_flg) return pair<string, char *>(\"\", p);\n    str += tmpc.first;\n    p = tmpc.second;\n  }\n  pair<string, char *> tmps = getStr(p + 1);\n  str += tmps.first;\n  p = tmps.second;\n  string ret = \"\";\n  if(str.length() * num - 1 >= I){\n    ans = str[I % str.length()];\n    end_flg = true;\n  } else if(str.length() * num <= MAX_LEN){\n    stringstream ss;\n    REP(i, num) ss << str;\n    ret = ss.str();\n  }\n  return pair<string, char *>(ret, p);\n}\n\nint main() {\n  string tmp_s;\n  while(cin >>tmp_s >>I && tmp_s != \"0\"){\n    stringstream ss;\n    ss <<\"1(\";\n    REP(i, tmp_s.length()){\n      if(i + 1 < tmp_s.length() && isdigit(tmp_s[i]) && isalpha(tmp_s[i + 1])){\n        ss <<tmp_s[i] <<\"(\" <<tmp_s[i + 1] <<\")\";\n        ++i;\n      } else\n        ss <<tmp_s[i];\n    }\n    ss <<\")\";\n    //cout <<\"------------\" <<endl <<ss.str() <<\", \" <<I <<endl;\n    char *tmp_c = new char[ss.str().length() + 1];\n    strcpy(tmp_c, ss.str().c_str());\n    strcpy(N, tmp_c);\n    end_flg = false;\n    pair<string, char *> s = check(N);\n    if(end_flg) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring str;\nint pos;\nint loc;\nll now;\n\nint number() {\n\tint res = 0;\n\twhile ( pos < str.size() && isdigit(str[pos]) ) {\n\t\tres = res * 10 + (int)(str[pos] - '0');\n\t\t++pos;\n\t}\n\treturn res;\n}\nstring alp() {\n\tstring res = \"\";\n\twhile ( pos < str.size() && 'A' <= str[pos] && str[pos] <= 'Z' ) {\n\t\tres += str[pos];\n\t\t++pos;\n\t}\n\treturn res;\n}\nstring expr2() {\n\tstring res = \"\";\n\twhile (pos < str.size() && str[pos] != ')') {\n\t\tint n = 1;\n\t\tif (isdigit(str[pos])) {\n\t\t\tn = number();\n\t\t}\n\n\t\tstring a;\n\t\tif (str[pos] == '(') {\n\t\t\t++pos;\n\t\t\ta = expr2();\n\t\t\t++pos;\n\t\t}\n\t\telse {\n\t\t\ta = alp();\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tres += a;\n\t\t}\n\t}\n\treturn res;\n}\nll expr() {\n\tll res = 0;\n\twhile (pos < str.size() && str[pos] != ')') {\n\t\tint n = 1;\n\t\tif (isdigit(str[pos])) {\n\t\t\tn = number();\n\t\t}\n\n\t\tint op = pos;\n\n\t\tll l;\n\t\tif (str[pos] == '(') {\n\t\t\t++pos;\n\t\t\tl = expr();\n\t\t\t++pos;\n\t\t\tnow -= l;\n\t\t}\n\t\telse {\n\t\t\tl = alp().size();\n\t\t}\n\n\t\tif (now <= loc && loc < now+l*n) {\n\t\t\tpos = op;\n\t\t\tstring s;\n\t\t\tif (str[pos] == '(') {\n\t\t\t\t++pos;\n\t\t\t\ts = expr2();\n\t\t\t\t++pos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = alp();\n\t\t\t}\n\t\t\tthrow s[(loc-now)%l];\n\t\t}\n\n\t\tnow += l * n;\n\t\tres += l * n;\n\t\tif (now > loc+1) now = loc+1;\n\t\tif (res > loc+1) res = loc+1;\n\t}\n\n\treturn res;\n}\n\n\nchar parse() {\n\tpos = 0;\n\n\ttry {\n\t\tnow = 0;\n\t\tpos = 0;\n\t\texpr();\n\t}\n\tcatch (char c) {\n\t\treturn c;\n\t}\n\treturn '0';\n}\n\nint main() {\n\twhile (cin >> str >> loc, str != \"0\" || loc != 0) {\n\t\tcout << parse() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n#include <ctime>\n#include <list>\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\nconst ll INF = 1e7;\n\nstruct Tree{\n\tll repeat, period;\n\tchar c;\n\tvector<Tree> ch;\n\n\tTree(string s, int _repeat) : repeat(_repeat){\n\t\tif (s.size() == 1){\n\t\t\tperiod = 1;\n\t\t\tc = s[0];\n\t\t\treturn;\n\t\t}\n\n\t\tint nest = 0, cnt = 0, l;\n\t\trep(i, s.size()){\n\t\t\tchar c = s[i];\n\t\t\tif (isalpha(c)){\n\t\t\t\tif (!nest){\n\t\t\t\t\tch.push_back(Tree(s.substr(i, 1), max(1, cnt)));\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == '('){\n\t\t\t\tif (!nest++){\n\t\t\t\t\tl = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == ')'){\n\t\t\t\tif (!--nest){\n\t\t\t\t\tch.push_back(Tree(s.substr(l, i-l), cnt));\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(!nest) cnt = cnt * 10 + c - '0';\n\t\t}\n\n\t\tperiod = 0;\n\t\tfor (auto &t : ch){\n\t\t\tperiod += t.period*t.repeat;\n\t\t\tperiod = min(period, INF);\n\t\t}\n\t\t//cout << s << ' ' << period << endl;\n\t}\n\n\tchar get(int x){\n\t\tif (ch.empty() && !x) return c;\n\t\tfor (auto &t : ch){\n\t\t\tif (x < t.period*t.repeat) return t.get(x%t.period);\n\t\t\tx -= t.period*t.repeat;\n\t\t}\n\t\treturn '0';\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\n\n\n\tstring s;\n\tint x;\n\twhile (cin >> s >> x, s != \"0\"){\n\t\tTree t(s, 1);\n\t\tcout << t.get(x) << '\\n';\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    if (isdigit(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int,char> P;\nbool isNum(char ch){return ('0'<=ch&&ch<='9');}\nbool isAl(char ch){return ('A'<=ch&&ch<='Z');}\nstring s,t;\nint n,p,len;\n\nvoid solve(){\n  while(1){\n    if(p>=len||s[p]==')')break;\n    int a=0;\n    while(isNum(s[p]))a=a*10+s[p]-'0',p++;\n    //cout<<a<<endl;\n    a=max(a,1);\n    if(s[p]=='('){\n      int l=t.size();\n      p++;solve();p++;\n      int r=t.size();\n      for(int i=0;i+1<a&&(int)t.size()<=n;i++)\n\tfor(int j=l;j<r&&(int)t.size()<=n;j++)\n\t  t.push_back(t[j]);\n    }else{\n      string tmp=\"\";\n      while(isAl(s[p]))tmp.push_back(s[p]),p++;\n      for(int i=0;i<a&&(int)t.size()<=n;i++)\n\tt+=tmp;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&n==0)break;\n    len=s.size();\n    p=0;\n    t=\"\";\n    solve();\n    if(n<(int)t.size())cout<<t[n]<<endl;\n    else cout<<'0'<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstring s;\nint x;\n\nint ct;\nchar c;\n\nint idx;\n\nstring now;\n\nvoid num();\nvoid read();\n\nvoid num(){\n    int n = 0;\n    while(idx<s.size() && isdigit(s[idx])){\n        n = n*10 + s[idx]-'0';\n        ++idx;\n    }\n\n    if(s[idx]=='(') ++idx;\n    int start = idx;\n\n    rep(i,n){\n        idx = start;\n        read();\n        if(c != '0') return;\n    }\n    if(s[idx]==')') ++idx;\n\n}\n\nvoid read(){\n    if(c != '0') return;\n    if(idx >= s.size()) return;\n\n    if(isdigit(s[idx])) num();\n    if(isupper(s[idx])){\n        if(ct == x){\n            c = s[idx];\n            return;\n        }\n\n        // dbg(ct);\n        ++ct;\n        ++idx;\n    }\n    if(s[idx]==')') return;\n\n    read();\n}\n\nint main(){\n    while(cin >>s >>x,(s!=\"0\")){\n        c = '0';\n        idx = 0;\n        ct = 0;\n\n        now = \"\";\n\n        read();\n        cout << c << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nll a,t;\nchar out;\nstring f(int a){\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(out!='0')return \"\";\n\t\tif(isalpha(s[t])){\n\t\t\tw+=s[t];\n\t\t\tt++;\n\t\t\tif(a<w.size()){\n\t\t\t\tout=w[a];return \"\";\n\t\t\t}\n\t\t}else if(s[t]==')'){\n\t\t\treturn w;\n\t\t}else{\n\t\t\tint co=0;\n\t\t\twhile(isdigit(s[t])){\n\t\t\t\tco*=10;\n\t\t\t\tco+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tstring tmp;\n\t\t\tif(isalpha(s[t])){\n\t\t\t\ttmp=s[t];\n\t\t\t}else{\n\t\t\t\tt++;\n\t\t\t\ttmp=f(a);\n\t\t\t}\n\t\t\trep(i,co)w+=tmp;\n\t\t\tt++;\n\t\t\tif(a<w.size()){\n\t\t\t\tout=w[a];\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\twhile(cin>>s>>a,s!=\"0\"){\n\t\tout='0';\n\t\tt=0;\n\t\tf(a);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nchar input[1111];\nint ans;\nint value=0;\ntypedef pair<int,const char*> Parsed;\nParsed term(const char *c);\nParsed fact(const char *c);\nParsed expr(const char *c);\nParsed term(const char *c){\n\tParsed r=fact(c);\n\twhile(*r.second!=')'&&*r.second!=0){\n\t\tif(r.first)return r;\n\t\tr=fact(r.second);\n\t}\n\treturn r;\n}\nParsed fact(const char *c){\n\tif(isdigit(*c)){\n\t\tint v=0;\n\t\twhile(isdigit(*c)){\n\t\t\tv=v*10+*(c++)-'0';\n\t\t}\n\t\tParsed r;\n\t\tfor(int i=0;i<v;i++){\n\t\t\tr=expr(c);\n\t\t\tif(r.first)return r;\n\t\t}\n\t\treturn r;\n\t}else{\n\t\treturn expr(c);\n\t}\n}\nParsed expr(const char *c){\n\tif(*c=='('){\n\t\tParsed r=term(c+1);\n\t\tif(*r.second!=')'){\n\t\t\t//cerr<<\"Error!!\"<<endl;\n\t\t\tfor(;;);\n\t\t}\n\t\treturn Parsed(r.first,r.second+1);\n\t}else{\n\t\tint res=0;\n\t\tvalue--;\n\t\tif(value<0){\n\t\t\tres=*c;\n\t\t}\n\t\treturn Parsed(res,c+1);\n\t}\n}\nint main() {\n\twhile(scanf(\"%s%d\",input,&value)){\n\t\tif(input[0]=='0')break;\n\t\tParsed a=term(input);\n\t\tif((int)a.first){\n\t\t\tprintf(\"%c\\n\",(char)a.first);\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nconst int MAX_STRING = 1000000+1;\n\nstring s;\n\nstring p_expr(int &p);\n\nint p_number(int &p)\n{\n  int res = 0;\n  while (isdigit(s[p])) {\n    res *= 10;\n    res += s[p++] - '0';\n  }\n  return res;\n}\n\nstring p_character(int &p)\n{\n  string res = \"\";\n  while (isalpha(s[p]))\n    res += s[p++];\n  return res;\n}\n\nstring p_term(int &p)\n{\n  if (isalpha(s[p])) {\n    return p_character(p);\n  } else {\n    int num = p_number(p);\n    string t = \"\";\n    if (s[p] == '(') {\n      ++p;\n      t = p_expr(p);\n      ++p;\n    } else {\n      t = p_character(p);\n    }\n    string res = \"\";\n    for (int i = 0; i < num && res.size() < MAX_STRING; ++i)\n      res += t;\n    return res;\n  }\n}\n\nstring p_expr(int &p)\n{\n  string res = p_term(p);\n  while (p < s.size() && s[p] != ')')\n    res += p_term(p);\n  return res;\n}\n\nint main()\n{\n  int i;\n  while (cin >> s >> i) {\n    if (s == \"0\" && i == 0)\n      break;\n\n    int p = 0;\n    string ans = p_expr(p);\n    if (i < ans.size())\n      cout << ans[i] << endl;\n    else\n      cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n//I referred to other's code.\nconst int MAX_L = 10000001;\nstring s;\nint needidx;\nstring expr(int& p);\nint num(int& p){\n  int res = 0;\n  while(isdigit(s[p])){\n    res = res * 10 + (s[p++] - '0');\n  }\n  return res;\n}\nstring chara(int& p){\n  string res = \"\";\n  while(isalpha(s[p])){\n    res += s[p++];\n  }\n  return res;\n}\nstring term(int& p){\n  string res;\n  if(isalpha(s[p])){\n    res =  chara(p);\n  }else{\n    int n = num(p);\n    string t;\n    if(s[p]=='('){\n      p++;\n      t = expr(p);\n      p++;\n    }else{\n      t = chara(p);\n    }\n    REP(i,n){\n      if(res.size() > needidx) break;\n      res += t;\n    }\n  }\n  return res;\n}\nstring expr(int& p){\n  string res = term(p);\n  while(p < s.size() && s[p] != ')' && res.size() < needidx){\n    res += term(p);\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>s>>needidx, s!=\"0\"){\n    int p = 0;\n    string ans = expr(p);\n    if(ans.size() > needidx){\n      cout<<ans[needidx]<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse {\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t      pls+=s[c][idx];\n\t    }\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&(int)s[!c].size()<n+500;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n\n    if((int)s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long id, nowend = 0;\nstring s;\nchar ans;\n\nlong long solve(long long now, long long req);\nvoid solve2();\n\nint main() {\n  while(1) {\n    cin >> s >> id;\n    if(s == \"0\" && id == 0) break;\n    ans = '0';\n    solve2();\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nlong long solve(long long now, long long req) {\n  long long cnt = 0, charcnt = 1;\n  string nows;\n  if(s[now] >= '0' && s[now] <= '9') {\n    while(s[now] >= '0' && s[now] <= '9') {\n      cnt *= 10;\n      cnt += s[now++] - '0';\n    }\n    charcnt = solve(now, inf);\n    cnt *= charcnt;\n    if(cnt > req) {\n      if(solve(now, req % charcnt) != -1) assert(0);\n      return -1;\n    }\n  }\n  else if(s[now] == '(') {\n    nowend = now + 1;\n    while(nowend < s.size() && s[nowend] != ')') {\n      charcnt = solve(nowend, req - cnt);\n      if(charcnt == -1) return -1;\n      cnt += charcnt;\n    }\n    ++nowend;\n  }\n  else {\n    while(now < s.size() && s[now] >= 'A' && s[now] <= 'Z')\n      nows += s[now++];\n    if(req < nows.size()) {\n      ans = nows[req];\n      return -1;\n    }\n    nowend = now;\n    cnt = nows.size();\n  }\n  return cnt;\n}\n\nvoid solve2() {\n  nowend = 0;\n  while(nowend < s.size()) {\n    long long x = solve(nowend, id);\n    if(x < 0) return;\n    id -= x;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n#include <vector>\n#include <map>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n\nstring Str;\nint Index;\n\nclass Node {\npublic:\n  int num;\n  string s;\n  vector<Node> v;\n  Node() { num = -1; }\n};\n\nNode root;\n\nint getNum(int &pos, string s) {\n  int st = pos;\n  int length = 0;\n  while(isdigit(s[pos])) { ++length; ++pos; }\n  //cout << s << \" => \" << s.substr(st, length) << endl;\n  return atoi(s.substr(st, length).c_str());\n}\n\nchar rec(int &i, int j, Node node) {\n  //cout << node.s << \" :: \" << node.num << endl;\n  if(node.s.size()) {\n    for(int l = 0; l < node.num; ++l) {\n      for(int k = 0; k < node.s.size(); ++k) {\n\t//cout << node.s[k];\n\tif(i == j) return node.s[k];\n\t++i;\n      }\n    }\n    return '0';\n  }\n\n  for(int k = 0; k < node.num; ++k) {\n    for(int l = 0; l < node.v.size(); ++l) {\n      char c = rec(i, j, node.v[l]);\n      if(c != '0') return c;\n    }\n  }\n  return '0';\n}\n\nvector<string> sep(string s)\n{\n  string t;\n  vector<string> v, u;\n  t += s[0];\n\n  for(int i=1; i<s.size(); ++i){\n    if( s[i-1] == ')' && isalpha(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( s[i-1] == ')' && isdigit(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( isdigit(s[i]) && isalpha(s[i-1])){\n      v.push_back(t);\n      t = \"\";\n    }\n    t += s[i];\n  }\n  if(t.size()) {\n    v.push_back(t);\n  }\n\n  int o, c;\n  o = c = 0;\n  t = \"\";\n  for(int i = 0; i < v.size(); ++i) {\n    if(o + c && o == c) {\n      u.push_back(t);\n      o = c = 0;\n      t = \"\";\n    }\n    t += v[i];\n    o += count(v[i].begin(), v[i].end(), '(');\n    c += count(v[i].begin(), v[i].end(), ')');\n  }\n  if(t.size()) u.push_back(t);\n  return u;\n  for(int i=0; i<u.size(); ++i){\n    cout << u[i] << \"_\";\n  }\n  cout << endl;\n  return u;\n}\n\nvoid conv(string &s) {\n  for(int i = 1; i < s.length(); ++i) {\n    if(s[i-1] == ')' && isalpha(s[i]) &&(i+1 >= s.length() || !isalpha(s[i+1]))) {\n      s.insert(i, \"1(\");\n      s.insert(i+3, \")\");\n    }\n    if(isdigit(s[i-1]) && isalpha(s[i]) && (i+1 >= s.length() || !isalpha(s[i+1]))) {\n      s.insert(i, \"(\");\n      s.insert(i+2, \")\");\n    }\n  }\n  //  cout << s << endl;\n}\n\nNode build(string s) {\n  //cout << s << endl;\n  Node node;\n  int num;\n  if(isalpha(s[0])) {\n    node.num = 1;\n    node.s = \"\" + s;\n    return node;\n  } else {\n    int pos = 0;\n    num = getNum(pos, s);\n    if(s[pos] != '(') {\n      node.num = num;\n      node.s = \"\";//(pos < s.size()) ? \"####\" : \"@@@\";\n      node.s += s[pos];\n      return node;\n    }\n    ++pos;\n    s.erase(s.begin(), s.begin()+pos);\n    s.erase(s.begin() + s.size() - 1);\n    if(count(s.begin(), s.end(), '(') == 0) {\n      node.num = num;\n      node.s = s;\n      return node;\n    }\n    int o, c;\n    string t = \"\";\n    o = c = 0;\n    vector<string> v = sep(s);\n    for(int i=0; i<v.size(); ++i){\n      node.v.push_back( build(v[i]) );\n    }\n  }  \n  node.num = num;\n  return node;\n  cout << node.s << endl;\n  for(int i = 0; i < node.v.size(); ++i) {\n    cout << node.v[i].s << \" \";\n  }\n  cout << endl << endl;\n  return node;\n}\n\nvoid solve() {\n  Str.insert(0, \"1(\");\n  Str.insert(Str.size(), \")\");\n  conv(Str);\n  //cout << Str << endl;\n  root = build(Str);\n  int i = 0;\n  char c  = rec(i, Index, root);\n  cout << c << endl;\n}\n\nmain() {\n  while(cin >> Str >> Index) {\n    if(Str == \"0\" && Index == 0) break;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll id;\nint N;\nstring s;\n\nint c;\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nvoid f(ll v){\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t\tf(min(v * n, id * 2));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(min(v * n, id * 2));\n\t\t\t}\n\t\t\tif(s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tassert('A' <= s[c] && s[c] <= 'Z');\n\tstring ss = readS();\n\tif(ans == 0) {\n\t\tif(ss.size() * v <= id) {\n\t\t\tid -= ss.size() * v;\n\t\t\treturn;\n\t\t}\n\n\t\twhile(id >= ss.size()) id -= ss.size();\n\t\tans = ss[id];\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0) f(1);\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nstring s;\nint index;\n\nint cur;\nbool end;\n\nstring rec()\n{\n    string res;\n\n    while(cur < s.size() && !end) {\n        while('A' <= s[cur] && s[cur] <= 'Z') {\n            res += s[cur];\n            cur++;\n        }\n\n        if('0' <= s[cur] && s[cur] <= '9') {\n            int n = s[cur++] - '0';\n            while('0' <= s[cur] && s[cur] <= '9') {\n                n = 10 * n + s[cur++] - '0';\n            }\n\n            string pattern;\n            if(s[cur] == '(') {\n                cur++;\n                pattern = rec();\n            } else {\n                pattern = s[cur++];\n            }\n\n            if(pattern.size() > index) {\n                res += pattern;\n                end = true;\n                break;\n            }\n\n            for(int i = 0; i < n; ++i) {\n                res += pattern;\n            }\n        }\n\n        if(s[cur] == ')') {\n            cur++;\n            return res;\n        }\n    }\n\n    return res;\n}\n\n\nint main()\n{\n    while(true){\n        cin >> s >> index;\n        if(s == \"0\" && index == 0) break;\n\n        cur = 0;\n        end = false;\n        string res = rec();\n        //cout << res << endl;\n        if(res.size() <= index) {\n            cout << 0 << endl;\n        } else {\n            cout << res[index] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <stack>\n#define DEBUG false\nusing namespace std;\n\nstruct P {\n  unsigned int i; // JèÔµêÌæªÌindex\n  int n;          // JèÔµñ\n};\n\nbool isDigit( char c ){\n  if( '0'<= c && c <= '9' ) return true;\n  return false;\n}\n\n/* ið®©µÄ¢«A¶ð©½ñ¾¯nð¸ç· */\nchar parse( string s, unsigned int n ){\n  const char *c = s.c_str();\n  unsigned int i=0;\n  stack<P> st;   // '('ÌÊuðL^\n  P p;\n  if( DEBUG ) cout << \"parse : \" << s << \" len=\" << s.length() << endl;\n\n  while( i<s.length() ){\n    if( false && DEBUG ) cout << \"while : i=\"<<i<<\" n=\"<<n<< \" s[i]=\"<<s[i] \n\t\t     << \" stack:\"<< st.size() << \" p.n=\" << p.n << endl;\n    if( isDigit( s[i] ) ){\n      unsigned int num = atoi( c+i );\n      if(  DEBUG ) cout << \"num=\" << num << endl;\n      while( isDigit( s[i] ) ) ++i;\n      if( s[i]=='(' ){\n\ti++;  // '(' ÌªðCNg·é\n\tp.i=i; p.n=num;\n\tst.push( p ); // JèÔµÌÅÌ¶ðÇÁ\n      }else {\n\t--num;\n\t//\tcout << \"n=\"<<n<<\" num=\"<<num<<endl;\n\tif( n<num ) return s[i];\n\telse n-=num;\n      }\n    }else if( s[i]==')' ){\n      p = st.top(); st.pop();\n      if( --p.n != 0 ){  st.push( p ); i=p.i; }\n      else ++i;\n    }else {\n      if( n==0 )\n\treturn s[i];\n      --n;\n      ++i;\n    }\n  }\n  return '0';\n}\n\nint main(){\n  string s;\n  unsigned int n;\n  while( cin>>s>>n && (s!=\"0\"|| n ) ){\n    if( DEBUG ){\n      cout << \"\\nn=\" << n << \" in : \" << s << endl;\n    }\n   \n    if( DEBUG )\n      cout << \"answer=\";\n    cout << parse( s,n ) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n\nll n, m, en[100];\nchar s[101], ans;\nconst ll mx = 1000010;\n\nll getNum(ll b, ll e) {\n  // [b, e]\n  ll temp = 0, counter = 0;\n  for (ll i = b; i <= e; i++) {\n    if ('0' <= s[i] && s[i] <= '9') {\n      temp = temp * 10 + s[i] - '0';\n    } else if (s[i] == '(') {\n      counter += (temp == 0 ? 1 : temp) * getNum(i+1, en[i] - 1);\n      temp = 0;\n      i = en[i];\n    } else {\n      counter += temp == 0 ? 1 : temp;\n      temp = 0;\n    }\n    if (counter > mx) return mx;\n  }\n  return counter;\n}\n\nchar check(ll num, ll rest) {\n  ll temp = 0;\n  for (ll i = num; i < n; i++) {\n    if ('0' <= s[i] && s[i] <= '9') {\n      temp = temp * 10 + s[i] - '0';\n    } else if (s[i] == '(') {\n      if (temp == 0) temp = 1;\n      ll gn = getNum(i+1, en[i] - 1);\n      ll add = temp * gn;\n      if (add > rest) {\n        return check(i+1, rest % gn);\n      }\n      rest -= add;\n      temp = 0;\n      i = en[i];\n    } else {\n      rest -= temp == 0 ? 1 : temp;\n      if (rest < 0) return s[i];\n      temp = 0;\n    }\n  }\n}\n\nint main() {\n  while (scanf(\"%s%lld\", s, &m), s[0] != '0') {\n    n = 0;\n    while (s[n] != 0) n++;\n    stack<ll> stc;\n    for (ll i = 0; i < n; i++) {\n      if (s[i] == '(') stc.push(i);\n      if (s[i] == ')') en[stc.top()] = i, stc.pop();\n    }\n    if (getNum(0, n-1) <= m) printf(\"0\\n\");\n    else printf(\"%c\\n\", check(0, m));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[2];\nint n,ima;\n \n \nint stoi(int &i){\n  int res=0;\n  while('0'<=str[ima][i]&&str[ima][i]<='9')res=res*10+str[ima][i]-'0',i++;\n  return res;\n}\n \n \nint main(){\n  while(1){\n \n    cin>>str[1]>>n;\n    if(str[1]==\"0\"&&n==0)break;\n    str[0].clear();\n    for(int i=0;i<str[1].size();i++) {\n      if(str[1][i]=='('&&str[1][i+2]==')') str[0]+=str[1][i+1],i+=2;\n      else str[0]+=str[1][i];\n    }\n    str[1].clear();    \n \n    ima=0;\n    int f=1;\n    int flg=1;\n    while(f){\n      f=0;\n      str[!ima].clear();\n      for(int i=0;i<(int)str[ima].size();i++){\n    if(!('0'<=str[ima][i]&&str[ima][i]<='9')) str[!ima]+=str[ima][i];\n    else {\n      f=1;\n      int num=stoi(i);\n      string pls;\n      if(str[ima][i]!='(') pls+=str[ima][i];\n      else {\n        int c=1;\n        while(c){\n          i++;\n          if(str[ima][i]=='(')c++;\n          if(str[ima][i]==')')c--;\n          if(c) pls+=str[ima][i];\n        }\n      }\n      while(num--&&(int)str[!ima].size()<=n+1) str[!ima]+=pls;\n    }\n      }\n       \n      ima=!ima;\n    }\n    //cout <<str[ima]<<endl;\n    if((int)str[ima].size()<=n&&flg) cout <<0<<endl;\n    else cout << str[ima][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct node{\n\tint number;\n\tstring letters;\n\tvector<node> children;\n\tchar get_char(int index,int &pos){\n\t\tint remain=index-pos+1;\n\t\tif(letters!=\"\"){\n\t\t\tif(letters.size()>=remain){\n\t\t\t\treturn letters[remain-1];\n\t\t\t}else{\n\t\t\t\tpos+=letters.size();\n\t\t\t\treturn '\\0';\n\t\t\t}\n\t\t}else{\n\t\t\tREP(i,number){\n\t\t\t\tREP(j,children.size()){\n\t\t\t\t\tchar c=children[j].get_char(index,pos);\n\t\t\t\t\tif(c!='\\0'){\n\t\t\t\t\t\treturn c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn '\\0';\n\t\t}\n\t}\n};\n\nint number(string &s,int &pos){\n\tint ret=0;\n\twhile(isdigit(s[pos])){\n\t\tret*=10;\n\t\tret+=s[pos]-'0';\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nstring letters(string &s,int &pos){\n\tstring ret;\n\twhile(isalpha(s[pos])){\n\t\tret+=s[pos];\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nvoid lp(string &s,int &pos){\n\tassert(s[pos]=='(');\n\tpos++;\n}\nvoid rp(string &s,int &pos){\n\tassert(s[pos]==')');\n\tpos++;\n}\nstring letter(string &s,int &pos){\n\tassert(isalpha(s[pos]));\n\tstring ret;\n\tret+=s[pos];\n\tpos++;\n\treturn ret;\n}\n\nvector<node> nodes(string &s,int &pos){\n\tvector<node> ret;\n\twhile(pos<s.size()){\n\t\tif(isdigit(s[pos])){\n\t\t\tnode nod;\n\t\t\tnod.number=number(s,pos);\n\t\t\tif(s[pos]=='('){\n\t\t\t\tlp(s,pos);\n\t\t\t\tnod.children=nodes(s,pos);\n\t\t\t\trp(s,pos);\n\t\t\t}else{\n\t\t\t\tnode c;\n\t\t\t\tc.letters=letter(s,pos);\n\t\t\t\tnod.children.push_back(c);\n\t\t\t}\n\t\t\tret.push_back(nod);\n\t\t}else if(isalpha(s[pos])){\n\t\t\tnode nod;\n\t\t\tnod.letters=letters(s,pos);\n\t\t\tret.push_back(nod);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring s;\n\tint index;\n\twhile(cin>>s>>index,s!=\"0\"||index){\n\t\tint pos=0;\n\t\tvector<node> roots=nodes(s,pos);\n\t\tpos=0;\n\t\tREP(i,roots.size()){\n\t\t\tchar c=roots[i].get_char(index,pos);\n\t\t\tif(c!='\\0'){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tcout<<0<<endl;\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring s; int n; int pos;\n\nint digit(){\n\tint ans = 0;\n\twhile(s[pos] >= '0' && s[pos] <= '9'){ ans = ans * 10 + s[pos] - '0'; pos++; }\n\treturn ans;\n}\nstring alpha(){\n\tstring ans = \"\";\n\twhile(s[pos] >= 'A' && s[pos] <= 'Z'){ ans += s[pos]; pos++; }\n\treturn ans;\n}\n\nstruct NODE{\n\tdouble len;\n\tstring val;\n\tvector< pair<double,NODE*> > next;\n\tNODE(){ len = 0; }\n};\n\nNODE* f(){\n\tdouble len = 0;\n\tNODE *c = new NODE;\n\twhile(s[pos] != ')'){\n\t\tif( s[pos] >= 'A' && s[pos] <= 'Z'){\n\t\t\tNODE *p = new NODE;\n\t\t\tp->val = alpha();\n\t\t\tp->len = p->val.size();\n\t\t\tc->next.push_back(make_pair(1,p));\n\t\t\tc->len += c->next.back().second->len;\n\t\t}else if( s[pos] >= '0' && s[pos] <= '9' ){\n\t\t\tint r = digit();\n\t\t\tif(s[pos] >=  'A'  && s[pos] <= 'Z'){\n\t\t\t\tNODE *p = new NODE;\n\t\t\t\tp->val = string(1,s[pos]);\n\t\t\t\tp->len = p->val.size();\n\t\t\t\tc->next.push_back(make_pair(r,p));\n\t\t\t\tc->len += r * c->next.back().second->len;\n\t\t\t\tpos++;\n\t\t\t}else if(s[pos] == '('){\n\t\t\t\tpos++;\n\t\t\t\tc->next.push_back(make_pair(r,f()));\n\t\t\t\tc->len += r * c->next.back().second->len;\n\t\t\t}else assert(0);\n\t\t}\n\t}\n\tpos++;\n\treturn c;\n}\nchar get(NODE *h,int n){\n\tif(h->val != \"\"){\n\t\treturn h->val[n];\n\t}\n\tint sum = 0;\n\tfor(int i = 0 ; i < h->next.size() ; i++){\n\t\twhile(h->next[i].first > 0){\n\t\t\tif(n - h->next[i].second->len < 0){\n\t\t\t\treturn get(h->next[i].second,n);\n\t\t\t}else{\n\t\t\t\tn -= h->next[i].second->len;\n\t\t\t}\n\t\t\th->next[i].first--;\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin >> s >> n && s != \"0\"){\n\t\tpos = 0;\n\t\ts += \")\";\n\t\tNODE *h = f();\n\t\tif(h->len <= n) cout << \"0\" << endl;\n\t\telse cout << get(h,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\n\nstring s;\nint index;\n \nint cur;\nbool endf;\n \nstring rec()\n{\n    string res;\n \n    while(cur < s.size() && !endf) {\n        while('A' <= s[cur] && s[cur] <= 'Z') {\n            res += s[cur];\n            cur++;\n        }\n \n        if('0' <= s[cur] && s[cur] <= '9') {\n            int n = s[cur++] - '0';\n            while('0' <= s[cur] && s[cur] <= '9') {\n                n = 10 * n + s[cur++] - '0';\n            }\n \n            string pattern;\n            if(s[cur] == '(') {\n                cur++;\n                pattern = rec();\n            } else {\n                pattern = s[cur++];\n            }\n \n            for(int i = 0; i < n; ++i) {\n                res += pattern;\n                if(res.size() > index) {\n                \tendf = true;\n                \tbreak;\n                }\n            }\n        }\n \n        if(s[cur] == ')') {\n            cur++;\n            return res;\n        }\n    }\n \n    return res;\n}\n \n \nint main()\n{\n    while(true){\n        cin >> s >> index;\n        if(s == \"0\" && index == 0) break;\n \n        cur = 0;\n        endf = false;\n        string res = rec();\n        //cout << res << endl;\n        if(res.size() <= index) {\n            cout << 0 << endl;\n        } else {\n            cout << res[index] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint f(string s, int num){\n    int ret = 0;\n    int n = s.size();\n    int t = 0;\n    rep(i,n){\n        if(isdigit(s[i])){\n            t *= 10;\n            t += s[i]-'0';\n        }else if(s[i] == '('){\n            int tmp = 0;\n            int nxt;\n            loop(j,i,n){\n                if(s[j] == '(')tmp++;\n                if(s[j] == ')'){\n                    tmp--;\n                    if(tmp == 0){\n                        nxt = j;\n                        break;\n                    }\n                }\n            }\n            int c = f(s.substr(i+1,nxt-i-1),num-ret);\n            if(c >= 0)return c;\n            c *= -1;\n            if(num-ret <= c*t) return f(s.substr(i+1,nxt-i-1), (num-ret-1)%c+1);\n            ret += c*t;\n            t = 0;\n            i = nxt;\n        }else if(s[i] >= 'A' && s[i] <= 'Z'){\n            if(t == 0)t++;\n            ret += t;\n            if(num <= ret)return s[i]-'A';\n            t = 0;\n        }\n    }\n    return -ret;\n}\n\nsigned main(void) {\n    string s;\n    int n;\n    while(cin >> s >> n, s != \"0\"){\n        int ret = f(s,n+1);\n        if(ret < 0)cout << 0 << endl;\n        else cout << char('A'+ret) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int t;\nconst long long int MAX_T=1e8;\nlong long int read(int& i,string& s);\nlong long int counta(int &i,string &s);\nchar solve(int &i,string &s){\n  int prei=i;\n  long long int ret;\n  while(ret=read(i,s)){\n    prei=i;\n    if(ret==-1){\n      t--;\n      if(t==0) return s[i-1];\n    }\n    else{\n      long long int val=counta(i,s);\n      if(val*ret>=t){\n\tt%=val;\n\tif(t==0) t=val;\n\ti=prei;\n\treturn solve(i,s);\n      }\n      else{\n\tt-=val*ret;\n      }\n    }\n  }\n  return '0';\n  \n}\n\nlong long int counta(int &i,string &s){\n  long long int ret;\n  long long int res=0;\n  while(ret=read(i,s)){\n    if(ret==-1){\n      res++;\n    }\n    else{\n      res+=counta(i,s)*ret;\n      res=min(res,MAX_T);\n    }\n  }\n  return min(MAX_T,res);\n}\n\nlong long int read(int& i,string& s){\n  if(i>=s.size() || s[i]==')'){\n    i++;\n    return 0;\n  }\n  if(isalpha(s[i])){\n    i++;\n    return -1;\n  }\n  long long int prei=i;\n  for(;i<s.size() && isdigit(s[i]);i++);\n  long long int res=(i-prei>8 ? MAX_T :stoi(s.substr(prei,i-prei)));\n  if(s[i]=='(') i++;\n  return res;\n}\n\n\nint main(){\n  string s;\n  while(cin>>s>>t,s!=\"0\"){\n    int i=0;\n    t++;\n    cout<<solve(i,s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m;\nchar ans;\nbool flag = false;\nstring dfs(string s) {\n\t//cout << s << endl;\n\tif(flag) return \"\";\n\tif('A' <= s[0] && s[0] <= 'Z') {\n\t\treturn s;\n\t}\n\t//10C??????????????????????¢????\n\tbool h = false;\n\tstring tt = \"\";\n\tint idx = 0;\n\tREP(i, s.size()) {\n\t\tif(i >= 5) break;\n\t\tif(s[i] == '(') h = true;\n\t\tif(isdigit(s[i])) tt += s[i], idx = i;\n\t}\n\tstring ret = \"\";\n\tif(!h) {\n\t\tstring tmp = dfs(s.substr(idx+1));\n\t\tint itt = stoi(tt);\n\t\tREP(i, itt) {\n\t\t\tret += tmp;\n\t\t\tif((int)ret.size() > m) {\n\t\t\t\tans = ret[m];\n\t\t\t\tflag = true;\n\t\t\t\t//cout << ans << endl;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\tstring num = \"\", para = \"\";\n\tint now = 0;\n\tbool f = true, g = false;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '(') {\n\t\t\tg = true;\n\t\t\tnow++;\n\t\t} else if(s[i] == ')') {\n\t\t\tnow--;\n\t\t} else if(isdigit(s[i])){\n\t\t\tf = false;\n\t\t} else {\n\t\t\tf = true;\n\t\t}\n\t\tif(g) para += s[i];\n\t\telse num += s[i];\n\t\tif(now == 0 && f) {\n\t\t\t//tmp???dfs?????????????????°?????????????????????ret????????????\n\t\t\tint ttmp = stoi(num);\n\t\t\tstring dret = dfs(para.substr(1, para.size()-2));\n\t\t\tREP(j, ttmp) {\n\t\t\t\tret += dret;\n\t\t\t\tif((int)ret.size() > m) {\n\t\t\t\t\tans = ret[m];\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tnum = \"\", para = \"\";\n\t\t\tf = true, g = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\n\t\tflag = false;\n\n\t\tbool f = true;\n\t\tint now = 0;\n\t\tstring tmp = \"\";\n\t\tREP(i, s.size()) {\n\t\t\t//cout << \"i:\" << i << \" \" << s[i] << endl;\n\t\t\tif(s[i] == '(') now++;\n\t\t\telse if(s[i] == ')') now--;\n\t\t\telse if(isdigit(s[i])) f = false;\n\t\t\telse f = true;\n\t\t\ttmp += s[i];\n\t\t\t//cout << tmp << \" \" << m << endl;\n\t\t\tif(now == 0 && f) {\n\t\t\t\tstring t = dfs(tmp);\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif(flag) {cout << ans << endl; goto e;}\n\t\t\t\telse if((int)t.size() <= m) {\n\t\t\t\t\tm -= t.size();\n\t\t\t\t}\telse {cout << t[m] << endl; goto e;}\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t\te:\n\t\tint a;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[300], v[300], w[300];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tmemset(p, 0, sizeof(p));\n\t\tmemset(w, 0, sizeof(w));\n\t\tmemset(v, 0, sizeof(v));\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (pos == s.size()) {\n\t\t\t\tprintf(\"0\\n\"); break;\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tpos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << s[pos - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstring str;\nint n;\n\nint dfs(string s, int pre){\n    int now = 0;\n    int ret = 0;\n    while(true){\n        while('A' <= s[now] && s[now] <= 'Z'){\n            ret++;\n            if(n == ret+pre){\n                cout << s[now] << endl;\n                return -1;\n            }\n            now++;\n            if(now == s.size()){\n                return ret;\n            }\n        }\n        int num = 0;\n        while('0' <= s[now] && s[now] <= '9'){\n            num = num*10+s[now]-'0';\n            now++;\n        }\n        string foo;\n        int kakko = 0;\n        while(true){\n            now++;\n            if(s[now] == ')') kakko--;\n            if(s[now] == '(') kakko++;\n            if(kakko < 0){\n                int d = dfs(foo,ret+pre);\n                if(d == -1) return -1;\n                if(ret+pre+num*d >= n){\n                    n -= (ret+pre);\n                    n %= d;\n                    if(n == 0) n = d;\n                    dfs(foo,0);\n                    return -1;\n                }\n                ret += num*d;\n                break;\n            }\n            foo.push_back(s[now]);\n        }\n        now++;\n        if(now == s.size()) return ret;\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> str >> n){\n        if(str == \"0\" && n == 0) break;\n        n++;\n        string tmp;\n        rep(i,str.size()){\n            if('A' <= str[i] && str[i] <= 'Z'){\n                if(i != 0 && ('0' <= str[i-1] && str[i-1] <= '9')){\n                    tmp.push_back('(');\n                    tmp.push_back(str[i]);\n                    tmp.push_back(')');\n                } else{\n                    tmp.push_back(str[i]);\n                }\n            } else{\n                tmp.push_back(str[i]);\n            }\n        }\n        str = tmp;\n        if(dfs(str,0) != -1){\n            cout << 0 << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[500];\nchar *p;\nint k;\nint len;\n\nint solve(int k, int l, int r){\n    int cur = k;\n    dump(k);\n    dump(l);\n    dump(r);\n    int res = 0;\n    while(s[l] && l<r){\n        while(isalpha(s[l])){\n            if(cur==0){\n                dump(k);\n                dump(s[l]);\n                throw s[l];\n            }\n            res++;\n            l++;\n            cur--;\n        }\n        int times = 0;\n        while(isdigit(s[l])){\n            times = times*10 + s[l]-'0';\n            l++;\n        }\n        dump(l);\n        dump(times);\n        if(s[l]=='('){\n            int d = 0;\n            int i = l;\n            while(1){\n                if(s[i]=='(') d++;\n                else if(s[i]==')') d--;\n                if(d==0) break;\n                i++;\n            }\n            int rangelen = solve(k,l+1,i);\n            for(int j=0;j<times;j++){\n                res += solve(k,l+1,i);\n                k -= rangelen;\n            }\n            l = i+1;\n        } else if(isalpha(s[l])){\n            for(int j=0;j<times;j++){\n                res += solve(k,l,l+1);\n                k -= 1;\n            }\n            l = l+1;\n        }\n    }\n    return res;\n}\n\nint main(){\n    static char t[500];\n    while(cin >> t >> k && t[0]!='0'){\n        int tlen = strlen(t);\n        len = 0;\n        for(int i=0;i<tlen;i++){\n            if(i>0 && isdigit(t[i-1]) && isalpha(t[i])){\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            } else {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n        try {\n            solve(k,0,len);\n            puts(\"0\");\n        } catch(char e){\n            cout << e << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<string, string> Parse;\n\nconst Parse eps = Parse(\"\", \"\");\n\nParse term(string str);\nParse expr(string str);\n\nParse term(string str)\n{\n    if(!isdigit(str[0])) {\n        return Parse(string(1, str[0]), str.substr(1));\n    } else {\n        int a = 0, idx = 0;\n        while(isdigit(str[idx])) {\n            a = a * 10 + str[idx++] - '0';\n        }\n        \n        if(str[idx] != '(') {\n            string ret = \"\";\n            for(int i = 0; i < a; i++) {\n                ret += string(1, str[idx]);\n            }\n            \n            return Parse(ret, str.substr(idx + 1));\n        } else {\n            Parse p = expr(str.substr(idx + 1));\n            string ret = \"\";\n            for(int i = 0; i < a; i++) {\n                ret += p.first;\n            }\n            return Parse(ret, p.second.substr(1));\n        }\n    }\n    \n}\n\nParse expr(string str)\n{\n    if(str == \"\") {\n        return eps;\n    }\n    if(str[0] == ')') {\n        return Parse(\"\", str);\n    }\n\n    Parse p1 = term(str);\n    Parse p2 = expr(p1.second);\n\n    return Parse(p1.first + p2.first, p2.second);\n}\n\n\nint main()\n{\n    int n;\n    string str;\n    while(cin >> str >> n && (str != \"0\" || n != 0)) {\n        Parse p = expr(str);\n        string parsed = p.first;\n        if(parsed.size() > n) {\n            cout << parsed[n] << endl;\n        } else {\n            cout << 0 << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nstring str,s;\nint pos,cnt,n;\nchar ans;\nbool f;\n\nint term();\nint factor();\n\nint exp(){\n   int x = term();\n   if(str[pos] == '+'){\n      pos++;\n      x += term();\n\t if(!f && x >= n){\n\t    ans = s[(x-n)%s.size()];\n\t    f = true;\n\t }\n   }\n   cnt = x;\n   return x % MAX;\n}\n\nint term(){\n   int x = factor();\n   if(x <= MAX){\n      if(str[pos] == '*'){\n\t pos++;\n\t x *= factor();\n\t if(!f && x >= n){\n\t    ans = s[(x-n)%s.size()];\n\t    f = true;\n\t }\n      }\n      cnt = x;\n      return x % MAX;\n   }\n}\n\nint factor(){\n   int x = 0;\n   if(str[pos] == '('){\n      pos++;\n      x = exp();\n      pos++;\n   } else if(str[pos] >= '0' && str[pos] <= '9'){\n      while(str[pos] >= '0' && str[pos] <= '9'){\n\t x *= 10;\n\t x += str[pos++] - '0';\n\t if(pos == n) break;\n      }\n   } else if(str[pos] >= 'A' && str[pos] <= 'Z'){\n      s.clear();\n      while(str[pos] >= 'A' && str[pos] <= 'Z'){\n\t s += str[pos++];\n\t if(pos == n) break;\n      }\n      if(!f && cnt >= n){\n\t ans = s[(cnt-n)%s.size()];\n\t f = true;\n      }\n      x = s.size();\n   }\n   return x % MAX;\n}\n\nint main(){\n   while(cin >> str >> n){\n      if(str == \"0\" && n == 0) break;\n      pos = cnt = 0;\n      f = false;\n      ans = '0';\n\n      for(int i=0;i<str.size();i++){\n\t if(str[i] == '(' ||\n\t    i > 0 && str[i-1] >= '0' && str[i-1] <= '9' && str[i] >= 'A' && str[i] <= 'Z'){\n\t    str.insert(str.begin()+i,'*');\n\t    i++;\n\t } else if(i > 0 && str[i-1] == ')'){\n\t    if(str[i] >= '0' && str[i] <= '9' || str[i] >= 'A' && str[i] <= 'Z'){\n\t       str.insert(str.begin()+i,'+');\n\t       i++;\n\t    }\n\t }\n      }\n\n      exp();\n      cout << ans << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define DEBUG false\nusing namespace std;\n\nunsigned int n; // oÍ·é¶\n\nstring tab=\"\";\nstring tabN=\"  \";\n\nstring parse( string s ){\n  string r=\"\", num, tmp;\n  if( DEBUG)  tab += tabN;\n\n  for( unsigned int i=0;i<s.length();i++ ){\n    if( i>n )\n      return s.substr( 0,i );\n\n    if( '0'<=s[i] && s[i]<='9' ){\n      num=\"\";\n      unsigned int j=i;\n      for( j=i;j<s.length();j++ )\n\tif( '0'<=s[j] && s[j]<='9' ) num = num + s[j];\n\telse                         break;\n      if( s[j]!='(' ){\n\ttmp = s[j];\n      }else{\n\tint a=0; // Ê\"(\"Ì - \")\"Ì\n\ttmp=\"\";\n\twhile( j<s.length() ){\n\t  if( s[j]=='(' )      ++a;\n\t  else if( s[j]==')' ) --a;\n\t  tmp = tmp + s[j++];\n\t  if( a==0 )\n\t    break;\n\t}\n\ttmp = tmp.substr( 1,tmp.length()-2 );\n      }\n      // ±Ì_Å num(tmp) ÌÅãÌ) ÌÊuªj\n      j++;\n\n      if( DEBUG )\n\tcout << tab << \"num=\"<<num << \" tmp=\" << tmp << endl;\n\n      tmp = parse( tmp );\n      if( i + num.length() * tmp.length()>n ){\n\tn -= i;\n\tn = n % tmp.length(); // tmp Ìn ¶Úª¦\n\treturn tmp;\n      }\n\n      string rp=\"\";\n      int rpN = atoi( num.c_str() );\n      for( int k=0;k<rpN ;k++ ){\n\trp = rp + tmp;\n\tif( i+rp.length() > n )\n\t  return s.substr( 0,i ) + rp;\n      }\n\n      string bef = s.substr( 0,i );\n      string back = \"\";\n      if( j<s.length() ) back = s.substr( j-1 );\n      s = bef + rp + back;\n      if( bef.length() > n )\n\treturn s;\n      \n      if( DEBUG ){\n\tcout << tab << \"bef =\"<<bef<<endl;\n\tcout << tab << \"rp =\"<<rp << endl;\n\tcout << tab << \"back =\"<<back << endl;\n\tcout << tab << \"s =\" << s << endl;\n      }\n    }else{\n      r = r + s[i];\n    }\n    if( r.length() > n )\n      break;\n  }\n  if( DEBUG )\n    tab = tab.substr( tabN.length() );\n\n  return r;\n}\n\nint main(){\n  string s, ans;\n\n  while( true ){\n    cin >> s >> n;\n    if( s==\"0\" && !n )\n      break;\n\n    if( DEBUG ){\n      cout << \"in : \" << s << endl;\n      cout << \"num=\" << n << endl << endl;\n    }\n    ans = parse( s );\n    if( DEBUG )\n      cout << \"return : \" << ans << endl;\n\n    if( n < ans.length() )\n      cout << ans[n] << endl;\n    else\n      cout << \"0\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[2];\nint n,ima;\n\n\nint stoi(int &i){\n  int res=0;\n  while('0'<=str[ima][i]&&str[ima][i]<='9')res=res*10+str[ima][i]-'0',i++;\n  return res;\n}\n\n\nint main(){\n  while(1){\n\n    cin>>str[1]>>n;\n    if(str[1]==\"0\"&&n==0)break;\n    str[0].clear();\n    for(int i=0;i<str[1].size();i++) {\n      if(str[1][i]=='('&&str[1][i+2]==')') str[0]+=str[1][i+1],i+=2;\n      else str[0]+=str[1][i];\n    }\n    str[1].clear();    \n\n    ima=0;\n    int f=1;\n    int flg=1;\n    while(f){\n      f=0;\n      str[!ima].clear();\n      for(int i=0;i<(int)str[ima].size();i++){\n\tif(!('0'<=str[ima][i]&&str[ima][i]<='9')) str[!ima]+=str[ima][i];\n\telse {\n\t  f=1;\n\t  int num=stoi(i);\n\t  string pls;\n\t  if(str[ima][i]!='(') pls+=str[ima][i];\n\t  else {\n\t    int c=1;\n\t    while(c){\n\t      i++;\n\t      if(str[ima][i]=='(')c++;\n\t      if(str[ima][i]==')')c--;\n\t      if(c) pls+=str[ima][i];\n\t    }\n\t  }\n\t  while(num--&&(int)str[!ima].size()<=n) str[!ima]+=pls;\n\t}\n      }\n      \n      ima=!ima;\n    }\n    //cout <<str[ima]<<endl;\n    if((int)str[ima].size()<=n&&flg) cout <<0<<endl;\n    else cout << str[ima][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\nint a[200020]={0};\nstring s,t,tt;\nvector<int> G[100000];\nint b[200020];\nchar c[200020];\nint kosuu=0;\nint kazu[200020];\nint nu(int i){\n\tint r=0;\n\tfor(int j=i;j<=s.length();j++){\n\t\tif(s[j]<='9' &&s[j]>='0'){\n\t\tr*=10;\n\t\tr += s[j]-'0';\n\t\t}\n\t\telse break;\n\t}\n\treturn r;\n}\n\nvoid dfs(int i,int j,int oya){\n\tif(i>j) return;\n//\tcout<<s.substr(i,j-i+1)<<endl;\n\tkosuu++;\n\tint r=kosuu;\n//\tcout<<i<<\" \"<<j<<\" \"<<oya<<endl;\n//\tcout<<oya<<\" \"<<r<<endl;\n\tif(s[i]>='A'&&s[i]<='Z'){\n\t\tG[oya].pb(r);\n\t\t\n\t\tb[r]=1;\n\t\tc[r]=s[i];\n//\t\tcout<<\"r=\"<<r<<endl;\n\t\tdfs(i+1,j,oya);\n\t}\n\telse{\n\t\tG[oya].pb(r);\n\t\tb[r]=nu(i);\n\t\tif(s[a[i]]=='('){\n\t\tdfs(a[a[i]]+1,j,oya);\n\t\tdfs(a[i]+1,a[a[i]]-1,r);\n\t\t}\n\t\telse{\n\t\t\tdfs(a[i]+1,j,oya);\n\t\t\tc[r]=s[a[i]];\n//\t\tcout<<\"r=\"<<r<<endl;\n\t\t}\n\t}\n}\n\n\nint kei(int u){\n\tint r=0;\n\tif(G[u].size()==0){\n\t\tkazu[u]=1;\n\t\treturn 1;\n\t}\n\tfor(int j=0;j<G[u].size();j++){\n\t\tr += b[G[u][j]]*kei(G[u][j]);\n\t\tr=min(r,10000000ll);\n\t}\n\tkazu[u]=r;\n\t//cout<<\"kosuu\"<<u<<\" \"<<r<<endl;\n\treturn r;\n}\nchar ans;\n\nvoid ch(int oya,int r){\n//\tcout<<oya<<\" \"<<kazu[oya]<<\" \"<<r<<endl;\n\tint u=0;\n\tif(G[oya].size()==0){\n\t\tans=c[oya];\n\t\t//cout<<c[oya]<<endl;\n\t\treturn;\n\t} \n\twhile(1){\n\t\t\n\t\tif(kazu[G[oya][u]]*b[G[oya][u]]<r) r-=kazu[G[oya][u]]*b[G[oya][u]];\n\t\telse{\n\t\t\tr %= kazu[G[oya][u]];\n\t\t\tif(r==0) r=kazu[G[oya][u]];\n\t\t\tch(G[oya][u],r);\n\t\t\tbreak;\n\t\t}\n\t\tu++;\n\t}\n}\n\nsigned main(){\n\n\t\n\twhile(1){\n\t\t//string s;\n\t\tint r;\n\t\tint na,nb;\n\tcin>>s>>r;\n\t\tif(s==\"0\" && r==0) return 0;\n\t//\ts=\"1(\"+s+\")\";\n\t\tfor(int i=0;i<100000;i++){\n\t\t\tG[i].clear();\n\t\t\tkazu[i]=0;\n\t\t}\n\t\tint i;\n\t\tstack<int> st;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t\tif(s[i]==')'){\n\t\t\tint \ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\ta[y]=i;\n\t\t\t}\n\t\t\tif(s[i]>='0' && s[i]<='9'){\n\t\t\t\tint g=i+1;\n\t\t\t\twhile(s[g]>='0' && s[g]<='9')g++;\n\t\t\t\ta[i]=g;\n\t\t\t}\n\t\t}\n\t\t\n\t\tkosuu=0;\n\t//\tfor(int i=0;i<s.length();i++) cout<<a[i]<<\" \";\n\t//\tcout<<endl;\n\t\tdfs(0,s.length()-1,0);\n//\tcout<<\tkei(0)<<endl;\n\t\tkei(0);\n\t\tif(kazu[0]<=r) cout<<0<<endl;\n\t\telse{\n\t\tch(0,r+1);\n\t\tcout<<ans<<endl;\n\t\t}\n\t}\n\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nint toint(int&);\nstring calc(int&);\nstring expr(int&);\n\n\nstring s;\nint n;\n\nint toint(int& idx){\n  int ret = 0;\n  while(isdigit(s[idx])){\n    ret = ret * 10 + s[idx] - '0';\n    idx++;\n  }\n  return ret;\n}\n\nstring calc(int& idx){\n  string java;\n  if(isdigit(s[idx])){ //すーじ\n    int num = toint(idx) ;\n    string ret = calc(idx) ;\n    for(int i = 0 ; i < num ; i++ ){\n      java += ret ;\n      if(java.size() >= n) break;\n    }\n  } else if(isalpha(s[idx])){ //えーじ\n    while(isalpha(s[idx])){\n      java += s[idx] ;\n      idx++ ;\n      if(java.size() >= n) break;\n    }\n  } else { //かっこ\n    idx++;\n    java = expr(idx);\n    idx++;\n  }\n  return java;\n}\nstring expr(int& idx){\n  string java;\n  while(isalpha(s[idx])|isdigit(s[idx])){\n    if(java.size() >= n) break;\n    java += calc(idx);\n  }\n  return java;\n}\n\n\nint main(){\n  int now;\n  while(cin >> s >> n, s!=\"0\"||n){\n    string ret = expr(now = 0);\n    if(n >= ret.size()) cout << 0 << endl;\n    else cout << ret[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\nbool watch=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(const string str,const int from,const int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1&&watch){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twatch=false;\n\t\t\t\t\t}\n\t\t\t\t\t//if(str==\"2(4(AB)3(XY))10C\"){\n\t\t\t\t\t//\tcout<<endl;\n\t\t\t\t\t//}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\twatch=true;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nint num(Cursol&);\nstring calc(Cursol&);\nstring expr(Cursol&);\n\nint pos ;\n\nint num(Cursol& p){\n  int ret = 0;\n  while(isdigit(*p)){\n    ret = ret * 10 + *p - '0';\n    p++;\n  }\n  return ret;\n}\n\nstring calc(Cursol& p){\n  string ret;\n  if(isdigit(*p)){\n    int number = num(p);\n    if( *p == '(') {\n      string res = expr(++p);\n      p++;\n      while(number--){\n        ret += res;\n        if(pos < ret.size()) break;\n      }\n    } else {\n      ret.insert(ret.end(), min( pos + 1, number), *p++);\n    }\n  }else{\n    while(isalpha(*p)){\n      ret += *p++;\n      if(pos < ret.size()) break;\n    }\n  }\n  return ret;\n}\n\n\nstring expr(Cursol& p){\n  string ret;\n  while( isalpha(*p) || isdigit(*p)){\n    ret += calc(p);\n    if(pos < ret.size()) break;\n  }\n  return ret;\n}\nint main(){\n  string str;\n  while(cin >> str >> pos, str!=\"0\"||pos){\n    Cursol idx = str.begin();\n    string ret = expr(idx);\n    if(pos < ret.size()) cout << ret[pos] << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nbool isdigit(char a) {\n\treturn a >= '0' && a <= '9';\n}\nstruct State {\n\tint rep;\n\tint sz;\n\tint pos;\n\tvector<int> child;\n};\nState tmp;\nvector<State> s;\nint readNumber(string &S, int &pos) {\n\tint res = 0;\n\twhile (isdigit(S[pos])) {\n\t\tres *= 10;\n\t\tres += S[pos] - '0';\n\t\tpos++;\n\t}\n\treturn res;\n}\nint sz(string &S, int &pos, int par) {\n\t//cerr << \"pos=\" << pos << endl;\n\tif (pos >= (int)S.size())return 0;\n\tif (S[pos] == '(') {\n\t\t//cerr << \"par = \" << par << endl;\n\t\tpos++;\n\t\twhile (S[pos] != ')') {\n\t\t\tif (isdigit(S[pos])) {\n\t\t\t\tint a = readNumber(S, pos);\n\t\t\t\ts[par].child.push_back(s.size());\n\t\t\t\ttmp.rep = a;\n\t\t\t\ttmp.pos = pos;\n\t\t\t\ts.push_back(tmp);\n\t\t\t\tsz(S, pos, (int)s.size() - 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts[par].child.push_back(s.size());\n\t\t\t\ttmp.rep = 1;\n\t\t\t\ttmp.sz = 1;\n\t\t\t\ttmp.pos = pos;\n\t\t\t\ts.push_back(tmp);\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tpos++;\n\t}\n\telse {\n\t\ts[par].child.push_back(s.size());\n\t\ttmp.rep = 1;\n\t\ttmp.sz = 1;\n\t\ttmp.pos = pos;\n\t\ts.push_back(tmp);\n\t\tpos++;\n\t}\n\ts[par].sz = 0;\n\tfor (int i = 0; i < s[par].child.size(); i++) {\n\t\ts[par].sz = min((int)1 << 40, s[par].sz + s[s[par].child[i]].sz * s[s[par].child[i]].rep);\n\t}\n\treturn s[par].sz;\n}\nint find(int p, int a) {\n\tif (a == 0 && (int)s[p].child.size() == 0) {\n\t\treturn s[p].pos;\n\t}\n\tfor (int i = 0; i < s[p].child.size(); i++) {\n\t\tif (a < s[s[p].child[i]].rep * s[s[p].child[i]].sz) {\n\t\t\treturn find(s[p].child[i], a % s[s[p].child[i]].sz);\n\t\t}\n\t\telse {\n\t\t\ta -= s[s[p].child[i]].rep * s[s[p].child[i]].sz;\n\t\t}\n\t}\n\treturn -1;\n}\nsigned main() {\n\twhile (true) {\n\t\tstring S;\n\t\tint a;\n\t\tcin >> S >> a;\n\t\tif (S == \"0\" && a == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tS = '(' + S + ')';\n\t\t//cerr << S << endl;\n\t\ts.clear();\n\t\ttmp.rep = 1;\n\t\ttmp.pos = 0;\n\t\ts.push_back(tmp);\n\t\tint p = 0;\n\t\tsz(S, p, 0);\n\t\t//cerr << s.size() << endl;\n\n\t\tint res = find(0, a);\n\t\t//while (S[res] == '(') res++;\n\t\t//cerr << res << endl;\n\t\tif (res == -1) {\n\t\t\tcout << '0' << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << S[res] << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n \nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n \nvoid dfs(int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    if('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int x=r.first,num=r.second;\n      int y=r.first,z=r.first;\n      if(s[x]=='('){\n    int c=1;\n    y=x+1;\n    for(z=y;z<=e&&c;z++){\n      if(s[z]=='(')c++;\n      if(s[z]==')')c--;\n    }\n    p=z;\n    z-=2;\n    while(num--)dfs(y,z);\n      }else{\n    while(num--)ans+=s[x];\n    p=x+1;\n      }\n    }\n   if('A'<=s[p]&&s[p]<='Z')\n      ans+=s[p++];\n  }\n}\n \nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,s.size()-1);\n    if(ans.size()<n+1)\n      cout<<0<<endl;\n    else cout<<ans[n]<<endl;\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring expr;\nint p,s,l;\nchar ans;\n\nint parseInt()\n{\n\tint ret=0;\n\twhile(p<expr.size())\n\t{\n\t\tif(!isdigit(expr[p])) break;\n\t\tret*=10;\n\t\tret+=expr[p]-'0';\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nstring parseStr()\n{\n\tstring ret;\n\twhile(p<expr.size())\n\t{\n\t\tif(!isupper(expr[p])) break;\n\t\tret+=expr[p];\n\t\tp++;\n\t}\n\t\n\treturn ret;\n}\n\nbool parse()\n{\n\tint lp=parseInt(), tp=p;\n\tstring str;\n\tif(expr[p]=='(')\n\t{\n\t\twhile(lp--)\n\t\t{\n\t\t\tp=tp;\n\t\t\tp++;\n\t\t\tif(parse()) return true;\n\t\t}\n\t\tp++;\n\t}\n\telse\n\t{\n\t\tif(lp==0) lp++;\n\t\tstr=parseStr();\n\t\t\n\t\tif(s+str.size()*lp > l)\n\t\t{\n\t\t\tint ex=(l-s+str.size()*lp)%str.size();\n\t\t\tans=str[ex];\n\t\t\treturn true;\n\t\t}\n\t\ts+=str.size()*lp;\n\t\t\n\t}\n\n\tif(p<expr.size() && expr[p]!=')') return parse();\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> expr >> l, (expr!=\"0\"||l))\n\t{\n\t\tp=0; s=0; ans='0';\n\t\t\n\t\tparse();\n\t\tprintf(\"%c\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll id;\nint N, c;\nstring s;\n\nconst ll MAX = 2000000;\n\nstruct Node {\n\tll v, len;\n\tstring s;\n\tvector<Node*> children;\n\tNode() : v(1), len(0), s(string()) {}\n};\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nNode* f(){\n\tNode* node = new Node();\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\tnode->v = n;\n\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tNode* res = f();\n\t\t\tnode->children.push_back(res);\n\t\t\tnode->len = min(MAX, node->len + res->len * res->v);\n\n\t\t\tif(s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tassert('A' <= s[c] && s[c] <= 'Z');\n\n\tnode->s = readS();\n\tnode->len = min(MAX, (ll)node->s.size());\n\n\t//if(ans == 0) {\n\t//\tif(ss.size() * v <= id) {\n\t//\t\tid -= ss.size() * v;\n\t//\t\treturn;\n\t//\t}\n\n\t//\twhile(id >= ss.size()) id -= ss.size();\n\t//\tans = ss[id];\n\t//}\n\treturn node;\n}\n\nvoid g(Node* node){\n\tif(node->children.size() == 0) {\n\t\tassert(id < node->s.size());\n\t\tans = node->s[id];\n\t\treturn;\n\t}\n\n\twhile(!(id < node->len)) id -= node->len;\n\n\tfor(auto child : node->children) {\n\t\tif(child->len * child->v <= id) {\n\t\t\tid -= child->len * child->v;\n\t\t}\n\t\telse{\n\t\t\tg(child);\n\t\t\tassert(ans);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0){\n\t\t\tNode* res = f();\n\t\t\tif(res->len * res->v <= id) {\n\t\t\t\tid -= res->len * res->v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg(res);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<string, int> gs(const string& s, int i = 0) {\n  string res = \"\";\n  if (i == s.size()) return make_pair(res, i);\n  if('0' <= s[i] && s[i] <= '9') {\n    int v = 0;\n    while('0' <= s[i] && s[i] <= '9') {\n      v *= 10;\n      v += s[i] - '0';\n      ++i;\n    }\n    if (s[i] == '(') {\n      string ss;\n      int j;\n      tie(ss, j) = gs(s, i+1);\n      REP(i,v) {\n        if (res.size() > 1100000) break;\n        res += ss;\n      }\n      i = j+1;\n    } else {\n      res += string(v, s[i]);\n      ++i;\n    }\n  } else {\n    res += s[i];\n    ++i;\n  }\n  if (i == s.size()) return make_pair(res, i);\n  if (s[i] != ')') {\n    string ss;\n    int j;\n    tie(ss, j) = gs(s,i);\n    if (res.size() <= 1100000)\n      res += ss;\n    i = j;\n  }\n  return make_pair(res, i);\n}\n\nint main() {\n  while(1){\n    string s;\n    int i;\n    cin>>s>>i;\n    if(s==\"0\"&&i==0) break;\n    string h1e6 = gs(s).first;\n    if (i >= h1e6.size()) cout << \"0\" << endl;\n    else cout << h1e6[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    string get_foo(const string &S, int &pos, function<int(int)> isfoo) {\n        int len = 0;\n        for(; isfoo(S[pos + len]); len++);\n        string ret = S.substr(pos, len);\n        pos += len;\n        return move(ret);\n    }\n    string calc(const string &S, int &pos, int N) {\n        bool paren = S[pos] == '(';\n        if(paren) pos++;\n        string res = \"\";        \n        do {\n            if(isdigit(S[pos])) {\n                int rec = stoi(get_foo(S, pos, [](int a) { return isdigit(a); }));\n                int need = N - res.size();\n                string ss = calc(S, pos, need);\n                rep(i, rec) {\n                    rep(j, ss.size()) {\n                        res.push_back(ss[j]);\n                        if(res.size() >= N) goto A;\n                    }\n                }\n          A:;\n            } else if(isalpha(S[pos])) {\n                if(paren) {\n                    res.append(get_foo(S, pos, [](int a) { return isalpha(a); }));\n                } else {\n                    res.push_back(S[pos++]);\n                }\n            } else assert(0);\n        } while(paren and S[pos] != ')' and res.size() < N);\n        if(paren) pos++;\n        return move(res);\n    }\n    \n    bool solve() {\n        string S; cin >> S;\n        if(S == \"0\") return false;\n        int N; cin >> N;\n        cerr << S << \" \" << N << endl;\n        int pos = 0;\n        string s = \"\";\n\n        while(pos < S.size() and s.size() <= N) {\n            s += calc(S, pos, N - s.size() + 1);\n        }\n        cout << (s.size() <= N ? \"0\" : s.substr(N, 1)) << endl;        \n        return true;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int i = 0;\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n\nstring genome() {\n\tstring res = \"\";\n\tif(s[roc] == '(') {\n\t\t++roc;\n\t\twhile(s[roc] != ')' && !found) {\n\t\t\tif(s[roc] >= 'A' && s[roc] <= 'Z') {\n\t\t\t\tres += s[roc];\n\t\t\t\t++t;\n\t\t\t\tif(t == i) {\n\t\t\t\t\tans = s[roc];\n\t\t\t\t\tfound = true;\n\t\t\t\t\t++roc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++roc;\n\t\t\t} else {\n\t\t\t\tll roc_buf = roc;\n\t\t\t\twhile(s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\t\t\tint roop = stoi(s.substr(roc_buf, roc - roc_buf));\n\t\t\t\tstring rooped = genome();\n\t\t\t\tif(!found) {\n\t\t\t\t\tREP(j, roop - 1) {\n\t\t\t\t\t\tif(t + rooped.size() < i) {\n\t\t\t\t\t\t\tt += rooped.size();\n\t\t\t\t\t\t\tres += rooped;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(ans == '#') {\n\t\t\t\t\t\t\t\tans = rooped[(i - t) - 1];\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t} else {\n\t\tres += s[roc];\n\t\t++t;\n\t\tif(t == i) {\n\t\t\tans = s[roc];\n\t\t\tfound = true;\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s>>i;\n\t\tif(s == \"0\" && i == 0) break;\n\t\troc = 0;\n\t\tt = -1;\n\t\tfound = false;\n\t\tans = '#';\n\t\ts = \"(\" + s;\n\t\ts += \")\";\n\t\tgenome();\n\t\tif(ans == '#') cout<<0<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstring s;\nint pos;\n\nstruct NODE{\n\tstring s;\n\tlong long size;\n\tvector< pair<NODE*,int> > ch;\n};\n\n\nNODE* getStringNode(){\n\tNODE *ans = new NODE();\n\twhile(s[pos] >= 'A' && s[pos] <= 'Z'){\n\t\tans->s += s[pos++];\n\t}\n\tans->size = (ans->s).size();\n\treturn ans;\n}\nint getNumber(){\n\tint ans = 0;\n\twhile(s[pos] >= '0' && s[pos] <= '9'){\n\t\tans = ans * 10 + s[pos++]-'0';\n\t}\n\treturn ans;\n}\n\nNODE* parse(){ \n\tNODE *mine = new NODE();\n\t\n\tmine->size = 0;\n\t\n\tint coef = 1;\n\twhile(s[pos] != ')'){\n\t\t//cout << s[pos] << \" < \" << pos << \" \" << s << endl;\n\t\tif( s[pos] == '('){\n\t\t\tpos++;\n\t\t\tmine->ch.push_back(make_pair(parse(),coef));\n\t\t\tcoef = 1;\n\t\t}else if('1' <= s[pos] && s[pos] <= '9'){\n\t\t\tcoef = getNumber();\n\t\t}else{\n\t\t\t(mine->ch).push_back(make_pair(getStringNode(),coef));\n\t\t\tcoef = 1;\n\t\t}\n\t}\n\t\n\t//cout << mine->ch.size() << endl;\n\tfor(int i = 0 ; i < (mine->ch).size() ; i++){\n\t\t//cout << \" \" << (mine->ch)[i].second << \" \" << mine->ch[i].first->size << endl;\n\t\tmine->size += (mine->ch)[i].second * mine->ch[i].first->size;\n\t\tmine->size = min(2000000ll,mine->size);\n\t}\n\tpos++;\n\treturn mine;\n}\nchar f(NODE *root,int K){\n\tif( root->s.size() != 0 ){\n\t\treturn root->s[K];\n\t}\n\t\n\tfor(int i = 0 ; i < root->ch.size() ; i++){\n\t\tlong long C = (root->ch)[i].second * root->ch[i].first->size;\n\t\tif( K < C ){\n\t\t\tK %= root->ch[i].first->size;\n\t\t\treturn f(root->ch[i].first,K);\n\t\t}else{\n\t\t\tK -= C;\n\t\t}\n\t}\n\treturn '0';\n}\n\nint main(){\n\tint n;\n\twhile(cin >> s >> n && s != \"0\"){\n\t\tpos = 0;\n\t\ts += \")\";\n\t\tNODE *root = parse();\n\t\t//cout << root->size << endl;\n\t\tcout << f(root,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num;\n  tree(): num(1) {}\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1000000) { num = 1000000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "1>------ ?????????????§?: ???????????§??????: 1145, ?§????: Debug Win32 ------\n1>C:\\Program Files (x86)\\MSBuild\\Microsoft.Cpp\\v4.0\\V120\\Microsoft.CppBuild.targets(364,5): warning MSB8004: Output Directory does not end with a trailing slash.  This build instance will add the slash as it is required to allow proper evaluation of the Output Directory.\n1>Source.cpp\n1>c:\\users\\owner\\????????°??????\\aoj\\1145\\source.cpp(93): warning C4244: '?????°' : 'll' ?????? 'unsigned int' ??????????????§????????????????????±?????????????????§??????????????????\n1>1145.vcxproj -> C:\\Users\\Owner\\????????°??????\\AOJ\\1145\\.\\1145.exe\n1>???????????§?????? \"1145.vcxproj\" ????????????????????????????????????\n========== ?????????: 1 ??£????????????0 ??±??????0 ??´??°?????????0 ???????????? =========="
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\n\nint a[200020]={0};\nstring s,t,tt;\nvector<int> G[100000];\nint b[200020];\nchar c[200020];\nint kosuu=0;\nint kazu[200020];\nint nu(int i){\n\tint r=0;\n\tfor(int j=i;j<=s.length();j++){\n\t\tif(s[j]<='9' &&s[j]>='0'){\n\t\tr*=10;\n\t\tr += s[j]-'0';\n\t\t}\n\t\telse break;\n\t}\n\treturn r;\n}\n\nvoid dfs(int i,int j,int oya){\n\tif(i>j) return;\n\tkosuu++;\n\tint r=kosuu;\n//\tcout<<i<<\" \"<<j<<\" \"<<oya<<endl;\n//\tcout<<oya<<\" \"<<r<<endl;\n\tif(s[i]>='A'&&s[i]<='Z'){\n\t\tG[oya].pb(r);\n\t\t\n\t\tb[r]=1;\n\t\tc[r]=s[i];\n\t\tdfs(i+1,j,oya);\n\t}\n\telse{\n\t\tG[oya].pb(r);\n\t\tb[r]=nu(i);\n\t\tif(s[a[i]]=='('){\n\t\tdfs(a[a[i]]+1,j,oya);\n\t\tdfs(a[i]+1,a[a[i]]-1,r);\n\t\t}\n\t\telse{\n\t\t\tdfs(a[i]+1,j,oya);\n\t\t\tc[r]=s[a[i]];\n\t\t}\n\t}\n}\n\n\nint kei(int u){\n\tint r=0;\n\tif(G[u].size()==0){\n\t\tkazu[u]=1;\n\t\treturn 1;\n\t}\n\tfor(int j=0;j<G[u].size();j++) r += b[G[u][j]]*kei(G[u][j]);\n\tkazu[u]=r;\n\t//cout<<\"kosuu\"<<u<<\" \"<<r<<endl;\n\treturn r;\n}\nchar ans;\n\nvoid ch(int oya,int r){\n\tint u=0;\n\tif(kazu[oya]==1){\n\t\tans=c[oya];\n\t\treturn;\n\t} \n\twhile(1){\n\t\t\n\t\tif(kazu[G[oya][u]]*b[G[oya][u]]<r) r-=kazu[G[oya][u]]*b[G[oya][u]];\n\t\telse{\n\t\t\tr %= kazu[G[oya][u]];\n\t\t\tif(r==0) r=kazu[G[oya][u]];\n\t\t\tch(G[oya][u],r);\n\t\t\treturn;\n\t\t}\n\t\tu++;\n\t}\n}\n\nsigned main(){\n\n\t\n\twhile(1){\n\t\t//string s;\n\t\tint r;\n\t\tint na,nb;\n\tcin>>s>>r;\n\t\tif(s==\"0\" && r==0) return 0;\n\t//\ts=\"1(\"+s+\")\";\n\t\tfor(int i=0;i<100000;i++){\n\t\t\tG[i].clear();\n\t\t\tkazu[i]=0;\n\t\t}\n\t\tint i;\n\t\tstack<int> st;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s[i]=='('){\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t\tif(s[i]==')'){\n\t\t\tint \ty=st.top();\n\t\t\t\tst.pop();\n\t\t\t\ta[y]=i;\n\t\t\t}\n\t\t\tif(s[i]>='0' && s[i]<='9'){\n\t\t\t\tint g=i+1;\n\t\t\t\twhile(s[g]>='0' && s[g]<='9')g++;\n\t\t\t\ta[i]=g;\n\t\t\t}\n\t\t}\n\t\t\n\t\tkosuu=0;\n\t//\tfor(int i=0;i<s.length();i++) cout<<a[i]<<\" \";\n\t//\tcout<<endl;\n\t\tdfs(0,s.length()-1,0);\n//\tcout<<\tkei(0)<<endl;\n\t\tif(kei(0)<=r) cout<<0<<endl;\n\t\telse{\n\t\tch(0,r+1);\n\t\tcout<<ans<<endl;\n\t\t}\n\t}\n\t\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\nconst int MAX = 1000001;\n\nclass Node\n{\npublic:\n\tchar c;\n\tint num;\n\tint total;\n\tvector<Node> child;\n\tNode(int num0, char c0){\n\t\tnum = num0;\n\t\tc = c0;\n\t\ttotal = 0;\n\t}\n};\n\nvoid solve(string s, int a)\n{\n\tNode root(1, '(');\n\tNode* pNode = &root;\n\tstack<Node*> stkNode;\n\tistringstream iss(s);\n\n\tfor(;;){\n\t\tint tmp;\n\t\tif(!(iss >> tmp)){\n\t\t\tif(iss.eof())\n\t\t\t\tbreak;\n\t\t\ttmp = 1;\n\t\t\tiss.clear();\n\t\t}\n\t\tchar c;\n\t\tiss >> c;\n\t\tif(c == ')'){\n\t\t\tpNode = stkNode.top();\n\t\t\tstkNode.pop();\n\t\t\tpNode->total += pNode->child.rbegin()->total * pNode->child.rbegin()->num;\n\t\t\tif(pNode->total > MAX)\n\t\t\t\tpNode->total = MAX;\n\t\t}else{\n\t\t\tpNode->child.push_back(Node(tmp, c));\n\t\t\tif(c == '('){\n\t\t\t\tstkNode.push(pNode);\n\t\t\t\tpNode = &(*pNode->child.rbegin());\n\t\t\t}else{\n\t\t\t\tpNode->child.rbegin()->total = 1;\n\t\t\t\tpNode->total += tmp;\n\t\t\t\tif(pNode->total > MAX)\n\t\t\t\t\tpNode->total = MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(pNode->total <= a){\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\n\tfor(;;){\n\t\ta %= pNode->total;\n\t\tfor(int i=0; ; ++i){\n\t\t\tif(a < pNode->child[i].total * pNode->child[i].num){\n\t\t\t\tpNode = &(pNode->child[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta -= pNode->child[i].total * pNode->child[i].num;\n\t\t}\n\t\tif(pNode->c != '('){\n\t\t\tcout << pNode->c << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(;;){\n\t\tstring s;\n\t\tint a;\n\t\tcin >> s >> a;\n\t\tif(s == \"0\" && a == 0)\n\t\t\tbreak;\n\n\t\tsolve(s, a);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct ll {\n  long long rn, cn;\n  string str;\n  struct ll *bNext;\n  struct ll *cNext;\n  ~ll(){\n    if (bNext)\n      delete bNext;\n    if (cNext)\n      delete cNext;\n  }\n};\n\nstring S;\n\npair<int, int> getNum(int I)\n{ \n  int n = 0;\n  /*if (S[I] == '(') {\n    I++;\n    }*/\n  while (isdigit(S[I])) {\n    n = n * 10 + S[I++] - '0';\n  }\n  return make_pair(n, I);\n}\n\n\npair<string, int> getString(int I)\n{\n  string str = \"\";\n  while (isalpha(S[I])) {\n    str += S[I++];\n  }\n  return make_pair(str, I);\n}\n\npair<ll*, int> getAChar(int I)\n{\n  ll* tmp = new ll;\n  tmp->str = \"\" + S[I];\n  tmp->rn = 0;\n  tmp->cn = 1;\n  tmp->cNext = NULL;\n  tmp->bNext = NULL;\n  return make_pair(tmp, I + 1);\n}\n\n\npair<ll*, int> parser(int I)\n{\n  ll* sList = new ll;\n  ll** pList = &sList;\n\n  while (I < S.size() && S[I] != ')') {\n    //cout << \"init \"<< S[I] << endl;\n    ll *str = new ll;\n    if (isdigit(S[I])) {\n      //cout << S[I] << endl;       \n      pair<int, int> t = getNum(I);\n      str->rn = t.first;\n      I = t.second;\n\n      //cout << (str->rn) << endl;            \n\n      if (S[I] == '(') {\n        pair<ll*, int> t = parser(I + 1);\n        str->cNext = t.first;\n        I = t.second;\n      } else {\n\tS = S.substr(0, I) + '(' + S[I] + ')' + S.substr(I+1, S.size() - I - 1);\n        //cout << S[I + 1] << endl;        \n        pair<ll*, int> t = parser(I + 1);\n        str->cNext = t.first;\n        I = t.second;\n      }\n      //cout << (str->rn) << endl; \n      //cout << (str->str) << endl;            \n    } else if (isalpha(S[I])) {\n      //cout << S[I] << endl;\n\n      pair<string, int> t = getString(I);\n      str->rn = t.first.size();\n      str->str = t.first, I = t.second;\n      str->cn = str->str.size();\n            \n      str->cNext = NULL;\n\n      //cout << (str->str) << endl;      \n\n    }\n    *pList = str;\n    pList = &str->bNext;\n  }  \n  *pList = NULL;\n  return make_pair(sList, I + 1);\n}\n\nvoid check(ll* str)\n{\n  if (!str) {\n    return;\n  }\n  if (str->rn == 0) {\n    cout << \"str = \"<< str->str << endl;\n    cout << \"cn = \"<< str->cn << endl;\n    //if (!str->bNext && !str->cNext) {cout << \"ok\" << endl << endl;}\n    check(str->bNext);\n  } else {\n    cout << \"n rn = \" << str->rn << endl;\n    cout << \"n cn = \" << str->cn << endl;\n    //cout << \"cn = \"<< str->cn << endl;    \n    check(str->cNext);        \n    check(str->bNext);\n  }\n}\n\nlong long parser2(ll* str)\n{\n  long long n = 0;\n  for (ll* i = str->cNext; i; i = i->bNext) {\n    if (i->cNext) {\n      i->cn = parser2(i);\n      if (i->cn >= 1e6) {i->cn = 1e8; n = i->cn;}\n      else {n += i->cn * i->rn;}\n    } else {\n      i->cn = i->str.size();\n      n += i->str.size();\n    }\n  }\n  return n;\n}\n\nchar parser3(ll* str, long long n)\n{\n  //cout << \"init n = \" << n << endl;\n  for (ll* i = str; i; i = i->bNext) {    \n    //cout << \"n = \" << n << endl;\n    //cout << i->str << endl;\n    if (!i->cNext && n < i->str.size()) {\n      //      cout << 1 << endl;\n      return i->str[n];      \n    } else if (n >= i->cn * i->rn) {\n      //      cout << 2 << endl;\n      n -= i->cn * i->rn;\n    } else {      \n      //      cout << 4 << endl;\n      n = n % i->cn;\n      return parser3(i->cNext, n);\n    } \n  } \n}\n\nint main()\n{\n  int n;\n\n  while (cin >> S >> n) {\n    if (S == \"0\" && n == 0) {\n      break;\n    }\n    cin.ignore();\n    pair<ll*, int> t = parser(0);\n    ll *a = new ll;\n    a->cNext = t.first;\n    a->bNext = NULL;\n    //check(t.first);\n    //cout << \"hoge\" <<endl;\n    a->cn = parser2(a);\n    // cout << a->cn << endl;\n    //check(t.first);\n    if (n < a->cn) {cout << parser3(a->cNext, n) << endl;}\n    else {cout << 0 << endl;}\n    delete a;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\ntypedef string::const_iterator State;\nclass ParseError {};\nstring expression(State&);\nstring ch(State&);\nint number(State&);\n\nint m;\nstring s;\nstring expression(State &begin) {\n\tstring ret = \"\", tmp = \"\";\n\tint num = 1;\n\t//cout << *begin << \" \" << begin - s.begin() << endl;\n\tif(isdigit(*begin)) {\n\t\tnum = number(begin);\n\t\t//begin++;\n\t}\n\tif(*begin == '(') {\n\t\tbegin++;\n\t\ttmp = expression(begin);\n\t\tbegin++;\n\t} else if(isupper(*begin)) {\n\t\ttmp = ch(begin);\n\t\t//begin++;\n\t}\n\n\t//cout << \"num:\" << num << \" tmp:\" << tmp << endl;\n\tREP(i, num) {\n\t\tif((int)ret.size() > m) return ret;\n\t\tret += tmp;\n\t}\n\n\t//cout << ret << endl;\n\tif(begin-s.begin() < (int)s.size() && *begin == ')') return ret;\n\tif(begin-s.begin() < (int)s.size()) {\n\t\t//cout << \"end\" << *begin << endl;\n\t\tret += expression(begin);\n\t}\n\t//cout << *begin << \" ret:\" << ret << endl;\n\treturn ret;\n}\n\n//???????????????\nstring ch(State &begin) {\n\tstring ret;\n\twhile(1) {\n\t\tif(isupper(*begin)) {\n\t\t\tret += *begin;\n\t\t\tbegin++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"char\" << ret << endl;\n\treturn ret;\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(1) {\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\t\t//REP(i, n) REP(j, n)\n\t\tState begin = s.begin();\n\t\tstring ans = expression(begin);\n\t\t//cout << \"ans:\" << ans << endl;\n\t\tif((int)ans.size() <= m) cout << \"0\" << endl;\n\t\telse cout << ans[m] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint pos;\nstruct Node;\nvector<Node> global;\nstruct Node {\n  string pat;\n  vector<P> xs;\n  bool leaf;\n  char chr;\n  long long len;\n\n  Node(char c) {\n    leaf = true;\n    chr = c;\n    len = 1;\n    pat=chr;\n  }\n  Node(string s) {\n    pat = s;\n    leaf = false;\n    len = 0;\n\n    int num = 0;\n    rep(i, s.length()) {\n      char c = s[i];\n      if ('0' <= c && c <= '9') num = 10*num + (int)(c-'0');\n      else {\n        if (num > 0) {\n          if (c == '(') {\n            int state = 1;\n            string t = \"\";\n            i++;\n            while (true) {\n              if (s[i] == '(') state++;\n              else if (s[i] == ')') {\n                state--;\n                if (state == 0) break;\n              }\n              t += s[i];\n              i++;\n            }\n            global.pb(Node(t));\n            xs.pb(P(global.size()-1, num));\n            rep(_, num) {\n              len += 1LL * global.back().len;\n              if (len > pos) return;\n            }\n          }\n          else {\n            xs.pb(P(c-'A', num));\n            len += num;\n          }\n          num = 0;\n        }\n        else {\n          xs.pb(P(c-'A', 1));\n          len += 1;\n        }\n      }\n      if (len > pos) return;\n    }\n  }\n\n  char get(int offset) {\n    assert(offset < len);\n    if (leaf) return chr;\n    long long l = 0;\n    for (P p : xs) {\n      long long u = global[p._1].len * p._2;\n      if (l+u > offset) {\n        return global[p._1].get((offset - l) % global[p._1].len);\n      }\n      l+=u;\n    }\n    return '0';\n  }\n};\n\nchar parse(string s) {\n  Node top(s);\n  if (top.len <= pos) return '0';\n  return top.get(pos);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  string s;\n  rep(i, 26) global.pb(Node((char)('A'+i)));\n\n  while (cin >> s >> pos) {\n    if (s == \"0\") break;\n    cout << parse(s) << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x334334334LL\n\ntypedef long long int LLI;\ntypedef pair<int, LLI> Pair;\n\nint n;\nint I;\nint num_node;\nint ls[1145141];\nchar buf[1145141];\nbool is_leaf[1145141];\nLLI size[1145141];\nvector<Pair> es[1145141];\n\nint dfs1(int k, int idx) {\n  char *res;\n  es[idx].clear();\n  size[idx] = 0;\n  while (k < n && buf[k] != ')') {\n    int g = num_node++;\n    LLI t = strtol(buf+k, &res, 10);\n    if (buf+k == res) {\n      t = 1;\n      size[g] = 0;\n      ls[g] = k;\n      is_leaf[g] = true;\n      while (k < n && 'A' <= buf[k] && buf[k] <= 'Z') {\n        size[g]++;\n        k++;\n      }\n    } else {\n      is_leaf[g] = false;\n      if (*res == '(') {\n        k = dfs1(res-buf+1, g);\n      } else {\n        k = res-buf;\n        size[g] = 0;\n        ls[g] = k;\n        is_leaf[g] = true;\n        while (k < n && 'A' <= buf[k] && buf[k] <= 'Z') {\n          size[g]++;\n          k++;\n        }\n      }\n    }\n    es[idx].push_back(Pair(g, t));\n    size[idx] = min(INF, size[idx] + size[g]*t);\n  }\n  return k+1;\n}\n\nvoid dfs2(int v, int I) {\n  //printf(\"I: %d\\n\", I);\n  //printf(\"size[%d]: %lld\\n\", v, size[v]);\n  //printf(\"is_leaf[%d]: %d\\n\", v, is_leaf[v]);\n  //if (is_leaf[v]) printf(\"ls[%d]: %d\\n\", v, ls[v]);\n  if (is_leaf[v] && I < size[v]) {\n    printf(\"%c\\n\", buf[ls[v]+I]);\n    return;\n  }\n\n  bool found = false;\n  //printf(\"%d:\", v);\n  for (int i=0; i<es[v].size(); i++) {\n    Pair p = es[v][i];\n    int u = p.first;\n    LLI t = p.second;\n    \n    //printf(\" %d\", u);\n    if (I < size[u]*t) {\n      found = true;\n      dfs2(u, I%size[u]);\n      break;\n    } else I -= size[u]*t;\n  }\n  //puts(\"\");\n\n  if (!found) puts(\"0\");\n}\n\nint main() {\n  while (1) {\n    scanf(\"%s%d\", buf, &I);\n    if (buf[0] == '0' && I == 0) return 0;\n\n    n = strlen(buf);\n    num_node = 1;\n    assert(dfs1(0, 0) >= n);\n    dfs2(0, I);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n\nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n\nvoid dfs(int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    while('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int x=r.first,num=r.second;\n      int y=r.first,z=r.first;\n      if(s[x]=='('){\n\tint c=1;\n\ty=x+1;\n\tfor(z=y;z<=e&&c;z++){\n\t  if(s[z]=='(')c++;\n\t  if(s[z]==')')c--;\n\t}\n\tp=z;\n\tz-=2;\n\twhile(num--)dfs(y,z);\n      }else{\n\twhile(num--)ans+=s[x];\n\tp=x+1;\n      }\n    }\n    while('A'<=s[p]&&s[p]<='Z')ans+=s[p++];\n  }\n}\n\nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,s.size()-1);\n    if(ans.size()>=n+1)cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n\nstring genome() {\n\tstring res = \"\";\n\tif(s[roc] == '(') {\n\t\t++roc;\n\t\twhile(s[roc] != ')' && !found) {\n\t\t\tif(s[roc] >= 'A' && s[roc] <= 'Z') {\n\t\t\t\tres += s[roc];\n\t\t\t\t++t;\n\t\t\t\tif(t == i && ans == '#') {\n\t\t\t\t\tans = s[roc];\n\t\t\t\t\tfound = true;\n\t\t\t\t\t++roc;\n\t\t\t\t\tt = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++roc;\n\t\t\t} else {\n\t\t\t\tll roc_buf = roc;\n\t\t\t\twhile(s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\t\t\tint roop = stoi(s.substr(roc_buf, roc - roc_buf));\n\t\t\t\tstring rooped = genome();\n\t\t\t\tif(!found) {\n\t\t\t\t\tREP(j, roop - 1) {\n\t\t\t\t\t\tif(t + rooped.size() < i) {\n\t\t\t\t\t\t\tt += rooped.size();\n\t\t\t\t\t\t\tres += rooped;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(ans == '#') {\n\t\t\t\t\t\t\t\tans = rooped[(i - t) - 1];\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tt = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres += rooped;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t} else {\n\t\tres += s[roc];\n\t\t++t;\n\t\tif(t == i) {\n\t\t\tans = s[roc];\n\t\t\tfound = true;\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s>>i;\n\t\tif(s == \"0\" && i == 0) break;\n\t\troc = 0;\n\t\tt = -1;\n\t\tfound = false;\n\t\tans = '#';\n\t\ts = \"(\" + s;\n\t\ts += \")\";\n\t\tgenome();\n\t\tif(ans == '#') cout<<0<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nchar ans;\nvoid saiki(string s, int &out, int &idx) {\n\tint num = 0;\n\twhile (idx<s.length()) {\n\t\tif (isdigit(s[idx])) {\n\t\t\tnum *= 10;\n\t\t\tnum += s[idx] - '0';\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tint idx2;\n\t\t\tREP(i, num) {\n\t\t\t\tidx2 = idx;\n\t\t\t\tsaiki(s, out, idx2);\n\t\t\t\tif (ans != '0'||out<0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tidx = idx2;\n\t\t\tnum = 0;\n\t\t}\n\t\telse if (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tstring s2 = \"\";\n\t\t\twhile ('A' <= s[idx] && s[idx] <= 'Z') {\n\t\t\t\ts2 +=s[idx];\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tREP(i,max(1,num))\n\t\t\tif (out < s2.length()) {\n\t\t\t\tans = s2[out];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout -= s2.length();\n\t\t\t\tif (out < 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tstring s;\n\tint out;\n\twhile (cin >> s >> out, s != \"0\") {\n\t\tint idx = 0;\n\t\tans = '0';\n\t\tsaiki(s, out, idx);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[s1.pos] == '(') pos++;\n      State s2 = expr(str,pos);\n      \n      string tmp = \"\";\n      for(int i = 0; i < s1.int_result; i++){\n        tmp += s2.str_result;\n        if(tmp.size() > 1500000) break;\n      }\n      result += tmp;\n      pos = s2.pos + 1;\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    if(genome == \"0\" && pos == 0) break;\n    string result = expr(genome,0).str_result;\n    if(pos < result.size()){\n      cout << result[pos] << endl;      \n    }\n    else{\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring expr(string const& s, int& p, int n);\nstring term(string const& s, int& p, int n);\n\nint number(string const& s, int& p) {\n    int res = 0;\n    while(isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\nstring str(string const& s, int& p) {\n    string res;\n    while(isalpha(s[p])) {\n        res += s[p++];\n    }\n    return res;\n}\n\nstring expr(string const& s, int& p, int n) {\n    string res;\n    while(p < s.size() && res.size() <= n && s[p] != ')') {\n        auto t = term(s, p, n);\n        res += t;\n    }\n    return res;\n}\n\nstring term(string const& s, int& p, int n) {\n    string res;\n    if(isdigit(s[p])) {\n        int k = number(s, p);\n        string t;\n        if(s[p] == '(') {\n            t = expr(s, ++p, n);\n            ++p;\n        } else {\n            t = str(s, p);\n        }\n        for(int i=0; i<k && res.size() <= n; ++i) {\n            res += t;\n        }\n    } else if(isalpha(s[p])) {\n        res = str(s, p);\n    } else {\n        assert(false);\n    }\n    return res;\n}\n\n\nint main() {\n    string s;\n    while(cin >> s, s != \"0\") {\n        int n;\n        cin >> n;\n        int p = 0;\n        auto res = expr(s, p, n);\n        if(res.size() <= n) {\n            cout << 0 << endl;\n        } else {\n            cout << res[n] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nInt g(string s){\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s))return sz(s);\n\tInt c=0,q,r,times=0;\n\trepn0(q,p,sz(s)-1){\n\t\tif(!isdigit(s[q]))break;\n\t\ttimes=times*10+s[q]-'0';\n\t}\n\tif(s[q]!='('){\n\t\ts=s.substr(0,q)+\"(\"+s.substr(q,1)+\")\"+s.substr(q+1);\n\t}\n\trep0(r,sz(s)){\n\t\tif(s[r]=='(')++c;\n\t\tif(s[r]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\treturn min(1000000LL,p+times*g(s.substr(q+1,r-q-1))+g(s.substr(r+1)));\n}\n\nchar f(string s,Int i){\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s)){\n\t\tif(i<p)return s[i];\n\t\telse return '0';\n\t}\n\tif(i<p)return s[i];\n\ts=s.substr(p);\n\ti-=p;\n\tInt c=0,q,times=0;\n\trep0(p,sz(s)){\n\t\tif(!isdigit(s[p]))break;\n\t\ttimes=times*10+s[p]-'0';\n\t}\n\tif(s[p]!='('){\n\t\ts=s.substr(0,p)+\"(\"+s.substr(p,1)+\")\"+s.substr(p+1);\n\t}\n\trep0(q,sz(s)){\n\t\tif(s[q]=='(')++c;\n\t\tif(s[q]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\tInt len=g(s.substr(p+1,q-p-1));\n\tif(len*times>i){\n\t\ti%=len;\n\t\treturn f(s.substr(p+1,q-p-1),i);\n\t}else{\n\t\ti-=len*times;\n\t\treturn f(s.substr(q+1),i);\n\t}\n}\n\nint main() {\n\tstring s;\n\tInt i;\n\tIL{\n\t\tcin>>s>>i;\n\t\tif(s==\"0\"&&i==0)break;\n\t\tcout<<f(s,i)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef pair<ll,ll> pll;\n\n#define reps(i,f,n) for(int i = int(f); i <= int(n); i++)\n#define rep(i,n) reps(i,0,int(n)-1)\n#define rrep(i,n) for(int i = n-1; i >= 0; i--)\n\n#define all(x) (x).begin(),(x).end()\n#define X first\n#define Y second\n\n#define sz size()\n#define eb emplace_back\n\nvector<int> x[1024];\nstring y[1024];\nint cnt;\n\nvoid parse(string s){\n  int ind = 0;\n  int l = s.size();\n  int num = 0;\n  cnt = 0;\n  vector<int> nums;\n  rep(i,1024)x[i].clear();\n  rep(i,1024)y[i] = \"\";\n\n  while(ind<l){\n    //cout << \"num\" << num << endl;\n    if(s[ind] == '('){\n      nums.push_back(num);\n      num = 0;\n    }else if('0' <= s[ind] && s[ind] <= '9'){\n      num *= 10;\n      num += s[ind]-'0';\n    }else if(s[ind] == ')'){\n      //rep(i, nums.size()) x[cnt].push_back(nums[i]);\n      //if(nums.size() == 0)x[cnt].push_back(1);\n      //cnt++;\n      nums.pop_back();\n    }else{\n      do{\n        y[cnt] += s[ind];\n        ind++;\n      }while( ind < l && 'A' <= s[ind] && s[ind] <= 'Z');\n      ind--;\n\n      if(num != 0){\n        rep(i, nums.size()) x[cnt].push_back(nums[i]);\n        x[cnt].push_back(num);\n        num = 0;\n        cnt++;\n      }else{\n        rep(i,nums.size())x[cnt].push_back(nums[i]);\n        if(nums.size()==0)x[cnt].push_back(1);\n        cnt++;\n      }\n    }\n    ind++;\n  }\n  if(y[cnt] != \"\"){\n    rep(i, nums.size()) x[cnt].push_back(nums[i]);\n    if(num != 0)x[cnt].push_back(num);\n    if(nums.size() == 0)x[cnt].push_back(1);\n    cnt++;\n  }\n}\n\nint main(void){\n  string s;\n  int p;\n  while(1){\n    cin >> s >> p;\n    if(s[0] == '0')break;\n    parse(s);\n\n    /*\n    rep(i,cnt){\n      cout << y[i] << endl;\n      rep(j,x[i].size()){\n        cout << x[i][j] << \",\";\n      }cout << endl;\n    }\n    */\n\n    rep(i,cnt){\n      int q = y[i].size();\n      rep(j, x[i].size()){\n        q *= x[i][j];\n        if(p < q){\n          cout << y[i][p%y[i].size()] << endl;\n          p -= q;\n          break;\n        }\n      }\n      p -=q;\n      if(p < 0)break;\n    }\n    if(p >= 0)cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\nbool watch=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(const string str,const int from,const int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(ll i = 0; i < cnt; i++){\n\t\t\t\t\t//if(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t//\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t//\tif(sum<idx){\n\t\t\t\t\t//\t\tcp=sum;\n\t\t\t\t\t//\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t//\t\tcontinue;\n\t\t\t\t\t//\t}\n\t\t\t\t\t//}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(ll i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\twatch=true;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nint pos,n;\nstring s,t,p;\nstring f();\nstring expr(){\n\tstring a=f();\n\twhile(isdigit(s[pos])||isalpha(s[pos])){\n\t\tif(a.size()>n)\n\t\t\tbreak;\n\t\ta+=f();\n\t}\n\treturn a;\n}\nstring f(){\n\tt=\"\";\n\tif(isdigit(s[pos])){\n\t\tint ret=0,i=0;\n\t\tfor(;isdigit(s[pos]);pos++){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t}\n\t\tp=f();\n\t\tfor(;i<ret;i++){\n\t\t\tt+=p;\n\t\t\tif(t.size()>n)\n\t\t\t\tbreak;\n\t\t}\n\t}else if(s[pos]=='('){\n\t\tpos++;\n\t\tt=expr();\n\t\tpos++;\n\t}else{\n\t\tfor(;isalpha(s[pos]);pos++){\n\t\t\tt+=s[pos];\n\t\t\tif(t.size()>n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\nint main(){\n\twhile(cin>>s>>n,s!=\"0\"||n){\n\t\tpos=0;\n\t\ts+=\"#\";\n\t\tstring t=expr();\n\t\tif(t.size()-1<n)\n\t\tcout<<0<<endl;\n\t\telse\n\t\tcout<<t[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nstring in;\nchar search(int s, int& e, int p, int& len){\n\tif(s==in.size()){\n\t\tlen=0;\n\t\treturn 0;\n\t}\n\t//cout << s << \", \" << p << \", \" << in[s] << endl;\n\tif(in[s]==')'){\n\t\tlen=0;\n\t\te=s+1;\n\t\treturn 0;\n\t}\n\tif(in[s]=='('){\n\t\treturn search(s+1,e,p,len);\n\t}\n\telse\n\t{\n\t\tint r=s;\n\t\tint v=0;\n\t\twhile('0'<=in[r]&&in[r]<='9'){\n\t\t\tv*=10;\n\t\t\tv+=in[r]-'0';\n\t\t\tr++;\n\t\t}\n\t\tif(v>0){\n\t\t\tint l=0;\n\t\t\tchar c;\n\t\t\tif(in[r]=='(')\n\t\t\t{\n\t\t\t\tc=search(r,e,p,l);\n\t\t\t\tif(c){\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t\tif(p<l*v){\n\t\t\t\t\treturn search(r,e,p%l,l);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(p<v){\n\t\t\t\t\treturn in[r];\n\t\t\t\t}\n\t\t\t\tl=1;\n\t\t\t\te=r+1;\n\t\t\t}\n\t\t\tp-=l*v;\n\t\t\tlen=l*v;\n\t\t}\n\t\telse{\n\t\t\tif(p==0){\n\t\t\t\treturn in[s];\n\t\t\t}\n\t\t\tp--;\n\t\t\te=s+1;\n\t\t\tlen=1;\n\t\t}\n\t}\n\tint len2;\n\tchar ret=search(e,e,p,len2);\n\tlen+=len2;\n\treturn ret;\n}\nint main() {\n\tint pos=0;\n\twhile(cin >> in >> pos){\n\t\tif(in[0]=='0'&&pos==0){\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << in << \", \" << pos << endl;\n\t\tint e,len;\n\t\tchar c=search(0,e,pos,len);\n\t\tif(c==0){\n\t\t\tc='0';\n\t\t}\n\t\tcout << c << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[2];\nint n,ima;\n\nint stoi(int &i){\n  int res=0;\n  while('0'<=str[ima][i]&&str[ima][i]<='9')res=res*10+str[ima][i]-'0',i++;\n  return res;\n}\n\n\nint main(){\n  while(1){\n    cin>>str[0]>>n;\n    if(str[0]==\"0\"&&n==0)break;\n    str[1].clear();\n    ima=0;\n    int f=1;\n    while(f){\n      f=0;\n      for(int i=0;i<(int)str[ima].size();i++){\n\tif(!('0'<=str[ima][i]&&str[ima][i]<='9')) str[!ima]+=str[ima][i];\n\telse {\n\t  f=1;\n\t  int num=stoi(i);\n\t  string pls;\n\t  if(str[ima][i]!='(') pls+=str[ima][i];\n\t  else {\n\t    int c=1;\n\t    while(c){\n\t      i++;\n\t      if(str[ima][i]=='(')c++;\n\t      if(str[ima][i]==')')c--;\n\t      if(c) pls+=str[ima][i];\n\t    }\n\t  }\n\t  while(num--&&(int)str[!ima].size()<=n) str[!ima]+=pls;\n\t}\n      }\n      str[ima].clear();\n      ima=!ima;\n    }\n    if((int)str[ima].size()<=n) cout <<0<<endl;\n    else cout << str[ima][n]<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      if(!s.empty() && !isdigit(s[0])) { return; }\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint n;\nstring dfs(int x){\n  int a=1,t=0;\n  string str,res;\n  for(int i=x;0<a;i++){\n    if('0'<=s[i]&&s[i]<='9')t*=10,t+=s[i]-'0';\n    else if(s[i]=='('&&a==1){\n      res=dfs(i+1);\n      t=max(1,t);\n      while(t--)str+=res;\n      a++;\n    }\n    else if(s[i]==')')a--,t=0;\n    else if(a==1)str+=s[i];\n  }\n  return str;\n}\nint main(){\n  while(cin>>s>>n){\n    s+=\")\";\n    for(int i=0;i<s.size();i++)\n      if('0'<=s[i]&&s[i]<='9'&&s[i+1]!='(')\n\ts=s.substr(0,i+1)+'('+s[i+1]+')'+s.substr(i+2,s.size());\n      string ans=dfs(0);\n      if(ans.size()>n)\n      cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstring st;\nint now = 0;\n\nstring getst() {\n\tstring genom;\n\twhile (isalpha(st[now])) {\n\t\tgenom += st[now];\n\t\tnow++;\n\t}\n\treturn genom;\n}\nint getcount() {\n\tlong long int num = 0;\n\twhile (isdigit(st[now])) {\n\t\tnum = num * 10 + st[now] - '0';\n\t\tnow++;\n\t}\n\treturn num;\n}\n\npair<int,char> check(long long int rest,long long int kakeru) {\n\tif (kakeru > 1e8) {\n\t\tkakeru = 1e8;\n\t}\n\tlong long int num = 1;\n\tbool isstart = true;\n\twhile (1) {\n\t\tif (st.size() <= now)break;\n\t\tif (st[now] == '(') {\n\t\t\tnow++;\n\t\t\tpair<int,char>p=check(rest,kakeru*num);\n\t\t\tif (p.second == '0') {\n\t\t\t\trest = p.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn make_pair(0,p.second);\n\t\t\t}\n\t\t}\n\t\telse if (st[now] == ')') {\n\t\t\tnow++;\n\t\t\tbreak;\n\t\t}\n\t\telse if(isalpha(st[now])){\n\t\t\tstring genom= getst();\n\t\t\tif (genom.size()*kakeru*num > rest) {\n\t\t\t\treturn make_pair(0, genom[rest%genom.size()]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trest -= genom.size()*kakeru*num;\n\t\t\t}\n\t\t\tnum = 1;\n\t\t}\n\t\telse {\n\t\t\tassert(isdigit(st[now]));\n\t\t\tnum = getcount();\n\t\t}\n\n\t\tisstart = false;\n\t}\n\treturn make_pair(rest, '0');\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"0\")break;\n\t\tnow = 0;\n\t\tint n; cin >> n;\n\t\tpair<int, char>p;\n\t\tchar ans=check(n,1).second;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid print_YES_NO(bool answer){cout<<(answer?\"YES\":\"NO\")<<endl;}\nvoid print_Yes_No(bool answer){cout<<(answer?\"Yes\":\"No\")<<endl;}\nvoid print_POSSIBLE_IMPOSSIBLE(bool answer){cout<<(answer?\"POSSIBLE\":\"IMPOSSIBLE\")<<endl;}\n\nchar ca[105];\nchar cs;\nLL p=0;\n\nLL check(LL a,LL n){\n\tLL b=0,c=0,d=0;\n\tbool flag=false;//1char\n\tfor(int i=a;i<strlen(ca);i++){\n\t\tif(ca[i]=='('){\n\t\t\tflag=false;\n\t\t\td=check(i+1,n);\n\t\t\t//cout<<i<<\" \"<<b<<\" \"<<d<<endl;\n\t\t\tif(d==-1)return -1;\n\t\t\tif(n<b*d){\n\t\t\t\tcheck(i+1,n%d);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tn-=b*d,c+=b*d,b=0,i=p;\n\t\t\t//cout<<i<<\" \"<<n<<endl;\n\t\t}\n\t\tif('0'<=ca[i] && ca[i]<='9')b*=10,b+=(int)ca[i]-(int)'0',flag=true;\n\t\tif(ca[i]==')'){\n\t\t\tp=i+1;\n\t\t\treturn c;\n\t\t}\n\t\tif('A'<=ca[i] && ca[i]<='Z'){\n\t\t\tif(flag){\n\t\t\t\tflag=false;\n\t\t\t\tif(n<b){\n\t\t\t\t\tcs=ca[i];\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tn-=b,c+=b,b=0;\n\t\t\t}else{\n\t\t\t\tif(n==0){\n\t\t\t\t\tcs=ca[i];\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tn--,c++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tLL n,m;\n\tLL i,j,k;\n\tLL a,b,c;\n\twhile(cin>>ca>>n){\n\t\tif(ca[0]=='0')break;\n\t\ta=check(0,n);\n\t\tif(a!=-1)cout<<0<<endl;\n\t\telse cout<<cs<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <string>\n\n#define range(i,a,b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\n\nusing namespace std;\n\nconst int imax=1234567;\n\nint n;\nstring S;\nsize_t cur=0;\n\nint digit();\nint number();\nstring expression();\n\nint digit(){\n\treturn S[cur++]-'0';\n}\n\nint number(){\n\tint res=digit();\n\twhile(isdigit(S[cur])){\n\t\tres=res*10+digit();\n\t}\n\treturn res;\n}\n\n\n\nstring expression(void){\n\tstring rec=\"\";\n\twhile(cur < n){\n\t\t//cout << cur << endl;\n\t\tif(rec.size()>=imax)\n\t\t\treturn rec;\n\n\t\tif(isupper(S[cur])){\n\t\t\n\t\t\trec+=S[cur++];\n\n\t\t}else if(isdigit(S[cur])){\n\n\t\t\tint r=number();\n\t\t\tstring c=\"\";\n\n\t\t\tif(S[cur]=='('){\n\t\t\t\tcur++;\n\t\t\t\tc=expression();\n\t\t\t}else\n\t\t\t\tc=S[cur++];\n\n\t\t\trep(i,r){\n\t\t\t\tif(rec.size()>=imax)\n\t\t\t\t\treturn rec;\n\t\t\t\trec+=c;\n\t\t\t}\n\t\t}else if(S[cur]==')'){\n\t\t\tcur++;\n\t\t\treturn rec;\n\t\t}\n\n\t}\n\treturn rec;\n}\n\nint main(void){\n\tint i;\n\twhile(cin >> S >> i){\n\t\tif(S==\"0\")\n\t\t\tbreak;\n\t\tn=S.size();\n\t\tcur=0;\n\t\tstring res=expression();\n\t\tif(i>=res.size())\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << res[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <ctime>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#ifndef M_PI\nconst double M_PI=acos(-1);\n#endif\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int((a).size()))\n#define F first\n#define S second\nint dx[]={0,1,0,-1,1,1,-1,-1},dy[]={1,0,-1,0,1,-1,1,-1};\n\nstring in;\nint p;\n\nvoid next(int& p){\n  ++p;\n  while(p<SZ(in) && in[p]!=')'){\n    if(in[p]=='(')next(p);\n    else ++p;\n  }\n  ++p;\n}\n\nll get(int po,int re){\n  ll le=0;\n  if(in[po]!='(')return 1;\n  ++po;\n  while(po<SZ(in) && in[po]!=')'){\n    if(isdigit(in[po])){\n      ll t=0;\n      while(isdigit(in[po]))t=t*10+in[po++]-'0';\n      ll cle=get(po,re);\n      if(cle==-1)return -1;\n      le+=cle*t;\n      if(in[po]=='(')next(po);\n      else ++po;\n    }else{\n      ++le;\n      ++po;\n    }\n    if(le>re)return -1;\n  }\n  return le;\n}\n\nchar rec(int po,int re){\n  while(po<SZ(in)){\n    //cout<<po<<' '<<re<<endl;\n    if(isdigit(in[po])){\n      ll t=0;\n      while(isdigit(in[po]))t=t*10+in[po++]-'0';\n      ll len=get(po,re);\n      //cout<<len<<endl;\n      int de=0;\n      if(in[po]=='(')++de;\n      if(len==-1)return rec(po+de,re);\n      else if(re<t*len)return rec(po+de,re%len);\n      re-=t*len;\n      //cout<<re<<endl;\n      if(de)next(po);\n      else ++po;\n    }else{\n      if(re==0)return in[po];\n      ++po;\n      --re;\n    }\n  }\n  ++po;\n  return '0';\n}\n\n\n\nmain(){\n  while(cin>>in>>p,in!=\"0\")\n    cout<<rec(0,p)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nstring s;\nstring buf;\nint p;\nint q;\n\nint nextint() {\n    string t;\n    while (isdigit(s[p])) {\n        t.push_back(s[p]);\n        p++;\n    }\n    return atoi(t.c_str());\n}\n\nvoid solve() {\n    if (p == s.size()) return;\n    if (buf.size() > q) return;\n    if (isupper(s[p])) {\n        buf.push_back(s[p]);\n        p++;\n        solve();\n    }\n    if (isdigit(s[p])) {\n        int n = nextint();\n        //cout << \"n: \" << n << ' ';\n        //cout << s[p] << ' ';\n        if (s[p] != '(') {\n            for (int i = 0; i < n; i++) {\n                buf.push_back(s[p]);\n            }\n            p++;\n            solve();\n            return;\n        }\n        p++;\n        int o = p;\n        for (int i = 0; i < n-1; i++) {\n            solve();\n            p = o;\n            if (buf.size() > q) return;\n        }\n        solve();\n        if (s[p] == ')') p++;\n        solve();\n    }\n}\n\nint main() {\n    while (cin >> s >> q) {\n        if (s == \"0\" && q == 0) break;\n        p = 0;\n        buf = \"\";\n        solve();\n        //cout << buf << ' ';\n        cout << (buf.size() > q ? buf[q] : '0') << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstring s;\nstring res;\nll K;\n\nbool dfs(int l,int r){\n  bool is_str=true;\n  repl(i,l,r){\n      if(s[i]=='('||s[i]==')'||isdigit(s[i]))is_str=false;\n  }\n  if(is_str){\n    res+=s.substr(l,r-l);\n    return res.length()>K;\n  }\n\n  if(isdigit(s[l])){\n    int i=l;\n    while(i<r&&isdigit(s[i]))i++;\n    int cnt=stoi(s.substr(l,i-l));\n    if(s[i]=='('){\n      int j=i+1;\n      int level=1;\n      while(j<r&&level!=0){\n        if(s[j]=='(')level++;\n        if(s[j]==')')level--;\n        j++;\n      }\n      rep(c,cnt){\n        if(dfs(i+1,j-1))return true;\n      }\n      if(dfs(j,r))return true;\n    }else{\n      rep(c,cnt){\n        if(dfs(i,i+1))return true;\n      }\n    }\n  }else{\n    if(dfs(l,l+1))return true;\n    if(dfs(l+1,r))return true;\n  }\n  return false;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>s>>K;\n    if(s==\"0\")break;\n    res=\"\";\n    int n=s.length();\n    if(!dfs(0,n))cout<<0<<endl;\n    else cout<<res[K]<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\ntypedef string::iterator State;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstring S;\n\nll g(State &itr);\nchar f(State &itr, ll n) {\n    auto itr2 = itr;\n    //cerr << *itr << \" \"<< n << endl;\n    if(*itr <= '9' && *itr >= '0') {\n        ll num = 0;\n        while(*itr <= '9' && *itr >= '0') {\n            num *= 10;\n            num += *itr - '0';\n            itr++;\n        }\n        itr2 = itr;\n        ll unit = g(itr);\n        ll ret = num * unit;\n        //cerr << *itr2 << \" \" << unit << \" \" << num << \" \"<< ret << endl;\n        if(ret <= n) {\n            return f(itr, n - ret);\n        } else {\n            n %= unit;\n            if(*itr2 == '(') itr2++;\n            return f(itr2, n);\n        }\n    }\n    //assert(*itr <= 'Z' && *itr >= 'A');\n    if(n == 0) return *itr;\n    itr++;\n    return f(itr, n - 1);\n}\n\nll g(State &itr) {\n    if(*itr == '(') {\n        itr++;\n        ll ret = 0;\n        while(*itr != ')') {\n            ret += g(itr);\n        }\n        itr++;\n        return ret;\n    }\n    if(*itr <= 'Z' && *itr >= 'A') {\n        itr++;\n        return 1;\n    }\n    if(*itr <= '9' && *itr >= '0') {\n        ll num = 0;\n        while(*itr <= '9' && *itr >= '0') {\n            num *= 10;\n            num += *itr - '0';\n            itr++;\n        }\n        ll ret = g(itr) * num;\n        return min((ll)10000000, ret);\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> S;\n        if(S == \"0\") break;\n        ll n;\n        cin >> n;\n        S = \"(\" + S + \")\";\n        auto itr = S.begin();\n        //cout << g(itr) << endl;\n        if(g(itr) <= n) {\n            cout << \"0\" << endl;\n            continue;\n        }\n        itr = S.begin();\n        itr++;\n        cout << f(itr, n) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() noexcept = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1000000) { num = 1000000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long id, nowend = 0;\nstring s;\nchar ans;\n\nlong long solve(long long now, long long req);\nvoid solve2();\n\nint main() {\n  while(1) {\n    cin >> s >> id;\n    if(s == \"0\" && id == 0) break;\n    ans = '0';\n    solve2();\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nlong long solve(long long now, long long req) {\n  long long cnt = 0, charcnt = 1;\n  string nows;\n  if(s[now] >= '0' && s[now] <= '9') {\n    while(s[now] >= '0' && s[now] <= '9') {\n      cnt *= 10;\n      cnt += s[now++] - '0';\n    }\n    charcnt = solve(now, req);\n    if(charcnt == -1) return -1;\n    cnt *= charcnt;\n    if(cnt > req) {\n      if(solve(now, req % charcnt) != -1)\n        ;\n      return -1;\n    }\n  }\n  else if(s[now] == '(') {\n    nowend = now;\n    while(nowend < s.size() && s[nowend] != ')') {\n      charcnt = solve(nowend, req - cnt);\n      if(charcnt == -1) return -1;\n      cnt += charcnt;\n    }\n    ++nowend;\n  }\n  else {\n    while(now < s.size() && s[now] >= 'A' && s[now] <= 'Z')\n      nows += s[now++];\n    if(req < nows.size()) {\n      ans = nows[req];\n      return -1;\n    }\n    nowend = now;\n    cnt = nows.size();\n  }\n  // assert(cnt > -2);\n  return cnt;\n}\n\nvoid solve2() {\n  nowend = 0;\n  while(nowend < s.size()) {\n    long long x = solve(nowend, id);\n    if(x < 0) return;\n    id -= x;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        curr->children.push_back(c);\n        c->num = ck;\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      auto c = make_shared<tree>();\n      c->s = read_s(s);\n      c->num = 1;\n      curr->children.push_back(c);\n      if(!s.empty() && !isdigit(s[0])) { return; }\n    }\n  }\n}\n\nstring ans;\n\nvoid visit(tree_ptr curr) {\n  if(ans.size() >= 1000001) { return; }\n  rep(i, curr->num) {\n    if (curr->children.empty()) {\n      ans += curr->s;\n      if(ans.size() >= 1000001) { return; }\n    }\n\n    rep(i, curr->children.size()) {\n      visit(curr->children[i]);\n    }\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  ans.clear();\n  visit(root);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans << endl;cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Node {\n  vector< Node * > child;\n  int64 mult;\n  int64 sum;\n  string s;\n\n  Node() : mult(1), sum(0) {}\n\n  char dfs(int pos) {\n    if(pos >= mult * sum) return '0';\n    pos %= sum;\n    if(s.size()) return s[pos];\n    for(auto &p : child) {\n      if(pos - p->mult * p->sum < 0) return p->dfs(pos);\n      pos -= p->mult * p->sum;\n    }\n    throw 0;\n  }\n};\n\nconst int64 LIM = 1 << 29;\n\nstring S;\nint ptr;\n\nNode *expr() {\n  if(isalpha(S[ptr])) {\n    Node *root = new Node();\n    while(isalpha(S[ptr])) root->s += S[ptr++];\n    root->sum = (int) root->s.size();\n    return root;\n  } else if(S[ptr] == '(') {\n    ++ptr;\n    Node *ret = expr();\n    ++ptr;\n    return ret;\n  } else {\n    Node *root = new Node();\n    while(isdigit(S[ptr])) {\n      int mult = 0;\n      while(isdigit(S[ptr])) mult = mult * 10 + S[ptr++] - '0';\n      auto beet = expr();\n      beet->mult = mult;\n      root->sum += min(LIM, beet->mult * beet->sum);\n      root->sum = min(LIM, root->sum);\n      root->child.emplace_back(beet);\n    }\n    return root;\n  }\n}\n\n\nint main() {\n  int idx;\n  while(cin >> S >> idx, S != \"0\") {\n    ptr = 0;\n    S += \"$\";\n    auto root = expr();\n    cout << root->dfs(idx) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<string, int> gs(const string& s, int i) {\n  string res = \"\";\n  if (i == (int)s.size()) return make_pair(res, i);\n  if('0' <= s[i] && s[i] <= '9') {\n    int v = 0;\n    while('0' <= s[i] && s[i] <= '9') {\n      v *= 10;\n      v += s[i] - '0';\n      ++i;\n    }\n    if (s[i] == '(') {\n      string ss;\n      int j;\n      tie(ss, j) = gs(s, i+1);\n      REP(i,v) {\n        if (res.size() > 1100000) break;\n        res += ss;\n      }\n      i = j+1;\n    } else {\n      res += string(v, s[i]);\n      ++i;\n    }\n  } else {\n    res += s[i];\n    ++i;\n  }\n  if (i == (int)s.size()) return make_pair(res, i);\n  if (s[i] != ')') {\n    string ss;\n    int j;\n    tie(ss, j) = gs(s,i);\n    if (res.size() <= 1100000)\n      res += ss;\n    i = j;\n  }\n  return make_pair(res, i);\n}\n\nint main() {\n  while(1){\n    string s;\n    int i;\n    cin>>s>>i;\n    if(s==\"0\"&&i==0) break;\n    string h1e6 = gs(s, 0).first;\n    if (i >= (int)h1e6.size()) cout << \"0\" << endl;\n    else cout << h1e6[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nconst int MAX=1e6+1;\n\ntypedef long long Int;\n\nInt cnt(int& p);\n\nInt get_num(int& p){\n  int res=0;\n  while(isdigit(s[p])){\n    res*=10;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nInt cnt_large(int& p){\n  Int res=0;\n  while(s[p]!=')'){\n    Int val=cnt(p);\n    res+=val;\n    if(res>MAX) res=MAX;\n  }\n  return res;\n}\n\n\nInt cnt(int& p){\n  if(isalpha(s[p])){\n    p++;\n    return 1;\n  }\n  if(isdigit(s[p])){\n    Int num=get_num(p);\n    if(isalpha(s[p])){\n      p++;\n      return num;\n    }\n    assert(s[p]=='(');\n    p++;\n    Int val=cnt_large(p);\n    assert(s[p]==')');\n    p++;\n    if(val>MAX){\n      return MAX;\n    }\n    if(num*val>MAX) return MAX;\n    return num*val;\n  }\n  return -1000000;\n}\n\nchar target(int &p,Int x){\n  while(p<s.size()){\n    int prep=p;\n    Int val=cnt(p);\n    if(val>=x){\n      p=prep;\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      Int num=get_num(p);\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      assert(s[p]=='(');\n      p++;\n      int prep2=p;\n      Int val2=cnt_large(p);\n      p=prep2;\n      return target(p,(x%val2==0) ? val2 : x%val2);\n    }\n    x-=val;\n  }\n  return '0';\n}\n\nint main(){\n  int n;\n  while(cin>>s>>n,s!=\"0\"){\n\n  int p=0;\n  cout<<target(p,n+1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint N;\nstring dfs(string s){\n\tstring r;\n\tint i=0;\n\tlong long n=-1;\n\tfor(;i<s.size();){\n\t\tif('0'<=s[i]&&s[i]<='9'){\n\t\t\tif(n<0)\n\t\t\t\tn=s[i]-'0';\n\t\t\telse\n\t\t\t\tn=n*10+s[i]-'0';\n\t\t\ti++;\n\t\t}else if(s[i]=='('){\n\t\t\tif(n<0)n=1;\n\t\t\tint cnt=1,j=i+1;\n\t\t\tfor(;cnt;){\n\t\t\t\tif(s[j]=='(')\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(s[j]==')')\n\t\t\t\t\tcnt--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tstring r0=dfs(s.substr(i+1,j-1-i-1));\n\t\t\tfor(int _=0;_<n;_++){\n\t\t\t\tr+=r0;\n\t\t\t\tif(r.size()>N)return r;\n\t\t\t}\n\t\t\tn=-1;\n\t\t\ti=j;\n\t\t}else{\n\t\t\tif(n<0)n=1;\n\t\t\tr+=string(n,s[i]);\n\t\t\tn=-1;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main(){\n\tfor(;;){\n\t\tstring s;\n\t\tcin>>s>>N;\n\t\tif(s==\"0\")break;\n\t\tstring r=dfs(s);\n\t\tprintf(\"%c\\n\",r.size()>N?r[N]:'0');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef long long lint;\n\nstring S;\nint x;\n\nstring ans_parse(int l, int r) {\n\tif (r - l == 1) return S.substr(l,1);\n\t\n\tstring res = \"\";\n\tint mul = 0, open_cnt = 0, close_cnt = 0, nxt_l = -1;\n\t\n\tfor_(i,l,r) {\n\t\tif (open_cnt == close_cnt) {\n\t\t\tif (isdigit(S[i])) mul = 10 * mul + (S[i] - '0');\n\t\t\tif (S[i] == '(') ++open_cnt, nxt_l = i+1;\n\t\t} else {\n\t\t\tif (S[i] == '(') ++open_cnt;\n\t\t\tif (S[i] == ')') {\n\t\t\t\t++close_cnt;\n\t\t\t\tif (open_cnt == close_cnt) {\n\t\t\t\t\tstring str = ans_parse(nxt_l, i);\n\t\t\t\t\tfor_(rep,0,mul) res += str;\n\t\t\t\t\tmul = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint parse(int l, int r) {\n\tif (r - l == 1) return 1;\n\t\n\tint res = 0, mul = 0, open_cnt = 0, close_cnt = 0, nxt_l = -1;\n\t\n\tfor_(i,l,r) {\n\t\tif (open_cnt == close_cnt) {\n\t\t\tif (isdigit(S[i])) mul = 10 * mul + (S[i] - '0');\n\t\t\tif (S[i] == '(') ++open_cnt, nxt_l = i+1;\n\t\t} else {\n\t\t\tif (S[i] == '(') ++open_cnt;\n\t\t\tif (S[i] == ')') {\n\t\t\t\t++close_cnt;\n\t\t\t\tif (open_cnt == close_cnt) {\n\t\t\t\t\tres += mul * parse(nxt_l, i);\n\t\t\t\t\tmul = 0;\n\t\t\t\t\tif (res < 0 || res > x) {\n\t\t\t\t\t\tif (res > x) {\n\t\t\t\t\t\t\tstring ans = ans_parse(l, r);\n\t\t\t\t\t\t\tcout << ans[x] << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> S >> x) {\n\t\tif (S == \"0\") break;\n\t\t\n\t\tint m = S.size();\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tif ('A' <= S[i] && S[i] <= 'Z') {\n\t\t\t\tS = S.substr(0, i) + \"(\" + S[i] + \")\" + S.substr(i+1);\n\t\t\t\tm += 2;\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor_(i,0,m) {\n\t\t\tif (S[i] == '(' && (i==0 || !isdigit(S[i-1]))) {\n\t\t\t\tS = S.substr(0, i) + \"1\" + S.substr(i);\n\t\t\t\t++m;\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tS = \"1(\" + S + \")\";\n\t\t//cerr << S << endl;\n\t\tif (parse(0, S.size()) >= 0) puts(\"0\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n \nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n \nstring genome() {\n    string res = \"\";\n    if(s[roc] == '(') {\n        ++roc;\n        while(s[roc] != ')' && !found) {\n            if(s[roc] >= 'A' && s[roc] <= 'Z') {\n                res += s[roc];\n                ++t;\n                if(t == i && ans == '#') {\n                    ans = s[roc];\n                    found = true;\n                    ++roc;\n                    t = INF;\n                    break;\n                }\n                ++roc;\n            } else {\n                ll roc_buf = roc;\n                while(s[roc] >= '0' && s[roc] <= '9') ++roc;\n                int roop = stoi(s.substr(roc_buf, roc - roc_buf));\n                string rooped = genome();\n                if(!found) {\n                    REP(j, roop - 1) {\n                        if(t + rooped.size() < i) {\n                            t += rooped.size();\n                            res += rooped;\n                        } else {\n                            if(ans == '#') {\n                                ans = rooped[(i - t) - 1];\n                                found = true;\n                                t = INF;\n                            }\n                            break;\n                        }\n                    }\n                    res += rooped;\n                }\n            }\n        }\n        ++roc;\n        return res;\n    } else {\n        res += s[roc];\n        ++t;\n        if(t == i) {\n            ans = s[roc];\n            found = true;\n        }\n        ++roc;\n        return res;\n    }\n}\n \nint main(void) {\n    while(true) {\n        cin>>s>>i;\n        if(s == \"0\" && i == 0) break;\n        roc = 0;\n        t = -1;\n        found = false;\n        ans = '#';\n        s = \"(\" + s;\n        s += \")\";\n        genome();\n        if(ans == '#') cout<<0<<endl;\n        else cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <vector>\n#include <ctype.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Node {\n  ll length;\n  ll size;\n  ll loop;\n  char c;\n  vector<Node> child;\n  Node() : length(0), size(0), loop(1), c(0) {;}\n};\n\nchar str[1000];\n\nNode parse(ll &index, ll loop) {\n  Node ret;\n  if (isalpha(str[index])) {\n    ret.length = 1;\n    ret.c = str[index];\n    index++;\n  } else if (isdigit(str[index])) {\n    ll nloop = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n    if (isalpha(str[index])) {\n      ret.child.push_back(parse(index, nloop));\n      ret.length += ret.child[ret.child.size() - 1].size;\n    } else {\n      assert(str[index] == '(');\n      index++;\n      while (str[index] != ')') {\n        ret.child.push_back(parse(index, nloop));\n        ret.length += ret.child[ret.child.size() - 1].size;\n      }\n      assert(str[index] == ')');\n      index++;\n    }\n  }\n  ret.size = ret.length * loop;\n  ret.loop = loop;\n  return ret;\n}\n\nchar nodechar(const Node &node, int n) {\n  if (node.size <= n) { return '0'; }\n  n %= node.length;\n  if (n == 0 && node.c != 0) { return node.c; }\n  REP(i, node.child.size()) {\n    const Node &target = node.child[i];\n    if (target.size > n) {\n      return nodechar(target, n);\n    }\n    n -= target.size;\n  }\n  assert(false);\n  return 0;\n}\n\nint main() {\n  ll n;\n  while (scanf(\"%s %lld\", str, &n), str[0] != '0' || n) {\n    ll index = 0;\n    Node root;\n    while (str[index] != '\\0') {\n      root.child.push_back(parse(index, 1));\n      root.size += root.child[root.child.size() - 1].size;\n      root.length += root.child[root.child.size() - 1].size;\n    }\n    printf(\"%c\\n\", nodechar(root, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\n\n\nistringstream input;\nint k;\n\n\nstruct elem{\n\tint sum, rep;\n\tvector<elem> vec;\n\tchar ch;\n\n\telem( char c, int r )\n\t\t: ch(c), sum(1), rep(r) {}\n\t\n\telem( const vector<elem> &v, int r )\n\t\t: rep(r), vec(v), ch(0) {\n\t\tint s = 0;\n\t\tfor( int i = 0; i < vec.size(); ++i ){\n\t\t\ts += vec[i].len();\n\t\t}\n\t\tsum = s;\n\n\n\t\trep = min( rep, k / sum + 1 );\n\t}\n\n\tint len(){\n\t\treturn sum * rep;\n\t}\n\n\tchar at( int x ){\n\t\tx %= sum;\n\t\tif( vec.empty() ){\n\t\t\tif( x == 0 ) return ch;\n\t\t}\n\t\telse{\n\t\t\tfor( int i = 0; i < vec.size(); ++i ){\n\t\t\t\tif( x < vec[i].len() ){\n\t\t\t\t\treturn vec[i].at(x);\n\t\t\t\t}\n\t\t\t\tx -= vec[i].len();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn '0';\n\t}\n};\n\n\n\nelem parse(int rep){\n\tif( isalpha( input.peek() ) ){\n\t\tchar c;\n\t\tinput >> c;\n\t\treturn elem( c, rep );\n\t}\n\n\tinput.ignore();\n\tvector<elem> v;\n\twhile( input.peek() != ')' ){\n\t\tif( isdigit( input.peek() ) ){\n\t\t\tint r;\n\t\t\tinput >> r;\n\t\t\tv.push_back( parse( r ) );\n\t\t}\n\t\telse{\n\t\t\tchar c;\n\t\t\tinput >> c;\n\t\t\tv.push_back( elem( c, 1 ) );\n\t\t}\n\t}\n\tinput.ignore();\n\treturn elem( v, rep );\n}\n\n\nchar solve(){\n\twhile(true){\n\t\tinput.peek();\n\t\tif( input.eof() ) break;\n\n\t\tif( isdigit( input.peek() ) ){\n\t\t\tint r;\n\t\t\tinput >> r;\n\t\t\telem e = parse(r);\n\n\t\t\tif( k < e.len() ){\n\t\t\t\treturn e.at(k);\n\t\t\t}\n\t\t\tk -= e.len();\n\t\t}\n\t\telse{\n\t\t\tchar c;\n\t\t\tinput >> c;\n\t\t\tif( k == 0 ){\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\t--k;\n\t\t}\n\t}\n\treturn '0';\n}\n\n\nint main(){\n\tstring s;\n\twhile(true){\n\t\tcin >> s >> k;\n\t\tif( s == \"0\" )\n\t\t\treturn 0;\n\n\t\tinput.clear();\n\t\tinput.str(s);\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n//#define debug(x) cerr << #x << \" : \" << x << endl\n#define debug(...)\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nstring get_foo(const string &S, int &pos, function<int(int)> isfoo) {\n    int len = 0;\n    for(; isfoo(S[pos + len]); len++);\n    string ret = S.substr(pos, len);\n    pos += len;\n    return ret;\n}\nstring calc(const string &S, int &pos, int N) {\n    //cerr << \"-> \" << S.substr(0, pos + 1) << endl;\n    bool paren = S[pos] == '(';\n    if(paren) pos++;\n    string res;\n    res.reserve(N + 1);\n    do {\n        if(isdigit(S[pos])) {\n            int rec = stoi(get_foo(S, pos, [](int a) { return isdigit(a); }));\n            int need = N - res.size();\n            string ss = calc(S, pos, need);\n            rep(i, rec) {\n                rep(j, ss.size()) {\n                    res.push_back(ss[j]);\n                    if(res.size() >= N) goto A;\n                }\n            }\n      A:;\n        } else if(isalpha(S[pos])) {\n            if(paren) {\n                res.append(get_foo(S, pos, [](int a) { return isalpha(a); }));\n            } else {\n                res.push_back(S[pos++]);\n            }\n        } else {\n            debug(pos);\n            debug(S[pos]);\n            assert(0);\n        }\n    } while(paren and S[pos] != ')' and res.size() < N);\n    //cerr << \"<- \" << S.substr(0, pos + 1) << \" \" << (paren ? \"!\": \"\") <<endl;\n    if(paren) pos++;\n    return res;\n}\n\nchar res[1000000 + 5];\n\nbool solve() {\n    string S; cin >> S;\n    int N; cin >> N;\n    if(S == \"0\" and N == 0) return false;\n    cerr << S << \" \" << N << endl;\n    int pos = 0, pos2 = 0;\n    while(pos < S.size() and pos2 <= N) {\n        string a = calc(S, pos, N - pos2 + 1);\n        rep(i, a.size()) {\n            res[pos2++] = a[i];\n            if(pos2 > N) break;\n        }\n    }\n    cout << (pos2 <= N ? \"0\" : string(res[N], 1)) << endl;        \n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int i = 0;\n    while(true) {\n        if(not solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str,ans;\nint n,pos;\n\nstring saiki(int S){\n  int k=1;\n  string res,s;\n  while(pos<(int)str.size()&&str[pos]!=')'&&(int)res.size()+S<=n){\n    if('0'<=str[pos]&&str[pos]<='9') {\n      k=0;\n      while('0'<=str[pos]&&str[pos]<='9')k=k*10+str[pos++]-'0';\n    }\n    else if(str[pos]=='('){\n      pos++;\n      s=saiki(res.size()+S);\n      for(int i=0;i<k&&res.size()+S<=n;i++)res+=s;\n      pos++,k=1;\n    }\n    else {\n      for(int i=0;i<k;i++) res+=str[pos];\n      pos++,k=1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>str>>n;\n    if(str==\"0\"&&n==0)break;\n    pos=0;\n    ans=\"\";\n    ans=saiki(0);\n    if(ans.size()<=n)cout<<0<<endl;\n    else cout <<ans[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nll a,t;\nchar out;\nstring f(){\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(out!='0')return \"\";\n\t\tif(isalpha(s[t])){\n\t\t\tw+=s[t];\n\t\t\tt++;\n\t\t\tif(a<w.size()){\n\t\t\t\tout=w[a];return \"\";\n\t\t\t}\n\t\t}else if(s[t]==')'){\n\t\t\treturn w;\n\t\t}else{\n\t\t\tint co=0;\n\t\t\twhile(isdigit(s[t])){\n\t\t\t\tco*=10;\n\t\t\t\tco+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tstring tmp;\n\t\t\tif(isalpha(s[t])){\n\t\t\t\ttmp=s[t];\n\t\t\t}else{\n\t\t\t\tt++;\n\t\t\t\ttmp=f();\n\t\t\t}\n\t\t\tif(a<w.size()+tmp.size()*co){\n\t\t\t\tif(a<w.size())out=w[a];\n\t\t\t\telse out=tmp[(a-w.size())%tmp.size()];\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\trep(i,co)w+=tmp;\n\t\t\tt++;\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\twhile(cin>>s>>a,s!=\"0\"){\n\t\tout='0';\n\t\tt=0;\n\t\tf();\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Node{\npublic:\n  long long int size, left_repeat;\n  string str;\n  Node* left;\n  Node* right;\n};\n\nclass GenomeTree{\npublic:\n  GenomeTree(string s){\n    root = (Node *)malloc(sizeof(Node));\n    func(s.begin(), s.end(), root);\n  }\n  char search(long long int n){\n    if(n >= root->size){ return '0'; }\n    return sea(n, root);\n  }\n  void destruction(){ dest(root); }\n\nprivate:\n  Node* root;\n  int c2i(char c){\n    int ans = c - '0';\n    if(0 <= ans && ans <= 9){ return ans; }\n    return -1;\n  }\n\n  void dest(Node* now){\n    if(now == NULL){ return; }\n    dest(now->left);\n    dest(now->right);\n    free(now);\n    return;\n  }\n\n  char sea(long long int n, Node *now){\n    if(now->str != \"\"){ return now->str[n]; }\n    if(n <= now->left->size * now->left_repeat)\n      return sea(n % now->left->size, now->left);\n    else\n      return sea(n - (now->left->size * now->left_repeat), now->right);\n  }\n\n  void NodeInit(Node *now){\n    now->size = now->left_repeat = 0;\n    now->left = now->right = NULL;\n    now->str = \"\";\n  }\n  \n  void func(string::iterator a, string::iterator b, Node* now){\n    NodeInit(now);\n    \n    if(a >= b){\n      now->size = 0;\n      return;\n    }\n    \n    if(*a == '('){ ++a; }\n    if(c2i(*a) < 0){\n      string::iterator size;\n      for(string::iterator it = a; it != b; it++){ now->str += *it; }\n      now->size = b - a;\n      return;\n    }\n    \n    while(c2i(*a) >= 0){\n      now->left_repeat *= 10;\n      now->left_repeat += c2i(*a);\n      ++a;\n    }\n    \n    if(*a != '('){\n      now->size = now->left_repeat;\n      now->left = (Node *)malloc(sizeof(Node));\n      NodeInit(now->left);\n      now->left->size = 1;\n      now->left->str += *a;\n    }\n    else{\n      int cout = 0;\n      string::iterator next_b;\n      for(string::iterator it = a; ; it++){\n        if(*it == '('){ ++cout; }\n        if(*it == ')'){ --cout; }\n        if(cout == 0){\n          next_b = it;\n          break;\n        }\n      }\n\n      now->left = (Node *)malloc(sizeof(Node));\n      now->right = (Node *)malloc(sizeof(Node));\n      func(a, next_b, now->left);\n      func(next_b + 1, b, now->right);\n      now->size = now->left->size * now->left_repeat + now->right->size;\n    }\n    return;\n  }\n};\n\n\nint main(void){\n  while(true){\n    string s;\n    int n;\n    cin >> s >> n;\n    if(s == \"0\" && n == 0){ break; }\n    \n    GenomeTree g(s);\n    cout << g.search(n) << endl;\n    g.destruction();\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x334334334LL\n\ntypedef long long int LLI;\ntypedef pair<int, LLI> Pair;\n\nint n;\nint I;\nint num_node;\nint ls[1145141];\nchar buf[1145141];\nbool is_leaf[1145141];\nLLI size[1145141];\nvector<Pair> es[1145141];\n\nint dfs1(int k, int idx) {\n  char *res;\n  es[idx].clear();\n  size[idx] = 0;\n  while (k < n && buf[k] != ')') {\n    int g = num_node++;\n    LLI t = strtol(buf+k, &res, 10);\n    if (buf+k == res) {\n      t = 1;\n      size[g] = 0;\n      ls[g] = k;\n      is_leaf[g] = true;\n      while (k < n && 'A' <= buf[k] && buf[k] <= 'Z') {\n        size[g]++;\n        k++;\n      }\n    } else {\n      is_leaf[g] = false;\n      if (*res == '(') {\n        k = dfs1(res-buf+1, g);\n      } else {\n        k = dfs1(res-buf, g);\n      }\n    }\n    es[idx].push_back(Pair(g, t));\n    size[idx] = min(INF, size[idx] + size[g]*t);\n  }\n  return k+1;\n}\n\nvoid dfs2(int v, int I) {\n  if (is_leaf[v] && I < size[v]) {\n    printf(\"%c\\n\", buf[ls[v]+I]);\n    return;\n  }\n\n  bool found = false;\n  for (int i=0; i<es[v].size(); i++) {\n    Pair p = es[v][i];\n    int u = p.first;\n    LLI t = p.second;\n\n    if (I < size[u]*t) {\n      found = true;\n      dfs2(u, I%size[u]);\n      break;\n    } else I -= size[u]*t;\n  }\n\n  if (!found) puts(\"0\");\n}\n\nint main() {\n  while (1) {\n    scanf(\"%s%d\", buf, &I);\n    if (buf[0] == '0' && I == 0) return 0;\n\n    n = strlen(buf);\n    num_node = 1;\n    assert(dfs1(0, 0) >= n);\n    dfs2(0, I);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nvoid expr(string &S, int &i);\n\nstring T;\nint N;\n\nint number(string &S, int &i) {\n\tint val = 0;\n\twhile (isdigit(S[i])) {\n\t\tval *= 10;\n\t\tval += S[i]-'0';\n\t\ti++;\n\t}\n\treturn (val);\n}\n\nstring String(string &S, int &i) {\n\tstring s;\n\twhile (T.size() <= N && i < S.size() && isupper(S[i])) {\n\t\ts += S[i];\n\t\tT += S[i];\n\t\ti++;\n\t}\n\treturn (s);\n}\n\nvoid par(string &S, int &i) {\n\tint val = number(S, i);\n\t//cout << \"number : \" << val << endl;\n\tstring s;\n\tif (S[i] == '(') {\n\t\tint plen = T.size();\n\t\ti++;\t\n\t\texpr(S, i);\n\t\tif (T.size() > N) return;\n\t\t//cout << val << \" : \" << plen << \" \" << T.size() << endl;\n\t\tfor (int j = plen; j < T.size(); j++) {\n\t\t\ts += T[j];\n\t\t}\n\t\ti++;\n\t} else {\n\t\ts += String(S, i);\n\t}\n\tval--;\n\tfor (int j = 0; j < val; j++) {\n\t\tT += s;\n\t\tif (T.size() > N) return;\n\t}\n}\n\nvoid expr(string &S, int &i) {\n\twhile (i < S.size() && isupper(S[i]) || isdigit(S[i])) {\n\t\tif (isupper(S[i])) {\n\t\t\tString(S, i);\n\t\t\t//cout << i << \" \" << S.size() << \" \" << T.size() << endl;\n\t\t\tif (T.size() > N) return;\n\t\t} else {\n\t\t\tpar(S, i);\n\t\t\tif (T.size() > N) return;\n\t\t}\n\t}\n\treturn;\n}\n\nbool solve() {\n\tstring S; cin >> S >> N;\n\tif (S == \"0\" && N == 0) return (false);\n\tT = \"\";\n\tint i = 0;\n\texpr(S, i);\n\t//cout << T.size() << endl;\n\tif (T.size() <= N) {\n\t\tcout << 0 << endl;\n\t} else {\n\t\tcout << T[N] << endl;\n\t}\n\treturn (true);\n}\n\nvoid Main() {\n\twhile (solve());\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint n;\nint len;\n\nchar loop(string s){\n\tint num = 0;\n\tstring ss = \"\";\n\tREP(i, s.length()){\n\t\tif (isdigit(s[i])){\n\t\t\tnum *= 10;\n\t\t\tnum += s[i] - '0';\n\t\t}\n\n\t\tif (s[i] == '('){\n\t\t\tif (n - len < ss.length()){\n\t\t\t\treturn ss[(n - len)];\n\t\t\t}\n\t\t\tchar c;\n\t\t\tREP(j, num){\n\t\t\t\tc = loop(s.substr(i + 1));\n\t\t\t\tif (c != '0')\n\t\t\t\t\treturn c;\n\t\t\t}\n\t\t\tnum = 0;\n\t\t\tint nu = 0;\n\t\t\twhile (1){\n\t\t\t\tif (s[i] == ')')nu--;\n\t\t\t\tif (s[i] == '(')nu++;\n\t\t\t\tif (nu == 0)break;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')'){\n\t\t\tif (n-len < ss.length()){\t\n\t\t\t\treturn ss[(n - len)];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//cout << ss;\n\t\t\t\tlen += ss.length();\n\t\t\t\treturn '0';\n\t\t\t}\t\n\t\t}\n\t\tif ('A' <= s[i] && s[i] <= 'Z'){\n\t\t\tREP(j,num)\n\t\t\t\tss += s[i];\n\t\t\tif (num==0)\n\t\t\t\tss += s[i];\n\t\t\tnum = 0;\n\t\t}\n\t}\n\n\tif (n-len < ss.length()){\n\t\treturn ss[(n - len)];\n\t}\n\telse{\n\t\tlen += ss.length();\n\t\treturn '0';\n\t}\n}\n\n\nint main() {\n\tstring s;\n\twhile (cin>>s>>n,s!=\"0\"){\n\t\tlen = 0;\n\t\tcout << loop(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nchar ans;\nint a;\nstring st;\nlong long int getnum() {\n\tlong long int  anum=0;\n\twhile (1) {\n\t\tif (isdigit(st[a])) {\n\t\t\tanum *= 10;\n\t\t\tanum += st[a]-'0';\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn anum;\n\t\t}\n\t}\n}\nstring getst() {\n\tstring ast;\n\twhile (1) {\n\t\tif (a == st.size())return ast;\n\t\tif ('A'<=st[a]&&st[a]<='Z') {\n\t\t\tast += st[a];\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn ast;\n\t\t}\n\t}\n}\nstring getans(const long long int repeatnum,const int targetnum) {\n\tstring nst;\n\twhile (1) {\n\t\tif (a == st.size())return  nst;\n\t\tif (st[a] == '(') {\n\t\t\ta++;\n\t\t\tnst+=getans(repeatnum, targetnum - nst.size());\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tlong long int num=getnum();\n\t\t\tstring plusst;\n\t\t\tif (st[a] == '(') {\n\t\t\t\ta++;\n\t\t\t\tplusst= getans(min(1000000000000,repeatnum*num), targetnum - nst.size()*repeatnum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tplusst = st[a];\n\t\t\t\ta++;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\tnst += plusst;\n\t\t\t}\n\t\t\tif ((nst.size())*repeatnum > targetnum) {\n\t\t\t\tans = nst[targetnum % nst.size()];\n\t\t\t\tthrow(0);\n\t\t\t}\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn nst;\n\t\t}\n\t\telse {\n\t\t\tstring plusst = getst();\n\t\t\tnst += plusst;\n\t\t\tif ((nst.size())*repeatnum > targetnum) {\n\t\t\t\tans = nst[targetnum % nst.size()];\n\t\t\t\tthrow(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\ta = 0;\n\t\tans = '0';\n\t\tint n;\n\t\tcin >> st >> n;\n\t\tif (st == \"0\")break;\n\t\ttry {\n\t\t\tgetans(1, n);\n\t\t}\n\t\tcatch (...) {\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nconst int MAX=1e6+1;\n\ntypedef long long Int;\n\nInt cnt(int& p);\n\nInt get_num(int& p){\n  int res=0;\n  while(p<s.size() && isdigit(s[p])){\n    res*=10;\n    res+=(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nInt cnt_large(int& p){\n  Int res=0;\n  while(s[p]!=')'){\n    Int val=cnt(p);\n    res+=val;\n    if(res>MAX) return MAX;\n  }\n  return res;\n}\n\nInt cnt(int& p){\n  if(isalpha(s[p])){\n    p++;\n    return 1;\n  }\n  if(isdigit(s[p])){\n    Int num=get_num(p);\n    if(isalpha(s[p])){\n      p++;\n      return num;\n    }\n    assert(s[p]=='(');\n    p++;\n    Int val=cnt_large(p);\n    assert(s[p]==')');\n    p++;\n    if(val>MAX){\n      return MAX;\n    }\n    return num*val;\n  }\n}\nchar target(int &p,Int x){\n  while(p<s.size()){\n\n    int prep=p;\n    Int val=cnt(p);\n    \n    if(val>=x){\n      p=prep;\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      Int num=get_num(p);\n      if(isalpha(s[p])){\n\treturn s[p];\n      }\n      assert(s[p]=='(');\n      p++;\n      int prep2=p;\n\n      Int val2=cnt_large(p);\n      p=prep2;\n\n      return target(p,(x%val2==0) ? val2 : x%val2);\n    }\n    x-=val;\n  }\n  return '0';\n}\n\nint main(){\n  int n;\n  while(cin>>s>>n,s!=\"0\"){\n\n  int p=0;\n  cout<<target(p,n+1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nstruct Data{\n    int cnt;\n    int r;\n    char c;\n    vector<Data*> childs;\n    Data(int r, int cnt, char c = '*') : r(r), cnt(cnt), c(c), childs(0){}\n};\n\nstring s;\nint idx;\n\nData* expr(int l){\n    int cnt = 0;\n    int i = l;\n    while('0' <= s[i] && s[i] <= '9'){\n        cnt *= 10;\n        cnt += (s[i] - '0');\n        ++i;\n    }\n    if(!cnt)\n        cnt = 1;\n    if(s[i] == '('){\n        ++i;\n        Data* d = new Data(0, cnt);\n        while(s[i] != ')'){\n            Data* ptr = expr(i);\n            d->childs.push_back(ptr);\n            i = ptr->r;\n        }\n        d->r = i + 1;\n        return d;\n    }\n    return new Data(i + 1, cnt, s[i]);\n}\n\nint parse(Data* d){\n    if(d->childs.empty()){\n        idx -= d->cnt;\n        if(idx < 0){\n            cout << d->c << endl;\n            return -1;\n        }\n    }\n    for(int i = 0; i < d->cnt; ++i)\n        for(auto& c : d->childs){\n            int ret = parse(c);\n            if(ret == -1)\n                return -1;\n        }\n    return 0;\n}\n\nbool solve(){\n    cin >> s >> idx;\n    if(s == \"0\")\n        return false;\n\n    Data* root = new Data(s.size(), 1);\n    int i = 0;\n    while(i != s.size()){\n        root->childs.push_back(expr(i));\n        i = root->childs.back()->r;\n    }\n    if(parse(root) != -1){\n        cout << 0 << endl;\n    }\n\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nInt flg=0;\nInt expr(string &s,Int &p,Int pos);\nInt factor(string &s,Int &p,Int pos);\nInt number(string &s,Int &p);\n\nconst Int LIM = 1e8;\nInt expr(string &s,Int &p,Int pos){\n  Int res=factor(s,p,pos);\n  if(flg) return -1;\n  pos-=res;\n\n  while(p<(Int)s.size()&&s[p]!=')'){\n    Int len=factor(s,p,pos);\n    if(flg) return -1;\n    res+=len;\n    pos-=len;\n  }\n  return max(min(res,LIM),-LIM);\n}\n\nInt factor(string &s,Int &p,Int pos){\n  if(isupper(s[p])){\n    if(0<=pos&&pos<1){\n      cout<<s[p]<<endl;\n      flg=1;\n      return -1;\n    }\n    p++;\n    return 1;\n  }\n  assert(isdigit(s[p]));\n\n  Int num=number(s,p);\n\n  if(isalpha(s[p])){\n    if(0<=pos&&pos<num){\n      cout<<s[p]<<endl;\n      flg=1;\n      return -1;\n    }\n    p++;\n    return num;\n  }\n  //cout<<s<<\" \"<<p<<\" \"<<pos<<\":\"<<s[p]<<endl;\n\n  assert(s[p]=='(');\n  p++;\n\n  Int b=p;\n  Int res=expr(s,p,-1);\n  assert(!flg);\n\n  assert(s[p]==')');\n  p++;\n\n  if(0<=pos&&pos<num*res){\n    expr(s,b,pos%res);\n    assert(flg);\n    return -1;\n  }\n\n  return max(min(num*res,LIM),-LIM);\n}\n\nInt number(string &s,Int &p){\n  Int res=0;\n  while(isdigit(s[p])){\n    res=res*10+(s[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nsigned main(){\n  string s;\n  Int pos;\n  while(cin>>s>>pos,s!=\"0\"){\n    flg=0;\n    Int p=0;\n    expr(s,p,pos);\n    if(!flg) cout<<0<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nstring s;\nint id;\n\nstruct Node {\n    int v;\n    string s;\n    vector<Node> children;\n    Node(int v_, string s_) : v(v_), s(s_){}\n    void print() {\n        if (children.size() == 0) {\n            cout << s;\n            return;\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                this->children[j].print();\n            }\n        }\n    }\n\n    int sum_v() {\n        int res = 0;\n        if (children.size() == 0) return s.size();\n        rep(i, (int)children.size()) {\n            res += children[i].sum_v();\n            if (res > (int)1e9) return (int)1e9;\n        }\n        return res * v;\n    }\n\n    char ans(int& cur_id) {\n        if (children.size() == 0) {\n            if (id - cur_id < (int)s.size()) {\\\n                return s[id - cur_id];\n            }\n            else {\n                cur_id += s.size();\n                return '0';\n            }\n        }\n        if (not (id - cur_id < sum_v()) ) {\n            cur_id += sum_v();\n            return '0';\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                char res = children[j].ans(cur_id);\n                if (isalpha(res)) return res;\n            }\n        }\n        return '0';\n    }\n};\n\nNode make_tree(int& i) {\n    Node cur_node(1, \"\");\n    while (s[i] != ')' && s[i] != '\\0') {\n        if (isdigit(s[i])) {\n            char *e;\n            int v = strtol(&s[i], &e, 10);\n            if (test) dump(e);\n            i += (e - &s[i]);\n            if (s[i] == '(') i++;\n            if (test) dump(s[i]);\n            Node child = make_tree(i);\n            child.v = v;\n            cur_node.children.push_back(child);\n            if (i < (int)s.size() && s[i] == ')') i++;\n            if (test) cout << \"2:\";\n            if (test) dump(s[i]);\n        }\n        else {\n            int start = i;\n            while (isalpha(s[i])) i++;\n            int end = i;\n            cur_node.children.push_back(Node(1, s.substr(start, end-start)));\n            if (test) dump(cur_node.children.back().s);\n        }\n    }\n    return cur_node;\n}\n\nvoid solve() {\n    cin >> s >> id;\n    if (s == \"0\") exit(0);\n    int id = 0;\n    Node root = make_tree(id);\n\n    if (false) {\n        root.print();\n        cout << endl;\n    }    \n    dump(root.sum_v());\n    \n    id = 0;\n    cout << root.ans(id) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_LEN = 1100010;\n\nchar c[MAX_LEN];\nchar ans;\nbool end_flg = false;\nbool bad_flg = false;\nint I;\nchar N[MAX_LEN];\n\npair<string, char *> getStr(char *p){\n  stringstream ss;\n  while(isalpha(*p)){\n    ss << (*p);\n    ++p;\n  }\n  return pair<string, char *>(ss.str(), p);\n}\n\npair<int, char *> getInt(char *p){\n  int ret = 0;\n  while(isdigit((*p))){\n      ret *= 10;\n      ret += ((*p) - '0');\n      ++p;\n  }\n  return pair<int, char *>(ret, p);\n}\n\npair<string, char *> check(char *p){\n  if(end_flg || bad_flg) return pair<string, char *>(\"\", p);\n  pair<int, char *> tmpi = getInt(p);\n  int num = tmpi.first;\n  p = tmpi.second;\n  string str = \"\";\n  while(isdigit(*(p + 1))){\n    pair<string, char *> tmpc = check(p + 1);\n    str += tmpc.first;\n    p = tmpc.second;\n    if(end_flg || bad_flg) return pair<string, char *>(\"\", p);\n  }\n  pair<string, char *> tmps = getStr(p + 1);\n  string now_str = tmps.first;\n  str += now_str;\n  p = tmps.second;\n  string ret = \"\";\n  if(str.length() * num - 1 >= I){\n    ans = str[I % str.length()];\n    end_flg = true;\n  } else if(str.length() * num >= MAX_LEN - 1){\n    bad_flg = true;\n    return pair<string, char *>(\"\", p);\n  } else{\n    stringstream ss;\n    REP(i, num) ss << str;\n    ret = ss.str();\n  }\n  return pair<string, char *>(ret, p);\n}\n\nint main() {\n  string tmp_s;\n  while(cin >>tmp_s >>I && tmp_s != \"0\"){\n    stringstream ss;\n    ss <<\"1(\";\n    REP(i, tmp_s.length()){\n      if(i + 1 < tmp_s.length() && isdigit(tmp_s[i]) && isalpha(tmp_s[i + 1]))\n        ss <<tmp_s[i] <<\"(\";\n      else if(i + 1 < tmp_s.length() && isalpha(tmp_s[i]) && isdigit(tmp_s[i + 1]))\n        ss <<\")\" <<tmp_s[i];\n      else\n        ss <<tmp_s[i];\n    }\n    ss <<\")\";\n    //cout <<ss.str() <<endl;\n    char *tmp_c = new char[ss.str().length() + 1];\n    strcpy(tmp_c, ss.str().c_str());\n    strcpy(N, tmp_c);\n    bad_flg = false;\n    end_flg = false;\n    pair<string, char *> s = check(N);\n    if(!bad_flg && end_flg) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 1000000000\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tdouble capacity;\n\tPath(int from = 0, int to = 0, double cost = 0, double capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nstring substrByParenthesis(string str, int open)\n{\n\tint st = 0;\n\tif (str[open] != '(') throw 1;\n\tFOR(i, open, str.size())\n\t{\n\t\tif (str[i] == ')' && --st == 0) { return str.substr(open + 1, i - open - 1); }\n\t\telse if (str[i] == '(') { st++; }\n\t}\n\tthrow 0;\n}\n\npair<int, char> decompressAndFind(const string &str, int r)\n{\n\tint p = 0;\n\tint produced = 0;\n\twhile (p < str.size())\n\t{\n\t\tint x = atoi(str.c_str() + p);\n\t\tif (x == 0) x = 1;\n\t\twhile (isdigit((unsigned int)str[p])) p++;\n\n\t\tif (str[p] == '(')\n\t\t{\n\t\t\tstring subs = substrByParenthesis(str, p);\n\t\t\tp += subs.size() + 2;\n\n\t\t\tpair<int, char> ret = decompressAndFind(subs, r);\n\t\t\tif (ret.second) { return ret; }\n\t\t\tif (ret.first * x > r) { return decompressAndFind(subs, r % ret.first); }\n\t\t\telse { r -= ret.first * x; produced += ret.first * x; }\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (r == 0) { return make_pair(0, str[p]); }\n\t\t\tr--;\n\t\t\tp++;\n\t\t\tproduced++;\n\t\t}\n\t}\n\treturn make_pair(produced, 0);\n}\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tstring input = read<string>();\n\t\tinput = regex_replace(input, regex(\"(\\\\d+)([A-Z])\"), string(\"$1($2)\"));\n\t\tint r = read<int>();\n\t\tif (input == \"0\") { break; }\n\t\tchar c = decompressAndFind(input, r).second;\n\t\tif (!c)  c = '0';\n\t\twrite(c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1145&lang=jp\n// http://algoogle.hadrori.jp/aoj/1145/\n#include <bits/stdc++.h>\n\n#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define endl \"\\n\"\n#define PI 3.14159265358979\n#define MOD 1000000007 // = 10^9 + 7\n\nusing namespace std;\nusing ll = long long;\n\nstring s;\nint n, cur = 0;\n\n//今見ているところの数字を取得\nint number()\n{\n\tint ret = 0;\n\twhile(isdigit(s[cur]))\n\t{\n\t\tret = ret * 10 + s[cur++] - '0';\n\t}\n\treturn ret;\n}\n\nint dfs(int sum) // sumはこれまで見た文字数\n{\n\tif (cur == s.length()) // 最後まで来た\n\t{\n\t\treturn 0;\n\t}\n\tif (s[cur] == '(') // 左カッコ\n\t{\n\t\tcur++; // 中に入る\n\t\treturn dfs(sum);\n\t}\n\tif (s[cur] == ')') // 右カッコ\n\t{\n\t\tcur++; // 外に出る\n\t\treturn 0;\n\t}\n\tif(isalpha(s[cur])) // 潜りきった\n\t{\n\t\tif (sum == n)\n\t\t{\n\t\t\tthrow s[cur];\n\t\t}\n\t\tcur++;\n\t\treturn 1 + dfs(sum + 1); // １文字先に\n\t}\n\n\t// 見ている文字は数字\n\n\tint m = number();\n\tint l; // 数字の後に来る文字の文字数\n\tint head = cur;\n\n\t// 数字の次にアルファベットなら\n\tif (isalpha(s[cur]))\n\t{\n\t\tl = 1;\n\t\tcur++;\n\t}\n\telse // それ以外（カッコ）なら\n\t{\n\t\tl = dfs(sum);\n\t}\n\n\t// 今見ている数字倍した後の範囲内にあるなら\n\tif (l * m + sum > n)\n\t{\n\t\tcur = head;\n\t\tn = (n - sum) % l; // これまで見ていた文字数(sum)分を消す\n\t\tdfs(0); // sumだけ消したので 0 で再探索\n\t}\n\n\t// 今見ている範囲内にはない\n\treturn l * m + dfs(sum + l * m);\t\n\n}\n\nchar solve(){\n\tcur = 0;\n\ttry{ dfs(0); }\n\tcatch(char e){ return e;}\n\treturn '0';\n}\n\nint main(){\n\twhile(cin >> s >> n, s!=\"0\") cout << solve() << endl;\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <stack>\n#define DEBUG false\nusing namespace std;\n\nint n; // oÍ·é¶\n\nstruct P {\n  int i; // JèÔµêÌæªÌindex\n  int n;          // JèÔµñ\n};\n\nbool isDigit( char c ){\n  if( '0'<= c && c <= '9' ) return true;\n  return false;\n}\n\nstring rev(string s ){ // 1¶ÌJèÔµÉ'('')' ðÂ¯é\n  for( unsigned int i=0;i<s.length();i++ ){\n    while( i<s.length() && !isDigit(s[i]) ) ++i;\n    if( isDigit(s[i]) ){\n      while( isDigit(s[i]) ) ++i;\n      if( s[i]!='(' ){\n\tstring bc=\"\";\n\tif( i+1<s.length() ) bc = s.substr(i+1);\n\ts = s.substr( 0,i ) + \"(\" + s[i] + \")\" + bc;\n      }\n    }\n    i+=2;\n  }\n  if( DEBUG )  cout << \"rev : \" << s << endl;\n  return s;\n}\n\n/* ið®©µÄ¢«A¶ð©½ñ¾¯nð¸ç· */\nchar parse( string s ){\n  const char *c = s.c_str();\n  unsigned int i=0;\n  stack<P> st;   // '('ÌÊuðL^\n  P p;\n  if( DEBUG ) cout << \"parse : \" << s << \" len=\" << s.length() << endl;\n\n  if( n==0 ){\n    while( i<s.length() && isDigit(s[i]) && s[i]=='(' ) ++i;\n    return s[i];\n  }\n\n  while( i<s.length() ){\n    if( DEBUG ) cout << \"while : i=\"<<i<<\" n=\"<<n<< \" s[i]=\"<<s[i] \n\t\t     << \" stack:\"<< st.size() << \" p.n=\" << p.n << endl;\n    if( isDigit( s[i] ) ){\n      int num = atoi( c+i );\n      if( DEBUG ) cout << \"num=\" << num << endl;\n      while( isDigit( s[i] ) ) ++i;\n      i++;  // '(' ÌªðCNg·é\n      p.i=i; p.n=num;\n      st.push( p ); // JèÔµÌÅÌ¶ðÇÁ\n    }else if( s[i]==')' ){\n      p = st.top(); st.pop();\n      if( --p.n != 0 ){  st.push( p ); i=p.i; }\n      else ++i;\n    }else {\n      --n;\n      //      if( DEBUG ) cout << \"while : i=\"<<i<<\" n=\"<<n<< \" s[i]=\"<<s[i] << endl;\n      if( n<0 )\n\treturn s[i];\n      ++i;\n    }\n  }\n  return '0';\n}\n\nint main(){\n  string s;\n  while( cin>>s>>n && (s!=\"0\"|| n ) ){\n    if( DEBUG ){\n      cout << \"\\nn=\" << n << \" in : \" << s << endl;\n    }\n   \n    if( DEBUG )\n      cout << \"answer=\";\n    cout << parse( rev(s) ) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstring s;\nstring res;\nll K;\n\nbool dfs(int l,int r){\n  bool is_str=true;\n  repl(i,l,r){\n      if(s[i]=='('||s[i]==')'||isdigit(s[i]))is_str=false;\n  }\n  if(is_str){\n    res+=s.substr(l,r-l);\n    return res.length()>K;\n  }\n\n  if(isdigit(s[l])){\n    int i=l;\n    while(i<r&&isdigit(s[i]))i++;\n    int cnt=stoi(s.substr(l,i-l));\n    if(s[i]=='('){\n      int j=i+1;\n      int level=1;\n      while(j<r&&level!=0){\n        if(s[j]=='(')level++;\n        if(s[j]==')')level--;\n        j++;\n      }\n      rep(c,cnt){\n        if(dfs(i+1,j-1))return true;\n      }\n      if(dfs(j,r))return true;\n    }else{\n      rep(c,cnt){\n        if(dfs(i,i+1))return true;\n      }\n    }\n  }else{\n    if(dfs(l,l+1))return true;\n    if(dfs(l+1,r))return true;\n  }\n  return false;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>s>>K;\n    if(s==\"0\")break;\n    res=\"\";\n    int n=s.length();\n    if(!dfs(0,n))cout<<0<<endl;\n    else cout<<res[K]<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nll roc = 0;\nstring s;\nll i;\nll t;\nbool found = false;\nchar ans = '#';\n\nstring genome() {\n\tstring res = \"\";\n\tif(s[roc] == '(') {\n\t\t++roc;\n\t\twhile(s[roc] != ')' && !found) {\n\t\t\tif(s[roc] >= 'A' && s[roc] <= 'Z') {\n\t\t\t\tres += s[roc];\n\t\t\t\t++t;\n\t\t\t\tif(t == i && ans == '#') {\n\t\t\t\t\tans = s[roc];\n\t\t\t\t\tfound = true;\n\t\t\t\t\t++roc;\n\t\t\t\t\tt = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++roc;\n\t\t\t} else {\n\t\t\t\tll roc_buf = roc;\n\t\t\t\twhile(s[roc] >= '0' && s[roc] <= '9') ++roc;\n\t\t\t\tint roop = stoi(s.substr(roc_buf, roc - roc_buf));\n\t\t\t\tstring rooped = genome();\n\t\t\t\tif(!found) {\n\t\t\t\t\tREP(j, roop - 1) {\n\t\t\t\t\t\tif(t + rooped.size() < i) {\n\t\t\t\t\t\t\tt += rooped.size();\n\t\t\t\t\t\t\tres += rooped;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(ans == '#') {\n\t\t\t\t\t\t\t\tans = rooped[(i - t) - 1];\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tt = INF;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t} else {\n\t\tres += s[roc];\n\t\t++t;\n\t\tif(t == i) {\n\t\t\tans = s[roc];\n\t\t\tfound = true;\n\t\t}\n\t\t++roc;\n\t\treturn res;\n\t}\n}\n\nint main(void) {\n\twhile(true) {\n\t\tcin>>s>>i;\n\t\tif(s == \"0\" && i == 0) break;\n\t\troc = 0;\n\t\tt = -1;\n\t\tfound = false;\n\t\tans = '#';\n\t\ts = \"(\" + s;\n\t\ts += \")\";\n\t\tgenome();\n\t\tif(ans == '#') cout<<0<<endl;\n\t\telse cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nstring str,s;\nint pos,cnt,n;\nchar ans;\n\nint term();\nint factor();\n\nint exp(){\n   int x = term();\n   if(x <= MAX){\n      if(str[pos] == '+'){\n\t pos++;\n\t x += term();\n\t if(x >= n) ans = s[(x-n)%s.size()];\n      }\n      cnt = x;\n      return x;\n   }\n}\n\nint term(){\n   int x = factor();\n   if(x <= MAX){\n      if(str[pos] == '*'){\n\t pos++;\n\t x *= factor();\n\t if(x >= n) ans = s[(x-n)%s.size()];\n      }\n      cnt = x;\n      return x;\n   }\n}\n\nint factor(){\n   int x = 0;\n   if(str[pos] == '('){\n      pos++;\n      x = exp();\n      pos++;\n   } else if(str[pos] >= '0' && str[pos] <= '9'){\n      while(str[pos] >= '0' && str[pos] <= '9'){\n\t x *= 10;\n\t x += str[pos++] - '0';\n\t if(pos == n) break;\n      }\n   } else if(str[pos] >= 'A' && str[pos] <= 'Z'){\n      s.clear();\n      while(str[pos] >= 'A' && str[pos] <= 'Z'){\n\t s += str[pos++];\n\t if(pos == n) break;\n      }\n      if(cnt >= n) ans = s[(x-n)%s.size()];\n      x = s.size();\n   }\n   if(x <= MAX) return x;\n}\n\nint main(){\n   while(cin >> str >> n){\n      if(str == \"0\" && n == 0) break;\n      pos = cnt = 0;\n      ans = '0';\n\n      for(int i=0;i<str.size();i++){\n\t if(str[i] == '(' ||\n\t    i > 0 && str[i-1] >= '0' && str[i-1] <= '9' && str[i] >= 'A' && str[i] <= 'Z'){\n\t    str.insert(str.begin()+i,'*');\n\t    i++;\n\t } else if(i > 0 && str[i-1] == ')'){\n\t    if(str[i] >= '0' && str[i] <= '9' || str[i] >= 'A' && str[i] <= 'Z'){\n\t       str.insert(str.begin()+i,'+');\n\t       i++;\n\t    }\n\t }\n      }\n\n      exp();\n      cout << ans << endl;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\n\nconst ll INF = 1000010;\nstring get_string(string s, int l, int r) {\n    string ret = \"\";\n    int cur = l;\n    while(cur < r) {\n        ll num = 0;\n        while(isdigit(s[cur])) {\n            num *= 10;\n            num += s[cur++] - '0';\n        }\n\n        // printf(\"cur = %d\\n\", cur);\n        if(s[cur] == '(') {\n            // s[cur] = '('\n            int level = 1; cur++;\n            int nl = cur, nr = -1;\n            for(; level != 0; cur++) {\n                if(s[cur] == '(') level++;\n                if(s[cur] == ')') level--;\n            }\n            // s[cur] は ')' のあと\n            nr = cur - 1;\n\n            string tmp = get_string(s, nl, nr);\n            for(int i=0; i<num && ret.length() < INF; i++) {\n                ret += tmp;\n            }\n        }\n        else {\n            // s[cur] = alphabet\n            num = max(1LL, num);\n            string tmp(1, s[cur]);\n            for(int i=0; i<num && ret.length() < INF; i++) {\n                ret += tmp;\n            }\n            cur++;\n        }\n    }\n    // printf(\"str = %s, ret = %s\\n\", s.substr(l, r-l).c_str(), ret.c_str());\n    return ret;\n}\n\nint main() {\n    while(1) {\n        string s; int N; cin >> s >> N;\n        if(s == \"0\") break;\n\n        int len = s.length();\n        string ans = get_string(s, 0, len);\n\n        if(ans.length() <= N) cout << 0 << endl;\n        else cout << ans[N] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid find(string s, string *str){\n\n    int numStart = 0;\n    int num = 0;\n    int mode = 2;  // 0:num 1:() 2:numStart\n    int strStart = 0;\n    int cnt = 0;\n    for(int i = 0; i < (int)s.size(); i++){\n        char temp = s[i];\n        if(mode == 2){\n            if(isalpha(temp)){\n                *str += temp;\n            }\n            else{\n                numStart = i;\n                mode = 0;\n            }\n        }\n        else if(mode == 0 && !isdigit(temp)){\n            num = stoi(s.substr(numStart, i - numStart));\n            mode = 1;\n            if(isalpha(temp)){\n                for(int j = 0; j < num; j++){\n                    *str += temp;\n                }\n                mode = 2;\n            }\n            else{\n                strStart = i + 1;\n                cnt++;\n            }\n        }\n        else if(mode == 1 && temp == '('){\n            cnt++;\n        }\n        else if(mode == 1 && temp == ')'){\n            cnt--;\n            if(cnt == 0){\n                string temp = s.substr(strStart, i - strStart);\n                string tempStr = \"\";\n                find(temp, &tempStr);\n\n                for(int j = 0; j < num; j++){\n                    if((*str).size() >= 1000050){\n                        break;\n                    }\n                    *str += tempStr;\n                }\n                mode = 2;\n            }\n        }\n\n        if((*str).size() >= 1000050){\n            break;\n        }\n    }\n}\n\nint main(){\n\n    while(1){\n        string s;\n        int i;\n        cin >> s >> i;\n        if(s == \"0\" && i == 0){\n            break;\n        }\n\n        string str = \"\";\n        find(s, &str);\n        if((int)str.size() > i){\n            cout << str[i] << endl;\n        }\n        else{\n            cout << 0 << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//21\n#include<iostream>\n#include<string>\n#include<cctype>\n\nusing namespace std;\n\nchar s[101];\nint i,n;\nchar a;\n\nvoid cat(string &a,const string &b){\n  if(a.size()<=n){\n    a+=b;\n  }\n}\n\nstring rs();\nstring prs();\n\nstring rs(){\n  if(isalpha(s[i])){\n    return string(1,s[i++]);\n  }else{\n    i++;\n    string r=prs();\n    i++;\n    return r;\n  }\n} \n\nstring prs(){\n  string r;\n  if(isalpha(s[i])){\n    cat(r,string(1,s[i]));\n    i++;\n    cat(r,prs());\n  }else if(isdigit(s[i])){\n    int n=0;\n    for(;isdigit(s[i]);i++){\n      n=n*10+s[i]-'0';\n    }\n    string rst=rs();\n    while(n--){\n      cat(r,rst);\n    }\n    cat(r,prs());\n  }\n  return r;\n}\n\nint main(){\n  for(;cin>>s>>n,s[0]!='0'||n;){\n    i=0;\n    string r;\n    r=prs();\n    cout<<((n<r.size())?r[n]:'0')<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(pos < str.size() && isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[pos] == '('){\n        pos++;\n        State s2 = expr(str,pos);\n        string tmp = \"\";\n        for(int i = 0; i < s1.int_result; i++){\n          tmp += s2.str_result;\n          if(tmp.size() > 1000000) break;\n        }\n        result += tmp;\n        pos = s2.pos;\n      }\n      else{\n        State s2 = alphas(str,pos);\n        string tmp = \"\";\n        for(int i = 0; i < s1.int_result; i++){\n          tmp += s2.str_result;\n          if(tmp.size() > 1000000) break;\n        }\n        result += tmp;\n        pos = s2.pos;\n      }\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    if(genome == \"0\" && pos == 0) break;\n    string result = expr(genome,0).str_result;\n    if(pos < result.size()){\n      cout << result[pos] << endl;      \n    }\n    else{\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m;\nchar ans;\nbool flag = false;\nstring dfs(string s) {\n\t//cout << s << endl;\n\tif(flag) return \"\";\n\tif('A' <= s[0] && s[0] <= 'Z') {\n\t\treturn s;\n\t}\n\tstring ret = \"\";\n\t//10C??????????????????????¢????\n\t/*bool h = false, ff = false;\n\tstring tt = \"\";\n\tint idx = -1;\n\tREP(i, s.size()) {\n\t\tif(i >= 5) break;\n\t\tif(s[i] == '(') h = true;\n\t\tif(isdigit(s[i])) tt += s[i], idx = i, ff = true;\n\t\telse if(ff && isdigit(s[i])) h = false;\n\t}\n\tstring ret = \"\";\n\tif(!h) {\n\t\tstring tmp = dfs(s.substr(idx+1));\n\t\tint itt = stoi(tt);\n\t\t//cout << \"tmp\" << tmp << \"itt\" << itt << endl;\n\t\tREP(i, itt) {\n\t\t\tret += tmp;\n\t\t\t//cout << ret << endl;\n\t\t\tif((int)ret.size() > m) {\n\t\t\t\tans = ret[m];\n\t\t\t\tflag = true;\n\t\t\t\t//cout << ans << endl;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t//cout << \"b\" << endl;\n\t*/\n\tstring num = \"\", para = \"\";\n\tint now = 0;\n\tbool f = true, g = false, kakko = false;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '(') {\n\t\t\tkakko = true;\n\t\t\tg = true;\n\t\t\tnow++;\n\t\t} else if(s[i] == ')') {\n\t\t\tnow--;\n\t\t} else if(isdigit(s[i])){\n\t\t\tf = false;\n\t\t} else {\n\t\t\tf = true;\n\t\t\tg = true;\n\t\t}\n\t\tif(g) para += s[i];\n\t\telse num += s[i];\n\t\tif(now == 0 && f) {\n\t\t\t//tmp???dfs?????????????????°?????????????????????ret????????????\n\t\t\t//cout << \"para\" << para << \"num\" << num << endl;\n\t\t\tint ttmp = stoi(num);\n\t\t\tstring dret;\n\t\t\tif(kakko) dret = dfs(para.substr(1, para.size()-2));\n\t\t\telse dret = dfs(para);\n\t\t\tREP(j, ttmp) {\n\t\t\t\tret += dret;\n\t\t\t\tif((int)ret.size() > m) {\n\t\t\t\t\tans = ret[m];\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tnum = \"\", para = \"\";\n\t\t\tf = true, g = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\n\t\tflag = false;\n\n\t\tbool f = true;\n\t\tint now = 0;\n\t\tstring tmp = \"\";\n\t\tREP(i, s.size()) {\n\t\t\t//cout << \"i:\" << i << \" \" << s[i] << endl;\n\t\t\tif(s[i] == '(') now++;\n\t\t\telse if(s[i] == ')') now--;\n\t\t\telse if(isdigit(s[i])) f = false;\n\t\t\telse f = true;\n\t\t\ttmp += s[i];\n\t\t\t//cout << tmp << \" \" << m << endl;\n\t\t\tif(now == 0 && f) {\n\t\t\t\tstring t = dfs(tmp);\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif(flag) {cout << ans << endl; goto e;}\n\t\t\t\telse if((int)t.size() <= m) {\n\t\t\t\t\tm -= t.size();\n\t\t\t\t}\telse {cout << t[m] << endl; goto e;}\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t\te:\n\t\tint a;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstring s;\nint x;\n\nint ct;\nchar c;\n\nint idx;\n\nstring now;\n\nvoid num();\nvoid read();\n\nvoid num(){\n    int n = 0;\n    while(idx<s.size() && isdigit(s[idx])){\n        n = n*10 + s[idx]-'0';\n        ++idx;\n    }\n\n    if(s[idx]=='('){\n        ++idx;\n        int start = idx;\n\n        rep(i,n){\n            idx = start;\n            read();\n            if(c != '0') return;\n        }\n\n        assert(s[idx]==')');\n        ++idx;\n    }\n    else{\n        rep(i,n){\n            now += s[idx];\n            if(ct == x){\n                c = s[idx];\n                return;\n            }\n            ++ct;\n        }\n        ++idx;\n    }\n}\n\nvoid read(){\n    if(c != '0') return;\n    if(idx >= s.size()) return;\n\n    if(isdigit(s[idx])) num();\n    if(isupper(s[idx])){\n        now += s[idx];\n        if(ct == x){\n            c = s[idx];\n            return;\n        }\n\n        // dbg(ct);\n        ++ct;\n        ++idx;\n    }\n    if(s[idx]==')') return;\n\n    read();\n}\n\nint main(){\n    while(cin >>s >>x,(s!=\"0\")){\n        c = '0';\n        idx = 0;\n        ct = 0;\n\n        now = \"\";\n\n        read();\n        // dbg(now);\n        cout << c << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_LEN = 1100010;\nconst int MAX_N_LEN = 500;\n\nchar ans;\nbool end_flg = false;\nint I;\nchar N[MAX_N_LEN];\n\npair<string, char *> getStr(char *p){\n  stringstream ss;\n  while(isalpha(*p)){\n    ss << (*p);\n    ++p;\n  }\n  return pair<string, char *>(ss.str(), p);\n}\n\npair<int, char *> getInt(char *p){\n  int ret = 0;\n  while(isdigit((*p))){\n      ret *= 10;\n      ret += ((*p) - '0');\n      ++p;\n  }\n  return pair<int, char *>(ret, p);\n}\n\npair<string, char *> check(char *p){\n  if(end_flg) return pair<string, char *>(\"\", p);\n  pair<int, char *> tmpi = getInt(p);\n  int num = tmpi.first;\n  p = tmpi.second;\n  string str = \"\";\n  while(isdigit(*(p + 1))){\n    pair<string, char *> tmpc = check(p + 1);\n    if(end_flg) return pair<string, char *>(\"\", p);\n    str += tmpc.first;\n    p = tmpc.second;\n  }\n  pair<string, char *> tmps = getStr(p + 1);\n  str += tmps.first;\n  p = tmps.second;\n  string ret = \"\";\n  if(str.length() * num - 1 >= I){\n    ans = str[I % str.length()];\n    end_flg = true;\n  } else if(str.length() * num <= MAX_LEN){\n    stringstream ss;\n    REP(i, num) ss << str;\n    ret = ss.str();\n  }\n  return pair<string, char *>(ret, p);\n}\n\nint main() {\n  string tmp_s;\n  while(cin >>tmp_s >>I && tmp_s != \"0\"){\n    stringstream ss;\n    ss <<\"1(\";\n    REP(i, tmp_s.length()){\n      if(i + 1 < tmp_s.length() && isdigit(tmp_s[i]) && isalpha(tmp_s[i + 1]))\n        ss <<tmp_s[i] <<\"(\";\n      else if(i + 1 < tmp_s.length() && isalpha(tmp_s[i]) && isdigit(tmp_s[i + 1]))\n        ss <<tmp_s[i] <<\")\";\n      else\n        ss <<tmp_s[i];\n    }\n    ss <<\")\";\n    //cout <<ss.str() <<\", \" <<I <<endl;\n    char *tmp_c = new char[ss.str().length() + 1];\n    strcpy(tmp_c, ss.str().c_str());\n    strcpy(N, tmp_c);\n    end_flg = false;\n    pair<string, char *> s = check(N);\n    if(end_flg) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nstring s; int n;\nint calc(int count, int idx){\n\tif(count == -1) return -1;\n\tidx++; //(\n\twhile(s[idx] != ')'){\n\t\tif(count == n){cout << s[idx] << endl; return -1;}\n\n\t\tif(isalpha(s[idx])){count++; idx++;}\n\t\telse {\n\t\t\tint m = 0;\n\t\t\twhile(isdigit(s[idx])){m*=10; m += s[idx]-'0'; idx++;}\n\t\t\trep(i, m) count = calc(count, idx);\n\n\t\t\tidx++;\n\t\t\tint b = 1;\n\t\t\twhile(b != 0){\n\t\t\t\tif(s[idx] == '(') b++;\n\t\t\t\telse if(s[idx] == ')') b--;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\twhile(cin >> s >> n){\n\t\tfor(int i=0; i < s.size(); i++){\n\t\t\tif(isdigit(s[i]) && isalpha(s[i+1])) s = s.substr(0, i+1) + \"(\" + s.substr(i+1, 1) + \")\" + s.substr(i+2);\n\t\t}\n\n\t\tint count = 0;\n\n\t\tif(s == \"0\" && n == 0) break;\n\t\tfor(int i=0; i< s.size();){\n\t\t\tif(count == n){cout << s[i] << endl; count = -1;}\n\t\t\tif(count == -1) break;\n\n\t\t\tif(isalpha(s[i])){count++; i++;}\n\t\t\telse {\n\t\t\t\tint m = 0;\n\t\t\t\twhile(isdigit(s[i])){m*=10; m += s[i]-'0'; i++;}\n\n\t\t\t\trep(j, m) count = calc(count, i);\n\n\t\t\t\ti++;\n\t\t\t\tint b = 1;\n\t\t\t\twhile(b != 0){\n\t\t\t\t\tif(s[i] == '(') b++;\n\t\t\t\t\telse if(s[i] == ')') b--;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count != -1) cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\n\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(int)l;i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#define NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n#define nextInt(n) scanf(\"%d\",&n)\n#define defInt(n) int n;nextInt(n)\n#define nextLong(n) scanf(\"%lld\",&n)\n#define defLong(n) ll n;nextLong(n)\n#define nextDouble(n) scanf(\"%lf\",&n)\n\n\nstring str;\nbool over;string ans;\nint p;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\n//\t\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\n\tclass ParseError{};\n\t\n\tstring expression(Cursor&);int number(Cursor&);\n\tstring seq(Cursor&);\n\n\t// <四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n\tstring expression(Cursor &c){\n\t\tstring res=\"\";\n\t\tif(over)return res;\n\t\twhile(c!=str.end() && *c!=')'){\n\t\t\tif(isdigit(*c)){\n\t\t\t\tint v=number(c);\n\t\t\t\tif(*c=='(')c++;\n\t\t\t\tstring data=expression(c);\n\t\t\t\tREP(i,v){\n\t\t\t\t\tres+=data;\n\t\t\t\t\tif(p<(int)res.size()-1){\n\t\t\t\t\t\tover=true;ans=res[p];return res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(*c==')')c++;\t\n\t\t\t}else{//文字\n\t\t\t\tres+=seq(c);\n\t\t\t\tif(p<(int)res.size()-1){\n\t\t\t\t\tover=true;ans=res[p];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t// <数>           ::= (0|1|2|3|4|5|6|7|8|9)+\n\tint number(Cursor &c){\n\t    stringstream ss;\n\t    while(isdigit(*c)){\n\t        ss << *c;c++;\n\t    }\n\t    int ret;ss >> ret;\n\t    return ret;\n\t}\n\n\t// <文字>\n\tstring seq(Cursor &c){\n\t    stringstream ss;\n\t    while(isupper(*c)){\n\t        ss << *c;c++;\n\t    }\n\t    return ss.str();\n\t}\n\n}\nusing namespace SyntaxAnalysis;\n\nclass Main{\n\tpublic:\n\n\tint N;\n\n\tvoid run(){\n\t\t// ifstream cin(\"D2\");\n//\t\tofstream cout( \"D2.out\" );\n\t\t\n\t\twhile(true){\n\t\t\tover=false;\n\t\t\tcin >> str;if(str==\"0\")break;\n\t\t\tcin >> p;\n\t\t\tCursor c=str.begin();\n\t\t\texpression(c);\n\t\t\tif(!over)cout << 0 <<endl;\n\t\t\telse cout <<ans <<endl;\n\t\t}\n\t}\n\n\n};\nint main(){\n\tcout <<fixed<<setprecision(15);\t\n\tios::sync_with_stdio(false);\n\tMain().run();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n//I referred to other's code.\nconst int MAX_L = 10000001;\nstring s;\nstring expr(int& p);\nint num(int& p){\n  int res = 0;\n  while(isdigit(s[p])){\n    res = res * 10 + (s[p++] - '0');\n  }\n  return res;\n}\nstring chara(int& p){\n  string res = \"\";\n  while(isalpha(s[p])){\n    res += s[p++];\n  }\n  return res;\n}\nstring term(int& p){\n  string res;\n  if(isalpha(s[p])){\n    res =  chara(p);\n  }else{\n    int n = num(p);\n    string t;\n    if(s[p]=='('){\n      p++;\n      t = expr(p);\n      p++;\n    }else{\n      t = chara(p);\n    }\n    REP(i,n){\n      if(res.size() > MAX_L) break;\n      res += t;\n    }\n  }\n  return res;\n}\nstring expr(int& p){\n  string res = term(p);\n  while(p < s.size() && s[p] != ')' && res.size() < MAX_L){\n    res += term(p);\n  }\n  return res;\n}\n\nint main(){\n  int i;\n  while(cin>>s>>i, s!=\"0\"){\n    int p = 0;\n    string ans = expr(p);\n    if(ans.size() > i){\n      cout<<ans[i]<<endl;\n    }else{\n      cout<<0<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nInt g(string s){\n//cout<<s<<endl;\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s))return sz(s);\n\tInt c=0,q,r,times=0;\n\trep0(q,sz(s)){\n\t\tif(!isdigit(s[q]))break;\n\t\ttimes=times*10+s[q]-'0';\n\t}\n\trep0(r,sz(s)){\n\t\tif(s[r]=='(')++c;\n\t\tif(s[r]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\treturn min(1000000LL,p+times*g(s.substr(q+1,r-q-1))+g(s.substr(r+1)));\n}\n\nchar f(string s,Int i){\n//cout<<s<<\" \"<<i<<endl;\n\tInt p;\n\trep0(p,sz(s))if(isdigit(s[p]))break;\n\tif(p==sz(s)){\n\t\tif(i<p)return s[i];\n\t\telse return '0';\n\t}\n\tif(i<p)return s[i];\n\ts=s.substr(p);\n\ti-=p;\n\tInt c=0,q,times=0;\n\trep0(p,sz(s)){\n\t\tif(!isdigit(s[p]))break;\n\t\ttimes=times*10+s[p]-'0';\n\t}\n\tif(s[p]!='('){\n\t\ts=s.substr(0,p)+\"(\"+s.substr(p,1)+\")\"+s.substr(p+1);\n\t}\n\trep0(q,sz(s)){\n\t\tif(s[q]=='(')++c;\n\t\tif(s[q]==')'){\n\t\t\t--c;\n\t\t\tif(c==0)break;\n\t\t}\n\t}\n\tInt len=g(s.substr(p+1,q-p-1));\n\tif(len*times>i){\n\t\ti%=len;\n\t\treturn f(s.substr(p+1,q-p-1),i);\n\t}else{\n\t\ti-=len*times;\n\t\treturn f(s.substr(q+1),i);\n\t}\n}\n\nint main() {\n\tstring s;\n\tInt i;\n\tIL{\n\t\tcin>>s>>i;\n\t\tif(s==\"0\"&&i==0)break;\n\t\tcout<<f(s,i)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define ARG5(a, b, c, d, NAME, ...) NAME\n#define REP(...) ARG5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)\n#define REP1(a) REP2(i, a)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) ARG5(__VA_ARGS__, REPR4, REPR3, REPR2, REPR1)(__VA_ARGS__)\n#define REPR1(a) REPR2(i, a)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\nstruct Initializer_ {\n  Initializer_(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(0);\n    std::cout << std::setprecision(10);\n    std::cerr << std::setprecision(10);\n  }\n} precalc;\n// clang-format on\n// }}}\n\n#include <ext/rope>\n\nusing namespace std;\nusing Rope = __gnu_cxx::rope<char>;\nusing siter = std::string::iterator;\n\ninline void consume(siter& it, char expected) {\n  if (expected == *it) {\n    ++it;\n    return;\n  }\n  cerr << \"Error:\\n\";\n  cerr << \"Expected: \" << expected << '\\n';\n  cerr << \"Actual:   \" << *it << '\\n';\n  ++it;\n  cerr << \"Rest string: \";\n  while (*it) {\n    cerr << *it;\n    ++it;\n  }\n  cerr << '\\n';\n}\nRope token(siter& it);\nRope eval(siter& it) {\n  Rope rope;\n  int r = 0;\n  while (*it != ')' && *it != '\\0') {\n    auto t = token(it);\n    if (rope.size() < 1000100) { rope += t; }\n  }\n  return rope;\n}\nRope token(siter& it) {\n  int r = 0;\n  while (isdigit(*it)) {\n    r = r * 10 + *it - '0';\n    ++it;\n  }\n  if (r == 0) r = 1;\n  Rope rope;\n  if (*it == '(') {\n    consume(it, '(');\n    rope = eval(it);\n    consume(it, ')');\n  } else {\n    rope.push_back(*it);\n    ++it;\n  }\n  Rope res;\n  REP(i, r) {\n    if (res.size() < 1000100) { res += rope; }\n  }\n  return res;\n}\n\nsigned main() {\n  string s;\n  int p;\n  while (cin >> s >> p) {\n    if (s == \"0\" && p == 0) break;\n    auto it = s.begin();\n    Rope rope = eval(it);\n    if (rope.size() <= p) {\n      cout << 0 << endl;\n    } else {\n      cout << rope[p] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nconst int MAX_STRING = 1000000+1;\n\nstring s;\n\nstring p_expr(int &p);\n\nint p_number(int &p)\n{\n  int res = 0;\n  while (isdigit(s[p])) {\n    res *= 10;\n    res += s[p++] - '0';\n  }\n  return res;\n}\n\nstring p_character(int &p)\n{\n  string res = \"\";\n  while (isalpha(s[p]))\n    res += s[p++];\n  return res;\n}\n\nstring p_term(int &p)\n{\n  if (isalpha(s[p])) {\n    return p_character(p);\n  } else {\n    int num = p_number(p);\n    string t = \"\";\n    if (s[p] == '(') {\n      ++p;\n      t = p_expr(p);\n      ++p;\n    } else {\n      t = p_character(p);\n    }\n    string res = \"\";\n    for (int i = 0; i < num && res.size() < MAX_STRING; ++i)\n      res += t;\n    return res;\n  }\n}\n\nstring p_expr(int &p)\n{\n  if (p >= s.size())\n    return \"\";\n\n  string res = p_term(p);\n  if (p < s.size())\n    res += p_term(p);\n  return res;\n}\n\nint main()\n{\n  int i;\n  while (cin >> s >> i) {\n    if (s == \"0\" && i == 0)\n      break;\n\n    int p = 0;\n    string ans = p_expr(p);\n    if (i < ans.size())\n      cout << ans[i] << endl;\n    else\n      cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nstring ans, str;\nint p;\n\nstring dfs(){\n    int res = 0;\n    string st = \"\";\n    while (p < str.size()) {\n        if (isdigit(str[p])) {\n            res = 0;\n            while (isdigit(str[p])) {\n                res *= 10;\n                res += str[p] - '0';\n                p++;\n            }\n        }else if (isalpha(str[p])){\n            st = \"\";\n            while (isalpha(str[p])) {\n                st += str[p];\n                p++;\n            }\n        }else if (str[p] == '('){\n            p++;\n            string tmp = dfs();\n            for (int i = 0; i < res; i++) {\n                st += tmp;\n            }\n        }else if (str[p] == ')'){\n            p++;\n            return st;\n        }\n    }\n    return st;\n}\n\nstring complement(string s){\n    int p = 0;\n    string expanded_string = \"\";\n    while (p < s.size()) {\n        if (isdigit(s[p]) && isalpha(s[p+1])) {\n            expanded_string += s[p++];\n            expanded_string += '(';\n            while (isalpha(s[p])) {\n                expanded_string += s[p++];\n            }\n            expanded_string += ')';\n        }else{\n            expanded_string += s[p++];\n        }\n    }\n    return expanded_string;\n}\n\nint main()\n{\n    int n;\n    while (true) {\n        p = 0;\n        cin >> str >> n;\n        if (str == \"0\") {\n            break;\n        }\n        str = complement(str);\n        ans = dfs();\n        if (ans.size() <= n) {\n            cout << \"0\" << endl;\n        }else{\n            cout << ans[n] << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n\nstruct Node{\n    ll size;\n    ll repeat;\n    string s;\n    vector<Node> v;\n    Node(){\n        size = 0;\n        repeat = 0;\n        s = \"\";\n    }\n    Node(ll size, ll repeat, string s){\n        this->size = size;\n        this->repeat = repeat;\n        this->s = s;\n    }\n};\n\nll fetch(const string &s, ll index){\n    ll po = 1;\n    for(ll i = index + 1; i < s.size(); i++){\n        if(s[i] == '(') po++;\n        else if(s[i] == ')') po--;\n        if(!po) return i;\n    }\n}\n\nNode dfs(const string &s){\n    ll num = 0;\n    string t = \"\";\n    Node ret(0, 1, \"\");\n    auto f = [&]{\n        if(t != \"\"){\n            ret.v.push_back(Node(t.size(), 1, t));\n            t = \"\";\n        }\n    };\n\n    for(ll i = 0; i < s.size(); i++){\n        if('0' <= s[i] && s[i] <= '9'){\n            f();\n            num = 10 * num + s[i] - '0';\n        }else if('A' <= s[i] && s[i] <= 'Z'){\n            for(ll j = 0; j < max<ll>(1, num); j++) t += s[i];\n            num = 0;\n        }else if(s[i] == '('){\n            f();\n            ll fe = fetch(s, i);\n            Node tmp = dfs(s.substr(i + 1, (fe - 1) - (i + 1) + 1));\n            tmp.repeat = max<ll>(1, num);\n            i = fe;\n            num = 0;\n            ret.v.push_back(tmp);\n        }\n    }\n    if(t != \"\") f();\n    for(auto child : ret.v){\n        ret.size += child.size * child.repeat;\n        if(ret.size > 1000002) ret.size = 1000002;\n    }\n    if(ret.size < 1000002) ret.size = ret.repeat * (ret.size + ret.s.size());\n    return ret;\n}\n\nchar solve(const Node &n, ll i){\n    if(n.s.size() > i) return n.s[i];\n    for(auto child : n.v){\n        if(child.size * child.repeat <= i){\n            i -= child.size * child.repeat;\n        }else{\n            return solve(child, i % child.size);\n        }\n    }\n    //return n.s[i];\n}\n\nint main(){\n    while(1){\n        string S;\n        ll I;\n        cin >> S >> I;\n        if(S == \"0\" && !I) break;\n        S = \"(\" + S + \")\";\n        auto node = dfs(S);\n        if(node.size <= I) cout << 0 << endl;\n        else cout << solve(node, I) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 1e-8\n#define x first\n#define y second\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint>  vvint;\ntypedef pair<int,int> pint;\ntypedef long long Int;\n\nstruct node{\n\tInt x;\n\tInt n;\n\tstring s;\n\tvector<node*> childs;\n\tnode* parent;\n};\n\nint kind(char c){\n\tif(c>='0' && c<='9') return 0;\n\tif(c>='A' && c<='Z') return 1;\n\tif(c=='(') return 2;\n\tif(c==')') return 3;\n}\nint readint(string &s,int &n){\n\tint ans=0;\n\tfor(;n<s.length() && s[n]>='0' && s[n]<='9';ans*=10,n++){\n\t\tans+=s[n]-'0';\n\t}\n\treturn ans/10;\n}\nstring readstr(string &s,int &n){\n\tstring ans;\n\tfor(;n<s.length() && s[n]>='A' && s[n]<='Z';ans+=s[n],n++);\n\treturn ans;\n}\n\t\t\nint main(){\n\tstring in;\n\tint n;\n\twhile(cin >> in >> n){\n//\t\tcout << in << \"\t\" << n << endl;\n\t\tif(in[0]=='0' && n==0) break;\n\t\tnode *cur=new(node);\n\t\tcur->x=1;\n\t\tnode *root=cur;\n\t\tin=\"1(\" + in;\n\t\tin+=\")\";\n\t\tint p=0;\n\t\tfor(;p<in.length();){\n//\t\t\tcout << cur->x << \"\t\" << cur->n << \"\t\" << cur->s << endl;\n//\t\t\tcout << in[p] << endl;\n\t\t\tif(kind(in[p])==0){\n\t\t\t\tint t=readint(in,p);\n\t\t\t\tnode *c = new(node);\n\t\t\t\tc->x=t;\n\t\t\t\t(cur->childs).push_back(c);\n\t\t\t\tc->parent=cur;\n\t\t\t\tif(kind(in[p])==1){\n\t\t\t\t\tstring s=readstr(in,p);\n//\t\t\t\t\tcout << s << endl;\n\t\t\t\t\tc->s=s;\n\t\t\t\t\tc->n=s.length();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcur=c;\n\t\t\t\t\tp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(kind(in[p])==1){\n\t\t\t\tstring s=readstr(in,p);\n\t\t\t\tnode *c = new(node);\n\t\t\t\t(cur->childs).push_back(c);\n\t\t\t\tc->x=1;\n\t\t\t\tc->s=s;\n\t\t\t\tc->n=s.length();\n\t\t\t\tc->parent=cur;\n\t\t\t\tcontinue;\n\t\t\t}else if(kind(in[p])==3){\n\t\t\t\tcur->n=0;\n\t\t\t\tfor(int i=0;i<(cur->childs).size();i++){\n\t\t\t\t\tcur->n += (cur->childs[i]->n)*(cur->childs[i]->x);\n\t\t\t\t\tif(cur->n > 1000010) cur->n=1000010;\n//\t\t\t\t\tcout << cur->n << endl;\n\t\t\t\t}\n\t\t\t\tcur=cur->parent;\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tcur=(root->childs[0]);\n\t\tfor(;;){\n//\t\t\tcout << n << \"\t\" << (cur->n) << \"\t\" << (cur->x) <<endl;\n\t\t\tif(n>=(cur->n)*(cur->x)){\n\t\t\t\tcout << 0 << endl;\n\t\t\t\tbreak;\n\t\t\t}else if(cur->s != \"\"){\n\t\t\t\tcout << (cur->s)[n] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint i;\n\t\t\tfor(i=0;(i<(cur->childs).size()) && (n>=(cur->childs[i]->n)*(cur->childs[i]->x));n-=(cur->childs[i]->n)*(cur->childs[i]->x),i++);\n\t\t\tcur=(cur->childs)[i];\n\t\t\tn%=(cur->n);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nstring S;\nint K;\n\nint to[111];\nint len[111][111];\n\nint calcLen(int l,int r){\n\tint &ans=len[l][r];\n\tif(l==r)return ans=0;\n\tif(isalpha(S[l])){\n\t\treturn ans=min(1+calcLen(l+1,r),K+1);\n\t}\n\n\tint p=l;\n\tint num=0;\n\twhile(isdigit(S[p])){\n\t\tnum=num*10+S[p]-'0';\n\t\tp++;\n\t}\n\n\tif(isalpha(S[p])){\n\t\treturn ans=min(num+calcLen(p+1,r),K+1);\n\t}\n\telse{\n\t\treturn ans=min(num*calcLen(p+1,to[p])+calcLen(to[p]+1,r),K+1);\n\t}\n}\n\n\nvoid findChar(int l,int r,int k){\n\tif(isalpha(S[l])){\n\t\tif(k){\n\t\t\tfindChar(l+1,r,k-1);\n\t\t}\n\t\telse{\n\t\t\tcout<<S[l]<<endl;\n\t\t}\n\t\treturn;\n\t}\n\n\n\tint p=l;\n\tint num=0;\n\twhile(isdigit(S[p])){\n\t\tnum=num*10+S[p]-'0';\n\t\tp++;\n\t}\n\n\tif(isalpha(S[p])){\n\t\tif(k<num){\n\t\t\tcout<<S[p]<<endl;\n\t\t}\n\t\telse{\n\t\t\tfindChar(p+1,r,k-num);\n\t\t}\n\t}\n\telse{\n\t\tif(num*len[p+1][to[p]]>k){\n\t\t\tfindChar(p+1,to[p],k%len[p+1][to[p]]);\n\t\t}\n\t\telse{\n\t\t\tfindChar(to[p]+1,r,k-num*len[p+1][to[p]]);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tstack<int>st;\n\tint N=S.size();\n\trep(i,N){\n\t\tif(S[i]=='('){\n\t\t\tst.push(i);\n\t\t}\n\t\telse if(S[i]==')'){\n\t\t\tto[st.top()]=i;\n\t\t\tst.pop();\n\t\t}\n\t}\n\n\tcalcLen(0,N);\n\n\tif(len[0][N]<=K){\n\t\tcout<<0<<endl;\n\t\treturn;\n\t}\n\tfindChar(0,N,K);\n}\n\nsigned main(){\n\twhile(cin>>S>>K,S!=\"0\"){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<string, int> gs(const string& s, int i) {\n  string res = \"\";\n  if (i == (int)s.size()) return make_pair(res, i);\n  if('0' <= s[i] && s[i] <= '9') {\n    int v = 0;\n    while('0' <= s[i] && s[i] <= '9') {\n      v *= 10;\n      v += s[i] - '0';\n      ++i;\n    }\n    if (s[i] == '(') {\n      string ss;\n      int j;\n      tie(ss, j) = gs(s, i+1);\n      REP(k,v) {\n        if (res.size() > 1100000) break;\n        res += ss;\n      }\n      i = j+1;\n    } else {\n      res += string(v, s[i]);\n      ++i;\n    }\n  } else {\n    res += s[i];\n    ++i;\n  }\n  if (i == (int)s.size()) return make_pair(res, i);\n  if (s[i] != ')') {\n    string ss;\n    int j;\n    tie(ss, j) = gs(s,i);\n    if (res.size() <= 1100000)\n      res += ss;\n    i = j;\n  }\n  return make_pair(res, i);\n}\n\nint main() {\n  while(1){\n    string s;\n    int i;\n    cin>>s>>i;\n    if(s==\"0\"&&i==0) break;\n    string h1e6 = gs(s, 0).first;\n    if (i >= (int)h1e6.size()) cout << \"0\" << endl;\n    else cout << h1e6[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str,ans;\nint n,pos;\n\nstring saiki(int S){\n  int k=1;\n  string res,s;\n  while(pos<(int)str.size()&&str[pos]!=')'){\n    if(res.size()+S>n)return res;\n    if('0'<=str[pos]&&str[pos]<='9') {\n      k=0;\n      while('0'<=str[pos]&&str[pos]<='9')k=k*10+str[pos++]-'0';\n    }\n    else if(str[pos]=='('){\n      pos++;\n      s=saiki(res.size()+S);\n      pos++;\n      for(int i=0;i<k&&res.size()+S<=n;i++)res+=s;\n    }\n    else {\n      for(int i=0;i<k;i++) res+=str[pos];\n      pos++;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>str>>n;\n    if(str==\"0\"&&n==0)break;\n    pos=0;\n    ans=\"\";\n    ans=saiki(0);\n    if(ans.size()<=n)cout <<0<<endl;\n    else cout <<ans[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e13 + 9;\n\n#define int ll\n#define double ld\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\t\n\tstring s; int I;\n\twhile (cin >> s >> I && s != \"0\") {\n\t\tstruct node {\n\t\t\tint sum;\n\t\t\tvector<int> to;\n\t\t\tstring s;\n\t\t};\n\t\ts = s + \")\";\n\t\t{\n\t\t\tmap<int, string, greater<int>> add;\n\t\t\trep(i, s.size()) {\n\t\t\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\t\t\tadd[i] = \"1(\";\n\t\t\t\t}\n\t\t\t}\n\t\t\teach(i, add) {\n\t\t\t\ts = s.substr(0, i.first) + i.second + s.substr(i.first);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tmap<int, string, greater<int>> add;\n\t\t\trep(i, s.size()) {\n\t\t\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\t\t\tadd[i+1] = \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\teach(i, add) {\n\t\t\t\ts = s.substr(0, i.first) + i.second + s.substr(i.first);\n\t\t\t}\n\t\t}\n\t\tvector<node> nd;\n\t\tnd.push_back(node());\n\t\tfunction<int(int, int)> make_node = [&](int n, int t) {\n\t\t\tint sn = n;\n\t\t\twhile (s[n] >= 'A' && s[n] <= 'Z') {\n\t\t\t\tnd[t].s.push_back(s[n]); n++;\n\t\t\t}\n\t\t\tnd[t].sum = nd[t].s.size();\n\t\t\tfor (;; n++) {\n\t\t\t\tif (s[n] == '(') {\n\t\t\t\t\tint tp = toint(s.substr(sn, n - sn));\n\t\t\t\t\tnd.push_back(node());\n\t\t\t\t\tint tt = nd.size() - 1;\n\t\t\t\t\tn = make_node(n + 1, tt);\n\t\t\t\t\tnd[tt].sum *= tp;\n\t\t\t\t\tnd[tt].sum = min(INF, nd[tt].sum);\n\t\t\t\t\tnd[t].sum += nd[tt].sum;\n\t\t\t\t\tnd[t].sum = min(INF, nd[t].sum);\n\t\t\t\t\tnd[t].to.push_back(tt);\n\t\t\t\t\tsn = n + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s[n] == ')') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmake_node(0, 0);\n\n\t\tfunction<char(int, int)> search = [&](int t,int c) {\n\t\t\tif (nd[t].s.size()) {\n\t\t\t\tc %= nd[t].s.size();\n\t\t\t\treturn nd[t].s[c];\n\t\t\t}\n\t\t\twhile (1) {\n\t\t\t\teach(to, nd[t].to) {\n\t\t\t\t\tif (nd[to].sum > c) {\n\t\t\t\t\t\treturn search(to, c);\n\t\t\t\t\t}\n\t\t\t\t\tc -= nd[to].sum;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (nd[0].sum <= I) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << search(0, I) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000200\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e;\n\t}\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<n+500;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e-1;\n\t  continue;\n\t}\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<n+500;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nlong long int getlen(string s)\n{\n\tlong long int ans = 0;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(isdigit(s[i])){\n\t\t\tlong long int num = s[i] - '0';\n\t\t\ti++;\n\t\t\twhile(isdigit(s[i])){\n\t\t\t\tnum = num * 10 + (s[i] - '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(s[i] != '('){\n\t\t\t\tans += num;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint kakko = 1;\n\t\t\tint tmp = i + 1;\n\t\t\twhile(kakko > 0){\n\t\t\t\tif(s[tmp] == '(') kakko++;\n\t\t\t\telse if(s[tmp] == ')') kakko--;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tstring tmps = s.substr(i + 1, tmp - 1 - (i + 1));\n\t\t\tans += num * getlen(tmps);\n\t\t\ti = tmp - 1;\n\t\t} else {\n\t\t\tans++;\n\t\t}\n\t\tif(ans > mod) ans = mod;\n\t}\n\t// cout << s << \" \" << ans << endl;\n\treturn ans;\n}\n\nchar solve(string s, int n)\n{\n\t// cout << s << n << endl;\n\tlong long int nowlen = 0;\n\tbool allchar = true;\n\tfor(int i = 0; i < s.length(); i++){\n\t\tif(isdigit(s[i])){\n\t\t\tallchar = false;\n\t\t\tlong long int num = s[i] - '0';\n\t\t\ti++;\n\t\t\twhile(isdigit(s[i])){\n\t\t\t\tnum = num * 10 + (s[i] - '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(s[i] != '('){\n\t\t\t\t// cout << s[i] << nowlen + num << endl;\n\t\t\t\tif(nowlen + num > n) return s[i];\n\t\t\t\telse {\n\t\t\t\t\tnowlen += num;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint kakko = 1;\n\t\t\tint tmp = i + 2;\n\t\t\twhile(kakko > 0){\n\t\t\t\tif(s[tmp] == '(') kakko++;\n\t\t\t\telse if(s[tmp] == ')') kakko--;\n\t\t\t\ttmp++;\n\t\t\t}\n\t\t\tstring tmps = s.substr(i + 1, tmp - 1 - (i + 1));\n\t\t\tlong long int tmpl = getlen(tmps);\n\t\t\t// cout << tmps << \" \" << tmpl << \" \" << nowlen << \" \" << n << \" \" << num << endl;\n\t\t\tif(nowlen + num * tmpl > n) return solve(tmps, (n - nowlen) % tmpl);\n\t\t\ti = tmp - 1;\n\t\t\tnowlen += num * tmpl;\n\t\t\t// cout << nowlen << endl;\n\t\t} else {\n\t\t\tif(nowlen == n) return s[i];\n\t\t\tnowlen++;\n\t\t}\n\t}\n\tif(allchar && n < s.length()) return s[n];\n\treturn '0';\n}\n\nint main()\n{\n\tstring s;\n\tint n;\n\twhile(1){\n\t\tcin >> s >> n;\n\t\tif(s == \"0\") break;\n\t\tcout << solve(s, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool flag = false;\n\nstring kansu( string s, long long int i, long long int k ) {\n\n  string b = \"\";\n  long long int rep = 0;\n  while( true ) {\n\n    //    cout << \"i = \" << i << \" : k = \" << k << endl;\n\n    if ( s[i] >= '0' && s[i] <= '9' ) {\n\n      rep = rep * 10 + s[i] - '0';\n\n    }else if ( s[i] == '(' ) {\n\n      i++;\n      string r = kansu( s, i, k );\n      if ( flag == true ) return \"\";\n\n      for ( long long int j = 0; j < rep; j++ ) {\n\n\tif ( k < r.size() ) {\n\t  cout << r[k] << endl;\n\t  flag = true;\n\t  return \"\";\n\t}else {\n\t  b += r;\n\t  k -= r.size();\n\t}\n\n      }\n\n      rep = 0;\n\n      for ( long long int j = 0; j >= 0; i++ ) {\n\tif ( s[i] == '(' ) {\n\t  j++;\n\t}else if ( s[i] == ')' ) {\n\t  j--;\n\t}\n      }\n\n    }else if ( s[i] == ')' ) {\n\n      return b;\n\n    }else {\n\n      if ( rep == 0 ) rep = 1;\n      for ( long long int j = 0; j < rep; j++ ) {\n\tif ( k == 0 ) {\n\t  cout << s[i] << endl;\n\t  flag = true;\n\t  return \"\";\n\t}\n\tb += s[i];\n\tk--;\n      }\n      rep = 0;\n\n    }\n\n    i++;\n\n  }\n\n}\n\nint main() {\n\n  while( true ) {\n\n    string s;\n    long long int k;\n    cin >> s >> k;\n    if ( s == \"0\" ) break;\n\n    flag = false;\n\n    kansu( s + \")\", 0, k );\n\n    if ( flag == false ) {\n      cout << 0 << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n\nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n\nvoid dfs(int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    while('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int ss=r.first,num=r.second;\n      int idx=r.first,z=r.first;\n      if(s[ss]=='('){\n\tint c=1;\n\tidx=ss+1;\n\tfor(z=idx;z<=e&&c;z++){\n\t  if(s[z]=='(')c++;\n\t  if(s[z]==')')c--;\n\t}\n\tp=z;\n\tz-=2;\n\tfor(int i=0;i<num;i++)dfs(idx,z);\n      }else{\n\tfor(int i=0;i<num;i++)ans+=s[ss];\n\tp=ss+1;\n      }\n    }\n    while('A'<=s[p]&&s[p]<='Z')ans+=s[p],p++;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,s.size()-1);\n    if(ans.size()>=n+1)cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nstring in;\nchar search(int s, int& e, int p, int& len){\n\tif(s==in.size()){\n\t\tlen=0;\n\t\treturn 0;\n\t}\n\t//cout << s << \", \" << p << \", \" << in[s] << endl;\n\tif(in[s]==')'){\n\t\tlen=0;\n\t\te=s+1;\n\t\treturn 0;\n\t}\n\tif(in[s]=='('){\n\t\tchar c=search(s+1,e,p,len);\n\t\tif(c){\n\t\t\treturn c;\n\t\t}\n\t\tp-=len;\n\t}\n\telse\n\t{\n\t\tint r=s;\n\t\tint v=0;\n\t\twhile('0'<=in[r]&&in[r]<='9'){\n\t\t\tv*=10;\n\t\t\tv+=in[r]-'0';\n\t\t\tr++;\n\t\t}\n\t\tif(v>0){\n\t\t\tint l=0;\n\t\t\tchar c=search(r,e,p,l);\n\t\t\tif(c){\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\tif(p<l*v){\n\t\t\t\treturn search(r,e,p%l,l);\n\t\t\t}\n\t\t\tp-=l*v;\n\t\t\tlen=l*v;\n\t\t}\n\t\telse{\n\t\t\tif(p==0){\n\t\t\t\treturn in[s];\n\t\t\t}\n\t\t\tp--;\n\t\t\te=s+1;\n\t\t\tlen=1;\n\t\t}\n\t}\n\tint len2;\n\tchar ret=search(e,e,p,len2);\n\tlen+=len2;\n\treturn ret;\n}\nint main() {\n\tint pos=0;\n\twhile(cin >> in >> pos){\n\t\tif(in[0]=='0'&&pos==0){\n\t\t\treturn 0;\n\t\t}\n\t\t//cout << in << \", \" << pos << endl;\n\t\tint e,len;\n\t\tchar c=search(0,e,pos,len);\n\t\tif(c==0){\n\t\t\tc='0';\n\t\t}\n\t\tcout << c << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nclass Parsing{\npublic:\n  string parse;\n  int pos,size,x;\n  Parsing(string p,int x):parse(p),x(x),size(0),pos(0){}\n  int readNum(){\n    int ret = 0;\n    while(isdigit(parse[pos])){\n      ret*=10;\n      ret+=parse[pos++]-'0';\n    }\n    return ret;\n  }\n  string decode(){\n    int n = readNum();\n    if(parse[pos]=='(') ++pos;\n    else{\n      string mes=\"\",ret=\"\";\n      while(isalpha(parse[pos])) mes+=parse[pos++];\n      for(int i=0;i<n;++i){\n\tret+=mes;\n\tif(ret.size()>=x) break;\n      }\n      return ret;\n    }\n    string mes=\"\";\n    while(isdigit(parse[pos]) || isalpha(parse[pos])){\n      if(isdigit(parse[pos])) mes+=decode();\n      else if(isalpha(parse[pos])) mes+=parse[pos++];\n    }\n    if(parse[pos]==')') ++pos;\n    string ret=\"\";\n    for(int i=0;i<n;++i){\n      ret+=mes;\n      if(ret.size()>=x) break;\n    }\n    return ret;\n  }\n\n  string exp(){\n    string ret;\n    for(;pos<parse.size();){\n      if(isdigit(parse[pos])) ret+=decode();\n      else ret+=parse[pos++],size++;\n      if(ret.size()>=x) break;\n    }\n    return ret;\n  }\n};\n\nint main(){\n  string s;\n  int p;\n  while(true){\n    cin >> s >> p;\n    if(s==\"0\") break;\n    Parsing par = Parsing(s,p+1);\n    string mes = par.exp();\n    //    cout << mes << endl;\n    if(mes.size() <= p) cout << 0 << endl;\n    else cout << mes[p] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nenum State{PLUS,MULTI,NUM,CHAR,END};\n\nstruct Node{\n\tNode* node1;\n\tNode* node2;\n\tint num;\n\tchar c;\n\tState state;\n\tint length;\n};\n\nint isChar(char c){return 'A'<=c && c<='Z';}\nint isNum(char c){return '0'<=c && c<='9';}\n\nint getNum(string str,int st,int en){\n\tint ret = 0;\n\tfor(int i=st;i<en;i++){\n\t\tret*=10;\n\t\tret+=str[i]-'0';\n\t}\n\treturn ret;\n}\nint cLen(string& str, int st, int en){\n\tif(isChar(str[st]))return 1;\n\tint pos = st;\n\tint count = 0;\n\twhile(1){\n\t\tif(str[pos]=='(')count++;\n\t\tif(str[pos]==')')count--;\n\t\tpos++;\n\t\tif(count==0)break;\n\t}\n\treturn pos-st;\n}\nint numLen(string& str, int st,int en){\n\tint pos = st;\n\twhile(1){\n\t\tif(pos==en || !isNum(str[pos]))break;\n\t\tpos++;\n\t}\n\treturn pos-st;\n}\n\nNode* nNode(){\n\tNode* ret = new Node;\n\tret->node1 = NULL;\n\tret->node2 = NULL;\n\tret->state = END;\n\tret->num = 0;\n\tret->c = '*';\n\tret->length = 0;\n\treturn ret;\n}\nNode* makeCharNode(char c){\n\tNode* ret = nNode();\n\tret->state = CHAR;\n\tret->c = c;\n\treturn ret;\n}\nNode* makeNumNode(int num){\n\tNode* ret = nNode();\n\tret->state = NUM;\n\tret->num = num;\n\treturn ret;\n}\n\nNode* solveF(string& str, int st, int en);\nNode* solveC(string& str, int st, int en){\n\tNode* ret;\t\n\tif(en-st==1)ret = makeCharNode(str[st]);\n\telse ret = solveF(str, st+1, en-1);\n\treturn ret;\n}\nNode* solveT(string& str, int st, int en){\n\tNode* ret;\n\tint len = numLen(str,st,en);\n\tif(len==0)ret = solveC(str, st, en);\n\telse{\n\t\tret = nNode();\n\t\tret->node1 = makeNumNode(getNum(str,st,st+len));\n\t\tret->node2 = solveC(str, st+len, en);\n\t\tret->state = MULTI;\n\t}\n\treturn ret;\n}\nNode* solveF(string& str, int st, int en){\n\tNode* ret;\t\n\tint len = numLen(str,st,en);\n\tint len2 = cLen(str,st+len,en);\n\tif(st+len+len2==en)ret = solveT(str,st,en);\n\telse{\n\t\tret = nNode();\n\t\tret->node1 = solveT(str,st,st+len+len2);\n\t\tret->node2 = solveF(str,st+len+len2,en);\n\t\tret->state = PLUS;\n\t}\n\treturn ret;\n}\n\nvoid printNode(Node* node, int depth){\n\tcout<<\"depth:\"<<depth<<\" state:\"<<node->state<<\" num:\"<<node->num\n\t\t<<\" char:\"<<node->c<<\" len:\"<<node->length<<endl;\n\t\n\tif(node->node1!=0)printNode(node->node1, depth+1);\n\tif(node->node2!=0)printNode(node->node2, depth+1);\n}\n\nint calcLength(Node* node){\n\tif(node->length!=0)return node->length;\n\t\n\tint ret = 0;\n\tif(node->state == PLUS){\n\t\tint val1 = calcLength(node->node1);\n\t\tint val2 = calcLength(node->node2);\n\t\tret = val1+val2;\n\t}\n\tif(node->state == MULTI){\n\t\tint val = calcLength(node->node2);\n\t\tint scale = node->node1->num;\n\t\tret = scale * val;\n\t}\n\tif(node->state == CHAR){\n\t\tret = 1;\n\t}\n\treturn node->length = min(1000001,ret);\n}\n\nchar getChar(Node* node, int lest){\n\tif(node->length <= lest)return '0';\n\t\n\tif(node->state == CHAR){\n\t\treturn node->c;\n\t}\n\tif(node->state == MULTI){\n\t\tlest %= node->node2->length;\n\t\treturn getChar(node->node2, lest);\n\t}\n\tif(node->state == PLUS){\n\t\tint left = node->node1->length;\n\t\tif(lest<left){\n\t\t\treturn getChar(node->node1, lest);\n\t\t}else{\n\t\t\treturn getChar(node->node2, lest-left);\n\t\t}\n\t}\n\treturn '0';\n}\n\nint main(){\n\tA:;\n\tint m;\n\tstring str;\n\tcin>>str>>m;\n\t\n\tif(str==\"0\")return 0;\n\t\n\tNode* root = solveF(str, 0, str.size());\n\tcalcLength(root);\n\t//printNode(root,0);\n\tprintf(\"%c\\n\",getChar(root,m));\n\t\n\tgoto A;\n}\n\n/*\n1000(1000(1000(1000(1000(1000(NM)))))) 999999\n0 0\n\n2(4(AB)3(XY))10C 30\n\n2(4(AB)3(XY))10C 0\n2(4(AB)3(XY))10C 21\n\n2(4(AB)3(XY))10C\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nint pos;\nstring s;\nint n;\nstring f();\nstring expr(){\n\t//cout<<\"-------\"<<endl;\n\tstring a=f();\n\t//cout<<a<<endl;\n\twhile(isdigit(s[pos])||isalpha(s[pos])){\n\t\tif(a.size()>n)\n\t\treturn a;\n\t\ta+=f();\n\t}\n\treturn a;\n}\nstring f(){\n\tif(isdigit(s[pos])){\n\t\tint ret=0;\n\t\tfor(;isdigit(s[pos]);pos++){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t}\n\t\t//cout<<ret<<endl;\n\t\tstring t=\"\";\n\t\tstring p=f();\n\t\tfor(int i=0;i<ret;i++){\n\t\t\tt+=p;\n\t\t\tif(t.size()>n)\n\t\t\t\treturn t;\n\t\t\n\t\t}\n\t\t//cout<<t<<endl;\n\t\treturn t;\n\t}else if(s[pos]=='('){\n\t\tpos++;\n\t\tstring t=expr();\n\t\tpos++;\n\t\treturn t;\n\t}else{\n\t\tstring t=\"\";\n\t\tfor(;isalpha(s[pos]);pos++){\n\t\t\tt+=s[pos];\n\t\t\tif(t.size()>n)\n\t\t\t\treturn t;\n\t\t\n\t\t}\n\t\treturn t;\n\t}\n}\nint main(){\n\t\n\twhile(cin>>s>>n,s!=\"0\"||n){\n\t\tpos=0;\n\t\ts+=\"#\";\n\t\tstring t=expr();\n\t\t//cout<<t<<endl;\n\t\tif(t.size()-1<n)\n\t\tcout<<0<<endl;\n\t\telse\n\t\tcout<<t[n]<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nint pos,n;#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nint pos,n;\nstring s,t,p;\nstring f();\nstring expr(){\n\tstring a=f();\n\twhile(isdigit(s[pos])||isalpha(s[pos])){\n\t\tif(a.size()>n)\n\t\t\tbreak;\n\t\ta+=f();\n\t}\n\treturn a;\n}\nstring f(){\n\tt=\"\";\n\tif(isdigit(s[pos])){\n\t\tint ret=0,i=0;\n\t\tfor(;isdigit(s[pos]);pos++){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t}\n\t\tp=f();\n\t\tfor(;i<ret;i++){\n\t\t\tt+=p;\n\t\t\tif(t.size()>n)\n\t\t\t\tbreak;\n\t\t}\n\t}else if(s[pos]=='('){\n\t\tpos++;\n\t\tt=expr();\n\t\tpos++;\n\t}else{\n\t\tfor(;isalpha(s[pos]);pos++){\n\t\t\tt+=s[pos];\n\t\t\tif(t.size()>n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\nint main(){\n\twhile(cin>>s>>n,s!=\"0\"||n){\n\t\tpos=0;\n\t\ts+=\"#\";\n\t\tstring t=expr();\n\t\tif(t.size()-1<n)\n\t\tcout<<0<<endl;\n\t\telse\n\t\tcout<<t[n]<<endl;\n\t}\n\treturn 0;\n}\nstring s;\nstring f();\nstring expr(){\n\tstring a=f();\n\twhile(isdigit(s[pos])||isalpha(s[pos])){\n\t\tif(a.size()>n)\n\t\treturn a;\n\t\ta+=f();\n\t}\n\treturn a;\n}\nstring f(){\n\tstring t;\n\tif(isdigit(s[pos])){\n\t\tint ret=0;\n\t\tfor(;isdigit(s[pos]);pos++){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t}\n\t\tt=\"\";\n\t\tstring p=f();\n\t\tfor(int i=0;i<ret;i++){\n\t\t\tt+=p;\n\t\t\tif(t.size()>n)\n\t\t\t\treturn t;\n\t\t\n\t\t}\n\t}else if(s[pos]=='('){\n\t\tpos++;\n\t\tt=expr();\n\t\tpos++;\n\t}else{\n\t\tt=\"\";\n\t\tfor(;isalpha(s[pos]);pos++){\n\t\t\tt+=s[pos];\n\t\t\tif(t.size()>n)\n\t\t\t\treturn t;\n\t\t}\n\t}\n\treturn t;\n}\nint main(){\n\twhile(cin>>s>>n,s!=\"0\"||n){\n\t\tpos=0;\n\t\ts+=\"#\";\n\t\tstring t=expr();\n\t\tif(t.size()-1<n)\n\t\tcout<<0<<endl;\n\t\telse\n\t\tcout<<t[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse,int x):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt(){return StringToInt(getCnt());}\n\n  string decode()\n  {\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    else \n      {\n\tstring mes,ret;\n\twhile('A' <= parse[pos] && parse[pos] <= 'Z')\t\n\t  mes += parse[pos++];\n\t\n\tfor(int i=0;i<power;i++)\n\t  {\n\t    ret += mes;\n\t    if(ret.size() >= x)\n\t      break;\n\t  }\n\treturn ret;\t  \n      }\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n  \n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+1);\n      string message = par.exp();\n      message.size() <= pos?cout << 0 << endl:cout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define D double\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nbool flag;\nchar ans;\n\nint calc(string &s, int &id) {\n\tint t = 0;\n\twhile (range(s[id], '0', '9' + 1)) {\n\t\tt *= 10;\n\t\tt += s[id] - '0';\n\t\tid++;\n\t} \n\treturn t;\n}\n\nint dfs(string s, int x){\n  int n = s.size();\n  int cur = 0;\n  REP(i,n){  \n    if(isalpha(s[i])){\n      if(cur == x){\n        flag = true;\n        ans = s[i];\n        return 0;\n      }\n      cur++; continue;\n    }\n    int k = calc(s,i);\n    string t;\n    if(isalpha(s[i])) t = s[i];\n    else{\n      int id = i, sum = 1;\n      while(sum){\n        i++;\n        if(s[i] == '(') sum++;\n        if(s[i] == ')') sum--;\n      }\n      t = s.substr(id+1,i-id-1);\n      //debug(t);\n    }\n    REP(_,k){\n      int tmp = dfs(t,x-cur);\n      if(flag) return 0;\n      cur += tmp;\n    }\n  }\n  return cur;\n}\n\nvoid solve(string s, int x) {\n\tint n = s.size();\n  ans = '0'; flag = false;\n\n  dfs(s,x);\n\n  cout << ans << endl;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int x; string s;\n  while(cin >> s >> x, s != \"0\") solve(s,x);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,pos,cnt;\nstring str;\nchar ans;\n\nvoid factor();\n\nvoid exp(){\n  while(str[pos] >= 'A' && str[pos] <= 'Z' && pos < str.size()){\n    if(n == cnt) ans = str[pos];\n    pos++;\n    cnt++;\n  }\n}\n\nvoid factor(){\n  while(pos < str.size() && ans == '0' && cnt <= 1000000 && str[pos] != ')'){\n    int num = 0;\n    while(str[pos] >= '0' && str[pos] <= '9' && pos < str.size()){\n      num *= 10;\n      num += str[pos++] - '0';\n    }    \n    if(str[pos] == '('){\n      pos++;\n      int prev = pos;\n      for(int i=0;i<num;i++) {\n        if(str[pos] >= 'A' && str[pos] <= 'Z') exp();\n        else factor();\n        if(i != num - 1) pos = prev;\n      }\n      pos++;\n    } else {\n      if(num == 0) exp();\n      else {\n        if(cnt <= n && n < cnt + num) ans = str[pos];\n        cnt += num;\n        pos++;\n      }\n    }\n  }\n}\n\nvoid solve(){\n  pos = cnt = 0;\n  ans = '0';\n  factor();\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> str >> n && (str != \"0\" || n)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nchar solve(string str, int &index, size_t &pos){\n\t//cout << \"solve : \" << str << endl;\n\tint cnt = 1, len = str.length();\n\tif( str[0] == '(' ){\n\t\tstr = str.substr(1);\n\t\tcnt = -1;\n\t}\n\twhile( !str.empty() && cnt-- ){\n\t\tif( str[0] >= '0' && str[0] <= '9' ){\n\t\t\tsize_t i, p;\n\t\t\tint num = stoi( str, &i );\n\t\t\tstring s = str.substr(i);\n\t\t\trep(k, num){\n\t\t\t\tchar res = solve( s, index, p );\n\t\t\t\tif( res != '0' ) return res;\n\t\t\t}\n\t\t\t//cout << p << endl;\n\t\t\tstr = s.substr(p);\n\t\t}else if( str[0] == ')' ){\n\t\t\tstr = str.substr(1);\n\t\t\tbreak;\n\t\t}else{\n\t\t\tint i=0;\n\t\t\twhile(str[i] < '0' || str[i] > '9'){\n\t\t\t\tif( str[i] == ')' ) break;\n\t\t\t\tif( index-- == 0 ) return str[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr = str.substr(i);\n\t\t}\n\t}\n\tpos = len - str.length();\n\treturn '0';\n}\n\nint main(){\n\tstring s;\n\tint i;\n\twhile(cin>>s>>i, s != \"0\" ){\n\t\trep(j, s.length()){\n\t\t\tif( s[j] == '(' && ( j == 0 || s[j-1] < '0' || s[j-1] > '9') ){\n\t\t\t\ts = s.substr(0, j) + \"1\" + s.substr(j);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tstring ss = \"1(\" + s + \")\";\n\t\tsize_t p;\n\t\tcout << solve(ss, i, p) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      if(s[0] == ')') { return; }\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\n#include<cstdlib>\n#define inf 1<<29\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\nstring s;\nchar ans;\nvector<string> v;\nmap<int,int> mp;\nbool flag=false;\n\nll rec(int,int,ll);\n\nvoid rec2(int a,int b,ll sum){\n  flag=true;\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],0);\n\tif(sum<tmp*atoi(v[i].c_str()))rec2(i+2,mp[i+1],sum%tmp);\n\telse sum-=tmp*atoi(v[i].c_str());\n\tif(ans!='0')return;\n        i=mp[i+1];\n      }\n      else {\n        ll tmp=atoi(v[i].c_str());\n        if(sum<tmp){\n\t  ans=v[i+1][0];\n\t  return;\n\t}\n\telse {\n\t  sum-=tmp;\n\t  i++;\n\t}\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      if(sum<v[i].length()){\n\tans=v[i][sum];\n\treturn;\n      }\n      else sum-=v[i].length();\n    }\n    else {}\n  }\n  return;\n}\n\nll rec(int a,int b,ll c){\n  ll sum=0;\n  if(ans!='0')return inf;\n\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return inf;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],sum+c);\n\tif(ans!='0')return inf;\n\tsum+=atoi(v[i].c_str())*tmp;\n\ti=mp[i+1];\n      }\n      else {\n\tsum+=atoi(v[i].c_str())*v[i+1].length();\n\ti++;\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      sum+=v[i].length();\n    }\n    else {}\n  }\n  if(n<sum && c<=n)rec2(a,b,n-c);\n  return sum;\n}\n\nint main()\n{\n  while(1){\n    cin>>s>>n;\n    if(s[0]=='0' && n==0)break;\n    ans='0';\n    v.clear();mp.clear();\n    string tmp1=\"\",tmp2=\"\";\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tif(tmp2!=\"\")v.push_back(tmp2);\n\ttmp2=\"\";\n\ttmp1+=s[i];\n      }\n      if('A'<=s[i] && s[i]<='Z'){\n\tif(tmp1!=\"\")v.push_back(tmp1);\n\ttmp1=\"\";\n\ttmp2+=s[i];\n      }\n      if(s[i]=='('){\n\tv.push_back(tmp1);\n\ttmp1=\"\";\n\tv.push_back(\"(\");\n      }\n      if(s[i]==')'){\n        v.push_back(tmp2);\n        tmp2=\"\";\n        v.push_back(\")\");\n      }\n      if(i==s.length()-1 && tmp2!=\"\")v.push_back(tmp2);\n    }\n    stack<int> st;\n    for(int i=0;i<v.size();i++){\n      if(v[i]==\"(\")st.push(i);\n      if(v[i]==\")\"){\n\tmp[st.top()]=i;\n\tst.pop();\n      }\n    }\n    flag=false;  \n    rec(0,v.size(),0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str,ans;\nint n,pos;\n\nstring saiki(int S){\n  int k=1;\n  string res,s;\n  while(pos<(int)str.size()&&str[pos]!=')'&&(int)res.size()+S<=n){\n    if('0'<=str[pos]&&str[pos]<='9') {\n      k=0;\n      while('0'<=str[pos]&&str[pos]<='9')k=k*10+str[pos++]-'0';\n    }\n    else if(str[pos]=='('){\n      pos++;\n      s=saiki(res.size()+S);\n      for(int i=0;i<k&&res.size()+S<=n;i++)res+=s;\n      pos++,k=1;\n    }\n    else {\n      for(int i=0;i<k;i++) res+=str[pos];\n      pos++,k=1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>str>>n;\n    if(str==\"0\"&&n==0)break;\n    pos=0;\n    ans=\"\";\n    ans=saiki(0);\n    if(ans.size()<=n)cout<<0<<endl;\n    else cout <<ans[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\n\nusing State = string::const_iterator;\nclass ParseError {};\n\nstring s;\nvector<LL> table;\n\nconst LL INF = 1e7;\n\nLL Num(State& begin) {\n    LL ret = 0;\n    while ('0' <= *begin && *begin <= '9') {\n        ret *= 10;\n        ret += *begin - '0';\n        chmin(ret, INF);\n        begin++;\n    }\n    return ret;\n}\n\nLL Molecules(State& begin);\n\nLL Molecule(State& begin) {\n    if ('A' <= *begin && *begin <= 'Z') {\n        int id = begin - s.begin();\n        begin++;\n        return table[id] = 1;\n    }\n    else if ('0' <= *begin && *begin <= '9') {\n        int id0 = begin - s.begin();\n        LL n = Num(begin);\n        if (*begin == '(') {\n            int id1 = begin - s.begin();\n            begin++;\n            LL mol = Molecules(begin);\n            begin++;\n\n            table[id1] = mol;\n            table[id0] = n * mol;\n            chmin(table[id0], INF);\n            return table[id0];\n        }\n        else if ('A' <= *begin && *begin <= 'Z') {\n            int id1 = begin - s.begin();\n            begin++;\n            table[id1] = 1;\n            table[id0] = n;\n            chmin(table[id0], INF);\n            return table[id0];\n        }\n    } else {\n        throw ParseError();\n    }\n}\n\nLL Molecules(State& begin) {\n    LL total = 0;\n    while (true) {\n        try {\n            total += Molecule(begin);\n            chmin(total, INF);\n        }\n        catch (ParseError) {\n            break;\n        }\n    }\n    return total;\n}\n\nchar Molecules(State& begin, int m);\n\nchar Molecule(State& begin, int m) {\n    if ('A' <= *begin && *begin <= 'Z') {\n        if (m == 0) {\n            return *begin;\n        }\n        begin++;\n    }\n    else if ('0' <= *begin && *begin <= '9') {\n        int id0 = begin - s.begin();\n        LL n = Num(begin);\n        if (*begin == '(') {\n            int id1 = begin - s.begin();\n            begin++;\n\n            if (table[id0] > m) {\n                return Molecules(begin, m % table[id1]);\n            }\n            LL mol = Molecules(begin);\n            begin++;\n\n        }\n        else if ('A' <= *begin && *begin <= 'Z') {\n            if (m < n) {\n                return *begin;\n            }\n            begin++;\n        }\n    } else {\n        throw ParseError();\n    }\n}\n\nchar Molecules(State& begin, int m) {\n    while (true) {\n        try {\n            int id = begin - s.begin();\n            if (table[id] > m) {\n                return Molecule(begin, m);\n            } else {\n                Molecule(begin);\n                m -= table[id];\n            }\n        }\n        catch (ParseError) {\n            break;\n        }\n    }\n    return '0';\n}\n\nint main()\n{\n    while (true) {\n        cin >> s;\n        int n; cin >> n;\n        if (s.size() == 1 && s[0] == '0' && n == 0) {\n            break;\n        }\n        table.resize(s.size());\n        State begin = s.begin();\n        Molecules(begin);\n\n        begin = s.begin();\n        cout << Molecules(begin, n) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nbool out;\nbool output(string s, ll I, ll mult, bool f){\n    if(!f && s.size() * mult < I) return false;\n    out = 1;\n    I %= s.size();\n    cout << s[I] << endl;\n    return true;\n}\nint main(){\n    while(1){\n        string s;\n        ll I;\n        cin >> s >> I;\n        if(s == \"0\" && !I) break;\n        stack<ll> st;\n        string now = \"\";\n        ll num = 0;\n        ll mult = 1;\n        bool f = 0;\n        for(char c : s){\n            if('0' <= c && c <= '9'){\n                num = num * 10 + (c - '0');\n            }else if(c == '('){\n                st.push(num);\n                mult *= num;\n                num = 0;\n                if(mult >= I){\n                    mult = 1;\n                    f = 1;\n                }\n            }else if('A' <= c && c <= 'Z'){\n                if(num != 0){\n                    I -= num;\n                    if(I <= 0 || f){\n                        out = 1;\n                        cout << c << endl;\n                        break;\n                    }\n                }\n                for(ll i = 0; i < max<ll>(1, num); i++) now += c;\n                num = 0;\n            }else if(c == ')'){\n                ll tmp = st.top();\n                st.pop();\n                if(output(now, I, mult, f)){\n                    break;\n                }else{\n                    I -= now.size() * mult;\n                    now = \"\";\n                }\n                mult /= tmp;\n            }\n        }\n        if(!out){\n            if(I < now.size()) cout << s[I] << endl;\n            else cout << 0 << endl;\n        }\n        out = 0;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(const string str,const int from,const int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<=idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\npair<string, int> gs(const string& s, int i) {\n  string res = \"\";\n  if (i == (int)s.size()) return make_pair(res, i);\n  if('0' <= s[i] && s[i] <= '9') {\n    int v = 0;\n    while('0' <= s[i] && s[i] <= '9') {\n      v *= 10;\n      v += s[i] - '0';\n      ++i;\n    }\n    if (s[i] == '(') {\n      string ss;\n      int j;\n      tie(ss, j) = gs(s, i+1);\n      REP(k,v) {\n        if (res.size() > 1100000) break;\n        res += ss;\n      }\n      i = j+1;\n    } else {\n      res += string(v, s[i]);\n      ++i;\n    }\n  } else {\n    res += s[i];\n    ++i;\n  }\n  if (i == (int)s.size()) return make_pair(res, i);\n  if (s[i] != ')') {\n    string ss;\n    int j;\n    tie(ss, j) = gs(s,i);\n    if (res.size() <= 1100000)\n      res += ss;\n    i = j;\n  }\n  return make_pair(res, i);\n}\n\nint main() {\n  while(1){\n    string s;\n    int i;\n    cin>>s>>i;\n    if(s==\"0\"&&i==0) break;\n    string h1e6 = gs(s, 0).first;\n    if (i >= (int)h1e6.size()) cout << \"0\" << endl;\n    else cout << h1e6[i] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstring s; int n; int pos;\n\nint digit(){\n\tint ans = 0;\n\twhile(s[pos] >= '0' && s[pos] <= '9'){ ans = ans * 10 + s[pos] - '0'; pos++; }\n\treturn ans;\n}\nstring alpha(){\n\tstring ans = \"\";\n\twhile(s[pos] >= 'A' && s[pos] <= 'Z'){ ans += s[pos]; pos++; }\n\treturn ans;\n}\n\nstruct NODE{\n\tint len;\n\tstring val;\n\tvector< pair<int,NODE*> > next;\n\tNODE(){ len = 0; }\n};\n\nNODE* f(){\n\tint len = 0;\n\tNODE *c = new NODE;\n\twhile(s[pos] != ')'){\n\t\tif( s[pos] >= 'A' && s[pos] <= 'Z'){\n\t\t\tNODE *p = new NODE;\n\t\t\tp->val = alpha();\n\t\t\tp->len = p->val.size();\n\t\t\tc->next.push_back(make_pair(1,p));\n\t\t\tc->len += c->next.back().second->len;\n\t\t}else if( s[pos] >= '0' && s[pos] <= '9' ){\n\t\t\tint r = digit();\n\t\t\tif(s[pos] >=  'A'  && s[pos] <= 'Z'){\n\t\t\t\tNODE *p = new NODE;\n\t\t\t\tp->val = string(1,s[pos]);\n\t\t\t\tp->len = p->val.size();\n\t\t\t\tc->next.push_back(make_pair(r,p));\n\t\t\t\tc->len += r * c->next.back().second->len;\n\t\t\t\tpos++;\n\t\t\t}else if(s[pos] == '('){\n\t\t\t\tpos++;\n\t\t\t\tc->next.push_back(make_pair(r,f()));\n\t\t\t\tc->len += r * c->next.back().second->len;\n\t\t\t}else assert(0);\n\t\t}\n\t}\n\tpos++;\n\treturn c;\n}\nchar get(NODE *h,int n){\n\tif(h->val != \"\"){\n\t\treturn h->val[n];\n\t}\n\tint sum = 0;\n\tfor(int i = 0 ; i < h->next.size() ; i++){\n\t\twhile(h->next[i].first > 0){\n\t\t\tif(n - h->next[i].second->len < 0){\n\t\t\t\treturn get(h->next[i].second,n);\n\t\t\t}else{\n\t\t\t\tn -= h->next[i].second->len;\n\t\t\t}\n\t\t\th->next[i].first--;\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin >> s >> n && s != \"0\"){\n\t\tpos = 0;\n\t\ts += \")\";\n\t\tNODE *h = f();\n\t\tif(h->len <= n) cout << \"0\" << endl;\n\t\telse cout << get(h,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n\nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n\nvoid dfs(int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    while('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int x=r.first,num=r.second;\n      int y=r.first,z=r.first;\n      if(s[x]=='('){\n\tint c=1;\n\ty=x+1;\n\tfor(z=y;z<=e&&c;z++){\n\t  if(s[z]=='(')c++;\n\t  if(s[z]==')')c--;\n\t}\n\tp=z;\n\tz-=2;\n\twhile(num--)dfs(y,z);\n      }else{\n\twhile(num--)ans+=s[x];\n\tp=x+1;\n      }\n    }\n    while('A'<=s[p]&&s[p]<='Z')\n      ans+=s[p++];\n  }\n}\n\nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,s.size()-1);\n    if(ans.size()<n+1)\n      cout<<0<<endl;\n    else cout<<ans[n]<<endl;\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    string get_foo(const string &S, int &pos, function<int(int)> isfoo) {\n        int len = 0;\n        for(; isfoo(S[pos + len]); len++);\n        string ret = S.substr(pos, len);\n        pos += len;\n        return ret;\n    }\n    string calc(const string &S, int &pos, int N) {\n        bool paren = S[pos] == '(';\n        if(paren) pos++;\n        string res;\n        res.reserve(N + 1);\n        do {\n            if(isdigit(S[pos])) {\n                int rec = stoi(get_foo(S, pos, [](int a) { return isdigit(a); }));\n                int need = N - res.size();\n                string ss = calc(S, pos, need);\n                rep(i, rec) {\n                    rep(j, ss.size()) {\n                        res.push_back(ss[j]);\n                        if(res.size() >= N) goto A;\n                    }\n                }\n          A:;\n            } else if(isalpha(S[pos])) {\n                if(paren) {\n                    res.append(get_foo(S, pos, [](int a) { return isalpha(a); }));\n                } else {\n                    res.push_back(S[pos++]);\n                }\n            } else assert(0);\n        } while(paren and S[pos] != ')' and res.size() < N);\n        if(paren) pos++;\n        return res;\n    }\n    \n    bool solve() {\n        string S; cin >> S;\n        if(S == \"0\") return false;\n        int N; cin >> N;\n        cerr << S << \" \" << N << endl;\n        int pos = 0;\n        string s = \"\";\n\n        while(pos < S.size() and s.size() <= N) {\n            s += calc(S, pos, N - s.size() + 1);\n        }\n        cout << (s.size() <= N ? \"0\" : s.substr(N, 1)) << endl;        \n        return true;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int i = 0;\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define EPS 1e-9\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint cur,N;\nstring s;\n\nint dig(){\n\treturn s[cur++]-'0';\n}\n\nint num(){\n\tint n=dig();\n\twhile(cur<s.size()&&isdigit(s[cur]))n=n*10+dig();\n\treturn n;\n}\n\nchar cha(){\n\treturn s[cur++];\n}\n\nstring str(){\n\tstring st=\"\";\n\tst+=cha();\n\twhile(cur<s.size()&&isalpha(s[cur]))st+=cha();\n\treturn st;\n}\n\nstring gen(){\n\tstring st=\"\";\n\twhile(cur<s.size()&&s[cur]!=')'&&st.size()<=N){\n\t\tif(isdigit(s[cur])){\n\t\t\tint n=num();\n\t\t\tif(s[cur]=='('){\n\t\t\t\tcur++;\n\t\t\t\tstring st2=gen();\n\t\t\t\tcur++;\n\t\t\t\trep(i,n){\n\t\t\t\t\tst+=st2;\n\t\t\t\t\tif(st.size()>N)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchar c=cha();\n\t\t\t\trep(i,n){\n\t\t\t\t\tst+=c;\n\t\t\t\t\tif(st.size()>N)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse st+=str();\n\t}\n\treturn st;\n}\n\nint main(){\n\twhile(cin>>s>>N&&(s!=\"0\"||N)){\n\t\tcur=0;\n\t\tstring st=gen();\n\t\tif(st.size()<=N)cout<<0<<endl;\n\t\telse cout<<st[N]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cassert>\n#include <string>\nusing namespace std;\n\n#ifdef DEBUG\n#define dump(s) cerr << #s << \" = \" << s << endl\n#else\n#define dump(...)\n#endif\n\nchar s[5000];\nint len;\n\nint length(int const k, int const l, int const r)\n{\n    int cur = 0, res = 0, p = l;\n    while (s[p] && p < r)\n    {\n        if (isalpha(s[p]))\n        {\n            while (s[p] && p < r && isalpha(s[p]))\n            {\n                if (cur == k)\n                {\n                    throw s[p];\n                }\n                res++;\n                p++;\n                cur++;\n            }\n        }\n        else if (isdigit(s[p]))\n        {\n            int times = 0;\n            while (s[p] && p < r && isdigit(s[p]))\n            {\n                times = times * 10 + s[p] - '0';\n                p++;\n            }\n            int d = 0, i = p;\n            p++;\n            assert(s[i] == '(');\n            while (1)\n            {\n                if (s[i] == '(') d++;\n                else if (s[i] == ')') d--;\n                if (d == 0) break;\n                i++;\n            }\n            int rangelen = length(k, p, i);\n            for (int j = 0; j < times; j++)\n            {\n                res += length(k - cur, p, i);\n                cur += rangelen;\n            }\n            p = i + 1;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    static char t[5000];\n    int k;\n    while (cin >> t >> k && t[0] != '0')\n    {\n        int tlen = strlen(t);\n        len = 0;\n        for (int i = 0; i < tlen; i++)\n        {\n            if (i > 0 && isdigit(t[i - 1]) && isalpha(t[i]))\n            {\n                s[len++] = '(';\n                s[len++] = t[i];\n                s[len++] = ')';\n            }\n            else\n            {\n                s[len++] = t[i];\n            }\n        }\n        s[len] = 0;\n\n        try\n        {\n            length(k, 0, len);\n            puts(\"0\");\n        }\n        catch (char e)\n        {\n            cout << e << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nchar ans;\nvoid saiki(string s, int &out, int &idx) {\n\tint num = 0;\n\twhile (idx<s.length()) {\n\t\tif (isdigit(s[idx])) {\n\t\t\tnum *= 10;\n\t\t\tnum += s[idx] - '0';\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tint idx2;\n\t\t\tREP(i, num) {\n\t\t\t\tidx2 = idx;\n\t\t\t\tsaiki(s, out, idx2);\n\t\t\t\tif (ans != '0'||out<0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tidx = idx2;\n\t\t\tnum = 0;\n\t\t}\n\t\telse if (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tstring s2 = \"\";\n\t\t\twhile ('A' <= s[idx] && s[idx] <= 'Z') {\n\t\t\t\ts2 +=s[idx];\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tREP(i,max(1,num))\n\t\t\tif (out < s2.length()) {\n\t\t\t\tans = s2[out];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout -= s2.length();\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tstring s;\n\tint out;\n\twhile (cin >> s >> out, s != \"0\") {\n\t\tint idx = 0;\n\t\tans = '0';\n\t\tsaiki(s, out, idx);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll id;\nint N, c;\nstring s;\n\nconst ll MAX = 2000000;\n\nstruct Node {\n\tll v, len;\n\tstring s;\n\tvector<Node*> children;\n\tNode() : v(1), len(0), s(string()) {}\n};\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nNode* f(){\n\tNode* node = new Node();\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\tnode->v = n;\n\n\t\tif(s[c] != '(') {\n\t\t\tNode* res = f();\n\t\t\tnode->children.push_back(res);\n\t\t\tnode->len = min(MAX, node->len + res->len * res->v);\n\t\t\treturn node;\n\t\t}\n\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tNode* res = f();\n\t\t\tnode->children.push_back(res);\n\t\t\tnode->len = min(MAX, node->len + res->len * res->v);\n\n\t\t\tif(c < N && s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\t//assert('A' <= s[c] && s[c] <= 'Z');\n\n\tif(!('A' <= s[c] && s[c] <= 'Z')) {\n\t\tint x = 0;\n\t}\n\n\tnode->s = readS();\n\tnode->len = min(MAX, (ll)node->s.size());\n\n\t//if(ans == 0) {\n\t//\tif(ss.size() * v <= id) {\n\t//\t\tid -= ss.size() * v;\n\t//\t\treturn;\n\t//\t}\n\n\t//\twhile(id >= ss.size()) id -= ss.size();\n\t//\tans = ss[id];\n\t//}\n\treturn node;\n}\n\nvoid g(Node* node){\n\tif(node->children.size() == 0) {\n\t\tassert(id < node->s.size());\n\t\tans = node->s[id];\n\t\treturn;\n\t}\n\n\twhile(!(id < node->len)) id -= node->len;\n\n\tfor(auto child : node->children) {\n\t\tif(child->len * child->v <= id) {\n\t\t\tid -= child->len * child->v;\n\t\t}\n\t\telse{\n\t\t\tg(child);\n\t\t\tassert(ans);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0){\n\t\t\tNode* res = f();\n\t\t\tif(res->len * res->v <= id) {\n\t\t\t\tid -= res->len * res->v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg(res);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1145&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint getnum(int&pos, const string& str) {\n\tint ret = 0;\n\twhile (true) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\tret = ret * 10 + (str[pos] - 0);\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstring gennom(int&pos, int& len, const string& str, const int& n) {\n\tint roop = getnum(pos, str);\n\tif (str[pos] == '(') pos++;\n\telse {\n\t\tstring ret;\n\t\tchar c = str[pos++];\n\t\tfor (int i = 0; i < roop;i++) {\n\t\t\tret += c;\n\t\t\tif (ret.length() >= n)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tstring s;\n\tstring ret;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\ts += gennom(pos,len, str, n);\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\ts += str[pos++];\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] == ')') {\n\t\t\tpos++; break;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < roop; i++) {\n\t\tret += s; len += ret.length();\n\t\tif (ret.length() >= n)break;\n\t}\n\treturn ret;\n}\n\nstring solve(const string& str,int& n) {\n\tstring ret;\n\tint pos = 0;\n\tint len = 0;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\tret += str[pos++]; len++;\n\t\t}\n\t\telse {\n\t\t\tret += gennom(pos, len, str, n);\n\t\t}\n\t\tif (len >= n)return ret;\n\t}\n\treturn ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring str; int n;\n\twhile (cin >> str >> n) {\n\t\tif (str == \"0\" && n == 0) break;\n\t\tstring ans = solve(str, n);\n\t\tif (ans.length() > n) {\n\t\t\tcout << ans[n] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <vector>\n#include <ctype.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const long long BASE = 1000000;\nstatic const int  BW = 6;\nstatic const int MAXDIGIT = 20;\n\nstruct Long {\n  long long digit[MAXDIGIT];\n  int size;\n  explicit Long(int size = 1, long long a = 0) : size(size) {\n    memset(digit, 0, sizeof(digit));\n    digit[0] = a;\n  }\n};\nconst Long ZERO(1, 0), ONE(1, 1);\n\n// Comparators\nbool operator<(const Long &x, const Long &y) {\n  if (x.size != y.size) { return x.size < y.size; }\n  for (int i = x.size - 1; i >= 0; --i) {\n    if (x.digit[i] != y.digit[i]) { return x.digit[i] < y.digit[i]; }\n  }\n  return false;\n}\nbool operator> (const Long &x, const Long &y) { return y < x; }\nbool operator<=(const Long &x, const Long &y) { return !(y < x); }\nbool operator>=(const Long &x, const Long &y) { return !(x < y); }\nbool operator!=(const Long &x, const Long &y) { return x < y || y < x; }\nbool operator==(const Long &x, const Long &y) { return !(x < y) && !(y < x); }\n\n// Input/Output\nostream &operator<<(ostream &os, const Long &x) {\n  os << x.digit[x.size - 1]; \n  for (int i = x.size - 2; i >= 0; i--) {\n    os << setw(BW) << setfill('0') << x.digit[i];\n  }\n  return os; \n}\nvoid print(const Long &x) {\n  printf(\"%lld\", x.digit[x.size - 1]);\n  for (int i = x.size - 2; i >= 0; --i) {\n    printf(\"%04lld\", x.digit[i]);\n  }\n}\n\n// Utilities\nLong normal(Long x) {\n  long long c = 0;\n  for (int i = 0; i < x.size; i++) {\n    while (x.digit[i] < 0) { x.digit[i + 1] -= 1; x.digit[i] += BASE; }\n    long long a = x.digit[i] + c;\n    x.digit[i] = a % BASE;\n    c = a / BASE;\n  }\n  for (; c > 0; c /= BASE) { x.digit[x.size++] = c % BASE; }\n  while (x.size > 1 && x.digit[x.size - 1] == 0) { --x.size; }\n  return x;\n}\n\nLong convert(long long a) {\n  return normal(Long(1, a));\n}\n\nLong convert(const string &s) {\n  Long x;\n  int i = s.size() % BW;\n  if (i > 0) i -= BW;\n  for (; i < (int)s.size(); i += BW) {\n    long long a = 0;\n    for (int j = 0; j < BW; j++) {\n      a = 10 * a + (i + j >= 0 ? s[i + j] - '0' : 0);\n    }\n    x.digit[x.size++] = a;\n  }\n  reverse(x.digit, x.digit + x.size);\n  return normal(x);\n}\n\n// Basic Operations\nLong operator+(Long x, const Long &y) {\n  if (x.size < y.size) { x.size = y.size; }\n  for (int i = 0; i < y.size; i++) { x.digit[i] += y.digit[i]; }\n  return normal(x);\n}\n\nLong operator-(Long x, const Long &y) {\n  assert(x >= y);\n  for (int i = 0; i < y.size; i++) { x.digit[i] -= y.digit[i]; }\n  return normal(x);\n}\n\nLong operator*(const Long &x, const Long &y) {\n  Long z(x.size + y.size);\n  for (int i = 0; i < x.size; i++) {\n    for (int j = 0; j < y.size; j++) {\n      z.digit[i+j] += x.digit[i] * y.digit[j];\n    }\n  }\n  return normal(z);\n}\n\nLong operator*(Long x, long long a) {\n  for (int i = 0; i < x.size; i++) { x.digit[i] *= a; }\n  return normal(x);\n}\n\npair<Long, long long> divmod(Long x, const long long &a) {\n  long long c = 0, t;\n  for (int i = x.size - 1; i>= 0; --i) {\n    t = BASE * c + x.digit[i];\n    x.digit[i] = t / a;\n    c = t % a;\n  }\n  return make_pair(normal(x), c);\n}\n\nLong operator/(const Long &x, const long long &a) {\n  return divmod(x, a).first;\n}\nlong long operator%(const Long &x, const long long &a) {\n  return divmod(x, a).second;\n}\n\npair<Long, Long> divmod(Long x, Long y) {\n  if (x.size < y.size) { return pair<Long, Long>(ZERO, x); }\n  int F = BASE / (y.digit[y.size - 1] + 1);  // multiplying good-factor\n  x = x * F; y = y * F;\n  Long z(x.size - y.size + 1);\n  for (int k = z.size - 1, i = x.size - 1; k >= 0; k--, i--) {\n    z.digit[k] = (i + 1 < x.size ? x.digit[i + 1] : 0) * BASE + x.digit[i];\n    z.digit[k] /= y.digit[y.size - 1];\n    Long t(k + y.size);\n    for (int m = 0; m < y.size; m++) {\n      t.digit[k + m] = z.digit[k] * y.digit[m];\n    }\n    t = normal(t);\n    while (x < t) {\n      z.digit[k] -= 1;\n      for (int m = 0; m < y.size; m++) {\n        t.digit[k + m] -= y.digit[m];\n      }\n      t = normal(t);\n    }\n    x = x - t;\n  }\n  return make_pair(normal(z), x / F);\n}\nLong operator/(Long x, Long y) {\n  return divmod(x, y).first;\n}\nLong operator%(Long x, Long y) {\n  return divmod(x, y).second;\n}\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Node {\n  Long length;\n  Long size;\n  ll loop;\n  char c;\n  vector<Node> child;\n  Node() : loop(1), c(0) {;}\n};\n\nchar str[1000];\n\nNode parse(ll &index) {\n  ll loop = 1;\n  Node ret;\n  if (isalpha(str[index])) {\n    ret.length = convert(1);\n    ret.c = str[index];\n    index++;\n  } else if (isdigit(str[index])) {\n    loop = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n    if (isalpha(str[index])) {\n      ret.child.push_back(parse(index));\n      ret.length = ret.length + ret.child[ret.child.size() - 1].size;\n    } else {\n      assert(str[index] == '(');\n      index++;\n      while (str[index] != ')') {\n        ret.child.push_back(parse(index));\n        ret.length = ret.length + ret.child[ret.child.size() - 1].size;\n      }\n      assert(str[index] == ')');\n      index++;\n    }\n  }\n  ret.size = ret.length * loop;\n  ret.loop = loop;\n  return ret;\n}\n\nchar nodechar(const Node &node, Long &n) {\n  if (node.size <= n) { return '0'; }\n  n = n % node.length;\n  if (n == convert(0) && node.c != 0) { return node.c; }\n  REP(i, node.child.size()) {\n    const Node &target = node.child[i];\n    if (target.size > n) {\n      return nodechar(target, n);\n    }\n    n = n - target.size;\n  }\n  assert(false);\n  return 0;\n}\n\nint main() {\n  ll n;\n  while (scanf(\"%s %lld\", str, &n), str[0] != '0' || n) {\n    ll index = 0;\n    Node root;\n    while (str[index] != '\\0') {\n      root.child.push_back(parse(index));\n      root.size = root.size + root.child[root.child.size() - 1].size;\n      root.length = root.length + root.child[root.child.size() - 1].size;\n    }\n    Long longn = convert(n);\n    printf(\"%c\\n\", nodechar(root, longn));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x334334334LL\n\ntypedef long long int LLI;\ntypedef pair<int, LLI> Pair;\n\nint n;\nint I;\nint num_node;\nint ls[11451419];\nchar buf[11451419];\nbool is_leaf[11451419];\nLLI size[11451419];\nvector<Pair> es[11451419];\n\nint dfs1(int k, int idx) {\n  char *res;\n  es[idx].clear();\n  size[idx] = 0;\n  while (k < n && buf[k] != ')') {\n    int g = num_node++;\n    LLI t = strtol(buf+k, &res, 10);\n    if (buf+k == res) {\n      t = 1;\n      size[g] = 0;\n      ls[g] = k;\n      is_leaf[g] = true;\n      while (k < n && 'A' <= buf[k] && buf[k] <= 'Z') {\n        size[g]++;\n        k++;\n      }\n    } else {\n      is_leaf[g] = false;\n      if (*res == '(') {\n        k = dfs1(res-buf+1, g);\n      } else {\n        k = dfs1(res-buf, g);\n      }\n    }\n    es[idx].push_back(Pair(g, t));\n    size[idx] = min(INF, size[idx] + size[g]*t);\n  }\n  return k+1;\n}\n\nvoid dfs2(int v, int I) {\n  if (is_leaf[v] && I < size[v]) {\n    printf(\"%c\\n\", buf[ls[v]+I]);\n    return;\n  }\n\n  bool found = false;\n  for (int i=0; i<es[v].size(); i++) {\n    Pair p = es[v][i];\n    int u = p.first;\n    LLI t = p.second;\n\n    if (I < size[u]*t) {\n      found = true;\n      dfs2(u, I%size[u]);\n      break;\n    } else I -= size[u]*t;\n  }\n\n  if (!found) puts(\"0\");\n}\n\nint main() {\n  while (1) {\n    scanf(\"%s%d\", buf, &I);\n    if (buf[0] == '0' && I == 0) return 0;\n\n    n = strlen(buf);\n    num_node = 1;\n    assert(dfs1(0, 0) >= n);\n    dfs2(0, I);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        curr->children.push_back(c);\n        c->num = ck;\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      auto c = make_shared<tree>();\n      c->s = read_s(s);\n      c->num = 1;\n      curr->children.push_back(c);\n      if(!s.empty() && !isdigit(s[0])) { return; }\n    }\n  }\n}\n\nstring ans;\n\nvoid visit(tree_ptr curr) {\n  if(ans.size() >= 1000000) { return; }\n  rep(i, curr->num) {\n    if (curr->children.empty()) {\n      ans += curr->s;\n      if(ans.size() >= 1000000) { return; }\n    }\n\n    rep(i, curr->children.size()) {\n      visit(curr->children[i]);\n    }\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  ans.clear();\n  visit(root);\n  if(ans.size() <= idx) { return '0'; }\n  cout << ans << endl;cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_LEN = 2100010;\n\nchar c[MAX_LEN];\nchar ans;\nbool end_flg = false;\nbool bad_flg = false;\nint I;\nchar N[MAX_LEN];\n\npair<string, char *> getStr(char *p){\n  stringstream ss;\n  while(isalpha(*p)){\n    ss << (*p);\n    ++p;\n  }\n  return pair<string, char *>(ss.str(), p);\n}\n\npair<int, char *> getInt(char *p){\n  int ret = 0;\n  while(isdigit((*p))){\n      ret *= 10;\n      ret += ((*p) - '0');\n      ++p;\n  }\n  return pair<int, char *>(ret, p);\n}\n\npair<string, char *> check(char *p){\n  if(end_flg || bad_flg) return pair<string, char *>(\"\", p);\n  pair<int, char *> tmpi = getInt(p);\n  int num = tmpi.first;\n  p = tmpi.second;\n  string str = \"\";\n  while(isdigit(*(p + 1))){\n    pair<string, char *> tmpc = check(p + 1);\n    str += tmpc.first;\n    p = tmpc.second;\n    if(end_flg || bad_flg) return pair<string, char *>(\"\", p);\n  }\n  pair<string, char *> tmps = getStr(p + 1);\n  string now_str = tmps.first;\n  str += now_str;\n  p = tmps.second;\n  string ret = \"\";\n  if(str.length() * num - 1 >= I){\n    ans = str[I % str.length()];\n    end_flg = true;\n  } else if(str.length() * num >= MAX_LEN - 1){\n    bad_flg = true;\n    return pair<string, char *>(\"\", p);\n  } else{\n    stringstream ss;\n    REP(i, num) ss << str;\n    ret = ss.str();\n  }\n  return pair<string, char *>(ret, p);\n}\n\nint main() {\n  string tmp_s;\n  while(cin >>tmp_s >>I && tmp_s != \"0\"){\n    stringstream ss;\n    ss <<\"1(\";\n    REP(i, tmp_s.length()){\n      if(i + 1 < tmp_s.length() && isdigit(tmp_s[i]) && isalpha(tmp_s[i + 1]))\n        ss <<tmp_s[i] <<\"(\";\n      else if(i + 1 < tmp_s.length() && isalpha(tmp_s[i]) && isdigit(tmp_s[i + 1]))\n        ss <<\")\" <<tmp_s[i];\n      else\n        ss <<tmp_s[i];\n    }\n    ss <<\")\";\n    char *tmp_c = new char[ss.str().length() + 1];\n    strcpy(tmp_c, ss.str().c_str());\n    strcpy(N, tmp_c);\n    bad_flg = false;\n    end_flg = false;\n    pair<string, char *> s = check(N);\n    if(!bad_flg && end_flg) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_LEN = 1100010;\n\nchar ans;\nbool end_flg = false;\nint I;\nchar N[MAX_LEN];\n\npair<string, char *> getStr(char *p){\n  stringstream ss;\n  while(isalpha(*p)){\n    ss << (*p);\n    ++p;\n  }\n  return pair<string, char *>(ss.str(), p);\n}\n\npair<int, char *> getInt(char *p){\n  int ret = 0;\n  while(isdigit((*p))){\n      ret *= 10;\n      ret += ((*p) - '0');\n      ++p;\n  }\n  return pair<int, char *>(ret, p);\n}\n\npair<string, char *> check(char *p){\n  if(end_flg) return pair<string, char *>(\"\", p);\n  pair<int, char *> tmpi = getInt(p);\n  int num = tmpi.first;\n  p = tmpi.second;\n  string str = \"\";\n  while(isdigit(*(p + 1))){\n    pair<string, char *> tmpc = check(p + 1);\n    str += tmpc.first;\n    p = tmpc.second;\n    if(end_flg) return pair<string, char *>(\"\", p);\n  }\n  pair<string, char *> tmps = getStr(p + 1);\n  string now_str = tmps.first;\n  str += now_str;\n  p = tmps.second;\n  string ret = \"\";\n  if(str.length() * num - 1 >= I){\n    ans = str[I % str.length()];\n    end_flg = true;\n  } else{\n    stringstream ss;\n    REP(i, num) ss << str;\n    ret = ss.str();\n  }\n  return pair<string, char *>(ret, p);\n}\n\nint main() {\n  string tmp_s;\n  while(cin >>tmp_s >>I && tmp_s != \"0\"){\n    stringstream ss;\n    ss <<\"1(\";\n    REP(i, tmp_s.length()){\n      if(i + 1 < tmp_s.length() && isdigit(tmp_s[i]) && isalpha(tmp_s[i + 1]))\n        ss <<tmp_s[i] <<\"(\";\n      else if(i + 1 < tmp_s.length() && isalpha(tmp_s[i]) && isdigit(tmp_s[i + 1]))\n        ss <<\")\" <<tmp_s[i];\n      else\n        ss <<tmp_s[i];\n    }\n    ss <<\")\";\n    char *tmp_c = new char[ss.str().length() + 1];\n    strcpy(tmp_c, ss.str().c_str());\n    strcpy(N, tmp_c);\n    end_flg = false;\n    pair<string, char *> s = check(N);\n    if(end_flg) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nchar solve(string str, int &index, size_t &pos){\n\t//cout << \"solve : \" << str << endl;\n\tint cnt = 1, len = str.length();\n\tif( str[0] == '(' ){\n\t\tstr = str.substr(1);\n\t\tcnt = -1;\n\t}\n\twhile( !str.empty() && cnt-- ){\n\t\tif( str[0] >= '0' && str[0] <= '9' ){\n\t\t\tsize_t i, p;\n\t\t\tint num = stoi( str, &i );\n\t\t\tstring s = str.substr(i);\n\t\t\trep(k, num){\n\t\t\t\tchar res = solve( s, index, p );\n\t\t\t\tif( res != '0' ) return res;\n\t\t\t}\n\t\t\tstr = s.substr(p);\n\t\t}else if( str[0] == ')' ){\n\t\t\tbreak;\n\t\t}else{\n\t\t\tint i=0;\n\t\t\twhile(str[i] < '0' || str[i] > '9'){\n\t\t\t\tif( str[i] == ')' ) break;\n\t\t\t\tif( index-- == 0 ) return str[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr = str.substr(i);\n\t\t}\n\t}\n\tpos = len - str.length();\n\treturn '0';\n}\n\nint main(){\n\tstring s;\n\tint i;\n\twhile(cin>>s>>i, s != \"0\" ){\n\t\tstring ss = \"1(\" + s + \")\";\n\t\tsize_t p;\n\t\tcout << solve(ss, i, p) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstring st;\nint now = 0;\n\nstring getst() {\n\tstring genom;\n\twhile (isalpha(st[now])) {\n\t\tgenom += st[now];\n\t\tnow++;\n\t}\n\treturn genom;\n}\nint getcount() {\n\tlong long int num = 0;\n\twhile (isdigit(st[now])) {\n\t\tnum = num * 10 + st[now] - '0';\n\t\tnow++;\n\t}\n\treturn num;\n}\n\npair<int,char> check(long long int rest,long long int kakeru) {\n\tif (kakeru > 1e8) {\n\t\tkakeru = 1e8;\n\t}\n\tlong long int num = 1;\n\tbool isstart = true;\n\twhile (1) {\n\t\tif (st.size() <= now)break;\n\t\tif (st[now] == '(') {\n\t\t\tnow++;\n\t\t\tpair<int,char>p=check(rest,kakeru*num);\n\t\t\tif (p.second == '0') {\n\t\t\t\trest = p.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn make_pair(0,p.second);\n\t\t\t}\n\t\t}\n\t\telse if (st[now] == ')') {\n\t\t\tnow++;\n\t\t\tbreak;\n\t\t}\n\t\telse if(isalpha(st[now])){\n\t\t\tstring genom= getst();\n\t\t\tif (genom.size()*kakeru*num > rest) {\n\t\t\t\treturn make_pair(0, genom[rest%genom.size()]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trest -= genom.size()*kakeru;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassert(isdigit(st[now]));\n\t\t\tnum = getcount();\n\t\t}\n\n\t\tisstart = false;\n\t}\n\treturn make_pair(rest, '0');\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"0\")break;\n\t\tnow = 0;\n\t\tint n; cin >> n;\n\t\tpair<int, char>p;\n\t\tchar ans=check(n,1).second;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Result {\n    long long length;\n    int index;\n};\n\nResult expand2(const string& s, int i, int target);\n\nResult expand1(const string& s, int i, int target) {\n    if (isalpha(s[i])) {\n        int start = i, length = 0;\n        for (; isalpha(s[i]); ++i) ++length;\n        if (target < length)\n            throw s[start + target];\n        return (Result){length, i};\n    }\n    if (isdigit(s[i])) {\n        int n_repeat = 0;\n        for (; isdigit(s[i]); ++i)\n            n_repeat = 10*n_repeat + (s[i]-'0');\n        if (s[i] == '(') {\n            Result r = expand2(s, i+1, target);\n            assert(s[r.index] == ')');\n            if (n_repeat * r.length > target) {\n                expand2(s, i+1, target % r.length);\n                assert(false);\n            }\n            return (Result){n_repeat * r.length, r.index + 1};\n        }\n        if (isalpha(s[i])) {\n            if (target < n_repeat)\n                throw s[i];\n            return (Result){n_repeat, i + 1};\n        }\n        assert(false);\n    }\n    assert(false);\n}\n\nResult expand2(const string& s, int i, int target) {\n    long long length = 0;\n    for (;;) {\n        Result r = expand1(s, i, target);\n        length += r.length;\n        target -= r.length;\n        i = r.index;\n        if (s[i] == '\\0' || s[i] == ')')\n            return (Result){length, i};\n    }\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    string s; int i;\n    while (cin>>s>>i, s!=\"0\"||i!=0) {\n        s += '\\0';\n        try {\n            expand2(s, 0, i);\n            cout << \"0\\n\";\n        } catch (char ch) {\n            cout << ch << '\\n';\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nstring parse(string V, int w) {\n\twhile (V.size() >= 2 && V[0] == '(' && V[V.size() - 1] == ')')V = V.substr(1, V.size() - 2);\n\tif (V.size() == 1)return V;\n\tint depth = 0;\n\tstring E = \"\", F = \"\"; vector<pair<int, string>>v;\n\tfor (int i = 0; i < V.size(); i++) {\n\t\tif (V[i] == '(')depth++;\n\t\tif (V[i] == ')')depth--; F += V[i];\n\t\tif (depth == 0 && ((V[i] >= 'A' && V[i] <= 'Z') || V[i] == ')')) {\n\t\t\tstring Y = \"\"; int c = 0; while (F[c] >= '0' && F[c] <= '9') { Y += F[c]; c++; }\n\t\t\tint D = 1; if (Y.size() >= 1)D = stoi(Y);\n\t\t\tv.push_back(make_pair(D, F.substr(c, F.size() - c))); F = \"\";\n\t\t}\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (E.size() >= w)break;\n\t\tfor (int j = 0; j < v[i].first; j++) {\n\t\t\tif (E.size() >= w)break;\n\t\t\tE += parse(v[i].second, w);\n\t\t}\n\t}\n\treturn E.substr(0, min((int)E.size(), w));\n}\nint main() {\n\twhile (true) {\n\t\tstring S; int T; cin >> S >> T; if (S == \"0\" && T == 0)break;\n\t\tstring U = parse(S, T + 1);\n\t\tif (U.size() <= T) { cout << \"0\" << endl; }\n\t\telse cout << U[T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() {}\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1000000) { num = 1000000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nstring s;\nint n, len;\n\nint next(int t){\n    int dep = 0;\n    for (int i = t; i < len; ++i) {\n        if (s[i] == '(') ++dep;\n        if (s[i] == ')') --dep;\n        \n        if ((s[i] < '0' || s[i] > '9') && dep == 0) return i + 1;\n    }\n    return len;\n}\n\n// [l,r)\nint count(int l, int r){\n    if (l >= r) return 0;\n    if (s[l] == '(' && next(l) == r) return count(l + 1, r - 1);\n    \n    if (s[l] >= 'A' && s[l] <= 'Z') return count(l + 1, r) + 1;\n    int num = 0, k = l;\n    while (s[k] >= '0' && s[k] <= '9') {\n        num = num * 10 + s[k] - '0';\n        ++k;\n    }\n    if (num == 0) num = 1;\n    \n    int ne = next(k);\n    long long ret = num * (long long)count(k, ne) + count(ne, r);\n    \n    if (ret > n) ret = n + 1;\n    \n    return (int)ret;\n}\n\nint count(int l){\n    return count(l, next(l));\n}\n\nchar search(int m, int now) {\n    if (s[now] == '(' || s[now] == ')') return search(m, now + 1);\n    if (m == 0){\n        for (int i = now; i < len; ++i) {\n            if (s[i] >= 'A' && s[i] <= 'Z')\n                return s[i];\n        }\n        return 'w';\n    }\n    int ne = next(now);\n    int c = count(now, ne);\n    if (c <= m){\n        return search(m - c, ne);\n    }\n    int k = now;\n    while (s[k] >= '0' && s[k] <= '9') {\n        ++k;\n    }\n    int co = count(k, next(k));\n    return search(m % co, k);\n}\n\nint main(){\n    while (true) {\n        cin >> s >> n;\n        len = s.length();\n        if (s == \"0\") break;\n        \n        if (count(0, len) <= n) {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        \n        cout << search(n, 0) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nll a,t;\nchar out;\nint cnt=0;\nstring f(int a){\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(out!='0')return \"\";\n\t\tif(isalpha(s[t])){\n\t\t\tw+=s[t];\n\t\t\tt++;cnt++;\n\t\t\tif(a<w.size()){\n\t\t\t\tif(out=='0')out=w[a];return \"\";\n\t\t\t}\n\t\t}else if(s[t]==')'){\n\t\t\treturn w;\n\t\t}else{\n\t\t\tint co=0;\n\t\t\twhile(isdigit(s[t])){\n\t\t\t\tco*=10;\n\t\t\t\tco+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tstring tmp;\n\t\t\tif(isalpha(s[t])){\n\t\t\t\ttmp=s[t];\n\t\t\t}else{\n\t\t\t\tt++;\n\t\t\t\ttmp=f(a-w.size());\n\t\t\t}\n//\t\t\tcout<<co<<\" \"<<tmp.size()<<endl;\n//\t\t\tcout<<w<<endl;\n\t\t\tif(a<w.size()+tmp.size()*co){\n\t\t\t\tif(a<w.size()){if(out=='0')out=w[a];}\n\t\t\t\telse if(out=='0')out=tmp[(a-w.size())%tmp.size()];\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\trep(i,co)w+=tmp;\n\t\t\tcnt+=tmp.size()*(co-1);\n\t\t\tt++;\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\twhile(cin>>s>>a,s!=\"0\"){\n\t\tout='0';\n\t\tt=cnt=0;\n\t\tf(a);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring evolve(string,int);\n\nint main(void){\n\tbool\tcmp;\n\tstring\tbfr;\n\n\tfor(int n;cin >> bfr >> n,bfr[0]-0x30||n;){\n\t\tdo{\n\t\t\tstring\taft;\n\t\t\tcmp=true;\n\n\t\t\tfor(int i=0;i<bfr.size()&&i<=1000000;i++){\n\t\t\t\tint\tval=0;\n\t\t\t\tstring\ttmp;\n\t\t\t\tfor(;bfr[i]>='0'&&bfr[i]<='9';i++)\n\t\t\t\t\tval=val*10+bfr[i]-0x30;\n\n\t\t\t\tif(val>0){\n\t\t\t\t\tif(bfr[i++]=='(')\n\t\t\t\t\t\tfor(int d=0;d!=0||bfr[i]!=')';i++){\n\t\t\t\t\t\t\tif(bfr[i]=='(')\n\t\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t\telse if(bfr[i]==')')\n\t\t\t\t\t\t\t\td--;\n\t\t\t\t\t\t\ttmp+=bfr[i];\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ttmp=bfr[--i];\n\t\t\t\t\taft+=evolve(tmp,val);\n\t\t\t\t\tcmp=false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\taft+=bfr[i];\n\t\t\t}\n\t\t\tbfr=aft;\n\t\t}while(!cmp);\n\n\t\tif(n<bfr.size())\n\t\t\tcout << bfr[n] << endl;\n\t\telse\n\t\t\tcout << 0 << endl;\n\t}\n\n\treturn 0;\n}\n\nstring evolve(string tmp,int c){\n\tstring out;\n\tfor(int i=0;i<c;i++)\n\t\tout+=tmp;\n\n\treturn out;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\n\nconst int MAX_LEN = 1000005;\n\nstring s;\n\nvoid dfs(int& cur, string& t)\n{\n    if(cur >= len(s)-1){\n        return;\n    }\n    while(cur < len(s)-1){\n        if(isdigit(s[cur])){\n            int st = cur;\n            while(isdigit(s[cur])){\n                cur++;\n            }\n            int num = stoi(s.substr(st,cur-st));\n            if(isalpha(s[cur])){\n                rep(i,num){\n                    t.pb(s[cur]);\n                }\n                cur++;\n            }else{\n                if(cur >= len(s)-1){\n                    return;\n                }\n                cur++;\n                string u;\n                dfs(cur,u);\n                rep(i,num){\n                    t += u;\n                    if(len(t) >= MAX_LEN){\n                        return;\n                    }\n                }\n            }\n        }else{\n            while(isalpha(s[cur])){\n                t.pb(s[cur]);\n                cur++;\n            }\n            if(s[cur] == ')'){\n                cur++;\n                return;\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> s >> n;\n        if(s == \"0\" && n == 0){\n            break;\n        }\n        s.pb('%');\n        string t;\n        int num = 0;\n        dfs(num,t);\n        if(len(t) <= n){\n            cout << \"0\\n\";\n        }else{\n            cout << t[n] << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n\n#define int long long\n\nusing namespace std;\n\nclass Solver {\n};\n\ntuple<string,char> dfs(string s, int remain) {\n\tstring now = \"\";\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif ('0' <= s[i] && s[i] <= '9') {\n\t\t\tint loop = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '9') {\n\t\t\t\tloop *= 10;\n\t\t\t\tloop += (s[i] - '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tstring tmp = \"\";\n\t\t\tint nest = 1;\n\t\t\tfor (; i < s.size(); i++) {\n\t\t\t\tif (s[i] == '(')nest++;\n\t\t\t\tif (s[i] == ')') {\n\t\t\t\t\tnest--;\n\t\t\t\t\tif (nest == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += s[i];\n\t\t\t}\n\n\t\t\ttuple<string, char> tpl = dfs(tmp, remain);\n\t\t\tif (get<1>(tpl) != '0')return make_tuple(now, get<1>(tpl));\n\t\t\ttmp = get<0>(tpl);\n\t\t\tfor (int j = 0; j < loop; j++) {\n\t\t\t\tremain -= tmp.size();\n\t\t\t\tnow += tmp;\n\t\t\t\tif (remain < 0)return make_tuple(now, now[now.size() + remain]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnow += s[i];\n\t\t\tremain--;\n\t\t\tif (remain < 0)return make_tuple(now, now[now.size() + remain]);\n\t\t}\n\t}\n\treturn make_tuple(now, '0');\n}\n\nsigned main() {\n\twhile (true) {\n\t\tstring s;\n\t\tint n;\n\t\tcin >> s >> n;\n\t\tif (s[0] == '0')break;\n\n\t\tstring formated = \"\";\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (i > 0 && 'A' <= s[i] && s[i] <= 'Z'\n\t\t\t\t&& '0' <= s[i - 1] && s[i - 1] <= '9') {\n\t\t\t\tformated += '(';\n\t\t\t\tformated += s[i];\n\t\t\t\tformated += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tformated += s[i];\n\t\t\t}\n\t\t}\n\t\tcout << get<1>(dfs(formated, n)) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint id, N;\nstring s;\n\nint c;\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nvoid f(int v){\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t\tf(v * n);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(v * n);\n\t\t\t}\n\t\t\tif(s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tassert('A' <= s[c] && s[c] <= 'Z');\n\tstring ss = readS();\n\tif(ans == 0) {\n\t\tif(ss.size() * v <= id) {\n\t\t\tid -= ss.size() * v;\n\t\t\treturn;\n\t\t}\n\n\t\twhile(id >= ss.size()) id -= ss.size();\n\t\tans = ss[id];\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0) f(1);\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 1000001\n\nchar base[101];\nchar *ans_buf,*work;\nint ans_index,result_index,base_length;\nint work_index,work_length;\n\nvoid recursive(int left,int right){\n\n\tif(left > right)return;\n\n\tint keisu = 0,index;\n\n\tfor(index = left; index <= right && base[index] >= 'A' && base[index] <= 'Z' && work_index < NUM;index++){\n\t\twork[work_index++] = base[index];\n\t\twork[work_index] = '\\0';\n\t}\n\n\tfor(;index <= right && base[index] >= '0' && base[index] <= '9';index++){\n\t\tkeisu = 10*keisu + (base[index]-'0');\n\t}\n\n\tif(keisu == 0){\n\t\tfor(work_length = 0; work[work_length] != '\\0';work_length++);\n\t\treturn;\n\t}\n\n\t//keisu != 0\n\n\tif(base[index] == '('){\n\n\t\tint depth = 1,next_right = -1,max_depth = 1;\n\t\tbool numFLG = false;\n\n\t\tfor(int i = index+1; i <= right; i++){\n\t\t\tif(base[i] == '('){\n\t\t\t\tdepth++;\n\t\t\t\tmax_depth = max(max_depth,depth);\n\t\t\t}else if(base[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(next_right == -1 && depth == 0){\n\t\t\t\t\tnext_right = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(base[i] >= '0' && base[i] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(max_depth == 1){\n\n\t\t\tif(!numFLG){\n\t\t\t\tfor(int i = 0; i < keisu && work_index < NUM; i++){\n\t\t\t\t\tfor(int k = index+1;k <= next_right-1 && work_index < NUM;k++){\n\t\t\t\t\t\twork[work_index++] = base[k];\n\t\t\t\t\t\twork[work_index] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trecursive(next_right+1,right);\n\t\t\t}else{\n\n\t\t\t\tint pre_index = work_index;\n\n\t\t\t\trecursive(index+1,next_right-1);\n\t\t\t\tfor(work_length = 0; work[pre_index+work_length] != '\\0';work_length++);\n\n\t\t\t\tfor(int i = 0; i < keisu-1 && work_index < NUM; i++){\n\t\t\t\t\tfor(int k = 0; k < work_length && work_index < NUM;k++){\n\t\t\t\t\t\twork[work_index++] = work[pre_index+k];\n\t\t\t\t\t\twork[work_index] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trecursive(next_right+1,right);\n\t\t\t}\n\n\t\t}else{\n\t\t\tdepth = 1,next_right = -1;\n\t\t\tfor(int i = index+1; i <= right; i++){\n\t\t\t\tif(base[i] == '('){\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(base[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(next_right == -1 && depth == 0){\n\t\t\t\t\t\tnext_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint pre_index = work_index;\n\n\t\t\trecursive(index+1,next_right-1);\n\t\t\tfor(work_length = 0; work[pre_index+work_length] != '\\0';work_length++);\n\n\t\t\tfor(int i = 0; i < keisu-1 && work_index < NUM; i++){\n\t\t\t\tfor(int k = 0; k < work_length && work_index < NUM;k++){\n\t\t\t\t\twork[work_index++] = work[pre_index+k];\n\t\t\t\t\twork[work_index] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecursive(next_right+1,right);\n\t\t}\n\n\t}else{\n\t\tfor(int i = 0; i < keisu && work_index < NUM; i++){\n\t\t\twork[work_index++] = base[index];\n\t\t\twork[work_index] = '\\0';\n\t\t}\n\t\tif(index + 1 <= right){\n\t\t\trecursive(index+1,right);\n\t\t}\n\n\t}\n\n\tfor(work_length = 0; work[work_length] != '\\0';work_length++);\n}\n\nvoid func(){\n\n\tfor(int a = 0; a < NUM+9; a++)ans_buf[a] = '0';\n\tresult_index = 0;\n\tfor(base_length = 0; base[base_length] != '\\0';base_length++);\n\n\tint left = 0,right = 0,depth;\n\n\twhile(left < base_length && result_index < NUM){\n\n\t\tdepth = 0;\n\t\tfor(int i = left; ;i++){\n\t\t\tif(base[i] == '('){\n\t\t\t\tdepth++;\n\t\t\t}else if(base[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tright = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(base[i] >= 'A' && base[i] <= 'Z'){\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tright = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//Do nothing\n\t\t\t}\n\t\t}\n\n\t\twork_index = 0;\n\t\twork_length = 0;\n\t\twork[0] = '\\0';\n\t\trecursive(left,right);\n\n\t\tfor(int a = 0; work[a] != '\\0' && result_index < NUM;a++){\n\t\t\tans_buf[result_index++] = work[a];\n\t\t}\n\n\t\tleft = right+1;\n\t}\n\n\tprintf(\"%c\\n\",ans_buf[ans_index]);\n}\n\n\nint main(){\n\n\tans_buf = new char[1000020];\n\twork = new char[1000020];\n\n\twhile(true){\n\t\tscanf(\"%s %d\",base,&ans_index);\n\t\tif(base[0] == '0' && ans_index == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nstring s,ans;\nint n;\n \nP getNum(string str,int x){\n  int r=0;\n  while('0'<=str[x]&&str[x]<='9')\n    r=r*10+str[x]-'0',x++;\n  return P(x,r);\n}\n \nvoid dfs(int b,int e){\n  int p=b;\n  while(p<=e&&ans.size()<=n){\n    if('0'<=s[p]&&s[p]<='9'){\n      P r=getNum(s,p);\n      int x=r.first,num=r.second;\n      int y=r.first,z=r.first;\n      if(s[x]=='('){\n    int c=1;\n    y=x+1;\n    for(z=y;z<=e&&c;z++){\n      if(s[z]=='(')c++;\n      if(s[z]==')')c--;\n    }\n    p=z;\n    z-=2;\n    while(num--)dfs(y,z);\n      }else{\n    while(num--)ans+=s[x];\n    p=x+1;\n      }\n    }\n   if('A'<=s[p]&&s[p]<='Z')\n      ans+=s[p++];\n  }\n}\n \nint main(){\n  while(1){\n    cin>>s>>n;\n    if(s==\"0\"&&!n)break;\n    dfs(0,s.size()-1);\n    if(ans.size()<n+1)\n      cout<<0<<endl;\n    else cout<<ans[n]<<endl;\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\n#include<cstdlib>\n#define inf 1<<29\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\nstring s;\nchar ans;\nvector<string> v;\nmap<int,int> mp;\n\nll rec(int,int,ll);\n\nvoid rec2(int a,int b,ll sum){\n  /*for(int i=a;i<b;i++)cout<<v[i]<<\" \";\n  cout<<sum<<endl;*/\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],0);\n\tif(sum<=tmp*atoi(v[i].c_str()))rec2(i+2,mp[i+1],sum%tmp);\n\telse sum-=tmp*atoi(v[i].c_str());\n\tif(ans!='0')return;\n        i=mp[i+1];\n      }\n      else {\n        ll tmp=atoi(v[i].c_str());\n        if(sum<=tmp){\n\t  ans=v[i+1][0];\n\t  return;\n\t}\n\telse {\n\t  sum-=tmp;\n\t  i++;\n\t}\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      if(sum<v[i].length()){\n\tans=v[i][sum];\n\treturn;\n      }\n      else sum-=v[i].length();\n    }\n    else {}\n  }\n  return;\n}\n\nll rec(int a,int b,ll c){\n  ll sum=0;\n  if(ans!='0')return inf;\n\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return inf;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],sum);\n\tif(ans!='0')return inf;\n\tsum+=atoi(v[i].c_str())*tmp;\n\ti=mp[i+1];\n      }\n      else {\n\tsum+=atoi(v[i].c_str())*v[i+1].length();\n\ti++;\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      sum+=v[i].length();\n    }\n    else {}\n  }\n  if(n<=sum)rec2(a,b,n-c);\n  return sum;\n}\n\nint main()\n{\n  while(1){\n    cin>>s>>n;\n    if(s[0]=='0' && n==0)break;\n    ans='0';\n    v.clear();mp.clear();\n    string tmp1=\"\",tmp2=\"\";\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tif(tmp2!=\"\")v.push_back(tmp2);\n\ttmp2=\"\";\n\ttmp1+=s[i];\n      }\n      if('A'<=s[i] && s[i]<='Z'){\n\tif(tmp1!=\"\")v.push_back(tmp1);\n\ttmp1=\"\";\n\ttmp2+=s[i];\n      }\n      if(s[i]=='('){\n\tv.push_back(tmp1);\n\ttmp1=\"\";\n\tv.push_back(\"(\");\n      }\n      if(s[i]==')'){\n        v.push_back(tmp2);\n        tmp2=\"\";\n        v.push_back(\")\");\n      }\n      if(i==s.length()-1 && tmp2!=\"\")v.push_back(tmp2);\n    }\n    stack<int> st;\n    for(int i=0;i<v.size();i++){\n      if(v[i]==\"(\")st.push(i);\n      if(v[i]==\")\"){\n\tmp[st.top()]=i;\n\tst.pop();\n      }\n    }\n    rec(0,v.size(),0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct State {\n  int pos;\n  string str_result;\n  int int_result;\n  State(int pos,string str_result) \n    : pos(pos), str_result(str_result) {}\n  State(int pos,int int_result) \n    : pos(pos), int_result(int_result) {}\n};\n\n// EXPR ::= NUMBERS ( EXPR ) | NUMBERS ALPHA | ALPHAS\n\nState alphas(const string& str,int pos){\n  string tmp = \"\";\n  while(isalpha(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return State(pos,tmp);\n}\n\nState numbers(const string& str,int pos){\n  int tmp = 0;\n  while(isdigit(str[pos])){\n    tmp += (str[pos] - '0');\n    tmp *= 10;\n    pos++;\n  }\n  tmp /= 10;\n  return State(pos,tmp);\n}\n\nState expr(const string& str,int pos){\n  string result = \"\";\n  while(pos < str.size() && (isdigit(str[pos]) || isalpha(str[pos]))){\n    if(isdigit(str[pos])){\n      State s1 = numbers(str,pos);\n      pos = s1.pos;\n      if(str[s1.pos] == '(') pos++;\n      State s2 = expr(str,pos);\n      \n      string tmp = \"\";\n      for(int i = 0; i < s1.int_result; i++){\n        tmp += s2.str_result;\n        if(tmp.size() > 10000000) break;\n      }\n      result += tmp;\n      pos = s2.pos + 1;\n    }\n    else if(isalpha(str[pos])){\n      State s1 = alphas(str,pos);\n      result += s1.str_result;\n      pos = s1.pos;\n    }\n  }\n  return State(pos,result);\n}\n\n\nint main(){\n  string genome;\n  int pos;\n  while(cin >> genome >> pos){\n    if(genome == \"0\" && pos == 0) break;\n    string result = expr(genome,0).str_result;\n    if(pos < result.size()){\n      cout << result[pos] << endl;      \n    }\n    else{\n      cout << 0 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e13 + 9;\n\n#define int ll\n#define double ld\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\t\n\tstring s; int I;\n\twhile (cin >> s >> I && s != \"0\") {\n\t\tstruct node {\n\t\t\tint sum;\n\t\t\tvector<int> to;\n\t\t\tstring s;\n\t\t};\n\t\ts = s + \")\";\n\t\t{\n\t\t\tmap<int, string, greater<int>> add;\n\t\t\trep(i, s.size()) {\n\t\t\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\t\t\tif (i == 0 || !(s[i - 1] >= '0' && s[i - 1] <= '9')) {\n\t\t\t\t\t\tadd[i] = \"1(\";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tadd[i] = \"(\";\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\teach(i, add) {\n\t\t\t\ts = s.substr(0, i.first) + i.second + s.substr(i.first);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tmap<int, string, greater<int>> add;\n\t\t\trep(i, s.size()) {\n\t\t\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\t\t\tadd[i+1] = \")\";\n\t\t\t\t}\n\t\t\t}\n\t\t\teach(i, add) {\n\t\t\t\ts = s.substr(0, i.first) + i.second + s.substr(i.first);\n\t\t\t}\n\t\t}\n\t\tvector<node> nd;\n\t\tnd.push_back(node());\n\t\tfunction<int(int, int)> make_node = [&](int n, int t) {\n\t\t\tint sn = n;\n\t\t\twhile (s[n] >= 'A' && s[n] <= 'Z') {\n\t\t\t\tnd[t].s.push_back(s[n]); n++;\n\t\t\t}\n\t\t\tnd[t].sum = nd[t].s.size();\n\t\t\tfor (;; n++) {\n\t\t\t\tif (s[n] == '(') {\n\t\t\t\t\tint tp = toint(s.substr(sn, n - sn));\n\t\t\t\t\tnd.push_back(node());\n\t\t\t\t\tint tt = nd.size() - 1;\n\t\t\t\t\tn = make_node(n + 1, tt);\n\t\t\t\t\tnd[tt].sum *= tp;\n\t\t\t\t\tnd[tt].sum = min(INF, nd[tt].sum);\n\t\t\t\t\tnd[t].sum += nd[tt].sum;\n\t\t\t\t\tnd[t].sum = min(INF, nd[t].sum);\n\t\t\t\t\tnd[t].to.push_back(tt);\n\t\t\t\t\tsn = n + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s[n] == ')') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmake_node(0, 0);\n\n\t\tfunction<char(int, int)> search = [&](int t,int c) {\n\t\t\tif (nd[t].s.size()) {\n\t\t\t\tc %= nd[t].s.size();\n\t\t\t\treturn nd[t].s[c];\n\t\t\t}\n\t\t\twhile (1) {\n\t\t\t\teach(to, nd[t].to) {\n\t\t\t\t\tif (nd[to].sum > c) {\n\t\t\t\t\t\treturn search(to, c);\n\t\t\t\t\t}\n\t\t\t\t\tc -= nd[to].sum;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (nd[0].sum <= I) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << search(0, I) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nint num(Cursol&);\nstring calc(Cursol&);\nstring expr(Cursol&);\n\nint pos ;\n\nint num(Cursol& p){\n  int ret = 0;\n  while(isdigit(*p)){\n    ret = ret * 10 + *p - '0';\n    p++;\n  }\n  return ret;\n}\n\nstring calc(Cursol& p){\n  string ret;\n  if(isdigit(*p)){\n    int number = num(p);\n    if( *p == '(') {\n      p++;\n      string res = expr(p);\n      p++;\n      while(number--){\n        ret += res;\n        if(pos < ret.size()) break;\n      }\n    } else {\n      char c = *p;\n      p++;\n      while(number--){\n        ret += c;\n        if(pos < ret.size()) break;\n      }\n    }\n  }else{\n    while(isalpha(*p)){\n      ret += *p;\n      p++;\n      if(pos < ret.size()) break;\n    }\n  }\n  return ret;\n}\n\n\nstring expr(Cursol& p){\n  string ret;\n  while( isalpha(*p) || isdigit(*p)){\n    ret += calc(p);\n    if(pos < ret.size()) break;\n  }\n  return ret;\n}\nint main(){\n  string str;\n  while(cin >> str >> pos, str!=\"0\"||pos){\n    Cursol idx = str.begin();\n    string ret = expr(idx);\n    if(pos < ret.size()) cout << ret[pos] << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n\ntypedef vector<int> vint;\ntypedef long long ll;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pii;\ntypedef vector<pair<pii,string>> vip;\n\nstring s;\nint n;\n\nvector<vip> node;\nvll cnt;\n\nvoid func(int l,int r,int root){\n\t// cout<<l<<\" \"<<r<<\" \"<<root<<\" \"<<s.substr(l,r-l+1)<<endl;\n\treep(i,l,r+1){\n\t\t// if(l==14) cout<<i<<endl;\n\t\tif(isdigit(s[i])){\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\twhile(isdigit(s[pos])) num=num*10+s[pos++]-'0';\n\t\t\tnode.PB(vip(0));\n\t\t\t// cout<<\"num \"<<num<<endl;\n\t\t\tif(s[pos]=='('){\n\t\t\t\tbool ok = true;\n\t\t\t\tint pp = pos+1;\n\t\t\t\tbool f = true;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(s[pp]=='(') ok=false;\n\t\t\t\t\tif(s[pp]==')') break;\n\t\t\t\t\tif(isdigit(s[pp])) f=false;\n\t\t\t\t\tpp++;\n\t\t\t\t}\n\t\t\t\tif(ok&&f){\n\t\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),s.substr(pos+1,pp-pos-1)));\n\t\t\t\t\ti=pp;\n\t\t\t\t}\n\t\t\t\telse if(ok){\n\t\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),\"\"));\n\t\t\t\t\tfunc(pos+1,pp-1,node.size()-1);\n\t\t\t\t\ti=pp;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpp = pos;\n\t\t\t\t\tint aa = 0;\n\t\t\t\t\tint bb = 0;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(s[pp]=='(') aa++;\n\t\t\t\t\t\tif(s[pp]==')') bb++;\n\t\t\t\t\t\tif(aa==bb) break;\n\t\t\t\t\t\tpp++;\n\t\t\t\t\t}\n\t\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),\"\"));\n\t\t\t\t\tfunc(pos+1,pp-1,node.size()-1);\n\t\t\t\t\ti=pp;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),s.substr(pos,1)));\n\t\t\t\ti=pos;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstring a=\"\";\n\t\t\tint pos = i;\n\t\t\twhile(pos<s.size()&&isupper(s[pos])) a+=s[pos++];\n\t\t\tnode.PB(vip(0));\n\t\t\tnode[root].PB(mkp(pii(1,node.size()-1),a));\n\t\t\ti=pos-1;\n\t\t}\n\t}\n}\n\nvoid visual(int x){\n\tfor(auto y:node[x]){\n\t\tcout<<y.F.F<<\" \"<<y.F.S<<\" \"<<y.S<<\" \"<<x<<endl;\n\t\tvisual(y.F.S);\n\t}\n}\n\nll dfs(int x){\n\tll ret = 0;\n\tfor(auto y:node[x]){\n\t\tif(node[y.F.S].size()==0){\n\t\t\tcnt[y.F.S] = y.S.size();\n\t\t\tret+=cnt[y.F.S]*y.F.F;\n\t\t\t// cout<<y.F.S<<\" \"<<y.S<<\" \"<<cnt[y.F.S]<<endl;\n\t\t}\n\t\telse{\n\t\t\tret+=dfs(y.F.S)*y.F.F;\n\t\t\t// cout<<y.F.S<<\" \"<<y.S<<\" \"<<cnt[y.F.S]<<endl;\n\t\t}\n\t}\n\treturn cnt[x]=min((ll)INT_MAX,ret);\n}\n\nvoid calc(int x,int n){\n\tll c = 0;\n\t// cout<<x<<\" \"<<n<<\" \"<<cnt[x]<<endl;\n\tfor(auto y:node[x]){\n\t\tc+=cnt[y.F.S]*y.F.F;\n\t\t// cout<<c<<endl;\n\t\tif(n<c){\n\t\t\tif(y.S.size()){\n\t\t\t\tn=n-(c-cnt[y.F.S]*y.F.F);\n\t\t\t\tassert(n>=0);\n\t\t\t\tcout<<y.S[n%y.S.size()]<<endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tn=n-(c-cnt[y.F.S]*y.F.F);\n\t\t\t\tassert(n>=0);\n\t\t\t\t// cout<<y.F.S<<\" \"<<n%cnt[y.F.S]<<endl;\n\t\t\t\tcalc(y.F.S,n%cnt[y.F.S]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>s>>n){\n\t\tif(s==\"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tnode.assign(1,vip(0));\n\t\tfunc(0,s.size()-1,0);\n\t\tcnt=vll(node.size());\n\t\tdfs(0);\n\t\t// cout<<endl;\n\t\t// visual(0);\n\t\tif(n>=cnt[0]){\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse{\n\t\t\tcalc(0,n);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nstring ans, str;\nint n, p;\n\nstring dfs(){\n    int res = 0;\n    string st = \"\";\n    while (p < str.size()) {\n        if (isdigit(str[p])) {\n            res = 0;\n            while (isdigit(str[p])) {\n                res *= 10;\n                res += str[p] - '0';\n                p++;\n            }\n        }else if (isalpha(str[p])){\n            st = \"\";\n            while (isalpha(str[p])) {\n                st += str[p];\n                p++;\n            }\n        }else if (str[p] == '('){\n            p++;\n            string tmp = dfs();\n            for (int i = 0; i < res; i++) {\n                if (st.size() > n){\n                    return st;\n                }\n                st += tmp;\n            }\n        }else if (str[p] == ')'){\n            p++;\n            return st;\n        }else{\n            break;\n        }\n    }\n    return st;\n}\n\nstring complement(string s){\n    int p = 0;\n    string expanded_string = \"\";\n    while (p < s.size()) {\n        if (!isalpha(s[p]) && isalpha(s[p+1])) {\n            expanded_string += s[p];\n            if (isdigit(s[p])) {\n                expanded_string += \"(\";\n            }else{\n                expanded_string += \"1(\";\n            }\n            p++;\n            while (isalpha(s[p])) {\n                expanded_string += s[p++];\n            }\n            expanded_string += ')';\n        }else{\n            expanded_string += s[p++];\n        }\n    }\n    return expanded_string;\n}\n\nint main()\n{\n    while (true) {\n        p = 0;\n        cin >> str >> n;\n        if (str == \"0\") {\n            break;\n        }\n        str = complement(str);\n        ans = dfs();\n        if (ans.size() <= n) {\n            cout << \"0\" << endl;\n        }else{\n            cout << ans[n] << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> T;\ntypedef vector<ll> vec;\n\ninline bool check(ll x, ll y, ll xMax, ll yMax) { return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string tostring(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\ntemplate<class T> inline T mypow(T x, ll n) { T res = 1; while (n > 0) { if (n & 1)res = res * x;\tx = x * x;\tn >>= 1; }return res; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define For(i,a,b)\tfor(ll (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define rFor(i,a,b)\tfor(ll (i) = (a-1);i >= (b);(i)--)\n#define rrep(i,n)\trFor(i,n,0)\n#define each(i,n)\tfor(auto &i : n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define tostr(a)\ttostring(a)\n#define dump(val) \tcerr << #val \" = \" << val << endl;\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst ll dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1e13 + 9;\n\n#define int ll\n#define double ld\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\t\n\tstring s; int I;\n\twhile (cin >> s >> I && s != \"0\") {\n\t\tstruct node {\n\t\t\tint sum;\n\t\t\tvector<int> to;\n\t\t\tstring s;\n\t\t};\n\t\ts = s + \")\";\n\t\twhile (1) {\n\t\t\tmap<int, string, greater<int>> add;\n\t\t\tFor(i, 1, s.size()) {\n\t\t\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\t\t\tif (s[i - 1] != '(' && !(s[i - 1] >= 'A' && s[i - 1] <= 'Z')) {\n\t\t\t\t\t\tadd[i] = \"(\";\n\t\t\t\t\t\tadd[i + 1] = \")\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (add.size() == 0)break;\n\t\t\teach(i, add) {\n\t\t\t\ts = s.substr(0, i.first) + i.second + s.substr(i.first);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tset<int, greater<int>> add;\n\t\t\trep(i, s.size()) {\n\t\t\t\tif (s[i] == '(' && (i == 0 || !(s[i - 1] >= '0' && s[i - 1] <= '9'))) {\n\t\t\t\t\tadd.insert(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\teach(i, add) {\n\t\t\t\ts.insert(s.begin() + i, '1');\n\t\t\t}\n\t\t}\n\n\t\tvector<node> nd;\n\t\tnd.push_back(node());\n\t\tfunction<int(int, int)> make_node = [&](int n, int t) {\n\t\t\tint sn = n;\n\t\t\twhile (s[n] >= 'A' && s[n] <= 'Z') {\n\t\t\t\tnd[t].s.push_back(s[n]); n++;\n\t\t\t}\n\t\t\tnd[t].sum = nd[t].s.size();\n\t\t\tfor (;; n++) {\n\t\t\t\tif (s[n] == '(') {\n\t\t\t\t\tint tp = toint(s.substr(sn, n - sn));\n\t\t\t\t\tnd.push_back(node());\n\t\t\t\t\tint tt = nd.size() - 1;\n\t\t\t\t\tn = make_node(n + 1, tt);\n\t\t\t\t\tnd[tt].sum *= tp;\n\t\t\t\t\tnd[tt].sum = min(INF, nd[tt].sum);\n\t\t\t\t\tnd[t].sum += nd[tt].sum;\n\t\t\t\t\tnd[t].sum = min(INF, nd[t].sum);\n\t\t\t\t\tnd[t].to.push_back(tt);\n\t\t\t\t\tsn = n + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s[n] == ')') {\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tmake_node(0, 0);\n\n\t\tfunction<char(int, int)> search = [&](int t,int c) {\n\t\t\tif (nd[t].s.size()) {\n\t\t\t\tc %= nd[t].s.size();\n\t\t\t\treturn nd[t].s[c];\n\t\t\t}\n\t\t\twhile (1) {\n\t\t\t\teach(to, nd[t].to) {\n\t\t\t\t\tif (nd[to].sum > c) {\n\t\t\t\t\t\treturn search(to, c);\n\t\t\t\t\t}\n\t\t\t\t\tc -= nd[to].sum;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (nd[0].sum <= I) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << search(0, I) << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nstring S;\nint idx, N;\n\nstruct T{\n  int rep;\n  char c;\n  vector<T> chd;\n  T(){rep=0, c='0';}\n};\n\n/*\n  <expr> ::= <term> | <term> <expr>\n  <term> ::= c | <num> c | <num> ( <expr> )\n */\n\npair<int,T> expr(int p);\npair<int,T> term(int p=0){\n  T t;\n  if(isdigit(S[p])){\n\tt.rep = S[p] - '0';\n\tfor(;isdigit(S[++p]);t.rep=t.rep*10+(S[p]-'0'));\n\tif(S[p] == '('){\n\t  auto res = expr(p+1);\n\t  p = res.FF;\n\t  t.chd.EB(res.SS);\n\t  assert(S[p] == ')');\n\t  return MP(p+1, t);\n\t}\n\telse{\n\t  t.c = S[p];\n\t  return MP(p+1, t);\n\t}\n  }\n  else{\n\tt.rep = 1;\n\tt.c = S[p++];\n\treturn MP(p, t);\n  }\n}\n\npair<int,T> expr(int p=0){\n  T t;\n  t.rep = 1;\n  while(p < N && S[p] != ')'){\n\tauto res = term(p);\n\tp = res.FF;\n\tt.chd.EB(res.SS);\n  }\n\n  return MP(p, t);\n}\n\nvoid debug(T& t, int lv = 1){\n  REP(i,lv) cout << \"*\";\n  cout << \" \" << t.rep << \": \" << t.c << endl;\n  for(auto& c: t.chd)\n\tdebug(c, lv+1);\n}\n\n\nchar dfs(T& t){\n  REP(j,t.rep){\n\tif(!t.chd.empty())\n\t  for(auto& ch: t.chd){\n\t\tchar c = dfs(ch);\n\t\tif(c != '0') return c;\n\t  }\n\telse{\n\t  if(idx == 0) return t.c;\n\t  --idx;\n\t}\n  }\n  return '0';\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>S>>idx,S!=\"0\"){\n\tN = SZ(S);\n\tauto rt = expr(0).SS;\n\tchar c = dfs(rt);\n\tcout << (c? c: '0') << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\npair<string, bool> seq(const string &s, int &id, int &k);\npair<int, bool> num(const string &s, int &id, int &k);\npair<string, bool> str(const string &s, int &id, int &k);\n\npair<string, bool> seq(const string &s, int &id, int &k) {\n\tpair<string, bool> ret = { \"\", true };\n\twhile (true) {\n\t\tauto c0 = num(s, id, k);\n\t\tif (c0.snd) {\n\t\t\tif (s[id] == '(') {\n\t\t\t\tid++;\n\t\t\t\tauto c1 = seq(s, id, k);\n\t\t\t\tif (c1.snd && s[id] == ')') {\n\t\t\t\t\tid++;\n\t\t\t\t\tLoop(i, c0.fst) {\n\t\t\t\t\t\tif (k < ret.fst.size()) break;\n\t\t\t\t\t\tret.fst += c1.fst;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse return { \"\", false };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto c2 = str(s, id, k);\n\t\t\t\tLoop(i, c0.fst) {\n\t\t\t\t\tif (k < ret.fst.size()) break;\n\t\t\t\t\tret.fst += c2.fst;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tauto c1 = str(s, id, k);\n\t\t\tif (c1.snd) {\n\t\t\t\tif (k < ret.fst.size());\n\t\t\t\telse ret.fst += c1.fst;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n}\n\npair<int, bool> num(const string &s, int &id, int &k) {\n\tint ret = 0;\n\twhile (true) {\n\t\tif ('0' <= s[id] && s[id] <= '9') {\n\t\t\tret = ret * 10 + (s[id] - '0');\n\t\t\tid++;\n\t\t}\n\t\telse {\n\t\t\tif (ret > 0) {\n\t\t\t\treturn { ret, true };\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn { 0, false };\n\t\t\t}\n\t\t}\n\t}\n}\n\npair<string, bool> str(const string &s, int &id, int &k) {\n\tstring ret = \"\";\n\twhile (true) {\n\t\tif ('A' <= s[id] && s[id] <= 'Z') {\n\t\t\tret += s[id];\n\t\t\tid++;\n\t\t}\n\t\telse {\n\t\t\tif (ret.size()) {\n\t\t\t\treturn { ret, true };\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn { \"\", false };\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tstring s;\n\t\tint k;\n\t\tcin >> s >> k;\n\t\tif (s == \"0\" && k == 0) break;\n\t\tint id = 0;\n\t\tauto c = seq(s, id, k);\n\t\tif (k < c.fst.size()) {\n\t\t\tcout << c.fst[k] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli INF = 2000000000LL;\n\nstring S;\nlli K, x, mem[1111], next[1111];\n\nlli init_rec() {\n  lli res = 0;\n  while (1) {\n    if (isalpha(S[x])) {\n      res = min(res + 1, INF);\n      x++;\n    } else if (isdigit(S[x])) {\n      string num = \"\";\n      while (isdigit(S[x])) {\n        num += S[x++];\n      }\n      lli n = atoll(num.c_str());\n      if (isalpha(S[x])) {\n        x++;\n        res = min(res + n, INF);\n      } else {\n        lli &len = mem[x];\n        lli &nx = next[x];\n        lli tmp = x;\n        x++;\n        len = init_rec();\n        x++;\n        nx = x;\n        lli add = min(n * len, INF);\n        res = min(res + add, INF);\n      }\n    } else {\n      return res;\n    }\n  }\n}\n\nvoid rec() {\n  while (1) {\n    if (isalpha(S[x])) {\n      if (--K == 0) {\n        throw S[x];\n      }\n      x++;\n    } else if (isdigit(S[x])) {\n      string num = \"\";\n      while (isdigit(S[x])) {\n        num += S[x++];\n      }\n      lli n = atoll(num.c_str());\n      if (isalpha(S[x])) {\n        K -= n;\n        if (K <= 0) {\n          throw S[x];\n        }\n        x++;\n      } else {\n        lli len = mem[x];\n        lli add = min(n * len, INF);\n        if (K <= add) {\n          K = (K - 1) % len + 1;\n          x++;\n          rec();\n          assert(false);\n        } else {\n          K -= add;\n          x = next[x];\n        }\n      }\n    } else {\n      return;\n    }\n  }\n}\n\nint main() {\n  while (cin >> S >> K) {\n    if (S == \"0\" && K == 0) return 0;\n    K++;\n    S += \"$\";\n    x = 0;\n    init_rec();\n    try {\n      x = 0;\n      rec();\n      cout << 0 << endl;\n    } catch(char ans) {\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nstring s;\nint p = 0;\nchar res;\nstring parse(ll k, ll repeat)\n{\n    string t;\n    while (p < s.size() && s[p] != ')' && t.size() <= k)\n    {\n        if (!isdigit(s[p]))\n        {\n            t += s[p];\n            ++p;\n        }\n        else\n        {\n            ll num = 0;\n            while (isdigit(s[p]))\n            {\n                num = 10*num + (s[p] - '0');\n                ++p;\n            }\n\n            if (s[p] == '(')\n            {\n                ++p;\n\n                string seq = parse(k - t.size(), num);\n                if (res != '0')\n                    return \"\";\n                rep(i, num)\n                    t += seq;\n\n                ++p;\n            }\n            else\n            {\n                t += string(num, s[p]);\n                ++p;\n            }\n        }\n    }\n\n    if (k < repeat * t.size() && res == '0')\n        res = t[k % t.size()];\n\n    return t;\n}\nint main()\n{\n    ll k;\n    while (cin >> s >> k, s[0] != '0')\n    {\n        p = 0;\n        res = '0';\n        parse(k, 1);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<string>\n#include<stack>\n\nusing namespace std;\n\nint main(){\n\n\tstring s;\n\tint i;\n\tstack<int> st;\n\tstring tmp;\n\tstring numtm;\n\tstring ans;\n\tbool f;\n\tstring rtmp;\n\n\twhile (1){\n\t\tcin >> s >> i;\n\t\tif (s == \"0\"&&i == 0) break;\n\n\t\twhile (!st.empty()) st.pop();\n\t\ttmp = \"\";\n\t\tnumtm = \"\";\n\n\t\tf = false;\n\t\tfor (int j = 0; j < s.size(); j++){\n\t\t\tif (s[j] >= '0'&&s[j] <= '9'){\n\t\t\t\tif (numtm != \"\" && f == true){\n\t\t\t\t\tfor (int k = 0; k < atoi(numtm.c_str()); k++){\n\t\t\t\t\t\tans += tmp;\n\t\t\t\t}\n\t\t\t\t\tnumtm = (\"\");\n\t\t\t\t}\n\t\t\t\telse ans += tmp;\n\t\t\t\tf = false;\n\t\t\t\ttmp = (\"\");\n\t\t\t\tnumtm += s[j];\n\t\t\t}\n\t\t\telse if (s[j] == '('){\n\t\t\t\tst.push(atoi(numtm.c_str()));\n\t\t\t\tnumtm = \"\";\n\t\t\t}\n\t\t\telse if (s[j] == ')'){\n\t\t\t\trtmp = ans;\n\t\t\t\tfor (int k = 0; k < st.top(); k++){\n\t\t\t\t\tif (tmp != \"\") ans += tmp;\n\t\t\t\t\telse if(k!=st.top()-1) ans += rtmp;\n\t\t\t\t}\n\t\t\t\ttmp = \"\";\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp += s[j];\n\t\t\t\tf = true;\n\t\t\t}\n\t\t}\n\t\tif (numtm != \"\"){\n\t\t\tfor (int j = 0; j < atoi(numtm.c_str()); j++){\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tnumtm = (\"\");\n\t\t}\n\t\telse ans += tmp;\n\t\tif (ans.size() > i) cout << ans[i] << endl;\n\t\telse cout << \"0\" << endl;\n\t\tans = \"\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <string>\n\n#define range(i,a,b) for(int (i)=a;(i)<(b);(i)++)\n#define rep(i,n) range(i,0,n)\n\nusing namespace std;\n\nconst int imax=1234567;\n\nint n;\nstring S;\nsize_t cur=0;\n\nint digit();\nint number();\nstring expression();\n\nint digit(){\n\treturn S[cur++]-'0';\n}\n\nint number(){\n\tint res=digit();\n\twhile(isdigit(S[cur])){\n\t\tres=res*10+digit();\n\t}\n\treturn res;\n}\n\n\n\nstring expression(void){\n\tstring rec=\"\";\n\twhile(cur < n){\n\t\t//cout << cur << endl;\n\t\tif(rec.size()>=imax)\n\t\t\treturn rec;\n\n\t\tif(isupper(S[cur])){\n\t\t\n\t\t\trec+=S[cur++];\n\n\t\t}else if(isdigit(S[cur])){\n\n\t\t\tint r=number();\n\t\t\tstring c=\"\";\n\n\t\t\tif(S[cur]=='('){\n\t\t\t\tcur++;\n\t\t\t\tc=expression();\n\t\t\t}else\n\t\t\t\tc=S[cur++];\n\n\t\t\trep(i,r){\n\t\t\t\tif(rec.size()>=imax)\n\t\t\t\t\treturn rec;\n\t\t\t\trec+=c;\n\t\t\t}\n\t\t}else if(S[cur]==')'){\n\t\t\tcur++;\n\t\t\treturn rec;\n\t\t}\n\n\t}\n\treturn rec;\n}\n\nint main(void){\n\tint i;\n\twhile(cin >> S >> i){\n\t\tif(S==\"0\")\n\t\t\tbreak;\n\t\tn=S.size();\n\t\tcur=0;\n\t\tstring res=expression();\n\t\tif(res[i]=='\\0')\n\t\t\tcout << 0 << endl;\n\t\telse\n\t\t\tcout << res[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\twhile (cin >> s >> N,s!=\"0\") {\n\t\tN++;\n\t\tbool flag = true;\n\t\twhile (flag) {\n\t\t\tint num = 0;\n\t\t\tflag = false;\n\t\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\t\tif (s[i]<'A' || s[i]>'Z')flag = true;\n\t\t\t\tif (s[i] <= '9'&&s[i] >= '0') {\n\t\t\t\t\tnum *= 10;\n\t\t\t\t\tnum += s[i] - '0';\n\t\t\t\t}\n\t\t\t\telse if (num&&s[i] >= 'A'&&s[i] <= 'Z') {\n\t\t\t\t\tstring t;\n\t\t\t\t\tint minus = 0;\n\t\t\t\t\tint box = num;\n\t\t\t\t\twhile (box) {\n\t\t\t\t\t\tbox /= 10;\n\t\t\t\t\t\tminus++;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < i - minus; j++) {\n\t\t\t\t\t\tt.push_back(s[j]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\t\t\tt.push_back(s[i]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j = i + 1; j < s.size(); j++) {\n\t\t\t\t\t\tt.push_back(s[j]);\n\t\t\t\t\t}\n\t\t\t\t\ts = t;\n\t\t\t\t\tnum = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (s[i] == ')') {\n\t\t\t\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\t\tif (s[j] == '(') {\n\t\t\t\t\t\t\t\t//cout << j << \" \" << i << endl;\n\t\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t\t\tint by = 1;\n\t\t\t\t\t\t\t\tint minus = 0;\n\t\t\t\t\t\t\t\tfor (int k = j - 1; k >= 0; k--) {\n\t\t\t\t\t\t\t\t\tif (s[k]<'0' || s[k]>'9')break;\n\t\t\t\t\t\t\t\t\tnum += by * (s[k] - '0');\n\t\t\t\t\t\t\t\t\tby *= 10;\n\t\t\t\t\t\t\t\t\tminus++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstring t;\n\t\t\t\t\t\t\t\tfor (int k = 0; k < j - minus; k++) {\n\t\t\t\t\t\t\t\t\tt.push_back(s[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tint add = 0;\n\t\t\t\t\t\t\t\tfor (int k = 0; k < num; k++) {\n\t\t\t\t\t\t\t\t\tfor (int l = j + 1; l < i; l++) {\n\t\t\t\t\t\t\t\t\t\tt.push_back(s[l]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tadd += i - j - 1;\n\t\t\t\t\t\t\t\t\tif (add >= N)break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int k = i + 1; k < s.size(); k++)t.push_back(s[k]);\n\t\t\t\t\t\t\t\ts = t;\n\t\t\t\t\t\t\t\ti-=2;\n\t\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse num = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << s.size() << endl;\n\t\t\t//cout << s << endl;\n\t\t}\n\t\tN--;\n\t\tif (s.size() <= N) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << s[N] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\nbool watch=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(const string str,const int from,const int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(ll i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//if(str==\"2(4(AB)3(XY))10C\"){\n\t\t\t\t\t//\tcout<<endl;\n\t\t\t\t\t//}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(ll i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\twatch=true;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;\nll a,t;\nstring f(){\n\tstring w=\"\";\n\twhile(t<s.size()){\n\t\tif(a<w.size())return w;\n\t\tif(isalpha(s[t])){\n\t\t\tw+=s[t];\n\t\t\tt++;\n\t\t}else if(s[t]==')'){\n\t\t\treturn w;\n\t\t}else{\n\t\t\tint co=0;\n\t\t\twhile(isdigit(s[t])){\n\t\t\t\tco*=10;\n\t\t\t\tco+=s[t]-'0';\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tstring tmp;\n\t\t\tif(isalpha(s[t])){\n\t\t\t\ttmp=s[t];\n\t\t\t}else{\n\t\t\t\tt++;\n\t\t\t\ttmp=f();\n\t\t\t}\n//\t\t\tcout<<co<<\" \"<<tmp.size()<<endl;\n//\t\t\tcout<<w<<endl;\n\t\t\twhile(co--){\n\t\t\t\tw+=tmp;\n\t\t\t\tif(a<w.size())return w;\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t}\n\treturn w;\n}\nint main(){\n\twhile(cin>>s>>a,s!=\"0\"){\n\t\tt=0;\n\t\tstring out=f();\n\t\tif(a<out.size())cout<<out[a]<<endl;\n\t\telse cout<<\"0\"<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000200\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    while(f){\n      f=0;\n      for(int i=0;i<(int)s[c].size();i++){\n\tif(!('0'<=s[c][i]&&s[c][i]<='9'))s[!c]+=s[c][i];\n\telse{\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t      pls+=s[c][idx];\n\t    }\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<N;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nstring s;\nint p,n,c=0;\nstring bnf1();\nstring get(){\n  string res;\n  if(s[p]=='(')p++,res=bnf1(),p++;\n  else if(isdigit(s[p])||isalpha(s[p])){\n    while(isdigit(s[p])||isalpha(s[p])){\n      res+=s[p++];\n      if(res.size()>1000000)return res.substr(0,1000009);\n    }\n  }\n  return res;\n}\nstring bnf2(){\n  string res=get();\n  while(s[p]=='*'){\n    if(res.size()>1000000)return res.substr(0,1000009);\n    p++;\n    string res2=get();\n    int num=0;\n    r(i,res.size())num=num*10+(res[i]-'0');\n    res=res2;\n    r(i,num-1){\n      res+=res2;\n      if(res.size()>1000000)return res.substr(0,1000009);\n    }\n  }\n  return res;\n}\nstring bnf1(){\n  string res=bnf2();\n  while(s[p]=='+'){\n    if(res.size()>1000000)return res.substr(0,1000009);\n    p++;\n    string res2=bnf2();\n    res+=res2;\n    if(res.size()>1000000)return res.substr(0,1000009);\n  }\n  return res;\n}\nint main(){\n  while(cin>>s>>n,s!=\"0\"){\n    p=0;\n    r(i,(int)s.size()-1){\n      if(isdigit(s[i])&&s[i+1]=='('||isdigit(s[i])&&isalpha(s[i+1])){\n        s=s.substr(0,i+1)+\"*\"+s.substr(i+1);\n        i--;\n      }\n      else if(s[i]==')'&&isalpha(s[i+1])||s[i]==')'&&isdigit(s[i+1])||isdigit(s[i+1])&&isalpha(s[i])){\n        s=s.substr(0,i+1)+\"+\"+s.substr(i+1);\n        i--;\n      }\n    }\n    string ans=bnf1();\n    if(n<ans.size())cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <cstdlib>\n#include <vector>\n#include <map>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n\nstring Str;\nint Index;\n\nclass Node {\npublic:\n  int num;\n  string s;\n  vector<Node> v;\n  Node() { num = -1; }\n};\n\nNode root;\n\nint getNum(int &pos, string s) {\n  int st = pos;\n  int length = 0;\n  while(isdigit(s[pos])) { ++length; ++pos; }\n  //cout << s << \" => \" << s.substr(st, length) << endl;\n  return atoi(s.substr(st, length).c_str());\n}\n\nchar rec(int &i, int j, Node node) {\n  //cout << node.s << \" :: \" << node.num << endl;\n  if(node.s.size()) {\n    for(int l = 0; l < node.num; ++l) {\n      for(int k = 0; k < node.s.size(); ++k) {\n\t//cout << node.s[k];\n\tif(i == j) return node.s[k];\n\t++i;\n      }\n    }\n    return '0';\n  }\n\n  for(int k = 0; k < node.num; ++k) {\n    for(int l = 0; l < node.v.size(); ++l) {\n      char c = rec(i, j, node.v[l]);\n      if(c != '0') return c;\n    }\n  }\n  return '0';\n}\n\nvector<string> sep(string s)\n{\n  string t;\n  vector<string> v, u;\n  t += s[0];\n\n  for(int i=1; i<s.size(); ++i){\n    if( s[i-1] == ')' && isalpha(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( s[i-1] == ')' && isdigit(s[i]) ){\n      v.push_back(t);\n      t = \"\";\n    }\n    else if( isdigit(s[i]) && isalpha(s[i-1])){\n      v.push_back(t);\n      t = \"\";\n    }\n    t += s[i];\n  }\n  if(t.size()) {\n    v.push_back(t);\n  }\n\n  int o, c;\n  o = c = 0;\n  t = \"\";\n  for(int i = 0; i < v.size(); ++i) {\n    if(o + c && o == c) {\n      u.push_back(t);\n      o = c = 0;\n      t = \"\";\n    }\n    t += v[i];\n    o += count(v[i].begin(), v[i].end(), '(');\n    c += count(v[i].begin(), v[i].end(), ')');\n  }\n  if(t.size()) u.push_back(t);\n  return u;\n  for(int i=0; i<u.size(); ++i){\n    cout << u[i] << \"_\";\n  }\n  cout << endl;\n  return u;\n}\n\nvoid conv(string &s) {\n  for(int i = 2; i < s.length(); ++i) {\n    if(isdigit(s[i-2]) && isalpha(s[i-1]) && !isalpha(s[i])) {\n      s.insert(i-1, \"(\");\n      s.insert(i+1, \")\");\n    }\n  }\n}\n\nNode build(string s) {\n  //cout << s << endl;\n  Node node;\n  int num;\n  if(isalpha(s[0])) {\n    node.num = 1;\n    node.s = \"\" + s;\n    return node;\n  } else {\n    int pos = 0;\n    num = getNum(pos, s);\n    if(s[pos] != '(') {\n      node.num = num;\n      node.s = \"\";//(pos < s.size()) ? \"####\" : \"@@@\";\n      node.s += s[pos];\n      return node;\n    }\n    ++pos;\n    s.erase(s.begin(), s.begin()+pos);\n    s.erase(s.begin() + s.size() - 1);\n    if(count(s.begin(), s.end(), '(') == 0) {\n      node.num = num;\n      node.s = s;\n      return node;\n    }\n    int o, c;\n    string t = \"\";\n    o = c = 0;\n    vector<string> v = sep(s);\n    for(int i=0; i<v.size(); ++i){\n      node.v.push_back( build(v[i]) );\n    }\n  }  \n  node.num = num;\n  return node;\n  cout << node.s << endl;\n  for(int i = 0; i < node.v.size(); ++i) {\n    cout << node.v[i].s << \" \";\n  }\n  cout << endl << endl;\n  return node;\n}\n\nvoid solve() {\n  Str.insert(0, \"1(\");\n  Str.insert(Str.size(), \")\");\n  conv(Str);\n  //cout << Str << endl;\n  root = build(Str);\n  int i = 0;\n  char c  = rec(i, Index, root);\n  cout << c << endl;\n}\n\nmain() {\n  while(cin >> Str >> Index) {\n    if(Str == \"0\" && Index == 0) break;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(string str,int from,int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(subs==\"4(AB)5(CD)\"){\n//\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\nconst ll MOD=1e9+7;\n\nstring str;\nint t;\n\nint num(int &i){\n  int re=0;\n  while(i<str.size() && isdigit(str[i])){\n    re*=10;\n    re+=str[i]-'0';\n    ++i;\n  }\n  return re;\n}\n\nstring Str(int &i){\n  //cout<<i<<endl;\n  string re;\n  while(i<str.size()){\n    if(isalpha(str[i]))\n      re+=str[i++];\n    else if(isdigit(str[i])){\n      int n=num(i);\n      string tmp;\n      if(str[i]=='('){\n\t++i;\n\ttmp=Str(i);\n\t++i;\n      }else{\n\ttmp=str[i++];\n      }\n      rep(i,n){\n\tre+=tmp;\n\tif(re.size()>t) return re;\n      }\n    }else if(str[i]==')') break;\n  }\n  if(re.size()>t) return re;\n  return re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  while(cin>>str>>t,str!=\"0\" || t){\n    int n=str.size(),i=0;\n    //cout<<str<<endl;\n    string re=Str(i);\n    //cout<<re<<endl;\n    if(re.size()<=t){\n      cout<<0<<endl;\n    }else{\n      cout<<re[t]<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m;\nchar ans;\nbool flag = false;\nstring dfs(string s) {\n\t//cout << s << endl;\n\tif(flag) return \"\";\n\tif('A' <= s[0] && s[0] <= 'Z') {\n\t\treturn s;\n\t}\n\t//10C??????????????????????¢????\n\tbool h = false, ff = false;\n\tstring tt = \"\";\n\tint idx = -1;\n\tREP(i, s.size()) {\n\t\tif(i >= 5) break;\n\t\tif(s[i] == '(') h = true;\n\t\tif(isdigit(s[i])) tt += s[i], idx = i, ff = true;\n\t\telse if(ff && isdigit(s[i])) h = false;\n\t}\n\tstring ret = \"\";\n\tif(!h) {\n\t\tstring tmp = dfs(s.substr(idx+1));\n\t\tint itt = stoi(tt);\n\t\t//cout << \"tmp\" << tmp << \"itt\" << itt << endl;\n\t\tREP(i, itt) {\n\t\t\tret += tmp;\n\t\t\t//cout << ret << endl;\n\t\t\tif((int)ret.size() > m) {\n\t\t\t\tans = ret[m];\n\t\t\t\tflag = true;\n\t\t\t\t//cout << ans << endl;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t//cout << \"b\" << endl;\n\tstring num = \"\", para = \"\";\n\tint now = 0;\n\tbool f = true, g = false, kakko = false;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '(') {\n\t\t\tkakko = true;\n\t\t\tg = true;\n\t\t\tnow++;\n\t\t} else if(s[i] == ')') {\n\t\t\tnow--;\n\t\t} else if(isdigit(s[i])){\n\t\t\tf = false;\n\t\t} else {\n\t\t\tf = true;\n\t\t\tg = true;\n\t\t}\n\t\tif(g) para += s[i];\n\t\telse num += s[i];\n\t\tif(now == 0 && f) {\n\t\t\t//tmp???dfs?????????????????°?????????????????????ret????????????\n\t\t\t//cout << \"para\" << para << \"num\" << num << endl;\n\t\t\tint ttmp = stoi(num);\n\t\t\tstring dret;\n\t\t\tif(kakko) dret = dfs(para.substr(1, para.size()-2));\n\t\t\telse dret = dfs(para);\n\t\t\tREP(j, ttmp) {\n\t\t\t\tret += dret;\n\t\t\t\tif((int)ret.size() > m) {\n\t\t\t\t\tans = ret[m];\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tnum = \"\", para = \"\";\n\t\t\tf = true, g = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\n\t\tflag = false;\n\n\t\tbool f = true;\n\t\tint now = 0;\n\t\tstring tmp = \"\";\n\t\tREP(i, s.size()) {\n\t\t\t//cout << \"i:\" << i << \" \" << s[i] << endl;\n\t\t\tif(s[i] == '(') now++;\n\t\t\telse if(s[i] == ')') now--;\n\t\t\telse if(isdigit(s[i])) f = false;\n\t\t\telse f = true;\n\t\t\ttmp += s[i];\n\t\t\t//cout << tmp << \" \" << m << endl;\n\t\t\tif(now == 0 && f) {\n\t\t\t\tstring t = dfs(tmp);\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif(flag) {cout << ans << endl; goto e;}\n\t\t\t\telse if((int)t.size() <= m) {\n\t\t\t\t\tm -= t.size();\n\t\t\t\t}\telse {cout << t[m] << endl; goto e;}\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t\te:\n\t\tint a;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// dp[a][b]ÉÍfrom a to bÌ¶ððÍµ½Æ«A½¶Ì¶ªoÄ­é©ðL^µÄ¨­\nll dp[101][101];\n\nll cp=-1;\nll idx;\nchar result=0;\nbool fin=false;\n\n// ðÍµÈªçJEgµÄ¢­\nint dfs(string str,int from,int to){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tfor(int i = 0; i < cnt; i++){\n\t\t\t\t\tif(dp[start+1][pos-1]!=-1){\n\t\t\t\t\t\tll sum=cp+dp[start+1][pos-1];\n\t\t\t\t\t\tif(sum<idx){\n\t\t\t\t\t\t\tcp=sum;\n\t\t\t\t\t\t\t//if(cp>idx){\n\t\t\t\t\t\t\t//\tfin=true;\n\t\t\t\t\t\t\t//\treturn 0;\n\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\tresCnt+=dp[start+1][pos-1];\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresCnt+=dfs(subs,start+1,pos-1);\n\t\t\t\t\tif(result!=0||fin)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t// ¶Ìê\n\t\t\telse{\n\t\t\t\tfor(int i = 0;i < cnt; i++){\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[pos];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresCnt++;\n\t\t\t\t\tcp++;\n\t\t\t\t\tif(cp>idx){\n\t\t\t\t\t\tfin=true;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif(cp==idx){\n\t\t\t\t\t\tresult=str[i];\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdp[from][to]=resCnt;\n\treturn resCnt;\n}\n\nint main(){\n\tstring str;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfor(int j = 0; j < 101; j++)\n\t\t\t\tdp[i][j]=-1;\n\t\tfin=false;\n\t\tcp=-1;\n\t\tresult=0;\n\t\tdfs(str,0,str.size()-1);\n\t\tif(result==0)\n\t\t\tcout<<0<<endl;\n\t\telse\n\t\t\tcout<<result<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n#define PB push_back\n#define mkp make_pair\n#define F first\n#define S second\n\ntypedef vector<int> vint;\ntypedef long long ll;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pii;\ntypedef vector<pair<pii,string>> vip;\n\nstring s;\nint n;\n\nvector<vip> node;\nvll cnt;\n\nvoid func(int l,int r,int root){\n\t// cout<<l<<\" \"<<r<<\" \"<<root<<endl;\n\treep(i,l,r){\n\t\t// cout<<i<<endl;\n\t\tif(isdigit(s[i])){\n\t\t\tint num = 0;\n\t\t\tint pos = i;\n\t\t\twhile(isdigit(s[pos])) num=num*10+s[pos++]-'0';\n\t\t\tnode.PB(vip(0));\n\t\t\t// cout<<\"num \"<<num<<endl;\n\t\t\tif(s[pos]=='('){\n\t\t\t\tbool ok = true;\n\t\t\t\tint pp = pos+1;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(s[pp]=='(') ok=false;\n\t\t\t\t\tif(s[pp]==')') break;\n\t\t\t\t\tpp++;\n\t\t\t\t}\n\t\t\t\tif(ok){\n\t\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),s.substr(pos+1,pp-pos-1)));\n\t\t\t\t\ti=pp;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpp = pos;\n\t\t\t\t\tint aa = 0;\n\t\t\t\t\tint bb = 0;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(s[pp]=='(') aa++;\n\t\t\t\t\t\tif(s[pp]==')') bb++;\n\t\t\t\t\t\tif(aa==bb) break;\n\t\t\t\t\t\tpp++;\n\t\t\t\t\t}\n\t\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),\"\"));\n\t\t\t\t\tfunc(pos+1,pp-1,node.size()-1);\n\t\t\t\t\ti=pp;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode[root].PB(mkp(pii(num,node.size()-1),s.substr(pos,1)));\n\t\t\t\ti=pos;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstring a=\"\";\n\t\t\tint pos = i;\n\t\t\twhile(pos<s.size()&&isupper(s[pos])) a+=s[pos++];\n\t\t\tnode.PB(vip(0));\n\t\t\tnode[root].PB(mkp(pii(1,node.size()-1),a));\n\t\t\ti=pos-1;\n\t\t}\n\t}\n}\n\nvoid visual(int x){\n\tfor(auto y:node[x]){\n\t\tcout<<y.F.F<<\" \"<<y.F.S<<\" \"<<y.S<<endl;\n\t\tvisual(y.F.S);\n\t}\n}\n\nll dfs(int x){\n\tll ret = 0;\n\tfor(auto y:node[x]){\n\t\tif(node[y.F.S].size()==0){\n\t\t\tcnt[y.F.S] = y.S.size();\n\t\t\tret+=cnt[y.F.S]*y.F.F;\n\t\t}\n\t\telse{\n\t\t\tret+=dfs(y.F.S)*y.F.F;\n\t\t}\n\t}\n\treturn cnt[x]=min((ll)INT_MAX,ret);\n}\n\nvoid calc(int x,int n){\n\tll c = 0;\n\t// cout<<x<<\" \"<<n<<endl;\n\tfor(auto y:node[x]){\n\t\tc+=cnt[y.F.S]*y.F.F;\n\t\t// cout<<c<<endl;\n\t\tif(n<c){\n\t\t\tif(y.S.size()){\n\t\t\t\tn=n-(c-cnt[y.F.S]*y.F.F);\n\t\t\t\tassert(n>=0);\n\t\t\t\tcout<<y.S[n%y.S.size()]<<endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tn=n-(c-cnt[y.F.S]*y.F.F);\n\t\t\t\tassert(n>=0);\n\t\t\t\t// cout<<y.F.S<<\" \"<<n%cnt[y.F.S]<<endl;\n\t\t\t\tcalc(y.F.S,n%cnt[y.F.S]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>s>>n){\n\t\tif(s==\"0\"){\n\t\t\tbreak;\n\t\t}\n\t\tnode.assign(1,vip(0));\n\t\tfunc(0,s.size(),0);\n\t\tcnt=vll(node.size());\n\t\tdfs(0);\n\t\tif(n>=cnt[0]){\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse{\n\t\t\tcalc(0,n);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int INF = 2e6;\n\nclass Parser{\npublic:\n  string S;\n  int i, k;\n  void init(string s, int x){\n    S = s;\n    k = x;\n    i = 0;\n  }\n\n  char parse(){\n    return expr2();\n  }\n\n  int expr(){\n    int ret = 0;\n    while(i < S.length() && S[i] != ')'){\n      int n = number(), t;\n      if(S[i] == '('){\n        ++i;\n        t = expr();\n        ++i;\n      }else{\n        t = str();\n      }\n      if(ret >= INF || n >= INF || t >= INF || n >= INF/t)\n        ret = INF;\n      else ret = min(ret + n*t, INF);\n    }\n    return min(INF,ret);\n  }\n\n  char expr2(){\n    //cout << \"i, k = \" << i << \", \" << k << endl;\n    if(i >= S.length()) return '0';\n    int n = number(), j;\n    if(S[i] == '('){\n      ++i;\n      j = i;\n      int t = expr();\n      ++i;\n      if(k >= n*t){\n        k -= n*t;\n      }else{\n        k %= t;\n        i = j;\n      }\n      return expr2();\n    }else{\n      j = i;\n      int t = str();\n      if(t*n > k){\n        return S[j + k%t];\n      }else{\n        k -= t*n;\n        return expr2();\n      }\n    }\n    return '0';\n  }\n\n  int number(){\n    if(i >= S.length() || S[i] < '0' || S[i] > '9') return 1;\n    int ret = 0;\n    while(i < S.length() && S[i] >= '0' && S[i] <= '9'){\n      ret *= 10;\n      ret += S[i] - '0';\n      ++i;\n    }\n    return ret;\n  }\n  \n  int str(){\n    int ret = 0;\n    while(i < S.length() && S[i] >= 'A' && S[i] <= 'Z'){\n      ++ret;\n      ++i;\n    }\n    return ret;\n  }\n};\n\nint main(){\n  string s;\n  int x;\n  Parser P;\n  while(cin >> s >> x, s != \"0\"){\n    P.init(s,x);\n    cout << P.parse() << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, char>;\n\nstring S;\nint n, it;\n\nint num() {\n\tint res = 0;\n\twhile (it < n && isdigit(S[it])) {\n\t\tres = res * 10 + S[it] - '0';\n\t\tit++;\n\t}\n\treturn res;\n}\n\nP parser(int t) {\n\tP res(0, '0');\n\twhile (it < n && S[it] != ')') {\n\t\tif (isdigit(S[it])) {\n\t\t\tint nm = num();\n\t\t\tif (S[it] == '(') {\n\t\t\t\tit++;\n\t\t\t\tint tmp = it;\n\t\t\t\tauto p = parser(t);\n\t\t\t\tif (p.second != '0') {\n\t\t\t\t\tres.second = p.second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (t < p.first * nm) {\n\t\t\t\t\tit = tmp;\n\t\t\t\t\tt %= p.first;\n\t\t\t\t\tres.second = parser(t).second;\n\t\t\t\t}\n\t\t\t\tt -= p.first * nm;\n\t\t\t\tres.first += p.first * nm;\n\t\t\t\tassert(S[it++] == ')');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t < nm) {\n\t\t\t\t\tres.second = S[it];\n\t\t\t\t}\n\t\t\t\tt -= nm;\n\t\t\t\tres.first += nm;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (t == 0) {\n\t\t\t\tres.second = S[it];\n\t\t\t}\n\t\t\tt--;\n\t\t\tres.first++;\n\t\t\tit++;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> S >> i, S != \"0\" || i != 0) {\n\t\tn = S.size();\n\t\tit = 0;\n\t\tcout << parser(i).second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nstring s; int n, p;\n\nint num()\n{\n\tint res = 0;\n\twhile (isdigit(s[p]))\n\t{\n\t\tres *= 10;\n\t\tres += s[p] - '0';\n\t\tp++;\n\t}\n\treturn res;\n}\n\nstring parse()\n{\n\tstring res;\n\tint t;\n\tif (isdigit(s[p])) t = num();\n\telse t = 1;\n\tif (s[p] == '(')\n\t{\n\t\tp++;\n\t\tstring tmp = parse();\n\t\tp++;\n\t\tREP(i, t)\n\t\t{\n\t\t\tres += tmp;\n\t\t\tif (res.size() > n) return res;\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(i, t)\n\t\t{\n\t\t\tres += s[p];\n\t\t\tif (res.size() > n) return res;\n\t\t}\n\t\tp++;\n\t}\n\twhile (p < s.size()&&s[p]!=')')\n\t{\n\t\tif (res.size() > n) return res;\n\t\tres += parse();\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> s >> n, s != \"0\")\n\t{\n\t\tp = 0;\n\t\tstring res = parse();\n\t\tif (res.size() > n) cout << res[n] << endl;\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<cstdio>\n#include<cstring>\n#include<climits>\n\nusing namespace std;\n\nlong long len(const char *str){\n  long long ret = 0;\n  str++;\n  while(*str!=')'){\n    //printf(\" %s : ret=%d\\n\",str,ret);\n    if(isdigit(*str)||*str=='('){\n      long long num;\n      if(*str=='('){\n        num = 1;\n      }else{\n        sscanf(str,\"%lld\",&num);\n        while(isdigit(*str)) str++;\n      }\n      long long length;\n      if(*str=='('){\n        length = len(str);\n      }else{\n        length = 1;\n      }\n      //printf(\"  len=%d, num=%d\\n\",length,num);\n      if(*str=='('){\n        long long nest = 0;\n        do{\n          if(*str=='(') nest++;\n          else if(*str==')') nest--;\n          str++;\n        }while(nest!=0);\n      }else{\n        str++;\n      }\n      ret+=num*length;\n    }else if(isalpha(*str)){\n      long long cnt = 0;\n      while(isalpha(*str)){\n        cnt++;\n        //printf(\"  alpha: %d (%c)\\n\",cnt,*str);\n        str++;\n      }\n      //printf(\"  alpha: %d (%c)\\n\",cnt,*str);\n      ret+=cnt;\n    }\n    if(ret > INT_MAX) return INT_MAX;\n  }\n  return ret;\n}\n\nchar parse(const char *str, long long p){\n  //printf(\"str: %s  p: %lld\\n\",str,p);\n  int f = (*str=='('?1:0);\n  if(p<0 || *str=='\\0') return '0';\n  if(isdigit(*str)||*str=='('){\n    long long num;\n    if(*str=='('){\n      num = 1;\n    }else{\n      sscanf(str,\"%lld\",&num);\n      while(isdigit(*str)) str++;\n    }\n    long long length;\n    if(*str=='('){\n      length = len(str);\n      //printf(\" %s: %d\\n\",str,length);\n    }else{\n      length = 1;\n    }\n    if(length==INT_MAX){\n      return parse(str+f, p);\n    }else if(num*length>p){\n      return parse(str+f, p%length);\n    }else{\n      if(*str=='('){\n        long long nest = 0;\n        do{\n          if(*str=='(') nest++;\n          else if(*str==')') nest--;\n          str++;\n        }while(nest!=0);\n      }else{\n        str++;\n      }\n      return parse(str, p-num*length);\n    }\n  }else if(isalpha(*str)){\n    if(p==0) return *str;\n    else return parse(str+1, p-1);\n  }\n}\n\nint main(){\n  char buff[120];\n  long long p;\n  while(scanf(\"%s%lld\",buff,&p),p!=0 || strcmp(buff,\"0\")!=0)\n    printf(\"%c\\n\",parse(buff,p));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Node {\n  vector< Node * > child;\n  int64 mult;\n  int64 sum;\n  string s;\n\n  Node() : mult(1), sum(0) {}\n\n  char dfs(int pos) {\n    if(pos >= mult * sum) return '0';\n    pos %= sum;\n    if(s.size()) return s[pos];\n    for(auto &p : child) {\n      if(pos - p->mult * p->sum < 0) return p->dfs(pos);\n      pos -= p->mult * p->sum;\n    }\n    throw 0;\n  }\n};\n\nconst int64 LIM = 1 << 29;\n\nstring S;\nint ptr;\n\nNode *expr() {\n  if(S[ptr] == '(') {\n    ++ptr;\n    Node *ret = expr();\n    ++ptr;\n    return ret;\n  } else {\n    Node *root = new Node();\n    while(isdigit(S[ptr]) || isalpha(S[ptr])) {\n      Node *beet;\n      if(isalpha(S[ptr])) {\n        beet = new Node();\n        beet->s += S[ptr++];\n        beet->sum = (int) beet->s.size();\n      } else {\n        int mult = 0;\n        while(isdigit(S[ptr])) mult = mult * 10 + S[ptr++] - '0';\n        beet = expr();\n        beet->mult = mult;\n      }\n      root->sum += min(LIM, beet->mult * beet->sum);\n      root->sum = min(LIM, root->sum);\n      root->child.emplace_back(beet);\n    }\n    return root;\n  }\n}\n\n\nint main() {\n  int idx;\n  while(cin >> S >> idx, S != \"0\") {\n    ptr = 0;\n    S += \"$\";\n    auto root = expr();\n    cout << root->dfs(idx) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Node {\n    string pattern;\n    ll len,factor;\n    vector<Node*> child;\n};\n\nint p;\n\nNode *parse(string &s) {\n    if(isdigit(s[p])) {\n        int r = 0;\n        while(isdigit(s[p])) {\n            r *= 10;\n            r += s[p] -'0';\n            p++;\n        }\n\n        Node *node = new Node();\n        node->factor = r;\n        if(s[p] == '(') {\n            p++;\n            while(s[p] != ')') {\n                Node *nr = parse(s);\n                node->child.push_back(nr);\n            }\n            p++;\n            node->len = 0;\n            for(int i=0; i<node->child.size(); ++i)\n                node->len += node->child[i]->len;\n\n            node->len *= node->factor;\n            return node;\n        }else{\n            node->pattern = string(1,s[p]);\n            p++;\n            node->len = r;\n            return node;\n        }\n    }\n\n    Node *node = new Node();\n    string pattern = \"\";\n    while(p < s.length() && isalpha(s[p])) {\n        pattern += string(1,s[p]);\n        p++;\n    }\n    node->pattern = pattern;\n    node->len = pattern.length();\n    node->factor = 1;\n    return node;\n}\n\nchar dfs(Node *v,ll idx) {\n    if(v->child.empty()) {\n        string pat = v->pattern;\n        if(idx < v->factor*pat.length()) return pat[idx%(pat.length())];\n        v->len = pat.length()*(v->factor);\n        return '-';\n    }\n\n    ll offset = 0;\n    for(int i=0; i<v->child.size(); ++i) {\n        char c = dfs(v->child[i],idx-offset);\n        if(c != '-') return c;\n        offset += v->child[i]->len;\n    }\n    if(idx/offset < v->factor) {\n        idx %= offset;\n        return dfs(v,idx);\n    }\n    v->len = offset*v->factor;\n    return '-';\n}\n\nint main() {\n    int n;\n    string s;\n    while(cin>>s) {\n        cin>>n;\n        if(s == \"0\" && n == 0) break;\n        p = 0;\n        s += \")\";\n        s = \"1(\" + s;\n        Node *root = parse(s);\n        char ans = dfs(root,n);\n        if(ans == '-') cout<<\"0\"<<endl;\n        else cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\ntypedef pair<char,lli> cip;\n\ntypedef string::iterator sta;\n\nbool isnum(char c){\n\treturn ('0'<=c && c<='9');\n}\n\nlli num(sta& s){\n\tlli res=0;\n\twhile(isnum(*s)){\n\t\tres*=10; res+=(*s-'0');\n\t\ts++;\n\t}\n\treturn res;\n}\n\ncip exprs(sta& s,lli p);\n\n#include<cassert>\n\n//6(55(44(255(YG))A)7(97(R))W9(U)PJ)G9(347(Y84(QSKVZ)JJ262(I779(UDOQ)RXSQV3(VTCY))W))4(B)NDJ 65420\n\ncip expr(sta& s,lli p){\n\t//printf(\"%c %lld\\n\",*s,p);\n\tcip res;\n\tif(isnum(*s)){\n\t\tlli a=num(s);\n\t\tif(*s=='('){\n\t\t\ts++; \n\t\t\tsta ns=s;\n\t\t\tcip pa=exprs(s,p);\n\t\t\tif(pa.fir!='0')res=pa;\n\t\t\telse{\n\t\t\t\tif(pa.sec*a>p){\n\t\t\t\t\tres=exprs(ns,p % pa.sec);\n\t\t\t\t}\n\t\t\t\telse res=cip('0',pa.sec*a);\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\t\telse{\n\t\t\tif(a>p)res=cip(*s,0);\n\t\t\telse res=cip('0',a);\n\t\t\ts++;\n\t\t}\n\t}\n\telse{\n\t\tif(p==0)res=cip(*s,0);\n\t\telse res=cip('0',1);\n\t\ts++;\n\t}\n\treturn res;\n}\n\ncip exprs(sta& s,lli p){\n\tcip res('0',0);\n\tlli nl=0;\n\tfor(;;){\n\t\tif(*s==')' || *s=='$')break;\n\t\tcip a=expr(s,p);\n\t\t//printf(\"expr %c %d\\n\",a.fir,a.sec);\n\t\tif(a.fir!='0')return a;\n\t\tp-=a.sec;\n\t\tnl+=a.sec;\n\t}\n\tres.sec=nl;\n\treturn res;\n}\n\nint n;\nstring s;\n\nint main(void){\n\tfor(;;){\n\t\tcin >> s >> n;\n\t\tif(n==0 && s[0]=='0' && s[1]=='\\0')break;\n\t\ts += \"$\";\n\t\tsta ss=s.begin();\n\t\tcip pa=exprs(ss,n);\n\t\tprintf(\"%c\\n\",pa.fir);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e14+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nstring s;int bas;\nclass bun{\npublic:\n\tchar c;//文字\n\tint kuri;//繰り返し回数\n\tllint len;//文字列長\n\tvector<bun> ko;//中身\n\tvoid make(void){\n\t\tif('A'<=s[bas]&&s[bas]<='Z'){\n\t\t\tc=s[bas];bas++;\n\t\t\tkuri=1;len=1;\n\t\t\treturn;\n\t\t}\n\t\t//そうでなければ数字のはず\n\t\tkuri=0;\n\t\twhile('0'<=s[bas]&&s[bas]<='9'){kuri*=10;kuri+=s[bas]-'0';bas++;}\n\t\tif(kuri==0){cerr<<\"bag\"<<__LINE__<<endl;}\n\t\tif(s[bas]=='('){\n\t\t\tbas++;len=0;c='#';\n\t\t\twhile(s[bas]!=')'){\n\t\t\t\tko.emplace_back();\n\t\t\t\tko.back().make();\n\t\t\t\tlen+=ko.back().len;\n\t\t\t}\n\t\t\tmineq(len,big);len*=kuri;mineq(len,big);\n\t\t\tbas++;\n\t\t}\n\t\telse{c=s[bas];bas++;len=kuri;}\n\t\treturn;\n\t}\n\tchar putc(llint index){\n\t\tif(len<=index){return '0';}\n\t\tif(c!='#'){return c;}\n\t\tindex%=(len/kuri);//一回当たりの回数\n\t\tfor(auto it:ko){\n\t\t\tif(index<it.len){return it.putc(index);}\n\t\t\telse{index-=it.len;}\n\t\t}\n\t}\n};\nbool solve(void){\n\tbun aa;\n\tstring ss;cin>>ss;\n\tif(ss==\"0\"){return false;}\n\ts=\"1(\"+ss+\")\";bas=0;\n\taa.make();\n\tint ind;cin>>ind;\n\tcout<<aa.putc(ind)<<endl;\n\treturn true;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);\n\tcin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> piii;\ntypedef pair<ll,ll> pll;\n\n#define reps(i,f,n) for(int i = int(f); i <= int(n); i++)\n#define rep(i,n) reps(i,0,int(n)-1)\n#define rrep(i,n) for(int i = n-1; i >= 0; i--)\n\n#define all(x) (x).begin(),(x).end()\n#define X first\n#define Y second\n\n#define sz size()\n#define eb emplace_back\n\nvector<int> x[1024];\nstring y[1024];\nint cnt;\n\nvoid parse(string s){\n  int ind = 0;\n  int l = s.size();\n  int num = 0;\n  cnt = 0;\n  vector<int> nums;\n  rep(i,1024)x[i].clear();\n  rep(i,1024)y[i] = \"\";\n\n  while(ind<l){\n    //cout << \"num\" << num << endl;\n    if(s[ind] == '('){\n      nums.push_back(num);\n      num = 0;\n    }else if('0' <= s[ind] && s[ind] <= '9'){\n      num *= 10;\n      num += s[ind]-'0';\n    }else if(s[ind] == ')'){\n      rep(i, nums.size()) x[cnt].push_back(nums[i]);\n      if(nums.size() == 0)x[cnt].push_back(1);\n      cnt++;\n      nums.pop_back();\n    }else{\n      if(num != 0){\n        nums.push_back(num);\n        num = 0;\n      }\n      y[cnt] += s[ind];\n    }\n    ind++;\n  }\n  if(y[cnt] != \"\"){\n    rep(i, nums.size()) x[cnt].push_back(nums[i]);\n    if(nums.size() == 0)x[cnt].push_back(1);\n    cnt++;\n  }\n}\n\nint main(void){\n  string s;\n  int p;\n  while(1){\n    cin >> s >> p;\n    if(s[0] == '0')break;\n    parse(s);\n    /*\n    rep(i,cnt){\n      cout << y[i] << endl;\n      rep(j,x[i].size()){\n        cout << x[i][j] << \",\";\n      }cout << endl;\n    }\n    */\n\n    rep(i,cnt){\n      int q = y[i].size();\n      rep(j, x[i].size()){\n        q *= x[i][j];\n        if(p < q){\n          cout << y[i][p%y[i].size()] << endl;\n          p -= q;\n          break;\n        }\n      }\n      p -=q;\n      if(p < 0)break;\n    }\n    if(p >= 0)cout << \"0\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdlib>\nusing namespace std;\nint pos,n;\nstring s;\nstring f();\nstring expr(){\n\tstring a=f();\n\twhile(isdigit(s[pos])||isalpha(s[pos])){\n\t\tif(a.size()>n)\n\t\t\tbreak;\n\t\ta+=f();\n\t}\n\treturn a;\n}\nstring f(){\n\tstring t=\"\",p;\n\tif(isdigit(s[pos])){\n\t\tint ret=0,i=0;\n\t\tfor(;isdigit(s[pos]);pos++){\n\t\t\tret*=10;\n\t\t\tret+=s[pos]-'0';\n\t\t}\n\t\tp=f();\n\t\tfor(;i<ret;i++){\n\t\t\tt+=p;\n\t\t\tif(t.size()>n)\n\t\t\t\tbreak;\n\t\t}\n\t}else if(s[pos]=='('){\n\t\tpos++;\n\t\tt=expr();\n\t\tpos++;\n\t}else{\n\t\tfor(;isalpha(s[pos]);pos++){\n\t\t\tt+=s[pos];\n\t\t\tif(t.size()>n)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\nint main(){\n\twhile(cin>>s>>n,s!=\"0\"||n){\n\t\tpos=0;\n\t\ts+=\"#\";\n\t\tstring t=expr();\n\t\tif(t.size()-1<n)\n\t\tcout<<0<<endl;\n\t\telse\n\t\tcout<<t[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n\n// ^¦çê½¶Ì¶ðÔ·\nll cntSreSize(string str){\n\tstring res;\n\tll pos=0;\n\tll resCnt=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\tll an=cntSreSize(subs);\n\t\t\t\tresCnt+=an*cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresCnt+=cnt;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pos-1;\n\t\t}\n\t}\n\treturn resCnt;\n}\n\n// ºÊ¶ñÌ¶ð¦ÂÂAâèðºÊâèÉªðµÄ¢­\nchar rec(string str,ll idx){\n\tstring res;\n\tll pos=0;\n\twhile(1){\n\t\tll initPos=pos;\n\t\tif(pos>=str.size())\n\t\t\tbreak;\n\t\tif(str[pos]>='0'&&str[pos]<='9'){\n\t\t\tfor(ll i=pos+1; ; i++){\n\t\t\t\tif(!(str[i]>='0'&&str[i]<='9')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll cnt=atoi(str.substr(initPos,pos-initPos).c_str());\n\t\t\tif(str[pos]=='('){\n\t\t\t\tstack<ll> s;\n\t\t\t\ts.push(0);\n\t\t\t\tll start=pos;\n\t\t\t\twhile(1){\n\t\t\t\t\tpos++;\n\t\t\t\t\tif(str[pos]=='(')\n\t\t\t\t\t\ts.push(0);\n\t\t\t\t\telse if(str[pos]==')')\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\tif(s.size()==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// »ÝÌÓÈºÌ¶ð¦A»ÌðpµÄAºÊâèðð­\n\t\t\t\tll subStrCnt=cntSreSize(str.substr(start+1,pos-start-1))*cnt;\n\t\t\t\t// àµidxªeÍÍð´¦Ä¢½ç\n\t\t\t\tif(subStrCnt<=idx){\n\t\t\t\t\tpos++;\n\t\t\t\t\tidx-=subStrCnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// ºÊâèÅßéidxÌÊu\n\t\t\t\tll nidx=idx%(subStrCnt/cnt);\n\t\t\t\tstring subs=str.substr(start+1,pos-start-1);\n\t\t\t\t// ºÊâèðð­\n\t\t\t\tchar an=rec(subs,nidx);\n\t\t\t\tif(an!=0)\n\t\t\t\t\treturn an;\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// »ÝÌÓÈºÌ¶ð¦A»ÌðpµÄAºÊâèðð­\n\t\t\t\tll subStrCnt=cnt;\n\t\t\t\t// àµidxªeÍÍð´¦Ä¢½ç\n\t\t\t\tif(subStrCnt<=idx){\n\t\t\t\t\tpos++;\n\t\t\t\t\tidx-=subStrCnt;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn str[pos];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t// ¶ñÌê\n\t\t\tfor(ll i = initPos; ; i++){\n\t\t\t\tif(i>=str.size()){\n\t\t\t\t\tpos=i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(!(str[i]>='A'&&str[i]<='Z')){\n\t\t\t\t\tpos=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring ss=str.substr(initPos,pos);\n\t\t\tll subStrCnt=ss.size();\n\t\t\t// àµidxªeÍÍð´¦Ä¢½ç\n\t\t\tif(subStrCnt<=idx){\n\t\t\t\tpos++;\n\t\t\t\tidx-=subStrCnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn ss[idx];\n\t\t\t//return ss;\n\t\t}\n\t}\n\treturn 0;\n}\n\t\nint main(){\n\n\tstring str;\n\tint idx;\n\twhile(cin>>str>>idx&&!(str==\"0\"&&idx==0)){\n\t\tchar r=rec(str,idx);\n\t\tif(r==0){\n\t\t\tcout<<0<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<r<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nbool out;\nbool output(string s, ll I, ll mult, bool f){\n    if(!f && s.size() * mult < I) return false;\n    out = 1;\n    I %= s.size();\n    cout << s[(I - 1) % s.size()] << endl;\n    return true;\n}\nint main(){\n    while(1){\n        string s;\n        ll I;\n        cin >> s >> I;\n        if(s == \"0\" && !I) break;\n        I++;\n        stack<ll> st;\n        string now = \"\";\n        ll num = 0;\n        ll mult = 1;\n        bool f = 0;\n        for(char c : s){\n            if('0' <= c && c <= '9'){\n                num = num * 10 + (c - '0');\n            }else if(c == '('){\n                st.push(num);\n                mult *= num;\n                num = 0;\n                if(mult >= I){\n                    mult = 1;\n                    f = 1;\n                }\n            }else if('A' <= c && c <= 'Z'){\n                if(num != 0){\n                    I -= num;\n                    if(I <= 0 || f){\n                        out = 1;\n                        cout << c << endl;\n                        break;\n                    }\n                }\n                for(ll i = 0; i < max<ll>(1, num); i++) now += c;\n                num = 0;\n            }else if(c == ')'){\n                ll tmp = st.top();\n                st.pop();\n                if(output(now, I, mult, f)){\n                    break;\n                }else{\n                    I -= now.size() * mult;\n                    now = \"\";\n                }\n                mult /= tmp;\n            }\n        }\n        if(!out){\n            if(I < now.size()) cout << s[I - 1] << endl;\n            else cout << 0 << endl;\n        }\n        out = 0;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nclass Solver {\n  public:\n    string get_foo(const string &S, int &pos, function<int(int)> isfoo) {\n        int len = 0;\n        for(; isfoo(S[pos + len]); len++);\n        string ret = S.substr(pos, len);\n        pos += ret.size();\n        return move(ret);\n    }\n    string calc(const string &S, int &pos, int N) {\n        bool paren = S[pos] == '(';\n        if(S[pos] == '(') pos++;\n        string res = \"\";        \n        do {\n            if(isdigit(S[pos])) {\n                int rec = stoi(get_foo(S, pos, [](int a) { return isdigit(a); }));\n                int need = N - res.size();\n                string ss = calc(S, pos, need);\n                if(rec * ss.size() > need) rec = need / ss.size() + 1;\n                rep(i, rec) res.append(ss);\n            } else if(isalpha(S[pos])) {\n                res.append(get_foo(S, pos, [](int a) { return isalpha(a); }));\n            } else assert(0);\n        } while(paren and S[pos] != ')');\n        if(paren) pos++;\n        return move(res);\n    }\n    \n    bool solve() {\n        string S; cin >> S;\n        if(S == \"0\") return false;\n        int N; cin >> N;\n        int pos = 0;\n        string s = \"\";\n\n        while(pos < S.size() and s.size() <= N) {\n            s += calc(S, pos, N - s.size() + 1);\n        }\n        cout << (s.size() <= N ? \"0\" : s.substr(N, 1)) << endl;        \n        return true;\n    }\n    \n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        Solver s;\n        if(not s.solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring s;\nint i;\nint idx;\nchar ans;\n\nint getNum()\n{\n  string ret = \"\";\n  while(idx < s.size() && isdigit(s[idx])) ret += s[idx++];\n  return stoi(ret);\n}\n\n// ()????????????/?????¨?????????\nint solve(int len)\n{\n  int ret = 0;\n  if(idx == s.size()) return 0;\n  if(s[idx] == ')') return 0;\n  if(s[idx] == '(') {\n    idx++; // skip '('\n    ret = solve(len);\n    if(ret == -1) return -1;\n    idx++; // skip ')'\n    return ret;\n  } else if(isalpha(s[idx])) {\n    if(len == i) {\n      ans = s[idx];\n      return -1;\n    }\n    idx++;\n    ret = solve(len+1);\n    if(ret == -1) return -1;\n    return ret + 1;\n  } else {\n    int k = getNum(), l = 1;\n    int re = idx;\n    if(isalpha(s[idx])) idx++;\n    else if(s[idx] == '(') {\n      l = solve(len);\n      if(l == -1) return -1;\n    }\n    if(i < len + k*l) { // ??¶????????????\n      idx = re;\n      i = (i - len) % l;\n      return solve(0); // -1\n    }\n    ret = solve(len + k*l);\n    if(ret == -1) return -1;\n    return ret + k*l;\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> s >> i, s != \"0\") {\n    idx = 0;\n    ans = '0';\n    solve(0);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nchar c[1000000];\n\nstring rec(string s, int v) {\n    int i = 0, tmp = 1;\n    string original = \"\";\n    while(i < s.length() && original.length() < v) {\n        if ('0' <= s[i] && s[i] <= '9') {\n            tmp = 0;\n            while(i < s.length() && '0' <= s[i] && s[i] <= '9') {\n                tmp = tmp * 10 + (s[i] - '0');\n                i++;\n            }\n            i--;\n        } else if (s[i] == '(') {\n            int flag = 1, j = i + 1;\n            while(j < s.length() && flag > 0) {\n                if (s[j] == '(') flag++;\n                else if (s[j] == ')') flag--;\n                j++;\n            }\n            j--;\n            string sub = rec(s.substr(i + 1, j - i - 1), v);\n            rep(j, tmp) {\n                if (original.length() + sub.length() < v) {\n                    original += sub;\n                } else {\n                    original += sub.substr(0, v - original.length());\n                    break;\n                }\n            }\n            tmp = 1;\n            i = j;\n        } else if ('A' <= s[i] && s[i] <= 'Z') {\n            rep(j, tmp) {\n                if (original.length() >= v) break;\n                original += s[i];\n            }\n            tmp = 1;\n        }\n        i++;\n    }\n    return original;\n}\n\n\nint main(){\n    cin.sync_with_stdio(false);\n    string s;\n    int i;\n    while(cin >> s >> i, s[0] != '0') {\n     string ans = rec(s, i + 1);\n     if (ans.length() - 1 < i) cout << 0 << endl;\n     else cout << ans[i] << endl;\n }\n\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n\n#define MAX_LEN 1000002\n\nusing namespace std;\n\ntypedef pair<string,int> parsed;\nparsed parse(const string &expr, int i)\n{\n  parsed ret;\n  string s;\n\n  int d=1;\n  if( isdigit( expr[i] ) ){\n    d=0;\n    while( isdigit( expr[i] ) ){\n      int t = expr[i++]-'0';\n      d*=10;\n      d+=t;\n    }\n  }\n\n  if( expr[i] == '(' ){\n    ++i;\n    while(expr[i]!=')'){\n      parsed p = parse(expr,i);\n      s += p.first;\n      i = p.second;\n    }\n    ++i;\n  }else{\n    while( isalpha( expr[i] ) ){\n      s+=expr[i++];\n    }\n  }\n\n  for(int j = 0; j < d; ++j){\n    ret.first+=s;\n    if( ret.first.length() > MAX_LEN )\n      break;\n  }\n\n  ret.second = i;\n  return ret;\n}\n\nchar solve(const string &expr, int n)\n{\n  parsed ans;\n\n  while(ans.second<expr.size()){\n    parsed p = parse(expr,ans.second);\n    ans.first += p.first;\n    if(ans.first.length()>MAX_LEN)break;\n    ans.second = p.second;\n  }\n  if(ans.first.length()<500)\n    cout<<\"RESULT:\"<<ans.first<<endl;\n\n  if(n<0||n>=ans.first.length())\n    return '0';\n  else\n    return ans.first[n];\n\n}\n\nint main()\n{\n  while(true){\n    string expr;\n    int n;\n    cin>>expr>>n;\n    if(expr==\"0\"&&n==0)\n      break;\n    cout << solve(expr,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\npair<char,int> fn(string s,int p){\n  int i,j,k,l;\n  int ln=s.length();\n  for(i=0;i<ln;){\n    if('A'<=s[i]&&s[i]<='Z'){\n      if(p){\n\tp--;\n\ti++;\n      }else{\n\treturn make_pair(s[i],0);\n      }\n    }else{\n      for(j=i;'0'<=s[j]&&s[j]<='9';j++);\n      if(s[j]=='('){\n\tl=1;\n\tfor(k=j+1;l;k++){\n\t  if(0){\n\t  }else if(s[k]=='('){\n\t    l++;\n\t  }else if(s[k]==')'){\n\t    l--;\n\t  }\n\t}\n\tstring t=s.substr(j+1,k-j-2);\n\tl=atoi(s.substr(i,j-i).c_str());\n\ti=k;\n\tfor(k=0;k<l;k++){\n\t  pair<char,int> r=fn(t,p);\n\t  if(r.first!='\\0')\n\t    return make_pair(r.first,0);\n\t  p=r.second;\n\t}\n      }else{\n\tif(p<atoi(s.substr(i,j-i).c_str())){\n\t  return make_pair(s[j],0);\n\t}else{\n\t  p-=atoi(s.substr(i,j-i).c_str());\n\t  i=j+1;\n\t}\n      }\n    }\n  }\n  return make_pair('\\0',p);\n}\nint main(){\n  int p;\n  string s;\n  while(cin>>s>>p&&(s!=\"0\"||p!=0)){\n    pair<char,int> r=fn(s,p);\n    cout<<(r.first=='\\0'?'0':r.first)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring in;\nint n, idx;\n\nint parse(int sum){\n    // cerr << \">>>> \" << sum << \", \" << in.substr(idx) << endl;\n    char cur = in[idx];\n    if(isdigit(cur)){\n        int mul = 0;\n        while(isdigit(in[idx])){\n            mul = 10 * mul + (int)(in[idx] - '0');\n            idx++;\n        }\n        \n        if(isupper(in[idx])){\n            if(sum + mul >= n){\n                throw in[idx];\n            }\n            idx++;\n            return mul * 1;\n        }\n\n        idx++; // read '('\n        int head = idx;\n        int len = 0;\n        while(in[idx] != ')'){\n            len += parse(sum + len);\n        }\n        idx++;\n        if(sum + mul * len >= n){\n            n = (n - sum) % len;\n            if(n == 0) n = len;\n\n            idx = head;\n            len = 0;\n            while(in[idx] != ')'){\n                len += parse(sum + len);\n            }\n        }\n        return mul * len;\n    }\n    else if(isupper(cur)){\n        int len = 0;\n        while(isupper(in[idx])){\n            len++;\n            if(sum + len == n){\n                throw in[idx];\n            }\n            idx++;\n        }\n        return len;\n    }\n}\n\nsigned main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(; cin >> in >> n, in != \"0\";){\n        n++;\n        in = \"1(\" + in + \")\";\n        idx = 0;\n        char res = '0';\n\n        try { parse(0); }\n        catch(char c) { res = c; }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (s[i] == ')') { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n        return;\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1000000) { num = 1000000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        curr->children.push_back(c);\n        c->num = ck;\n        dfs(s, c);\n        consume(s, ')');\n      }\n    }\n    else {\n      auto c = make_shared<tree>();\n      c->s = read_s(s);\n      c->num = 1;\n      curr->children.push_back(c);\n      if(!s.empty() && !isdigit(s[0])) { return; }\n    }\n  }\n}\n\nstring ans;\n\nvoid visit(tree_ptr curr) {\n  if(ans.size() >= 1000001) { return; }\n  rep(i, curr->num) {\n    if (curr->children.empty()) {\n      ans += curr->s;\n      if(ans.size() >= 1000001) { return; }\n    }\n\n    rep(i, curr->children.size()) {\n      visit(curr->children[i]);\n    }\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  ans.clear();\n  visit(root);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans << endl;cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int mod = 1e9 + 7;\n\nstring expr(string& s,int& i);\nstring term(string& s,int& i);\nstring str(string& s,int& i);\nint number(string& s,int& i);\n\nint main()\n{\n    string s;\n    int k;\n    while(cin>>s>>k){\n        if(s==\"0\")return 0;\n        int i=0;\n        string text=expr(s,i);\n        if(text.length()<=k)cout<<0<<endl;\n        else cout<<text[k]<<endl;\n    }\n}\n\nstring expr(string& s,int& i){\n    string val=\"\";\n    while(1){\n        string t=term(s,i);\n        if(t==\"\")break;\n        if(val.length()>=1000001)break;\n        val+=t;\n    }\n    return val;\n}\n\nstring term(string& s,int& i){\n    string val=\"\";\n    if(isdigit(s[i])){\n        int n=number(s,i);\n        string so=\"\";\n        if(s[i]=='('){\n            i++;\n            so=expr(s,i);\n            i++;\n        }else{\n            so=s[i];\n            i++;\n        }\n        for(int i=0;i<n;++i){\n            if(val.length()>=1000001)break;\n            val+=so;\n        }\n    }else{\n        val=str(s,i);\n    }\n    return val;\n}\n\nstring str(string& s, int& i) {\n  string val=\"\";\n  while(s[i]>='A'&&s[i]<='Z')val+=s[i++];\n  return val;\n}\n\nint number(string& s, int& i) {\n  int n = s[i++] - '0';\n  while(isdigit(s[i])) n = n*10 + s[i++] - '0';\n  return n;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        auto c = make_shared<tree>();\n        c->num = ck;\n        curr->children.push_back(c);\n        while(s[0] != ')') {\n          dfs(s, c);\n        }\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring str;\nstring ans;\nint N;\n\nint cal(string s) {\n    if (s == \"\") return 1;\n    stringstream ss;\n    ss << s;\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nstring make_str(string s, int left) {\n    if (s.size() == 1) return s;\n\n    string ret;\n    string ch;\n    string num;\n    for (int i = 0, len = s.size(), count = 0; i < len; i++) {\n        if (!count && '0' <= s[i] && s[i] <= '9') num += s[i];\n        else {\n            ch += s[i];\n            if (s[i] == '(') count++;\n            if (s[i] == ')') count--;\n            if (count == 0) {\n                if(ch.size() > 0 && ch[0] == '(') {\n                    ch.erase(ch.begin());\n                    ch.erase(ch.end()-1);\n                }\n\n                string tmp = make_str(ch, left + ret.size());\n                for (int j = 0, len = cal(num); j < len; j++) {\n                    if (ret.size() + left > N + 1) break;\n                    ret += tmp;\n                }\n                ch = \"\";\n                num = \"\";\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid calc_char(int c, string s, int sum) {\n    string ans_str = make_str(s, N - sum);\n    string ans_;\n    for (int i = 0; i < c; i++) {\n        ans_ += ans_str;\n        if (ans_.size() > sum + 1) break;\n    }\n    ans = ans_[sum];\n}\n\nint dfs(string s, int left) {\n    if (s.size() == 1) return 1;\n    int sum = 0;\n\n    string num;\n    string ch;\n    for (int i = 0, len = s.size(), count = 0; i < len; i++) {\n        if (!count && '0' <= s[i] && s[i] <= '9') num += s[i];\n        else {\n            ch += s[i];\n            if (s[i] == '(') count++;\n            if (s[i] == ')') count--;\n            if (count == 0) {\n                int c = cal(num);\n                if(ch.size() > 0 && ch[0] == '(') {\n                    ch.erase(ch.begin());\n                    ch.erase(ch.end()-1);\n                }\n\n                int tmp = dfs(ch, sum + left);\n                if (tmp < 0) return -1;\n                sum += c * tmp;\n                if (sum + left > N) {\n                    calc_char(c, ch, N - (sum - c * tmp) - left);\n                    return -1;\n                }\n                ch = \"\";\n                num = \"\";\n            }\n        }\n    }\n\n    return sum;\n}\n\nvoid solve() {\n    ans = \"0\";\n\n    if (str.size() > 1)\n        dfs(str, 0);\n    else if (N == 0)\n        ans = str;\n\n    cout << ans << endl;\n}\n\nint main() {\n    while (cin >> str >> N, str != \"0\" || N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\ntypedef pair<char,lli> cip;\n\ntypedef string::iterator sta;\n\nbool isnum(char c){\n\treturn ('0'<=c && c<='9');\n}\n\nlli num(sta& s){\n\tlli res=0;\n\twhile(isnum(*s)){\n\t\tres*=10; res+=(*s-'0');\n\t\ts++;\n\t}\n\treturn res;\n}\n\ncip exprs(sta& s,lli p);\n\n#include<cassert>\n\ncip expr(sta& s,lli p){\n\t//printf(\"%c %lld\\n\",*s,p);\n\tcip res;\n\tif(isnum(*s)){\n\t\tlli a=num(s);\n\t\tif(*s=='('){\n\t\t\ts++; \n\t\t\tsta ns=s;\n\t\t\tcip pa=exprs(s,p);\n\t\t\tif(pa.fir!='0')res=pa;\n\t\t\telse{\n\t\t\t\tif(pa.sec*a>p){\n\t\t\t\t\tres=exprs(ns,p % pa.sec);\n\t\t\t\t}\n\t\t\t\telse res=cip('0',pa.sec*a);\n\t\t\t}\n\t\t\tassert(*s==')'); s++;\n\t\t}\n\t\telse{\n\t\t\tif(a>p)res=cip(*s,0);\n\t\t\telse res=cip('0',a);\n\t\t\ts++;\n\t\t}\n\t}\n\telse{\n\t\tif(p==0)res=cip(*s,0);\n\t\telse res=cip('0',1);\n\t\ts++;\n\t}\n\treturn res;\n}\n\ncip exprs(sta& s,lli p){\n\tcip res('0',0);\n\tlli nl=0;\n\tfor(;;){\n\t\tif(*s==')' || *s=='$')break;\n\t\tcip a=expr(s,p);\n\t\t//printf(\"expr %c %d\\n\",a.fir,a.sec);\n\t\tif(a.fir!='0')return a;\n\t\tp-=a.sec;\n\t\tnl+=a.sec;\n\t}\n\tres.sec=nl;\n\treturn res;\n}\n\nint n;\nstring s;\n\nint main(void){\n\tfor(;;){\n\t\tcin >> s >> n;\n\t\tif(n==0 && s[0]=='0' && s[1]=='\\0')break;\n\t\ts += \"$\";\n\t\tsta ss=s.begin();\n\t\tcip pa=exprs(ss,n);\n\t\tprintf(\"%c\\n\",pa.fir);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <vector>\n#include <ctype.h>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const long long BASE = 1000000;\nstatic const int  BW = 6;\nstatic const int MAXDIGIT = 20;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nstruct Node {\n  ll length;\n  ll size;\n  ll loop;\n  char c;\n  vector<Node> child;\n  Node() : length(0), size(0), loop(1), c(0) {;}\n};\n\nchar str[1000];\n\nNode parse(ll &index) {\n  ll loop = 1;\n  Node ret;\n  if (isalpha(str[index])) {\n    ret.length = 1;\n    ret.c = str[index];\n    index++;\n  } else if (isdigit(str[index])) {\n    loop = atoi(str + index);\n    while (isdigit(str[index])) { index++; }\n    if (isalpha(str[index])) {\n      ret.child.push_back(parse(index));\n      ret.length += ret.child[ret.child.size() - 1].size;\n    } else {\n      assert(str[index] == '(');\n      index++;\n      while (str[index] != ')') {\n        ret.child.push_back(parse(index));\n        ret.length += ret.child[ret.child.size() - 1].size;\n      }\n      assert(str[index] == ')');\n      index++;\n    }\n  }\n  ret.size = ret.length * loop;\n  ret.size = min(ret.size, 1000000000LL);\n  ret.length = min(ret.length, 1000000000LL);\n  ret.loop = loop;\n  return ret;\n}\n\nchar nodechar(const Node &node, ll &n) {\n  if (node.size <= n) { return '0'; }\n  n %= node.length;\n  if (n == 0 && node.c != 0) { return node.c; }\n  REP(i, node.child.size()) {\n    const Node &target = node.child[i];\n    if (target.size > n) {\n      return nodechar(target, n);\n    }\n    n -= target.size;\n  }\n  assert(false);\n  return 0;\n}\n\nint main() {\n  ll n;\n  while (scanf(\"%s %lld\", str, &n), str[0] != '0' || n) {\n    ll index = 0;\n    Node root;\n    while (str[index] != '\\0') {\n      root.child.push_back(parse(index));\n      root.size += root.child[root.child.size() - 1].size;\n      root.length += root.size;\n    }\n    printf(\"%c\\n\", nodechar(root, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nconstexpr int MOD = 1e9 + 7;\ntypedef string::const_iterator State;\nint MAX = 1000001;\nint R;\nint number(State &begin);\nstring factor(State &begin);\nbool fin = false;\nvoid consume(State &begin, char expected) {\n    if (fin) begin++;\n    if (*begin == expected)\n        begin++;\n    else {\n        begin++;\n        // cerr << \"expected \" << expected << \" but got \" << *begin << endl;\n        // cerr << \"rest string is \";\n        // while (*begin) {\n        //     cerr << *begin++;\n        // }\n        // cerr << endl;\n    }\n}\nstring expression(State &begin) {\n    if (fin) return \"\";\n    string ret = factor(begin);\n    for (;;) {\n        if (ret.size() > R) {\n            fin = true;\n            return ret;\n        }\n        if (isdigit(*begin))\n            ret += expression(begin);\n        else if (isupper(*begin))\n            ret += expression(begin);\n        else if (*begin == '(')\n            ret += expression(begin);\n        else\n            break;\n    }\n    return ret;\n}\nstring factor(State &begin) {\n    string ret;\n    if (fin) return ret;\n    int cnt = 1;\n    if (*begin == '(') {\n        consume(begin, '(');\n        ret = expression(begin);\n        consume(begin, ')');\n        return ret;\n    } else if (isdigit(*begin)) {\n        cnt = number(begin);\n        // begin++;\n        // cerr << cnt << endl;\n        string res = factor(begin);\n        // begin++;\n        REP(_, cnt) {\n            ret += res;\n            if (ret.size() > R) {\n                fin = true;\n                return ret;\n            }\n        }\n        // ret += factor(begin);\n        // cerr << ret << endl;\n        return ret;\n    } else if (isupper(*begin)) {\n        while (isupper(*begin)) {\n            ret += *begin;\n            begin++;\n        }\n        // ret += factor(begin);\n        return ret;\n    } else\n        return ret;\n}\nint number(State &begin) {\n    int ret = 0;\n    if (fin) return ret;\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n    // cerr << ret << endl;\n    return ret;\n}\n\nbool solve() {\n    string S;\n    fin = false;\n    int r;\n    cin >> S;\n    if (S == \"0\") return false;\n    cin >> r;\n    R = r;\n    // cerr << S << endl;\n    State begin = S.begin();\n    string res = expression(begin);\n    // cerr << res << endl;\n    if (r >= res.size())\n        cout << '0' << endl;\n    else\n        cout << res[r] << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nstring s;\nstring buf;\nint p;\nint q;\n\nint nextint() {\n    string t;\n    while (isdigit(s[p])) {\n        t.push_back(s[p]);\n        p++;\n    }\n    return atoi(t.c_str());\n}\n\nvoid solve() {\n    if (p == s.size()) return;\n    if (buf.size() > q) return;\n    if (isupper(s[p])) {\n        buf.push_back(s[p]);\n        p++;\n        solve();\n    }\n    if (isdigit(s[p])) {\n        int n = nextint();\n        //cout << \"n: \" << n << endl;\n        //cout << s[p] << endl;\n        if (s[p] == '(') p++;\n        int o = p;\n        for (int i = 0; i < n-1; i++) {\n            solve();\n            p = o;\n            if (buf.size() > q) return;\n        }\n        solve();\n        if (s[p] == ')') p++;\n        solve();\n    }\n}\n\nint main() {\n    while (cin >> s >> q) {\n        if (s == \"0\" && q == 0) break;\n        p = 0;\n        buf = \"\";\n        solve();\n        //cout << buf << ' ';\n        cout << (buf.size() > q ? buf[q] : '0') << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\nusing namespace std;\n\nclass Parsing\n{\nprivate:\n  string parse;\n  int pos;\n  int size;\n  int x;\npublic:\n\n  Parsing(string parse = \"\",int x = 0):parse(parse),pos(0),x(x),size(0){}\n\n  int StringToInt(string v)\n  {\n    int ret = 0;\n    for(int i=0;i<v.size();i++)\n      ret += (v[i]-'0')*(int)pow(10.0,v.size()-i-1);\n    return ret;\n  }\n\n  string getCnt()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    string v;\n    while('0' <= parse[pos] && parse[pos] <= '9') \n      v += parse[pos++];\n    return v;  \n  }\n\n  int getCntInt()\n  {\n    return StringToInt(getCnt());\n  }\n\n  string decode()\n  {\n    assert('0' <= parse[pos] && parse[pos] <= '9');\n    int power = getCntInt();\n    if(parse[pos] == '(')\n      pos++;\n    string message;\n    while(('0' <= parse[pos] && parse[pos] <= '9') || ('A' <= parse[pos] && parse[pos] <= 'Z') )\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  message += decode();\n\telse if('A' <= parse[pos] && parse[pos] <= 'Z')\n\t  message += parse[pos++];\n      }  \n    \n    if(parse[pos] == ')')\n      pos++;\n    \n    string ret;\n    for(int i=0;i<power;i++)\n      {\n\tret += message,size += message.size();\n\tif(ret.size() >= x)\n\t  break;\n      }\n    return ret;\n  }\n\n  string exp()\n  {\n    string ret;\n    for(;pos<parse.size();)\n      {\n\tif('0' <= parse[pos] && parse[pos] <= '9')\n\t  ret += decode();\n\telse\n\t  ret += parse[pos++],size++;\n\tif(ret.size() >= x)\n\t  break;\n\t//cout << \"ret = \" << ret << endl;\n      }\n    return ret;\n  }\n\n  int getSize()\n  {\n    return size;\n  }\n\n};\n\nint main()\n{\n  string Genome;  \n  int pos;\n  while(cin >> Genome >> pos, Genome != \"0\" || pos != 0)\n    {\n      Parsing par = Parsing(Genome,pos+1);\n      string message = par.exp();\n      //cout << \"message = \" << message.substr(0,10) << endl;\n      if(message.size() <= pos)\n\tcout << 0 << endl;\n      else\n\tcout << message[pos] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <ctype.h>\nusing namespace std;\nstring S;\nint pos;\nint I;\n\ntypedef struct List {\n  int d;\n  string s;\n  List *l; //loop\n  List *n; //next\n} List;\nList *l;\n\n\nbool isalpha(char ch) {\n  return ('A' <= ch && ch <= 'Z');\n}\n\nvoid makeList(List *l) {\n  char ch = S[pos++];\n  //printf(\"CH:%c pos:%d\\n\",ch,pos-1);\n  if(ch=='\\0') {\n    l->n=l->l = NULL;\n  }\n  if(isdigit(ch)) {\n    int d = ch - '0';\n    while(isdigit(S[pos])) d = d*10 + S[pos++] - '0';\n    l->d=d;\n    //cout << d << endl;\n    makeList(l);\n  } else if(isalpha(ch)) {\n    string s=\"\";\n    s+=ch;\n    while(isalpha(S[pos])) s += S[pos++];\n    l->s=s;\n    //cout << s << endl;\n    if(s.length()==1) {\n      l->n = new List();\n      l->n->l=l->n->n=NULL;\n      makeList(l->n);\n    } else {\n      makeList(l);\n    }\n  } else if(ch=='(') {\n    if(isalpha(S[pos])) {\n      makeList(l);\n    } else {\n      l->l = new List();\n      l->l->l=l->l->n=NULL;\n      makeList(l->l);\n    }\n    pos--; // ?\n    if(S[pos++]!=')') { printf(\"%c what?\\n\",S[pos]); exit(1); }\n    if(S[pos] == ')') {\n      l->n = NULL;\n      makeList(l);\n    } else {\n      l->n = new List();\n      l->n->l=l->n->n=NULL;\n      makeList(l->n);\n    }\n  }\n}\n\nint d; bool flag;\nvoid solve(List *l) {\n  if(flag) return;\n  if(l->s==\"\") {\n    //printf(\"l->sNULL\\n\");\n    while((l->d)--) {\n      solve(l->l);\n    }\n    //printf(\"lNull l->n\\n\");\n    solve(l->n);\n  } else {\n    int Ssize = (l->s).size();\n    if(d-Ssize*(l->d)-1 <= 0) {\n      if(!flag && d <= Ssize*(l->d)-1) {\n\tcout << (l->s[d%((l->s).size())]) << endl;\n\tflag=true;\n\treturn;\n      }\n    }\n    d= d - Ssize*(l->d);\n    //cout << d<<\": \"<<l->s << \"l->d:\"<<l->d << endl;\n\n    if((l->n)!=NULL)\n      solve(l->n);\n  }\n}\n\n\nmain() {\n  while(cin>>S>>I,S!=\"0\") {\n    pos=0;\n    l = new List();\n    l->n=l->l=NULL; l->d=1;\n    makeList(l);\n    d=I; flag=false; solve(l); if(!flag) cout << '0' << endl;\n    delete(l);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\nchar input[1111];\nint ans;\nint value=0;\ntypedef pair<int,const char*> Parsed;\nParsed term(const char *c);\nParsed fact(const char *c);\nParsed expr(const char *c);\nParsed term(const char *c){\n\tParsed r=fact(c);\n\twhile(*r.second!=')'&&*r.second!=0){\n\t\tif(r.first)return r;\n\t\tr=fact(r.second);\n\t}\n\treturn r;\n}\nParsed fact(const char *c){\n\tif(isdigit(*c)){\n\t\tint v=0;\n\t\twhile(isdigit(*c)){\n\t\t\tv=v*10+*(c++)-'0';\n\t\t}\n\t\tParsed r;\n\t\tfor(int i=0;i<v;i++){\n\t\t\tr=expr(c);\n\t\t\tif(r.first)return r;\n\t\t}\n\t\treturn r;\n\t}else{\n\t\treturn expr(c);\n\t}\n}\nParsed expr(const char *c){\n\tif(*c=='('){\n\t\tParsed r=term(c+1);\n\t\tif(*r.second!=')'){\n\t\t\tcerr<<\"Error!!\"<<endl;\n\t\t}\n\t\treturn Parsed(r.first,r.second+1);\n\t}else{\n\t\tint res=0;\n\t\tvalue--;\n\t\tif(value<0){\n\t\t\tres=*c;\n\t\t}\n\t\treturn Parsed(res,c+1);\n\t}\n}\nint main() {\n\twhile(scanf(\"%s%d\",input,&value)){\n\t\tif(input[0]=='0')break;\n\t\tParsed a=term(input);\n\t\tif((int)a.first){\n\t\t\tprintf(\"%c\\n\",(char)a.first);\n\t\t}else{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define ALL(c) c.begin(), c.end()\n#define SZ(c) ((int)c.size())\n#define REP(i, n) for (int i = 0, loop_num_##i = n; i < loop_num_##i; i++)\n\nstruct State {\n\tint idx;\n\tstring s;\n\n\tchar get_char() {\n\t\tif (idx >= SZ(s)) return '\\n';\n\t\treturn s[idx];\n\t}\n\tbool is_digit() {\n\t\treturn '0' <= get_char() && get_char() <= '9';\n\t}\n\tbool is_end() {\n\t\treturn idx == SZ(s);\n\t}\n\tvoid next(int n = 1) {\n\t\tidx += n;\n\t}\n};\n\nstruct Node {\n\tvector<pair<Node*, int>> data;\n\tstring immediate;\n\tint width;\n\tNode() : data(), immediate(\"\"), width(0) {}\n};\n\nint parse_num(State &s) {\n\tstring ret = \"\";\n\twhile (s.is_digit()) {\n\t\tret += s.get_char();\n\t\ts.next();\n\t}\n\treturn stoll(ret);\n}\n\nNode *parse(State &s) {\n\tNode *ret = new Node();\n\twhile (!s.is_end()) {\n\t\tif (s.is_digit()) {\n\t\t\tint repeat = parse_num(s);\n\t\t\t//cerr << \"rep: \" << repeat << endl;\n\t\t\tif (s.get_char() == '(') {\n\t\t\t\ts.next(); // skip '('\n\t\t\t\tNode *tmp = parse(s);\n\t\t\t\tret->data.emplace_back(tmp, repeat);\n\t\t\t\tret->width += tmp->width * repeat;\n\t\t\t\tif (ret->width > 1e8) ret->width = 1e9;\n\t\t\t\ts.next(); // skip ')'\n\t\t\t} else {\n\t\t\t\tNode *tmp = new Node();\n\t\t\t\ttmp->immediate = string(\"\") + s.get_char();\n\t\t\t\ttmp->width = 1;\n\t\t\t\tret->data.emplace_back(tmp, repeat);\n\t\t\t\tret->width += 1 * repeat;\n\t\t\t\tif (ret->width > 1e8) ret->width = 1e9;\n\t\t\t\t//cerr << \"immediate(1): \" << tmp->immediate << endl;\n\t\t\t\ts.next();\n\t\t\t}\n\t\t} else {\n\t\t\tif (s.get_char() == ')') return ret;\n\t\t\tstring genom;\n\t\t\twhile (!s.is_end() && !s.is_digit() && s.get_char() != ')') {\n\t\t\t\tgenom += s.get_char();\n\t\t\t\ts.next();\n\t\t\t}\n\t\t\t//cerr << \"immediate: \" << genom << endl;\n\t\t\tNode *tmp = new Node();\n\t\t\ttmp->immediate = genom;\n\t\t\ttmp->width = SZ(genom);\n\t\t\tret->data.emplace_back(tmp, 1);\n\t\t\tret->width += SZ(genom);\n\t\t\tif (ret->width > 1e8) ret->width = 1e9;\n\t\t}\n\t}\n\treturn ret;\n}\n\nchar solve(Node *node, int idx) {\n\tif (SZ(node->data) == 0) {\n\t\tif (SZ(node->immediate) <= idx) return '#';\n\t\treturn node->immediate[idx];\n\t}\n\tint size = 0;\n\tfor (int i = 0; i < SZ(node->data); i++) {\n\t\tint len = node->data[i].first->width * node->data[i].second;\n\t\tif (idx < size + len) {\n\t\t\treturn solve(node->data[i].first, (idx - size) % (node->data[i].first->width));\n\t\t} else {\n\t\t\tsize += len;\n\t\t\t//cerr << \"size: \" << size << endl;\n\t\t}\n\t}\n\treturn '0';\n}\n\nsigned main() {\n\twhile (1) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint idx;\n\t\tcin >> idx;\n\t\tif (s == \"0\" && idx == 0) break;\n\t\tState st {0, s};\n\t\tNode *root = parse(st);\n\t\tchar ans = solve(root, idx);\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <utility>\n#include <queue>\n#include <string>\n#include <vector>\n#define llint long long\n#define lim 1000000000LL\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct node{\n\tllint val;\n\tstring s;\n\tllint num;\n\tvector<llint> vec;\n\tnode(){}\n\tnode(llint a){\n\t\tval = a;\n\t}\n\tnode(string t){\n\t\ts = t;\n\t\tval = -1;\n\t}\n};\n\nstring s;\nint k;\nvector<node> tree;\n\nllint parseNum(int &p)\n{\n\tllint ret = 0;\n\twhile(s[p] >= '0' && s[p] <= '9'){\n\t\tret *= 10;\n\t\tret += s[p] - '0';\n\t\tp++;\n\t}\n\treturn ret;\n}\n\nstring parseString(int &p)\n{\n\tstring ret;\n\twhile(s[p] >= 'A' && s[p] <= 'Z'){\n\t\tret += s[p];\n\t\tp++;\n\t}\n\treturn ret;\n}\n\nvoid parseSeq(int &p, int root)\n{\n\twhile(1){\n\t\tif(s[p] >= '0' && s[p] <= '9'){\n\t\t\tllint mul = parseNum(p);\n\t\t\ttree.push_back(node(mul));\n\t\t\ttree[root].vec.push_back(tree.size()-1);\n\t\t\tif(s[p] == '('){\n\t\t\t\tp++;\n\t\t\t\tparseSeq(p, tree.size()-1);\n\t\t\t\tp++;\n\t\t\t}else{\n\t\t\t\tint r = tree.size()-1;\n\t\t\t\tstring t;\n\t\t\t\tt += s[p];\n\t\t\t\ttree.push_back(node(t));\n\t\t\t\ttree[r].vec.push_back(tree.size()-1);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\telse if(s[p] >= 'A' && s[p] <= 'Z'){\n\t\t\tstring t = parseString(p);\n\t\t\ttree.push_back(node(t));\n\t\t\ttree[root].vec.push_back(tree.size()-1);\n\t\t}else break;\n\t}\n}\n\nllint dfs(llint v)\n{\n\tif(tree[v].val == -1){\n\t\ttree[v].num = tree[v].s.size();\n\t\treturn tree[v].s.size();\n\t}\n\tllint cnt = 0;\n\tfor(int i = 0; i < tree[v].vec.size(); i++){\n\t\tint u = tree[v].vec[i];\n\t\tcnt += dfs(u);\n\t\tcnt = min(cnt, lim);\n\t}\n\ttree[v].num = cnt * tree[v].val;\n\ttree[v].num = min(tree[v].num, lim);\n\treturn tree[v].num;\n}\nchar dfs2(llint v, llint k)\n{\n\tif(tree[v].val == -1) return tree[v].s[k];\n\t\n\tllint pos;\n\tif(tree[v].num >= lim) pos = k;\n\telse pos = k % (tree[v].num/tree[v].val);\n\t\n\tllint cnt = 0;\n\tfor(int i = 0; i < tree[v].vec.size(); i++){\n\t\tint u = tree[v].vec[i];\n\t\tif(cnt + tree[u].num > pos) return dfs2(u, pos - cnt);\n\t\tcnt += tree[u].num;\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> s >> k;\n\t\tif(s == \"0\" && k == 0) break;\n\t\ts += \"#\";\n\t\t\n\t\ttree.clear();\n\t\ttree.push_back(node(1));\n\t\t\n\t\tint p = 0;\n\t\tparseSeq(p, 0);\n\t\t\n\t\tllint res = dfs(0);\n\t\tif(res <= k){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << dfs2(0, k) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <cctype>\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s; int n, p[200], v[200], w[200];\nint main() {\n\twhile (cin >> s >> n, s != \"0\") {\n\t\tstring t = string({ s[0] });\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (isdigit(s[i - 1]) && isalpha(s[i])) t += \"(\" + string({ s[i] }) + \")\";\n\t\t\telse t += s[i];\n\t\t}\n\t\tint pos1 = 0, w1 = 0; s = \"\";\n\t\tfor (int i = 0; i < t.size(); i++) {\n\t\t\tif (isdigit(t[i])) w1 = 10 * w1 + t[i] - 48;\n\t\t\telse {\n\t\t\t\tif (t[i] == '(') v[pos1] = w[pos1] = w1, w1 = 0;\n\t\t\t\ts += t[i]; pos1++;\n\t\t\t}\n\t\t}\n\t\tstack<int> st;\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (s[i] == '(') st.push(i);\n\t\t\tif (s[i] == ')') p[i] = st.top(), p[st.top()] = i, st.pop();\n\t\t}\n\t\tint pos = 0;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (pos == s.size()) {\n\t\t\t\tprintf(\"0\\n\"); break;\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (s[pos] == '(') {\n\t\t\t\t\tif (w[pos]) w[pos]--, pos++;\n\t\t\t\t\telse w[pos] = v[pos], pos = p[pos] + 1;\n\t\t\t\t}\n\t\t\t\telse if (s[pos] == ')') pos = p[pos];\n\t\t\t\telse {\n\t\t\t\t\tpos++; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << s[pos - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n\n#define int long long\n\nusing namespace std;\n\nclass Solver {\n};\n\ntuple<string,char> dfs(string s, int remain) {\n\tstring now = \"\";\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif ('0' <= s[i] && s[i] <= '9') {\n\t\t\tint loop = 0;\n\t\t\twhile ('0' <= s[i] && s[i] <= '9') {\n\t\t\t\tloop *= 10;\n\t\t\t\tloop += (s[i] - '0');\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tstring tmp = \"\";\n\t\t\tint nest = 1;\n\t\t\tfor (; i < s.size(); i++) {\n\t\t\t\tif (s[i] == '(')nest++;\n\t\t\t\tif (s[i] == ')') {\n\t\t\t\t\tnest--;\n\t\t\t\t\tif (nest == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp += s[i];\n\t\t\t}\n\n\t\t\ttuple<string, char> tpl = dfs(tmp, remain);\n\t\t\tif (get<1>(tpl) != '0')return make_tuple(now, get<1>(tpl));\n\t\t\ttmp = get<0>(tpl);\n\t\t\tfor (int j = 0; j < loop; j++) {\n\t\t\t\tremain -= tmp.size();\n\t\t\t\tnow += tmp;\n\t\t\t\tif (remain < 0)return make_tuple(now, now[now.size() + remain]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnow += s[i];\n\t\t\tremain--;\n\t\t\tif (remain < 0)return make_tuple(now, now[now.size() + remain]);\n\t\t}\n\t}\n\treturn make_tuple(now, '0');\n}\n\nsigned main() {\n\twhile (true) {\n\t\tstring s;\n\t\tint n;\n\t\tcin >> s >> n;\n\t\tif (s[0] == '0')break;\n\n\t\tstring formated = \"\";\n\t\tfor (int i = 0; i < s.size(); i++) {\n\t\t\tif (i > 0 && 'A' <= s[i] && s[i] <= 'Z'\n\t\t\t\t&& '0' <= s[i - 1] && s[i - 1] <= '9') {\n\t\t\t\tformated += '(';\n\t\t\t\tformated += s[i];\n\t\t\t\tformated += ')';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tformated += s[i];\n\t\t\t}\n\t\t}\n\t\tcout << get<1>(dfs(formated, n)) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nchar buf[1000000];\n\nstruct expr\n{\n  typedef enum { NODE, LEAF } expr_type;\n  expr_type type;\n  int len;\n  vector<expr> cs;\n  string genom;\n};\n\ntypedef string::const_iterator Iterator;\npair<expr,Iterator> parse_one(Iterator it, const Iterator& last)\n{\n  if (it == last) {\n    throw \"eof\";\n  }\n  if ('A' <= *it &&  *it <= 'Z') {\n    string genom;\n    while (it != last && 'A' <= *it &&  *it <= 'Z') {\n      genom += *it;\n      ++it;\n    }\n    expr e;\n    e.type = expr::LEAF;\n    e.len = 1;\n    e.genom = genom;\n    return make_pair(e, it);\n  } else {\n    int len = 0;\n    while (it != last && '0' <= *it && *it <= '9') {\n      len = 10*len + (*it - '0');\n      ++it;\n    }\n    if (*it == '(') {\n      ++it;\n      expr e;\n      e.type = expr::NODE;\n      e.len = len;\n      while (*it != ')') {\n        pair<expr,Iterator> p = parse_one(it, last);\n        e.cs.push_back(p.first);\n        it = p.second;\n      }\n      ++it;\n      return make_pair(e, it);\n    } else {\n      expr e;\n      e.type = expr::LEAF;\n      e.len = len;\n      e.genom = *it;\n      ++it;\n      return make_pair(e, it);\n    }\n  }\n}\n\nexpr parse(Iterator it, const Iterator& last)\n{\n  expr e;\n  e.type = expr::NODE;\n  e.len = 1;\n  while (it != last) {\n    const pair<expr,Iterator> p = parse_one(it, last);\n    e.cs.push_back(p.first);\n    it = p.second;\n  }\n  return e;\n}\n\nstring expand(const expr& e, unsigned idx)\n{\n  if (e.type == expr::NODE) {\n    string t = \"\";\n    for (vector<expr>::const_iterator it(e.cs.begin()); it != e.cs.end(); ++it) {\n      t += expand(*it, idx);\n      if (t.size() > idx) {\n        return t.substr(0, idx+1);\n      }\n    }\n    string g = \"\";\n    g.reserve(min(1000000UL, t.size() * idx));\n    for (int i = 0; i < e.len; i++) {\n      g += t;\n      if (g.size() > idx) {\n        return g.substr(0, idx+1);\n      }\n    }\n    return g.substr(0, idx+1);\n  } else {\n    string g = \"\";\n    g.reserve(min(1000000UL, e.genom.size() * e.len));\n    for (int i = 0; i < e.len; i++) {\n      g += e.genom;\n    }\n    return g.substr(0, idx+1);\n  }\n}\n\nint main()\n{\n  string s;\n  unsigned idx;\n  while (cin >> s >> idx && s != \"0\") {\n    const expr e = parse(s.begin(), s.end());\n    const string t = expand(e, idx);\n    if (idx < t.size()) {\n      cout << t[idx] << endl;\n    } else {\n      cout << \"0\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint number(string &s, int &iter) {\n\tint ret = 0;\n\twhile ('0' <= s[iter] && s[iter] <= '9') {\n\t\tret *= 10;\n\t\tret += s[iter] - '0';\n\t\titer++;\n\t}\n\treturn ret;\n}\n\nint dfs(string &s, int &iter, int pos) {\n\tint len = 0;\n\tint start = iter;\n\t\n\twhile (iter < s.length()) {\n\t\tif ('A' <= s[iter] && s[iter] <= 'Z') {\n\t\t\tif (len == pos) { cout << s[iter] << endl; }\n\t\t\tlen++;\n\t\t\tif (len > 1000010) len = 1000010;\n\t\t\titer++;\n\t\t}\n\t\telse if ('0' <= s[iter] && s[iter] <= '9') {\n\t\t\tint num = number(s, iter);\n\t\t\tif (s[iter] == '(') {\n\t\t\t\titer++;\n\t\t\t\tint tmpIter = iter;\n\t\t\t\tint resLen = dfs(s, iter, -1);\n\t\t\t\tif (len <= pos && pos < len + resLen * num) {\n\t\t\t\t\titer = tmpIter;\n\t\t\t\t\tdfs(s, iter, (pos - len) % resLen);\n\t\t\t\t}\n\t\t\t\tlen += resLen * num;\n\t\t\t\tif (len > 1000010) len = 1000010;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (len <= pos && pos < len + num) {\n\t\t\t\t\tcout << s[iter] << endl;\n\t\t\t\t}\n\t\t\t\tlen += num;\n\t\t\t\tif (len > 1000010) len = 1000010;\n\t\t\t\titer++;\n\t\t\t}\n\t\t}\n\t\telse if (s[iter] == ')') {\n\t\t\titer++;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\n\nint main() {\n\tstring s;\n\tint pos;\n\twhile (cin >> s >> pos) {\n\t\tif (s == \"0\") break;\n\t\tint iter = 0;\n\t\tint length = dfs(s, iter, pos);\n\t\tif (length <= pos) { cout << 0 << endl; }\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000100\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e;\n\t}\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    if(flg2) idx=s[c].size();\n\t    if(idx==s[c].size())flg2=1;\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<n+100;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "string in;\nint p;\n\nvoid next(int& p){\n  ++p;\n  while(p<SZ(in) && in[p]!=')'){\n    if(in[p]=='(')next(p);\n    else ++p;\n  }\n  ++p;\n}\n\nll get(int po,int re){\n  ll le=0;\n  if(in[po]!='(')return 1;\n  ++po;\n  while(po<SZ(in) && in[po]!=')'){\n    if(isdigit(in[po])){\n      ll t=0;\n      while(isdigit(in[po]))t=t*10+in[po++]-'0';\n      ll cle=get(po,re);\n      if(cle==-1)return -1;\n      le+=cle*t;\n      if(in[po]=='(')next(po);\n      else ++po;\n    }else{\n      ++le;\n      ++po;\n    }\n    if(le>re)return -1;\n  }\n  return le;\n}\n\nchar rec(int po,int re){\n  while(po<SZ(in)){\n    //cout<<po<<' '<<re<<endl;\n    if(isdigit(in[po])){\n      ll t=0;\n      while(isdigit(in[po]))t=t*10+in[po++]-'0';\n      ll len=get(po,re);\n      //cout<<len<<endl;\n      int de=0;\n      if(in[po]=='(')++de;\n      if(len==-1)return rec(po+de,re);\n      else if(re<t*len)return rec(po+de,re%len);\n      re-=t*len;\n      //cout<<re<<endl;\n      if(de)next(po);\n      else ++po;\n    }else{\n      if(re==0)return in[po];\n      ++po;\n      --re;\n    }\n  }\n  ++po;\n  return '0';\n}\n\n\n\nmain(){\n  while(cin>>in>>p,in!=\"0\")\n    cout<<rec(0,p)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring str;\nstring ans;\nint N;\n\ninline int cal(string s) {\n    if (s == \"\") return 1;\n    stringstream ss;\n    ss << s;\n    int ret;\n    ss >> ret;\n    return ret;\n}\n\nstring make_str(string s, int left) {\n    if (s.size() == 1) return s;\n\n    string ret;\n    string ch;\n    string num;\n    for (int i = 0, len = s.size(), count = 0; i < len; i++) {\n        if (ret.size() + left > N + 1) break;\n        if (s[i] == '(') count++;\n        if (s[i] == ')') count--;\n        if (count || (!count && !('0' <= s[i] && s[i] <= '9'))) ch += s[i];\n        if (!count && '0' <= s[i] && s[i] <= '9') num += s[i];\n        else if (count == 0){\n            if(ch.size() > 0 && ch[0] == '(') {\n                ch.erase(ch.begin());\n            }\n            string tmp = make_str(ch, left + ret.size());\n            for (int j = 0, len = cal(num); j < len; j++) {\n                if (ret.size() + left > N + 1) break;\n                ret += tmp;\n            }\n            ch = \"\";\n            num = \"\";\n        }\n    }\n\n    return ret;\n}\n\nvoid calc_char(int c, string s, int sum) {\n    string ans_str = make_str(s, 0);\n    string ans_;\n    for (int i = 0; i < c; i++) {\n        ans_ += ans_str;\n        if (ans_.size() > N + 1) break;\n    }\n    ans = ans_[sum];\n}\n\nint dfs(string s, int left) {\n    if (s.size() == 1) return 1;\n    int sum = 0;\n\n    string num;\n    string ch;\n    for (int i = 0, len = s.size(), count = 0; i < len; i++) {\n        if (!count && '0' <= s[i] && s[i] <= '9') num += s[i];\n        else {\n            ch += s[i];\n            if (s[i] == '(') count++;\n            if (s[i] == ')') count--;\n            if (count == 0) {\n                int c = cal(num);\n                if(ch.size() > 0 && ch[0] == '(') {\n                    ch.erase(ch.begin());\n                    ch.erase(ch.end()-1);\n                }\n\n                int tmp = dfs(ch, sum + left);\n                if (tmp < 0) return -1;\n                sum += c * tmp;\n                if (sum + left > N) {\n                    calc_char(c, ch, N - (sum - c * tmp));\n                    return -1;\n                }\n                ch = \"\";\n                num = \"\";\n            }\n        }\n    }\n\n    return sum;\n}\n\nvoid solve() {\n    ans = \"0\";\n\n    dfs(str, 0);\n\n    cout << ans << endl;\n}\n\nint main() {\n    while (cin >> str >> N, str != \"0\" || N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e-1;\n\t  continue;\n\t}\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  int j;\n\t  for(j=0;j<dig&&s[!c].size()+pls.size()<n+200;j++)s[!c]+=pls;\n\t  if(s[!c].size()<n&&j<dig)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if((int)s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\n\nstruct Node{\n    ll size;\n    ll repeat;\n    string s;\n    vector<Node> v;\n    Node(){\n        size = 0;\n        repeat = 0;\n        s = \"\";\n    }\n    Node(ll size, ll repeat, string s){\n        this->size = size;\n        this->repeat = repeat;\n        this->s = s;\n    }\n};\n\nll fetch(const string &s, ll index){\n    ll po = 1;\n    for(ll i = index + 1; i < s.size(); i++){\n        if(s[i] == '(') po++;\n        else if(s[i] == ')') po--;\n        if(!po) return i;\n    }\n}\n\nNode dfs(const string &s){\n    ll num = 0;\n    string t = \"\";\n    Node ret(0, 1, \"\");\n    auto f = [&]{\n        if(t != \"\"){\n            ret.v.push_back(Node(t.size(), 1, t));\n            t = \"\";\n        }\n    };\n\n    for(ll i = 0; i < s.size(); i++){\n        if('0' <= s[i] && s[i] <= '9'){\n            f();\n            num = 10 * num + s[i] - '0';\n        }else if('A' <= s[i] && s[i] <= 'Z'){\n            for(ll j = 0; j < max<ll>(1, num); j++) t += s[i];\n            num = 0;\n        }else if(s[i] == '('){\n            f();\n            ll fe = fetch(s, i);\n            Node tmp = dfs(s.substr(i + 1, (fe - 1) - (i + 1) + 1));\n            tmp.repeat = max<ll>(1, num);\n            i = fe;\n            num = 0;\n            ret.v.push_back(tmp);\n        }\n    }\n    if(t != \"\") f();\n    for(auto child : ret.v){\n        ret.size += child.size * child.repeat;\n        if(ret.size > 1000000) ret.size = 1000000;\n    }\n    if(ret.size < 1000000) ret.size = ret.repeat * (ret.size + ret.s.size());\n    return ret;\n}\n\nchar solve(const Node &n, ll i){\n    if(n.s.size() > i) return n.s[i];\n    for(auto child : n.v){\n        if(child.size * child.repeat < i){\n            i -= child.size * child.repeat;\n        }else{\n            return solve(child, i % max<ll>(1, child.size));\n        }\n    }\n    return n.s[i];\n}\n\nint main(){\n    while(1){\n        string S;\n        ll I;\n        cin >> S >> I;\n        if(S == \"0\" && !I) break;\n        S = \"(\" + S + \")\";\n        auto node = dfs(S);\n        if(node.size - 1 < I) cout << 0 << endl;\n        else cout << solve(node, I) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define di(a) ('0'<=a&&a<='9')\n#define az(a) ('A'<=a&&a<='Z')\n#define INF 1ll<<40\nusing namespace std;\ntypedef unsigned long long ll;\nstring s; int n; ll tL[100],fL[100];\nint fNext(int p){\n\twhile(di(s[p]))p++;\n\tif(s[p]=='(')for(int d=0;p<n;p++){\n\t\tif(s[p]=='(')d++;\n\t\tif(s[p]==')'){\n\t\t\td--; if(d==0)break;\n\t\t}\n\t}\n\treturn p<n-1&&di(s[p+1])|az(s[p+1])?p+1:-1;\n}\nll tLen(int p){\n\tif(tL[p])return tL[p];\n\tint m=0,fn=fNext(p),pp=p;\n\twhile(di(s[p]))m*=10,m+=s[p++]-'0'; if(m==0)m=1;\n\tif(az(s[p]))tL[pp]=m+(fn<0?0:tLen(fn));\n\telse tL[pp]=m*(tLen(p+1))+(fn<0?0:tLen(fn));\n\tif(tL[pp]>=INF)tL[pp]=INF;\n\treturn tL[pp];\n}\nll fLen(int p){\n\tif(fL[p])return fL[p];\n\tint m=0,pp=p;\n\twhile(di(s[p]))m*=10,m+=s[p++]-'0'; if(m==0)m=1;\n\tif(az(s[p]))return fL[pp]=m;\n\tfL[pp]=m*(tLen(p+1));\n\tif(fL[pp]>=INF)fL[pp]=INF;\n\treturn fL[pp];\n}\nchar ge(int p,int idx){\n\tint m=0,fn=fNext(p),pp=p;\n\tif(idx>=fLen(p))return fn<0?'0':ge(fn,idx-fLen(p));\n\twhile(di(s[p]))m*=10,m+=s[p++]-'0'; if(m==0)m=1;\n\tif(s[p]=='('){\n\t\tif(fLen(pp)<INF)idx%=fLen(pp)/m;\n\t\treturn ge(p+1,idx);\n\t}\n\tif(idx<m)return s[p];\n\treturn ge(p+1,idx-m);\n}\nint main(){\n\tint idx;\n\twhile(cin>>s>>idx,s[0]!='0'){\n\t\trep(i,100)fL[i]=tL[i]=0;\n\t\tn=s.size();\n\t\tcout<<ge(0,idx)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_digit(char c){\n\treturn ('0' <= c && c <= '9');\n}\n\nbool is_alpha(char c){\n\treturn ('A' <= c && c <= 'Z');\n}\n\n//stringツ型ツつゥツづァintツ型ツづ可陛渉環キツつキツづゥ\nint s_to_i(string s){\n    bool flag = false;\n    int n = 0;\n    for(unsigned int i=0 ; i < s.size() ; ++i ){\n        if( i == 0 && s[i] == '-' ){\n            flag = true;\n        }else if( s[i] >= '0' && s[i] <= '9' ){\n            n *= 10;\n            n += s[i] - '0';\n        }else{\n            break;\n        }\n    }\n    return (flag)? -n : n ;\n}\n\n//intツ型ツつゥツづァstringツ型ツづ可陛渉環キツつキツづゥ\nstring i_to_s(int n){\n    bool flag = false;\n    string s;\n    if( n < 0 ){\n        flag = true;\n        n *= -1;\n    }\n    do{\n        s.push_back( (n%10)+'0' );\n        n /= 10;\n    }while( n != 0 );\n    \n    reverse( s.begin() , s.end() );\n    if( flag ) \n        s.insert( s.begin() , 1 , '-' );\n    return s;\n}\n\nint main(){\n\tstring s;\n\tint k;\n\twhile( cin >> s >> k ){\n\t\tif( s == \"0\" && k == 0 ) break;\n\t\t\n\t\t// 1ツ閉カツ篠堋づ個繰ツづィツ陛板つオツづ可づ?環?古?'(', ')' ツづーツづつつッツづゥ.\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( is_digit(s[i-1]) && is_alpha(s[i]) ){\n\t\t\t\tstring str;\n\t\t\t\tstr.push_back('(');\n\t\t\t\tstr.push_back( s[i] );\n\t\t\t\tstr.push_back(')');\n\t\t\t\ts.replace( i , 1 , str );\n\t\t\t}\n\t\t}\n\t\t// f[i] := s[i] == ')' ツづ個づ?つォツづ個妥篠可楪つキツづゥ'('ツづ個暗環置ツづーツ陛板つキ. \n\t\tint f[101], h[101] = {0};\n\t\tfor(int i=0 ; i < 101 ; i++ ) f[i] = -1;\n\t\t\n\t\tstack<int> st;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\tst.push( i );\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tf[i] = st.top();\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t\t// h[i] := s[i] == ')' ツづ個妥篠可楪つキツづゥツ繰ツづィツ陛板つオツ青板づーツ陛板つキ.\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( f[i] != -1 ){\n\t\t\t\tint j = f[i];\n\t\t\t\t// num := () ツづ個前ツづ個繰ツづィツ陛板つキツ嘉アツ青板づ個閉カツ篠堋療ア\n\t\t\t\tstring num;\n\t\t\t\tfor(int j_ = j-1 ; j_ >= 0 && is_digit(s[j_]) ; j_-- ){\n\t\t\t\t\tnum.push_back( s[j_] );\n\t\t\t\t}\n\t\t\t\treverse( num.begin() , num.end() );\n\t\t\t\th[i] = s_to_i( num );\n\t\t\t\t//cout << \"[\" << f[i] << \"] - [\" << i << \"] : \" << h[i] << endl;\n\t\t\t}\n\t\t}\n\t\tchar ans = '0';\n\t\tint p=0;\n\t\tint cnt=0;\n\t\twhile( true ){\n\t\t\t// debug:\n\t\t\t/*cout << s << endl;\n\t\t\tfor(int i=0 ; i < p ; i++ ) cout << ' ';\n\t\t\tcout << '^' << endl;\n\t\t\tcout << \"i = \" << cnt << endl;*/\n\t\t\t\n\t\t\tif( s[p] == ')' ){\n\t\t\t\tint i = f[p];\n\t\t\t\t// num := () ツづ個前ツづ個繰ツづィツ陛板つキツ嘉アツ青板づ個閉カツ篠堋療ア\n\t\t\t\tstring num;\n\t\t\t\tfor(int j = i-1 ; j >= 0 && is_digit(s[j]) ; j-- ){\n\t\t\t\t\tnum.push_back( s[j] );\n\t\t\t\t}\n\t\t\t\treverse( num.begin() , num.end() );\n\t\t\t\tstring dec_num = i_to_s(s_to_i(num)-1);\n\t\t\t\tstring str = \"0\";\n\t\t\t\t\n\t\t\t\twhile( dec_num.size() != num.size() ){\n\t\t\t\t\tdec_num = str + dec_num;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint N = s_to_i( num );\n\t\t\t\tif( N > 1 ){\n\t\t\t\t\tp = f[p];\n\t\t\t\t\ts.replace( i-num.size() , num.size() , dec_num );\n\t\t\t\t}else{\n\t\t\t\t\ts.replace( i-num.size() , num.size() , i_to_s(h[p]) );\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}else if( is_alpha(s[p]) ){\n\t\t\t\tif( cnt == k ){\n\t\t\t\t\tans = s[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif( p >= s.size() ) break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_digit(char c){\n\treturn ('0' <= c && c <= '9');\n}\n\nbool is_alpha(char c){\n\treturn ('A' <= c && c <= 'Z');\n}\n\n//stringツ型ツつゥツづァintツ型ツづ可陛渉環キツつキツづゥ\nint s_to_i(string s){\n    bool flag = false;\n    int n = 0;\n    for(unsigned int i=0 ; i < s.size() ; ++i ){\n        if( i == 0 && s[i] == '-' ){\n            flag = true;\n        }else if( s[i] >= '0' && s[i] <= '9' ){\n            n *= 10;\n            n += s[i] - '0';\n        }else{\n            break;\n        }\n    }\n    return (flag)? -n : n ;\n}\n\n//intツ型ツつゥツづァstringツ型ツづ可陛渉環キツつキツづゥ\nstring i_to_s(int n){\n    bool flag = false;\n    string s;\n    if( n < 0 ){\n        flag = true;\n        n *= -1;\n    }\n    do{\n        s.push_back( (n%10)+'0' );\n        n /= 10;\n    }while( n != 0 );\n    \n    reverse( s.begin() , s.end() );\n    if( flag ) \n        s.insert( s.begin() , 1 , '-' );\n    return s;\n}\n\nint main(){\n\tstring s;\n\tint k;\n\twhile( cin >> s >> k ){\n\t\tif( s == \"0\" && k == 0 ) break;\n\t\t\n\t\t// 1ツ閉カツ篠堋づ個繰ツづィツ陛板つオツづ可づ?環?古?'(', ')' ツづーツづつつッツづゥ.\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( is_digit(s[i-1]) && is_alpha(s[i]) ){\n\t\t\t\tstring str;\n\t\t\t\tstr.push_back('(');\n\t\t\t\tstr.push_back( s[i] );\n\t\t\t\tstr.push_back(')');\n\t\t\t\ts.replace( i , 1 , str );\n\t\t\t}\n\t\t}\n\t\t// f[i] := s[i] == ')' ツづ個づ?つォツづ個妥篠可楪つキツづゥ'('ツづ個暗環置ツづーツ陛板つキ. \n\t\tint f[1001], h[1001] = {0};\n\t\tfor(int i=0 ; i < 1001 ; i++ ) f[i] = -1;\n\t\t\n\t\tstack<int> st;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\tst.push( i );\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tf[i] = st.top();\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t\t// h[i] := s[i] == ')' ツづ個妥篠可楪つキツづゥツ繰ツづィツ陛板つオツ青板づーツ陛板つキ.\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( f[i] != -1 ){\n\t\t\t\tint j = f[i];\n\t\t\t\t// num := () ツづ個前ツづ個繰ツづィツ陛板つキツ嘉アツ青板づ個閉カツ篠堋療ア\n\t\t\t\tstring num;\n\t\t\t\tfor(int j_ = j-1 ; j_ >= 0 && is_digit(s[j_]) ; j_-- ){\n\t\t\t\t\tnum.push_back( s[j_] );\n\t\t\t\t}\n\t\t\t\treverse( num.begin() , num.end() );\n\t\t\t\th[i] = s_to_i( num );\n\t\t\t\t//cout << \"[\" << f[i] << \"] - [\" << i << \"] : \" << h[i] << endl;\n\t\t\t}\n\t\t}\n\t\tchar ans = '0';\n\t\tint p=0;\n\t\tint cnt=0;\n\t\twhile( true ){\n\t\t\t// debug:\n\t\t\t/*cout << s << endl;\n\t\t\tfor(int i=0 ; i < p ; i++ ) cout << ' ';\n\t\t\tcout << '^' << endl;\n\t\t\tcout << \"i = \" << cnt << endl;*/\n\t\t\t\n\t\t\tif( s[p] == ')' ){\n\t\t\t\tint i = f[p];\n\t\t\t\t// num := () ツづ個前ツづ個繰ツづィツ陛板つキツ嘉アツ青板づ個閉カツ篠堋療ア\n\t\t\t\tstring num;\n\t\t\t\tfor(int j = i-1 ; j >= 0 && is_digit(s[j]) ; j-- ){\n\t\t\t\t\tnum.push_back( s[j] );\n\t\t\t\t}\n\t\t\t\treverse( num.begin() , num.end() );\n\t\t\t\tstring dec_num = i_to_s(s_to_i(num)-1);\n\t\t\t\tstring str = \"0\";\n\t\t\t\t\n\t\t\t\twhile( dec_num.size() != num.size() ){\n\t\t\t\t\tdec_num = str + dec_num;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint N = s_to_i( num );\n\t\t\t\tif( N > 1 ){\n\t\t\t\t\tp = f[p];\n\t\t\t\t\ts.replace( i-num.size() , num.size() , dec_num );\n\t\t\t\t}else{\n\t\t\t\t\ts.replace( i-num.size() , num.size() , i_to_s(h[p]) );\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}else if( is_alpha(s[p]) ){\n\t\t\t\tif( cnt == k ){\n\t\t\t\t\tans = s[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif( p >= s.size() ) break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\n\nstring get_foo(const string &S, int &pos, function<int(int)> isfoo) {\n    int len = 0;\n    for(; isfoo(S[pos + len]); len++);\n    string ret = S.substr(pos, len);\n    pos += len;\n    return ret;\n}\nstring calc(const string &S, int &pos, int N) {\n    bool paren = S[pos] == '(';\n    if(paren) pos++;\n    string res;\n    res.reserve(N + 1);\n    do {\n        if(isdigit(S[pos])) {\n            int rec = stoi(get_foo(S, pos, [](int a) { return isdigit(a); }));\n            int need = N - res.size();\n            string ss = calc(S, pos, need);\n            rep(i, rec) {\n                rep(j, ss.size()) {\n                    res.push_back(ss[j]);\n                    if(res.size() >= N) goto A;\n                }\n            }\n      A:;\n        } else if(isalpha(S[pos])) {\n            if(paren) {\n                res.append(get_foo(S, pos, [](int a) { return isalpha(a); }));\n            } else {\n                res.push_back(S[pos++]);\n            }\n        } else assert(0);\n    } while(paren and S[pos] != ')' and res.size() < N);\n    if(paren) pos++;\n    return res;\n}\n    \nbool solve() {\n    string S; cin >> S;\n    int N; cin >> N;\n    if(S == \"0\" and N == 0) return false;\n    cerr << S << \" \" << N << endl;\n    int pos = 0;\n    string s;\n    s.reserve(N * 2);\n\n    while(pos < S.size() and s.size() <= N) {\n        s.append(calc(S, pos, N - s.size() + 1));\n    }\n    cout << (s.size() <= N ? \"0\" : s.substr(N, 1)) << endl;        \n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int i = 0;\n    while(true) {\n        if(not solve()) break;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nstring s;\nint n;\nint m;\nchar solve(){\n    stack<pair<int,string> > q;\n    stack<int> st;\n    string tmp;\n    int dep = 0;\n    for(int i=0;i<m;i++){\n        bool flag = 0;\n        int k = 0;\n        while(isdigit(s[i])){\n            flag = 1;\n            k *=10;\n            k += s[i]-'0';\n            i++;\n        }\n        if(flag){\n            if(s[i]=='('){\n                st.push(tmp.size());\n                n -= tmp.size();\n                q.push(MP(k,tmp));\n                tmp = \"\";\n                dep++;\n            }else{\n                string tmp2(k,s[i]);\n                tmp += tmp2;\n                if((int)tmp.size()-1>=n){\n                    return tmp[n]; \n                }\n            }\n        }else{\n            if(s[i]==')'){\n                dep--;\n                int y = st.top();\n                st.pop();\n                n += y;\n                auto xx = q.top();\n                q.pop();\n                int p = xx.first;\n                string t = xx.second;\n                if(t.size()+p*(int)tmp.size()-1>=n){\n                    n -= t.size();\n                    int id = n % tmp.size();\n                    return tmp[id];\n                }else{\n                    string tmp2 = t;\n                    rep(zz,p){\n                        tmp2 += tmp;\n                    }\n                    tmp = tmp2;\n                    if(dep==0){\n                        n -= tmp.size();\n                        tmp = \"\";\n                    }\n                }\n            }else{\n                tmp.push_back(s[i]);\n            }\n        }\n    }\n    if((int)tmp.size()-1<n){\n        return '0';\n    }else{\n        return tmp[n];\n    }\n}\n\nint main(){\n    while(cin >> s >> n){\n        if(s==\"0\"&&n==0)break;\n        m = s.size();\n        cout << solve() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\nusing namespace std;\nstring s;\nint n;\nvoid calc(string &p,int k){\n    //cout << p << \" \" << k << endl;\n    if(k>=s.size())return;\n    if(p.size()>n)return;\n    if(s[k]==')')return;\n    if(s[k]<='Z'&&s[k]>='A'){\n        p.push_back(s[k]);\n        calc(p,k+1);\n        return;\n    }\n    string x;\n    int z = k;\n    bool flag = 0;\n    for(int i=k;;i++){\n        if(s[i]=='('){\n            z = i;\n            flag = 1;\n            break;\n        }\n        if(s[i]<='Z'&&s[i]>='A'){\n            z = i-1;\n            break;\n        }\n        x.push_back(s[i]);\n    }\n    int d=0;\n        if(s[z]=='(')d++;\n        int r;\n        for(int i=z+1;;i++){\n            if(s[i]=='('){\n                d++;\n            }\n            if(s[i]==')'){\n                d--;\n            }\n            if(d==0){\n                r = i;  \n                break;\n            }\n        }\n    if(flag){\n        int y = stoi(x);\n        for(int j=0;j<y;j++){\n            if(p.size()>n)return;\n            calc(p,z+1);\n        }\n        if(p.size()>n)return;\n        if(p.size()<=n){\n            calc(p,r+1);\n        }\n    }else{\n        int y = stoi(x);\n        for(int i=0;i<y;i++){\n            p.push_back(s[r]);\n        }\n        if(p.size()<=n){\n            calc(p,r+1);\n        }\n    }\n   \n    return;\n}\n\n\nint main(){   \n    while(cin >> s >> n&&s!=\"0\"){\n        string p;\n        calc(p,0);\n        if(p.size()<=n){\n            cout << 0 << endl;\n        }else{\n            cout << p[n] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<int, int> pii;\n\nstring S;\nint N;\n\nint main(void) {\n  while(cin >> S >> N) {\n    if(S[0] == '0' && N == 0) break;\n    int p = 0, cnt = 0;\n    stack<pii> stk;\n\n    char ans = '0';\n    while(p < S.length()) {\n      if('0' <= S[p] && S[p] <= '9') {\n        int itr = 0;\n        for(; '0' <= S[p] && S[p] <= '9'; p++) itr = itr * 10 + (S[p] - '0');\n        if(S[p] == '(') {\n          p++;\n          stk.push(pii(itr, p));\n        } else {\n          while(itr--) {\n            if(cnt == N) {\n              ans = S[p];\n              goto PRINT;\n            }\n            cnt++;\n          }\n          p++;\n        }\n      } else if('A' <= S[p] && S[p] <= 'Z') {\n        if(cnt == N) {\n          ans = S[p];\n          goto PRINT;\n        }\n        p++, cnt++;\n      } else if(S[p] == ')') {\n        stk.top().first--;\n        if(stk.top().first > 0) p = stk.top().second;\n        else {\n          stk.pop();\n          p++;\n        }\n      }\n    }\n\nPRINT:\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n#include<assert.h>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tStage(){\n\t\tcin >> s >> id;\n\t}\n\t\n\tbool is_end(){\n\t\treturn s == \"0\";\n\t}\n\t\n\tvoid action(){\n\t\tstack<Gram> st;\n\t\tauto grams = trans_gram();\n\t\tfor (auto gram : grams)\n\t\t{\n\t\t\t//解凍\n\t\t\tif (gram.kind == 'p' && gram.par == ')')\n\t\t\t{\n\t\t\t\tauto alpha = st.top(); st.pop();\n\t\t\t\tauto parL = st.top(); st.pop();\n\t\t\t\tauto roop = st.top(); st.pop();\n\t\t\t\tgram = roop_modify(roop, alpha);\n\t\t\t}\n\n\n\t\t\t//結合\n\t\tstart:;\n\t\t\twhile(!st.empty() && gram.kind == 'a')\n\t\t\t{\n\t\t\t\tGram tmp;\n\t\t\t\tswitch (st.top().kind){\n\t\t\t\tcase 'a':\n\t\t\t\t\ttmp = st.top(); st.pop();\n\t\t\t\t\tgram = append(tmp, gram);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\ttmp = st.top(); st.pop();\n\t\t\t\t\tgram = roop_modify(tmp, gram);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto last;\n\t\t\t\t}\n\t\t\t}\n\t\tlast:;\n\t\t\tst.push(gram);\n\t\t}\n\t\tstring res = \"\";\n\t\twhile (!st.empty()) {\n\t\t\tif (st.top().kind == 'a') {\n\t\t\t\tres = st.top().s + res;\n\t\t\t\tif (res.size() >= id)\n\t\t\t\t{\n\t\t\t\t\tres = res.substr(0, id + 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t\tif (id >= res.size()) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << res[id] << endl;\n\t\t}\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tint num;\n\t\tstring s;\n\t\tchar par;\n\t};\n\n\tint id;\n\tstring s;\n\t\n\tvector<Gram> trans_gram()const\n\t{\n\t\tvector<Gram> grams;\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tGram gram;\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.par = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.par = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (is_num(s[i])) {\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnum *= 10;\n\t\t\t\t\t\tnum += s[i] - '0';\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} while (is_num(s[i]));\n\t\t\t\t\ti--;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = num;\n\t\t\t\t}\n\t\t\t\telse if (is_alpha(s[i])) {\n\t\t\t\t\tstring tmp{ s[i] };\n\t\t\t\t\twhile (i < s.size() - 1 && is_alpha(s[i + 1])) {\n\t\t\t\t\t\ttmp += {s[i + 1]};\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tgram.kind = 'a';\n\t\t\t\t\tgram.s = tmp;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tbool is_num(const char& c) const{\n\t\treturn '0' <= c && c <= '9';\n\t}\n\tbool is_alpha(const char& c)const {\n\t\treturn 'A' <= c && c <= 'Z';\n\t}\n\tGram roop_modify(const Gram& roop, const Gram& alpha)const\n\t{\n\t\tassert(roop.kind == 'n');\n\t\tassert(alpha.kind == 'a');\n\n\t\tGram gram;\n\t\tgram.kind = 'a';\n\t\tREP(i, roop.num)\n\t\t{\n\t\t\tgram.s += alpha.s;\n\t\t\tif (gram.s.size() > id)break;\n\t\t}\n\t\treturn gram;\n\t}\n\tGram append(Gram l, const Gram& r)const \n\t{\n\t\tassert(l.kind == 'a');\n\t\tassert(r.kind == 'a');\n\t\tl.s += r.s;\n\t\tif (l.s.size() > id) {\n\t\t\tl.s = l.s.substr(0, id + 10);\n\t\t}\n\t\treturn l;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile(true){\n\t\tStage stage;\n\t\tif(stage.is_end())break;\n\t\tstage.action();\n\t}\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nchar ans;\nint a;\nstring st;\nlong long int getnum() {\n\tlong long int  anum=0;\n\twhile (1) {\n\t\tif (isdigit(st[a])) {\n\t\t\tanum *= 10;\n\t\t\tanum += st[a]-'0';\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn anum;\n\t\t}\n\t}\n}\nstring getst() {\n\tstring ast;\n\twhile (1) {\n\t\tif (a == st.size())return ast;\n\t\tif ('A'<=st[a]&&st[a]<='Z') {\n\t\t\tast += st[a];\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn ast;\n\t\t}\n\t}\n}\nstring getans(const long long int repeatnum,const int targetnum) {\n\tstring nst;\n\twhile (1) {\n\t\tif (a == st.size())return  nst;\n\t\tif (st[a] == '(') {\n\t\t\ta++;\n\t\t\tnst+=getans(repeatnum, targetnum - nst.size());\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tlong long int num=getnum();\n\t\t\tstring plusst;\n\t\t\tif (st[a] == '(') {\n\t\t\t\ta++;\n\t\t\t\tplusst= getans(min(1000000000ll,repeatnum*num), targetnum - nst.size()*repeatnum);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tplusst = st[a];\n\t\t\t\ta++;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\tnst += plusst;\n\t\t\t}\n\t\t\tif ((nst.size())*repeatnum > targetnum) {\n\t\t\t\tans = nst[targetnum % nst.size()];\n\t\t\t\tthrow(0);\n\t\t\t}\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn nst;\n\t\t}\n\t\telse {\n\t\t\tstring plusst = getst();\n\t\t\tnst += plusst;\n\t\t\tif ((nst.size())*repeatnum > targetnum) {\n\t\t\t\tans = nst[targetnum % nst.size()];\n\t\t\t\tthrow(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\ta = 0;\n\t\tans = '0';\n\t\tint n;\n\t\tcin >> st >> n;\n\t\tif (st == \"0\")break;\n\t\ttry {\n\t\t\tgetans(1, n);\n\t\t}\n\t\tcatch (...) {\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\n\nchar ans;\nvoid saiki(string s, int &out, int &idx) {\n\tint num = 0;\n\twhile (idx<s.length()) {\n\t\tif (isdigit(s[idx])) {\n\t\t\tnum *= 10;\n\t\t\tnum += s[idx] - '0';\n\t\t\tidx++;\n\t\t}\n\t\telse if(s[idx]=='('){\n\t\t\tidx++;\n\t\t\tint idx2;\n\t\t\tREP(i, num) {\n\t\t\t\tidx2 = idx;\n\t\t\t\tsaiki(s, out, idx2);\n\t\t\t\tif (ans != '0'||out<0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tidx = idx2;\n\t\t\tnum = 0;\n\t\t}\n\t\telse if (s[idx] == ')') {\n\t\t\tidx++;\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tstring s2 = \"\";\n\t\t\tif (num == 0) {\n\t\t\t\twhile ('A' <= s[idx] && s[idx] <= 'Z') {\n\t\t\t\t\ts2 += s[idx];\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts2 += s[idx];\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tREP(i,max(1,num))\n\t\t\tif (out < s2.length()) {\n\t\t\t\tans = s2[out];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout -= s2.length();\n\t\t\t\tif (out < 0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tnum = 0;\n\t\t}\n\t}\n\treturn;\n}\nint main() {\n\tstring s;\n\tint out;\n\twhile (cin >> s >> out, s != \"0\") {\n\t\tint idx = 0;\n\t\tans = '0';\n\t\tsaiki(s, out, idx);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n\n//string solve(int times,string s){\n//    string ret=\"\";\n//    string part=\"\";\n//    \n//    int len=s.size();\n//\n//    rep(i,len){\n//        if( isalpha(s[i]) ){\n//            part+=s[i];\n//        }\n//        else if( isdigit(s[i]) ){\n//            string num;\n//            for(int j=i;j<len;j++){\n//                if(j>1000010)return part;\n//                if( isdigit(s[j]) )num+=s[j];\n//                else{\n//                    break;\n//                }\n//            }\n//            i+=num.size();\n//            \n//            if( s[i]!='(' ){\n//                part+=solve( stoi(num) , string( 1,s[i] ) );\n//            }else{\n//                i++;\n//                string repeat=\"\";\n//                int brackets=1;\n//                for(int j=i;j<len;j++){\n//                    if( s[j]==')' ){\n//                        repeat+=')';\n//                        brackets--;\n//                        \n//                    }else if( s[j]=='(' ){\n//                        brackets++;\n//                        repeat+='(';\n//                        \n//                    }else{\n//                        if(j==len-1)return \"invalid2\";\n//                        \n//                        repeat+=s[j];\n//                    }\n//                    if(brackets<=0)break;\n//                }\n//                \n//                repeat.erase(repeat.size()-1);\n//                i+=repeat.size();\n//                \n//                part+=solve( stoi(num) , repeat );\n//            }\n//            \n//            \n//        }else return \"invalid1\";\n//    }\n//    \n//    \n//    rep(i,times)ret+=part;\n//    \n////    cout<<ret<<endl;\n//    return ret;\n//}\n\n\nstring getDigit(int n,string s){\n    string ret=\"\";\n    \n    for(int i=n;i<s.size();i++){\n        if( isdigit(s[i]) )ret+=s[i];\n        else break;\n    }\n    return ret;\n}\n\n\nstring solve(int num,string s){\n//    cout<<s<<endl;\n    string part=\"\";\n    \n    int len=s.size();\n    rep(i,len){\n        if( isalpha(s[i]) )part+=s[i];\n        if(part.size()>1000100)return part;\n        \n        else if( isdigit(s[i]) ){\n            string deg=getDigit(i,s);\n            i+=deg.size();\n            \n            if(s[i]=='('){\n                int bra=1;\n                i++;\n                string repeat=\"\";\n                for(int j=i;j<len;j++){\n                    if( s[j]=='(' )bra++;\n                    if( s[j]==')' )bra--;\n                    \n                    if( bra==0 )break;\n                    else{\n                        repeat+=s[j];\n                        if(repeat.size()>1000100)break;\n                    }\n                }\n                part+=solve( stoi(deg) , repeat );\n                if(part.size()>1000100)return part;\n                i+=repeat.size();\n                \n            }else{\n                part+=solve( stoi(deg) , string(1,s[i]) );\n            }\n        }\n    }\n    \n    if(part.size()>1000100)return part;\n    string ret=\"\";\n    rep(i,num)ret+=part;\n    \n    return ret;\n}\n\n\nint main(){\n    string s;\n    int n;\n    while(cin>>s>>n){\n        if(s==\"0\"&& n==0)break;\n        \n        string res = solve(1,s);\n        \n        if(res.size()<=n)cout<<\"0\"<<endl;\n        else cout<<res[n]<<endl;\n        \n//        cout<<res.size()<<endl;\n    }\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstring str;\nint n;\n\nint dfs(string s){\n    int now = 0;\n    int ret = 0;\n    while(true){\n        while('A' <= s[now] && s[now] <= 'Z'){\n            ret++;\n            if(n == ret){\n                cout << s[now] << endl;\n                return -1;\n            }\n            now++;\n            if(now == s.size()){\n                return ret;\n            }\n        }\n        int num = 0;\n        while('0' <= s[now] && s[now] <= '9'){\n            num = num*10+s[now]-'0';\n            now++;\n        }\n        string foo;\n        int kakko = 0;\n        while(true){\n            now++;\n            if(s[now] == ')') kakko--;\n            if(s[now] == '(') kakko++;\n            if(kakko < 0){\n                int d = dfs(foo);\n                if(d == -1) return -1;\n                if(ret+num*d >= n){\n                    n -= ret;\n                    n %= d;\n                    if(n == 0) n += d;\n                    dfs(foo);\n                    return -1;\n                }\n                ret += num*d;\n                break;\n            }\n            foo.push_back(s[now]);\n        }\n        now++;\n        if(now == s.size()) return ret;\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> str >> n){\n        if(str == \"0\" && n == 0) break;\n        n++;\n        string tmp;\n        rep(i,str.size()){\n            if('A' <= str[i] && str[i] <= 'Z'){\n                if(i != 0 && ('0' <= str[i-1] && str[i-1] <= '9')){\n                    tmp.push_back('(');\n                    tmp.push_back(str[i]);\n                    tmp.push_back(')');\n                } else{\n                    tmp.push_back(str[i]);\n                }\n            } else{\n                tmp.push_back(str[i]);\n            }\n        }\n        str = tmp;\n        if(dfs(str) != -1){\n            cout << 0 << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000600\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n    int flg2=0;\n    while(f){\n      f=0;      \n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e-1;\n\t  continue;\n\t}\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(!flg2){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&(int)s[!c].size()+(int)pls.size()<n+500;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if((int)s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(void){\n\tint val;\n\twhile(cin >> val)\n\t\tcerr << val << \" \";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstring s;\nint pos;\n\nint length(){\n\tlong long res = 0;\n\twhile(isdigit(s[pos])) res = 10*res+s[pos++]-'0';\n\tif(!res){\n\t\twhile(s[pos]!=')'&&!isdigit(s[pos])&&pos<s.size()) { res++; pos++;}\n\t\treturn res;\n\t}\n\tlong long tmp = 0;\n\tif(s[pos++] != '(') return res;\n\twhile(s[pos] != ')') tmp += length();\n\tpos++;\n\treturn min((int)(res*tmp), 1000001);\n}\n\nvoid print(int p, int n){\n\tif(p==s.size()) {\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tpos = p;\n\tint L = length();\n\tif(n < L){\n\t\tif(isdigit(s[p])){\n\t\t\twhile(isdigit(s[p])){ p++; }\n\t\t\tint L2 = 0;\n\t\t\tif(s[p]=='('){\n\t\t\t\tp++;\n\t\t\t\tpos = p;\n\t\t\t\twhile(pos<s.length()&&s[pos]!=')') L2 += length();\n\t\t\t} else {\n\t\t\t\tpos = p;\n\t\t\t\tL2 = length();\n\t\t\t}\n\t\t\tprint(p, n%L2);\n\t\t} else {\n\t\t\tcout << s[p+n] << endl;\n\t\t}\n\t} else {\n\t\tprint(pos, n-L);\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> s >> n){\n\t\tif(s==\"0\"&&n==0) break;\n\t\tprint(0,n);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cctype>\nusing namespace std;\ntypedef string::const_iterator Cursol;\nint num(Cursol&);\nstring calc(Cursol&);\nstring expr(Cursol&);\n\nint pos ;\n\nint num(Cursol& p){\n  int ret = 0;\n  while(isdigit(*p)){\n    ret = ret * 10 + *p - '0';\n    p++;\n  }\n  return ret;\n}\n\nstring calc(Cursol& p){\n  string ret;\n  if(isdigit(*p)){\n    int number = num(p);\n    if( *p == '(') {\n      string res = expr(++p);\n      p++;\n      while(number--){\n        ret += res;\n        if(pos < ret.size()) break;\n      }\n    } else {\n      ret.insert(ret.end(), min( pos + 1, number), *p++);\n      cout << ret << endl;\n    }\n  }else{\n    while(isalpha(*p)){\n      ret += *p++;\n      if(pos < ret.size()) break;\n    }\n  }\n  return ret;\n}\n\n\nstring expr(Cursol& p){\n  string ret;\n  while( isalpha(*p) || isdigit(*p)){\n    ret += calc(p);\n    if(pos < ret.size()) break;\n  }\n  return ret;\n}\nint main(){\n  string str;\n  while(cin >> str >> pos, str!=\"0\"||pos){\n    Cursol idx = str.begin();\n    string ret = expr(idx);\n    if(pos < ret.size()) cout << ret[pos] << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long id, nowend = 0;\nstring s;\nchar ans;\n\nlong long solve(long long now, long long req);\nvoid solve2();\n\nint main() {\n  while(1) {\n    cin >> s >> id;\n    if(s == \"0\" && id == 0) break;\n    ans = '0';\n    solve2();\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nlong long solve(long long now, long long req) {\n  long long cnt = 0, charcnt = 1;\n  string nows;\n  if(s[now] >= '0' && s[now] <= '9') {\n    while(s[now] >= '0' && s[now] <= '9') {\n      cnt *= 10;\n      cnt += s[now++] - '0';\n    }\n    charcnt = solve(now, req);\n    if(charcnt < 0) return -1;\n    cnt *= charcnt;\n    if(cnt > req) {\n      if(solve(now, req % charcnt) != -1) assert(0);\n      return -1;\n    }\n  }\n  else if(s[now] == '(') {\n    nowend = now;\n    while(nowend < s.size() && s[nowend] != ')') {\n      charcnt = solve(nowend, req - cnt);\n      if(charcnt == -1) return -1;\n      cnt += charcnt;\n    }\n    ++nowend;\n  }\n  else {\n    while(now < s.size() && s[now] >= 'A' && s[now] <= 'Z')\n      nows += s[now++];\n    if(req < nows.size()) {\n      ans = nows[req];\n      return -1;\n    }\n    nowend = now;\n    cnt = nows.size();\n  }\n  return cnt;\n}\n\nvoid solve2() {\n  nowend = 0;\n  while(nowend < s.size()) {\n    long long x = solve(nowend, id);\n    if(x < 0) return;\n    id -= x;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n\nint num;\n\nconst char *solve(const char *p, int idx)\n{\n    while (*p != '\\0' && *p != ')') {\n        int n = 1;\n        if (isdigit(*p)) {        \n            n = 0;\n            while (isdigit(*p)) {\n                n *= 10;                \n                n += *p - '0';\n                ++p;\n            }\n        }\n        if (isalpha(*p)) {\n            for (int i = 0; i < n; i++) {\n                if (num++ == idx) {\n                    throw *p;\n                }\n            }\n            ++p;            \n        } else if (*p == '(') {\n            ++p;\n            const char *q = p;\n            for (int i = 0; i < n; i++) {\n                p = solve(q, idx);\n            }\n            ++p;\n        }        \n    }       \n    return p;\n}\n\nchar find_char(const std::string &s, int idx)\n{\n    try {\n        num = 0;\n        solve(s.c_str(), idx);\n    } catch (char ch) {\n        return ch;\n    }\n    return '0';\n}\n\nint main()\n{\n    std::string s;\n    int idx;\n    while (1) {\n        std::cin >> s >> idx;\n        if (s == \"0\" && idx == 0) {\n            break;\n        }\n        \n        std::cout << find_char(s, idx) << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 1000001\n\nchar base[101];\nchar *ans_buf,*work;\nint ans_index,result_index,base_length;\nint work_index,work_length;\n\nvoid recursive(int left,int right){\n\n\tif(left > right)return;\n\n\tint keisu = 0,index;\n\n\tfor(index = left; index <= right && base[index] >= 'A' && base[index] <= 'Z' && work_index < ans_index+1;index++){\n\t\twork[work_index++] = base[index];\n\t\twork[work_index] = '\\0';\n\t}\n\n\tfor(;index <= right && base[index] >= '0' && base[index] <= '9';index++){\n\t\tkeisu = 10*keisu + (base[index]-'0');\n\t}\n\n\tif(keisu == 0){\n\t\tfor(work_length = 0; work[work_length] != '\\0';work_length++);\n\t\treturn;\n\t}\n\n\t//keisu != 0\n\n\tif(base[index] == '('){\n\n\t\tint depth = 1,next_right = -1,max_depth = 1;\n\t\tbool numFLG = false;\n\n\t\tfor(int i = index+1; i <= right; i++){\n\t\t\tif(base[i] == '('){\n\t\t\t\tdepth++;\n\t\t\t\tmax_depth = max(max_depth,depth);\n\t\t\t}else if(base[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(next_right == -1 && depth == 0){\n\t\t\t\t\tnext_right = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(base[i] >= '0' && base[i] <= '9'){\n\t\t\t\tnumFLG = true;\n\t\t\t}\n\t\t}\n\n\t\tif(max_depth == 1){\n\n\n\t\t\tif(!numFLG){\n\n\t\t\t\tfor(int i = 0; i < keisu && work_index < ans_index+1; i++){\n\t\t\t\t\tfor(int k = index+1;k <= next_right-1 && work_index < NUM;k++){\n\t\t\t\t\t\twork[work_index++] = base[k];\n\t\t\t\t\t\twork[work_index] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trecursive(next_right+1,right);\n\t\t\t}else{\n\n\t\t\t\tint pre_index = work_index;\n\n\t\t\t\trecursive(index+1,next_right-1);\n\t\t\t\tfor(work_length = 0; work[pre_index+work_length] != '\\0';work_length++);\n\n\t\t\t\tfor(int i = 0; i < keisu-1 && work_index < ans_index+1; i++){\n\t\t\t\t\tfor(int k = 0; k < work_length && work_index < NUM;k++){\n\t\t\t\t\t\twork[work_index++] = work[pre_index+k];\n\t\t\t\t\t\twork[work_index] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trecursive(next_right+1,right);\n\t\t\t}\n\n\t\t}else{\n\t\t\tdepth = 1,next_right = -1;\n\t\t\tfor(int i = index+1; i <= right; i++){\n\t\t\t\tif(base[i] == '('){\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(base[i] == ')'){\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(next_right == -1 && depth == 0){\n\t\t\t\t\t\tnext_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint pre_index = work_index;\n\n\t\t\trecursive(index+1,next_right-1);\n\t\t\tfor(work_length = 0; work[pre_index+work_length] != '\\0';work_length++);\n\n\t\t\tfor(int i = 0; i < keisu-1 && work_index < ans_index+1; i++){\n\t\t\t\tfor(int k = 0; k < work_length && work_index < NUM;k++){\n\t\t\t\t\twork[work_index++] = work[pre_index+k];\n\t\t\t\t\twork[work_index] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecursive(next_right+1,right);\n\t\t}\n\n\t}else{\n\t\tfor(int i = 0; i < keisu && work_index < ans_index+1; i++){\n\t\t\twork[work_index++] = base[index];\n\t\t\twork[work_index] = '\\0';\n\t\t}\n\t\tif(index + 1 <= right){\n\t\t\trecursive(index+1,right);\n\t\t}\n\n\t}\n\n\tfor(work_length = 0; work[work_length] != '\\0';work_length++);\n}\n\nvoid func(){\n\n\tfor(int a = 0; a < NUM+9; a++)ans_buf[a] = '0';\n\tresult_index = 0;\n\tfor(base_length = 0; base[base_length] != '\\0';base_length++);\n\n\tint left = 0,right = 0,depth;\n\n\twhile(left < base_length && result_index < ans_index+1){\n\n\t\tdepth = 0;\n\t\tfor(int i = left; ;i++){\n\t\t\tif(base[i] == '('){\n\t\t\t\tdepth++;\n\t\t\t}else if(base[i] == ')'){\n\t\t\t\tdepth--;\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tright = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else if(base[i] >= 'A' && base[i] <= 'Z'){\n\t\t\t\tif(depth == 0){\n\t\t\t\t\tright = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//Do nothing\n\t\t\t}\n\t\t}\n\n\t\twork_index = 0;\n\t\twork_length = 0;\n\t\twork[0] = '\\0';\n\t\trecursive(left,right);\n\n\t\tfor(int a = 0; work[a] != '\\0' && result_index < NUM;a++){\n\t\t\tans_buf[result_index++] = work[a];\n\t\t}\n\n\t\tleft = right+1;\n\t}\n\n\tprintf(\"%c\\n\",ans_buf[ans_index]);\n}\n\n\nint main(){\n\n\tans_buf = new char[1000020];\n\twork = new char[1000020];\n\n\twhile(true){\n\t\tscanf(\"%s %d\",base,&ans_index);\n\t\tif(base[0] == '0' && ans_index == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint n;\nint len;\nchar loop(string s){\n\tint num = 0;\n\tstring ss = \"\";\n\tREP(i, s.length()){\n\t\tif (isdigit(s[i])){\n\t\t\tnum *= 10;\n\t\t\tnum += s[i] - '0';\n\t\t}\n\n\t\tif (s[i] == '('){\n\t\t\tchar c;\n\t\t\tREP(j, num){\n\t\t\t\tc = loop(s.substr(i + 1));\n\t\t\t\tif (c != '0')\n\t\t\t\t\treturn c;\n\t\t\t}\n\t\t\tnum = 0;\n\t\t\tint nu = 0;\n\t\t\twhile (1){\n\t\t\t\tif (s[i] == ')')nu--;\n\t\t\t\tif (s[i] == '(')nu++;\n\t\t\t\tif (nu == 0)break;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == ')'){\n\t\t\tif (n-len < ss.length()){\n\t\t\t\t\n\t\t\t\treturn ss[(n - len)];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tlen += ss.length();\n\t\t\t\treturn '0';\n\t\t\t}\t\n\t\t}\n\t\tif ('A' <= s[i] && s[i] <= 'Z'){\n\t\t\tREP(j,num)\n\t\t\t\tss += s[i];\n\t\t\tif (num==0)\n\t\t\t\tss += s[i];\n\t\t\tnum = 0;\n\t\t}\n\t}\n\n\tif (n-len < ss.length()){\n\t\treturn ss[(n - len)];\n\t}\n\telse{\n\t\t\n\t\tlen += ss.length();\n\t\treturn '0';\n\t}\n}\n\n\nint main() {\n\tstring s;\n\twhile (cin>>s>>n,s!=\"0\"){\n\t\tlen = 0;\n\n\t\tcout << loop(s) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\n\nint toint(int&);\nstring calc(int&);\nstring expr(int&);\n\n\nstring s;\nint n;\n\nint toint(int& idx){\n  int ret = 0;\n  while(isdigit(s[idx])){\n    ret = ret * 10 + s[idx] - '0';\n    idx++;\n  }\n  return ret;\n}\n\nstring calc(int& idx){\n  string java;\n  if(isdigit(s[idx])){ //すーじ\n    int num = toint(idx) ;\n    string ret = calc(idx) ;\n    for(int i = 0 ; i < num ; i++ ){\n      java += ret ;\n      if(java.size() >= n) break;\n    }\n  } else if(isalpha(s[idx])){ //えーじ\n    while(isalpha(s[idx])){\n      java += s[idx] ;\n      idx++ ;\n      if(java.size() >= n) break;\n    }\n  } else { //かっこ\n    idx++;\n    java = expr(idx);\n    idx++;\n  }\n  return java;\n}\nstring expr(int& idx){\n  string java;\n  while(isalpha(s[idx])|isdigit(s[idx])){\n    java += calc(idx);\n    if(java.size() >= n) break;\n  }\n  return java;\n}\n\n\nint main(){\n  int now;\n  while(cin >> s >> n, s!=\"0\"|n){\n    string ret = expr(now = 0);\n    if(ret.size() <= n) cout << 0 << endl;\n    else cout << ret[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nint idx, target;\nstring s;\n\nstruct node {\n\tint repeat;\n\tlong long len;\n\tvector<node> children;\n\tchar c;\n\n\tnode(int r):len(0ll), repeat(r){}\n\tnode(int r, char c):len(1ll), repeat(r), c(c){}\n\n\tlong long size() const {\n\t\treturn len * repeat;\n\t}\n\n\tvoid add(const node& n) {\n\t\tchildren.push_back(n);\n\t\tlen += n.size();\n\t\tchmin<int>(repeat, target / len + 1);\n\t}\n\n\tchar get(int idx) const {\n\t\tconst long long sum = len * repeat;\n\t\tif(idx < sum) {\n\t\t\tif(children.size()) {\n\t\t\t\tidx %= len;\n\t\t\t\tfor(int i = 0; i < (int)children.size(); ++i) {\n\t\t\t\t\tconst long long tmp = children[i].size();\n\t\t\t\t\tif(idx < tmp)\n\t\t\t\t\t\treturn children[i].get(idx);\n\n\t\t\t\t\tidx -= tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\n\t\treturn '0';\t\t\n\t}\n};\n\nint number() {\n\tint res = 0;\n\twhile(isdigit(s[idx])) {\n\t\tres *= 10;\n\t\tres += s[idx++] - '0';\n\t}\n\n\treturn res;\n}\n\nnode parse(int repeat) {\n\tnode res(repeat);\n\twhile(idx < (int)s.size() && s[idx] != ')') {\n\t\tif(isdigit(s[idx])) {\n\t\t\tconst int r = number();\n\t\t\tif(s[idx] == '(') {\n\t\t\t\t++idx;\n\t\t\t\tres.add(parse(r));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.add(node(r, s[idx]));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tres.add(node(1, s[idx]));\n\t\t}\n\n\t\t++idx;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> target, s != \"0\") {\n\t\tidx = 0;\n\t\tconst node root = parse(1);\n\t\tcout << root.get(target) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1145&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint getnum(int&pos, const string& str) {\n\tint ret = 0;\n\twhile (true) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\tret = ret * 10 + (str[pos] - '0');\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstring gennom(int&pos, int& len, const string& str, const int& n) {\n\tint roop = getnum(pos, str);\n\tif (str[pos] == '(') pos++;\n\telse {\n\t\tstring ret;\n\t\tchar c = str[pos++];\n\t\tfor (int i = 0; i < roop;i++) {\n\t\t\tret += c;\n\t\t\tif (ret.length() >= n)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tstring s;\n\tstring ret;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\ts += gennom(pos,len, str, n);\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\ts += str[pos++];\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] == ')') {\n\t\t\tpos++; break;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < roop; i++) {\n\t\tret += s; len += ret.length();\n\t\tif (ret.length() >= n)break;\n\t}\n\treturn ret;\n}\n\nstring solve(const string& str,int& n) {\n\tstring ret;\n\tint pos = 0;\n\tint len = 0;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\tret += str[pos++]; len++;\n\t\t}\n\t\telse {\n\t\t\tret += gennom(pos, len, str, n);\n\t\t}\n\t\tif (len >= n)return ret;\n\t}\n\treturn ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring str; int n;\n\twhile (cin >> str >> n) {\n\t\tif (str == \"0\" && n == 0) break;\n\t\tstring ans = solve(str, n);\n\t\tif (ans.length() > n) {\n\t\t\tcout << ans[n] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint N;\nstring dfs(string s){\n\tstring r;\n\tint i=0;\n\tlong long n=-1;\n\tfor(;i<s.size();){\n\t\tif('0'<=s[i]&&s[i]<='9'){\n\t\t\tif(n<0)\n\t\t\t\tn=s[i]-'0';\n\t\t\telse\n\t\t\t\tn=n*10+s[i]-'0';\n\t\t\ti++;\n\t\t}else if(s[i]=='('){\n\t\t\tif(n<0)n=1;\n\t\t\tint cnt=1,j=i+1;\n\t\t\tfor(;cnt;){\n\t\t\t\tif(s[j]=='(')\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(s[j]==')')\n\t\t\t\t\tcnt--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tstring r0=dfs(s.substr(i+1,j-1-i-1));\n\t\t\tr+=r0;\n\t\t\tif(r.size()>N)return r;\n\t\t\tfor(int _=1;_<n;_++)r+=r0;\n\t\t\tn=-1;\n\t\t\ti=j;\n\t\t}else{\n\t\t\tif(n<0)n=1;\n\t\t\tr+=string(n,s[i]);\n\t\t\tn=-1;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main(){\n\tfor(;;){\n\t\tstring s;\n\t\tcin>>s>>N;\n\t\tif(s==\"0\")break;\n\t\tstring r=dfs(s);\n\t\tprintf(\"%c\\n\",r.size()>N?r[N]:'0');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\nusing namespace std;\n\nint N;\nstring dfs(const string &s,int L,int R){\n\tstring r;\n\tint i=L;\n\tlong long n=-1;\n\tfor(;i<R;){\n\t\tif('0'<=s[i]&&s[i]<='9'){\n\t\t\tif(n<0)\n\t\t\t\tn=s[i]-'0';\n\t\t\telse\n\t\t\t\tn=n*10+s[i]-'0';\n\t\t\ti++;\n\t\t}else if(s[i]=='('){\n\t\t\tif(n<0)n=1;\n\t\t\tint cnt=1,j=i+1;\n\t\t\tfor(;cnt;){\n\t\t\t\tif(s[j]=='(')\n\t\t\t\t\tcnt++;\n\t\t\t\telse if(s[j]==')')\n\t\t\t\t\tcnt--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tstring r0=dfs(s,i+1,j-1);\n\t\t\tfor(int _=0;_<n;_++){\n\t\t\t\tr+=r0;\n\t\t\t\tif(r.size()>N)return r;\n\t\t\t}\n\t\t\tn=-1;\n\t\t\ti=j;\n\t\t}else{\n\t\t\tif(n<0)n=1;\n\t\t\tr+=string(n,s[i]);\n\t\t\tn=-1;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main(){\n\tfor(;;){\n\t\tstring s;\n\t\tcin>>s>>N;\n\t\tif(s==\"0\")break;\n\t\tstring r=dfs(s,0,s.size());\n\t\tprintf(\"%c\\n\",r.size()>N?r[N]:'0');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s,an;\nint n;\nvoid dfs(int x){\n  int t=0,i=x;\n  string str;\n  while('0'<=s[i]&&s[i]<='9')t*=10,t+=s[i++]-'0';\n  t=max(1,t);\n  if(s[i]=='(')\n    while(t--&&an.size()<=n)dfs(i+1);\n  while('A'<=s[i]&&s[i]<='Z')an+=s[i++];\n}\nint main(){\n  while(cin>>s>>n){\n    an.clear();\n    for(int i=0;i<s.size();i++)\n      if('0'<=s[i]&&s[i]<='9'&&'A'<=s[i+1]&&s[i+1]<='Z')\n\ts=s.substr(0,i+1)+'('+s[i+1]+')'+s.substr(i+2,s.size());\n    dfs(0);\n    //   cout<<an<<endl;\n    if(an.size()>n)\n      cout<<an[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\n#include<cstdlib>\n#define inf 1<<29\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\nstring s;\nchar ans;\nvector<string> v;\nmap<int,int> mp;\n\nll rec(int,int,ll);\n\nvoid rec2(int a,int b,ll sum){\n  /*for(int i=a;i<b;i++)cout<<v[i]<<\" \";\n  cout<<sum<<endl;*/\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],0);\n\tif(sum<tmp*atoi(v[i].c_str()))rec2(i+2,mp[i+1],sum%tmp);\n\telse sum-=tmp*atoi(v[i].c_str());\n\tif(ans!='0')return;\n        i=mp[i+1];\n      }\n      else {\n        ll tmp=atoi(v[i].c_str());\n        if(sum<tmp){\n\t  ans=v[i+1][0];\n\t  return;\n\t}\n\telse {\n\t  sum-=tmp;\n\t  i++;\n\t}\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      if(sum<v[i].length()){\n\tans=v[i][sum];\n\treturn;\n      }\n      else sum-=v[i].length();\n    }\n    else {}\n  }\n  return;\n}\n\nll rec(int a,int b,ll c){\n  ll sum=0;\n  if(ans!='0')return inf;\n\n  for(int i=a;i<b;i++){\n    if('0'<=v[i][0] && v[i][0]<='9'){\n      if(ans!='0')return inf;\n      if(v[i+1]==\"(\"){\n\tll tmp=rec(i+2,mp[i+1],sum);\n\tif(ans!='0')return inf;\n\tsum+=atoi(v[i].c_str())*tmp;\n\ti=mp[i+1];\n      }\n      else {\n\tsum+=atoi(v[i].c_str())*v[i+1].length();\n\ti++;\n      }\n    }\n    else if('A'<=v[i][0] && v[i][0]<='Z'){\n      sum+=v[i].length();\n    }\n    else {}\n  }\n  if(n<sum)rec2(a,b,n-c);\n  return sum;\n}\n\nint main()\n{\n  while(1){\n    cin>>s>>n;\n    if(s[0]=='0' && n==0)break;\n    ans='0';\n    v.clear();mp.clear();\n    string tmp1=\"\",tmp2=\"\";\n    for(int i=0;i<s.length();i++){\n      if('0'<=s[i] && s[i]<='9'){\n\tif(tmp2!=\"\")v.push_back(tmp2);\n\ttmp2=\"\";\n\ttmp1+=s[i];\n      }\n      if('A'<=s[i] && s[i]<='Z'){\n\tif(tmp1!=\"\")v.push_back(tmp1);\n\ttmp1=\"\";\n\ttmp2+=s[i];\n      }\n      if(s[i]=='('){\n\tv.push_back(tmp1);\n\ttmp1=\"\";\n\tv.push_back(\"(\");\n      }\n      if(s[i]==')'){\n        v.push_back(tmp2);\n        tmp2=\"\";\n        v.push_back(\")\");\n      }\n      if(i==s.length()-1 && tmp2!=\"\")v.push_back(tmp2);\n    }\n    stack<int> st;\n    for(int i=0;i<v.size();i++){\n      if(v[i]==\"(\")st.push(i);\n      if(v[i]==\")\"){\n\tmp[st.top()]=i;\n\tst.pop();\n      }\n    }\n    rec(0,v.size(),0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint m;\nchar ans;\nbool flag = false;\nstring dfs(string s) {\n\t//cout << s << endl;\n\tif(flag) return \"\";\n\tif('A' <= s[0] && s[0] <= 'Z') {\n\t\treturn s;\n\t}\n\tstring ret = \"\";\n\t//10C??????????????????????¢????\n\t/*bool h = false, ff = false;\n\tstring tt = \"\";\n\tint idx = -1;\n\tREP(i, s.size()) {\n\t\tif(i >= 5) break;\n\t\tif(s[i] == '(') h = true;\n\t\tif(isdigit(s[i])) tt += s[i], idx = i, ff = true;\n\t\telse if(ff && isdigit(s[i])) h = false;\n\t}\n\tstring ret = \"\";\n\tif(!h) {\n\t\tstring tmp = dfs(s.substr(idx+1));\n\t\tint itt = stoi(tt);\n\t\t//cout << \"tmp\" << tmp << \"itt\" << itt << endl;\n\t\tREP(i, itt) {\n\t\t\tret += tmp;\n\t\t\t//cout << ret << endl;\n\t\t\tif((int)ret.size() > m) {\n\t\t\t\tans = ret[m];\n\t\t\t\tflag = true;\n\t\t\t\t//cout << ans << endl;\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t//cout << \"b\" << endl;\n\t*/\n\tstring num = \"\", para = \"\";\n\tint now = 0;\n\tbool f = true, g = false, kakko = false;\n\tREP(i, s.size()) {\n\t\tif(s[i] == '(') {\n\t\t\tkakko = true;\n\t\t\tg = true;\n\t\t\tnow++;\n\t\t} else if(s[i] == ')') {\n\t\t\tnow--;\n\t\t} else if(isdigit(s[i])){\n\t\t\tf = false;\n\t\t} else {\n\t\t\tf = true;\n\t\t\tg = true;\n\t\t}\n\t\tif(g) para += s[i];\n\t\telse num += s[i];\n\t\tif(now == 0 && f) {\n\t\t\t//tmp???dfs?????????????????°?????????????????????ret????????????\n\t\t\t//cout << \"para\" << para << \"num\" << num << endl;\n\t\t\tif(num == \"\") num = \"1\";\n\t\t\tint ttmp = stoi(num);\n\t\t\tstring dret;\n\t\t\tif(kakko) dret = dfs(para.substr(1, para.size()-2));\n\t\t\telse dret = dfs(para);\n\t\t\tREP(j, ttmp) {\n\t\t\t\tret += dret;\n\t\t\t\tif((int)ret.size() > m) {\n\t\t\t\t\tans = ret[m];\n\t\t\t\t\tflag = true;\n\t\t\t\t\t//cout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tnum = \"\", para = \"\";\n\t\t\tf = true, g = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring s;\n\t\tcin >> s >> m;\n\t\tif(s == \"0\" && !m) break;\n\n\t\tflag = false;\n\n\t\tbool f = true;\n\t\tint now = 0;\n\t\tstring tmp = \"\";\n\t\tREP(i, s.size()) {\n\t\t\t//cout << \"i:\" << i << \" \" << s[i] << endl;\n\t\t\tif(s[i] == '(') now++;\n\t\t\telse if(s[i] == ')') now--;\n\t\t\telse if(isdigit(s[i])) f = false;\n\t\t\telse f = true;\n\t\t\ttmp += s[i];\n\t\t\t//cout << tmp << \" \" << m << endl;\n\t\t\tif(now == 0 && f) {\n\t\t\t\tstring t = dfs(tmp);\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif(flag) {cout << ans << endl; goto e;}\n\t\t\t\telse if((int)t.size() <= m) {\n\t\t\t\t\tm -= t.size();\n\t\t\t\t}\telse {cout << t[m] << endl; goto e;}\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t\te:\n\t\tint a;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint cket(std::string &str, int i)\n{\n\tint n = 1;\n\n\tfor ( ; i < str.size(); ++i ) {\n\t\tif ( str[i] == '(' ) n++;\n\t\tif ( str[i] == ')' ) n--;\n\n\t\tif ( n == 0 ) break;\n\t}\n\treturn i;\n}\n\nint n;\nchar expand(std::string str)\n{\n\tstd::string res;\n\tfor ( int i = 0; i < str.size(); ++i ) {\n\t\tif ( isdigit( str[i] ) ) {\n\t\t\tint j = 1;\n\t\t\twhile ( isdigit(str[i + j] ) ) j++;\n\t\t\tint num = std::atoi(str.substr(i, j).c_str());\n\t\t\t\n\t\t\tint s, e;\n\t\t\tif ( str[i + j] == '(' ) {\n\t\t\t\tint k;\n\t\t\t\tk = cket(str, i + j + 1);\n\t\t\t\ts = i + j + 1;\n\t\t\t\te = k - (i+j+1);\n\t\t\t\ti = k;\n\t\t\t} else {\n\t\t\t\ts = i + j;\n\t\t\t\te = 1;\n\t\t\t\ti = i + j;\n\t\t\t}\n\t\t\tfor ( int l = 0; l < num; ++l ){\n\t\t\t\tchar a = expand(str.substr(s, e));\n\t\t\t\tif ( a != '0' ) return a;\n\t\t\t}\n\t\t} else {\n\t\t\tif ( n == 0 ) {\n\t\t\t\treturn str[i];\n\t\t\t}\n\t\t\tn--;\n\t\t}\n\t}\n\treturn '0';\n}\n\nint main(void)\n{\n\twhile ( true ) {\n\t\tstd::string str;\n\n\t\tstd::cin >> str >> n;\n\t\tif ( str == \"0\" && n == 0 ) break;\n\n\t\tstd::cout << expand(str) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <ctype.h>\n#include <stdlib.h>\nusing namespace std;\nstring S;\nint pos;\nint I;\n\ntypedef struct List {\n  int d;\n  string s;\n  List *l; //loop\n  List *n; //next\n} List;\nList *l;\n\n\nbool isalpha(char ch) {\n  return ('A' <= ch && ch <= 'Z');\n}\n\nvoid makeList(List *l) {\n  char ch = S[pos++];\n  //printf(\"CH:%c pos:%d\\n\",ch,pos-1);\n  if(ch=='\\0') {\n    l->n=l->l = NULL;\n  }\n  if(isdigit(ch)) {\n    int d = ch - '0';\n    while(isdigit(S[pos])) d = d*10 + S[pos++] - '0';\n    l->d=d;\n    //cout << d << endl;\n    makeList(l);\n  } else if(isalpha(ch)) {\n    string s=\"\";\n    s+=ch;\n    while(isalpha(S[pos])) s += S[pos++];\n    l->s=s;\n    //cout << s << endl;\n    if(s.length()==1) {\n      l->n = new List();\n      l->n->l=l->n->n=NULL;\n      makeList(l->n);\n    } else {\n      makeList(l);\n    }\n  } else if(ch=='(') {\n    if(isalpha(S[pos])) {\n      makeList(l);\n    } else {\n      l->l = new List();\n      l->l->l=l->l->n=NULL;\n      makeList(l->l);\n    }\n    pos--; // ?\n    if(S[pos++]!=')') { printf(\"%c what?\\n\",S[pos]); exit(1); }\n    if(S[pos] == ')') {\n      l->n = NULL;\n      makeList(l);\n    } else {\n      l->n = new List();\n      l->n->l=l->n->n=NULL;\n      makeList(l->n);\n    }\n  }\n}\n\nint d; bool flag;\nvoid solve(List *l) {\n  if(flag) return;\n  if(l->s==\"\") {\n    //printf(\"l->sNULL\\n\");\n    while((l->d)--) {\n      solve(l->l);\n    }\n    //printf(\"lNull l->n\\n\");\n    solve(l->n);\n  } else {\n    int Ssize = (l->s).size();\n    if(d-Ssize*(l->d)-1 <= 0) {\n      if(!flag && d <= Ssize*(l->d)-1) {\n\tcout << (l->s[d%((l->s).size())]) << endl;\n\tflag=true;\n\treturn;\n      }\n    }\n    d= d - Ssize*(l->d);\n    //cout << d<<\": \"<<l->s << \"l->d:\"<<l->d << endl;\n\n    if((l->n)!=NULL)\n      solve(l->n);\n  }\n}\n\n\nmain() {\n  while(cin>>S>>I,S!=\"0\") {\n    pos=0;\n    l = new List();\n    l->n=l->l=NULL; l->d=1;\n    makeList(l);\n    d=I; flag=false; solve(l); if(!flag) cout << '0' << endl;\n    delete(l);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i=j;i<k;i++)\n#define rep(i,j) reps(i,0,j)\n#define InumF 1<<30\n#define fr first\n#define sc second\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\ntypedef pair<int,int> Pii;\n\nint main(){\n\tstring str;\n\tint n;\n\twhile(true){\n\t\tcin >> str;\n\t\tscanf(\"%d\",&n);\n\t\tif(str == \"0\" && n == 0)break;\n\t\tint len = str.size();\n\t\tstring numew=\"\";\n\t\tnumew += str[0];\n\t\treps(i,1,len){\n\t\t\tif(isdigit(str[i-1]) && isalpha(str[i])){\n\t\t\t\tnumew += \"(\";\n\t\t\t\tnumew += str[i];\n\t\t\t\tnumew += \")\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnumew += str[i];\n\t\t\t}\n\t\t}\n\t\tstr = numew;\n\t\tstack < int > S;\n\t\tvector<int> par(128,-1);\n\t\tvector<int> num(128,-1);\n\t\trep(i,str.size()){\n\t\t\tif(isdigit(str[i])){\n\t\t\t\tstring tmp = \"\";\n\t\t\t\tint j;\n\t\t\t\tfor(j = i; str[j] != '(' ;j++){\n\t\t\t\t\ttmp += str[j];\n\t\t\t\t}\n\t\t\t\tnum[i] = atoi(tmp.c_str());\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\n\t\trep(i,str.size()){\n\t\t\tif(str[i] == '('){\n\t\t\t\tfor(int j = i-1; j >= 0; j--){\n\t\t\t\t\tif(num[j] != -1){\n\t\t\t\t\t\tS.push(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[i] == ')'){\n\t\t\t\tpar[i] = S.top();\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\t//cout << num[i] << \" \";\n\t\t}\n\n\n\t\tint now = 0;\n\t\tint cnt = 0;\n\t\tvector<int> nex = num;\n\t\t\n\t\twhile(true){\n\t\t\t//cout<<now<<\"(\"<<cnt<<\")\"<<\" \";\n\t\t\tif(isalpha(str[now])){\n\t\t\t\t//cout<<str[now];\n\t\t\t\tif(cnt == n){\n\t\t\t\t\tcout<<str[now]<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnow++,cnt++;\n\t\t\t}\n\t\t\telse if(isdigit(str[now])){\n\t\t\t\tnex[now]--;\n\t\t\t\tif(nex[now] == 0)nex[now] = num[now];\n\t\t\t\tint j = now;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(str[j] == '(')break;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tnow = j;\n\t\t\t}\n\t\t\telse if(str[now] == '(')now++;\n\t\t\telse if(str[now] == ')'){\n\t\t\t\tif(nex[par[now]] == num[par[now]])now++;\n\t\t\t\telse now = par[now];\n\t\t\t}\n\t\t\tif(now == str.size()){\n\t\t\t\tcout<<0<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint l;\nchar ans;\nbool f;\nint dfs(string s,int x){\n  //if(x%10000==1) cout<<s<<\" \"<<x<<endl;\n  int res=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(isalpha(s[i])){\n      if(res==x){\n\tf=1;\n\tans=s[i];\n\treturn 0;\n      }\n      res++;\n      continue;\n    }\n    //cout<<s[i]<<endl;\n    int k=0,op=0;\n    for(;isdigit(s[i]);i++) k=k*10+s[i]-'0';\n    //cout<<k<<endl;\n    string t;\n    if(s[i]=='('){\n      for(i++;!(op==0&&s[i]==')');i++){\n\tt+=s[i];\n\tif(s[i]=='(') op++;\n\tif(s[i]==')') op--;\n      }\n    }else t=s[i];\n    //cout<<k<<endl;\n    for(int j=0;j<k;j++){\n      int tmp=dfs(t,x-res);\n      if(f) return 0;\n      res+=tmp;\n    }\n    if(f) return 0;\n  }\n  return res;\n}\nsigned main(){\n  string s;\n  int x;\n  while(cin>>s>>x,!(s==\"0\"&&x==0)){\n    f=0;\n    ans='-';\n    l=dfs(s,x);\n    if(f) cout<<ans<<endl;\n    else  cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#define DEBUG false\nusing namespace std;\n\nunsigned int n; // oÍ·é¶\n\nstring tab=\"\";\nstring tabN=\"  \";\n\nstring parse( string s ){\n  string r=\"\", num, tmp;\n  if( DEBUG)  tab += tabN;\n\n  for( unsigned int i=0;i<s.length();i++ ){\n    if( i>n )\n      return s.substr( 0,i );\n\n    if( '0'<=s[i] && s[i]<='9' ){\n      num=\"\";\n      unsigned int j=i;\n      for( j=i;j<s.length();j++ )\n\tif( '0'<=s[j] && s[j]<='9' ) num = num + s[j];\n\telse                         break;\n      if( s[j]!='(' ){\n\ttmp = s[j];\n      }else{\n\tint a=0; // Ê\"(\"Ì - \")\"Ì\n\ttmp=\"\";\n\twhile( j<s.length() ){\n\t  if( s[j]=='(' )      ++a;\n\t  else if( s[j]==')' ) --a;\n\t  tmp = tmp + s[j++];\n\t  if( a==0 )\n\t    break;\n\t}\n\ttmp = tmp.substr( 1,tmp.length()-2 );\n      }\n      // ±Ì_Å num(tmp) ÌÅãÌ) ÌÊuªj\n      j++;\n\n      if( DEBUG )\n\tcout << tab << \"num=\"<<num << \" tmp=\" << tmp << endl;\n\n      tmp = parse( tmp );\n      if( tmp.length()>n )\n\treturn s.substr( 0,i ) + tmp;\n\n      string rp=\"\";\n      int rpN = atoi( num.c_str() );\n      for( int k=0;k<rpN ;k++ ){\n\trp = rp + tmp;\n\tif( i+rp.length() > n )\n\t  return s.substr( 0,i ) + rp;\n      }\n\n      string bef = s.substr( 0,i );\n      string back = \"\";\n      if( j<s.length() ) back = s.substr( j-1 );\n      s = bef + rp + back;\n      if( bef.length() > n )\n\treturn s;\n      \n      if( DEBUG ){\n\tcout << tab << \"bef =\"<<bef<<endl;\n\tcout << tab << \"rp =\"<<rp << endl;\n\tcout << tab << \"back =\"<<back << endl;\n\tcout << tab << \"s =\" << s << endl;\n      }\n    }else{\n      r = r + s[i];\n    }\n    if( r.length() > n )\n      break;\n  }\n  if( DEBUG )\n    tab = tab.substr( tabN.length() );\n\n  return r;\n}\n\nint main(){\n  string s, ans;\n\n  while( true ){\n    cin >> s >> n;\n    if( s==\"0\" && !n )\n      break;\n\n    if( DEBUG ){\n      cout << \"in : \" << s << endl;\n      cout << \"num=\" << n << endl << endl;\n    }\n    ans = parse( s );\n    if( DEBUG )\n      cout << \"return : \" << ans << endl;\n\n    if( n < ans.length() )\n      cout << ans[n] << endl;\n    else\n      cout << \"0\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define all(a) (a).begin(), (a).end()\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nstring s; int n;\nint calc(int count, int idx){\n\tif(count == -1) return -1;\n\tidx++; //(\n\twhile(s[idx] != ')'){\n\t\tif(count == n){cout << s[idx] << endl; return -1;}\n\n\t\tif(isalpha(s[idx])){count++; idx++;}\n\t\telse {\n\t\t\tint m = 0;\n\t\t\twhile(isdigit(s[idx])){m*=10; m += s[idx]-'0'; idx++;}\n\t\t\trep(i, m) count = calc(count, idx);\n\n\t\t\tidx++;\n\t\t\tint b = 1;\n\t\t\twhile(b != 0){\n\t\t\t\tif(s[idx] == '(') b++;\n\t\t\t\telse if(s[idx] == ')') b--;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t}\n\t\tif(count == -1) return -1;\n\t}\n\treturn count;\n}\n\nint main(){\n\twhile(cin >> s >> n){\n\t\tfor(int i=0; i < s.size(); i++){\n\t\t\tif(isdigit(s[i]) && isalpha(s[i+1])) s = s.substr(0, i+1) + \"(\" + s.substr(i+1, 1) + \")\" + s.substr(i+2);\n\t\t}\n\n\t\tint count = 0;\n\n\t\tif(s == \"0\" && n == 0) break;\n\t\tfor(int i=0; i< s.size(); i++){\n\t\t\tif(count == n){cout << s[i] << endl; count = -1;}\n\t\t\tif(count == -1) break;\n\n\t\t\tif(isalpha(s[i])){count++;}\n\t\t\telse {\n\t\t\t\tint m = 0;\n\t\t\t\twhile(isdigit(s[i])){m*=10; m += s[i]-'0'; i++;}\n\n\t\t\t\trep(j, m) count = calc(count, i);\n\n\t\t\t\ti++;\n\t\t\t\tint b = 1;\n\t\t\t\twhile(b != 0){\n\t\t\t\t\tif(s[i] == '(') b++;\n\t\t\t\t\telse if(s[i] == ')') b--;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t}\n\t\tif(count != -1) cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nstruct Term\n{\n    using Ptr = shared_ptr<Term>;\n    Term(const int rep, const vector<Ptr>& child, const int unit, const string& s) : rep{rep}, child{child}, unit{unit}, s{s} {}\n    int rep;\n    vector<Ptr> child;\n    int unit;\n    string s;\n};\nusing Ptr = Term::Ptr;\nstring S;\nstring::iterator c;\nPtr parse()\n{\n    if (not isdigit(*c)) {\n        string s;\n        for (; 'A' <= *c and *c <= 'Z'; c++) { s.push_back(*c); }\n        return make_shared<Term>(1, vector<Ptr>{}, (int)s.size(), s);\n    }\n    string d;\n    for (; isdigit(*c); c++) { d.push_back(*c); }\n    const int D = d == \"\" ? 1 : stoi(d);\n    Ptr ans = make_shared<Term>(D, vector<Ptr>{}, 0, \"\");\n    bool hasb = false;\n    if (*c == '(') { hasb = true, c++; }\n    if (not hasb) { return (ans->unit = 1, ans->s = string(1, *c), c++, ans); }\n    for (; *c != ')';) {\n        const auto p = parse();\n        ans->child.push_back(p);\n        ans->unit = min(ans->unit + (p->unit) * (p->rep), 1000001);\n    }\n    c++;\n    return ans;\n}\nstring toString(const Ptr p)\n{\n    if (p->child.empty()) { return p->s; }\n    string s = to_string(p->rep) + \"(\";\n    for (const auto& c : p->child) { s += toString(c); }\n    s += \")\";\n    return s;\n}\nint main()\n{\n    while (true) {\n        int N;\n        cin >> S >> N;\n        if (S == \"0\" and N == 0) { break; }\n        S = \"1(\" + S + \")\";\n        c = S.begin();\n        const Ptr root = parse();\n//        show(toString(root));\n        if (N >= root->unit * root->rep) {\n            cout << 0 << endl;\n            continue;\n        }\n        Ptr p = root;\n        while (true) {\n            if (p->child.empty()) {\n                cout << p->s[N] << endl;\n                break;\n            } else {\n                for (const auto& c : p->child) {\n                    if (N >= c->rep * c->unit) {\n                        N -= c->rep * c->unit;\n                    } else {\n                        N %= c->unit;\n                        p = c;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\n\nstring factor(State &begin,int &n,int x);\nint number(State &begin);\nstring seq(State &begin);\n\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nstring seq(State &begin){\n\tstring ret=\"\";\n\twhile(*begin>='A' && *begin<='Z'){\n\t\tret+=*begin;\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nstring factor(State &begin,int &n,int x){\n\tint k=1;\n\tstring str=\"\";\n\twhile(1){\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tstring ret=factor(begin,n,x);\n\t\t\t//cout << ret << endl;\n\t\t\tbegin++;\n\t\t\tif(n>x)return ret;\n\t\t\tfor(int i=1;i<k;i++){\n\t\t\t\tstr+=ret;\n\t\t\t\tn+=ret.size();\n\t\t\t\tif(n>x){\n\t\t\t\t\tstring res=\"\";\n\t\t\t\t\tres+=ret[ret.size()-(n-x)];\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*begin>='0' && *begin<='9'){\n\t\t\tk=number(begin);\n\t\t}else if(*begin>='A' && *begin<='Z'){\n\t\t\t//string ret=seq(begin);\n\t\t\tfor(int i=0;i<k;i++){\n\t\t\t\tstr+=*begin;\n\t\t\t\tn++;\n\t\t\t\tif(n>x){\n\t\t\t\t\tstring res=\"\";\n\t\t\t\t\tres+=*begin;\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=1;\n\t\t\tbegin++;\n\t\t}else break;\n\t}\n\treturn str;\n}\n\nint main(void){\n\twhile(1){\n\t\tint x;\n\t\tstring str;\n\t\tcin >> str >> x;\n\t\tif(str==\"0\" && x==0)break;\n\t\tState begin=str.begin();\n\t\tint d=0;\n\t\tstring res=factor(begin,d,x);\n\t\tif(d<=x)res=\"0\";\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n\n#define MAX_LEN 1000002\n\nusing namespace std;\n\ntypedef pair<string,int> parsed;\nparsed parse(const string &expr, int i){\n  parsed ret;\n  string s;\n\n  int d=1;\n  if( isdigit( expr[i] ) ){\n    d=0;\n    while( isdigit( expr[i] ) ){\n      int t = expr[i++]-'0';\n      d*=10;\n      d+=t;\n    }\n  }\n\n  if( expr[i] == '(' ){\n    parsed p = parse(expr,i+1);\n    s = p.first;\n    i = p.second;\n  }else{\n    while( isalpha( expr[i] ) ){\n      s+=expr[i++];\n    }\n  }\n\n  for(int j = 0; j < d; ++j){\n    ret.first+=s;\n    if( ret.first.length() > MAX_LEN )\n      break;\n  }\n\n  if( i < expr.size() && expr[i] == ')' )++i;\n\n  ret.second = i;\n  return ret;\n}\n\nchar solve(const string &expr, int n){\n  parsed ans;\n  while(ans.second<expr.size()){\n    parsed p = parse(expr,ans.second);\n    ans.first += p.first;\n    ans.second = p.second;\n  }\n  if(n<0||n>=ans.first.length())return '0';\n  return ans.first[n];\n}\n\nint main(){\n  while(true){\n    string expr;\n    int n;\n    cin>>expr>>n;\n    if(expr==\"0\"&&n==0)\n      break;\n    cout << solve(expr,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n#include<assert.h>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n\nstruct Stage{\n\tStage(){\n\t\tcin >> s >> id;\n\t}\n\t\n\tbool is_end(){\n\t\treturn s == \"0\";\n\t}\n\t\n\tvoid action(){\n\t\tstack<Gram> st;\n\t\tauto grams = trans_gram();\n\t\tfor (auto gram : grams)\n\t\t{\n\t\t\t//解凍\n\t\t\tif (gram.kind == 'p' && gram.par == ')')\n\t\t\t{\n\t\t\t\tauto alpha = st.top(); st.pop();\n\t\t\t\tauto parL = st.top(); st.pop();\n\t\t\t\tauto roop = st.top(); st.pop();\n\t\t\t\tgram = roop_modify(roop, alpha);\n\t\t\t}\n\n\n\t\t\t//結合\n\t\tstart:;\n\t\t\twhile(!st.empty() && gram.kind == 'a')\n\t\t\t{\n\t\t\t\tGram tmp;\n\t\t\t\tswitch (st.top().kind){\n\t\t\t\tcase 'a':\n\t\t\t\t\ttmp = st.top(); st.pop();\n\t\t\t\t\tgram = append(tmp, gram);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\ttmp = st.top(); st.pop();\n\t\t\t\t\tgram = roop_modify(tmp, gram);\n\t\t\t\t\tbreak;\n\t\t\t\t\t/*\n\t\t\t\tcase 'p':\n\t\t\t\t\tst.pop();\n\t\t\t\t\ttmp = st.top(); st.pop();\n\t\t\t\t\tgram = roop_modify(tmp, gram);\n\t\t\t\t\tbreak;\n\t\t\t\t\t*/\n\t\t\t\tdefault:\n\t\t\t\t\tgoto last;\n\t\t\t\t}\n\t\t\t}\n\t\tlast:;\n\t\t\tst.push(gram);\n\t\t}\n\t\tstring res = \"\";\n\t\twhile (!st.empty()) {\n\t\t\tif (st.top().kind == 'a') {\n\t\t\t\tres = st.top().s + res;\n\t\t\t\tif (res.size() >= id)\n\t\t\t\t{\n\t\t\t\t\tres = res.substr(0, id + 10);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.pop();\n\t\t}\n\t\tif (id >= res.size()) {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << res[id] << endl;\n\t\t}\n\t}\n\t\nprivate:\n\tstruct Gram {\n\t\tchar kind;\n\t\tint num;\n\t\tstring s;\n\t\tchar par;\n\t};\n\n\tint id;\n\tstring s;\n\t\n\tvector<Gram> trans_gram()const\n\t{\n\t\tvector<Gram> grams;\n\t\tREP(i, s.size())\n\t\t{\n\t\t\tGram gram;\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '(':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.par = '(';\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tgram.kind = 'p';\n\t\t\t\tgram.par = ')';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (is_num(s[i])) {\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tnum *= 10;\n\t\t\t\t\t\tnum += s[i] - '0';\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} while (is_num(s[i]));\n\t\t\t\t\ti--;\n\t\t\t\t\tgram.kind = 'n';\n\t\t\t\t\tgram.num = num;\n\t\t\t\t}\n\t\t\t\telse if (is_alpha(s[i])) {\n\t\t\t\t\tstring tmp{ s[i] };\n\t\t\t\t\twhile (i < s.size() - 1 && is_alpha(s[i + 1])) {\n\t\t\t\t\t\ttmp += {s[i + 1]};\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tgram.kind = 'a';\n\t\t\t\t\tgram.s = tmp;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgrams.push_back(gram);\n\t\t}\n\t\treturn grams;\n\t}\n\n\tbool is_num(const char& c) const{\n\t\treturn '0' <= c && c <= '9';\n\t}\n\tbool is_alpha(const char& c)const {\n\t\treturn 'A' <= c && c <= 'Z';\n\t}\n\tGram roop_modify(const Gram& roop, const Gram& alpha)const\n\t{\n\t\tassert(roop.kind == 'n');\n\t\tassert(alpha.kind == 'a');\n\n\t\tGram gram;\n\t\tgram.kind = 'a';\n\t\tREP(i, roop.num)\n\t\t{\n\t\t\tgram.s += alpha.s;\n\t\t\tif (gram.s.size() >= id)break;\n\t\t}\n\t\treturn gram;\n\t}\n\tGram append(Gram l, const Gram& r)const \n\t{\n\t\tassert(l.kind == 'a');\n\t\tassert(r.kind == 'a');\n\t\tl.s += r.s;\n\t\tif (l.s.size() > id) {\n\t\t\tl.s = l.s.substr(0, id + 10);\n\t\t}\n\t\treturn l;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile(true){\n\t\tStage stage;\n\t\tif(stage.is_end())break;\n\t\tstage.action();\n\t}\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1145&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nint getnum(int&pos, const string& str) {\n\tint ret = 0;\n\twhile (true) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\tret = ret * 10 + (str[pos] - '0');\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstring gennom(int&pos,const string& str, const int& n) {\n\tint roop = getnum(pos, str);\n\tif (str[pos] == '(') pos++;\n\telse {\n\t\tstring ret;\n\t\tchar c = str[pos++];\n\t\tfor (int i = 0; i < roop;i++) {\n\t\t\tret += c;\n\t\t\tif (ret.length() > n)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tstring s;\n\tstring ret;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= '0' && str[pos] <= '9') {\n\t\t\ts += gennom(pos,str, n);\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\ts += str[pos++];\n\t\t\tcontinue;\n\t\t}\n\t\tif (str[pos] == ')') {\n\t\t\tpos++; break;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < roop; i++) {\n\t\tret += s;\n\t\tif (ret.length() > n)break;\n\t}\n\treturn ret;\n}\n\nstring solve(const string& str,int& n) {\n\tstring ret;\n\tint pos = 0;\n\tfor (;pos < str.length();) {\n\t\tif (str[pos] >= 'A' && str[pos] <= 'Z') {\n\t\t\tret += str[pos++];\n\t\t}\n\t\telse {\n\t\t\tret += gennom(pos,str, n);\n\t\t}\n\t\tif (ret.length() > n)return ret;\n\t}\n\treturn ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tstring str; int n;\n\twhile (cin >> str >> n) {\n\t\tif (str == \"0\" && n == 0) break;\n\t\tstring ans = solve(str, n);\n\t\t//cout << ans << endl;\n\t\tif (ans.length() > n) {\n\t\t\tcout << ans[n] << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef string::const_iterator State;\nstring s;\nint reff;\nstring expr(State& be){\n\tstring ret;\n\twhile(true){\n\t\tint x=1;\n\t\tif(isdigit(*be)){\n\t\t\tx=0;\n\t\t\twhile(isdigit(*be)){\n\t\t\t\tx*=10;\n\t\t\t\tx+=(*be)-'0';\n\t\t\t\tbe++;\n\t\t\t}\n\t\t}\n\t\tif(*be=='('){\n\t\t\tbe++;\n\t\t\tstring t=expr(be);\n\t\t\trep(i,x){\n\t\t\t\tif(ret.size()>reff) break;\n\t\t\t\tret+=t;\n\t\t\t}\n\t\t\tbe++;\n\t\t}else if('A'<=*be && *be<='Z'){\n\t\t\trep(i,x){\n\t\t\t\tif(ret.size()>reff) break;\n\t\t\t\tret+=(*be);\n\t\t\t}\n\t\t\tbe++;\n\t\t}else break;\n\t\tif(ret.size()>reff) break;\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tcin>>s>>reff;\n\t\tif(s[0]=='0') break;\n\t\tState be=s.begin();\n\t\tstring t=expr(be);\n\t\tif(t.size()<=reff) cout << \"0\\n\";\n\t\telse cout << t[reff]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_LEN = 1100010;\n\nchar ans;\nbool end_flg = false;\nint I;\nchar N[MAX_LEN];\n\npair<string, char *> getStr(char *p){\n  stringstream ss;\n  while(isalpha(*p)){\n    ss << (*p);\n    ++p;\n  }\n  return pair<string, char *>(ss.str(), p);\n}\n\npair<int, char *> getInt(char *p){\n  int ret = 0;\n  while(isdigit((*p))){\n      ret *= 10;\n      ret += ((*p) - '0');\n      ++p;\n  }\n  return pair<int, char *>(ret, p);\n}\n\npair<string, char *> check(char *p){\n  if(end_flg) return pair<string, char *>(\"\", p);\n  pair<int, char *> tmpi = getInt(p);\n  int num = tmpi.first;\n  p = tmpi.second;\n  string str = \"\";\n  while(isdigit(*(p + 1))){\n    pair<string, char *> tmpc = check(p + 1);\n    str += tmpc.first;\n    p = tmpc.second;\n    if(end_flg) return pair<string, char *>(\"\", p);\n  }\n  pair<string, char *> tmps = getStr(p + 1);\n  string now_str = tmps.first;\n  str += now_str;\n  p = tmps.second;\n  string ret = \"\";\n  if(str.length() * num - 1 >= I){\n    ans = str[I % str.length()];\n    end_flg = true;\n  } else if(str.length() * num <= MAX_LEN){\n    stringstream ss;\n    REP(i, num) ss << str;\n    ret = ss.str();\n  }\n  return pair<string, char *>(ret, p);\n}\n\nint main() {\n  string tmp_s;\n  while(cin >>tmp_s >>I && tmp_s != \"0\"){\n    stringstream ss;\n    ss <<\"1(\";\n    REP(i, tmp_s.length()){\n      if(i + 1 < tmp_s.length() && isdigit(tmp_s[i]) && isalpha(tmp_s[i + 1]))\n        ss <<tmp_s[i] <<\"(\";\n      else if(i + 1 < tmp_s.length() && isalpha(tmp_s[i]) && isdigit(tmp_s[i + 1]))\n        ss <<\")\" <<tmp_s[i];\n      else\n        ss <<tmp_s[i];\n    }\n    ss <<\")\";\n    char *tmp_c = new char[ss.str().length() + 1];\n    strcpy(tmp_c, ss.str().c_str());\n    strcpy(N, tmp_c);\n    end_flg = false;\n    pair<string, char *> s = check(N);\n    if(end_flg) cout <<ans <<endl;\n    else cout <<0 <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int inf = 2000000;\n\nstring s;\nint k;\nint l[100];\n\nint lexpr(int& i);\nvoid expr(int& i, int k, char& c);\n\nint lfactor(int& i){\n    int p = 0;\n    while(isdigit(s[i])){\n        p = p * 10 + s[i++] - '0';\n    }\n    if(s[i] != '('){\n        ++i;\n        return p;\n    }\n    ++i;\n    ll m = lexpr(i);\n    ++i;\n    return (int)min(m * p, (ll)inf);\n}\n\nint lterm(int& i){\n    if(isdigit(s[i])){\n        return lfactor(i);\n    }\n    i++;\n    return 1;\n}\n\nint lexpr(int& i){\n    int p = i;\n    int m = 0;\n    while(s[i] && s[i] != ')'){\n        m += lterm(i);\n        if(m > inf){\n            m = inf;\n            break;\n        }\n    }\n    return l[p] = m;\n}\n\nint factor(int& i, int k, char& c){\n    int p = 0;\n    while(isdigit(s[i])){\n        p = p * 10 + s[i++] - '0';\n    }\n    if(s[i] != '('){\n        if(k < p){\n            c = s[i];\n        }\n        ++i;\n        return p;\n    }\n    ++i;\n    ll m = l[i];\n    if(k < m * p){\n        expr(i, k % m, c);\n        ++i;\n        return k + 1;\n    }\n    expr(i, m + 1, c);\n    ++i;\n    return m * p;\n}\n\nint term(int& i, int k, char& c){\n    if(isdigit(s[i])){\n        return factor(i, k, c);\n    }\n    if(k == 0){\n        c = s[i];\n    }\n    ++i;\n    return 1;\n}\n\nvoid expr(int& i, int k, char& c){\n    while(s[i] && s[i] != ')'){\n        int m = term(i, k, c);\n        if(k < m){\n            break;\n        }\n        k -= m;\n    }\n}\n\nint main(){\n    while(1){\n        cin >> s >> k;\n        if(s == \"0\" && k == 0){\n            break;\n        }\n        int i = 0;\n        lexpr(i);\n        i = 0;\n        char c = '0';\n        expr(i, k, c);\n        cout << c << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e17\nusing namespace std;\n\nlong long id, nowend = 0;\nstring s;\nchar ans;\n\nlong long solve(long long now, long long req);\nvoid solve2();\n\nint main() {\n  while(1) {\n    cin >> s >> id;\n    if(s == \"0\" && id == 0) break;\n    ans = '0';\n    solve2();\n    cout << ans << endl;\n  }\n  return 0;\n}\n\nlong long solve(long long now, long long req) {\n  long long cnt = 0, charcnt = 1;\n  string nows;\n  if(s[now] >= '0' && s[now] <= '9') {\n    while(s[now] >= '0' && s[now] <= '9') {\n      cnt *= 10;\n      cnt += s[now++] - '0';\n    }\n    charcnt = solve(now, req);\n    if(charcnt == -1) return -1;\n    cnt *= charcnt;\n    if(cnt > req) {\n      if(solve(now, req % charcnt) != -1)\n        ;\n      return -1;\n    }\n  }\n  else if(s[now] == '(') {\n    nowend = now;\n    while(nowend < s.size() && s[nowend] != ')') {\n      charcnt = solve(nowend, req - cnt);\n      if(charcnt == -1) return -1;\n      cnt += charcnt;\n    }\n    ++nowend;\n  }\n  else {\n    while(now < s.size() && s[now] >= 'A' && s[now] <= 'Z')\n      nows += s[now++];\n    if(req < nows.size()) {\n      ans = nows[req];\n      return -1;\n    }\n    nowend = now;\n    cnt = nows.size();\n  }\n  assert(cnt > -2);\n  return cnt;\n}\n\nvoid solve2() {\n  nowend = 0;\n  while(nowend < s.size()) {\n    long long x = solve(nowend, id);\n    if(x < 0) return;\n    id -= x;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nchar ans;\nint a;\nstring st;\nlong long int getnum() {\n\tlong long int  anum=0;\n\twhile (1) {\n\t\tif (isdigit(st[a])) {\n\t\t\tanum *= 10;\n\t\t\tanum += st[a]-'0';\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn anum;\n\t\t}\n\t}\n}\nstring getst() {\n\tstring ast;\n\twhile (1) {\n\t\tif (a == st.size())return ast;\n\t\tif ('A'<=st[a]&&st[a]<='Z') {\n\t\t\tast += st[a];\n\t\t\ta++;\n\t\t}\n\t\telse {\n\t\t\treturn ast;\n\t\t}\n\t}\n}\nstring getans(const long long int repeatnum,const int targetnum) {\n\tstring nst;\n\twhile (1) {\n\t\tif (a == st.size())return  nst;\n\t\tif (st[a] == '(') {\n\t\t\ta++;\n\t\t\tnst+=getans(repeatnum, targetnum - nst.size());\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tlong long int num=getnum();\n\t\t\tstring plusst;\n\t\t\tif (st[a] == '(') {\n\t\t\t\ta++;\n\t\t\t\tplusst= (getans(min(1000000000000,repeatnum*num), targetnum - nst.size()*repeatnum));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tplusst = st[a];\n\t\t\t\ta++;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\tnst += plusst;\n\t\t\t}\n\t\t\tif ((nst.size())*repeatnum > targetnum) {\n\t\t\t\tans = nst[targetnum % nst.size()];\n\t\t\t\tthrow(0);\n\t\t\t}\n\t\t}\n\t\telse if (st[a] == ')') {\n\t\t\ta++;\n\t\t\treturn nst;\n\t\t}\n\t\telse {\n\t\t\tstring plusst = getst();\n\t\t\tnst += plusst;\n\t\t\tif ((nst.size())*repeatnum > targetnum) {\n\t\t\t\tans = nst[targetnum % nst.size()];\n\t\t\t\tthrow(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\ta = 0;\n\t\tans = '0';\n\t\tint n;\n\t\tcin >> st >> n;\n\t\tif (st == \"0\")break;\n\t\ttry {\n\t\t\tgetans(1, n);\n\t\t}\n\t\tcatch (...) {\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstring st;\nint now = 0;\n\nstring getst(bool isone=false) {\n\tstring genom;\n\twhile (isalpha(st[now])) {\n\t\tgenom += st[now];\n\t\tnow++;\n\t\tif (isone)break;\n\t}\n\treturn genom;\n}\nint getcount() {\n\tlong long int num = 0;\n\twhile (isdigit(st[now])) {\n\t\tnum = num * 10 + st[now] - '0';\n\t\tnow++;\n\t}\n\treturn num;\n}\n\npair<string,char> check(long long int rest,long long int kakeru) {\n\tif (kakeru > 1e8) {\n\t\tkakeru = 1e8;\n\t}\n\tlong long int num = 1;\n\tstring nst;\n\tbool isstart = true;\n\tbool prenum = false;\n\twhile (1) {\n\t\tif (nst.size() > rest)return make_pair(\"\",nst[rest]);\n\t\tif (st.size() <= now)break;\n\t\tif (st[now] == '(') {\n\t\t\tnow++;\n\t\t\tpair<string,char>p=check(rest,num);\n\t\t\tif (p.second == '0') {\n\t\t\t\tnst += p.first;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn make_pair(\"\",p.second);\n\t\t\t}\n\t\t\tprenum = false;\n\t\t\tnum = 1;\n\t\t}\n\t\telse if (st[now] == ')') {\n\t\t\tnow++;\n\t\t\tbreak;\n\t\t}\n\t\telse if(isalpha(st[now])){\n\t\t\tstring genom;\n\t\t\tif (!prenum) {\n\t\t\t\tgenom = getst();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgenom = getst(true);\n\t\t\t}\n\t\t\tif (genom.size()*kakeru*num > rest) {\n\t\t\t\treturn make_pair(\"\", genom[rest%genom.size()]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//rest -= genom.size()*kakeru*num;\n\t\t\t\tfor (int i = 0; i < num; ++i) {\n\t\t\t\t\tnst += genom;\n\t\t\t\t\tif (nst.size() > 1e6)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = 1;\n\t\t\tprenum = false;\n\t\t}\n\t\telse {\n\t\t\tassert(isdigit(st[now]));\n\t\t\tnum = getcount();\n\t\t\tprenum = true;\n\t\t}\n\n\t\tisstart = false;\n\t}\n\tstring finst;\n\tfor (int i = 0; i < kakeru; ++i) {\n\t\tfinst += nst;\n\t\tif (finst.size() > 1e6)break;\n\t}\n\tif (finst.size() > rest)return make_pair(\"\",finst[rest]);\n\treturn make_pair(finst, '0');\n}\nint main() {\n\twhile (1) {\n\t\tcin >> st;\n\t\tif (st == \"0\")break;\n\t\tnow = 0;\n\t\tint n; cin >> n;\n\t\tpair<int, char>p;\n\t\tchar ans=check(n,1).second;\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct Node {\n  vector< Node * > child;\n  int64 mult;\n  int64 sum;\n  string s;\n\n  Node() : mult(1), sum(0) {}\n\n  char dfs(int pos) {\n    if(pos >= mult * sum) return '0';\n    pos %= sum;\n    if(s.size()) return s[pos];\n    for(auto &p : child) {\n      if(pos - p->mult * p->sum < 0) return p->dfs(pos);\n      pos -= p->mult * p->sum;\n    }\n    throw 0;\n  }\n};\n\nconst int64 LIM = 1 << 29;\n\nstring S;\nint ptr;\n\nNode *expr() {\n  if(S[ptr] == '(') {\n    ++ptr;\n    Node *ret = expr();\n    ++ptr;\n    return ret;\n  } else {\n    Node *root = new Node();\n    while(isdigit(S[ptr]) || isalpha(S[ptr])) {\n      Node *beet;\n      if(isalpha(S[ptr])) {\n        beet = new Node();\n        beet->s += S[ptr++];\n        beet->sum = (int) beet->s.size();\n      } else {\n        int mult = 0;\n        while(isdigit(S[ptr])) mult = mult * 10 + S[ptr++] - '0';\n        if(isalpha(S[ptr])) {\n          beet = new Node();\n          beet->s += S[ptr++];\n          beet->sum = (int) beet->s.size();\n        } else {\n          beet = expr();\n        }\n        beet->mult = mult;\n      }\n      root->sum += min(LIM, beet->mult * beet->sum);\n      root->sum = min(LIM, root->sum);\n      root->child.emplace_back(beet);\n    }\n    return root;\n  }\n}\n\n\nint main() {\n  int idx;\n  while(cin >> S >> idx, S != \"0\") {\n    ptr = 0;\n    S += \"$\";\n    auto root = expr();\n    cout << root->dfs(idx) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000100\nusing namespace std;\ntypedef pair<int,int> P;\nstring s[2];\nint n,c,f;\n\nP stoi(int x){\n  int r=0,idx=x;\n  while('0'<=s[c][idx]&&s[c][idx]<='9')r=r*10+s[c][idx]-'0',idx++;\n  return P(r,idx);\n}\n\nint main(){\n  while(1){\n    cin>>s[0]>>n;\n    if(s[0]==\"0\"&&n==0)break;\n    s[1].clear();\n    c=0;\n    f=1;\n\n    while(f){\n      f=0;\n      for(int i=0;i<(int)s[c].size();i++){\n\tint e=i;\n\twhile(s[c][e]&&!('0'<=s[c][e]&&s[c][e]<='9'))e++;\n\tif(e!=i){\n\t  s[!c]+=s[c].substr(i,e-i);\n\t  i=e;\n\t}\n\n\tif('0'<=s[c][i]&&s[c][i]<='9'){\n\t  if(!f&&n<i){\n\t    c=!c;\n\t    break;\n\t  }\n\t  f=1;\n\t  P r=stoi(i);\n\t  int dig=r.first;\n\t  int idx=r.second;\n\t  string pls;\n\t  if(s[c][idx]!='(')pls+=s[c][idx];\n\t  else{\n\t    int cls=1;\n\t    int start=idx;\n\t    while(1){\n\t      idx++;\n\t      if(s[c][idx]=='(')cls++;\n\t      if(s[c][idx]==')')cls--;\n\t      if(!cls)break;\n\t    }\n\t    pls=s[c].substr(start+1,idx-start-1);\n\t    i=idx;\n\t  }\n\t  for(int j=0;j<dig&&s[!c].size()+pls.size()<N;j++)s[!c]+=pls;\n\t}\n      }\n      s[c].clear();\n      c=!c;\n    }\n    if(s[c].size()<=n)cout<<0<<endl;\n    else cout<<s[c][n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint id, N;\nstring s;\n\nint c;\n\nint readNum(){\n\tint n = 0;\n\twhile(c < N && isdigit(s[c])) {\n\t\tn = n * 10 + (s[c] - '0');\n\t\tc++;\n\t}\n\treturn n;\n}\n\nstring readS(){\n\tstring ret;\n\tassert(s[c] != '(' && s[c] != ')');\n\twhile(c < N && 'A' <= s[c] && s[c] <= 'Z') {\n\t\tret += s[c];\n\t\tc++;\n\t}\n\treturn ret;\n}\n\nchar ans;\n\nvoid f(ll v){\n\tif(isdigit(s[c])) {\n\t\tint n = readNum();\n\t\twhile(c < N) {\n\t\t\tif(s[c] == '(') {\n\t\t\t\tc++;\n\t\t\t\tf(v * n);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(v * n);\n\t\t\t}\n\t\t\tif(s[c] == ')') {\n\t\t\t\tc++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tassert('A' <= s[c] && s[c] <= 'Z');\n\tstring ss = readS();\n\tif(ans == 0) {\n\t\tif(ss.size() * v <= id) {\n\t\t\tid -= ss.size() * v;\n\t\t\treturn;\n\t\t}\n\n\t\twhile(id >= ss.size()) id -= ss.size();\n\t\tans = ss[id];\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> s >> id, s != \"0\") {\n\t\tN = s.size();\n\t\tc = 0;\n\t\tans = 0;\n\t\twhile(c < N && ans == 0) f(1);\n\n\t\tif(ans) cout << ans << endl;\n\t\telse cout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\n\nstring S;\nsize_t cur;\nint N;\n\nint digit(){\n\tint n;\n\tn=S[cur]-'0';\n\tcur++;\n\treturn n;\n}\n\nint Number(){\n\tint n=digit();\n\twhile(isdigit(S[cur])&& cur<S.size())\n\t\tn=n*10+digit();\n\treturn n;\n}\n\nstring element(){\n\tstring s;\n\ts=S[cur++];\n\twhile(isupper(S[cur]))\n\t\ts+=S[cur++];\n\treturn s;\n}\n\nstring expression(){\n\tstring res,tmp;\n\tint n=1;\n\tif(isdigit(S[cur])&&cur<S.size())\n\t\t n=Number();\n\tif(S[cur]=='('&&S.size()){\n\t\tcur++;\n\t\ttmp=expression();\n\t\tcur++;\n\t}else if(cur<S.size()&&isupper(S[cur]))\n\t\ttmp=element();\n\tres=tmp;\n\tfor(int i=1;i<n&&res.size()<=N+1;i++)\n\t\tres+=tmp;\n\tif(cur<S.size()&&S[cur]==')')\n\t\treturn res;\n\tif(cur<S.size())\n\t\tres+=expression();\n\treturn res;\n}\nint main(void){\n\twhile(cin >> S >> N,S!=\"0\"){\n\t\tstring result;\n\t\tcur=0;\n\t\tresult=expression();\n\t\tif(result.size()<N+1)\n\t\t\tcout << '0' <<endl;\n\t\telse\n\t\t\tcout << result[N] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\nusing namespace std;\n\nint n;\nstring s;\n\nint stoi(string x){\n  stringstream ss(x);\n  int n;\n  ss >> n;\n  return n;\n}\n\nstring parse(int l, int r){\n  string res = \"\";\n  while(l<r){\n    while(l<r && s[l]<'0' || '9'<s[l]){\n      res += s[l];\n      if(n<res.size())return res;\n      l++;\n    }\n    if(l==r)return res;\n\n    string tmp = \"\";\n    do{\n      tmp += s[l];\n      l++;\n    }while('0'<=s[l] && s[l]<='9');\n\n\n    int time = stoi(tmp);\n\n    int num = 0,dif = 0;\n    while(l+dif<r){\n      if(s[l+dif] == '(')num++;\n      if(s[l+dif] == ')')num--;\n      if(!num){\n\tstring hoge;\n\tif(s[l] == '(' && s[l+dif] == ')')hoge = parse(l+1,l+dif);\n\telse hoge = parse(l,l+dif+1);\n\tfor(int i=0;i<time;i++){\n\t  res += hoge;\n\t  if(n<res.size())return res;\n\t}\n\tl += dif+1;\n\tbreak;\n      }\n      dif++;\n    }\n  }\n  return res;\n}\n    \nint main(){\n  int cnt = 0;\n  while(cin >> s >> n , s!=\"0\"||n){\n    string str = parse(0,s.size());\n\n    if(str.size()<n+1)cout << 0 << endl;\n    else cout << str[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstring s;\nint t;\nint p=0;\n\nconst int INF=1000001;\n\nint read_digit(){\n\tint res=0;\n\twhile(isdigit(s[p])){\n\t\tres*=10;\n\t\tres+=s[p++]-'0';\n\t}\n\treturn res;\n}\n\nstring calc(){\n\tstring res;\n\twhile(p<s.size()){\n\t\tif(isdigit(s[p])){\n\t\t\tint mul=read_digit();\n\t\t\tstring get;\n\t\t\tif(s[p]=='('){\n\t\t\t\tp++;\n\t\t\t\tget=calc();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tget=s[p++];\n\t\t\t}\n\t\t\tfor(int i=0;i<mul;i++){\n\t\t\t\tfor(int j=0;j<get.size();j++){\n\t\t\t\t\tif(res.size()>t) break;\n\t\t\t\t\tres+=get[j];\n\t\t\t\t}\n\t\t\t\tif(res.size()>t) break;\n\t\t\t}\n\t\t}\n\t\telse if(isupper(s[p])){\n\t\t\tif(res.size()<=t)\n\t\t\t\tres+=s[p];\n\t\t\tp++;\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>s>>t && s!=\"0\"){\n\t\tp=0;\n\t\tstring get=calc();\n\t\tif(get.size()<t+1) cout<<0<<endl;\n\t\telse cout<<get[t]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <memory>\n\nusing namespace std;\n\nstruct before_main {before_main() {cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\ntypedef shared_ptr<struct tree> tree_ptr;\n\nstruct tree {\n  string s;\n  vector<tree_ptr> children;\n  ll num = 1;\n  tree() = default;\n  tree(string s, ll num): s(s), num(num) {}\n};\n\nll read_k(string& s) {\n  stringstream ss(s);\n  int x; string t; ss >> x >> t;\n  s = t;\n  return x;\n}\n\nstring read_s(string& s) {\n  int n = s.size();\n  string t;\n  int last = -1;\n  bool br = 0;\n  rep(i, n) {\n    last = i;\n    if (!isalpha(s[i])) { br = 1; break; }\n    t.push_back(s[i]);\n  }\n  if (br) s = s.substr(last);\n  else s = \"\";\n  return t;\n}\n\nvoid consume(string& s, char expected) {\n  if (s[0] != expected) {\n    cout << \"Expected: \" << expected << endl;\n    cout << \"Remain: \" << s << endl;\n    assert(0);\n  }\n  s = s.substr(1);\n}\n\nvoid dfs(string& s, tree_ptr curr) {\n  for (; !s.empty();) {\n    if (isdigit(s[0])) {\n      ll ck = read_k(s);\n      if (isalpha(s[0])) {\n        auto c = make_shared<tree>();\n        c->num = ck;\n        c->s = read_s(s);\n        curr->children.push_back(c);\n      }\n      else {\n        consume(s, '(');\n        while(s[0] != ')') {\n          auto c = make_shared<tree>();\n          c->num = ck;\n          curr->children.push_back(c);\n          dfs(s, c);\n        }\n        consume(s, ')');\n      }\n    }\n    else {\n      curr->s = read_s(s);\n      return;\n    }\n  }\n}\n\nint stop;\nstring ans;\n\nvoid visit(tree_ptr curr, ll num) {\n\n  if(stop == 2) { return; }\n  num *= curr->num;\n  if(num >= 1001000) { num = 1001000; stop = 1; }\n\n  if (curr->children.empty()) {\n    rep(i, num) ans += curr->s;\n    if(stop) { stop ++; }\n  }\n\n  rep(i, curr->children.size()) {\n    visit(curr->children[i], num);\n  }\n}\n\nchar solve(string& s, int idx) {\n  auto root = make_shared<tree>();\n  dfs(s, root);\n  stop = 0; ans.clear();\n  visit(root, 1);\n  if(ans.size() <= idx) { return '0'; }\n//  cout << ans.size() << \" / \" << idx << endl;\n  return ans[idx];\n}\n\nint main() {\n\n  while (1) {\n    string s; cin >> s;\n    int idx; cin >> idx;\n    if (s == \"0\" && idx == 0) { break; }\n    cout << solve(s, idx) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool is_digit(char c){\n\treturn ('0' <= c && c <= '9');\n}\n\nbool is_alpha(char c){\n\treturn ('A' <= c && c <= 'Z');\n}\n\n//string型からint型に変換する\nint s_to_i(string s){\n    bool flag = false;\n    int n = 0;\n    for(unsigned int i=0 ; i < s.size() ; ++i ){\n        if( i == 0 && s[i] == '-' ){\n            flag = true;\n        }else if( s[i] >= '0' && s[i] <= '9' ){\n            n *= 10;\n            n += s[i] - '0';\n        }else{\n            break;\n        }\n    }\n    return (flag)? -n : n ;\n}\n\n//int型からstring型に変換する\nstring i_to_s(int n){\n    bool flag = false;\n    string s;\n    if( n < 0 ){\n        flag = true;\n        n *= -1;\n    }\n    do{\n        s.push_back( (n%10)+'0' );\n        n /= 10;\n    }while( n != 0 );\n    \n    reverse( s.begin() , s.end() );\n    if( flag ) \n        s.insert( s.begin() , 1 , '-' );\n    return s;\n}\n\n// s[i..j] がアルファベットのみで構成されているかどうか返す.\nbool is_genome(const string& s, int i, int j){\n\tfor(int k=i ; k <= j ; k++ ){\n\t\tif( k >= s.size() ) continue;\n\t\t\n\t\tif( !is_alpha(s[k]) ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tstring s;\n\tint k;\n\twhile( cin >> s >> k ){\n\t\tif( s == \"0\" && k == 0 ) break;\n\t\t\n\t\t// 1文字の繰り返しにも括弧 '(', ')' をつける.\n\t\tfor(int i=1 ; i < s.size() ; i++ ){\n\t\t\tif( is_digit(s[i-1]) && is_alpha(s[i]) ){\n\t\t\t\tstring str;\n\t\t\t\tstr.push_back('(');\n\t\t\t\tstr.push_back( s[i] );\n\t\t\t\tstr.push_back(')');\n\t\t\t\ts.replace( i , 1 , str );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint f[1001], h[1001] = {0};\n\t\tbool genome[1001] = {0};\n\t\tfor(int i=0 ; i < 1001 ; i++ ) f[i] = -1;\n\t\t\n\t\t// f[i] := s[i] == ')' のときの対応する'('の位置を返す. \n\t\t// 括弧の対応を調べる.\n\t\tstack<int> st;\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( s[i] == '(' ){\n\t\t\t\tst.push( i );\n\t\t\t}else if( s[i] == ')' ){\n\t\t\t\tf[i] = st.top();\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t}\n\t\t// h[i] := s[i] == ')' の対応する繰り返し数を返す.\n\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\tif( f[i] != -1 ){\n\t\t\t\tint j = f[i];\n\t\t\t\t// num := () の前の繰り返す回数の文字列\n\t\t\t\tstring num;\n\t\t\t\tfor(int j_ = j-1 ; j_ >= 0 && is_digit(s[j_]) ; j_-- ){\n\t\t\t\t\tnum.push_back( s[j_] );\n\t\t\t\t}\n\t\t\t\treverse( num.begin() , num.end() );\n\t\t\t\th[i] = s_to_i( num );\n\t\t\t\t// 対応する括弧の中がアルファベットのみで構成されているかどうか.\n\t\t\t\tgenome[i] = is_genome( s , f[i]+1 , i-1 );\n\t\t\t\t// cout << \"[\" << f[i] << \"] - [\" << i << \"] : \" << h[i];\n\t\t\t\t// cout << \" : \" << genome[i] << endl;\n\t\t\t}\n\t\t}\n\t\tchar ans = '0';\n\t\tint p=0;\n\t\tint cnt=0;\n\t\twhile( true ){\n\t\t\t// debug:\n\t\t\t/*cout << s << endl;\n\t\t\tfor(int i=0 ; i < p ; i++ ) cout << ' ';\n\t\t\tcout << '^' << endl;\n\t\t\tcout << \"i = \" << cnt << endl;*/\n\t\t\t\n\t\t\tif( s[p] == ')' ){\n\t\t\t\tint i = f[p];\n\t\t\t\t// num := () の前の繰り返す回数の文字列\n\t\t\t\tstring num;\n\t\t\t\tfor(int j = i-1 ; j >= 0 && is_digit(s[j]) ; j-- ){\n\t\t\t\t\tnum.push_back( s[j] );\n\t\t\t\t}\n\t\t\t\treverse( num.begin() , num.end() );\n\t\t\t\tint de = s_to_i(num)-1;\n\t\t\t\tstring dec_num = i_to_s( de );\n\t\t\t\tstring str = \"0\";\n\t\t\t\t\n\t\t\t\twhile( dec_num.size() != num.size() ){\n\t\t\t\t\tdec_num = str + dec_num;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint N = s_to_i( num );\n\t\t\t\tif( N > 1 ){\n\t\t\t\t\t// skip := 飛ばせる数.\n\t\t\t\t\tint skip = (p - f[p] - 1) * de;\n\t\t\t\t\t\n\t\t\t\t\t// 括弧の中がアルファベットのみで繰り返しを飛ばせるときは飛ばす.\n\t\t\t\t\tif( genome[p] && cnt + skip < k ){\n\t\t\t\t\t\tcnt += skip;\n\t\t\t\t\t\ts.replace( i-num.size() , num.size() , i_to_s(h[p]) );\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tp = f[p];\n\t\t\t\t\t\ts.replace( i-num.size() , num.size() , dec_num );\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\ts.replace( i-num.size() , num.size() , i_to_s(h[p]) );\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}else if( is_alpha(s[p]) ){\n\t\t\t\tif( cnt == k ){\n\t\t\t\t\tans = s[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tcnt++;\n\t\t\t}else{\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif( p >= s.size() ) break;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, char>;\n\nstring S;\nint n, it;\n\nint num() {\n\tint res = 0;\n\twhile (it < n && isdigit(S[it])) {\n\t\tres = res * 10 + S[it] - '0';\n\t\tit++;\n\t}\n\treturn res;\n}\n\nP parser(int t) {\n\tP res(0, '0');\n\twhile (it < n && S[it] != ')') {\n\t\tif (isdigit(S[it])) {\n\t\t\tint nm = num();\n\t\t\tif (S[it] == '(') {\n\t\t\t\tit++;\n\t\t\t\tint tmp = it;\n\t\t\t\tauto p = parser(t);\n\t\t\t\tif (p.second != '0') {\n\t\t\t\t\tres.second = p.second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (t < p.first * nm) {\n\t\t\t\t\tit = tmp;\n\t\t\t\t\tt %= p.first;\n\t\t\t\t\tres.second = parser(t).second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt -= p.first * nm;\n\t\t\t\tres.first += p.first * nm;\n\t\t\t\tassert(S[it++] == ')');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t < nm) {\n\t\t\t\t\tres.second = S[it];\n\t\t\t\t}\n\t\t\t\tt -= nm;\n\t\t\t\tres.first += nm;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (t == 0) {\n\t\t\t\tres.second = S[it];\n\t\t\t}\n\t\t\tt--;\n\t\t\tres.first++;\n\t\t\tit++;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint i;\n\twhile (cin >> S >> i, S != \"0\" || i != 0) {\n\t\tn = S.size();\n\t\tit = 0;\n\t\tcout << parser(i).second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define TEST_MODE true\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep2(i, a, b) for (int i = (a); i < (b); ++i)\n#define rrep(i, n) for (int i = (n)-1; i >= 0; --i)\n#define rrep2(i, a, b) for (int i = (a)-1; i >= b; --i)\n#define range(i, a, b, c) for (int i = a;             \\\n                               c > 0 ? i < b : i > b; \\\n                               i += c)\n#define chmax(a, b) (a = (a) < (b) ? (b) : (a))\n#define chmin(a, b) (a = (a) > (b) ? (b) : (a))\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define all(a) begin(a), end(a)\n#define ifnot(a) if (not(a))\n#define int long long\n\n#ifdef LOCAL_ENV\n\n#if TEST_MODE == true\nconst bool test = true;\n#define dump(x) cerr << #x << \" = \" << (x) << endl\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\n#else\nconst bool test = false;\n#define dump(x) \n#endif\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nconst int INF = (int)1 << 60;\nconst ll INFL = (ll)1 << 60;\nll mod_n = (int)1e9 + 7;\nconst double eps = 1e-10;\ntypedef long double Real;\n// return -1, 0, 1\nint sgn(const Real &r) { return (r > eps) - (r < -eps); }\nint sgn(const Real &a, const Real &b) { return sgn(a - b); }\n\n//.....................\nconst int MAX = (int)2e5 + 5;\n\nvector<string> split(const string &str, char sep)\n{\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while (getline(ss, buffer, sep))\n    {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\ntemplate <class InputIterator>\nint sum(InputIterator begin, InputIterator end)\n{\n    return accumulate(begin, end, 0ll);\n}\n\nvoid solve();\n\nsigned main()\n{\n    cout << fixed << setprecision(20);\n    solve();\n    while (true)\n    {\n        char s[MAX];\n        if (scanf(\"%s\", s) == EOF)\n            break;\n        int n = strlen(s);\n        for (int i = n - 1; i > -1; i--)\n        {\n            ungetc(s[i], stdin);\n        }\n        solve();\n    }\n    return 0;\n}\n\nstring s;\nint id;\n\nstruct Node {\n    int v;\n    string s;\n    vector<Node> children;\n    Node(int v_, string s_) : v(v_), s(s_){}\n    void print() {\n        if (children.size() == 0) {\n            cout << s;\n            return;\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                this->children[j].print();\n            }\n        }\n    }\n\n    int sum_v() {\n        int res = 0;\n        if (children.size() == 0) return s.size();\n        rep(i, (int)children.size()) {\n            res += children[i].sum_v();\n            if (res > (int)1e9) return (int)1e9;\n        }\n        return res * v;\n    }\n\n    char ans(int& cur_id) {\n        if (children.size() == 0) {\n            if (id - cur_id < (int)s.size()) {\\\n                return s[id - cur_id];\n            }\n            else {\n                cur_id += s.size();\n                return '0';\n            }\n        }\n        if (not (id - cur_id < sum_v()) ) {\n            cur_id += sum_v();\n            return '0';\n        }\n        rep(i, v) {\n            rep(j, (int)children.size()) {\n                char res = children[j].ans(cur_id);\n                if (isalpha(res)) return res;\n            }\n        }\n        return '0';\n    }\n};\n\nNode make_tree(int& i) {\n    Node cur_node(1, \"\");\n    while (s[i] != ')' && s[i] != '\\0') {\n        if (isdigit(s[i])) {\n            char *e;\n            int v = strtol(&s[i], &e, 10);\n            if (test) dump(e);\n            i += (e - &s[i]);\n            if (s[i] == '(') i++;\n            if (test) dump(s[i]);\n            Node child = make_tree(i);\n            child.v = v;\n            cur_node.children.push_back(child);\n            if (i < (int)s.size() && s[i] == ')') i++;\n            if (test) cout << \"2:\";\n            if (test) dump(s[i]);\n        }\n        else {\n            int start = i;\n            while (isalpha(s[i])) i++;\n            int end = i;\n            cur_node.children.push_back(Node(1, s.substr(start, end-start)));\n            if (test) dump(cur_node.children.back().s);\n        }\n    }\n    return cur_node;\n}\n\nvoid solve() {\n    cin >> s >> id;\n    if (s == \"0\") exit(0);\n    int id = 0;\n    Node root = make_tree(id);\n\n    if (false) {\n        root.print();\n        cout << endl;\n    }    \n    dump(root.sum_v());\n    \n    id = 0;\n    cout << root.ans(id) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint n;\nstring dfs(int x){\n  int a=1,t=0;\n  string str,res;\n  for(int i=x;0<a&&i<s.size();i++){\n    if('0'<=s[i]&&s[i]<='9')t*=10,t+=s[i]-'0';\n    else if(s[i]=='('&&a==1){\n      res=dfs(i+1);\n      t=max(1,t);\n      while(t--)str+=res;\n      a++;\n    }\n    else if(s[i]==')')a--;\n    else if(a==1)str+=s[i];\n  }\n  return str;\n}\nint main(){\n  while(cin>>s>>n){\n    s+=\")\";\n    string ans=dfs(0);\n    if(ans.size()>n)\n      cout<<ans[n]<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\nusing namespace std;\n\npair<string, int> solve(string s, int n){\n\tif((int)s.length() == 1){\n\t\tif(n==0) return make_pair(string(1, s[0]), 1);\n\t\treturn make_pair(\"0\", 1);\n\t}\n\t\n\tint ptr=0;\n\tint len=0;\n\twhile(ptr < (int)s.length()){\n\t\tint num=0;\n\t\twhile('0'<=s[ptr] && s[ptr]<='9'){\n\t\t\tnum = num*10 + s[ptr]-'0';\n\t\t\tptr++;\n\t\t}\n\t\tif(num==0) num=1;\n\t\t\n\t\tstring search;\n\t\tif(s[ptr] == '('){\n\t\t\tint depth=1;\n\t\t\tint rem = ptr+1;\n\t\t\tptr++;\n\t\t\twhile(depth>0){\n\t\t\t\tif(s[ptr]=='(') depth++;\n\t\t\t\tif(s[ptr]==')') depth--;\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\tsearch = s.substr(rem, ptr-rem-1);\n\t\t}else{\n\t\t\tsearch = string(1, s[ptr]);\n\t\t\tptr++;\n\t\t}\n\t\t\n\t\tpair<string, int> ret = solve(search, n-len);\n\t\tint sublen = ret.second;\n\t\tif(ret.first != \"0\")\n\t\t\treturn ret;\n\t\tif(sublen*num > n-len)\n\t\t\treturn solve(search, (n-len)%sublen);\n\t\tlen += num*sublen;\n\t}\n\treturn make_pair(\"0\", len);\n}\n\nint main(){\n\twhile(1){\n\t\tstring s;\n\t\tint n;\n\t\tcin >> s >> n;\n\t\tif(s==\"0\") break;\n\t\tcout << solve(s, n).first << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\nint k;\n\nint term(int& i, int k, char& c);\nint factor(int& i, int k, char& c);\n\nint expr(int& i, int k, char& c){\n    int l = 0;\n    while(s[i] && s[i] != ')'){\n        int t = term(i, k, c);\n        k -= t;\n        l += t;\n        if (0 > k){\n            break;\n        }\n    }\n    return l;\n}\n\nint term(int& i, int k, char& c){\n    if('0' <= s[i] && s[i] <= '9'){\n        return factor(i, k, c);\n    }\n\n    if(k == 0){\n        c = s[i];\n    }\n\n    ++i;\n    return 1;\n}\n\nint factor(int& i, int k, char& c){\n    int n = 0;\n    while('0' <= s[i] && s[i] <= '9'){\n        n = n * 10 + (s[i++] - '0');\n    }\n\n    if(s[i] != '('){\n        if(k < n){\n            c = s[i];\n        }\n        ++i;\n        return n;\n    }\n\n    ++i;\n      \n    int j = i;\n    int l = expr(i, k, c);\n    ++i;\n\n    if(ll(l) * n <= k){\n        return l * n;\n    } else {\n        i = j;\n        expr(i, k % l, c);\n        ++i;\n        return k + 1;\n    }\n}\n\nint main(){\n    while(1){\n        cin >> s >> k;\n        if(s == \"0\" && k == 0){\n            break;\n        }\n        int i = 0;\n        char c = '0';\n        expr(i, k, c);\n        cout << c << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,pos,cnt;\nstring str;\nchar ans;\n\nvoid factor();\n\nvoid exp(){\n  while(str[pos] >= 'A' && str[pos] <= 'Z' && pos < str.size()){\n    if(n == cnt) ans = str[pos];\n    pos++;\n    cnt++;\n  }\n}\n\nvoid factor(){\n  while(pos < str.size() && ans == '0' && cnt <= 1000010 && str[pos] != ')'){\n    int num = 0;\n    while(str[pos] >= '0' && str[pos] <= '9' && pos < str.size()){\n      num *= 10;\n      num += str[pos++] - '0';\n    }    \n    if(str[pos] == '('){\n      pos++;\n      int prev = pos;\n      for(int i=0;i<num;i++) {\n        if(str[pos] >= 'A' && str[pos] <= 'Z') exp();\n        else factor();\n        if(i != num - 1) pos = prev;\n      }\n      pos++;\n    } else {\n      if(num == 0) exp();\n      else {\n        if(cnt <= n && n < cnt + num) ans = str[pos];\n        cnt += num;\n        pos++;\n      }\n    }\n  }\n}\n\nvoid solve(){\n  pos = cnt = 0;\n  ans = '0';\n  factor();\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> str >> n && (str != \"0\" || n)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cctype>\n#include <iostream>\nusing namespace std;\ntypedef string::const_iterator State;\n\nstring factor(State &begin,int &n,int x);\nint number(State &begin);\nstring seq(State &begin);\n\n\nint number(State &begin){\n\tint ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nstring seq(State &begin){\n\tstring ret=\"\";\n\twhile(*begin>='A' && *begin<='Z'){\n\t\tret+=*begin;\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nstring factor(State &begin,int &n,int x){\n\tint k=1;\n\tstring str=\"\";\n\twhile(1){\n\t\tif(*begin=='('){\n\t\t\tbegin++;\n\t\t\tstring ret=factor(begin,n,x);\n\t\t\t//cout << ret << endl;\n\t\t\tbegin++;\n\t\t\tif(n>x)return ret;\n\t\t\tfor(int i=1;i<k;i++){\n\t\t\t\tstr+=ret;\n\t\t\t\tn+=ret.size();\n\t\t\t\tif(n>x){\n\t\t\t\t\tstring res=\"\";\n\t\t\t\t\tres+=ret[ret.size()-(n-x)];\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*begin>='0' && *begin<='9'){\n\t\t\tk=number(begin);\n\t\t}else if(*begin>='A' && *begin<='Z'){\n\t\t\tstring ret=seq(begin);\n\t\t\tfor(int i=0;i<k;i++){\n\t\t\t\tstr+=ret;\n\t\t\t\tn+=ret.size();\n\t\t\t\tif(n>x){\n\t\t\t\t\tstring res=\"\";\n\t\t\t\t\tres+=ret[ret.size()-(n-x)];\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk=1;\n\t\t}else break;\n\t}\n\treturn str;\n}\n\nint main(void){\n\twhile(1){\n\t\tint x;\n\t\tstring str;\n\t\tcin >> str >> x;\n\t\tif(str==\"0\" && x==0)break;\n\t\tState begin=str.begin();\n\t\tint d=0;\n\t\tstring res=factor(begin,d,x);\n\t\tif(d<=x)res=\"0\";\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n\n#define MAX_LEN 1000002\n\nusing namespace std;\n\ntypedef pair<string,int> parsed;\nparsed parse(const string &expr, int i){\n  parsed ret;\n  string s;\n\n  int d=0;\n  if( isdigit( expr[i] ) ){\n    while( isdigit( expr[i] ) ){\n      int t = expr[i++]-'0';\n      d*=10;\n      d+=t;\n    }\n  }\n\n  if( expr[i] == '(' ){\n    parsed p = parse(expr,i+1);\n    s = p.first;\n    i = p.second;\n  }else{\n    while( isalpha( expr[i] ) ){\n      s+=expr[i++];\n    }\n  }\n\n  if( d==0 )d=1;\n  for(int j = 0; j < d; ++j){\n    ret.first+=s;\n    if( ret.first.length() > MAX_LEN )\n      break;\n  }\n\n  if( i < expr.size() && expr[i] == ')' )++i;\n\n  ret.second = i;\n  return ret;\n}\n\nchar solve(const string &expr, int n){\n  parsed ans;\n  while(ans.second<expr.size()){\n    parsed p = parse(expr,ans.second);\n    ans.first += p.first;\n    ans.second = p.second;\n  }\n  if(n<0||n>=ans.first.length())return '0';\n  return ans.first[n];\n}\n\nint main(){\n  while(true){\n    string expr;\n    int n;\n    cin>>expr>>n;\n    if(expr==\"0\"&&n==0)\n      break;\n    cout << solve(expr,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 1000000000\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tdouble capacity;\n\tPath(int from = 0, int to = 0, double cost = 0, double capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nstring substrByParenthesis(string str, int open)\n{\n\tint st = 0;\n\tif (str[open] != '(') throw 1;\n\tFOR(i, open, str.size())\n\t{\n\t\tif (str[i] == ')' && --st == 0) { return str.substr(open + 1, i - open - 1); }\n\t\telse if (str[i] == '(') { st++; }\n\t}\n\tthrow 0;\n}\n\npair<int, char> decompressAndFind(const string &str, int r)\n{\n\tint p = 0;\n\tint produced = 0;\n\twhile (p < str.size())\n\t{\n\t\tint x = atoi(str.c_str() + p);\n\t\tif (x == 0) x = 1;\n\t\twhile (isdigit((unsigned int)str[p])) p++;\n\n\t\tif (str[p] == '(')\n\t\t{\n\t\t\tstring subs = substrByParenthesis(str, p);\n\t\t\tp += subs.size() + 2;\n\n\t\t\tpair<int, char> ret = decompressAndFind(subs, r);\n\t\t\tif (ret.second) { return ret; }\n\t\t\tif (ret.first * x > r) { return decompressAndFind(subs, r % ret.first); }\n\t\t\telse { r -= ret.first * x; produced += ret.first * x; }\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (r == 0) { return make_pair(0, str[p]); }\n\t\t\tr--;\n\t\t\tp++;\n\t\t\tproduced++;\n\t\t}\n\t}\n\treturn make_pair(produced, 0);\n}\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tstring input = read<string>();\n\t\tinput = regex_replace(input, regex(\"(\\\\d+)([A-Z])\"), string(\"$1($2)\"));\n\t\tint r = read<int>();\n\t\tif (input == \"0\") { break; }\n\t\tchar c = decompressAndFind(input, r).second;\n\t\tif (!c)  c = '0';\n\t\twrite(c);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  long long blen;       // tenkai go no nagasa\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n\n//\nint is_under_5digits(char * g)\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n\tdepth++;\n      if(*p==')')\n\tdepth--;\n      if(depth==0)\n\t{\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n\treturn(p-g);\n\t}\n    }\n  return(-1);\n} \nint get_1st(char * g,int l)\n{\n  int ret;\n  int i;\n  \n  if(isupper(g[0]))\n    {\n      for(i=0;i<l;i++)\n\tif(!isupper(g[i+1]))\n\t  return(i+1);\n      \n      return(l);\n    }\n  if(ret=is_under_5digits(g))\n    {\n#if DEBUG2\n      printf(\"NL=%d\\n\",ret);\n#endif\n      if(isalpha(g[ret]))\n\treturn(ret+1);\n      if(g[ret]=='(')\n\treturn(ret+1+get_close_paren(g+ret));\n    }\n}\nint is_single(char * g,int l)\n{\n  if(l==1)\n    return(isupper(g[0]));\n  else\n    return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n\n  for(i=0;i<len;i++)\n    if(!isupper(g[i]))\n      return(0);\n\n  return(-1);\n}\nint get_times(char * g,char len)\n{\n  int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n  c=0;\n  for(i=0;i<len;i++)\n    {\n      c*=10;\n      c+=(g[i]-'0');\n    }\n  return(c);\n}\nint get_len_leaf()\n{\n\n}\n\nlong long get_len_recursive(int ndp)\n{\n  long long ret;\n\n  if(Gnode[ndp].cdr == -1)\n    {\n      if(Gnode[ndp].car == -1)\n\t{\n\t  if(Gnode[ndp].coef > 1)\n\t    ret=Gnode[ndp].coef;\n\t  else\n\t    ret=Gnode[ndp].glen;\n\t  //printf(\"Le:%d\\n\",ret);\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n      else\n\t{\n\t  ret=get_len_recursive(Gnode[ndp].car)*Gnode[ndp].coef;\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n    }\n  else\n    {\n        ret=get_len_recursive(Gnode[ndp].car);\n\tret+=get_len_recursive(Gnode[ndp].cdr);\n\tGnode[ndp].blen=ret;\n\treturn(ret);\n    }\n}\n\nvoid print_all_node()\n{\n  int i,j;\n\n  for(i=0;i<=node_ptr;i++)\n    {\n      printf(\"%d:\",i);\n      printf(\"[%d]\",Gnode[i].coef);\n      printf(\"(%lld)\",Gnode[i].blen);\n      if(Gnode[i].car>0)\n\tprintf(\"%d:\",Gnode[i].car);\n      else\n\tprintf(\"*:\");\n      if(Gnode[i].cdr>0)\n\tprintf(\"%d:\",Gnode[i].cdr);\n      else\n\tprintf(\"*:\");\n      \n      for(j=0;j<Gnode[i].glen;j++)\n\t{\n\t  printf(\"%c\",Gnode[i].genum[j]);\n\t}\n      printf(\"\\n\");\n    }\n}\nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n\n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n\nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n\n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n\nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n  int l1,carp,cdrp,ret;\n    \n  //printf(\"g %s gl %d\\n\",g,gl);\n  set_node(ndp,g,gl);\n  \n  l1=get_1st(g,gl);\n\n  if(l1 < gl)\n    {\n      carp=Gnode[ndp].car = get_new_node();\n      cdrp=Gnode[ndp].cdr = get_new_node();\n      set_nodes_recursive(carp,g,l1);\n  \n      set_nodes_recursive(cdrp,&g[l1],gl-l1);\n    }\n  else if(ret=is_under_5digits(g))\n    {\n      Gnode[ndp].coef=get_times(g,ret);\n      if(g[ret]=='(')\n\t{\n\t  carp=Gnode[ndp].car = get_new_node();\n\t  Gnode[ndp].cdr = -1;\n      //printf(\"tims %d\\n\",get_times(g,ret));\n\t  set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n\t}\n      else\n\t{\n\t  Gnode[ndp].car = -1;\n\t  Gnode[ndp].genum +=ret;\n\t  Gnode[ndp].glen  -=ret;\n\t}\n    }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n\nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n  struct NODE *np;\n  np=&Gnode[ndp];\n#ifdef DEBUG  \n  printf(\"N,I=%d %d\\n\",ndp,id);\n#endif\n  if(np->blen <= id)\n    return('0');\n  if(np->cdr == -1)\n    {\n      if(np->car == -1)\n\t{\n\t  if(np->coef > 1)\n\t    {\n\t      return(np->genum[0]);\n\t    }\n\t  else\n\t    return(np->genum[id]);\n\t}\n      else\n\treturn(get_bunsi(np->car,id % Gnode[np->car].blen));\n    }\n  if(Gnode[np->car].blen > id)\n    return(get_bunsi(np->car,id));\n  else\n    return(get_bunsi(np->cdr,id-Gnode[np->car].blen));\n}\nmain()\n{\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG\n      print_all_node();\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <setjmp.h>\n\nstatic const char * e;\nstatic jmp_buf      co;\n\nstatic int expr ( int );\n\nstatic int\nterm (\n  const int n\n  )\n{\n  if ( *e == '(' )\n  {\n    int ret;\n\n    ++e;\n    ret = expr ( n );\n    ++e;\n\n    return ( ret );\n  }\n\n  if ( n == 0 )\n  {\n    printf ( \"%c\\n\", *e );\n    longjmp ( co, 1 );\n  }\n  ++e;\n\n  return ( 1 );\n}\n\nstatic int\nexpr (\n  int n\n  )\n{\n  int res = 0;\n\n  for ( ; ; )\n  {\n    const char * b;\n    int p = 0;\n    int ret;\n\n    if ( *e == ')' || *e == '\\0' ) break ;\n\n    while ( isdigit ( *e ) )\n    {\n      p = ( p * 10 ) + ( *( e++ ) - '0' );\n    }\n    p = p ? p : 1;\n\n    b = e;\n    ret = term ( n );\n    if ( n >= ret && n < ret * p )\n    {\n      e = b;\n      ret = term ( n % ret )\n          + ret * ( n / ret );\n    }\n\n    res += ret * p;\n    n   -= ret * p;\n  }\n\n  return ( res );\n}\n\n/** Application main entry point. */\nint\nmain (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  for ( ; ; )\n  {\n    char s[ 128 ];\n    int n;\n\n    scanf ( \" %s %d\", s, &n );\n    if ( n == 0 && !strcmp ( s, \"0\" ) ) break ;\n\n    e = s;\n    if ( setjmp ( co ) == 0 )\n    {\n      expr ( n );\n      puts ( \"0\" );\n    }\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nvoid judge_str(int start, int end,int coefficient);\nint count, flag, n;\nchar genome[101];\n\nint main()\n{\n\tint start, end;\n\twhile (1)\n\t{\n\t\tscanf(\"%s %d\",genome,&n);\n\t\tif (genome[0] == '0'&&n == 0) break;\n\t\t\n\t\tcount = 0;\n\t\tflag = 1;\n\t\tfor (end = 0; genome[end] != '\\0'; end++);\n\t\tjudge_str(0, end, 1);\n\t\tif (count-1 < n)printf(\"0\\n\");\n\t}\n\treturn 0;\n}\nvoid judge_str(int start, int end, int coefficient)\n{\n\tint i, t,brackets=0;\n\tint c_coef[20] = {0}, start2[20], end2[20], count_str = 0;\n\n\tfor (i=0;i<coefficient && flag;i++)\n\t{\n\t\tfor (t = start; t < end && flag; t++)\n\t\t{\n\t\t\tif ('0' <= genome[t] && genome[t] <= '9')\n\t\t\t{\n\t\t\t\tc_coef[count_str] = c_coef[count_str] * 10 + genome[t]-'0';\n\t\t\t}\n\t\t\telse if (genome[t] == '(')\n\t\t\t{\n\t\t\t\tstart2[count_str] = t+1;\n\t\t\t\tt++;\n\t\t\t\tfor (brackets = 1; brackets; t++)\n\t\t\t\t{\n\t\t\t\t\tif (genome[t] == '(')brackets++;\n\t\t\t\t\tif (genome[t] == ')')brackets--;\n\t\t\t\t}\n\t\t\t\tt--;\n\t\t\t\tend2[count_str] = t;\n\t\t\t\tjudge_str(start2[count_str],end2[count_str],c_coef[count_str]);\n\t\t\t\tcount_str++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (c_coef[count_str] != 0) judge_str(t, t + 1, c_coef[count_str]);\n\t\t\t\tcount++;\n\t\t\t\tif (count - 1 == n)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%c\\n\", genome[t]);\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1145: The Genome Database of All Space Life\n// 2017.10.1 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\nchar buf[102];\nchar ans;\n\nchar *expr();\n\nchar *factor(char *p, long long w, long long *n)\n{\n\tint k;\n\n\tif (*p == '(') {\n\t\tif ((p = expr(p+1, w, n)) == NULL) return NULL;\n\t\tp++;\n\t} else {\n\t\tchar *q = p;\n\t\twhile (isalpha(*p)) p++;\n\t\tk = p - q;\n\t\tif (w*k <= *n) *n -= w*k;\n\t\telse {\n\t\t\t*n %= k;\n\t\t\twhile (*n > 0 && isalpha(*q)) q++, (*n)--;\n\t\t\tans = *q;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn p;\n}\n\nchar *expr(char *p, long long k, long long *n)\n{\n\tlong long r;\n\n\twhile (*p) {\n\t\tif (*p == ')') break;\n\t\tr = 1; if (isdigit(*p)) {\n\t\t\tr = 0; while (isdigit(*p)) r = 10 * r + (*p++ - '0');\n\t\t}\n\t\tif ((p = factor(p, k*r, n)) == NULL) return NULL;\n\t}\n\treturn p;\n}\n\nint main()\n{\n\tlong long i;\n\n\twhile (scanf(\"%s%lld\", buf, &i) && *buf != '0') {\n\t\tans = '0';\n\t\texpr(buf, 1LL, &i);\n\t\tputchar(ans), putchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[16];\n\tchar roopstr[256];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[256];\n  char c[16];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\n';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[16];\n      char roopstr[256];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[256];\n  char answer[1024];\n  int i = 0;\n  while(1){\n    fgets(first,256,stdin);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\n')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    putchar(answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[8];\n\tchar roopstr[100];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[100];\n  char c[8];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\0';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[8];\n      char roopstr[100];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[110];\n  char answer[128];\n  int i = 0;\n  while(1){\n    gets(first);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\0')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    printf(\"%c\\n\",answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\nWA\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  long long blen;       // tenkai go no nagasa\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n\n//\nint is_under_5digits(char * g)\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n\tdepth++;\n      if(*p==')')\n\tdepth--;\n      if(depth==0)\n\t{\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n\treturn(p-g);\n\t}\n    }\n  return(-1);\n} \nint get_1st(char * g,int l)\n{\n  int ret;\n  int i;\n  \n  if(isupper(g[0]))\n    {\n      for(i=0;i<l;i++)\n\tif(!isupper(g[i+1]))\n\t  return(i+1);\n      \n      return(l);\n    }\n  if(ret=is_under_5digits(g))\n    {\n#if DEBUG2\n      printf(\"NL=%d\\n\",ret);\n#endif\n      if(isalpha(g[ret]))\n\treturn(ret+1);\n      if(g[ret]=='(')\n\treturn(ret+1+get_close_paren(g+ret));\n    }\n}\nint is_single(char * g,int l)\n{\n  if(l==1)\n    return(isupper(g[0]));\n  else\n    return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n\n  for(i=0;i<len;i++)\n    if(!isupper(g[i]))\n      return(0);\n\n  return(-1);\n}\nint get_times(char * g,char len)\n{\n  int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n  c=0;\n  for(i=0;i<len;i++)\n    {\n      c*=10;\n      c+=(g[i]-'0');\n    }\n  return(c);\n}\nint get_len_leaf()\n{\n\n}\n\nlong long get_len_recursive(int ndp)\n{\n  long long ret;\n\n  if(Gnode[ndp].cdr == -1)\n    {\n      if(Gnode[ndp].car == -1)\n\t{\n\t  if(Gnode[ndp].coef > 1)\n\t    ret=Gnode[ndp].coef;\n\t  else\n\t    ret=Gnode[ndp].glen;\n\t  //printf(\"Le:%d\\n\",ret);\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n      else\n\t{\n\t  ret=get_len_recursive(Gnode[ndp].car)*Gnode[ndp].coef;\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n    }\n  else\n    {\n        ret=get_len_recursive(Gnode[ndp].car);\n\tret+=get_len_recursive(Gnode[ndp].cdr);\n\tGnode[ndp].blen=ret;\n\treturn(ret);\n    }\n}\n\nvoid print_all_node()\n{\n  int i,j;\n\n  for(i=0;i<=node_ptr;i++)\n    {\n      printf(\"%d:\",i);\n      printf(\"[%d]\",Gnode[i].coef);\n      printf(\"(%lld)\",Gnode[i].blen);\n      if(Gnode[i].car>0)\n\tprintf(\"%d:\",Gnode[i].car);\n      else\n\tprintf(\"*:\");\n      if(Gnode[i].cdr>0)\n\tprintf(\"%d:\",Gnode[i].cdr);\n      else\n\tprintf(\"*:\");\n      \n      for(j=0;j<Gnode[i].glen;j++)\n\t{\n\t  printf(\"%c\",Gnode[i].genum[j]);\n\t}\n      printf(\"\\n\");\n    }\n}\nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n\n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n\nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n\n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n\nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n  int l1,carp,cdrp,ret;\n    \n  //printf(\"g %s gl %d\\n\",g,gl);\n  set_node(ndp,g,gl);\n  \n  l1=get_1st(g,gl);\n\n  if(l1 < gl)\n    {\n      carp=Gnode[ndp].car = get_new_node();\n      cdrp=Gnode[ndp].cdr = get_new_node();\n      set_nodes_recursive(carp,g,l1);\n  \n      set_nodes_recursive(cdrp,&g[l1],gl-l1);\n    }\n  else if(ret=is_under_5digits(g))\n    {\n      Gnode[ndp].coef=get_times(g,ret);\n      if(g[ret]=='(')\n\t{\n\t  carp=Gnode[ndp].car = get_new_node();\n\t  Gnode[ndp].cdr = -1;\n      //printf(\"tims %d\\n\",get_times(g,ret));\n\t  set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n\t}\n      else\n\t{\n\t  Gnode[ndp].car = -1;\n\t  Gnode[ndp].genum +=ret;\n\t  Gnode[ndp].glen  -=ret;\n\t}\n    }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n\nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n  struct NODE *np;\n  np=&Gnode[ndp];\n#ifdef DEBUG  \n  printf(\"N,I=%d %d\\n\",ndp,id);\n#endif\n  if(np->blen <= id)\n    return('0');\n  if(np->cdr == -1)\n    {\n      if(np->car == -1)\n\t{\n\t  if(np->coef > 1)\n\t    {\n\t      return(np->genum[0]);\n\t    }\n\t  else\n\t    return(np->genum[id]);\n\t}\n      else\n\treturn(get_bunsi(np->car,id % Gnode[np->car].blen));\n    }\n  if(Gnode[np->car].blen > id)\n    return(get_bunsi(np->car,id));\n  else\n    return(get_bunsi(np->cdr,id-Gnode[np->car].blen));\n}\nmain()\n{\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG\n      print_all_node();\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n\n*/\n#include <stdio.h>\n#include <string.h>\n\n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  long long blen;       // tenkai go no nagasa\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n\n//\nint is_under_5digits(char * g)\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n\tdepth++;\n      if(*p==')')\n\tdepth--;\n      if(depth==0)\n\t{\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n\treturn(p-g);\n\t}\n    }\n  return(-1);\n} \nint get_1st(char * g,int l)\n{\n        int ret;\n        int i;\n  \n        if(isupper(g[0]))\n        {\n                for(i=0;i<l;i++)\n                        if(!isupper(g[i+1]))\n                                return(i+1);\n                \n                return(l);\n        }\n        if(ret=is_under_5digits(g))\n        {\n#if DEBUG2\n                printf(\"NL=%d\\n\",ret);\n#endif\n                if(isalpha(g[ret]))\n                        return(ret+1);\n                if(g[ret]=='(')\n                        return(ret+1+get_close_paren(g+ret));\n        }\n}\nint is_single(char * g,int l)\n{\n        if(l==1)\n                return(isupper(g[0]));\n        else\n                return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n\n  for(i=0;i<len;i++)\n          if(!isupper(g[i]))\n                  return(0);\n  \n  return(-1);\n}\nint get_times(char * g,char len)\n{\n        int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n        c=0;\n        for(i=0;i<len;i++)\n        {\n                c*=10;\n                c+=(g[i]-'0');\n        }\n        return(c);\n}\n\n\nlong long get_len_recursive(int ndp)\n{\n        long long ret;\n        \n        if(Gnode[ndp].cdr == -1)\n        {\n                if(Gnode[ndp].car == -1)\n                {\n                        if(Gnode[ndp].coef != 1)\n                                ret=Gnode[ndp].coef;\n                        else\n                                ret=Gnode[ndp].glen;\n                        //printf(\"Le:%d\\n\",ret);\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n                else\n                {\n                        ret=get_len_recursive(Gnode[ndp].car)*Gnode[ndp].coef;\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n        }\n        else\n        {\n                ret=get_len_recursive(Gnode[ndp].car);\n                ret+=get_len_recursive(Gnode[ndp].cdr);\n                Gnode[ndp].blen=ret;\n                return(ret);\n        }\n}\n\nvoid print_all_node()\n{\n        int i;\n\n        printf(\"SEQ:COEF:LEN:CAR:CDR:STRING\\n\");\n        for(i=0;i<=node_ptr;i++)\n        {       \n                print_1_node(i);\n                printf(\"\\n\");\n        }\n}\nprint_1_node(int i)\n{\n        int j;\n\n          printf(\"%d:\",i);\n          printf(\"[%d]\",Gnode[i].coef);\n          printf(\"(%lld)\",Gnode[i].blen);\n          if(Gnode[i].car>0)\n                  printf(\"%d:\",Gnode[i].car);\n          else\n                  printf(\"*:\");\n          if(Gnode[i].cdr>0)\n                  printf(\"%d:\",Gnode[i].cdr);\n          else\n                  printf(\"*:\");\n          \n          for(j=0;j<Gnode[i].glen;j++)\n          {\n                  printf(\"%c\",Gnode[i].genum[j]);\n          }\n}\n\n\nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n\n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n\nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n\n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n\nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n        int l1,carp,cdrp,ret;\n    \n  //printf(\"g %s gl %d\\n\",g,gl);\n        set_node(ndp,g,gl);\n  \n        l1=get_1st(g,gl);\n\n        if(l1 < gl)\n        {\n                carp=Gnode[ndp].car = get_new_node();\n                cdrp=Gnode[ndp].cdr = get_new_node();\n                set_nodes_recursive(carp,g,l1);\n                \n                set_nodes_recursive(cdrp,&g[l1],gl-l1);\n        }\n        else if(ret=is_under_5digits(g))\n        {\n                Gnode[ndp].coef=get_times(g,ret);\n                if(g[ret]=='(')\n                {\n                        carp=Gnode[ndp].car = get_new_node();\n                        Gnode[ndp].cdr = -1;\n                        //printf(\"tims %d\\n\",get_times(g,ret));\n                        set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n                }\n                else\n                {\n                        Gnode[ndp].car = -1;\n                        Gnode[ndp].genum +=ret;\n                        Gnode[ndp].glen  -=ret;\n                }\n        }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n\nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n        struct NODE *np;\n\n        np=&Gnode[ndp];\n#ifdef DEBUG1  \n        print_1_node(ndp);\n        printf(\"\\t:I=%d\\n\",id);\n#endif\n        if(np->blen <= id)\n                return('0');\n        if(np->cdr == -1)\n        {\n                if(np->car == -1)\n                {\n                        if(np->coef > 1)\n                        {\n                                return(np->genum[0]);\n                        }\n                        else\n                                return(np->genum[id]);\n                }\n                else\n                        return(get_bunsi(np->car,id % Gnode[np->car].blen));\n        }\n        if(Gnode[np->car].blen > id)\n                return(get_bunsi(np->car,id));\n        else\n                return(get_bunsi(np->cdr,id-Gnode[np->car].blen));\n}\nmain()\n{\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG1\n      print_all_node();\n      printf(\"---------------\\n\");\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n \n*/\n#include <stdio.h>\n#include <string.h>\n \n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  int blen;       // tenkai go no nagasa never .GE. 1000000\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n \n//\nint is_under_5digits(char * g)\n{\n  int i;\n \n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n  \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n    depth++;\n      if(*p==')')\n    depth--;\n      if(depth==0)\n    {\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n    return(p-g);\n    }\n    }\n  return(-1);\n}\nint get_1st(char * g,int l)\n{\n        int ret;\n        int i;\n   \n        if(isupper(g[0]))\n        {\n                for(i=0;i<l;i++)\n                        if(!isupper(g[i+1]))\n                                return(i+1);\n                 \n                return(l);\n        }\n        if(ret=is_under_5digits(g))\n        {\n#if DEBUG2\n                printf(\"NL=%d\\n\",ret);\n#endif\n                if(isalpha(g[ret]))\n                        return(ret+1);\n                if(g[ret]=='(')\n                        return(ret+1+get_close_paren(g+ret));\n        }\n}\nint is_single(char * g,int l)\n{\n        if(l==1)\n                return(isupper(g[0]));\n        else\n                return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n \n  for(i=0;i<len;i++)\n          if(!isupper(g[i]))\n                  return(0);\n   \n  return(-1);\n}\nint get_times(char * g,char len)\n{\n        int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n        c=0;\n        for(i=0;i<len;i++)\n        {\n                c*=10;\n                c+=(g[i]-'0');\n        }\n        return(c);\n}\n \n \nint get_len_recursive(int ndp)\n{\n        int ret,ret1,ret2;\n         \n        if(Gnode[ndp].cdr == -1)\n        {\n                if(Gnode[ndp].car == -1)\n                {\n                        if(Gnode[ndp].coef != 1)\n                                ret=Gnode[ndp].coef;\n                        else\n                                ret=Gnode[ndp].glen;\n                        //printf(\"Le:%d\\n\",ret);\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n                else\n                {\n                        ret=get_len_recursive(Gnode[ndp].car);\n                        if(ret!=-1)\n                        {\n                                ret*=Gnode[ndp].coef;\n                                if(ret>1000000)\n                                        ret= -1;\n                        }\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n        }\n        else\n        {\n                ret1=get_len_recursive(Gnode[ndp].car);\n                ret2=get_len_recursive(Gnode[ndp].cdr);\n                if(ret1==-1 || ret2==-1)\n                        ret=-1;\n                else\n                {\n                        ret=ret1+ret2;\n                        if(ret>1000000)\n                                ret= -1;\n                }\n                Gnode[ndp].blen=ret;\n                return(ret);\n        }\n}\n \nvoid print_all_node()\n{\n        int i;\n \n        printf(\"SEQ:COEF:LEN:CAR:CDR:STRING\\n\");\n        for(i=0;i<=node_ptr;i++)\n        {      \n                print_1_node(i);\n                printf(\"\\n\");\n        }\n}\nprint_1_node(int i)\n{\n        int j;\n \n          printf(\"%d:\",i);\n          printf(\"[%d]\",Gnode[i].coef);\n          printf(\"(%d)\",Gnode[i].blen);\n          if(Gnode[i].car>0)\n                  printf(\"%d:\",Gnode[i].car);\n          else\n                  printf(\"*:\");\n          if(Gnode[i].cdr>0)\n                  printf(\"%d:\",Gnode[i].cdr);\n          else\n                  printf(\"*:\");\n           \n          for(j=0;j<Gnode[i].glen;j++)\n          {\n                  printf(\"%c\",Gnode[i].genum[j]);\n          }\n}\n \n \nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n \n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n \nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n \n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n \nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n        int l1,carp,cdrp,ret;\n     \n  //printf(\"g %s gl %d\\n\",g,gl);\n        set_node(ndp,g,gl);\n   \n        l1=get_1st(g,gl);\n \n        if(l1 < gl)\n        {\n                carp=Gnode[ndp].car = get_new_node();\n                cdrp=Gnode[ndp].cdr = get_new_node();\n                set_nodes_recursive(carp,g,l1);\n                 \n                set_nodes_recursive(cdrp,&g[l1],gl-l1);\n        }\n        else if(ret=is_under_5digits(g))\n        {\n                Gnode[ndp].coef=get_times(g,ret);\n                if(g[ret]=='(')\n                {\n                        carp=Gnode[ndp].car = get_new_node();\n                        Gnode[ndp].cdr = -1;\n                        //printf(\"tims %d\\n\",get_times(g,ret));\n                        set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n                }\n                else\n                {\n                        Gnode[ndp].car = -1;\n                        Gnode[ndp].genum +=ret;\n                        Gnode[ndp].glen  -=ret;\n                }\n        }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n \nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n        struct NODE *np;\n        int car_len;\n\n        np=&Gnode[ndp];\n#ifdef DEBUG1 \n        print_1_node(ndp);\n        printf(\"\\t:I=%d\\n\",id);\n#endif\n        if(np->car > 0)\n                car_len=Gnode[np->car].blen;\n        else\n                car_len=0;\n        \n        if(np->blen==-1)\n        {                \n                if(np->cdr == -1)\n                {\n                        if(car_len == -1)\n                                return(get_bunsi(np->car,id % car_len));\n                        else\n                                return(get_bunsi(np->car,id));\n                }\n                else\n                {\n                        if(car_len > id || car_len== -1)\n                                return(get_bunsi(np->car,id));\n                        else\n                                return(get_bunsi(np->cdr,id-car_len));\n                }       \n        }\n        else\n        {\n                if(np->blen <= id)\n                        return('0');\n                if(np->cdr == -1)\n                {\n                        if(np->car == -1)\n                        {\n                                if(np->coef > 1) // number*terminal\n                                {\n                                        return(np->genum[0]);\n                                }\n                                else             // terminal...\n                                        return(np->genum[id]);\n                        }\n                        else\n                                return(get_bunsi(np->car,id % car_len));\n                }\n                if(car_len > id)\n                        return(get_bunsi(np->car,id));\n                else\n                        return(get_bunsi(np->cdr,id-car_len));\n        }\n}\nmain()\n        {\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG1\n      print_all_node();\n      printf(\"--trace inf------------\\n\");\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n \nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[16];\n\tchar roopstr[256];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[256];\n  char c[16];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\n';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[16];\n      char roopstr[256];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[256];\n  char answer[1024];\n  int i = 0;\n  while(1){\n    fgets(first,256,stdin);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\n')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    if(answer[i]=='0')printf(\"0\\n\");\n    else printf(\"%c\\n\",answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n \n*/\n#include <stdio.h>\n#include <string.h>\n \n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  int blen;       // tenkai go no nagasa never .GE. 1000000\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n \n//\nint is_under_5digits(char * g)\n{\n  int i;\n \n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n  \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n    depth++;\n      if(*p==')')\n    depth--;\n      if(depth==0)\n    {\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n    return(p-g);\n    }\n    }\n  return(-1);\n}\nint get_1st(char * g,int l)\n{\n        int ret;\n        int i;\n   \n        if(isupper(g[0]))\n        {\n                for(i=0;i<l;i++)\n                        if(!isupper(g[i+1]))\n                                return(i+1);\n                 \n                return(l);\n        }\n        if(ret=is_under_5digits(g))\n        {\n#if DEBUG2\n                printf(\"NL=%d\\n\",ret);\n#endif\n                if(isalpha(g[ret]))\n                        return(ret+1);\n                if(g[ret]=='(')\n                        return(ret+1+get_close_paren(g+ret));\n        }\n}\nint is_single(char * g,int l)\n{\n        if(l==1)\n                return(isupper(g[0]));\n        else\n                return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n \n  for(i=0;i<len;i++)\n          if(!isupper(g[i]))\n                  return(0);\n   \n  return(-1);\n}\nint get_times(char * g,char len)\n{\n        int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n        c=0;\n        for(i=0;i<len;i++)\n        {\n                c*=10;\n                c+=(g[i]-'0');\n        }\n        return(c);\n}\n \n \nint get_len_recursive(int ndp)\n{\n        int ret,ret1,ret2;\n         \n        if(Gnode[ndp].cdr == -1)\n        {\n                if(Gnode[ndp].car == -1)\n                {\n                        if(Gnode[ndp].coef != 1)\n                                ret=Gnode[ndp].coef;\n                        else\n                                ret=Gnode[ndp].glen;\n                        //printf(\"Le:%d\\n\",ret);\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n                else\n                {\n                        ret=get_len_recursive(Gnode[ndp].car);\n                        if(ret!=-1)\n                        {\n                                ret*=Gnode[ndp].coef;\n                                if(ret>1000000)\n                                        ret= -1;\n                        }\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n        }\n        else\n        {\n                ret1=get_len_recursive(Gnode[ndp].car);\n                ret2=get_len_recursive(Gnode[ndp].cdr);\n                if(ret1==-1 || ret2==-1)\n                        ret=-1;\n                else\n                {\n                        ret=ret1+ret2;\n                        if(ret>1000000)\n                                ret= -1;\n                }\n                Gnode[ndp].blen=ret;\n                return(ret);\n        }\n}\n \nvoid print_all_node()\n{\n        int i;\n \n        printf(\"SEQ:COEF:LEN:CAR:CDR:STRING\\n\");\n        for(i=0;i<=node_ptr;i++)\n        {      \n                print_1_node(i);\n                printf(\"\\n\");\n        }\n}\nprint_1_node(int i)\n{\n        int j;\n \n          printf(\"%d:\",i);\n          printf(\"[%d]\",Gnode[i].coef);\n          printf(\"(%d)\",Gnode[i].blen);\n          if(Gnode[i].car>0)\n                  printf(\"%d:\",Gnode[i].car);\n          else\n                  printf(\"*:\");\n          if(Gnode[i].cdr>0)\n                  printf(\"%d:\",Gnode[i].cdr);\n          else\n                  printf(\"*:\");\n           \n          for(j=0;j<Gnode[i].glen;j++)\n          {\n                  printf(\"%c\",Gnode[i].genum[j]);\n          }\n}\n \n \nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n \n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n \nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n \n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n \nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n        int l1,carp,cdrp,ret;\n     \n  //printf(\"g %s gl %d\\n\",g,gl);\n        set_node(ndp,g,gl);\n   \n        l1=get_1st(g,gl);\n \n        if(l1 < gl)\n        {\n                carp=Gnode[ndp].car = get_new_node();\n                cdrp=Gnode[ndp].cdr = get_new_node();\n                set_nodes_recursive(carp,g,l1);\n                 \n                set_nodes_recursive(cdrp,&g[l1],gl-l1);\n        }\n        else if(ret=is_under_5digits(g))\n        {\n                Gnode[ndp].coef=get_times(g,ret);\n                if(g[ret]=='(')\n                {\n                        carp=Gnode[ndp].car = get_new_node();\n                        Gnode[ndp].cdr = -1;\n                        //printf(\"tims %d\\n\",get_times(g,ret));\n                        set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n                }\n                else\n                {\n                        Gnode[ndp].car = -1;\n                        Gnode[ndp].genum +=ret;\n                        Gnode[ndp].glen  -=ret;\n                }\n        }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n \nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n        struct NODE *np;\n        int car_len;\n\n        np=&Gnode[ndp];\n#ifdef DEBUG1 \n        print_1_node(ndp);\n        printf(\"\\t:I=%d\\n\",id);\n#endif\n        if(np->car > 0)\n                car_len=Gnode[np->car].blen;\n        else\n                car_len=0;\n        \n        if(np->blen==-1)\n        {                \n                if(np->cdr == -1)\n                {\n                        if(car_len != -1)\n                                return(get_bunsi(np->car,id % car_len));\n                        else\n                                return(get_bunsi(np->car,id));\n                }\n                else\n                {\n                        if(car_len > id || car_len== -1)\n                                return(get_bunsi(np->car,id));\n                        else\n                                return(get_bunsi(np->cdr,id-car_len));\n                }       \n        }\n        else\n        {\n                if(np->blen <= id)\n                        return('0');\n                if(np->cdr == -1)\n                {\n                        if(np->car == -1)\n                        {\n                                if(np->coef > 1) // number*terminal\n                                {\n                                        return(np->genum[0]);\n                                }\n                                else             // terminal...\n                                        return(np->genum[id]);\n                        }\n                        else\n                                return(get_bunsi(np->car,id % car_len));\n                }\n                if(car_len > id)\n                        return(get_bunsi(np->car,id));\n                else\n                        return(get_bunsi(np->cdr,id-car_len));\n        }\n}\nmain()\n        {\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG1\n      print_all_node();\n      printf(\"--trace inf------------\\n\");\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n \nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[16];\n\tchar roopstr[256];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[256];\n  char c[16];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\n';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[16];\n      char roopstr[256];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[256];\n  char answer[1024];\n  int i = 0;\n  while(1){\n    fgets(first,256,stdin);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\n')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    putchar(answer[i]);\n    putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n//#include<time.h>\nvoid judge_str(int start, int end,int coefficient);\nint count, flag, n;\nchar genome[101];\nint c_coef[500000] = { 0 }, start2[500000], end2[500000], count_str = 0;\n\nint main()\n{\n\tint start, end;\n\t//clock_t START, END;\n\twhile (1)\n\t{\n\t\tfor (int i = 0; i < count_str; i++) c_coef[i] = 0;\n\t\tcount_str = 0;\n\t\tscanf(\"%s %d\",genome,&n);\n\t\tif (genome[0] == '0'&&n == 0) break;\n\t\t//START = clock();\n\t\tcount = 0;\n\t\tflag = 1;\n\t\tfor (end = 0; genome[end] != '\\0'; end++);\n\t\tjudge_str(0, end, 1);\n\t\tif (count-1 < n)printf(\"0\\n\");\n\t\t//END = clock();\n\t\t//printf(\"%.2f秒かかりました\\n\", (double)(END - START) / CLOCKS_PER_SEC);\n\t}\n\treturn 0;\n}\nvoid judge_str(int start, int end, int coefficient)\n{\n\tint i, t,brackets=0;\n\n\tfor (i=0;i<coefficient && flag;i++)\n\t{\n\t\tfor (t = start; t < end && flag; t++)\n\t\t{\n\t\t\tif ('0' <= genome[t] && genome[t] <= '9')\n\t\t\t{\n\t\t\t\tc_coef[count_str] = c_coef[count_str] * 10 + genome[t]-'0';\n\t\t\t}\n\t\t\telse if (genome[t] == '(')\n\t\t\t{\n\t\t\t\tstart2[count_str] = t+1;\n\t\t\t\tt++;\n\t\t\t\tfor (brackets = 1; brackets; t++)\n\t\t\t\t{\n\t\t\t\t\tif (genome[t] == '(')brackets++;\n\t\t\t\t\tif (genome[t] == ')')brackets--;\n\t\t\t\t}\n\t\t\t\tt--;\n\t\t\t\tend2[count_str] = t;\n\t\t\t\tcount_str++;\n\t\t\t\tjudge_str(start2[count_str-1],end2[count_str-1],c_coef[count_str-1]);\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (c_coef[count_str] != 0) judge_str(t, t + 1, c_coef[count_str++]);\n\t\t\t\telse count++;\n\t\t\t\t if (count - 1 == n && flag)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%c\\n\", genome[t]);\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n\n*/\n#include <stdio.h>\n#include <string.h>\n\n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  long long blen;       // tenkai go no nagasa\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n\n//\nint is_under_5digits(char * g)\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n\tdepth++;\n      if(*p==')')\n\tdepth--;\n      if(depth==0)\n\t{\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n\treturn(p-g);\n\t}\n    }\n  return(-1);\n} \nint get_1st(char * g,int l)\n{\n        int ret;\n        int i;\n  \n        if(isupper(g[0]))\n        {\n                for(i=0;i<l;i++)\n                        if(!isupper(g[i+1]))\n                                return(i+1);\n                \n                return(l);\n        }\n        if(ret=is_under_5digits(g))\n        {\n#if DEBUG2\n                printf(\"NL=%d\\n\",ret);\n#endif\n                if(isalpha(g[ret]))\n                        return(ret+1);\n                if(g[ret]=='(')\n                        return(ret+1+get_close_paren(g+ret));\n        }\n}\nint is_single(char * g,int l)\n{\n        if(l==1)\n                return(isupper(g[0]));\n        else\n                return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n\n  for(i=0;i<len;i++)\n          if(!isupper(g[i]))\n                  return(0);\n  \n  return(-1);\n}\nint get_times(char * g,char len)\n{\n        int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n        c=0;\n        for(i=0;i<len;i++)\n        {\n                c*=10;\n                c+=(g[i]-'0');\n        }\n        return(c);\n}\n\n\nlong long get_len_recursive(int ndp)\n{\n        long long ret;\n        \n        if(Gnode[ndp].cdr == -1)\n        {\n                if(Gnode[ndp].car == -1)\n                {\n                        if(Gnode[ndp].coef != 1)\n                                ret=Gnode[ndp].coef;\n                        else\n                                ret=Gnode[ndp].glen;\n                        //printf(\"Le:%d\\n\",ret);\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n                else\n                {\n                        ret=get_len_recursive(Gnode[ndp].car)*Gnode[ndp].coef;\n                        Gnode[ndp].blen=ret;\n                        return(ret);\n                }\n        }\n        else\n        {\n                ret=get_len_recursive(Gnode[ndp].car);\n                ret+=get_len_recursive(Gnode[ndp].cdr);\n                Gnode[ndp].blen=ret;\n                return(ret);\n        }\n}\n\nvoid print_all_node()\n{\n  int i,j;\n\n  for(i=0;i<=node_ptr;i++)\n    {\n      printf(\"%d:\",i);\n      printf(\"[%d]\",Gnode[i].coef);\n      printf(\"(%lld)\",Gnode[i].blen);\n      if(Gnode[i].car>0)\n\tprintf(\"%d:\",Gnode[i].car);\n      else\n\tprintf(\"*:\");\n      if(Gnode[i].cdr>0)\n\tprintf(\"%d:\",Gnode[i].cdr);\n      else\n\tprintf(\"*:\");\n      \n      for(j=0;j<Gnode[i].glen;j++)\n\t{\n\t  printf(\"%c\",Gnode[i].genum[j]);\n\t}\n      printf(\"\\n\");\n    }\n}\nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n\n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n\nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n\n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n\nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n        int l1,carp,cdrp,ret;\n    \n  //printf(\"g %s gl %d\\n\",g,gl);\n        set_node(ndp,g,gl);\n  \n        l1=get_1st(g,gl);\n\n        if(l1 < gl)\n        {\n                carp=Gnode[ndp].car = get_new_node();\n                cdrp=Gnode[ndp].cdr = get_new_node();\n                set_nodes_recursive(carp,g,l1);\n                \n                set_nodes_recursive(cdrp,&g[l1],gl-l1);\n        }\n        else if(ret=is_under_5digits(g))\n        {\n                Gnode[ndp].coef=get_times(g,ret);\n                if(g[ret]=='(')\n                {\n                        carp=Gnode[ndp].car = get_new_node();\n                        Gnode[ndp].cdr = -1;\n                        //printf(\"tims %d\\n\",get_times(g,ret));\n                        set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n                }\n                else\n                {\n                        Gnode[ndp].car = -1;\n                        Gnode[ndp].genum +=ret;\n                        Gnode[ndp].glen  -=ret;\n                }\n        }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n\nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n        struct NODE *np;\n        np=&Gnode[ndp];\n#ifdef DEBUG  \n        printf(\"N,I=%d %d\\n\",ndp,id);\n#endif\n        if(np->blen <= id)\n                return('0');\n        if(np->cdr == -1)\n        {\n                if(np->car == -1)\n                {\n                        if(np->coef > 1)\n                        {\n                                return(np->genum[0]);\n                        }\n                        else\n                                return(np->genum[id]);\n                }\n                else\n                        return(get_bunsi(np->car,id % Gnode[np->car].blen));\n        }\n        if(Gnode[np->car].blen > id)\n                return(get_bunsi(np->car,id));\n        else\n                return(get_bunsi(np->cdr,id-Gnode[np->car].blen));\n}\nmain()\n{\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG1\n      print_all_node();\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[8];\n\tchar roopstr[100];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[100];\n  char c[8];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\n';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[8];\n      char roopstr[100];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[110];\n  char answer[128];\n  int i = 0;\n  while(1){\n    fgets(first,110,stdin);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\n')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    printf(\"%c\\n\",answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[16];\n\tchar roopstr[256];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[256];\n  char c[16];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\n';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[16];\n      char roopstr[256];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[256];\n  char answer[1024];\n  int i = 0;\n  while(1){\n    fgets(first,256,stdin);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\n')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    printf(\"%c\\n\",answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nchar input[200];\nint count;\nint target;\nchar result;\n\nvoid go_next(int repeat,int start,int end) {\n\tint repeating;\n\tint i,j,k;\n\tint kakko_nest;\n\tint next_repeat;\n\tfor(repeating=0;repeating<repeat && count<target;repeating++) {\n\t\tfor(i=start;i<end && count<target;i++) {\n\t\t\tif(isdigit(input[i])) {\n\t\t\t\tnext_repeat=input[i]-'0';\n\t\t\t\tfor(j=i+1;j<end && isdigit(input[j]);j++) {\n\t\t\t\t\tnext_repeat=next_repeat*10+(input[j]-'0');\n\t\t\t\t}\n\t\t\t\tif(input[j]=='(') {\n\t\t\t\t\tfor(k=j+1,kakko_nest=1;k<end && kakko_nest>0;k++) {\n\t\t\t\t\t\tif(input[k]=='(')kakko_nest++;\n\t\t\t\t\t\telse if(input[k]==')')kakko_nest--;\n\t\t\t\t\t}\n\t\t\t\t\tgo_next(next_repeat,j+1,k-1);\n\t\t\t\t\ti=k-1;\n\t\t\t\t} else {\n\t\t\t\t\tk=j+1;\n\t\t\t\t\tgo_next(next_repeat,j,j+1);\n\t\t\t\t\ti=j;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t\tif(count>=target)result=input[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile(1) {\n\t\tscanf(\"%s%d\",input,&target);\n\t\tif(strcmp(input,\"0\")==0 && target==0)break;\n\t\tresult='0';\n\t\tcount=-1;\n\t\tgo_next(1,0,strlen(input));\n\t\tprintf(\"%c\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[8];\n\tchar roopstr[100];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[100];\n  char c[8];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\n';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[8];\n      char roopstr[100];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[110];\n  char answer[128];\n  int i = 0;\n  while(1){\n    fgets(first,110,stdin);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\n')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    printf(\"%c\\n\",answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1145: The Genome Database of All Space Life\n// 2017.11.13 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\ntypedef struct { char *p; int n; } S;\nS stack[102]; int top;\nchar buf[102];\nchar ans[1000003];\n\nint main()\n{\n\tint w, W, n, m, k;\n\tchar *bp, *p, *q;\n\n\twhile (scanf(\"%s%d\", bp=buf, &w) && *bp != '0') {\n\t\tn = 0, p = ans, top = 0, W = w++;\n\t\twhile (*bp) {\n\t\t\tif (isdigit(*bp)) {\n\t\t\t\tn = 0; while (isdigit(*bp)) n = (n<<3) + (n<<1) + (*bp++ & 0xf);\n\t\t\t} else if (*bp == '(') {\n\t\t\t\tbp++;\n\t\t\t\tstack[top].p = p, stack[top++].n = n;\n\t\t\t\tn = 0;\n\t\t\t} else if (*bp == ')') {\n\t\t\t\tbp++;\n\t\t\t\tq = stack[--top].p, k = p-q, m = stack[top].n;\n\t\t\t\twhile (--m) {\n\t\t\t\t\tif (w - k < 0) k = w;\n\t\t\t\t\tmemcpy(p, q, k), p += k; w -= k;\n\t\t\t\t\tif (w < 0) goto done;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (n > 0) { w -= n; while (n--) *p++ = *bp; bp++; }\n\t\t\t\telse while (isalpha(*bp)) *p++ = *bp++, w--;\n\t\t\t\tif (w < 0) goto done;\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t}\ndone:\tif (p-ans <= W) putchar('0');\n\t\telse putchar(ans[W]);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint roop(int *a,int n,char *ans,int times,char str[]){\n  while(1){\n    if(times==0)return 0;\n    int i;\n    for(i=0;str[i]!='\\0';i++){\n      if(str[i]>=65&&str[i]<=90){\n\tif(*a==n)*ans=str[i];\n\t*a = *a + 1;\n      }\n      else if(str[i]>=48&&str[i]<=57){\n\tint j;\n\tint rt;\n\tchar rooptimes[8];\n\tchar roopstr[100];\n\tfor(j=i;str[j]>=48&&str[j]<=57;j++){\n\t  rooptimes[j-i] = str[j];\n\t}\n\trt = atoi(rooptimes);    \n\ti = j;\n\tif(str[i]=='('){\n\t  i++;\n\t  int bracketscount = 1;\n\t  for(j=i;bracketscount>0;j++){\n\t    roopstr[j-i] = str[j];\n\t    if(str[j]=='(')bracketscount++;\n\t    if(str[j]==')')bracketscount--;\n\t  }\n\t  roopstr[j-i-1] = '\\0';\n\t  i = j-1;\n\t}\n\telse if(str[i]>=65&&str[i]<=90){\n\t  roopstr[0] = str[i];\n\t  roopstr[1] = '\\0';\n\t}\n\troop(a,n,ans,rt,roopstr);\n      }\n      if(*ans!='0')return 0;\n    }\n    times--;\n  }\n}\nchar genome(char first[]){\n  char str[100];\n  char c[8];\n  int n;\n  int i; \n  int count=0;\n  char ans = '0';\n  char *p;\n  p = &ans;\n  for(i=0;first[i]!=' ';i++){\n    str[i]=first[i];\n  }\n  i++;\n  str[i] = '\\0';\n  n = i;\n  for(i=0;first[n]!='\\0';i++){\n    c[i]=first[n];\n    n++;\n  }\n  n = atoi(c);\n\n\n  for(i=0;str[i]!='\\0';i++){\n    if(str[i]>=65&&str[i]<=90){\n      if(count==n)ans = str[i];\n      count++;\n    }\n    else if(str[i]>=48&&str[i]<=57){\n      int j;\n      int rt;\n      char rooptimes[8];\n      char roopstr[100];\n      for(j=i;str[j]>=48&&str[j]<=57;j++){\n\trooptimes[j-i] = str[j];\n      }\n      rt = atoi(rooptimes);    \n      i = j;\n      if(str[i]=='('){\n\ti++;\n\tint bracketscount = 1;\n\tfor(j=i;bracketscount>0;j++){\n\t  roopstr[j-i] = str[j];\n\t  if(str[j]=='(')bracketscount++;\n\t  if(str[j]==')')bracketscount--;\n\t}\n\troopstr[j-i-1] = '\\0';\n\ti = j-1;\n      }\n      else if(str[i]>=65&&str[i]<=90){\n\troopstr[0] = str[i];\n\troopstr[1] = '\\0';\n      }\n      roop(&count,n,p,rt,roopstr);\n    }\n    if(ans!='0')break;\n  }\n  return ans;\n}\n\nint main(void){\n\n  char first[110];\n  char answer[128];\n  int i = 0;\n  while(1){\n    gets(first);\n    if(first[0]=='0'&&first[1]==' '&&first[2]=='0'&&first[3]=='\\0')break;\n    answer[i] = genome(first);\n    i++;\n  }\n  for(i=0;answer[i]!='\\0';i++){\n    printf(\"%c\\n\",answer[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n//#include<time.h>\nvoid judge_str(int start, int end,int coefficient);\nint count, flag, n;\nchar genome[101];\nint c_coef[500000] = { 0 }, start2[500000], end2[500000], count_str = 0;\n\nint main()\n{\n\tint start, end;\n\t//clock_t START, END;\n\twhile (1)\n\t{\n\t\tfor (int i = 0; i < count_str; i++) c_coef[i] = 0;\n\t\tcount_str = 0;\n\t\tscanf(\"%s %d\",genome,&n);\n\t\tif (genome[0] == '0'&&n == 0) break;\n\t\t//START = clock();\n\t\tcount = 0;\n\t\tflag = 1;\n\t\tfor (end = 0; genome[end] != '\\0'; end++);\n\t\tjudge_str(0, end, 1);\n\t\tif (count-1 < n)printf(\"0\\n\");\n\t\t//END = clock();\n\t\t//printf(\"%.2f秒かかりました\\n\", (double)(END - START) / CLOCKS_PER_SEC);\n\t}\n\treturn 0;\n}\nvoid judge_str(int start, int end, int coefficient)\n{\n\tint i, t,brackets=0;\n\n\tfor (i=0;i<coefficient && flag;i++)\n\t{\n\t\tfor (t = start; t < end && flag; t++)\n\t\t{\n\t\t\tif ('0' <= genome[t] && genome[t] <= '9')\n\t\t\t{\n\t\t\t\tc_coef[count_str] = c_coef[count_str] * 10 + genome[t]-'0';\n\t\t\t}\n\t\t\telse if (genome[t] == '(')\n\t\t\t{\n\t\t\t\tstart2[count_str] = t+1;\n\t\t\t\tt++;\n\t\t\t\tfor (brackets = 1; brackets; t++)\n\t\t\t\t{\n\t\t\t\t\tif (genome[t] == '(')brackets++;\n\t\t\t\t\tif (genome[t] == ')')brackets--;\n\t\t\t\t}\n\t\t\t\tt--;\n\t\t\t\tend2[count_str] = t;\n\t\t\t\tcount_str++;\n\t\t\t\tjudge_str(start2[count_str-1],end2[count_str-1],c_coef[count_str-1]);\n\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (c_coef[count_str] != 0) judge_str(t, t + 1, c_coef[count_str++]);\n\t\t\t\telse count++;\n\t\t\t\t if (count - 1 == n && flag)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%c\\n\", genome[t]);\n\t\t\t\t\tflag = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  int blen;       // tenkai go no nagasa\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n\n//\nint is_under_5digits(char * g)\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n\tdepth++;\n      if(*p==')')\n\tdepth--;\n      if(depth==0)\n\t{\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n\treturn(p-g);\n\t}\n    }\n  return(-1);\n} \nint get_1st(char * g,int l)\n{\n  int ret;\n  int i;\n  \n  if(isupper(g[0]))\n    {\n      for(i=0;i<l;i++)\n\tif(!isupper(g[i+1]))\n\t  return(i+1);\n      \n      return(l);\n    }\n  if(ret=is_under_5digits(g))\n    {\n#if DEBUG2\n      printf(\"NL=%d\\n\",ret);\n#endif\n      if(isalpha(g[ret]))\n\treturn(ret+1);\n      if(g[ret]=='(')\n\treturn(ret+1+get_close_paren(g+ret));\n    }\n}\nint is_single(char * g,int l)\n{\n  if(l==1)\n    return(isupper(g[0]));\n  else\n    return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n\n  for(i=0;i<len;i++)\n    if(!isupper(g[i]))\n      return(0);\n\n  return(-1);\n}\nint get_times(char * g,char len)\n{\n  int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n  c=0;\n  for(i=0;i<len;i++)\n    {\n      c*=10;\n      c+=(g[i]-'0');\n    }\n  return(c);\n}\nint get_len_leaf()\n{\n\n}\n\nint get_len_recursive(int ndp)\n{\n  int ret;\n\n  if(Gnode[ndp].cdr == -1)\n    {\n      if(Gnode[ndp].car == -1)\n\t{\n\t  if(Gnode[ndp].coef > 1)\n\t    ret=Gnode[ndp].coef;\n\t  else\n\t    ret=Gnode[ndp].glen;\n\t  //printf(\"Le:%d\\n\",ret);\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n      else\n\t{\n\t  ret=get_len_recursive(Gnode[ndp].car)*Gnode[ndp].coef;\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n    }\n  else\n    {\n        ret=get_len_recursive(Gnode[ndp].car);\n\tret+=get_len_recursive(Gnode[ndp].cdr);\n\tGnode[ndp].blen=ret;\n\treturn(ret);\n    }\n}\n\nvoid print_all_node()\n{\n  int i,j;\n\n  for(i=0;i<=node_ptr;i++)\n    {\n      printf(\"%d:\",i);\n      printf(\"[%d]\",Gnode[i].coef);\n      printf(\"(%d)\",Gnode[i].blen);\n      if(Gnode[i].car>0)\n\tprintf(\"%d:\",Gnode[i].car);\n      else\n\tprintf(\"*:\");\n      if(Gnode[i].cdr>0)\n\tprintf(\"%d:\",Gnode[i].cdr);\n      else\n\tprintf(\"*:\");\n      \n      for(j=0;j<Gnode[i].glen;j++)\n\t{\n\t  printf(\"%c\",Gnode[i].genum[j]);\n\t}\n      printf(\"\\n\");\n    }\n}\nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n\n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n\nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].car=-1;\n  Gnode[node_ptr].cdr=-1;\n  Gnode[node_ptr].genum=NULL;\n  Gnode[node_ptr].glen=0;\n  Gnode[node_ptr].blen=0;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\nint init_node()\n{\n  int i;\n\n  for(i=0;i<100;i++)\n    {\n      Gnode[i].car=-1;\n      Gnode[i].cdr=-1;\n      Gnode[i].genum=NULL;\n      Gnode[i].glen=0;\n      Gnode[i].blen=0;\n      Gnode[i].coef=1;\n    }\n}\n\nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n  int l1,carp,cdrp,ret;\n    \n  //printf(\"g %s gl %d\\n\",g,gl);\n  set_node(ndp,g,gl);\n  \n  l1=get_1st(g,gl);\n\n  if(l1 < gl)\n    {\n      carp=Gnode[ndp].car = get_new_node();\n      cdrp=Gnode[ndp].cdr = get_new_node();\n      set_nodes_recursive(carp,g,l1);\n  \n      set_nodes_recursive(cdrp,&g[l1],gl-l1);\n    }\n  else if(ret=is_under_5digits(g))\n    {\n      Gnode[ndp].coef=get_times(g,ret);\n      if(g[ret]=='(')\n\t{\n\t  carp=Gnode[ndp].car = get_new_node();\n\t  Gnode[ndp].cdr = -1;\n      //printf(\"tims %d\\n\",get_times(g,ret));\n\t  set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n\t}\n      else\n\t{\n\t  Gnode[ndp].car = -1;\n\t  Gnode[ndp].genum +=ret;\n\t  Gnode[ndp].glen  -=ret;\n\t}\n    }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n\nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n  struct NODE *np;\n  np=&Gnode[ndp];\n#ifdef DEBUG  \n  printf(\"N,I=%d %d\\n\",ndp,id);\n#endif\n  if(np->blen <= id)\n    return('0');\n  if(np->cdr == -1)\n    {\n      if(np->car == -1)\n\t{\n\t  if(np->coef > 1)\n\t    {\n\t      return(np->genum[0]);\n\t    }\n\t  else\n\t    return(np->genum[id]);\n\t}\n      else\n\treturn(get_bunsi(np->car,id % Gnode[np->car].blen));\n    }\n  if(Gnode[np->car].blen > id)\n    return(get_bunsi(np->car,id));\n  else\n    return(get_bunsi(np->cdr,id-Gnode[np->car].blen));\n}\nmain()\n{\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      init_node();\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG\n      print_all_node();\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1145\nTitle The Genome Database of All Space Life\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nchar s[101];\nint  idx;\nint node_ptr;\nstruct NODE\n{\n  int car;\n  int cdr;\n  char * genum;\n  int glen;       // mojiretu no nagasa\n  int blen;       // tenkai go no nagasa\n  int coef;       // keisuu < 5keta\n} Gnode[100];\n\n//\nint is_under_5digits(char * g)\n{\n  int i;\n\n  for(i=0;i<5;i++)\n    if(!isdigit(g[i]))\n      return(i);\n \n  return(5);\n}\nint get_close_paren(char * g)\n{\n  char *p;\n  int depth;\n#ifdef DEBUG2\n  printf(\"gcp=%s\\n\",g);\n#endif\n  depth=0;\n  for(p=g;*p;p++)\n    {\n      if(*p=='(')\n\tdepth++;\n      if(*p==')')\n\tdepth--;\n      if(depth==0)\n\t{\n#ifdef DEBUG2\n  printf(\"gcpA=%d\\n\",p-g);\n#endif\n\treturn(p-g);\n\t}\n    }\n  return(-1);\n} \nint get_1st(char * g,int l)\n{\n  int ret;\n  int i;\n  \n  if(isupper(g[0]))\n    {\n      for(i=0;i<l;i++)\n\tif(!isupper(g[i+1]))\n\t  return(i+1);\n      \n      return(l);\n    }\n  if(ret=is_under_5digits(g))\n    {\n#if DEBUG2\n      printf(\"NL=%d\\n\",ret);\n#endif\n      if(isalpha(g[ret]))\n\treturn(ret+1);\n      if(g[ret]=='(')\n\treturn(ret+1+get_close_paren(g+ret));\n    }\n}\nint is_single(char * g,int l)\n{\n  if(l==1)\n    return(isupper(g[0]));\n  else\n    return(isupper(g[0]) && is_single(g+1,l-1));\n}\nint all_upper(char * g,int len)\n{\n  int i;\n\n  for(i=0;i<len;i++)\n    if(!isupper(g[i]))\n      return(0);\n\n  return(-1);\n}\nint get_times(char * g,char len)\n{\n  int i,c;\n  //printf(\"T:%s %d\\n\",g,len);\n  c=0;\n  for(i=0;i<len;i++)\n    {\n      c*=10;\n      c+=(g[i]-'0');\n    }\n  return(c);\n}\nint get_len_leaf()\n{\n\n}\n\nint get_len_recursive(int ndp)\n{\n  int ret;\n\n  if(Gnode[ndp].cdr == -1)\n    {\n      if(Gnode[ndp].car == -1)\n\t{\n\t  if(Gnode[ndp].coef > 1)\n\t    ret=Gnode[ndp].coef;\n\t  else\n\t    ret=Gnode[ndp].glen;\n\t  //printf(\"Le:%d\\n\",ret);\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n      else\n\t{\n\t  ret=get_len_recursive(Gnode[ndp].car)*Gnode[ndp].coef;\n\t  Gnode[ndp].blen=ret;\n\t  return(ret);\n\t}\n    }\n  else\n    {\n        ret=get_len_recursive(Gnode[ndp].car);\n\tret+=get_len_recursive(Gnode[ndp].cdr);\n\tGnode[ndp].blen=ret;\n\treturn(ret);\n    }\n}\n\nvoid print_all_node()\n{\n  int i,j;\n\n  for(i=0;i<=node_ptr;i++)\n    {\n      printf(\"%d:\",i);\n      printf(\"[%d]\",Gnode[i].coef);\n      printf(\"(%d)\",Gnode[i].blen);\n      if(Gnode[i].car>0)\n\tprintf(\"%d:\",Gnode[i].car);\n      else\n\tprintf(\"*:\");\n      if(Gnode[i].cdr>0)\n\tprintf(\"%d:\",Gnode[i].cdr);\n      else\n\tprintf(\"*:\");\n      \n      for(j=0;j<Gnode[i].glen;j++)\n\t{\n\t  printf(\"%c\",Gnode[i].genum[j]);\n\t}\n      printf(\"\\n\");\n    }\n}\nvoid set_node(int n,char * g,int len)\n{\n  int ret;\n  //printf(\"G:%d %s %d\\n\",n,g,len);\n  Gnode[n].car = -1;\n  Gnode[n].cdr = -1;\n\n  Gnode[n].genum = g;\n  Gnode[n].glen = len;\n}\n\nint get_new_node()\n{\n  node_ptr++;\n  Gnode[node_ptr].coef=1;\n  return(node_ptr);\n}\n\nvoid set_nodes_recursive(int ndp,char * g,int gl)\n{\n  int l1,carp,cdrp,ret;\n    \n  //printf(\"g %s gl %d\\n\",g,gl);\n  set_node(ndp,g,gl);\n  \n  l1=get_1st(g,gl);\n\n  if(l1 < gl)\n    {\n      carp=Gnode[ndp].car = get_new_node();\n      cdrp=Gnode[ndp].cdr = get_new_node();\n      set_nodes_recursive(carp,g,l1);\n  \n      set_nodes_recursive(cdrp,&g[l1],gl-l1);\n    }\n  else if(ret=is_under_5digits(g))\n    {\n      Gnode[ndp].coef=get_times(g,ret);\n      if(g[ret]=='(')\n\t{\n\t  carp=Gnode[ndp].car = get_new_node();\n\t  Gnode[ndp].cdr = -1;\n      //printf(\"tims %d\\n\",get_times(g,ret));\n\t  set_nodes_recursive(carp,g+ret+1,gl-ret-2);\n\t}\n      else\n\t{\n\t  Gnode[ndp].car = -1;\n\t  Gnode[ndp].genum +=ret;\n\t  Gnode[ndp].glen  -=ret;\n\t}\n    }\n}\nvoid set_all_node()\n{\n  set_nodes_recursive(0,s,strlen(s));\n}\n\nvoid get_len_all()\n{\n  get_len_recursive(0);\n}\nchar get_bunsi(int ndp,int id)\n{\n  struct NODE *np;\n  np=&Gnode[ndp];\n#ifdef DEBUG  \n  printf(\"N,I=%d %d\\n\",ndp,id);\n#endif\n  if(np->blen <= id)\n    return('0');\n  if(np->cdr == -1)\n    {\n      if(np->car == -1)\n\t{\n\t  if(np->coef > 1)\n\t    {\n\t      return(np->genum[0]);\n\t    }\n\t  else\n\t    return(np->genum[id]);\n\t}\n      else\n\treturn(get_bunsi(np->car,id % Gnode[np->car].blen));\n    }\n  if(Gnode[np->car].blen > id)\n    return(get_bunsi(np->car,id));\n  else\n    return(get_bunsi(np->cdr,id-Gnode[np->car].blen));\n}\n\nmain()\n{\n  while(EOF!=scanf(\"%s %d\",s,&idx) && !(s[0]=='0' && s[1]=='\\0' && idx==0))\n    {\n      node_ptr=0;\n      set_all_node();\n      get_len_all();\n#ifdef DEBUG\n      print_all_node();\n#endif\n      printf(\"%c\\n\",get_bunsi(0,idx));\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "Java",
    "code": "// The Genome Database of All Space Life\nimport java.util.*;\n\npublic class Main {\n\tstatic String formula;\n\tstatic int pos;\n\tstatic int n;\n\tstatic StringBuilder sb;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tformula = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif (formula.equals(\"0\") && n == 0)\n\t\t\t\tbreak;\n\t\t\tpos = 0;\n\t\t\tsb = new StringBuilder();\n\t\t\tparse();\n\t\t\tif (n >= sb.length())\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t\tSystem.out.println(sb.charAt(n));\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic void parse() {\n\t\twhile (pos < formula.length() && sb.length() <= n + 1)\n\t\t\tterm();\n\t}\n\n\tstatic void term() {\n\t\tif (sb.length() > n + 1) {\n\t\t\tpos = formula.length();\n\t\t\treturn;\n\t\t}\n\t\tif (Character.isUpperCase(formula.charAt(pos))) {\n\t\t\tif (sb.length() <= n + 1)\n\t\t\t\tsb.append(formula.charAt(pos));\n\t\t\tpos++;\n\t\t\treturn;\n\t\t}\n\t\tint n = number();\n\t\tif (formula.charAt(pos) != '(') {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tsb.append(formula.charAt(pos));\n\t\t\tpos++;\n\t\t\treturn;\n\t\t}\n\t\tpos++;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint t = pos;\n\t\t\twhile (pos < formula.length() && formula.charAt(pos) != ')')\n\t\t\t\tterm();\n\t\t\tpos = t;\n\t\t}\n\t\twhile (pos < formula.length() && formula.charAt(pos) != ')')\n\t\t\tterm();\n\t\tpos++;\n\t\treturn;\n\t}\n\n\tstatic int number() {\n\t\tint result = 0;\n\t\twhile (Character.isDigit(formula.charAt(pos))) {\n\t\t\tresult *= 10;\n\t\t\tresult += formula.charAt(pos++) - '0';\n\t\t}\n\t\treturn result;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tchar[] a, b;\n\tint n;\n\tint id, pos;\n\t\n\tvoid A(){\n\t\twhile(true){\n\t\t\tint start = pos;\n\t\t\tint t = id;\n\t\t\tint num = 1;\n\t\t\tint goal;\n\t\t\twhile(Character.isDigit(a[id])==true) id++;\n\t\t\tif(id!=t) num = Integer.valueOf(s.substring(t,id));\n\t\t\tB();\n\t\t\t\n\t\t\tgoal = pos;\n\t\t\tfor(int i=0;i<num-1;i++){\n\t\t\t\tfor(int j=start;j<goal;j++){\n\t\t\t\t\tif(pos>n || j>n){\n\t\t\t\t\t\ti = num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tb[pos] = b[j];\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(id==a.length || a[id]==')') break;\n\t\t}\n\t}\n\t\n\tvoid B(){\n\t\tif(a[id]=='('){\n\t\t\tid++;\n\t\t\tA();\n\t\t\tid++;\n\t\t}else{\n\t\t\tint t = id;\n\t\t\twhile(id<s.length() && Character.isUpperCase(a[id])==true) id++;\n\t\t\tif(id==a.length || a[id]==')'){\n\t\t\t\tfor(int i=t;i<id;i++){\n\t\t\t\t\tif(pos>n) break;\n\t\t\t\t\tb[pos] = a[i];\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\ta = s.toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\tb = new char[n+1];\n\t\t\tArrays.fill(b,'0');\n\t\t\tid = 0;\n\t\t\tpos = 0;\n\t\t\tA();\n\t\t\tSystem.out.println(b[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tif(flg) return \"\";\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tif(flg) return \"\";\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#' || word == '(')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\tif(flg) return \"\";\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"\";\n\t\tString res = fact();\n\t\tif(flg) return \"\";\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tif(flg) return \"\";\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(flg) return \"\";\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tif(flg) return \"\";\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tfinal int MAX = 1000000 + 1;\n\t\tdata = new char[MAX];\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n\t\t\tfor(int i=0; i < MAX; i++){\n\t\t\t\tdata[i] = '\\u0000';\n\t\t\t}\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString a = \"\";\n\t\t\tString result = exp();\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < data.length;i++){\n//\t\t\t\tSystem.out.print(data[i] + \":\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    String S;\n    int I;\n    ArrayList<Character> line;\n    boolean end;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    S = sc.next();\n\t    I = sc.nextInt();\n\t    if(S.equals(\"0\") && I==0)break;\n\t    line = new ArrayList<Character>();\n\t    end = false;\n\t    splitLine(S);\n\n\t    String ans = \"\";\n\t    if(I>=line.size())ans = \"0\";\n\t    else ans = String.valueOf(line.get(I));\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    void splitLine(String s){\n\tif(end)return;\n\n\tfor(int i=0; i<s.length(); i++){\n\t    if(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0){\n\t\tint j = i+1;\n\t\tfor(j=i+1; j<s.length(); j++){\n\t\t    if(!(s.charAt(j)-'A'<=25 && s.charAt(j)-'A'>=0))break;\n\t\t}\n\t\taddLine(s.substring(i,j));\n\t\tif(end)return;\n\t\ti = j-1;\n\t    }else{\n\t\tint iL = i;\n\t\tfor(iL=i+1; iL<s.length(); iL++){\n\t\t    if(!(s.charAt(iL)<10 || s.charAt(iL)=='0'))break;\n\t\t}\n\t\tint num = 0;\n\t\tint j=iL;\n\t\tfor(j=iL; j<s.length(); j++){\n\t\t    if(s.charAt(j)=='('){num++;}\n\t\t    if(s.charAt(j)==')')num--;\n\t\t    if(num==0)break;\n\t\t}\n\t\tint count = Integer.parseInt(s.substring(i,iL));\n\t\tString newS = \"\";\n\t\tif(iL==j){\n\t\t    newS = s.substring(iL,iL+1);\n\t\t}else{\n\t\t    newS = s.substring(iL+1,j);\n\t\t}\n\t\twhile(count-->0)splitLine(newS);\n\t\ti = j;\n\t    }\n\t}\n    }\n    \n    void addLine(String s){\n\tchar[] c = s.toCharArray();\n\tfor(int i=0; i<c.length; i++){\n\t    line.add(c[i]);\n\t    if(line.size()>I){end = true; return;}\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s, t;\n\tint n;\n\t\n\tvoid func(){\n\t\tString v = s;\n\t\tString u = s;\n\t\tint id;\n\t\tint t;\n\t\twhile(true){\n\t\t\tint p = s.indexOf(')');\n\t\t\tint q = s.lastIndexOf('(', p);\n\t\t\tif(p==-1) break;\n\t\t\t\n\t\t\tu = s.substring(q+1, p);\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tid++;\n\t\t\tint r;\n\t\t\tv = s.substring(id, q);\n\t\t\tif(v.length()>0) r = Integer.valueOf(v);\n\t\t\telse r = 1;\n\t\t\t\n\t\t\tt = id;\n\t\t\tid--;\n\t\t\twhile(id!=-1 && Character.isUpperCase(s.charAt(id))==true) id--;\n\t\t\tid++;\n\t\t\tv = s.substring(id, t);\n\t\t\t\n\t\t\tStringBuffer cc = new StringBuffer(s.substring(0,t));\n\t\t\tfor(int i=0;i<r;i++) cc.append(u);\n\t\t\ts = cc.append(s.substring(p+1, s.length())).toString();\n\t\t\t\n\t\t\tv = s.substring(id, t+(p-q-1)*r);\n\t\t\tif(v.length()>n) break;\n\t\t}\n\t\tif(v.length()>n) System.out.println(s.charAt(n));\n\t\telse System.out.println(0);\n\t}\n\t\n\t\n\tvoid tf(){\n\t\tStringBuffer bb;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(Character.isUpperCase(s.charAt(i))==true){\n\t\t\t\tif(i==0 || Character.isUpperCase(s.charAt(i-1))==false){\n\t\t\t\t\tif(i==s.length()-1 || Character.isUpperCase(s.charAt(i+1))==false){\n\t\t\t\t\t\tbb = new StringBuffer();\n\t\t\t\t\t\tbb.append(s.substring(0, i)).append('(').append(s.charAt(i)).append(')').append(s.substring(i+1, s.length()));\n\t\t\t\t\t\ts = bb.toString();\n\t\t\t\t\t\ti+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif(s.compareTo(\"0\")==0 && n==0) break;\n\t\t\ttf();\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[] str;\n\tstatic int I, pos;\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tstr = sc.next().toCharArray();\n\t\t\tI = sc.nextInt();\n\t\t\tif (str[0] == '0') break;\n\t\t\tpos = 0;\n\t\t\tMid root = parseMid();\n\t\t\tSystem.out.println(root.ch(I));\n\t\t}\n\t}\n\n\tstatic Mid parseMid() {\n\t\tMid mid = new Mid();\n\t\twhile (pos < str.length && str[pos] != ')') {\n\t\t\tif (Character.isDigit(str[pos])) {\n\t\t\t\tint t = parseInt();\n\t\t\t\tif (str[pos] == '(') {\n\t\t\t\t\t++pos;\n\t\t\t\t\tMid c = parseMid();\n\t\t\t\t\t++pos;\n\t\t\t\t\tc.times = t;\n\t\t\t\t\tmid.child.add(c);\n\t\t\t\t} else {\n\t\t\t\t\tchar[] cs = new char[t];\n\t\t\t\t\tArrays.fill(cs, str[pos]);\n\t\t\t\t\tLeaf c = new Leaf(String.valueOf(cs));\n\t\t\t\t\t++pos;\n\t\t\t\t\tmid.child.add(c);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLeaf c = parseLeaf();\n\t\t\t\tmid.child.add(c);\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\n\tstatic Leaf parseLeaf() {\n\t\tint start = pos;\n\t\twhile (pos < str.length && 'A' <= str[pos] && str[pos] <= 'Z') {\n\t\t\t++pos;\n\t\t}\n\t\treturn new Leaf(String.valueOf(str, start, pos - start));\n\t}\n\n\tstatic int parseInt() {\n\t\tint ret = 0;\n\t\twhile (pos < str.length && Character.isDigit(str[pos])) {\n\t\t\tret *= 10;\n\t\t\tret += str[pos] - '0';\n\t\t\t++pos;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic abstract class Node {\n\t\tabstract long length();\n\n\t\tabstract char ch(int pos);\n\t}\n\n\tstatic class Mid extends Node {\n\t\tArrayList<Node> child = new ArrayList<Node>();\n\t\tint times = 1;\n\n\t\tlong length() {\n\t\t\tlong ret = 0;\n\t\t\tfor (Node c : child) {\n\t\t\t\tret += c.length();\n\t\t\t\tif (ret > I) break;\n\t\t\t}\n\t\t\treturn Math.min(ret * times, I + 1);\n\t\t}\n\n\t\tchar ch(int pos) {\n\t\t\tlong oneLen = 0;\n\t\t\tfor (Node c : child) {\n\t\t\t\toneLen += c.length();\n\t\t\t}\n\t\t\tif (pos / oneLen >= this.times) {\n\t\t\t\treturn '0';\n\t\t\t}\n\t\t\tpos %= oneLen;\n\t\t\tlong start = 0;\n\t\t\tfor (Node c : child) {\n\t\t\t\tlong len = c.length();\n\t\t\t\tif (pos < start + len) {\n\t\t\t\t\treturn c.ch((int) (pos - start));\n\t\t\t\t}\n\t\t\t\tstart += len;\n\t\t\t}\n\t\t\treturn '0';\n\t\t}\n\t}\n\n\tstatic class Leaf extends Node {\n\t\tString str;\n\n\t\tLeaf(String s) {\n\t\t\tthis.str = s;\n\t\t}\n\n\t\tlong length() {\n\t\t\treturn this.str.length();\n\t\t}\n\n\t\tchar ch(int pos) {\n\t\t\treturn this.str.charAt(pos);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tint idx = in.nextInt();\n\t\t\tif(s[0] == '0') break;\n\t\t\tNode base = new Node(1);\n\t\t\tcur = 0;\n\t\t\twhile(cur < s.length){\n\t\t\t\tbase.edge.add(gen());\n\t\t\t}\n\t\t\tSystem.out.println(base.dfs(idx) < 0 ? res : '0');\n\t\t}\n\t}\n\t\n\tpublic static char res;\n\tpublic static int cur;\n\tpublic static Node gen(){\n\t\tif(Character.isDigit(s[cur])){\n\t\t\tint num = 0;\n\t\t\twhile(Character.isDigit(s[cur])){\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[cur++]-'0';\n\t\t\t}\n\t\t\tif(Character.isUpperCase(s[cur])){\n\t\t\t\treturn new Node(getStr(), num);\n\t\t\t}\n\t\t\tcur++;\n\t\t\tNode node = new Node(num);\n\t\t\twhile(cur < s.length && s[cur] != ')')\n\t\t\t\tnode.edge.add(gen());\n\t\t\tcur++;\n\t\t\treturn node;\n\t\t}else{\n\t\t\treturn new Node(getStr(), 1);\n\t\t}\n\t}\n\t\n\tpublic static String getStr(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(cur < s.length && Character.isUpperCase(s[cur]))\n\t\t\tsb.append(s[cur++]);\n\t\treturn sb.toString();\n\t}\n}\n\nclass Node{\n\tArrayList<Node> edge;\n\tString str;\n\tint num;\n\tpublic Node(int num){\n\t\tedge = new ArrayList<Node>();\n\t\tthis.num = num;\n\t}\n\t\n\tpublic Node(String str, int num){\n\t\tthis.str = str;\n\t\tthis.num = num;\n\t}\n\t\n\tpublic String toString(){\n\t\tif(str != null){\n\t\t\treturn (num>1?num:\"\")+str;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num>1) sb.append(num+\"<\");\n\t\tfor(Node v: edge) sb.append(v);\n\t\tif(num>1) sb.append('>');\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic long dfs(long sidx){\n\t\t// sidx : ??????????????¢\n\t\tif(str != null){\n\t\t\tif(sidx <= str.length()*num-1){\n\t\t\t\tsidx = sidx % str.length();\n\t\t\t\tMain.res = str.charAt((int)sidx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn sidx-str.length();\n\t\t}\n\t\tlong origin = sidx;\n\t\tfor(Node v: edge){\n\t\t\tsidx = v.dfs(sidx);\n\t\t\tif(sidx<0) return sidx;\n\t\t}\n\t\tlong len = origin - sidx;\n\t\tif((origin+len)/len <= num){\n\t\t\treturn dfs(origin % len);\n\t\t}\n\t\treturn origin - num*len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    String S;\n    int I;\n    ArrayList<Character> line;\n    boolean end;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    S = sc.next();\n\t    I = sc.nextInt();\n\t    if(S.equals(\"0\") && I==0)break;\n\n\t    line = new ArrayList<Character>();\n\t    end = false;\n\t    splitLine(S);\n\n\t    String ans = \"\";\n\t    if(I>=line.size())ans = \"0\";\n\t    else ans = String.valueOf(line.get(I));\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    void splitLine(String s){\n\tif(end)return;\n\n\tfor(int i=0; i<s.length(); i++){\n\t    if(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0){\n\t\tint j = i+1;\n\t\tfor(j=i+1; j<s.length(); j++){\n\t\t    if(!(s.charAt(j)-'A'<=25 && s.charAt(j)-'A'>=0))break;\n\t\t}\n\t\taddLine(s.substring(i,j));\n\t\tif(end)return;\n\t\ti = j-1;\n\t\t\n\t    }else{\n\t\tint from = i;\n\t\tfor(from=i+1; from<s.length(); from++){\n\t\t    char c = s.charAt(from);\n\t\t    if(!(c>='0' && c<='9')) break;\n\t\t}\n\t\tint N = Integer.parseInt(s.substring(i,from));\n\n\t\tint pair = 0;\n\t\tint to=from;\n\t\tfor(to=from; to<s.length(); to++){\n\t\t    if(s.charAt(to)=='(') pair++;\n\t\t    if(s.charAt(to)==')') pair--;\n\t\t    if(pair==0)break;\n\t\t}\n\t\t\n\t\tString seq = \"\";\n\t\tif(from==to){\n\t\t    seq = s.substring(from,from+1);\n\t\t}else{\n\t\t    seq = s.substring(from+1,to);\n\t\t}\n\t\t\n\t\twhile(N-->0)splitLine(seq);\n\t\ti = to;\n\t    }\n\t}\n    }\n    \n    void addLine(String s){\n\tchar[] c = s.toCharArray();\n\tfor(int i=0; i<c.length; i++){\n\t    line.add(c[i]);\n\t    if(line.size()>I){end = true; return;}\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\n\tstatic int n;\n\tstatic int count;\n\tstatic String str;\n\tstatic boolean R;\n\tstatic void solve(int a,int b){\n\t//\tSystem.out.println(a+\" \"+b);\n\t\tint now=0;\n\t\tfor(int i=a;i<=b;i++){\n\t\t\tif('0'<=str.charAt(i)&&str.charAt(i)<='9'){\n\t\t\t\tnow*=10;\n\t\t\t\tnow+=(int)(str.charAt(i)-'0');\n\t\t\t}else if(str.charAt(i)=='('){\n\t\t\t\tif(now==0)now=1;\n\t\t\t\tint K=1;\n\t\t\t\tint j;\n\t\t\t\tfor(j=i+1;j<=b;j++){\n\t\t\t\t\tif(str.charAt(j)=='(')K++;\n\t\t\t\t\tif(str.charAt(j)==')')K--;\n\t\t\t\t\tif(K==0)break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<now;k++){\n\t\t\t\t\tsolve(i+1,j-1);\n\t\t\t\t\tif(R)return ;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t\tnow=0;\n\t\t\t}else{\n\t\t\t\tif(now==0)now=1;\n\t\t\t\tfor(int j=0;j<now;j++){\n\t\t\t\t\tif(count==n){\n\t\t\t\t\t\tSystem.out.println(str.charAt(i));\n\t\t\t\t\t\tR=true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tnow=0;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tScanner s=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tstr=s.next();\n\t\t\tint a=s.nextInt();\n\t\t\tn=a;\n\t\t\tcount=0;\n\t\t\tR=false;\n\t\t\tif(str.equals(\"0\"))break;\n\t\t\tsolve(0,str.length()-1);\n\t\t\tif(!R)System.out.println(\"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\nclass Tree {\n\tboolean leaf;\n\tString str;\n\tArrayList<Tree> nodes;\n\tArrayList<Integer> repeats;\n\tint num;\n\n\tTree() {\n\t\tstr = null;\n\t\tleaf = false;\n\t\tnodes = new ArrayList<Tree>();\n\t\trepeats = new ArrayList<Integer>();\n\t\tnum = 0;\n\t}\n\n\tvoid setStr(String s) {\n\t\tstr = s;\n\t\tleaf = true;\n\t}\n\n\tvoid addChild(Tree t, int rep) {\n\t\tnodes.add(t);\n\t\trepeats.add(rep);\n\t\tnum++;\n\t}\n\n\tlong length() {\n\t\tif (leaf)\n\t\t\treturn str.length();\n\t\tlong len = 0;\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tTree t = nodes.get(i);\n\t\t\tint rep = repeats.get(i);\n\t\t\tlen += t.length() * rep;\n\t\t}\n\t\treturn len;\n\t}\n\n\tint charAt(long index) {\n\t\tif (leaf) {\n\t\t\tif (index >= str.length())\n\t\t\t\treturn -1;\n\t\t\treturn str.charAt((int) index);\n\t\t} else {\n\t\t\tfor (int ononon = 0; ononon < num; ononon++) {\n\t\t\t\tTree t = nodes.get(ononon);\n\t\t\t\tint rep = repeats.get(ononon);\n\t\t\t\tint chr = t.charAt(index);\n\t\t\t\tif (chr != -1)\n\t\t\t\t\treturn chr;\n\t\t\t\tlong len = t.length();\n\t\t\t\tif (index - len * rep < 0) {\n\t\t\t\t\tindex %= len;\n\t\t\t\t\treturn t.charAt(index);\n\t\t\t\t} else {\n\t\t\t\t\tindex -= len * rep;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic String toString() {\n//\t\tSystem.out.println(\"tostr leaf? \" + leaf + \" \" + num);\n\t\tif (leaf)\n\t\t\treturn str;\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tTree t = nodes.get(i);\n\t\t\tint rep = repeats.get(i);\n//\t\t\tSystem.out.println(\"node rep=\" + rep);\n\t\t\tif (rep > 1) {\n\t\t\t\ts += rep + \"(\" + t + \")\";\n\t\t\t} else {\n\t\t\t\ts += t;\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n}\n\nclass SReader {\n\tint idx;\n\tString[] ss;\n\n\tSReader(String[] ss) {\n\t\tthis.ss = ss;\n\t}\n\n\tString next() {\n\t\treturn ss[idx];\n\t}\n\n\tboolean end() {\n\t\treturn idx == ss.length;\n\t}\n\n\tString read() {\n\t\treturn ss[idx++];\n\t}\n\n\tvoid read(String expected) {\n\t\tif (!read().equals(expected))\n\t\t\tthrow new RuntimeException(\"ha?\");\n\t}\n\n\tboolean readIf(String s) {\n\t\tif (ss[idx].equals(s)) {\n\t\t\tidx++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\npublic class Main {\n\tprivate static void solve() {\n\t\twhile (true) {\n\t\t\tString s = nes();\n\t\t\tif (s.equals(\"0\")) {\n\t\t\t\tnei();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s.replaceAll(\"([0-9]+)([A-Z])\", \"$1($2)\").replaceAll(\"[0-9]+|\\\\(|\\\\)\", \" $0 \").replaceAll(\" +\", \" \")\n\t\t\t\t\t.trim();\n\t\t\tString[] ss = s.split(\" \");\n\t\t\tlong idx = nei();\n\t\t\tSReader r = new SReader(ss);\n\t\t\tTree t = parseTree(r);\n\t\t\tint ONON = t.charAt(idx);\n\t\t\tif (ONON == -1)\n\t\t\t\tout(\"0\");\n\t\t\telse\n\t\t\t\tout((char) ONON);\n\t\t}\n\t}\n\n\tprivate static Tree parseTree(SReader r) {\n\t\tTree t = new Tree();\n\t\twhile (!r.end() && !r.next().equals(\")\")) {\n\t\t\tString n = r.read();\n\t\t\tif (n.replaceAll(\"[0-9]\", \"\").isEmpty()) {\n\t\t\t\tr.read(\"(\"); // \"(\"\n\t\t\t\tt.addChild(parseTree(r), Integer.parseInt(n));\n\t\t\t\tr.read(\")\"); // \")\"\n\t\t\t} else {\n\t\t\t\tTree tt = new Tree();\n\t\t\t\ttt.setStr(n);\n\t\t\t\tt.addChild(tt, 1);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(BigDecimal.valueOf(val).toPlainString());\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(float val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException | NoSuchElementException e) {\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tint idx = in.nextInt();\n\t\t\tif(s[0] == '0') break;\n\t\t\tNode base = new Node(1);\n\t\t\tcur = 0;\n\t\t\twhile(cur < s.length){\n\t\t\t\tbase.edge.add(gen());\n\t\t\t}\n\t\t\tSystem.out.println(base.dfs(idx) < 0 ? res : '0');\n\t\t}\n\t}\n\t\n\tpublic static char res;\n\tpublic static int cur;\n\tpublic static Node gen(){\n\t\tif(Character.isDigit(s[cur])){\n\t\t\tint num = 0;\n\t\t\twhile(Character.isDigit(s[cur])){\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[cur++]-'0';\n\t\t\t}\n\t\t\tif(Character.isAlphabetic(s[cur])){\n\t\t\t\treturn new Node(getStr(), num);\n\t\t\t}\n\t\t\tcur++;\n\t\t\tNode node = new Node(num);\n\t\t\twhile(cur < s.length && s[cur] != ')')\n\t\t\t\tnode.edge.add(gen());\n\t\t\tcur++;\n\t\t\treturn node;\n\t\t}else{\n\t\t\treturn new Node(getStr(), 1);\n\t\t}\n\t}\n\t\n\tpublic static String getStr(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(cur < s.length && Character.isAlphabetic(s[cur]))\n\t\t\tsb.append(s[cur++]);\n\t\treturn sb.toString();\n\t}\n}\n\nclass Node{\n\tArrayList<Node> edge;\n\tString str;\n\tint num;\n\tpublic Node(int num){\n\t\tedge = new ArrayList<Node>();\n\t\tthis.num = num;\n\t}\n\t\n\tpublic Node(String str, int num){\n\t\tthis.str = str;\n\t\tthis.num = num;\n\t}\n\t\n\tpublic String toString(){\n\t\tif(str != null){\n\t\t\treturn (num>1?num:\"\")+str;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num>1) sb.append(num+\"<\");\n\t\tfor(Node v: edge) sb.append(v);\n\t\tif(num>1) sb.append('>');\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic long dfs(long sidx){\n\t\t// sidx : ??????????????¢\n\t\tif(str != null){\n\t\t\tif(sidx <= str.length()*num-1){\n\t\t\t\tsidx = sidx % str.length();\n\t\t\t\tMain.res = str.charAt((int)sidx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn sidx-str.length();\n\t\t}\n\t\tlong origin = sidx;\n\t\tfor(Node v: edge){\n\t\t\tsidx = v.dfs(sidx);\n\t\t\tif(sidx<0) return sidx;\n\t\t}\n\t\tlong len = origin - sidx;\n\t\tif((origin+len)/len <= num){\n\t\t\treturn dfs(origin % len);\n\t\t}\n\t\treturn origin - num*len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s, t;\n\tint n;\n\t\n\tvoid func(){\n\t\tString v = s;\n\t\tString u = s;\n\t\tint id;\n\t\tint t;\n\t\twhile(true){\n\t\t\tint p = s.indexOf(')');\n\t\t\tint q = s.lastIndexOf('(', p);\n\t\t\tif(p==-1) break;\n\t\t\t\n\t\t\tu = s.substring(q+1, p);\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tid++;\n\t\t\tint r;\n\t\t\tv = s.substring(id, q);\n\t\t\tif(v.length()>0) r = Integer.valueOf(v);\n\t\t\telse r = 1;\n\t\t\t\n\t\t\tt = id;\n\t\t\tid--;\n\t\t\twhile(id!=-1 && Character.isUpperCase(s.charAt(id))==true) id--;\n\t\t\tid++;\n\t\t\tv = s.substring(id, t);\n\t\t\t\n\t\t\tStringBuffer bb = new StringBuffer();\n\t\t\tStringBuffer cc = new StringBuffer(s.substring(0,t));\n\t\t\tStringBuffer dd = new StringBuffer(v);\n\t\t\tfor(int i=0;i<r;i++) bb.append(u);\n\t\t\ts = cc.append(bb).append(s.substring(p+1, s.length())).toString();\n\t\t\t\n\t\t\tv = dd.append(bb).toString();\n\t\t\tif(v.length()>n) break;\n\t\t}\n\t\tif(v.length()>n) System.out.println(s.charAt(n));\n\t\telse System.out.println(0);\n\t}\n\t\n\t\n\tvoid tf(){\n\t\tStringBuffer bb;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(Character.isUpperCase(s.charAt(i))==true){\n\t\t\t\tif(i==0 || Character.isUpperCase(s.charAt(i-1))==false){\n\t\t\t\t\tif(i==s.length()-1 || Character.isUpperCase(s.charAt(i+1))==false){\n\t\t\t\t\t\tbb = new StringBuffer();\n\t\t\t\t\t\tbb.append(s.substring(0, i)).append('(').append(s.charAt(i)).append(')').append(s.substring(i+1, s.length()));\n\t\t\t\t\t\ts = bb.toString();\n\t\t\t\t\t\ti+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif(s.compareTo(\"0\")==0 && n==0) break;\n\t\t\ttf();\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tif(flg) return \"\";\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"\";\n\t\tString res = fact();\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tdata = new char[ansindex+1];\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString result = exp();\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < data.length;i++){\n//\t\t\t\tSystem.out.print(data[i] + \":\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tif(flg) return \"\";\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tif(flg) return \"\";\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#' || word == '(')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\tif(flg) return \"\";\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"\";\n\t\tString res = fact();\n\t\tif(flg) return \"\";\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tif(flg) return \"\";\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(flg) return \"\";\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tif(flg) return \"\";\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tfinal int MAX = 1000000 + 1;\n\t\t\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n//\t\t\tfor(int i=0; i < MAX; i++){\n//\t\t\t\tdata[i] = '\\u0000';\n//\t\t\t}\n\t\t\tdata = new char[ansindex + 1];\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString result = exp();\n\t\t\t//debug\n//\t\t\tfor(int i=0; i < data.length;i++){\n//\t\t\t\tSystem.out.print(data[i]);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package icpc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\nclass Tree {\n\tboolean leaf;\n\tString str;\n\tArrayList<Tree> nodes;\n\tArrayList<Integer> repeats;\n\tint num;\n\n\tTree() {\n\t\tstr = null;\n\t\tleaf = false;\n\t\tnodes = new ArrayList<Tree>();\n\t\trepeats = new ArrayList<Integer>();\n\t\tnum = 0;\n\t}\n\n\tvoid setStr(String s) {\n\t\tstr = s;\n\t\tleaf = true;\n\t}\n\n\tvoid addChild(Tree t, int rep) {\n\t\tnodes.add(t);\n\t\trepeats.add(rep);\n\t\tnum++;\n\t}\n\n\tlong length() {\n\t\tif (leaf)\n\t\t\treturn str.length();\n\t\tlong len = 0;\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tTree t = nodes.get(i);\n\t\t\tint rep = repeats.get(i);\n\t\t\tlen += t.length() * rep;\n\t\t}\n\t\treturn len;\n\t}\n\n\tint charAt(long index) {\n\t\tif (leaf) {\n\t\t\tif (index >= str.length())\n\t\t\t\treturn -1;\n\t\t\treturn str.charAt((int) index);\n\t\t} else {\n\t\t\tfor (int ononon = 0; ononon < num; ononon++) {\n\t\t\t\tTree t = nodes.get(ononon);\n\t\t\t\tint rep = repeats.get(ononon);\n\t\t\t\tint chr = t.charAt(index);\n\t\t\t\tif (chr != -1)\n\t\t\t\t\treturn chr;\n\t\t\t\tlong len = t.length();\n\t\t\t\tif (index - len * rep < 0) {\n\t\t\t\t\tindex %= len;\n\t\t\t\t\treturn t.charAt(index);\n\t\t\t\t} else {\n\t\t\t\t\tindex -= len * rep;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tpublic String toString() {\n//\t\tSystem.out.println(\"tostr leaf? \" + leaf + \" \" + num);\n\t\tif (leaf)\n\t\t\treturn str;\n\t\tString s = \"\";\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tTree t = nodes.get(i);\n\t\t\tint rep = repeats.get(i);\n//\t\t\tSystem.out.println(\"node rep=\" + rep);\n\t\t\tif (rep > 1) {\n\t\t\t\ts += rep + \"(\" + t + \")\";\n\t\t\t} else {\n\t\t\t\ts += t;\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n}\n\nclass SReader {\n\tint idx;\n\tString[] ss;\n\n\tSReader(String[] ss) {\n\t\tthis.ss = ss;\n\t}\n\n\tString next() {\n\t\treturn ss[idx];\n\t}\n\n\tboolean end() {\n\t\treturn idx == ss.length;\n\t}\n\n\tString read() {\n\t\treturn ss[idx++];\n\t}\n\n\tvoid read(String expected) {\n\t\tif (!read().equals(expected))\n\t\t\tthrow new RuntimeException(\"ha?\");\n\t}\n\n\tboolean readIf(String s) {\n\t\tif (ss[idx].equals(s)) {\n\t\t\tidx++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\npublic class Main {\n\tprivate static void solve() {\n\t\twhile (true) {\n\t\t\tString s = nes();\n\t\t\tif (s.equals(\"0\")) {\n\t\t\t\tnei();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s.replaceAll(\"([0-9]+)([A-Z])\", \"$1($2)\").replaceAll(\"[0-9]+|\\\\(|\\\\)\", \" $0 \").replaceAll(\" +\", \" \")\n\t\t\t\t\t.trim();\n\t\t\tString[] ss = s.split(\" \");\n\t\t\tlong idx = nei();\n\t\t\tSReader r = new SReader(ss);\n\t\t\tTree t = parseTree(r);\n\t\t\tint ONON = t.charAt(idx);\n\t\t\tif (ONON == -1)\n\t\t\t\tout(\"0\");\n\t\t\telse\n\t\t\t\tout((char) ONON);\n\t\t}\n\t}\n\n\tprivate static Tree parseTree(SReader r) {\n\t\tTree t = new Tree();\n\t\twhile (!r.end() && !r.next().equals(\")\")) {\n\t\t\tString n = r.read();\n\t\t\tif (n.replaceAll(\"[0-9]\", \"\").isEmpty()) {\n\t\t\t\tr.read(\"(\"); // \"(\"\n\t\t\t\tt.addChild(parseTree(r), Integer.parseInt(n));\n\t\t\t\tr.read(\")\"); // \")\"\n\t\t\t} else {\n\t\t\t\tTree tt = new Tree();\n\t\t\t\ttt.setStr(n);\n\t\t\t\tt.addChild(tt, 1);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(BigDecimal.valueOf(val).toPlainString());\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(float val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException | NoSuchElementException e) {\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tchar[] b;\n\tboolean[] f;\n\tint n;\n\t\n\tvoid func(){\n\t\tString u;\n\t\tint pos = 0;\n\t\tint p, q, r, t, id;\n\t\tboolean flag = false;\n\t\twhile(true){\n\t\t\tt = 0;\n\t\t\twhile(true){\n\t\t\t\tp = s.indexOf(')', t);\n\t\t\t\tif(p==-1 || f[p]==false) break;\n\t\t\t\tt = p+1;\n\t\t\t}\n\t\t\tt = p;\n\t\t\twhile(true){\n\t\t\t\tq = s.lastIndexOf('(', t);\n\t\t\t\tif(q==-1 || f[q]==false) break;\n\t\t\t\tt = q-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1 && q==-1) break;\n\t\t\t\n\t\t\tf[p] = true;\n\t\t\tf[q] = true;\n\t\t\tr = 1;\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tu = s.substring(id+1, q);\n\t\t\tif(u.compareTo(\"\")!=0) r = Integer.valueOf(u); \n\t\t\t\n\t\t\tif(f[p-1]==false){\n\t\t\t\tu = s.substring(q+1,p);\n\t\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\t\tfor(int j=0;j<p-q-1;j++){\n\t\t\t\t\t\tb[pos] = u.charAt(j);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = t;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tt = pos;\n\t\t\t\tfor(int i=0;i<r-1;i++){\n\t\t\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\t\t\tb[pos] = b[j];\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = t;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true) break;\n\t\t}\n\t}\n\t\n\tString tf(char[] a){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(Character.isUpperCase(a[i])==true\n\t\t\t\t&& (i==0 || Character.isUpperCase(a[i-1])==false)\n\t\t\t\t\t&& (i==a.length-1 || Character.isUpperCase(a[i+1])==false)){\n\t\t\t\t\t\tsb.append('(').append(a[i]).append(')');\n\t\t\t}else{\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tchar[] a = sc.next().toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\ts = tf(a);\n\t\t\tif(s.indexOf(')')==-1) s = '(' + s + ')';\n\t\t\tf = new boolean[s.length()];\n\t\t\tb = new char[n+1];\n\t\t\tArrays.fill(b,'0');\n\t\t\tfunc();\n\t\t\tSystem.out.println(b[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static class Compress{\n\t\tint times;\n\t\tCompress child;\n\t\tCompress next;\n\t\tString input;\n\t\t\n\t\tpublic Compress(int times, Compress child, Compress next, String input) {\n\t\t\tsuper();\n\t\t\tthis.times = times;\n\t\t\tthis.child = child;\n\t\t\tthis.next = next;\n\t\t\tthis.input = input;\n\t\t}\n\t\t\n\t\tpublic long get_ch_next_len(){\n\t\t\tlong len = 0;\n\t\t\tif(this.child != null){\n\t\t\t\tlen = this.child.get_ch_next_len();\n\t\t\t}else{\n\t\t\t\tlen = input.length();\n\t\t\t}\n\t\t\tlen *= this.times;\n\t\t\t\n\t\t\tif(this.next != null){\n\t\t\t\tlen += this.next.get_ch_next_len();\n\t\t\t}\n\t\t\t\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tprivate long calc(){\n\t\t\treturn this.get_ch_next_len();\n\t\t}\n\t\t\n\t\tprivate long calc2(){\n\t\t\tlong len = 0;\n\t\t\t\n\t\t\tif(this.child != null){\n\t\t\t\tlen += this.child.get_ch_next_len();\n\t\t\t}else{\n\t\t\t\tlen += this.input.length();\n\t\t\t}\n\t\t\tlen *= this.times;\n\t\t\t\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tpublic char get_ch(long N, int times){\n\t\t\t//System.out.println(this + \" \" + N);\n\t\t\tchar ret = '0';\n\t\t\t\n\t\t\tif(this.child != null){\n\t\t\t\tret = this.child.get_ch(N, this.times);\n\t\t\t}\n\t\t\t\n\t\t\tif(ret != '0'){\n\t\t\t\treturn ret;\n\t\t\t}else{\n\t\t\t\tlong len = this.calc();\n\t\t\t\t\n\t\t\t\t//System.out.println(this.toString() + \" \" + N + \" \" + len);\n\t\t\t\n\t\t\t\tif(N < len * times){\n\t\t\t\t\tlong len2 = this.calc2();\n\t\t\t\t\tlong rest = N % len;\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(\"> \" + this.toString() + \" \" + rest + \" \" + len2);\n\t\t\t\t\t\n\t\t\t\t\tif(this.child != null && rest < len2){\n\t\t\t\t\t\treturn this.child.get_ch(rest % len2, this.times);\n\t\t\t\t\t}else if(this.input != null && rest < len2){\n\t\t\t\t\t\treturn this.input.charAt((int) (rest % this.input.length()));\n\t\t\t\t\t}else if(this.next != null && rest >= len2){\n\t\t\t\t\t\treturn this.next.get_ch(rest - len2, times);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn '0';\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\treturn '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tsb.append(times);\n\t\t\t\n\t\t\tif(this.child != null){\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(this.child.toString());\n\t\t\t\tsb.append(\")\");\n\t\t\t}else{\n\t\t\t\tsb.append(this.input);\n\t\t\t}\n\t\t\t\n\t\t\tif(this.next != null){\n\t\t\t\tsb.append(this.next.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\t\n\tpublic static Compress parse(char[] input, int start , int end){\n\t\t\n\t\tint times = 0;\n\t\tint loop_start = start;\n\t\t\n\t\twhile(loop_start <= end){\n\t\t\tif('0' <= input[loop_start] && input[loop_start] <= '9'){\n\t\t\t\ttimes *= 10;\n\t\t\t\ttimes += input[loop_start] - '0';\n\t\t\t\tloop_start++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean kakko_found = false;\n\t\tint kakko_lv = 0;\n\t\tint kakko_start = -1;\n\t\tint kakko_end = -1;\n\t\t\n\t\tCompress ret = new Compress(times, null, null, \"\");\n\t\t\n\t\tfor(int cur = loop_start; cur <= end; cur++){\n\t\t\tif(input[cur] == '('){\n\t\t\t\tkakko_found = true;\n\t\t\t\t\n\t\t\t\tif(kakko_lv == 0){\n\t\t\t\t\tkakko_start = cur;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkakko_lv++;\n\t\t\t}else if(input[cur] == ')'){\n\t\t\t\tkakko_lv--;\n\t\t\t\t\n\t\t\t\tif(kakko_lv == 0){\n\t\t\t\t\tkakko_end = cur;\n\t\t\t\t\t\n\t\t\t\t\tret.child = parse(input, kakko_start + 1, kakko_end - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!kakko_found){\n\t\t\tret.times = times == 0 ? 1 : times;\n\t\t\t\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(input[loop_start]);\n\t\t\t\n\t\t\tret.input = sb.toString();\n\t\t\tkakko_end = loop_start;\n\t\t}\n\t\t\n\t\tif(kakko_end < end){\n\t\t\tret.next = parse(input, kakko_end + 1, end);\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal String input = sc.next();\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(\"0\".equals(input) && N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tCompress comp = parse(input.toCharArray(), 0, input.length() - 1);\n\t\t\t\n\t\t\t//System.out.println(comp);\n\t\t\t\n\t\t\tSystem.out.println(comp.get_ch(N, 1));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s, t;\n\tint n;\n\t\n\tvoid func(){\n\t\tString v = s;\n\t\tString u = s;\n\t\tint id;\n\t\tint t;\n\t\twhile(true){\n\t\t\tint p = s.indexOf(')');\n\t\t\tint q = s.lastIndexOf('(', p);\n\t\t\tif(p==-1) break;\n\t\t\t\n\t\t\tu = s.substring(q+1, p);\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tid++;\n\t\t\tint r;\n\t\t\tv = s.substring(id, q);\n\t\t\tif(v.length()>0) r = Integer.valueOf(v);\n\t\t\telse r = 1;\n\t\t\t\n\t\t\tt = id;\n\t\t\tid--;\n\t\t\twhile(id!=-1 && Character.isUpperCase(s.charAt(id))==true) id--;\n\t\t\tid++;\n\t\t\tv = s.substring(id, t);\n\t\t\t\n\t\t\tStringBuffer cc = new StringBuffer();\n\t\t\tStringBuffer dd = new StringBuffer();\n\t\t\tcc.append(s.substring(0,t));\n\t\t\tdd.append(v);\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tcc.append(u);\n\t\t\t\tdd.append(u);\n\t\t\t}\n\t\t\tcc.append(s.substring(p+1, s.length()));\n\t\t\ts = cc.toString();\n\t\t\t\n\t\t\tv = dd.toString();\n\t\t\tif(v.length()>n) break;\n\t\t}\n\t\tif(v.length()>n) System.out.println(s.charAt(n));\n\t\telse System.out.println(0);\n\t}\n\t\n\t\n\tvoid tf(){\n\t\tStringBuffer bb;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(Character.isUpperCase(s.charAt(i))==true){\n\t\t\t\tif(i==0 || Character.isUpperCase(s.charAt(i-1))==false){\n\t\t\t\t\tif(i==s.length()-1 || Character.isUpperCase(s.charAt(i+1))==false){\n\t\t\t\t\t\tbb = new StringBuffer();\n\t\t\t\t\t\tbb.append(s.substring(0, i)).append('(').append(s.charAt(i)).append(')').append(s.substring(i+1, s.length()));\n\t\t\t\t\t\ts = bb.toString();\n\t\t\t\t\t\ti+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif(s.compareTo(\"0\")==0 && n==0) break;\n\t\t\ttf();\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s, t;\n\tint n;\n\t\n\tvoid func(){\n\t\tString v = s;\n\t\tString u = s;\n\t\tStringBuffer cc;\n\t\tint id, r, t;\n\t\twhile(true){\n\t\t\tint p = s.indexOf(')');\n\t\t\tint q = s.lastIndexOf('(', p);\n\t\t\tif(p==-1) break;\n\t\t\t\n\t\t\tu = s.substring(q+1, p);\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && 48<=s.charAt(id) && s.charAt(id)<=57) id--;\n\t\t\tid++;\n\t\t\tv = s.substring(id, q);\n\t\t\tif(v.length()>0) r = Integer.valueOf(v);\n\t\t\telse r = 1;\n\t\t\t\n\t\t\tt = id;\n\t\t\tid--;\n\t\t\twhile(id!=-1 && 65<=s.charAt(id) && s.charAt(id)<=90) id--;\n\t\t\tid++;\n\t\t\t\n\t\t\tcc = new StringBuffer(s.substring(0,t));\n\t\t\tfor(int i=0;i<r;i++) cc.append(u);\n\t\t\ts = cc.append(s.substring(p+1, s.length())).toString();\n\t\t\t\n\t\t\tv = s.substring(id, t+(p-q-1)*r);\n\t\t\tif(v.length()>n) break;\n\t\t}\n\t\tif(v.length()>n) System.out.println(s.charAt(n));\n\t\telse System.out.println(0);\n\t}\n\t\n\t\n\tvoid tf(){\n\t\tStringBuffer bb;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(Character.isUpperCase(s.charAt(i))==true){\n\t\t\t\tif(i==0 || Character.isUpperCase(s.charAt(i-1))==false){\n\t\t\t\t\tif(i==s.length()-1 || Character.isUpperCase(s.charAt(i+1))==false){\n\t\t\t\t\t\tbb = new StringBuffer();\n\t\t\t\t\t\tbb.append(s.substring(0, i)).append('(').append(s.charAt(i)).append(')').append(s.substring(i+1, s.length()));\n\t\t\t\t\t\ts = bb.toString();\n\t\t\t\t\t\ti+=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif(s.compareTo(\"0\")==0 && n==0) break;\n\t\t\ttf();\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1145();\n\t}\n\t\n\tclass AOJ1145{\n\t\tfinal String[] ps={\n\t\t\t\t\"(\\\\d+)(\\\\()\",\t\t// テヲツ閉ーテ・ツュツ?テゥツ鳴凝ヲツ仰ャテ・ツシツァ\n\t\t\t\t\"(\\\\d+)([A-Z])\",\t// テヲツ閉ーテ・ツュツ?テヲツ鳴?・ツュツ?\n\t\t\t\t\"(\\\\))(\\\\d+)\",\t\t// テゥツ鳴嘉ヲツ仰ャテ・ツシツァ+テヲツ閉ーテ・ツュツ?\n\t\t\t\t\"(\\\\))([A-Z])\",\t\t// テゥツ鳴嘉ヲツ仰ャテ・ツシツァ+テヲツ鳴?・ツュツ?\n\t\t\t\t\"([A-Z])([A-Z])\",\t// テヲツ鳴?・ツュツ?テヲツ鳴?・ツュツ?\n\t\t\t\t\"([A-Z])(\\\\d+)\"};\t// テヲツ鳴?・ツュツ?テヲツ閉ーテ・ツュツ?\n\t\tPattern[] pp;\n\t\tAOJ1145(){\n\t\t\tpp=new Pattern[ps.length];\n\t\t\tfor(int i=0; i<ps.length; ++i)\tpp[i]=Pattern.compile(ps[i]);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tString s=sc.next();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(s.equals(\"0\"))\tbreak;\n\t\t\t\tsolve(s,n);\n\t\t\t}\n\t\t}\n\t\tvoid solve(String s,int n){\n\t\t\tMatcher m=null;\n\t\t\tfor(int i=0; i<6; ++i){\n\t\t\t\tm=pp[i].matcher(s);\n\t\t\t\twhile(m.find()){\n\t\t\t\t\ts=s.replaceFirst(ps[i], m.group(1)+ (i>=2? \"+\": \"*\") +m.group(2));\n\t\t\t\t\tm=pp[i].matcher(s);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"<\"+s);\n\t\t\tParser parse=new Parser(s+\"#\",n);\n\t\t\tString ret=parse.start();\n//\t\t\tSystem.out.println(\">\"+ret+\"#\");\n\t\t\tSystem.out.println( (ret.length()<=n? \"0\": ret.charAt(n)) );\n\t\t}\n\t\tclass Parser{\n\t\t\tint pos=0,N;\n\t\t\tchar[] str;\n\t\t\tParser(String s,int n){\n\t\t\t\tthis.str=s.toCharArray();\n\t\t\t\tthis.N=n;\n\t\t\t}\n\t\t\tString start(){\n\t\t\t\treturn f1();\n\t\t\t}\n\t\t\tprivate String f1(){\n\t\t\t\tString ret=f2();\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ret.length()>N)\tbreak;\n\t\t\t\t\tchar op=str[pos];\n//\t\t\t\t\tSystem.out.println(\"f1op:\"+op);\n\t\t\t\t\tif(op=='+'){\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tString tmp=f2();\n//\t\t\t\t\t\tSystem.out.println(\"tmp:\"+tmp);\t\n\t\t\t\t\t\tret+=tmp;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"f1:\"+ret+\" \"+pos);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tprivate String f2(){\n\t\t\t\tString ret=f3();\n\t\t\t\twhile(true){\n\t\t\t\t\tchar op=str[pos];\n//\t\t\t\t\tSystem.out.println(\"f2op:\"+op);\n\t\t\t\t\tif(op=='*'){\n\t\t\t\t\t\t++pos;\n//\t\t\t\t\t\tSystem.out.println(\"f2n:\"+ret);\n\t\t\t\t\t\tint n=Integer.parseInt(ret);\n\t\t\t\t\t\tret=f3();\n\t\t\t\t\t\tStringBuilder tmp=new StringBuilder();\n\t\t\t\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\t\t\t\ttmp.append(ret);\n\t\t\t\t\t\t\tif(tmp.length()>N)\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tret=tmp.toString();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"f2:\"+ret+\" \"+pos);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tprivate String f3(){\n\t\t\t\tString ret=new String();\n\t\t\t\tif(Character.isDigit(str[pos])){\n\t\t\t\t\tStringBuilder tmp=new StringBuilder();\n\t\t\t\t\ttmp.append(str[pos++]);\n\t\t\t\t\twhile(Character.isDigit(str[pos]))\ttmp.append(str[pos++]);\n\t\t\t\t\tret=tmp.toString();\n\t\t\t\t}else if(str[pos]=='('){\n\t\t\t\t\t++pos;\n\t\t\t\t\tret=f1();\n\t\t\t\t\t++pos;\t// \")\"テ」ツ?ョテ・ツ按?\n\t\t\t\t}else if(Character.isUpperCase(str[pos])){\n\t\t\t\t\tret=\"\"+str[pos++];\n//\t\t\t\t\tSystem.out.println(\"f3up:\"+ret+\" p:\"+pos);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"f3:\"+ret+\" \"+pos);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1141{\n\t\tboolean[] isNotPrime;\n\t\tAOJ1141(){\n\t\t\tisNotPrime=sieve(1000000);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint a=sc.nextInt(),d=sc.nextInt(),n=sc.nextInt();\n\t\t\t\tif((a|(d|n))==0)\tbreak;\n\t\t\t\tsolve(a,d,n);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int a,int d,int n){\n\t\t\tint cnt=0;\n\t\t\tfor(int i=a; i<=1000000; i+=d){\n\t\t\t\tif(!isNotPrime[i])\t++cnt;\n\t\t\t\tif(cnt==n){\n\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tboolean[] sieve(int MAX){\n\t\t\tboolean[] isNotPrime=new boolean[MAX+1];\n\t\t\tisNotPrime[1]=true;\n\t\t\tfor(int i=2; i*i<=MAX; ++i){\n\t\t\t\tif(!isNotPrime[i])for(int j=i+i; j<=MAX; j+=i)\tisNotPrime[j]=true;\n\t\t\t}\n\t\t\treturn isNotPrime;\n\t\t}\n\t}\n\t\n\tclass AOJ1142{\n\t\tAOJ1142(){\n\t\t\tint n=sc.nextInt();\n\t\t\twhile(--n>=0)\tsolve();\n\t\t}\n\t\tvoid solve(){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tHashSet<String> set=new HashSet<String>();\n\t\t\tset.add(line.toString());\n\t\t\tfor(int i=1; i<=line.length(); ++i){\n\t\t\t\tString s1=line.substring(0, i),\n\t\t\t\t\t\ts2=line.substring(i, line.length());\n\t\t\t\tString s1r=new StringBuilder(s1).reverse().toString(),\n\t\t\t\t\t\ts2r=new StringBuilder(s2).reverse().toString();\n\t\t\t\tset.add(s1+s2r);\n\t\t\t\tset.add(s1r+s2);\n\t\t\t\tset.add(s1r+s2r);\n\t\t\t\tset.add(s2+s1);\n\t\t\t\tset.add(s2+s1r);\n\t\t\t\tset.add(s2r+s1);\n\t\t\t\tset.add(s2r+s1r);\n\t\t\t}\n//\t\t\tSystem.out.println(set);\n\t\t\tSystem.out.println(set.size());\n\t\t}\n\t}\n\t\n\tclass AOJ1144{\n\t\tAOJ1144(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tw=sc.nextInt();\n\t\t\t\th=sc.nextInt();\n\t\t\t\tif((w|h)==0)\tbreak;\n\t\t\t\tsolve(w,h);\n\t\t\t}\n\t\t}\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tint w,h;\n\t\tint sx,sy,ex,ey;\n\t\tvoid solve(int w,int h){\n\t\t\tboolean[][] b=new boolean[w][h];\n\t\t\tsx=0;\tsy=0;\tex=0;\tey=0;\n\t\t\tfor(int y=0; y<h; ++y)for(int x=0; x<w; ++x){\n\t\t\t\tint tmp=sc.nextInt();\n\t\t\t\tb[x][y]=(tmp!=1);\n\t\t\t\tif(tmp==2){\n\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t}else if(tmp==3){\n\t\t\t\t\tex=x;\tey=y;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans=-1;\n\t\t\tfor(int cnt=0; cnt<=10; ++cnt){\n\t\t\t\tboolean[][] bc=new boolean[w][h];\n\t\t\t\tfor(int x=0; x<w; ++x)for(int y=0; y<h; ++y)\tbc[x][y]=b[x][y];\n\t\t\t\tint ret=DFS(sx,sy,0,cnt,bc);\n\t\t\t\tif(ret<INF){\n\t\t\t\t\tans=ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\tint DFS(int x,int y,int depth,int limit,boolean[][] b){\n//\t\t\tSystem.out.println(x+\" \"+y+\" \"+depth+\" \"+limit);\n\t\t\tif(depth>=limit)\treturn INF;\n\t\t\tif(x==ex&&y==ey)\treturn depth;\n\t\t\t\n\t\t\tint ret=INF;\n\t\t\tfor(int v=0; v<4; ++v){\n\t\t\t\tint xx=x+vx[v],yy=y+vy[v];\n\t\t\t\tif(!(0<=xx&&xx<w && 0<=yy&&yy<h))\tcontinue;\n\t\t\t\tif(!b[xx][yy])\tcontinue;\n\t\t\t\tif(xx==ex&&yy==ey){\n\t\t\t\t\tret=min(ret,depth+1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\txx+=vx[v];\n\t\t\t\t\tyy+=vy[v];\n\t\t\t\t\tif(!(0<=xx&&xx<w && 0<=yy&&yy<h))\tbreak;\n\t\t\t\t\tif(xx==ex&&yy==ey){\n\t\t\t\t\t\tret=min(ret,depth+1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!b[xx][yy]){\n\t\t\t\t\t\txx-=vx[v];\n\t\t\t\t\t\tyy-=vy[v];\n\t\t\t\t\t\tb[xx+vx[v]][yy+vy[v]]=true;\n\t\t\t\t\t\tret=min(ret, DFS(xx,yy,depth+1,limit,b));\n\t\t\t\t\t\tb[xx+vx[v]][yy+vy[v]]=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tint idx = in.nextInt();\n\t\t\tif(s[0] == '0') break;\n\t\t\tNode base = new Node(1);\n\t\t\tcur = 0;\n\t\t\twhile(cur < s.length){\n\t\t\t\tbase.edge.add(gen());\n\t\t\t}\n\t\t\tfor(int i=0; i<100; i++){\n\t\t\t\tint val = (int)base.dfs(i);\n\t\t\t\tif(val >= 0) break;\n\t\t\t\tSystem.out.print(res);\n\t\t\t}\n\t\t\tSystem.out.println();\n//\t\t\tSystem.out.println(base.dfs(idx) < 0 ? res : '0');\n\t\t}\n\t}\n\t\n\tpublic static char res;\n\tpublic static int cur;\n\tpublic static Node gen(){\n\t\tif(Character.isDigit(s[cur])){\n\t\t\tint num = 0;\n\t\t\twhile(Character.isDigit(s[cur])){\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[cur++]-'0';\n\t\t\t}\n\t\t\tif(Character.isUpperCase(s[cur])){\n\t\t\t\treturn new Node(s[cur++]+\"\", num);\n\t\t\t}\n\t\t\tcur++;\n\t\t\tNode node = new Node(num);\n\t\t\twhile(cur < s.length && s[cur] != ')')\n\t\t\t\tnode.edge.add(gen());\n\t\t\tcur++;\n\t\t\treturn node;\n\t\t}else{\n\t\t\treturn new Node(getStr(), 1);\n\t\t}\n\t}\n\t\n\tpublic static String getStr(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(cur < s.length && Character.isUpperCase(s[cur]))\n\t\t\tsb.append(s[cur++]);\n\t\treturn sb.toString();\n\t}\n}\n\nclass Node{\n\tArrayList<Node> edge;\n\tString str;\n\tint num;\n\tpublic Node(int num){\n\t\tedge = new ArrayList<Node>();\n\t\tthis.num = num;\n\t}\n\t\n\tpublic Node(String str, int num){\n\t\tthis.str = str;\n\t\tthis.num = num;\n\t}\n\t\n\tpublic String toString(){\n\t\tif(str != null){\n\t\t\treturn (num>1?num:\"\")+str;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num>1) sb.append(num+\"<\");\n\t\tfor(Node v: edge) sb.append(v);\n\t\tif(num>1) sb.append('>');\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic long dfs(long sidx){\n\t\t// sidx : ??????????????¢\n\t\tif(str != null){\n\t\t\tif(sidx <= str.length()*num-1){\n\t\t\t\tsidx = sidx % str.length();\n\t\t\t\tMain.res = str.charAt((int)sidx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn sidx-str.length()*num;\n\t\t}\n\t\tlong origin = sidx;\n\t\tfor(Node v: edge){\n\t\t\tsidx = v.dfs(sidx);\n\t\t\tif(sidx<0) return sidx;\n\t\t}\n\t\tlong len = origin - sidx;\n\t\tif((origin+len)/len <= num){\n\t\t\treturn dfs(origin % len);\n\t\t}\n\t\treturn origin - num*len;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tif(flg) return \"\";\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tif(flg) return \"\";\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#' || word == '(')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"\";\n\t\tString res = fact();\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(flg) return \"\";\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tfinal int MAX = 1000000 + 1;\n\t\tdata = new char[MAX];\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\t\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString result = exp();\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < data.length;i++){\n//\t\t\t\tSystem.out.print(data[i] + \":\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    String S;\n    int I;\n    ArrayList<Character> line;\n    boolean end;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    S = sc.next();\n\t    I = sc.nextInt();\n\t    if(S.equals(\"0\") && I==0)break;\n\t    line = new ArrayList<Character>();\n\t    end = false;\n\t    splitLine(S);\n\n\t    String ans = \"\";\n\t    if(I>=line.size())ans = \"0\";\n\t    else ans = String.valueOf(line.get(I));\n\t    /*\n\t    for(int i=0; i<line.size(); i++){\n\t\tSystem.out.print(line.get(i)+\" \");\n\t    }\n\t    System.out.println();\n\t    */\n\t    System.out.println(\"ans\"+ans);\n\t}\n    }\n\n    void splitLine(String s){\n\tif(end)return;\n\tLinkedList<String> q = new LinkedList<String>();\n\tq.add(s);\n\n\twhile(q.size()>=1){\n\t    s = q.poll();\n\n\t    boolean onlyAlpha = true;;\n\t    for(int i=0; i<s.length(); i++){\n\t\tif(!(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0)){\n\t\t    onlyAlpha = false; \n\t\t    break;\n\t\t}\n\t    }\n\t    if(onlyAlpha){addLine(s); if(end)return; continue;}\n\n\t    for(int i=0; i<s.length(); i++){\n\t\tif(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0){\n\t\t    int j = i+1;\n\t\t    for(j=i+1; j<s.length(); j++){\n\t\t\tif(!(s.charAt(j)-'A'<=25 && s.charAt(j)-'A'>=0))break;\n\t\t    }\n\t\t    splitLine(s.substring(i,j));\n\t\t    i = j-1;\n\t\t}else{\n\t\t    int iL = i;\n\t\t    for(iL=i+1; iL<s.length(); iL++){\n\t\t\tif(!(s.charAt(iL)<10 || s.charAt(iL)=='0'))break;\n\t\t    }\n\t\t    int num = 0;\n\t\t    int j=iL;\n\t\t    for(j=iL; j<s.length(); j++){\n\t\t\tif(s.charAt(j)=='('){num++;}\n\t\t\tif(s.charAt(j)==')')num--;\n\t\t\tif(num==0)break;\n\t\t    }\n\t\t    int count = Integer.parseInt(s.substring(i,iL));\n\t\t    //System.out.println(\"count\"+count);\n\t\t    String newS = \"\";\n\t\t    if(iL==j){\n\t\t\tnewS = s.substring(iL,iL+1);\n\t\t    }else{\n\t\t\tnewS = s.substring(iL+1,j);\n\t\t    }\n\t\t    //System.out.println(newS);\n\t\t    while(count-->0)splitLine(newS);\n\t\t    i = j;\n\t\t}\n\t    }\n\t}\n    }\n\t\n    void addLine(String s){\n\tchar[] c = s.toCharArray();\n\tfor(int i=0; i<c.length; i++){\n\t    line.add(c[i]);\n\t    if(line.size()>I){end = true; return;}\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static class Compress{\n\t\tint times;\n\t\tCompress child;\n\t\tCompress next;\n\t\tString input;\n\t\t\n\t\tpublic Compress(int times, Compress child, Compress next, String input) {\n\t\t\tsuper();\n\t\t\tthis.times = times;\n\t\t\tthis.child = child;\n\t\t\tthis.next = next;\n\t\t\tthis.input = input;\n\t\t}\n\t\t\n\t\tpublic long get_ch_next_len(){\n\t\t\tlong len = 0;\n\t\t\tif(this.child != null){\n\t\t\t\tlen = this.child.get_ch_next_len();\n\t\t\t}else{\n\t\t\t\tlen = input.length();\n\t\t\t}\n\t\t\tlen *= this.times;\n\t\t\t\n\t\t\tif(this.next != null){\n\t\t\t\tlen += this.next.get_ch_next_len();\n\t\t\t}\n\t\t\t\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tprivate long calc(){\n\t\t\treturn this.get_ch_next_len();\n\t\t}\n\t\t\n\t\tprivate long calc2(){\n\t\t\tlong len = 0;\n\t\t\t\n\t\t\tif(this.child != null){\n\t\t\t\tlen += this.child.get_ch_next_len();\n\t\t\t}else{\n\t\t\t\tlen += this.input.length();\n\t\t\t}\n\t\t\tlen *= this.times;\n\t\t\t\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tpublic char get_ch(long N, int times){\n\t\t\t//System.out.println(this + \" \" + N);\n\t\t\tchar ret = '0';\n\t\t\t\n\t\t\tif(this.child != null){\n\t\t\t\tret = this.child.get_ch(N, this.times);\n\t\t\t}\n\t\t\t\n\t\t\tif(ret != '0'){\n\t\t\t\treturn ret;\n\t\t\t}else{\n\t\t\t\tlong len = this.calc();\n\t\t\t\t\n\t\t\t\t//System.out.println(this.toString() + \" \" + N + \" \" + len);\n\t\t\t\n\t\t\t\tif(N < len * times){\n\t\t\t\t\tlong len2 = this.calc2();\n\t\t\t\t\tlong rest = N % len;\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(\"> \" + this.toString() + \" \" + rest + \" \" + len2);\n\t\t\t\t\t\n\t\t\t\t\tif(this.child != null && rest < len2){\n\t\t\t\t\t\treturn this.child.get_ch(rest % len2, this.times);\n\t\t\t\t\t}else if(this.input != null && rest < len2){\n\t\t\t\t\t\treturn this.input.charAt((int) (rest % this.input.length()));\n\t\t\t\t\t}else if(this.next != null && rest >= len2){\n\t\t\t\t\t\treturn this.next.get_ch(rest - len2, times);\n\t\t\t\t\t}else{\n\t\t\t\t\t\treturn '0';\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\treturn '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\n\t\t\tsb.append(times);\n\t\t\t\n\t\t\tif(this.child != null){\n\t\t\t\tsb.append(\"(\");\n\t\t\t\tsb.append(this.child.toString());\n\t\t\t\tsb.append(\")\");\n\t\t\t}else{\n\t\t\t\tsb.append(this.input);\n\t\t\t}\n\t\t\t\n\t\t\tif(this.next != null){\n\t\t\t\tsb.append(this.next.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\t\n\tpublic static Compress parse(char[] input, int start , int end){\n\t\t\n\t\tint times = 0;\n\t\tint loop_start = start;\n\t\t\n\t\twhile(loop_start <= end){\n\t\t\tif('0' <= input[loop_start] && input[loop_start] <= '9'){\n\t\t\t\ttimes *= 10;\n\t\t\t\ttimes += input[loop_start] - '0';\n\t\t\t\tloop_start++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean kakko_found = false;\n\t\tint kakko_lv = 0;\n\t\tint kakko_start = -1;\n\t\tint kakko_end = -1;\n\t\t\n\t\tCompress ret = new Compress(times, null, null, \"\");\n\t\t\n\t\tif(input[loop_start] != '('){\n\t\t\tret.times = times == 0 ? 1 : times;\n\t\t\t\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(input[loop_start]);\n\t\t\t\n\t\t\tret.input = sb.toString();\n\t\t\t\n\t\t\tif(loop_start < end){\n\t\t\t\tret.next = parse(input, loop_start + 1, end);\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tfor(int cur = loop_start; cur <= end; cur++){\n\t\t\tif(input[cur] == '('){\n\t\t\t\tkakko_found = true;\n\t\t\t\t\n\t\t\t\tif(kakko_lv == 0){\n\t\t\t\t\tkakko_start = cur;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkakko_lv++;\n\t\t\t}else if(input[cur] == ')'){\n\t\t\t\tkakko_lv--;\n\t\t\t\t\n\t\t\t\tif(kakko_lv == 0){\n\t\t\t\t\tkakko_end = cur;\n\t\t\t\t\t\n\t\t\t\t\tret.child = parse(input, kakko_start + 1, kakko_end - 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(kakko_end < end){\n\t\t\tret.next = parse(input, kakko_end + 1, end);\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal String input = sc.next();\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(\"0\".equals(input) && N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tCompress comp = parse(input.toCharArray(), 0, input.length() - 1);\n\t\t\t\n\t\t\t//System.out.println(comp);\n\t\t\t\n\t\t\tSystem.out.println(comp.get_ch(N, 1));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1145();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\tvoid AOJ2021(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt(),K=sc.nextInt(),A=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] d=new int[N][N];\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<L; i++)\tl[i]=sc.nextInt();\n\t\t\tl[L]=H;\n\t\t\tfor(int i=0; i<K; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),t=sc.nextInt();\n\t\t\t\td[x][y]=t;\td[y][x]=t;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tfor(int k=0; k<N; k++)\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C2021> open=new PriorityQueue<C2021>();\n\t\t\topen.add(new C2021(A,M,0));\n\t\t\tint[][] close=new int[N][M+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<=M; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[A][M]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2021 now=open.poll();\n\t\t\t\tfor(int i=0; i<=L; i++){\n\t\t\t\t\tif(now.now==l[i])\tcontinue;\n\t\t\t\t\tif(d[now.now][l[i]]>M)\tcontinue;\n\t\t\t\t\tint t=now.time+d[now.now][l[i]],r=now.remain-d[now.now][l[i]];\n\t\t\t\t\tif(r<0){\n\t\t\t\t\t\tt+=-1*r;\n\t\t\t\t\t\tr=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(close[l[i]][r]<=t)\tcontinue;\n\t\t\t\t\tif(l[i]==H){\n\t\t\t\t\t\tans=min(ans,t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C2021(l[i],r,t));\n\t\t\t\t\tclose[l[i]][r]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"Help!\":ans));\n\t\t}\n\t}\n\tclass C2021 implements Comparable<C2021>{\n\t\tint now,remain,time;\n\t\tC2021(int n,int r,int t){this.now=n; this.remain=r; this.time=t;}\n\t\t@Override public int compareTo(C2021 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\t//System.out.println(\"L: \"+line);\n\t\t\ttry{\n\t\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString().charAt(n));\n\t\t\t}catch(Exception e){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans=expr();}\n\t\tprivate String expr(){\n\t\t\tString res=term();\n\t\t\tif(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tString res=fact();\n\t\t\tif(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0 && sb.length()<n)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tboolean[] f;\n\tint n;\n\t\n\tvoid func(){\n\t\tString u;\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint p, q, r, t, id;\n\t\tboolean check = false;\n\t\twhile(true){\n\t\t\tt = 0;\n\t\t\twhile(true){\n\t\t\t\tp = s.indexOf(')', t);\n\t\t\t\tif(p==-1 || f[p]==false) break;\n\t\t\t\tt = p+1;\n\t\t\t}\n\t\t\tt = p;\n\t\t\twhile(true){\n\t\t\t\tq = s.lastIndexOf('(', t);\n\t\t\t\tif(q==-1 || f[q]==false) break;\n\t\t\t\tt = q-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1 && q==-1) break;\n\t\t\t\n\t\t\tf[p] = true;\n\t\t\tf[q] = true;\n\t\t\tr = 1;\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tu = s.substring(id+1, q);\n\t\t\tif(u.compareTo(\"\")!=0) r = Integer.valueOf(u); \n\t\t\t\n\t\t\tif(f[p-1]==false){\n\t\t\t\tu = s.substring(q+1,p);\n\t\t\t\tfor(int i=0;i<r;i++) sb.append(u);\n\t\t\t}else{\n\t\t\t\tu = sb.toString();\n\t\t\t\tfor(int i=0;i<r-1;i++) sb.append(u);\n\t\t\t}\n\t\t\t\n\t\t\tcheck = true;\n\t\t\tif(sb.length()>n) break;\n\t\t}\n\t\t\n\t\tif(check==false){\n\t\t\tif(s.length()>n) System.out.println(s.charAt(n));\n\t\t\telse System.out.println(0);\n\t\t}else{\n\t\t\tif(sb.length()>n) System.out.println(sb.charAt(n));\n\t\t\telse System.out.println(0);\n\t\t}\n\t}\n\t\n\t\n\tString tf(char[] a){\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(Character.isUpperCase(a[i])==true\n\t\t\t\t&& (i==0 || Character.isUpperCase(a[i-1])==false)\n\t\t\t\t\t&& (i==a.length-1 || Character.isUpperCase(a[i+1])==false)){\n\t\t\t\t\t\tsb.append('(').append(a[i]).append(')');\n\t\t\t}else{\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tchar[] a = sc.next().toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\ts = tf(a);\n\t\t\tf = new boolean[s.length()];\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic class Node {\n\t\tint times;\n\t\tint length;\n\t\tint sum;\n\t\tString str;\n\t\tLinkedList<Node> child;\n\t\tint position;\n\t\tNode(int size,int position){\n\t\t\tthis.position = position;\n\t\t\tchild = new LinkedList<Main.Node>();\n\t\t\tthis.times = size;\n\t\t}\n\t\tNode(int size, String code ,int position) {\n\t\t\tthis.position = position;\n\t\t\tint np = position;\n\t\t\tchild = new LinkedList<Main.Node>();\n\t\t\ttimes = size;\n\t\t\tint buffer_int = -1;\n\t\t\tthis.length = 0;\n\t\t\tsum = 0;\n\t\t\tif (code.length() == 1) {\n\t\t\t\tthis.length = 1;\n\t\t\t\tthis.str = code;\n\t\t\t} else {\n\t\t\t\tfor (int ptr = 0; ptr < code.length(); ptr++) {\n\t\t\t\t\tif(np > 1e7){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar ch = code.charAt(ptr);\n\t\t\t\t\tif (ch >= 'A' && ch <= 'Z') {\n\t\t\t\t\t\tNode c = new Node(Math.abs(buffer_int), ch + \"\" ,np);\n\t\t\t\t\t\tchild.add(c);\n\t\t\t\t\t\tnp += c.sum;\n\t\t\t\t\t\tbuffer_int = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (ch >= '0' && ch <= '9') {\n\t\t\t\t\t\tif (buffer_int == -1) {\n\t\t\t\t\t\t\tbuffer_int = ch - '0';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbuffer_int *= 10;\n\t\t\t\t\t\t\tbuffer_int += ch - '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ch == '(') {\n\t\t\t\t\t\tint depth = 1;\n\t\t\t\t\t\tString str2 = \"\";\n\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\tptr++;\n\t\t\t\t\t\t\tch = code.charAt(ptr);\n\t\t\t\t\t\t\tif (ch == ')') {\n\t\t\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\t\t\tif(depth == 0) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ch == '(') {\n\t\t\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr2 += ch;\n\t\t\t\t\t\t}\n\t//\t\t\t\t\tSystem.out.println(\" \"+str2);\n\t\t\t\t\t\tNode c = new Node(1, str2 ,np);\n\t\t\t\t\t\tNode kakko = new Node(Math.abs(buffer_int),np);\n\t\t\t\t\t\tkakko.child.add(c);\n\t\t\t\t\t\tfor (Node q : kakko.child) {\n\t\t\t\t\t\t\tif(kakko.length + np > 1e7){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tkakko.length += q.sum;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint hensuu1;\n\t\t\t\t\t\tfor(hensuu1 = 0 ; hensuu1 < kakko.times;hensuu1++){\n\t\t\t\t\t\t\tkakko.sum += kakko.length ;\n\t\t\t\t\t\t\tif(np + kakko.sum > 1000000){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkakko.times = hensuu1;\n\t\t\t\t\t\tthis.child.add(kakko);\n\t\t\t\t\t\tnp += kakko.length;\n\t\t\t\t\t\tbuffer_int = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Node q : child) {\n\t\t\t\tthis.length += q.sum;\n\t\t\t}\n\t\t\tint hensuu1;\n\t\t\tfor(hensuu1 = 0 ; hensuu1 < times;hensuu1++){\n\t\t\t\tthis.sum += this.length ;\n\t\t\t\tif(position + this.sum > 1000000){\n\t\t\t//\t\tSystem.out.println(\"ツ可ス1\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.times = hensuu1;\n\t\t\treturn;\n\t\t}\n\n\t\tString getChar(int i) {\n\t//\t\tSystem.out.println(i);\n\t\t\tif (this.sum <= i) {\n\t\t\t\treturn \"0\";\n\t\t\t}\n\t\t\t\n\t\t\tint set = 0;\n\t\t\tint z = 0;\n\t\t\tfor (Node q : child) {\n\t\t\t\tset += q.sum;\n\t//\t\t\tSystem.out.println(\" \"+z+\",\"+set);\n\t\t\t\tif (set > i) {\n\t\t\t\t\treturn q.getChar((i - z)%q.length);\n\t\t\t\t}\n\t\t\t\tz = set;\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t\t\n\t\tvoid dump(){\n\t\t\tSystem.out.println(times);\n\t\t\tSystem.out.println(length);\n\t\t\tSystem.out.println(sum);\n\t\t\tSystem.out.println(str);\n\t\t\t\n\t\t\tfor(Node q : child){\n\t\t\t\tq.dump();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"\";\t\t\t\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tString in = sc.next();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (in.equals(\"0\") && n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tNode root = new Node(1, \"(\"+in+\")\" ,0);\n/*\n\t\t\troot.dump();\n\t/*/\t\t\n    \t\tSystem.out.println(root.getChar(n));\n//*/\t\t\t\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport static java.math.BigInteger.valueOf;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nabstract class Tree {\n    public abstract BigInteger length();\n    public abstract char get(int i);\n\n    private static char[] input;\n    private static int ptr;\n    private static Tree top() {\n        Tree tree;\n        if (input[ptr] == '(') {\n            ptr++;\n            tree = top();\n            assert input[ptr] == ')';\n            ptr++;\n        } else {\n            Node node = new Node();\n            while (true) {\n                if (Character.isDigit(input[ptr])) {\n                    node.addChild(num(), top());\n                } else if (Character.isUpperCase(input[ptr])) {\n                    node.addChild(1, new Leaf(seq()));\n                } else {\n                    tree = node;\n                    break;\n                }\n            }\n        }\n        return tree;\n    }\n\n    public static String seq() {\n        StringBuilder seq = new StringBuilder();\n        while (Character.isUpperCase(input[ptr])) {\n            seq.append(input[ptr]);\n            ptr++;\n        }\n        return seq.toString();\n    }\n\n    public static int num() {\n        int number = 0;\n        while (Character.isDigit(input[ptr])) {\n            number = number * 10 + (input[ptr] - '0');\n            ptr++;\n        }\n        return number;\n    }\n\n    public static Tree construct(String seq) {\n        input = (seq + '\\u0000').toCharArray();\n        ptr = 0;\n        return top();\n    }\n}\n\nclass Node extends Tree {\n    final List<Integer> ns = new ArrayList<Integer>();\n    final List<Tree> children = new ArrayList<Tree>();\n    private BigInteger length = BigInteger.ZERO;\n    public void addChild(int n, Tree child) {\n        ns.add(n);\n        children.add(child);\n        length = length.add(child.length().multiply(valueOf(n)));\n    }\n    @Override\n    public BigInteger length() {\n        return length;\n    }\n    @Override\n    public char get(int i) {\n        BigInteger index = valueOf(i);\n        for (int j = 0; j < ns.size(); j++) {\n            if (children.get(j).length().multiply(valueOf(ns.get(j))).compareTo(index) > 0) {\n                return children.get(j).get(index.mod(children.get(j).length()).intValue());\n            } else {\n                index = index.subtract(children.get(j).length().multiply(valueOf(ns.get(j))));\n            }\n        }\n        return 0;\n    }\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append('(');\n        for (int i = 0; i < ns.size(); i++) {\n            builder.append(ns.get(i));\n            builder.append(children.get(i).toString());\n        }\n        builder.append(')');\n        return builder.toString();\n    }\n}\n\nclass Leaf extends Tree {\n    private final String seq;\n    public Leaf(String seq) {\n        this.seq = seq;\n    }\n    @Override\n    public BigInteger length() {\n        return valueOf(seq.length());\n    }\n    @Override\n    public char get(int i) {\n        return seq.charAt(i);\n    }\n    @Override\n    public String toString() {\n        return seq;\n    }\n}\n\nclass Main {\n    private static void solve() {\n        final Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            final String s = scanner.next();\n            final int i = scanner.nextInt();\n            if (s.equals(\"0\") && i == 0) {\n                break;\n            }\n            final Tree tree = Tree.construct(s);\n            final char c = tree.get(i);\n            if (c == 0) {\n                System.out.println(0);\n            } else {\n                System.out.println(c);\n            }\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    String S;\n    int I;\n    ArrayList<Character> line;\n    boolean end;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    S = sc.next();\n\t    I = sc.nextInt();\n\t    if(S.equals(\"0\") && I==0)break;\n\n\t    line = new ArrayList<Character>();\n\t    end = false;\n\t    splitLine(S);\n\n\t    String ans = \"\";\n\t    if(I>=line.size())ans = \"0\";\n\t    else ans = String.valueOf(line.get(I));\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    void splitLine(String s){\n\tif(end)return;\n\n\tfor(int i=0; i<s.length(); i++){\n\t    if(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0){\n\t\tint j = i+1;\n\t\tfor(j=i+1; j<s.length(); j++){\n\t\t    if(!(s.charAt(j)-'A'<=25 && s.charAt(j)-'A'>=0))break;\n\t\t}\n\t\taddLine(s.substring(i,j));\n\t\tif(end)return;\n\t\ti = j-1;\n\t\t\n\t    }else{\n\t\tint from = i;\n\t\tfor(from=i+1; from<s.length(); from++){\n\t\t    //if(!(s.charAt(from)<10 || s.charAt(from)=='0'))break;\n\t\t    char c = s.charAt(from);\n\t\t    if(!(c=='0' || c=='1' || c=='2' || c=='3' || c=='4' || c=='5' || c=='6' || c=='7' || c=='8' || c=='9'))break;\n\t\t}\n\t\tint N = Integer.parseInt(s.substring(i,from));\n\n\t\tint pair = 0;\n\t\tint to=from;\n\t\tfor(to=from; to<s.length(); to++){\n\t\t    if(s.charAt(to)=='(') pair++;\n\t\t    if(s.charAt(to)==')') pair--;\n\t\t    if(pair==0)break;\n\t\t}\n\t\t\n\t\tString seq = \"\";\n\t\tif(from==to){\n\t\t    seq = s.substring(from,from+1);\n\t\t}else{\n\t\t    seq = s.substring(from+1,to);\n\t\t}\n\t\t\n\t\twhile(N-->0)splitLine(seq);\n\t\ti = to;\n\t    }\n\t}\n    }\n    \n    void addLine(String s){\n\tchar[] c = s.toCharArray();\n\tfor(int i=0; i<c.length; i++){\n\t    line.add(c[i]);\n\t    if(line.size()>I){end = true; return;}\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    String S;\n    int I;\n    ArrayList<Character> line;\n    boolean end;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\twhile(true){\n\t    S = sc.next();\n\t    I = sc.nextInt();\n\t    if(S.equals(\"0\") && I==0)break;\n\t    line = new ArrayList<Character>();\n\t    end = false;\n\t    splitLine(S);\n\n\t    String ans = \"\";\n\t    if(I>=line.size())ans = \"0\";\n\t    else ans = String.valueOf(line.get(I));\n\t    /*\n\t    for(int i=0; i<line.size(); i++){\n\t\tSystem.out.print(line.get(i)+\" \");\n\t    }\n\t    System.out.println();\n\t    */\n\t    System.out.println(ans);\n\t}\n    }\n\n    void splitLine(String s){\n\tif(end)return;\n\t\n\tboolean onlyAlpha = true;;\n\tfor(int i=0; i<s.length(); i++){\n\t    if(!(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0)){\n\t\tonlyAlpha = false; \n\t\tbreak;\n\t    }\n\t}\n\tif(onlyAlpha){addLine(s); if(end)return; return;}\n\t\n\tfor(int i=0; i<s.length(); i++){\n\t    if(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0){\n\t\tint j = i+1;\n\t\tfor(j=i+1; j<s.length(); j++){\n\t\t    if(!(s.charAt(j)-'A'<=25 && s.charAt(j)-'A'>=0))break;\n\t\t}\n\t\tsplitLine(s.substring(i,j));\n\t\ti = j-1;\n\t    }else{\n\t\tint iL = i;\n\t\tfor(iL=i+1; iL<s.length(); iL++){\n\t\t    if(!(s.charAt(iL)<10 || s.charAt(iL)=='0'))break;\n\t\t}\n\t\tint num = 0;\n\t\tint j=iL;\n\t\tfor(j=iL; j<s.length(); j++){\n\t\t    if(s.charAt(j)=='('){num++;}\n\t\t    if(s.charAt(j)==')')num--;\n\t\t    if(num==0)break;\n\t\t}\n\t\tint count = Integer.parseInt(s.substring(i,iL));\n\t\t//System.out.println(\"count\"+count);\n\t\tString newS = \"\";\n\t\tif(iL==j){\n\t\t    newS = s.substring(iL,iL+1);\n\t\t}else{\n\t\t    newS = s.substring(iL+1,j);\n\t\t}\n\t\t//System.out.println(newS);\n\t\twhile(count-->0)splitLine(newS);\n\t\ti = j;\n\t    }\n\t}\n    }\n    \n    void addLine(String s){\n\tchar[] c = s.toCharArray();\n\tfor(int i=0; i<c.length; i++){\n\t    line.add(c[i]);\n\t    if(line.size()>I){end = true; return;}\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tchar[] b;\n\tboolean[] f;\n\tint n;\n\t\n\tvoid func(){\n\t\tString u;\n\t\tint pos = 0;\n\t\tint p, q, r, t, id;\n\t\tboolean flag = false;\n\t\twhile(true){\n\t\t\tt = 0;\n\t\t\twhile(true){\n\t\t\t\tp = s.indexOf(')', t);\n\t\t\t\tif(p==-1 || f[p]==false) break;\n\t\t\t\tt = p+1;\n\t\t\t}\n\t\t\tt = p;\n\t\t\twhile(true){\n\t\t\t\tq = s.lastIndexOf('(', t);\n\t\t\t\tif(q==-1 || f[q]==false) break;\n\t\t\t\tt = q-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1 && q==-1) break;\n\t\t\t\n\t\t\tf[p] = true;\n\t\t\tf[q] = true;\n\t\t\tr = 1;\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tu = s.substring(id+1, q);\n\t\t\tif(u.compareTo(\"\")!=0) r = Integer.valueOf(u); \n\t\t\t\n\t\t\tif(f[p-1]==false){\n\t\t\t\tu = s.substring(q+1,p);\n\t\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\t\tfor(int j=0;j<p-q-1;j++){\n\t\t\t\t\t\tb[pos] = u.charAt(j);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = p;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tt = pos;\n\t\t\t\tfor(int i=0;i<r-1;i++){\n\t\t\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\t\t\tb[pos] = b[j];\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = t;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true) break;\n\t\t}\n\t}\n\t\n\tString tf(char[] a){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar[] c = new char[1000];\n\t\tint pos = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(Character.isUpperCase(a[i])==true \n\t\t\t\t&& (i==0 || c[pos-1]==')' || Character.isDigit(c[pos-1])==true)){\n\t\t\t\tc[pos] = '(';\n\t\t\t\tc[pos+1] = a[i];\n\t\t\t\tc[pos+2] = ')';\n\t\t\t\tpos += 3;\n\t\t\t}else{\n\t\t\t\tc[pos] = a[i];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<pos;i++) sb.append(c[i]);\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tchar[] a = sc.next().toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\ts = tf(a);\n\t\t\tf = new boolean[s.length()];\n\t\t\tb = new char[n+1];\n\t\t\tArrays.fill(b,'0');\n\t\t\tfunc();\n\t\t\tSystem.out.println(b[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ4\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1,-1,1,1,-1}, vy={-1,0,1,0,-1,-1,1,1};\n\tfinal int INF=1<<26;\n\tfinal double EPS=1.0e-08;\n\tpublic static void main(String[] args) {\n\t\t//long s=System.currentTimeMillis();\n\t\tnew Main().AOJ1145();\n\t\t//out.println((System.currentTimeMillis()-s)+\"msec\");\n\t}\n\t\n\t// WA\n\tvoid AOJ2021(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt(),K=sc.nextInt(),A=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] d=new int[N][N];\n\t\t\tint[] l=new int[L+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\td[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<L; i++)\tl[i]=sc.nextInt();\n\t\t\tl[L]=H;\n\t\t\tfor(int i=0; i<K; i++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt(),t=sc.nextInt();\n\t\t\t\td[x][y]=t;\td[y][x]=t;\n\t\t\t}\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tfor(int k=0; k<N; k++)\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C2021> open=new PriorityQueue<C2021>();\n\t\t\topen.add(new C2021(A,M,0));\n\t\t\tint[][] close=new int[N][M+1];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<=M; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[A][M]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2021 now=open.poll();\n\t\t\t\tfor(int i=0; i<=L; i++){\n\t\t\t\t\tif(now.now==l[i])\tcontinue;\n\t\t\t\t\tif(d[now.now][l[i]]>M)\tcontinue;\n\t\t\t\t\tint t=now.time+d[now.now][l[i]],r=now.remain-d[now.now][l[i]];\n\t\t\t\t\tif(r<0){\n\t\t\t\t\t\tt+=-1*r;\n\t\t\t\t\t\tr=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(close[l[i]][r]<=t)\tcontinue;\n\t\t\t\t\tif(l[i]==H){\n\t\t\t\t\t\tans=min(ans,t);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t//break;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new C2021(l[i],r,t));\n\t\t\t\t\tclose[l[i]][r]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"Help!\":ans));\n\t\t}\n\t}\n\tclass C2021 implements Comparable<C2021>{\n\t\tint now,remain,time;\n\t\tC2021(int n,int r,int t){this.now=n; this.remain=r; this.time=t;}\n\t\t@Override public int compareTo(C2021 o) {\n\t\t\tif(this.time<o.time)\treturn -1;\n\t\t\tif(this.time>o.time)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ2151(){\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(),M=sc.nextInt(),L=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[][] cost=new int[N+1][N+1],robber=new int[N+1][N+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=N; j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tcost[i][j]=INF;\trobber[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tcost[a][b]=c;\tcost[b][a]=c;\n\t\t\t\trobber[a][b]=d;\trobber[b][a]=d;\n\t\t\t}\n\t\t\tPriorityQueue<C2151> open=new PriorityQueue<C2151>();\n\t\t\topen.add(new C2151(1,L,0));\n\t\t\tint[][] close=new int[N+1][L+1];\n\t\t\tfor(int i=0; i<=N; i++){\n\t\t\t\tfor(int j=0; j<=L; j++)\tclose[i][j]=INF;\n\t\t\t}\n\t\t\tclose[1][L]=0;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC2151 now=open.poll();\n\t\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\t\tif(now.now==i)\tcontinue;\n\t\t\t\t\tif(cost[now.now][i]>=INF)\tcontinue;\n\t\t\t\t\tif(now.remains>=cost[now.now][i]){\n\t\t\t\t\t\tint re2=now.remains-cost[now.now][i];\n\t\t\t\t\t\tif(close[i][re2]>now.robbers){\n\t\t\t\t\t\t\tif(i==N){\n\t\t\t\t\t\t\t\tans=min(ans,now.robbers);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\topen.add(new C2151(i,re2,now.robbers));\n\t\t\t\t\t\t\t\tclose[i][re2]=now.robbers;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint rob2=now.robbers+robber[i][now.now];\n\t\t\t\t\tif(close[i][now.remains]<=rob2)\tcontinue;\n\t\t\t\t\tif(i==N)\tans=min(ans,rob2);\n\t\t\t\t\telse{\n\t\t\t\t\t\topen.add(new C2151(i,now.remains,rob2));\n\t\t\t\t\t\tclose[i][now.remains]=rob2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tclass C2151 implements Comparable<C2151>{\n\t\tint now,remains,robbers;\n\t\tC2151(int n,int r,int r2){this.now=n; this.remains=r; this.robbers=r2;}\n\t\t@Override public int compareTo(C2151 o) {\n\t\t\tif(this.robbers<o.robbers)\treturn -1;\n\t\t\tif(this.robbers>o.robbers)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt(),sx=0,sy=0;\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=sc.nextInt();\n\t\t\t\t\tif(b[x][y]==2){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<C1144> open=new PriorityQueue<C1144>();\n\t\t\tint[] temp=new int[10];\n\t\t\tArrays.fill(temp, -1);\n\t\t\topen.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tTreeSet<C1144> close=new TreeSet<C1144>();\n\t\t\tclose.add(new C1144(sx,sy,0,temp,temp));\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1144 now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x,yy=now.y;\n\t\t\t\t\tif((0<=xx+vx[i] && xx+vx[i]<W && 0<=yy+vy[i] && yy+vy[i]<H) && b[xx+vx[i]][yy+vy[i]]==1 && !now.stone(xx+vx[i], yy+vy[i]))\tcontinue;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\n\t\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H))\tbreak;\n\t\t\t\t\t\tif(b[xx][yy]==3){\n\t\t\t\t\t\t\tans=min(ans,now.step+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[xx][yy]==1 && !now.stone(xx, yy)){\n\t\t\t\t\t\t\tif(now.step==9)\tbreak;\n\t\t\t\t\t\t\tint[] tx=now.x2.clone(),ty=now.y2.clone();\n\t\t\t\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\t\t\t\tif(tx[j]<0 && ty[j]<0){\n\t\t\t\t\t\t\t\t\ttx[j]=xx;\tty[j]=yy;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\txx-=vx[i];\tyy-=vy[i];\n\t\t\t\t\t\t\tC1144 next=new C1144(xx,yy,now.step+1,tx,ty);\n\t\t\t\t\t\t\tif(close.contains(next))\tbreak;\n\t\t\t\t\t\t\topen.add(next);\n\t\t\t\t\t\t\tclose.add(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?\"-1\":ans));\n\t\t}\n\t}\n\tclass C1144 implements Comparable<C1144>{\n\t\tint x,y,step;\n\t\tint[] x2,y2;\n\t\tC1144(int x,int y,int step,int[] x2,int[] y2){this.x=x; this.y=y; this.step=step; this.x2=x2; this.y2=y2;}\n\t\t@Override public int compareTo(C1144 o) {\n\t\t\tif(this.step<o.step)\treturn -1;\n\t\t\tif(this.step>o.step)\treturn 1;\n\t\t\tif(Arrays.equals(this.x2, o.x2) && Arrays.equals(this.y2, o.y2))\treturn 0;\n\t\t\treturn -1;\n\t\t}\n\t\tboolean stone(int x,int y){\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tif(x2[i]<0 && y2[i]<0)\treturn false;\n\t\t\t\tif(x2[i]==x && y2[i]==y)\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t// WA\n\tvoid AOJ1145(){\n\t\twhile(true){\n\t\t\tStringBuilder line=new StringBuilder(sc.next());\n\t\t\tint n=sc.nextInt();\n\t\t\tif(line.toString().equals(\"0\"))\tbreak;\n\t\t\tchar last=line.charAt(0);\n\t\t\tfor(int i=1; i<line.length(); i++){\n\t\t\t\tif(Character.isDigit(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '*');\n\t\t\t\t\telse if(line.charAt(i)=='(')\tline.insert(i++, '*');\n\t\t\t\t}else if(Character.isUpperCase(last)){\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t\telse if(Character.isDigit(line.charAt(i)))\tline.insert(i++, '+');\n\t\t\t\t}else if(last==')' && line.charAt(i)!=')')\tline.insert(i++, '+');\n\t\t\t\tlast=line.charAt(i);\n\t\t\t}\n\t\t\tline.append(\"#\");\n\t\t\t//System.out.println(\"L: \"+line);\n\t\t\ttry{\n\t\t\t\tSystem.out.println(new parsed1145(line.toString(), n).toString().charAt(n));\n\t\t\t}catch(Exception e){\n\t\t\t\tSystem.out.println(0);\n\t\t\t}\n\t\t}\n\t}\n\tclass parsed1145{\n\t\tString line,ans;\n\t\tint pos=0,n;\n\t\tpublic parsed1145(String line, int n) { this.line=line; this.n=n; ans=expr();}\n\t\tprivate String expr(){\n\t\t\tString res=term();\n\t\t\tif(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tpos++;\n\t\t\t\t\tres+=term();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String term(){\n\t\t\tString res=fact();\n\t\t\t//if(res.length()>n)\treturn res;\n\t\t\twhile(true){\n\t\t\t\tchar op=line.charAt(pos);\n\t\t\t\tif(op=='*'){\n\t\t\t\t\tint t=Integer.parseInt(res);\n\t\t\t\t\tpos++;\n\t\t\t\t\tres=fact();\n\t\t\t\t\tif(res.length()>n)\treturn res;\n\t\t\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\t\t\twhile(--t>=0 && sb.length()<=n)\tsb.append(res);\n\t\t\t\t\tres=sb.toString();\n\t\t\t\t}else\tbreak;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tprivate String fact(){\n\t\t\tif(Character.isDigit(line.charAt(pos))){\n\t\t\t\tString t=\"\"+(line.charAt(pos)-'0');\n\t\t\t\tpos++;\n\t\t\t\twhile(Character.isDigit(line.charAt(pos))){\n\t\t\t\t\tt+=(line.charAt(pos)-'0');\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\treturn t;\n\t\t\t}else if(line.charAt(pos)=='('){\n\t\t\t\tpos++;\n\t\t\t\tString res=expr();\n\t\t\t\tpos++;\n\t\t\t\treturn res;\n\t\t\t}else if(Character.isUpperCase(line.charAt(pos))){\n\t\t\t\treturn \"\"+line.charAt(pos++);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\t\t@Override public String toString() {\treturn ans;}\n\t}\n\t\n\tvoid AOJ1165(){\n\t\tfinal int[] vx2={-1,0,1,0}, vy2={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=1; i<N; i++){\n\t\t\t\tint n=sc.nextInt(),d=sc.nextInt();\n\t\t\t\tx[i]=x[n]+vx2[d];\ty[i]=y[n]+vy2[d];\n\t\t\t}\n\t\t\tArrays.sort(x);\tArrays.sort(y);\n\t\t\tSystem.out.println((x[N-1]-x[0]+1)+\" \"+(y[N-1]-y[0]+1));\n\t\t}\n\t}\n\t\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\treturn (min<=x&&x<X)&&(min<=y&&y<Y);}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.BigInteger;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tBigInteger I = sc.nextBigInteger();\n\t\t\tif(s.equals(\"0\") && I.equals(BigInteger.ZERO)) break;\n\n\t\t\ttree = new ArrayList<Node>();\n\t\t\ttree.add(new Node(' ',new ArrayList<Edge>()));\n\t\t\tidx = 0;\n\t\t\tmakeMap(0);\n\n\t\t\tBigInteger sum = BigInteger.ZERO;\n\t\t\tfor(Edge e : tree.get(0).eds) sum = sum.add(e.cost);\n\t\t\tSystem.out.println(sum.compareTo(I) <= 0 ? '0' : solve(I,0));\n\t\t}\n\t}\n\n\tprivate static String s;\n\tprivate static ArrayList<Node> tree;\n\tprivate static int idx;\n\n\tprivate static char solve(BigInteger rem,int pos){\n\t\tif(tree.get(pos).ch != ' '){\n\t\t\treturn tree.get(pos).ch;\n\t\t}\n\n\t\tArrayList<Edge> tmp = tree.get(pos).eds;\n\t\tint npos = 0;\n\t\tBigInteger sum = BigInteger.ZERO;\n\t\tint i = 0;\n\t\tfor(;sum.compareTo(rem) <= 0 && i<tmp.size();i++){\n\t\t\tsum = sum.add(tmp.get(i).cost);\n\t\t}\n\t\ti--;\n\t\trem = rem.subtract(sum).add(tmp.get(i).cost);\n\n\t\treturn solve(rem.remainder(tmp.get(i).cost.divide(new BigInteger(Integer.toString(tmp.get(i).d)))), tmp.get(i).to);\n\t}\n\n\tprivate static BigInteger makeMap(int pos){\n\t\tBigInteger res = BigInteger.ZERO;\n\t\tBigInteger mul = BigInteger.ONE;\n\n\t\tfor(;idx<s.length();idx++){\n\t\t\tchar ch = s.charAt(idx);\n\n\t\t\tif('A' <= ch && ch <= 'Z'){\n\t\t\t\ttree.add(new Node(ch,new ArrayList<Edge>()));\n\t\t\t\ttree.get(pos).eds.add(new Edge(tree.size()-1,mul,1));\n\t\t\t\tres = res.add(mul);\n\t\t\t}\n\t\t\telse if(ch == '('){\n\t\t\t\tidx++;\n\t\t\t\ttree.add(new Node(' ',new ArrayList<Edge>()));\n\t\t\t\tint npos = tree.size() - 1;\n\t\t\t\tBigInteger cost = makeMap(npos);\n\t\t\t\ttree.get(pos).eds.add(new Edge(npos,cost.multiply(mul),Integer.parseInt(mul.toString())));\n\t\t\t\tres = res.add(cost.multiply(mul));\n\t\t\t\tmul = BigInteger.ONE;\n\t\t\t}\n\t\t\telse if(ch == ')'){\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tString muls = \"\";\n\t\t\t\tfor(;'0'<=s.charAt(idx) && s.charAt(idx)<='9';idx++)\n\t\t\t\t\tmuls += s.charAt(idx);\n\t\t\t\tmul = new BigInteger(muls);\n\t\t\t\tidx--;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nclass Node{\n\tchar ch;\n\tArrayList<Edge> eds;\n\n\tNode(char ch,ArrayList<Edge> eds){\n\t\tthis.ch = ch;\n\t\tthis.eds = new ArrayList<Edge>(eds);\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[%c,\"+eds+\"]\",ch);\n\t}\n}\n\nclass Edge{\n\tint to;\n\tBigInteger cost;\n\tint d;\n\n\tEdge(int to,BigInteger cost,int d){\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t\tthis.d = d;\n\t}\n\n\tpublic String toString(){\n\t\treturn String.format(\"[to%d,%s/%d]\",to,cost.toString(),d);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//The Genome Database of All Space Life\npublic class Main{\n\n\tstatic char[] s;\n\tstatic int id;\n\tstatic int len;\n\n\tstatic String msg(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint x = 1;\n\t\twhile(true){\n\t\t\tchar ch = s[id++];\n\t\t\tif(Character.isDigit(ch)){\n\t\t\t\tid--;\n\t\t\t\tx = num();\n\t\t\t}\n\t\t\telse if(ch=='('){\n\t\t\t\tString t = msg();\n\t\t\t\twhile(sb.length() <= len && x--!=0){\n\t\t\t\t\tfor(int i=0;i<t.length();i++){\n\t\t\t\t\t\tif(sb.length() > len)break;\n\t\t\t\t\t\tsb.append(t.charAt(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx = 1;\n\t\t\t}\n\t\t\telse if(Character.isUpperCase(ch)){\n\t\t\t\twhile(sb.length() <= len && x--!=0)sb.append(ch);\n\t\t\t\tx = 1;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic int num(){\n\t\tchar ch = s[id++];\n\t\tint x = ch - '0';\n\t\twhile(true){\n\t\t\tch = s[id++];\n\t\t\tif(!Character.isDigit(ch))break;\n\t\t\tx *= 10;\n\t\t\tx += ch - '0';\n\t\t}\n\t\tid--;\n\t\treturn x;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tString ss = sc.next();\n\t\t\tlen = sc.nextInt();\n\t\t\tif(ss.equals(\"0\") && len == 0)break;\n\t\t\ts = (ss+\"#\").toCharArray();\n\t\t\tid = 0;\n\t\t\tlen++;\n\t\t\tString genom = msg();\n\t\t\tSystem.out.println(genom.length() >= len ? genom.charAt(len-1) : \"0\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tchar[] b;\n\tboolean[] f;\n\tint n;\n\t\n\tvoid func(){\n\t\tString u;\n\t\tint pos = 0;\n\t\tint p, q, r, t, id;\n\t\tboolean flag = false;\n\t\twhile(true){\n\t\t\tt = 0;\n\t\t\twhile(true){\n\t\t\t\tp = s.indexOf(')', t);\n\t\t\t\tif(p==-1 || f[p]==false) break;\n\t\t\t\tt = p+1;\n\t\t\t}\n\t\t\tt = p;\n\t\t\twhile(true){\n\t\t\t\tq = s.lastIndexOf('(', t);\n\t\t\t\tif(q==-1 || f[q]==false) break;\n\t\t\t\tt = q-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1 && q==-1) break;\n\t\t\t\n\t\t\tf[p] = true;\n\t\t\tf[q] = true;\n\t\t\tr = 1;\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tu = s.substring(id+1, q);\n\t\t\tif(u.compareTo(\"\")!=0) r = Integer.valueOf(u); \n\t\t\t\n\t\t\tif(f[p-1]==false){\n\t\t\t\tu = s.substring(q+1,p);\n\t\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\t\tfor(int j=0;j<p-q-1;j++){\n\t\t\t\t\t\tb[pos] = u.charAt(j);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = p;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tt = pos;\n\t\t\t\tfor(int i=0;i<r-1;i++){\n\t\t\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\t\t\tb[pos] = b[j];\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = t;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true) break;\n\t\t}\n\t}\n\t\n\tString tf(char[] a){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(Character.isUpperCase(a[i])==true\n\t\t\t\t&& (i==0 || Character.isUpperCase(a[i-1])==false)\n\t\t\t\t\t&& (i==a.length-1 || Character.isUpperCase(a[i+1])==false)){\n\t\t\t\t\t\tsb.append('(').append(a[i]).append(')');\n\t\t\t}else{\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tchar[] a = sc.next().toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\ts = tf(a);\n\t\t\tif(s.indexOf(')')==-1) s = '(' + s + ')';\n\t\t\tf = new boolean[s.length()];\n\t\t\tb = new char[n+1];\n\t\t\tArrays.fill(b,'0');\n\t\t\tfunc();\n\t\t\tSystem.out.println(b[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s, t;\n\tint n;\n\t\n\tvoid func(){\n\t\tboolean flag;\n\t\tint min = 0;\n\t\tString v = s;\n\t\tString u = s;\n\t\tStringBuffer cc;\n\t\tint id, p, q, r, t;\n\t\twhile(true){\n\t\t\tp = s.indexOf(')');\n\t\t\tq = s.lastIndexOf('(', p);\n\t\t\tr = p;\n\t\t\tif(r==-1) r = s.length();\n\t\t\t\n\t\t\tflag = false;\n\t\t\tfor(int i=min;i<r;i++){\n\t\t\t\tmin = i;\n\t\t\t\tif(Character.isUpperCase(s.charAt(i))==true){\n\t\t\t\t\tif(i==0 || Character.isUpperCase(s.charAt(i-1))==false){\n\t\t\t\t\t\tif(i==s.length()-1 || Character.isUpperCase(s.charAt(i+1))==false){\n\t\t\t\t\t\t\tp = i;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1) break;\n\t\t\t\n\t\t\tif(flag==false){\n\t\t\t\tu = s.substring(q+1, p);\n\t\t\t}else{\n\t\t\t\tu = s.substring(p,p+1);\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\t\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && 48<=s.charAt(id) && s.charAt(id)<=57) id--;\n\t\t\tid++;\n\t\t\tv = s.substring(id, q);\n\t\t\tif(v.length()>0) r = Integer.valueOf(v);\n\t\t\telse r = 1;\n\t\t\t\n\t\t\tt = id;\n\t\t\tid--;\n\t\t\twhile(id!=-1 && 65<=s.charAt(id) && s.charAt(id)<=90) id--;\n\t\t\tid++;\n\t\t\t\n\t\t\tcc = new StringBuffer(s.substring(0,t));\n\t\t\tfor(int i=0;i<r;i++) cc.append(u);\n\t\t\ts = cc.append(s.substring(p+1, s.length())).toString();\n\t\t\t\n\t\t\tif(flag==true) q-=2;\n\t\t\tv = s.substring(id, t+(p-q-1)*r);\n\t\t\tif(v.length()>n) break;\n\t\t}\n\t\tif(v.length()>n) System.out.println(s.charAt(n));\n\t\telse System.out.println(0);\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif(s.compareTo(\"0\")==0 && n==0) break;\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tif(flg) return \"\";\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tif(flg) return \"\";\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#' || word == '(')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\tif(flg) return \"\";\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"\";\n\t\tString res = fact();\n\t\tif(flg) return \"\";\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tif(flg) return \"\";\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(flg) return \"\";\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tif(flg) return \"\";\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tfinal int MAX = 1000000 + 1;\n\t\tdata = new char[MAX];\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString a = \"\";\n\t\t\tString result = exp();\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < data.length;i++){\n//\t\t\t\tSystem.out.print(data[i] + \":\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic String input;\n\tstatic int targetindex;\n\tstatic boolean debug = false;\n\t\n\tstatic class Segment\n\t{\n\t\tboolean issimple = false;\n\t\tString simplecontent = \"\";\n\t\tArrayList<Segment> subsegs = new ArrayList<Segment>();\n\t\tArrayList<Integer> times = new ArrayList<Integer>();\n//\t\tBigInteger length = new BigInteger(\"0\");\n\t\t\n//\t\tString tempcont;\n\t\t\n//\t\tint id = (int) (Math.random()*1000);\n\t\t\n\t\t\n\t\tString getOf(int index)\n\t\t{\n\t\t\tint segs = subsegs.size();\n\t\t\t\n\t\t\tif(issimple)\n\t\t\t{\n\t\t\t\tif(index >= simplecontent.length())return \"0\";\n\t\t\t\treturn simplecontent.substring(index, index+1);\n\t\t\t}\n\t\t\t\n\t\t\tint reducedindex = index;\n\t\t\tfor(int cursegid = 0; cursegid < segs; cursegid++)\n\t\t\t{\n\t\t\t\tSegment curseg = subsegs.get(cursegid);\n\t\t\t\tint thislength = curseg.getlength();\n\t\t\t\tint thiscost = thislength * times.get(cursegid);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(\"remaining: \" + reducedindex + \" SEGMENT \" + cursegid + \" LENGTH: \" + (thiscost) + \":   [\" + curseg.tempcont);\n\t\t\t\t\n\t\t\t\tif(reducedindex >= thiscost)\n\t\t\t\t{\n\t\t\t\t\t//not this segment, move on\n\t\t\t\t\treducedindex -= thiscost;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//within this segment\n//\t\t\t\t\tSystem.out.println(\": SEGMENT \" + cursegid + \", I \" + reducedindex);\n\t\t\t\t\treducedindex = reducedindex%thislength;\n\t\t\t\t\tif(reducedindex < 0)reducedindex += thislength;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\treturn curseg.getOf(reducedindex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn \"0\";\n\t\t}\n\t\t\n\t\tpublic int getlength()\n\t\t{ //returns a max of 1000001\n\t\t\tif(issimple)\n\t\t\t{\n//\t\t\t\tSystem.out.println(\"SIMPLE COUNT \" + simplecontent);\n\t\t\t\treturn simplecontent.length();\n\t\t\t}\t\t\t\n\t\t\t\n\t\t\tint segs = subsegs.size();\n\t\t\tint ans = 0;\n\t\t\tfor(int cursegid = 0; cursegid < segs; cursegid++)\n\t\t\t{\n\t\t\t\tSegment curseg = subsegs.get(cursegid);\n\t\t\t\t\n\t\t\t\tans += curseg.getlength() * times.get(cursegid);\n\t\t\t\t\n//\t\t\t\tSystem.out.println(\"[\" + id + \"] count \" + ans);\n\t\t\t\t\n\t\t\t\tif(ans >= 1000001) {return 1000001;}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(\"[\" + id + \"] count \" + ans + \"              \" + subsegs.size() + \" \" + times.get(0));\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tpublic Segment(String content)\n\t\t{\n\t\t\t//we only need the first 1000000 chars!\n//\t\t\ttempcont = content;\n//\t\t\tSystem.out.println(id + \": \" + content);\n\t\t\t\n\t\t\tint curdepth = 0;\n\t\t\tint outermostparstart = 0;\n\n\t\t\tint numberstart = -1;\n\t\t\t\n\t\t\tint simplesegmentstart = 0; //ends when you hit a number, i guess.\n\t\t\tint reps = -1;\n\t\t\t\n\t\t\tissimple = true;\n\t\t\t\n\t\t\tfor(int i = 0; i < content.length(); i++)\n\t\t\t{\n\t\t\t\tString cur = content.substring(i, i+1);\n\t\t\t\tchar curc = content.charAt(i);\n\t\t\t\t\n\t\t\t\tif(curc >= 48 && curc <= 57)\n\t\t\t\t{\n\t\t\t\t\tissimple = false;\n\t\t\t\t\tif(curdepth == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsimplesegmentstart = i+1;\t\t\t\t\t\t\n\t\t\t\t\t\tif(numberstart == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnumberstart = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!(content.charAt(i+1) >= 48 && content.charAt(i+1) <= 57))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treps = Integer.parseInt(content.substring(numberstart,i+1));\n//\t\t\t\t\t\t\tSystem.out.println(\"reps \" + reps);\n\t\t\t\t\t\t\tnumberstart = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cur.equals(\"(\"))\n\t\t\t\t{\n\t\t\t\t\tissimple = false;\n\t\t\t\t\tif(curdepth == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\toutermostparstart = i;\n\t\t\t\t\t}\n\t\t\t\t\tcurdepth += 1;\n\t\t\t\t}\n\t\t\t\telse if(cur.equals(\")\"))\n\t\t\t\t{\n\t\t\t\t\tcurdepth -= 1;\n\t\t\t\t\t\n\t\t\t\t\tif(curdepth == 0)\n\t\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\t\tString minicontent = content.substring(outermostparstart+1, i);\n\t\t\t\t\t\tif(debug)System.out.println(reps + \" repetitions of \" + minicontent);\n\t\t\t\t\t\t\n\t\t\t\t\t\tsubsegs.add(new Segment(minicontent));\n\t\t\t\t\t\ttimes.add(reps);\n\t\t\t\t\t\tsimplesegmentstart = i+1;\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\treps = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{ //letters\n\t\t\t\t\tif(curdepth == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(reps > 0 && i > 0 && content.charAt(i-1) >= 48 && content.charAt(i-1) <= 57 )\n\t\t\t\t\t\t{ //repetition of single letters\n\t\t\t\t\t\t\tif(debug)System.out.println(reps + \" repetitions of letter \" + cur + \",         content[\" + content);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tsubsegs.add(new Segment(cur));\n\t\t\t\t\t\t\ttimes.add(reps);\n\t\t\t\t\t\t\tsimplesegmentstart = i+1;\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\treps =  -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //plain letters\n\t\t\t\t\t\t\tif(reps == -1 && (i == content.length()-1 || !(content.charAt(i+1) >= 65 && content.charAt(i+1) <= 90)) && !(simplesegmentstart == 0 && i == content.length()-1) )\n\t\t\t\t\t\t\t{ //last letter in the plain text\n\t\t\t\t\t\t\t\tString simplesegstr = content.substring(simplesegmentstart, i+1);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsubsegs.add(new Segment(simplesegstr));\n\t\t\t\t\t\t\t\ttimes.add(1);\n\t\t\t\t\t\t\t\tsimplesegmentstart = i+1;\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"Added simple segment \" + simplesegstr + \"              content[\" + content);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(issimple)\n\t\t\t{\n\t\t\t\tsimplecontent = content;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tinput = scan.next();\n\t\t\ttargetindex = scan.nextInt();\n\t\t\t\n\t\t\tif(input.equals(\"0\") && targetindex == 0)return;\n\t\t\t\n\t\t\tSegment seg = new Segment(input);\n\t\t\t\n//\t\t\tSystem.out.println(\"total length \" + seg.getlength());\n\t\t\tif(debug)System.out.println(\"ANS: \");\n\t\t\tSystem.out.println(seg.getOf(targetindex));\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport static java.math.BigInteger.valueOf;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nabstract class Tree {\n    public abstract BigInteger length();\n    public abstract char get(int i);\n\n    private static char[] input;\n    private static int ptr;\n    private static Tree top() {\n        Tree tree;\n        if (input[ptr] == '(') {\n            ptr++;\n            tree = top();\n            assert input[ptr] == ')';\n            ptr++;\n        } else {\n            Node node = new Node();\n            while (true) {\n                if (Character.isDigit(input[ptr])) {\n                    int n = num();\n                    if (input[ptr] == '(') {\n                        node.addChild(n, top());\n                    } else {\n                        node.addChild(n, new Leaf(String.valueOf(input[ptr])));\n                        ptr++;\n                    }\n                } else if (Character.isUpperCase(input[ptr])) {\n                    node.addChild(1, new Leaf(seq()));\n                } else {\n                    tree = node;\n                    break;\n                }\n            }\n        }\n        return tree;\n    }\n\n    public static String seq() {\n        StringBuilder seq = new StringBuilder();\n        while (Character.isUpperCase(input[ptr])) {\n            seq.append(input[ptr]);\n            ptr++;\n        }\n        return seq.toString();\n    }\n\n    public static int num() {\n        int number = 0;\n        while (Character.isDigit(input[ptr])) {\n            number = number * 10 + (input[ptr] - '0');\n            ptr++;\n        }\n        return number;\n    }\n\n    public static Tree construct(String seq) {\n        input = (seq + '\\u0000').toCharArray();\n        ptr = 0;\n        return top();\n    }\n}\n\nclass Node extends Tree {\n    final List<Integer> ns = new ArrayList<Integer>();\n    final List<Tree> children = new ArrayList<Tree>();\n    private BigInteger length = BigInteger.ZERO;\n    public void addChild(int n, Tree child) {\n        ns.add(n);\n        children.add(child);\n        length = length.add(child.length().multiply(valueOf(n)));\n    }\n    @Override\n    public BigInteger length() {\n        return length;\n    }\n    @Override\n    public char get(int i) {\n        BigInteger index = valueOf(i);\n        for (int j = 0; j < ns.size(); j++) {\n            if (children.get(j).length().multiply(valueOf(ns.get(j))).compareTo(index) > 0) {\n                return children.get(j).get(index.mod(children.get(j).length()).intValue());\n            } else {\n                index = index.subtract(children.get(j).length().multiply(valueOf(ns.get(j))));\n            }\n        }\n        return 0;\n    }\n    @Override\n    public String toString() {\n        final StringBuilder builder = new StringBuilder();\n        builder.append('(');\n        for (int i = 0; i < ns.size(); i++) {\n            builder.append(ns.get(i));\n            builder.append(children.get(i).toString());\n        }\n        builder.append(')');\n        return builder.toString();\n    }\n}\n\nclass Leaf extends Tree {\n    private final String seq;\n    public Leaf(String seq) {\n        this.seq = seq;\n    }\n    @Override\n    public BigInteger length() {\n        return valueOf(seq.length());\n    }\n    @Override\n    public char get(int i) {\n        return seq.charAt(i);\n    }\n    @Override\n    public String toString() {\n        return seq;\n    }\n}\n\nclass Main {\n    private static void solve() {\n        final Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            final String s = scanner.next();\n            final int i = scanner.nextInt();\n            if (s.equals(\"0\") && i == 0) {\n                break;\n            }\n            final Tree tree = Tree.construct(s);\n            final char c = tree.get(i);\n            if (c == 0) {\n                System.out.println(0);\n            } else {\n                System.out.println(c);\n            }\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tchar[] a, b;\n\tint n;\n\tint id, pos;\n\t\n\tvoid A(){\n\t\twhile(true){\n\t\t\tint start = pos;\n\t\t\tint t = id;\n\t\t\tint num = 1;\n\t\t\tint goal;\n\t\t\twhile(Character.isDigit(a[id])==true) id++;\n\t\t\tif(id!=t) num = Integer.valueOf(s.substring(t,id));\n\t\t\tB();\n\t\t\t\n\t\t\tgoal = pos;\n\t\t\tfor(int i=0;i<num-1;i++){\n\t\t\t\tfor(int j=start;j<goal;j++){\n\t\t\t\t\tif(pos>n || j>n){\n\t\t\t\t\t\ti = num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tb[pos] = b[j];\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(id==a.length || a[id]==')') break;\n\t\t}\n\t}\n\t\n\tvoid B(){\n\t\tif(a[id]=='('){\n\t\t\tid++;\n\t\t\tA();\n\t\t\tid++;\n\t\t}else{\n\t\t\tint t = id;\n\t\t\twhile(id<s.length() && Character.isUpperCase(a[id])==true) id++;\n\t\t\tif(id==a.length || a[id]==')' || Character.isDigit(a[id])==true){\n\t\t\t\tfor(int i=t;i<id;i++){\n\t\t\t\t\tif(pos>n) break;\n\t\t\t\t\tb[pos] = a[i];\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\ta = s.toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\tb = new char[n+1];\n\t\t\tArrays.fill(b,'0');\n\t\t\tid = 0;\n\t\t\tpos = 0;\n\t\t\tA();\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(b[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    final static long INF = 1000000L * 1000L;\n    boolean over;\n    long len;\n    boolean isAtom;\n    String atom;\n    LinkedList<Node> children = new LinkedList<>();\n    int address;\n  }\n\n  Node kaiseki(int index) {\n    Node node = new Node();\n    node.len = 0;\n    while (index < s.length() && s.charAt(index) != ')') {\n      if (Character.isAlphabetic(s.charAt(index))) {\n        StringBuilder sb = new StringBuilder();\n        while (index < s.length() && Character.isAlphabetic(s.charAt(index))) {\n          sb.append(s.charAt(index++));\n        }\n        Node child = new Node();\n        child.isAtom = true;\n        child.atom = sb.toString();\n        child.len = child.atom.length();\n\n        node.children.add(child);\n        node.len += child.len;\n      } else {\n        assert Character.isDigit(s.charAt(index));\n        long len = 0;\n        while (Character.isDigit(s.charAt(index))) {\n          char c = s.charAt(index++);\n          len = len * 10 + c - '0';\n        }\n        Node child = new Node();\n        child.isAtom = false;\n        if (s.charAt(index) == '(') {\n          ++index;\n          Node mago = kaiseki(index);\n          index = mago.address;\n          ++index;\n          child.children.add(mago);\n          child.over |= mago.over;\n          len *= mago.len;\n        } else {\n          Node mago = new Node();\n          mago.isAtom = true;\n          mago.atom = s.charAt(index++) + \"\";\n          mago.len = 1;\n          child.children.add(mago);\n        }\n        child.len = len;\n        node.children.add(child);\n        node.len += len;\n        node.over |= child.over;\n      }\n      node.over |= node.len >= Node.INF;\n    }\n    node.address = index;\n    return node;\n  }\n\n  String s;\n\n  void run() {\n    for (; ; ) {\n      s = sc.next();\n      int index = ni();\n      if (s.charAt(0) == '0') {\n        break;\n      }\n      Node root = kaiseki(0);\n      if (!root.over && root.len <= index) {\n        System.out.println(0);\n        continue;\n      }\n      Node node = root;\n      for (; ; ) {\n        if (node.isAtom) {\n          System.out.println(node.atom.charAt(index));\n          break;\n        }\n        for (Node next : node.children) {\n          if (next.over) {\n            node = next;\n            break;\n          } else if (index < next.len) {\n            node = next;\n            if (node.isAtom) {\n              index %= node.len;\n            } else {\n              long sum = 0;\n              for (Node ite : next.children) {\n                sum += ite.len;\n              }\n              index %= sum;\n            }\n            break;\n          } else {\n            index -= next.len;\n          }\n        }\n      }\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tif(flg) return \"\";\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tif(flg) return \"\";\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#' || word == '(')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"\";\n\t\tString res = fact();\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(flg) return \"\";\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tdata = new char[ansindex+1];\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString result = exp();\n//\t\t\t//debug\n//\t\t\tfor(int i=0; i < data.length;i++){\n//\t\t\t\tSystem.out.print(data[i] + \":\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.print(\"ANS=\");\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    String S;\n    int I;\n    ArrayList<Character> line;\n    boolean end;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    S = sc.next();\n\t    I = sc.nextInt();\n\t    if(S.equals(\"0\") && I==0)break;\n\t    line = new ArrayList<Character>();\n\t    end = false;\n\t    splitLine(S);\n\n\t    String ans = \"\";\n\t    if(I>=line.size())ans = \"0\";\n\t    else ans = String.valueOf(line.get(I));\n\t    System.out.println(ans);\n\t}\n    }\n\n    void splitLine(String s){\n\tif(end)return;\n\tfor(int i=0; i<s.length(); i++){\n\t    if(s.charAt(i)-'A'<=25 && s.charAt(i)-'A'>=0){\n\t\tint j = i+1;\n\t\tfor(j=i+1; j<s.length(); j++){\n\t\t    if(!(s.charAt(j)-'A'<=25 && s.charAt(j)-'A'>=0))break;\n\t\t}\n\t\taddLine(s.substring(i,j));\n\t\tif(end)return;\n\t\ti = j-1;\n\t    }else{\n\t\tint iL = i;\n\t\tfor(iL=i+1; iL<s.length(); iL++){\n\t\t    if(!(s.charAt(iL)<10 || s.charAt(iL)=='0'))break;\n\t\t}\n\t\tint num = 0;\n\t\tint j=iL;\n\t\tfor(j=iL; j<s.length(); j++){\n\t\t    if(s.charAt(j)=='('){num++;}\n\t\t    if(s.charAt(j)==')')num--;\n\t\t    if(num==0)break;\n\t\t}\n\t\tint count = Integer.parseInt(s.substring(i,iL));\n\t\tString newS = \"\";\n\t\tif(iL==j){\n\t\t    newS = s.substring(iL,iL+1);\n\t\t}else{\n\t\t    newS = s.substring(iL+1,j);\n\t\t}\n\t\twhile(count-->0)splitLine(newS);\n\t\ti = j;\n\t    }\n\t}\n    }\n    \n    void addLine(String s){\n\tchar[] c = s.toCharArray();\n\tfor(int i=0; i<c.length; i++){\n\t    line.add(c[i]);\n\t    if(line.size()>I){end = true; return;}\n\t}\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tchar[] b;\n\tboolean[] f;\n\tint n;\n\t\n\tvoid func(){\n\t\tString u;\n\t\tint pos = 0;\n\t\tint p, q, r, t, id;\n\t\tboolean flag = false;\n\t\twhile(true){\n\t\t\tt = 0;\n\t\t\twhile(true){\n\t\t\t\tp = s.indexOf(')', t);\n\t\t\t\tif(p==-1 || f[p]==false) break;\n\t\t\t\tt = p+1;\n\t\t\t}\n\t\t\tt = p;\n\t\t\twhile(true){\n\t\t\t\tq = s.lastIndexOf('(', t);\n\t\t\t\tif(q==-1 || f[q]==false) break;\n\t\t\t\tt = q-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1 && q==-1) break;\n\t\t\t\n\t\t\tf[p] = true;\n\t\t\tf[q] = true;\n\t\t\tr = 1;\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tu = s.substring(id+1, q);\n\t\t\tif(u.compareTo(\"\")!=0) r = Integer.valueOf(u); \n\t\t\t\n\t\t\tif(f[p-1]==false){\n\t\t\t\tu = s.substring(q+1,p);\n\t\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\t\tfor(int j=0;j<p-q-1;j++){\n\t\t\t\t\t\tb[pos] = u.charAt(j);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = p;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tt = pos;\n\t\t\t\tfor(int i=0;i<r-1;i++){\n\t\t\t\t\tfor(int j=0;j<t;j++){\n\t\t\t\t\t\tb[pos] = b[j];\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tif(pos==n+1){\n\t\t\t\t\t\t\ti = r;\n\t\t\t\t\t\t\tj = t;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(flag==true) break;\n\t\t}\n\t}\n\t\n\tString tf(char[] a){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar[] c = new char[1000];\n\t\tint pos = 0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(Character.isUpperCase(a[i])==true){\n\t\t\t\tif(i==0 || i==a.length-1 || c[pos-1]==')' || Character.isDigit(c[pos-1])==true || (c[pos-1]=='(' && Character.isUpperCase(a[i+1])==false)){\n\t\t\t\t\tc[pos] = '(';\n\t\t\t\t\tc[pos+1] = a[i];\n\t\t\t\t\tc[pos+2] = ')';\n\t\t\t\t\tpos += 3;\n\t\t\t\t}else{\n\t\t\t\t\tc[pos] = a[i];\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tc[pos] = a[i];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<pos;i++) sb.append(c[i]);\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tchar[] a = sc.next().toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\ts = tf(a);\n\t\t\tSystem.out.println(s);\n\t\t\tf = new boolean[s.length()];\n\t\t\tb = new char[n+1];\n\t\t\tArrays.fill(b,'0');\n\t\t\tfunc();\n\t\t\tSystem.out.println(b[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s;\n\tboolean[] f;\n\tint n;\n\t\n\tvoid func(){\n\t\tString u;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint p, q, r, t, id;\n\t\tboolean check = false;\n\t\twhile(true){\n\t\t\tt = 0;\n\t\t\twhile(true){\n\t\t\t\tp = s.indexOf(')', t);\n\t\t\t\tif(p==-1 || f[p]==false) break;\n\t\t\t\tt = p+1;\n\t\t\t}\n\t\t\tt = p;\n\t\t\twhile(true){\n\t\t\t\tq = s.lastIndexOf('(', t);\n\t\t\t\tif(q==-1 || f[q]==false) break;\n\t\t\t\tt = q-1;\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1 && q==-1) break;\n\t\t\t\n\t\t\tf[p] = true;\n\t\t\tf[q] = true;\n\t\t\tr = 1;\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && Character.isDigit(s.charAt(id))==true) id--;\n\t\t\tu = s.substring(id+1, q);\n\t\t\tif(u.compareTo(\"\")!=0) r = Integer.valueOf(u); \n\t\t\t\n\t\t\tif(f[p-1]==false){\n\t\t\t\tu = s.substring(q+1,p);\n\t\t\t\tfor(int i=0;i<r;i++) sb.append(u);\n\t\t\t}else{\n\t\t\t\tu = sb.toString();\n\t\t\t\tfor(int i=0;i<r-1;i++) sb.append(u);\n\t\t\t}\n\t\t\t\n\t\t\tcheck = true;\n\t\t\tif(sb.length()>n) break;\n\t\t}\n\t\t\n\t\tif(check==false){\n\t\t\tif(s.length()>n) System.out.println(s.charAt(n));\n\t\t\telse System.out.println(0);\n\t\t}else{\n\t\t\tif(sb.length()>n) System.out.println(sb.charAt(n));\n\t\t\telse System.out.println(0);\n\t\t}\n\t}\n\t\n\t\n\tString tf(char[] a){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(Character.isUpperCase(a[i])==true\n\t\t\t\t&& (i==0 || Character.isUpperCase(a[i-1])==false)\n\t\t\t\t\t&& (i==a.length-1 || Character.isUpperCase(a[i+1])==false)){\n\t\t\t\t\t\tsb.append('(').append(a[i]).append(')');\n\t\t\t}else{\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tchar[] a = sc.next().toCharArray();\n\t\t\tn = sc.nextInt();\n\t\t\tif(a[0]=='0' && n==0) break;\n\t\t\ts = tf(a);\n\t\t\tf = new boolean[s.length()];\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tString str;\n\tint p, n;\n\tchar ans;\n\tstatic final int INF = 1<<30;\n\tstatic final int LONG = INF+1;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tstr = in.next();\n\t\t\tn = in.nextInt();\n\t\t\tif(str.equals(\"0\") && n==0) return ;\n\t\t\tans = '0';\n\t\t\tsolve();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tif(n == 0 && str.length()>=1 && Character.isUpperCase(str.charAt(0))){\n\t\t\tans = str.charAt(0);\n\t\t\treturn ;\n\t\t}\n\t\tp = 0;\n\t\tint len = expr();\n\t\tif(len <= n) return ;\n\t\tp = 0;\n\t\tint t = term();\n\t\tif(t <= n){\n\t\t\tstr = str.substring(p);\n\t\t\tn -= t;\n\t\t\tsolve();\n\t\t\treturn ;\n\t\t}\n\t\tp = 0;\n\t\tnum();\n\t\tif(Character.isUpperCase(str.charAt(p))){\n\t\t\tans = str.charAt(p);\n\t\t\treturn ;\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t\tint q = p;\n\t\t\tint b = expr();\n\t\t\tn %= b;\n\t\t\tstr = str.substring(q, p);\n\t\t\tsolve();\n\t\t\treturn ;\n\t\t}\n\t}\n\t\n\tint expr(){\n\t\tif(p==str.length() || str.charAt(p)==')') return 0;\n\t\tint r = term(), a = expr();\n\t\tif(r == LONG || a == LONG){\n\t\t\treturn LONG;\n\t\t}\n\t\telse{\n\t\t\treturn r + a > n+1?LONG:r+a;\n\t\t}\n\t}\n\n\tint term(){\n\t\tif(Character.isUpperCase(str.charAt(p))){\n\t\t\tp++;\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\tint a = num();\n\t\t\tif(Character.isUpperCase(str.charAt(p))){\n\t\t\t\tp++;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t\tp++;\n\t\t\tint b = expr();\n\t\t\tp++;\n\t\t\tif( b == LONG ){\n\t\t\t\treturn LONG;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn a*b;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tint num(){\n\t\tif(p==str.length()) return INF;\n\t\tint q = p;\n\t\tchar c = str.charAt(p);\n\t\tif(!Character.isDigit(c)) return INF;\n\t\tp++;\n\t\tint a = num(), b = c-'0';\n\t\tif(a==INF) return b;\n\t\tfor(int i=0; i<p-q-1;i++){\n\t\t\tb *= 10;\n\t\t}\n\t\treturn b + a;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\npublic class Main {\n\tString str;\n\tint pos;\n\tchar [] data;\n\tint ind;\n\tint ansindex;\n\tboolean flg;\n\t\n\tprivate String exp(){\n\t\tStringBuilder res = new StringBuilder(term());\n\t\tchar word = str.charAt(pos);\n\t\twhile(!(word == ')' || word == '#')){\n\t\t\tres.append(term());\n\t\t\tif(flg) break;\n\t\t\tword = str.charAt(pos);\n\t\t}\n\t\treturn res.toString();\n\t}\n\t\n\tprivate String term(){\n\t\tif(flg) return \"A\";\n\t\tString res = fact();\n\t\tchar input = res.charAt(0);\n\t\tif(Character.isDigit(input)){\n\t\t\tint times = Integer.parseInt(res);\n\t\t\tString word = fact();\n\t\t\tStringBuilder res2 = new StringBuilder(word);\n\t\t\tif(flg) return res2.toString();\n\t\t\tfor(int i=1; i < times; i++){\n\t\t\t\tres2.append(word);\n\t\t\t\tfor(int j=0; j < word.length();j++){\n\t\t\t\t\tdata[ind++] = word.charAt(j);\n\t\t\t\t\tif(ind == ansindex + 1){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\treturn res2.toString();\n\t\t}\n\t\telse{\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate String fact(){\n\t\tif(flg) return \"A\";\n\t\tif(Character.isDigit(str.charAt(pos))){\n\t\t\tStringBuilder t = new StringBuilder(\"\"+str.charAt(pos++)) ;\n\t\t\twhile(Character.isDigit(str.charAt(pos))){\n\t\t\t\tt.append(\"\" +(str.charAt(pos++)));\n\t\t\t}\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if(str.charAt(pos) == '('){\n\t\t\tpos++;\n\t\t\tString res = exp();\n\t\t\tpos++;\n\t\t\treturn res;\n\t\t}\n\t\telse{\n\t\t\tString res = \"\" + str.charAt(pos++);\n\t\t\tdata[ind++] = res.charAt(0);\n\t\t\tif(ind == ansindex + 1) flg = true;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\twhile(true){\n\t\t\tstr = sc.next();\n\t\t\tansindex = sc.nextInt();\n\t\t\tif(str.equals(\"0\") && ansindex == 0) break;\n\t\t\tdata = new char[ansindex + 1];\n\t\t\tstr += \"#\";\n\t\t\tpos = 0;\n\t\t\tind = 0;\n\t\t\tflg = false;\n\t\t\tString result = exp();\n\t\t\tif(data[ansindex] == '\\u0000'){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(data[ansindex]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tString s, t;\n\tint n;\n\t\n\tvoid func(){\n\t\tboolean flag;\n\t\tString v = s;\n\t\tString u = s;\n\t\tStringBuffer cc;\n\t\tint id, p, q, r, t;\n\t\twhile(true){\n\t\t\tp = s.indexOf(')');\n\t\t\tq = s.lastIndexOf('(', p);\n\t\t\tr = p;\n\t\t\tif(r==-1) r = s.length();\n\t\t\t\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tif(Character.isUpperCase(s.charAt(i))==true){\n\t\t\t\t\tif(i==0 || Character.isUpperCase(s.charAt(i-1))==false){\n\t\t\t\t\t\tif(i==s.length()-1 || Character.isUpperCase(s.charAt(i+1))==false){\n\t\t\t\t\t\t\tp = i;\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(p==-1) break;\n\t\t\t\n\t\t\tif(flag==false){\n\t\t\t\tu = s.substring(q+1, p);\n\t\t\t}else{\n\t\t\t\tu = s.substring(p,p+1);\n\t\t\t\tq = p;\n\t\t\t}\n\t\t\t\n\t\t\tid = q-1;\n\t\t\twhile(id!=-1 && 48<=s.charAt(id) && s.charAt(id)<=57) id--;\n\t\t\tid++;\n\t\t\tv = s.substring(id, q);\n\t\t\tif(v.length()>0) r = Integer.valueOf(v);\n\t\t\telse r = 1;\n\t\t\t\n\t\t\tt = id;\n\t\t\tid--;\n\t\t\twhile(id!=-1 && 65<=s.charAt(id) && s.charAt(id)<=90) id--;\n\t\t\tid++;\n\t\t\t\n\t\t\tcc = new StringBuffer(s.substring(0,t));\n\t\t\tfor(int i=0;i<r;i++) cc.append(u);\n\t\t\ts = cc.append(s.substring(p+1, s.length())).toString();\n\t\t\t\n\t\t\tif(flag==true) q-=2;\n\t\t\tv = s.substring(id, t+(p-q-1)*r);\n\t\t\tif(v.length()>n) break;\n\t\t}\n\t\tif(v.length()>n) System.out.println(s.charAt(n));\n\t\telse System.out.println(0);\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\ts = sc.next();\n\t\t\tn = sc.nextInt();\n\t\t\tif(s.compareTo(\"0\")==0 && n==0) break;\n\t\t\tfunc();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ts = in.next().toCharArray();\n\t\t\tint idx = in.nextInt();\n\t\t\tif(s[0] == '0') break;\n\t\t\tNode base = new Node(1);\n\t\t\tcur = 0;\n\t\t\twhile(cur < s.length){\n\t\t\t\tbase.edge.add(gen());\n\t\t\t}\n//\t\t\tfor(int i=0; i<100; i++){\n//\t\t\t\tint val = (int)base.dfs(i);\n//\t\t\t\tif(val >= 0) break;\n//\t\t\t\tSystem.out.print(res);\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(base.dfs(idx) < 0 ? res : '0');\n\t\t}\n\t}\n\t\n\tpublic static char res;\n\tpublic static int cur;\n\tpublic static Node gen(){\n\t\tif(Character.isDigit(s[cur])){\n\t\t\tint num = 0;\n\t\t\twhile(Character.isDigit(s[cur])){\n\t\t\t\tnum *= 10;\n\t\t\t\tnum += s[cur++]-'0';\n\t\t\t}\n\t\t\tif(Character.isUpperCase(s[cur])){\n\t\t\t\treturn new Node(s[cur++]+\"\", num);\n\t\t\t}\n\t\t\tcur++;\n\t\t\tNode node = new Node(num);\n\t\t\twhile(cur < s.length && s[cur] != ')')\n\t\t\t\tnode.edge.add(gen());\n\t\t\tcur++;\n\t\t\treturn node;\n\t\t}else{\n\t\t\treturn new Node(getStr(), 1);\n\t\t}\n\t}\n\t\n\tpublic static String getStr(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(cur < s.length && Character.isUpperCase(s[cur]))\n\t\t\tsb.append(s[cur++]);\n\t\treturn sb.toString();\n\t}\n}\n\nclass Node{\n\tArrayList<Node> edge;\n\tString str;\n\tint num;\n\tpublic Node(int num){\n\t\tedge = new ArrayList<Node>();\n\t\tthis.num = num;\n\t}\n\t\n\tpublic Node(String str, int num){\n\t\tthis.str = str;\n\t\tthis.num = num;\n\t}\n\t\n\tpublic String toString(){\n\t\tif(str != null){\n\t\t\treturn (num>1?num:\"\")+str;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num>1) sb.append(num+\"<\");\n\t\tfor(Node v: edge) sb.append(v);\n\t\tif(num>1) sb.append('>');\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic long dfs(long sidx){\n\t\t// sidx : ??????????????¢\n\t\tif(str != null){\n\t\t\tif(sidx <= str.length()*num-1){\n\t\t\t\tsidx = sidx % str.length();\n\t\t\t\tMain.res = str.charAt((int)sidx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn sidx-str.length()*num;\n\t\t}\n\t\tlong origin = sidx;\n\t\tfor(Node v: edge){\n\t\t\tsidx = v.dfs(sidx);\n\t\t\tif(sidx<0) return sidx;\n\t\t}\n\t\tlong len = origin - sidx;\n\t\tif((origin+len)/len <= num){\n\t\t\treturn dfs(origin % len);\n\t\t}\n\t\treturn origin - num*len;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "class GenomeDB\n  class GenomeData\n    def initialize\n      @length = 0\n      @num = 0\n      @data_array = []\n    end\n\n    attr_accessor :num\n\n    def size\n      @length\n    end\n\n    def << data\n      @length += data.size * @num\n      @data_array << data\n      self\n    end\n\n    def [] i\n      return nil if i >= @length\n      index = i\n      @num.times do\n        @data_array.each do |data|\n          if index >= data.size\n            index -= data.size\n            next\n          end\n          return data[index]\n        end\n      end\n    end\n  end\n\n  class << self\n    def parse seq\n      result = GenomeData.new\n      result.num = 1\n      data_array = genome_parse(seq, 0).first\n      if data_array.instance_of?(Array)\n        data_array.each do |data|\n          result << data\n        end\n      else\n        result << data_array\n      end\n      result\n    end\n\n    private\n    def genome_parse seq, start\n      i = start\n      result = []\n\n      word = ''\n      while i < seq.size\n        case seq[i]\n        when /[A-Z]/\n          word << seq[i]\n          i += 1\n        when /[0-9]/\n          unless word.size == 0\n            result << word\n            word = ''\n          end\n          genome_data,next_index = get_compress_data(seq, i)\n          result << genome_data\n          i = next_index\n        when \")\"\n          unless word.size == 0\n            result << word\n            word = ''\n          end\n          i += 1\n          break\n        end\n      end\n      result << word unless word.size == 0\n      [result, i]\n    end\n\n    def get_compress_data seq, start\n      num = get_num_token(seq, start)\n      data_array,next_index = get_data(seq, start + num.size)\n      genome_data = GenomeData.new\n      genome_data.num = num.to_i\n      if data_array.instance_of?(Array)\n        data_array.each do |data|\n          genome_data << data\n        end\n      else\n        genome_data << data_array\n      end\n      [genome_data, next_index]\n    end\n\n    def get_data seq, start\n      i = start\n      data_array = []\n      case seq[i]\n      when \"(\"\n        i += 1\n        data_array,next_index = genome_parse(seq, i)\n        i = next_index\n      when /[A-Z]/\n        data_array << seq[i]\n        i += 1\n      end\n      [data_array, i]\n    end\n\n    def get_num_token seq, start\n      num = ''\n      i = start\n      while i < seq.size\n        if seq[i] =~ /[A-Z(]/\n          break\n        end\n        num << seq[i]\n        i += 1\n      end\n      num\n    end\n  end\nend\n\ndef main\n  loop do\n    seq,index = gets.chomp.split(' ')\n    break if seq.eql?('0') and index.eql?('0')\n    puts GenomeDB.parse(seq)[index.to_i] || '0'\n  end\nend\n\nif $0 == __FILE__\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      @i += 1 if @s[@i] == \"(\"\n      word = parse\n      return word if word.size >= @target\n      @i += 1 if @s[@i] == \")\"\n      n.times do\n        result += word\n        return result if result.size >= @target\n      end\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      return result if result.size >= @target\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = @s[@i,@s.size].to_i\n  @i += Math::log10(n).to_i + 1\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "class GenomeDB\n  class GenomeData\n    def initialize\n      @length = 0\n      @num = 0\n      @data_array = []\n    end\n\n    attr_accessor :num\n\n    def size\n      @length\n    end\n\n    def << data\n      @length += data.size * @num\n      @data_array << data\n      self\n    end\n\n    def [] i\n      return '0' if i >= @length\n      index = i\n      @num.times do\n        @data_array.each do |data|\n          if index >= data.size\n            index -= data.size\n            next\n          end\n          return data[index]\n        end\n      end\n    end\n  end\n\n  class << self\n    def parse seq\n      result = GenomeData.new\n      result.num = 1\n      data_array = genome_parse(seq, 0).first\n      if data_array.instance_of?(Array)\n        data_array.each do |data|\n          result << data\n        end\n      else\n        result << data_array\n      end\n      result\n    end\n\n    private\n    def genome_parse seq, start\n      i = start\n      result = []\n\n      word = ''\n      while i < seq.size\n        case seq[i]\n        when /[A-Z]/\n          word << seq[i]\n          i += 1\n        when /[0-9]/\n          unless word.size == 0\n            result << word\n            word = ''\n          end\n          genome_data,next_index = get_compress_data(seq, i)\n          result << genome_data\n          i = next_index\n        when \")\"\n          unless word.size == 0\n            result << word\n            word = ''\n          end\n          i += 1\n          break\n        end\n      end\n      result << word unless word.size == 0\n      [result, i]\n    end\n\n    def get_compress_data seq, start\n      num = get_num_token(seq, start)\n      data_array,next_index = get_data(seq, start + num.size)\n      genome_data = GenomeData.new\n      genome_data.num = num.to_i\n      if data_array.instance_of?(Array)\n        data_array.each do |data|\n          genome_data << data\n        end\n      else\n        genome_data << data_array\n      end\n      [genome_data, next_index]\n    end\n\n    def get_data seq, start\n      i = start\n      data_array = []\n      case seq[i]\n      when \"(\"\n        i += 1\n        data_array,next_index = genome_parse(seq, i)\n        i = next_index\n      when /[A-Z]/\n        data_array << seq[i]\n        i += 1\n      end\n      [data_array, i]\n    end\n\n    def get_num_token seq, start\n      num = ''\n      i = start\n      while i < seq.size\n        if seq[i] =~ /[A-Z(]/\n          break\n        end\n        num << seq[i]\n        i += 1\n      end\n      num\n    end\n  end\nend\n\ndef main\n  loop do\n    seq,index = gets.chomp.split(' ')\n    break if seq.eql?('0') and index.eql?('0')\n    puts GenomeDB.parse(seq)[index.to_i]\n  end\nend\n\nif $0 == __FILE__\n  main\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\n# <genom> = <term> | <term> <genom>\n# <term> = <elm>+ | <num> <elm> | <num> '(' <genom> ')'\n# <elm> = 'A'..'Z'\n# <num> = ('0'..'9')+\n\ndef genom(gnm, i)\n  glen = 0\n  gch = nil\n\n  while ! gnm[$pos].nil? && gnm[$pos] != ')'\n    tlen, tch = term(gnm, i)\n    if gch.nil?\n      gch = tch if ! tch.nil?\n      i -= tlen\n    end\n    glen += tlen\n  end\n\n  [glen, gch]\nend\n\ndef term(gnm, i)\n  case gnm[$pos]\n  when 'A'..'Z'\n    len = 1\n    loop do\n      ch = gnm[$pos + len]\n      break if ch.nil? || ch < 'A' || ch > 'Z'\n      len += 1\n    end\n    tch = (i < len) ? gnm[$pos + i] : nil\n    $pos += len\n    return [len, tch]\n  when '0'..'9'\n    nlen = 1\n    loop do\n      ch = gnm[$pos + nlen]\n      break if ch < '0' || ch > '9'\n      nlen += 1\n    end\n    num = gnm[$pos, nlen].to_i\n    $pos += nlen\n\n    if gnm[$pos] == '('\n      $pos += 1\n      pos0 = $pos\n      glen, gch = genom(gnm, i)\n      $pos += 1\n      gnlen = glen * num\n      return [gnlen, gch] if ! gch.nil? || i >= gnlen\n\n      $pos = pos0\n      i0 = i % glen\n      glen, gch = genom(gnm, i0)\n      $pos += 1\n      return [gnlen, gch]\n    else\n      tch = (i < num) ? gnm[$pos] : nil\n      $pos += 1\n      return [nlen, tch]\n    end\n  end\nend\n\n### main\n\nloop do\n  gnm, ist = gets.strip.split\n  break if gnm == '0' && ist == '0'\n\n  i = ist.to_i\n  #p [gnm, i]\n\n  $pos = 0\n  num, ch = genom(gnm, i)\n  #p [num, ch]\n\n  puts (ch.nil? ? 0 : ch)\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      @i += 1 if @s[@i] == \"(\"\n      word = parse\n      return word if word.size > @target\n      @i += 1 if @s[@i] == \")\"\n      n.times do\n        result += word\n        return result if result.size > @target\n      end\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = @s[@i,@s.size].to_i\n  @i += Math::log10(n).to_i + 1\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(s,_l,_r)\n\tr=''\n\ti=_l\n\tn=nil\n\twhile i<_r\n\t\tif ('0'..'9').include?(s[i])\n\t\t\tif !n\n\t\t\t\tn=s[i].to_i\n\t\t\telse\n\t\t\t\tn=n*10+s[i].to_i\n\t\t\tend\n\t\t\ti+=1\n\t\telsif s[i]=='('\n\t\t\tn=1 if !n\n\t\t\tcnt=1\n\t\t\tj=i+1\n\t\t\twhile cnt>0\n\t\t\t\tif s[j]=='('\n\t\t\t\t\tcnt+=1\n\t\t\t\telsif s[j]==')'\n\t\t\t\t\tcnt-=1\n\t\t\t\tend\n\t\t\t\tj+=1\n\t\t\tend\n\t\t\t_r=dfs(s,i+1,j-1)\n\t\t\tn.times{\n\t\t\t\tr+=_r\n\t\t\t\treturn r if r.size>$n\n\t\t\t}\n\t\t\tn=nil\n\t\t\ti=j\n\t\telse\n\t\t\tn=1 if !n\n\t\t\tr+=s[i]*n\n\t\t\tn=nil\n\t\t\ti+=1\n\t\tend\n\tend\n\tr\nend\ni=0\nloop{\n\ts,_=gets.split\n\tbreak if s=='0'\n\t$n=_.to_i\n\tr=dfs(s,0,s.size)\n\tputs r.size>$n ? r[$n] : '0'\n}"
  },
  {
    "language": "Ruby",
    "code": "def check_size arr\n  case a=arr.shift\n  when /[A-Z]+/\n    a.size\n  when /\\d+/\n    a.to_i*check_size(arr)\n  when ?(\n    ans=0\n    ans+=check_size(arr) while arr[0]!=?)\n    arr.shift\n    ans\n  end\nend\n\ndef get_ch arr,n\n  while a=arr.shift\n    case a\n    when /[A-Z]+/\n      l=a.size\n      break a[n] if n<l\n      n-=l\n    when /\\d+/\n      tarr=arr.dup\n      l=check_size(tarr)\n      break get_ch(arr,n%l) if n<l*a.to_i\n      arr=tarr\n      n-=l*a.to_i\n    end\n  end\nend\n\nwhile (a,b=gets.split)!=[?0]*2\n  puts get_ch(a.scan(/[A-Z]+|\\(|\\)|\\d+/),b.to_i)||0\nend"
  },
  {
    "language": "Ruby",
    "code": "\ndef solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      @i += 1 if @s[@i] == \"(\"\n      word = parse\n      return word if word.size >= @target\n      @i += 1 if @s[@i] == \")\"\n      n.times {result += word}\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = @s[@i,@s.size].to_i\n  @i += Math::log10(n).to_i + 1\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "def check_size arr\n  ans=0\n  while a=arr.shift\n    case a\n    when /[A-Z]+/\n      ans+=a.size\n    when /\\d+/\n      t=arr.shift\n      ans+=a.to_i*(t==?(?check_size(arr):t.size)\n    when ?)\n      break\n    end\n  end\n  ans\nend\n\ndef get_ch arr,n\n  #p [arr,n]\n  while a=arr.shift\n    case a\n    when /[A-Z]+/\n      l=a.size\n      if n<l\n        return a[n]\n      end\n      n-=l\n    when /\\d+/\n      arr.shift if arr[0]==?(\n      tarr=arr.dup\n      l=check_size(tarr)\n      #p [l,arr,tarr,n]\n      if n<l*a.to_i\n        n%=l\n        return get_ch(arr,n)\n      end\n      arr=tarr\n      n-=l*a.to_i\n    end\n  end\n  #p [arr,n,\"error\"]\n  #n\nend\n\nwhile gets\n  a,b=$_.split\n  break if a==?0\n  cnt=b.to_i\n  arr = a.scan(/[A-Z]+|\\(|\\)|\\d+/)\n#  p check_size arr\n  puts get_ch(arr,cnt)||0\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(s,_l,_r)\n\tr=''\n\ti=_l\n\tn=nil\n\twhile i<_r\n\t\tif ('0'..'9').include?(s[i])\n\t\t\tif !n\n\t\t\t\tn=s[i].to_i\n\t\t\telse\n\t\t\t\tn=n*10+s[i].to_i\n\t\t\tend\n\t\t\ti+=1\n\t\telsif s[i]=='('\n\t\t\tn=1 if !n\n\t\t\tcnt=1\n\t\t\tj=i+1\n\t\t\twhile cnt>0\n\t\t\t\tif s[j]=='('\n\t\t\t\t\tcnt+=1\n\t\t\t\telsif s[j]==')'\n\t\t\t\t\tcnt-=1\n\t\t\t\tend\n\t\t\t\tj+=1\n\t\t\tend\n\t\t\tr0=dfs(s,i+1,j-1)\n\t\t\tn.times{\n\t\t\t\tr+=r0\n\t\t\t\treturn r if r.size>$n\n\t\t\t}\n\t\t\tn=nil\n\t\t\ti=j\n\t\telse\n\t\t\tn=1 if !n\n\t\t\tr+=s[i]*n\n\t\t\tn=nil\n\t\t\ti+=1\n\t\tend\n\tend\n\tr\nend\ni=0\nloop{\n\ts,_=gets.split\n\tbreak if s=='0'\n\t$n=_.to_i\n\tr=dfs(s,0,s.size)\n\tputs r.size>$n ? r[$n] : '0'\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\n# <genom> = <term> | <term> <genom>\n# <term> = <elm>+ | <num> <elm> | <num> '(' <genom> ')'\n# <elm> = 'A'..'Z'\n# <num> = ('0'..'9')+\n\ndef genom(gnm, i)\n  glen = 0\n  gch = nil\n\n  while ! gnm[$pos].nil? && gnm[$pos] != ')'\n    tlen, tch = term(gnm, i)\n    gch = tch if gch.nil? && ! tch.nil?\n    i -= tlen if gch.nil?\n    glen += tlen\n  end\n\n  [glen, gch]\nend\n\ndef term(gnm, i)\n  if /[A-Z]/ =~ gnm[$pos]\n    len = parse_alph(gnm)\n    tch = (i < len) ? gnm[$pos + i] : nil\n    $pos += len\n    return [len, tch]\n  end\n\n  len = parse_num(gnm)\n  num = gnm[$pos, len].to_i\n  $pos += len\n\n  if gnm[$pos] == '('\n    $pos += 1\n    pos0 = $pos\n    glen, gch = genom(gnm, i)\n    $pos += 1\n    gnlen = glen * num\n    return [gnlen, gch] if ! gch.nil? || i >= gnlen\n\n    $pos = pos0\n    i0 = i % glen\n    glen, gch = genom(gnm, i0)\n    $pos += 1\n    return [gnlen, gch]\n  else\n    tch = (i < num) ? gnm[$pos] : nil\n    $pos += 1\n    return [num, tch]\n  end\nend\n\ndef parse_alph(gnm)\n  len = 0\n  while /[A-Z]/ =~ gnm[$pos + len]\n    len += 1\n  end\n  len\nend\n\ndef parse_num(gnm)\n  len = 0\n  while /[0-9]/ =~ gnm[$pos + len]\n    len += 1\n  end\n  len\nend\n\n### main\n\nloop do\n  gnm, ist = gets.strip.split\n  break if gnm == '0' && ist == '0'\n\n  i = ist.to_i\n  #p [gnm, i]\n\n  $pos = 0\n  num, ch = genom(gnm, i)\n  #p [num, ch]\n\n  puts (ch.nil? ? 0 : ch)\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(s)\n\tr=''\n\ti=0\n\tn=nil\n\twhile i<s.size\n\t\tif ('0'..'9').include?(s[i])\n\t\t\tif !n\n\t\t\t\tn=s[i].to_i\n\t\t\telse\n\t\t\t\tn=n*10+s[i].to_i\n\t\t\tend\n\t\t\ti+=1\n\t\telsif s[i]=='('\n\t\t\tn=1 if !n\n\t\t\tcnt=1\n\t\t\tj=i+1\n\t\t\twhile cnt>0\n\t\t\t\tif s[j]=='('\n\t\t\t\t\tcnt+=1\n\t\t\t\telsif s[j]==')'\n\t\t\t\t\tcnt-=1\n\t\t\t\tend\n\t\t\t\tj+=1\n\t\t\tend\n\t\t\t_r=dfs(s[i+1..j-2])\n\t\t\tr+=_r\n\t\t\treturn r if r.size>=$n\n\t\t\tr+=_r*(n-1)\n\t\t\tn=nil\n\t\t\ti=j\n\t\telse\n\t\t\tn=1 if !n\n\t\t\tr+=s[i]*n\n\t\t\tn=nil\n\t\t\ti+=1\n\t\tend\n\tend\n\tr\nend\nloop{\n\ts,_=gets.split\n\tbreak if s=='0'\n\t$n=_.to_i\n\tr=dfs(s)\n\tputs $n<r.size ? r[$n] : '0'\n}"
  },
  {
    "language": "Ruby",
    "code": "def solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      @i += 1 if @s[@i] == \"(\"\n      word = parse\n      return word if word.size > @target\n      @i += 1 if @s[@i] == \")\"\n      n.times do\n        result += word\n        return result if result.size > @target\n      end\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      return result if result.size > @target\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = @s[@i,@s.size].to_i\n  @i += Math::log10(n).to_i + 1\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      case @s[@i]\n        when \"(\"\n          @i += 1\n          word = parse\n          @i += 1\n        else\n          word = @s[@i]\n          @i += 1\n      end\n      n.times do\n        result += word\n        return result if result.size > @target\n      end\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = 0\n  while @s[@i] =~ /[0-9]/ do\n    n *= 10\n    n += @s[@i].to_i\n    @i += 1\n  end\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(s)\n\tr=''\n\ti=0\n\tn=nil\n\twhile i<s.size\n\t\tif ('0'..'9').include?(s[i])\n\t\t\tif !n\n\t\t\t\tn=s[i].to_i\n\t\t\telse\n\t\t\t\tn=n*10+s[i].to_i\n\t\t\tend\n\t\t\ti+=1\n\t\telsif s[i]=='('\n\t\t\tn=1 if !n\n\t\t\tcnt=1\n\t\t\tj=i+1\n\t\t\twhile cnt>0\n\t\t\t\tif s[j]=='('\n\t\t\t\t\tcnt+=1\n\t\t\t\telsif s[j]==')'\n\t\t\t\t\tcnt-=1\n\t\t\t\tend\n\t\t\t\tj+=1\n\t\t\tend\n\t\t\t_r=dfs(s[i+1..j-2])\n\t\t\treturn _r if _r.size>=$n\n\t\t\tr=r+_r*n\n\t\t\tn=nil\n\t\t\ti=j\n\t\telse\n\t\t\tn=1 if !n\n\t\t\tr+=s[i]*n\n\t\t\tn=nil\n\t\t\ti+=1\n\t\tend\n\tend\n\tr\nend\nloop{\n\ts,_=gets.split\n\tbreak if s=='0'\n\t$n=_.to_i\n\tr=dfs(s)\n\tputs $n<r.size ? r[$n] : '0'\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(s)\n\tr=''\n\ti=0\n\tn=nil\n\twhile i<s.size\n\t\tif ('0'..'9').include?(s[i])\n\t\t\tif !n\n\t\t\t\tn=s[i].to_i\n\t\t\telse\n\t\t\t\tn=n*10+s[i].to_i\n\t\t\tend\n\t\t\ti+=1\n\t\telsif s[i]=='('\n\t\t\tn=1 if !n\n\t\t\tcnt=1\n\t\t\tj=i+1\n\t\t\twhile cnt>0\n\t\t\t\tif s[j]=='('\n\t\t\t\t\tcnt+=1\n\t\t\t\telsif s[j]==')'\n\t\t\t\t\tcnt-=1\n\t\t\t\tend\n\t\t\t\tj+=1\n\t\t\tend\n\t\t\t_r=dfs(s[i+1..j-2])\n\t\t\tn.times{\n\t\t\t\tr+=_r\n\t\t\t\treturn r if r.size>$n\n\t\t\t}\n\t\t\tn=nil\n\t\t\ti=j\n\t\telse\n\t\t\tn=1 if !n\n\t\t\tr+=s[i]*n\n\t\t\tn=nil\n\t\t\ti+=1\n\t\tend\n\tend\n\tr\nend\ni=0\nloop{\n\ts,_=gets.split\n\tbreak if s=='0'\n\t$n=_.to_i\n\tr=dfs(s)\n\tputs r.size>$n ? r[$n] : '0'\n}"
  },
  {
    "language": "Ruby",
    "code": "def solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      @i += 1 if @s[@i] == \"(\"\n      word = parse\n#       return word if word.size > @target\n      @i += 1 if @s[@i] == \")\"\n      n.times do\n        result += word\n        return result if result.size > @target\n      end\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = @s[@i,@s.size].to_i\n  @i += Math::log10(n).to_i + 1\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "def check_size arr\n  ans=0\n  while a=arr.shift\n    case a\n    when /[A-Z]+/\n      ans+=a.size\n    when /\\d+/\n      t=arr.shift\n      ans+=a.to_i*(t==?(?check_size(arr):t.size)\n    when ?)\n      break\n    end\n  end\n  ans\nend\n\ndef get_ch arr,n\n  #p [arr,n]\n  while a=arr.shift\n    case a\n    when /[A-Z]+/\n      l=a.size\n      if n<l\n        return a[n]\n      end\n      n-=l\n    when /\\d+/\n      if arr[0]==?(\n        arr.shift\n        tarr=arr.dup\n        l=check_size(tarr)\n        #p [l,arr,tarr,n]\n        if n<l*a.to_i\n          n%=l\n          return get_ch(arr,n)\n        end\n        arr=tarr\n        n-=l*a.to_i\n      else\n        b=arr.shift\n        l=b.size\n        if n<l*a.to_i\n          return b[n%l]\n        end\n        n-=l*a.to_i\n      end\n    end\n  end\n  #p [arr,n,\"error\"]\n  #n\nend\n\nwhile gets\n  a,b=$_.split\n  break if a==?0\n  cnt=b.to_i\n  arr = a.scan(/[A-Z]+|\\(|\\)|\\d+/)\n#  p check_size arr\n  puts get_ch(arr,cnt)||0\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve(s, i)\n  @s = s\n  @target = i\n  @i = 0\n  answer = parse[i]\n  return answer ? answer : \"0\"\nend\n\ndef parse\n  return \"\" if @i >= @s.size\n  result = \"\"\n  case @s[@i]\n    when /[0-9]/\n      n = number\n      @i += 1 if @s[@i] == \"(\"\n      word = parse\n      @i += 1 if @s[@i] == \")\"\n      n.times do\n        result += word\n        return result if result.size > @target\n      end\n    when \")\"\n      return \"\"\n    else\n      result += @s[@i]\n      @i += 1\n  end\n  result + parse\nend\n\ndef number\n  n = 0\n  while @s[@i] =~ /[0-9]/ do\n    n *= 10\n    n += @s[@i].to_i\n    @i += 1\n  end\n  n\nend\n\nuntil (s,i=gets.split).all?{|w|w==\"0\"} do\n  puts solve(s, i.to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "class Exp\n\tdef initialize(*args)\n\t\t@children = args\n\tend\n\tdef to_s\n\t\t@children.map(&:to_s).join\n\tend\n\tdef size\n\t\t@children.map(&:size).inject(:+)\n\tend\n\n\tdef [](k)\n\t\ts = @children[0].size\n\t\tif k < s\n\t\t\t@children[0][k]\n\t\telse\n\t\t\t@children[1][k-s]\n\t\tend\n\tend\nend\n\nclass Term\n\tdef initialize(*args)\n\t\t@children = args\n\tend\n\tdef to_s\n\t\tif @children[0].class == Num\n\t\t\t@children[1].to_s * @children[0].value.to_i\n\t\telse\n\t\t\t@children[0].to_s\n\t\tend\n\tend\n\tdef size\n\t\tif @children[0].class == Num\n\t\t\t@children[1].size * @children[0].value.to_i\n\t\telse\n\t\t\t@children[0].size\n\t\tend\n\tend\n\n\tdef [](k)\n\t\tif @children[0].class == Num\n\t\t\t@children[1][k % @children[1].size]\n\t\telse\n\t\t\t@children[0].to_s\n\t\tend\n\tend\nend\n\nclass Alph\n\tdef initialize(value)\n\t\t@value = value\n\tend\n\tdef to_s\n\t\t@value\n\tend\n\tdef size\n\t\t1\n\tend\n\tdef [](k)\n\t\t@value\n\tend\nend\n\nclass Num\n\tdef initialize(value)\n\t\t@value = value\n\tend\n\n\tdef size\n\t\t@value.size\n\tend\n\tattr_reader :value\nend\n\ndef get_exp(tokens, i)\n\treturn [nil, i] if i >= tokens.size\n\tt, i = get_term(tokens, i)\n\treturn [nil, i] unless t\n\n\te, i = get_exp(tokens, i)\n\tif e\n\t\treturn [Exp.new(t, e), i]\n\telse\n\t\treturn [Exp.new(t), i]\n\tend\nend\n\ndef get_term(tokens, i)\n\treturn [nil, i] if i >= tokens.size\n\n\ta, j = get_alph(tokens, i)\n\tif a\n\t\treturn [Term.new(a), j]\n\tend\n\n\tn, j = get_num(tokens, i)\n\treturn [nil, i] unless n\n\n\ta, k = get_alph(tokens, j)\n\tif a\n\t\treturn [Term.new(n, a), k]\n\tend\n\n\te, k = get_exp(tokens, j+1)\n\tif tokens[j] == ?( && e && tokens[k] == ?)\n\t\treturn [Term.new(n, e), k+1]\n\telse\n\t\treturn [nil, i]\n\tend\nend\n\ndef get_alph(tokens, i)\n\treturn [nil, i] if i >= tokens.size\n\tif ('A'..'Z') === tokens[i] \n\t\treturn [Alph.new(tokens[i]), i+1]\n\tend\n\t[nil, i]\nend\n\ndef get_num(tokens, i)\n\treturn [nil, i] if i >= tokens.size\n\tif tokens[i] =~ /^\\d+$/\n\t\treturn [Num.new(tokens[i]), i+1]\n\tend\n\t[nil, i]\nend\n\nloop {\n\ts, n = gets.chomp.split\n\tbreak if s == ?0\n\tn = n.to_i\n\n\ttokens = s.scan(/\\d+|[()\\w]/)\n\te, _ = get_exp(tokens, 0)\n\tif n < e.size\n\t\tputs e[n]\n\telse\n\t\tputs 0\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "def check_size arr\n  case a=arr.shift\n  when /[A-Z]+/\n    a.size\n  when /\\d+/\n    a.to_i*check_size(arr)\n  when ?(\n    ans=0\n    ans+=check_size(arr) while arr[0]!=?)\n    arr.shift\n    ans\n  end\nend\n\ndef get_ch arr,n\n  while a=arr.shift\n    case a\n    when /[A-Z]+/\n      l=a.size\n      break a[n] if n<l\n      n-=l\n    when /\\d+/\n      tarr=arr.dup\n      l=check_size(tarr)\n      break get_ch(arr,n%l) if n<l*a.to_i\n      arr=tarr\n      n-=l*a.to_i\n    end\n  end\nend\n\nwhile (a,b=gets.split)!=[?0]*2\n  puts get_ch(a.scan(/[A-Z]+|\\(|\\)|\\d+/),b.to_i)||0\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(s)\n\tr=''\n\ti=0\n\tn=nil\n\twhile i<s.size\n\t\tif ('0'..'9').include?(s[i])\n\t\t\tif !n\n\t\t\t\tn=s[i].to_i\n\t\t\telse\n\t\t\t\tn=n*10+s[i].to_i\n\t\t\tend\n\t\t\ti+=1\n\t\telsif s[i]=='('\n\t\t\tn=1 if !n\n\t\t\tcnt=1\n\t\t\tj=i+1\n\t\t\twhile cnt>0\n\t\t\t\tif s[j]=='('\n\t\t\t\t\tcnt+=1\n\t\t\t\telsif s[j]==')'\n\t\t\t\t\tcnt-=1\n\t\t\t\tend\n\t\t\t\tj+=1\n\t\t\tend\n\t\t\t_r=dfs(s[i+1..j-2])\n\t\t\tr+=_r\n\t\t\treturn r[0,$n] if r.size>=$n\n\t\t\tr+=_r*(n-1)\n\t\t\tn=nil\n\t\t\ti=j\n\t\telse\n\t\t\tn=1 if !n\n\t\t\tr+=s[i]*n\n\t\t\tn=nil\n\t\t\ti+=1\n\t\tend\n\tend\n\tr\nend\nloop{\n\ts,_=gets.split\n\tbreak if s=='0'\n\t$n=_.to_i\n\tr=dfs(s)\n\tputs $n<r.size ? r[$n] : '0'\n}"
  },
  {
    "language": "Python",
    "code": "def uncompress(text, L):\n    newText = ''\n    pos = 0\n    while True:\n        if len(newText) > L:\n            break\n        if pos >= len(text):\n            break\n        if text[pos].isdigit():\n            endDigit = getEndDigit(text, pos)\n            num = int(text[pos : endDigit])\n            if text[endDigit] == '(':\n                endPar = getEndParenthesis(text, endDigit)\n                insideText = uncompress(text[endDigit + 1 : endPar - 1], L - len(newText))\n                for _ in range(num):\n                    newText += insideText\n                    if len(newText) > L:\n                        break\n                pos = endPar\n            else:\n                newText += (text[endDigit] * num)\n                pos = endDigit + 1\n        else:\n            newText += text[pos]\n            pos += 1\n    return newText\n\ndef getEndParenthesis(text, pos):\n    count = 0\n    while True:\n        if text[pos] == '(':\n            count += 1\n        elif text[pos] == ')':\n            count -= 1\n        if count == 0:\n            return pos + 1\n        pos += 1\n\ndef getEndDigit(text, pos):\n    while True:\n        if not text[pos].isdigit():\n            return pos\n        pos += 1\n\nif __name__ == '__main__':\n    while True:\n        text, idx = input().strip().split()\n        if text == '0' and idx == '0':\n            break\n\n        text = uncompress(text, int(idx))\n        print(text[int(idx)] if len(text) > int(idx) else 0)\n"
  },
  {
    "language": "Python",
    "code": "from string import digits, ascii_uppercase\ndef parse(S):\n    S += \"$\"\n    cur = 0\n    res = []\n    def expr():\n        nonlocal cur\n        R = []; l = 0\n        while 1:\n            c = S[cur]\n            if c in digits:\n                v = number()\n                if S[cur] == '(':\n                    cur += 1 # '('\n                    R0, l0 = expr()\n                    cur += 1 # ')'\n                    l += v * l0\n                    R.append((v, l0, R0))\n                else:\n                    c = S[cur]\n                    cur += 1 # 'A' ~ 'Z'\n                    l += v\n                    R.append((v, 1, [c]))\n            elif c in ascii_uppercase:\n                cur += 1 # 'A' ~ 'Z'\n                l += 1\n                R.append(c)\n            else:\n                break\n        return R, l\n\n    def number():\n        nonlocal cur\n        v = 0\n        while 1:\n            c = S[cur]\n            if c not in digits:\n                break\n            v = 10*v + int(c)\n            cur += 1 # '0' ~ '9'\n        return v\n\n    R, l = expr()\n    return R, l\n\ndef solve(res, x):\n    R, l = res\n    if l <= x:\n        return \"0\"\n    cur = R\n    while 1:\n        for data in cur:\n            if isinstance(data, str):\n                if x == 0:\n                    return data\n                x -= 1\n            else:\n                v, l, R = data\n                if x < v*l:\n                    cur = R\n                    x %= l\n                    break\n                x -= v*l\n\nwhile 1:\n    S, x = input().split()\n    if S == \"0\":\n        break\n    x = int(x)\n    R, l = res = parse(S)\n    if l <= x:\n        print(\"0\")\n        continue\n    print(solve(res, x))\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    def pearser(s, n):\n        if s == \"\":\n            return \"\"\n        i = 0\n        while 1:\n            if not s[i].isdigit():break\n            i += 1\n        if i == 0:\n            r = pearser(s[i + 1:], n - 1)\n            return s[0] + r\n        if s[i] == \"(\":\n            r = Parentp(s[i:], n, int(s[:i]))\n        else:\n            r = s[i] * int(s[:i])\n            if len(r) >= n:\n                return r[:n]\n            r += pearser(s[i+1:], n - len(r))\n        return r\n\n    def Parentp(s, n, p):\n        if s == \"\": return \"\"\n        b = 0\n        c = 0\n        i = 0\n        while 1:\n            if s[i] == \"(\":\n                c += 1\n            if s[i] == \")\":\n                c -= 1\n            if c == 0:\n                break\n            i += 1\n        r = pearser(s[b + 1:i], n)\n        l = len(r)\n        if l * p >= n:\n            r = r * (n // l + 1)\n            return r[:n]\n        r = r * p\n        r += pearser(s[i+1:], n - len(r))\n        return r\n\n    def m(s,n):\n        n = int(n)\n        r = pearser(s, n + 1)\n        if len(r) <= n:\n            print(0)\n            return\n        print(r[n])\n\n    while 1:\n        s, n = map(str, input().split())\n        if s == n == \"0\":\n            break\n        m(s, n)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef check(c):\n    return (ord(c) >= ord('0') and ord(c) <= ord('9'))\n\ndef check2(c):\n    return (ord(c) >= ord('A') and ord(c) <= ord('Z'))\n\nwhile True:\n    S1, S2 = raw_input().split()\n    if S1 == '0':\n        break\n    N = int(S2)\n    SS = ''\n    flag = False\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if check(S1[i]) and not check(S1[i + 1]) and S1[i + 1] != '(':\n            SS += '('\n            flag = True\n        elif flag:\n            SS += ')'\n            flag = False\n    SS += S1[len(S1) - 1]\n    if flag:\n        SS += ')'\n    S1 = '(' + SS + ')'\n    for i in range(26):\n        c = chr(ord('A') + i)\n        S1 = S1.replace('(' + c, '(\"' + c)\n        S1 = S1.replace(c + ')', c + '\")')\n        S1 = S1.replace(')' + c, ')\"' + c)\n        S1 = S1.replace(c + '(', c + '\"(')\n        for j in range(10):\n            c2 = str(j)\n            S1 = S1.replace(c + c2, c + '\"' + c2)\n    S1 = S1[1 : -1]\n    print S1\n    S1 = S1.replace('(', ',')\n    SS = ''\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if not check(S1[i]) and check(S1[i + 1]):\n            SS += '('\n    SS += S1[len(S1) - 1]\n    if check(S1[0]):\n        SS = '(' + SS\n    S1 = '(1, ' + SS + ')'\n    S1 = S1.replace(')(', '),(')\n    S1 = S1.replace(')\"', '),\"')\n    S1 = S1.replace('\"(', '\",(')\n    print S1\n    hoge = eval(S1)\n    ans = 0\n    m = {}\n    def func(obj):\n        if type(obj) == type(\"hoge\"):\n            m[obj] = len(obj)\n            return len(obj)\n        num = obj[0]\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += num * func(obj[i])\n        m[obj] = ret\n        return ret\n\n    def func2(obj, index):\n        if type(obj) == type(\"hoge\"):\n            return obj[index]\n        num = obj[0]\n        S = m[obj]\n        index %= S / num\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += m[obj[i]]\n            if ret > index:\n                ret -= m[obj[i]]\n                return func2(obj[i], index - ret)\n        return '0'\n    \n    func(hoge)\n    #print m\n    if N >= m[hoge]:\n        print '0'\n    else:\n        print func2(hoge, N)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(s,n):\n        def _f(s, n):\n            # print('_f', s,n)\n            l = len(s)\n            if l == 0 or n < 1:\n                return ''\n            r = ''\n            if '1' <= s[0] <= '9':\n                c = int(s[0])\n                ti = 1\n                for i in range(1,l):\n                    ti = i\n                    if not ('0' <= s[i] <= '9'):\n                        break\n                    c *= 10\n                    c += int(s[i])\n                if s[ti] == '(':\n                    k = 1\n                    ki = ti+1\n                    for i in range(ti+1,l):\n                        if s[i] == '(':\n                            k += 1\n                        elif s[i] == ')':\n                            k -= 1\n                            if k == 0:\n                                ki = i\n                                break\n                    kr = _f(s[ti+1:ki], n)\n                    kl = len(kr)\n                    if kl * c >= n:\n                        r = kr * (n//kl+1)\n                        return r[:n]\n                    r = kr * c\n                    r += _f(s[ki+1:], n - len(r))\n                    return r\n                else:\n                    r += s[ti] * c\n                    if len(r) >= n:\n                        return r[:n]\n                    r += _f(s[ti+1:], n - len(r))\n                    return r\n            r = s[0] + _f(s[1:], n - 1)\n            return r\n\n        fr = _f(s, n+1)\n        # print(len(fr),fr[n:n+1])\n        if len(fr) <= n:\n            return '0'\n        return fr[n]\n\n    while 1:\n        s,n = LS()\n        if s == '0' and n == '0' :\n            break\n        rr.append(f(s, int(n)))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef check(c):\n    return (ord(c) >= ord('0') and ord(c) <= ord('9'))\n\ndef check2(c):\n    return (ord(c) >= ord('A') and ord(c) <= ord('Z'))\n\nwhile True:\n    S1, S2 = raw_input().split()\n    if S1 == '0':\n        break\n    N = int(S2)\n    SS = ''\n    flag = False\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if check(S1[i]) and not check(S1[i + 1]) and S1[i + 1] != '(':\n            SS += '('\n            flag = True\n        elif flag:\n            SS += ')'\n            flag = False\n    SS += S1[len(S1) - 1]\n    if flag:\n        SS += ')'\n    S1 = '(' + SS + ')'\n    for i in range(26):\n        c = chr(ord('A') + i)\n        S1 = S1.replace('(' + c, '(\"' + c)\n        S1 = S1.replace(c + ')', c + '\")')\n        S1 = S1.replace(')' + c, ')\"' + c)\n        S1 = S1.replace(c + '(', c + '\"(')\n        for j in range(10):\n            c2 = str(j)\n            S1 = S1.replace(c + c2, c + '\"' + c2)\n    S1 = S1[1 : -1]\n    S1 = S1.replace('(', ',')\n    SS = ''\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if not check(S1[i]) and check(S1[i + 1]):\n            SS += '('\n    SS += S1[len(S1) - 1]\n    if check(S1[0]):\n        SS = '(' + SS\n    S1 = '(1, ' + SS + ')'\n    S1 = S1.replace(')(', '),(')\n    S1 = S1.replace(')\"', '),\"')\n    S1 = S1.replace('\"(', '\",(')\n    hoge = eval(S1)\n    ans = 0\n    m = {}\n    def func(obj):\n        if type(obj) == type(\"hoge\"):\n            m[obj] = len(obj)\n            return len(obj)\n        num = obj[0]\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += num * func(obj[i])\n        m[obj] = ret\n        return ret\n\n    def func2(obj, index):\n        if type(obj) == type(\"hoge\"):\n            return obj[index]\n        num = obj[0]\n        S = m[obj]\n        index %= S / num\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += m[obj[i]]\n            if ret > index:\n                ret -= m[obj[i]]\n                return func2(obj[i], index - ret)\n        return '0'\n    \n    func(hoge)\n    #print m\n    if N >= m[hoge]:\n        print '0'\n    else:\n        print func2(hoge, N)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\ndef parse_expr(s,i,num):\n    if i < len(s) and f_num[s[i]]:\n        n,i = parse_num(s,i,num)\n        if s[i] == \"(\":\n            i += 1\n            su = 0\n            while i < len(s) and s[i] != \")\":\n                e,i = parse_expr(s,i,num)\n                su += e\n            return su*n,i+1\n        else:\n            k,i = parse_alp(s,i,n)\n            return k+n-1,i\n    else:\n        k,i = parse_alp(s,i,num)\n        return k,i\n\ndef parse_num(s,i,num):\n    m = int(s[i])\n    i += 1\n    while i < len(s) and f_num[s[i]]:\n        m *= 10\n        m += int(s[i])\n        i += 1\n    return num*m,i\n\ndef parse_alp(s,i,num):\n    k = 1\n    i += 1\n    while i < len(s) and f_alp[s[i]]:\n        k += 1\n        i += 1\n    return k,i\n\ndef find(s,l,r,i):\n    if l == r:\n        return 0\n    su,k = parse_expr(s,l,1)\n    if i < su:\n        if l < r and f_alp[s[l]]:\n            return s[l+i]\n        else:\n            n,l = parse_num(s,l,1)\n            if l < r and s[l] == \"(\":\n                return find(s,l+1,k-1,i%(su//n))\n            else:\n                return find(s,l,k,i%(su//n))\n    else:\n        return find(s,k,r,i-su)\nwhile 1:\n    s,i = input().split()\n    if s == i == \"0\":break\n    i = int(i)\n    f_alp = defaultdict(lambda : 0)\n    f_num = defaultdict(lambda : 0)\n    for a in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        f_alp[a] = 1\n    for a in range(10):\n        f_num[str(a)] = 1\n    print(find(s,0,len(s),i))\n\n"
  },
  {
    "language": "Python",
    "code": "import re\nimport sys\n\nDIGIT_RE = re.compile(r'\\d+')\n\ndef decomp(string, cur, idx):\n    # returns a tuple (decomp_str, endpos)\n    decomp_str = ''\n\n    while cur < len(string):\n        if string[cur].isdigit():\n            m = DIGIT_RE.match(string, pos=cur)\n            times = int(m.group())\n            dstr, end = decomp(string, m.end(), idx)\n            if times*len(dstr) > idx:\n                print dstr[(idx-len(decomp_str))%len(dstr)]\n                raise Exception\n\n            decomp_str += times*dstr\n            cur = end\n\n        elif string[cur].isalpha():\n            decomp_str += string[cur]\n            cur += 1\n\n        elif string[cur] == ')':\n            cur += 1  # ignore\n\n        elif string[cur] == '(':\n            tmp = decomp(string, cur+1, idx)\n            decomp_str += tmp[0]\n            cur += tmp[1] + 1\n\n    return decomp_str, cur\n\ndef main():\n    while True:\n        string, idx = raw_input().split()\n        if (string, idx) == ('0', '0'):\n            break\n\n        idx = int(idx)\n\n        try:\n            dstr = decomp(string, 0, idx)[0]\n            print dstr[idx] if idx < len(dstr) else 0\n        except Exception:\n            continue\n\nif __name__ == '__main__':\n    main()\n        "
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef check(c):\n    return (ord(c) >= ord('0') and ord(c) <= ord('9'))\n\nwhile True:\n    S1, S2 = raw_input().split()\n    if S1 == '0':\n        break\n    N = int(S2)\n    SS = ''\n    flag = False\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if check(S1[i]) and not check(S1[i + 1]) and S1[i + 1] != '(':\n            SS += '('\n            flag = True\n        elif flag:\n            SS += ')'\n            flag = False\n    SS += S1[len(S1) - 1]\n    if flag:\n        SS += ')'\n    S1 = '(' + SS + ')'\n    for i in range(26):\n        S1 = S1.replace('(' + chr(ord('A') + i), '(\"' + chr(ord('A') + i))\n        S1 = S1.replace(chr(ord('A') + i) + ')', chr(ord('A') + i) + '\")')\n    S1 = S1[1:-1]\n    S1 = S1.replace('(', ',')\n    SS = ''\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if not check(S1[i]) and check(S1[i + 1]):\n            SS += '('\n            flag = True\n    SS += S1[len(S1) - 1]\n    if check(S1[0]):\n        SS = '(' + SS\n    S1 = '(1, ' + SS + ')'\n    S1 = S1.replace(')(', '),(')\n    hoge = eval(S1)\n    ans = 0\n    m = {}\n    def func(obj):\n        if type(obj) == type(\"hoge\"):\n            m[obj] = len(obj)\n            return len(obj)\n        num = obj[0]\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += num * func(obj[i])\n        m[obj] = ret\n        return ret\n\n    def func2(obj, index):\n        if type(obj) == type(\"hoge\"):\n            return obj[index]\n        num = obj[0]\n        S = m[obj]\n        index %= S / num\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += m[obj[i]]\n            if ret > index:\n                ret -= m[obj[i]]\n                return func2(obj[i], index - ret)\n        return '0'\n    \n    func(hoge)\n    #print m\n    if N >= m[hoge]:\n        print '0'\n    else:\n        print func2(hoge, N)\n\n"
  },
  {
    "language": "Python",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct node{\n\tint number;\n\tstring letters;\n\tvector<node> children;\n\tchar get_char(int index,int &pos){\n\t\tint remain=index-pos+1;\n\t\tif(letters!=\"\"){\n\t\t\tif(letters.size()>=remain){\n\t\t\t\treturn letters[remain-1];\n\t\t\t}else{\n\t\t\t\tpos+=letters.size();\n\t\t\t\treturn '\\0';\n\t\t\t}\n\t\t}else{\n\t\t\tREP(i,number){\n\t\t\t\tREP(j,children.size()){\n\t\t\t\t\tchar c=children[j].get_char(index,pos);\n\t\t\t\t\tif(c!='\\0'){\n\t\t\t\t\t\treturn c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn '\\0';\n\t\t}\n\t}\n};\n\nint number(string &s,int &pos){\n\tint ret=0;\n\twhile(isdigit(s[pos])){\n\t\tret*=10;\n\t\tret+=s[pos]-'0';\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nstring letters(string &s,int &pos){\n\tstring ret;\n\twhile(isalpha(s[pos])){\n\t\tret+=s[pos];\n\t\tpos++;\n\t}\n\treturn ret;\n}\n\nvoid lp(string &s,int &pos){\n\tassert(s[pos]=='(');\n\tpos++;\n}\nvoid rp(string &s,int &pos){\n\tassert(s[pos]==')');\n\tpos++;\n}\nstring letter(string &s,int &pos){\n\tassert(isalpha(s[pos]));\n\tstring ret;\n\tret+=s[pos];\n\tpos++;\n\treturn ret;\n}\n\nvector<node> nodes(string &s,int &pos){\n\tvector<node> ret;\n\twhile(pos<s.size()){\n\t\tif(isdigit(s[pos])){\n\t\t\tnode nod;\n\t\t\tnod.number=number(s,pos);\n\t\t\tif(s[pos]=='('){\n\t\t\t\tlp(s,pos);\n\t\t\t\tnod.children=nodes(s,pos);\n\t\t\t\trp(s,pos);\n\t\t\t}else{\n\t\t\t\tnode c;\n\t\t\t\tc.letters=letter(s,pos);\n\t\t\t\tnod.children.push_back(c);\n\t\t\t}\n\t\t\tret.push_back(nod);\n\t\t}else if(isalpha(s[pos])){\n\t\t\tnode nod;\n\t\t\tnod.letters=letters(s,pos);\n\t\t\tret.push_back(nod);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tstring s;\n\tint index;\n\twhile(cin>>s>>index,s!=\"0\"||index){\n\t\tint pos=0;\n\t\tvector<node> roots=nodes(s,pos);\n\t\tpos=0;\n\t\tREP(i,roots.size()){\n\t\t\tchar c=roots[i].get_char(index,pos);\n\t\t\tif(c!='\\0'){\n\t\t\t\tcout<<c<<endl;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tcout<<0<<endl;\n\t\tnext:;\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\ndef check(c):\n    return (ord(c) >= ord('0') and ord(c) <= ord('9'))\n\ndef check2(c):\n    return (ord(c) >= ord('A') and ord(c) <= ord('Z'))\n\nwhile True:\n    S1, S2 = raw_input().split()\n    if S1 == '0':\n        break\n    N = int(S2)\n    SS = ''\n    flag = False\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if check(S1[i]) and not check(S1[i + 1]) and S1[i + 1] != '(':\n            SS += '('\n            flag = True\n        elif flag:\n            SS += ')'\n            flag = False\n    SS += S1[len(S1) - 1]\n    if flag:\n        SS += ')'\n    S1 = '(' + SS + ')'\n    for i in range(26):\n        c = chr(ord('A') + i)\n        S1 = S1.replace('(' + c, '(\"' + c)\n        S1 = S1.replace(c + ')', c + '\")')\n        S1 = S1.replace(')' + c, ')\"' + c)\n        S1 = S1.replace(c + '(', c + '\"(')\n        for j in range(10):\n            c2 = str(j)\n            S1 = S1.replace(c + c2, c + '\"' + c2)\n    S1 = S1[1 : -1]\n    S1 = S1.replace('(', ',')\n    SS = ''\n    for i in range(len(S1) - 1):\n        SS += S1[i]\n        if not check(S1[i]) and check(S1[i + 1]):\n            SS += '('\n    SS += S1[len(S1) - 1]\n    if check(S1[0]):\n        SS = '(' + SS\n    S1 = '(1, ' + SS + ')'\n    S1 = S1.replace(')(', '),(')\n    S1 = S1.replace(')\"', '),\"')\n    S1 = S1.replace('\"(', '\",(')\n    hoge = eval(S1)\n    ans = 0\n    m = {}\n    def func(obj):\n        if type(obj) == type(\"hoge\"):\n            m[obj] = len(obj)\n            return len(obj)\n        num = obj[0]\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += num * func(obj[i])\n        m[obj] = ret\n        return ret\n\n    def func2(obj, index):\n        if type(obj) == type(\"hoge\"):\n            return obj[index]\n        num = obj[0]\n        S = m[obj]\n        index %= S / num\n        ret = 0\n        for i in range(1, len(obj)):\n            ret += m[obj[i]]\n            if ret > index:\n                ret -= m[obj[i]]\n                return func2(obj[i], index - ret)\n        return '0'\n    \n    func(hoge)\n    if N >= m[hoge]:\n        print '0'\n    else:\n        print func2(hoge, N)\n\n"
  },
  {
    "language": "Python",
    "code": "def string(s,i):\n  l = 0\n  while i < len(s) and s[i].isalpha():\n    l += 1\n    i += 1\n  return i,l\n\ndef number(s,i):\n  n = 0\n  while i < len(s) and s[i].isdigit():\n    n = n*10 + (ord(s[i])-ord('0'))\n    i += 1\n  return i,n\n\ndef block(s,i):\n  if i < len(s) and s[i].isalpha():\n    return string(s,i)\n  else:\n    i,n = number(s,i)\n    if i < len(s) and s[i] == '(':\n      i += 1\n      sum = 0\n      while i < len(s) and s[i] != ')':\n        i,tmp = block(s,i)\n        sum += tmp\n      sum *= n\n      i += 1\n      return i,sum\n    else:\n      i,tmp = block(s,i)\n      sum = tmp*n\n      return i,sum\n\ndef find(s,i,j,p):\n  if i == j:\n    return 0\n  k,l = block(s,i)\n  if p < l:\n    if i < j and s[i].isalpha():\n      return s[i+p]\n    else:\n      i,n = number(s,i)\n      if i < j and s[i] == '(':\n        return find(s,i+1,k-1,p%(l//n))\n      else:\n        return find(s,i,k,p%(l//n))\n  else:\n    return find(s,k,j,p-l)\n\nif __name__ == '__main__':\n  while True:\n    [s,p] = input().split()\n    p = int(p)\n    if s == \"0\" and p == 0:\n      break\n    print(find(s,0,len(s),p))\n\n"
  }
]