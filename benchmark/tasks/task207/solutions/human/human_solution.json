[
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std; \n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nclass Dice\n{\npublic:\n    vector<int> pip; // ì¼kãºÌÚ\n    Dice(){\n        pip.assign(6, -1);\n    }\n    void roll(int d){ // ì¼kE¶Éñ]\n        int dir[][4] = {{4,2,5,0},{4,3,5,1},{4,0,5,2},{4,1,5,3},{0,3,2,1},{0,1,2,3}};\n        int tmp = pip[dir[d][0]];\n        for(int i=0; i<3; ++i)\n            pip[dir[d][i]] = pip[dir[d][i+1]];\n        pip[dir[d][3]] = tmp;\n    }\n};\n\nvector<vector<int> > mesh;\nvector<vector<bool> > check;\nDice dice;\nvoid solve(int y, int x)\n{\n    dice.pip[5] = mesh[y][x];\n    check[y][x] = true;\n    for(int i=0; i<4; ++i){\n        int y1 = y + dy[i];\n        int x1 = x + dx[i];\n        if(!check[y1][x1] && mesh[y1][x1] != 0){\n            dice.roll(i);\n            solve(y1, x1);\n            dice.roll((i+2)%4);\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n        mesh.assign(7, vector<int>(7, 0));\n        vector<int> num(6, 0);\n        int y1, x1;\n        for(int i=1; i<=5; ++i){\n            for(int j=1; j<=5; ++j){\n                cin >> mesh[i][j];\n                if(mesh[i][j] != 0){\n                    ++ num[mesh[i][j]-1];\n                    if(mesh[i][j] == 1){\n                        y1 = i;\n                        x1 = j;\n                    }\n                }\n            }\n        }\n\n        if(count(num.begin(), num.end(), 1) < 6){\n            cout << \"false\" << endl;\n            continue;\n        }\n\n        check.assign(7, vector<bool>(7, false));\n        dice = Dice();\n        solve(y1, x1);\n        if(dice.pip[0] + dice.pip[2] == 7 && dice.pip[1] + dice.pip[3] == 7 && dice.pip[4] + dice.pip[5] == 7)\n            cout << \"true\" << endl;\n        else\n            cout << \"false\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<iomanip>\n\n#define N 5\nusing namespace std;\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nstruct Dice{\n  int D[6];\n  Dice(){for(int i = 0; i < 6; ++i)D[i]=-1;}\n  void roll(int dir){\n    int t;\n    switch(dir){\n    case NORTH:t=D[4];D[4]=D[5];D[5]=D[1];D[1]=D[0];D[0]=t;break;\n    case EAST: t=D[3];D[3]=D[5];D[5]=D[2];D[2]=D[0];D[0]=t;break;\n    case SOUTH:t=D[1];D[1]=D[5];D[5]=D[4];D[4]=D[0];D[0]=t;break;\n    case WEST: t=D[2];D[2]=D[5];D[5]=D[3];D[3]=D[0];D[0]=t;break;\n    }\n  }\n  bool isDice(){\n    for(int i = 0; i < 3;++i){\n      if(D[i]+D[5-i]!=7)return false;\n    }\n    return true;\n  }\n};\n\nstruct state{\n  int i,j,pre;\n  state(int i, int j, int p):i(i),j(j),pre(p){}\n};\n\nbool isinside(int i, int j){\n  return 0<=i&&i<N&&0<=j&&j<N;\n}\n\nbool solve(int M[][N], int sti, int stj, int L){\n  queue<state> Q;\n  state st(sti,stj,1);\n  int left=L;\n  Dice d;\n  d.D[0]=M[sti][stj];\n  Q.push(st);\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    for(int k = (now.pre-1+4)%4, nk=0; nk < 4; ++nk){\n      state next(now.i+di[k],now.j+dj[k],k);\n      Dice td=d;\n      if(isinside(next.i,next.j)&&M[next.i][next.j]>0){\n\ttd.roll(k);\n\tif(td.D[0]==-1||td.D[0]==M[next.i][next.j]){\n\t  td.D[0]=M[next.i][next.j];\n\t  --left;\n\t  if(left<0)break;\n\t  Q.push(next);\n\t  d=td;\n\t  break;\n\t}else return false;\n      }\n      ++k;\n      k%=4;\n    }\n  }\n  set<int> S;\n  for(int i = 0; i < 6; ++i){\n    if(d.D[i]>0&&d.D[i]<7)S.insert(d.D[i]);\n  }\n  return (S.size()==6)&&d.isDice()&&L==6;\n}\n\nint main(){\n  int T;\n  \n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n\n    int M[N][N];\n    int sti,stj,l=0;\n    \n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcin >> M[i][j];\n\tif(M[i][j]>0){\n\t  sti=i;\n\t  stj=j;\n\t  ++l;\n\t}\n      }\n    }\n    cout << (solve(M,sti,stj,l)?\"true\":\"false\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\n\nvector<string> trim(const vector<string>& vec) {\n  int n,e,s,w;\n  w = IINF, e = -IINF, n = IINF, s = -IINF;\n\n  for(int y=0;y<vec.size();y++){\n    for(int x=0;x<vec[y].size();x++){\n      if(vec[y][x] == '0')continue;\n      w = min(w,x);\n      e = max(e,x);\n      n = min(n,y);\n      s = max(s,y);\n    }\n  }\n  vector<string> ret;\n  for(int y=n;y<=s;y++) ret.push_back(vec[y].substr(w,e-w+1));\n  return ret;\n}\n\nvector<string> rotate90(const vector<string>& piece){\n  vector<string> ret;\n  int h = piece[0].size(), w = piece.size();\n  ret.resize(h);\n  for(int i=0;i<h;i++)ret[i].resize(w);\n  for(int y=0;y<ret.size();y++){\n    for(int x=0;x<ret[0].size();x++){\n      ret[y][x] = piece[ret[0].size()-1-x][y];\n    }\n  }\n  return ret;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nFACE dir[] = {FRONT,LEFT,BACK,RIGHT};\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\ndice<int> makeDice(int top,int front)\n{\n  dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++)\n    {\n      if(around[top][i] == front)\n\t{\n\t  idx = i+1;\n\t  break;\n\t}\n    }\n  assert(idx != IINF);\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\n//\n\nint T,itmp;\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\nbool used[5][5];\nint counter[6];\n\ninline bool isValid(const vector<string>& vec,int x,int y){\n  return ( 0 <= x && x < vec[0].size() && 0 <= y && y < vec.size() );\n}\n\nvoid dfs(const vector<string> &vec,int x,int y){\n  if( used[y][x] ) return;\n  counter[vec[y][x]-'1']++;\n  used[y][x] = true;\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if( isValid(vec,nx,ny) ) {\n      if( !used[ny][nx] && vec[ny][nx] != '0' ) { \n        dfs(vec,nx,ny);\n      }\n    }\n  }\n}\n\n\n\nbool check(const vector<string> &vec){\n  rep(i,5)rep(j,5) used[i][j] = false;\n  rep(i,6) counter[i] = 0;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' ) {\n    dfs(vec,j,i);\n    goto Skip;\n  }\n Skip:;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' && !used[i][j] ) return false;\n  rep(i,6) if( counter[i] != 1 ) return false;\n  return true;\n}\n\nconst string YES = \"true\", NO = \"false\";\nint top,dice_tmp,H,W;\nbool error;\nconst bool DEBUG = false;\n\ninline void roller(dice<int> &die,int type){\n  if( type == 0 ) { // FRONT to TOP\n    rep(i,3) die.roll_x();\n  } else if( type == 1 ) { // LEFT to TOP\n    die.roll_y();\n  } else if( type == 2 ) { // BACK to TOP\n    die.roll_x();\n  } else { // RIGHT to TOP\n    rep(i,3) die.roll_y();\n  }\n}\n\nvoid dfs2(dice<int> &die,const vector<string>& vec,int x,int y){\n\n  if( error ) return;\n  if( used[y][x] ) return;\n  used[y][x] = true;\n  if( DEBUG )cout << \"(\" << x << \",\" << y << \") = \" << vec[y][x] << \" top = \" << die[TOP]+1  << \" rig = \" << die[RIGHT]+1<< endl;\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx] == '0' ) continue;\n    if( die[dir[i]] != vec[ny][nx]-'1' ) {\n      error = true;\n      return;\n    }\n\n    roller(die,i);\n    dfs2(die,vec,nx,ny);\n    roller(die,(i+2)%4);\n\n  }\n}\n\nbool correct(const vector<string>& vec){\n  dice<int> die = makeDice(top,dice_tmp);\n  int sx = -1, sy = -1;\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j]-'1' == top ) {\n    sx = j, sy = i;\n    break;\n  }\n  assert( sx != -1 && sy != -1 );\n  if(DEBUG)cout << \"TOP = \" << top << endl;\n  if(DEBUG)rep(i,6) { cout << die[face[i]] << endl; }\n\n  rep(i,4) {\n    int nx = sx + dx[i], ny = sy + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx]-'1' == dice_tmp ) {\n      int debug = 0;\n      while( die[dir[i]] != dice_tmp ){\n        die.roll_z();\n        debug++;\n        assert(debug<=4);\n      };\n      break;\n    }\n  }\n\n  H = vec.size(), W = vec[0].size();\n\n  rep(i,H)rep(j,W)used[i][j]=false;\n  error = false;\n  if( DEBUG ) {\n  cout << endl;\n  cout << \"is correct???\" << endl;\n  rep(i,H){\n    rep(j,W) cout << vec[i][j];\n    cout << endl;\n  } cout << endl;\n  }\n  dfs2(die,vec,sx,sy);\n  if( error ) return false;\n  rep(i,H)rep(j,W)if(vec[i][j]!='0'&&!used[i][j])return false;\n  return true;\n}\n\ninline void simulate(vector<string> vec){\n\n  rep(i,2){\n    rep(_,4){\n      if( correct(vec) ) {\n        cout << YES << endl;\n        return;\n      }\n      vec = rotate90(vec);\n    }\n    rep(j,vec.size()) reverse(vec[j].begin(),vec[j].end());\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> T;\n  while( T-- ){\n    vector<string> vec(5);\n    rep(i,5) vec[i] = \"\";\n    rep(i,5) rep(j,5) {\n      cin >> itmp;\n      vec[i] += string(1,(char)('0'+itmp));\n    }\n\n    //vec = trim(vec);\n\n    if( !check(vec) ) {\n      cout << NO << endl;\n      continue;\n    }\n\n    top = -1,dice_tmp = -1;\n    rep(i,vec.size())rep(j,vec[i].size())if(vec[i][j]!='0') {\n      top = vec[i][j] - '1';\n      rep(k,4){\n        int nx = j + dx[k], ny = i + dy[k];\n        if( isValid(vec,nx,ny) ) {\n          if( vec[ny][nx] != '0' ) {\n            dice_tmp = vec[ny][nx] - '1';\n            goto Skip2;\n          }\n        } \n      }\n    }\n  Skip2:;\n    assert( top != -1 && dice_tmp != -1 );\n\n    simulate(vec);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\nclass Cube{\n    public:\n    int f[6];\n    Cube(){}\n    void roll_y(){ roll(0, 2, 5, 3);}\n    void roll_x(){ roll(0, 1, 5, 4);}\n    void roll(int i, int j, int k, int l){\n\tint t = f[i]; f[i] = f[j]; f[j] = f[k]; f[k] = f[l]; f[l] = t;\n    }\n  \n  bool valid(){\n    bool v[6];\n    rep(i, 6) v[i] = false;\n    rep(i, 6) if ( 1 <= f[i]  && f[i] <= 6 ) v[f[i]-1] = true;\n    rep(i, 6) if ( !v[i] ) return false;\n    return f[0]+f[5]==7 && f[1]+f[4]==7 && f[2]+f[3]==7;\n  }\n};\n\nclass State{\n  public:\n  int pi, pj;\n  Cube cube;\n  State(){}\n  State(int pi, int pj):pi(pi),pj(pj){\n    rep(i, 6) cube.f[i] = -1;\n  }\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    rep(i, 6){\n      if ( cube.f[i] == s.cube.f[i] ) continue;\n      return cube.f[i] < s.cube.f[i];\n    }\n    return false;\n  }\n};\n\nint G[7][7];\nset<State> V;\n\nbool dfs(State u){\n  u.cube.f[5] = G[u.pi][u.pj];\n  if ( u.cube.valid() ) return true;\n  V.insert(u);\n\n  State v;\n  int di[4] = {1, -1, 0, 0};\n  int dj[4] = {0, 0, -1, 1};\n  int dp[4] = {1, 4, 3, 2};\n  rep(r, 4){\n    if ( u.cube.f[dp[r]] == -1 && G[u.pi+di[r]][u.pj+dj[r]] ||\n\t u.cube.f[dp[r]] == G[u.pi+di[r]][u.pj+dj[r]] ){\n      v = u;\n      v.pi += di[r]; v.pj += dj[r];\n      if ( dp[r] == 1 ) rep(i, 3) v.cube.roll_x();\n      if ( dp[r] == 4 ) v.cube.roll_x();\n      if ( dp[r] == 3 ) v.cube.roll_y();\n      if ( dp[r] == 2 ) rep(i, 3) v.cube.roll_y();\n      if ( V.find(v) == V.end() && dfs(v) ) return true;\n    }\n  }\n  return false;\n}\n\nbool valid(vector<int> d){\n  if ( d.size() != 6 ) return false;\n  sort(d.begin(), d.end());\n  rep(i, 6)\n    if ( i+1 != d[i] ) return false;\n  return true;\n}\n\nmain(){\n  int tcase; cin >> tcase;\n  rep(t, tcase){\n    rep(i, 7) rep(j, 7) G[i][j] = 0;\n    int si, sj;\n    vector<int> d;\n    for ( int i = 1; i <= 5; i++ ){\n      for ( int j = 1; j <= 5; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] ) { \n\t  si = i; sj = j; \n\t  d.push_back(G[i][j]);\n\t}\n      }\n    }\n    State s = State(si, sj);\n    V.clear();\n    if ( valid(d) && dfs(s) ) cout << \"true\" << endl;\n    else cout << \"false\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nvector<string> rotate90(const vector<string>& piece){\n  vector<string> ret;\n  int h = piece[0].size(), w = piece.size();\n  ret.resize(h);\n  for(int i=0;i<h;i++)ret[i].resize(w);\n  for(int y=0;y<ret.size();y++){\n    for(int x=0;x<ret[0].size();x++){\n      ret[y][x] = piece[ret[0].size()-1-x][y];\n    }\n  }\n  return ret;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nFACE dir[] = {FRONT,LEFT,BACK,RIGHT};\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\ndice<int> makeDice(int top,int front){\n  dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++){\n    if(around[top][i] == front){\n\t  idx = i+1;\n\t  break;\n    }\n  }\n  //assert(idx != IINF); 今回は破綻してても良い というか破綻してたらdfs2がすぐ打ちきられてfalseであることが分かる\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\nint T,itmp;\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\nbool used[5][5];\nint counter[6];\n\ninline bool isValid(const vector<string>& vec,int x,int y){ return ( 0 <= x && x < vec[0].size() && 0 <= y && y < vec.size() ); }\n\nvoid dfs(const vector<string> &vec,int x,int y){\n  if( used[y][x] ) return;\n  counter[vec[y][x]-'1']++;\n  used[y][x] = true;\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if( isValid(vec,nx,ny) ) {\n      if( !used[ny][nx] && vec[ny][nx] != '0' ) { \n        dfs(vec,nx,ny);\n      }\n    }\n  }\n}\n\n\n\nbool check(const vector<string> &vec){\n  rep(i,5)rep(j,5) used[i][j] = false;\n  rep(i,6) counter[i] = 0;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' ) {\n    dfs(vec,j,i);\n    goto Skip;\n  }\n Skip:;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' && !used[i][j] ) return false;\n  rep(i,6) if( counter[i] != 1 ) return false;\n  return true;\n}\n\nconst string YES = \"true\", NO = \"false\";\nint top,dice_tmp,H,W;\nbool error;\nconst bool DEBUG = false;\n\ninline void roller(dice<int> &die,int type){\n  if( type == 0 ) { // FRONT to TOP\n    rep(i,3) die.roll_x();\n  } else if( type == 1 ) { // LEFT to TOP\n    die.roll_y();\n  } else if( type == 2 ) { // BACK to TOP\n    die.roll_x();\n  } else { // RIGHT to TOP\n    rep(i,3) die.roll_y();\n  }\n}\n\nvoid dfs2(dice<int> &die,const vector<string>& vec,int x,int y){\n\n  if( error ) return;\n  if( used[y][x] ) return;\n  used[y][x] = true;\n\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx] == '0' ) continue;\n    if( die[dir[i]] != vec[ny][nx]-'1' ) {\n      error = true;\n      return;\n    }\n    roller(die,i);\n    dfs2(die,vec,nx,ny);\n    roller(die,(i+2)%4);\n  }\n}\n\nbool correct(const vector<string>& vec){\n  dice<int> die = makeDice(top,dice_tmp);\n  int sx = -1, sy = -1;\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j]-'1' == top ) {\n    sx = j, sy = i;\n    break;\n  }\n\n  rep(i,4) {\n    int nx = sx + dx[i], ny = sy + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx]-'1' == dice_tmp ) {\n      int debug = 0;\n      while( die[dir[i]] != dice_tmp ){\n        die.roll_z();\n        debug++;\n      }\n      break;\n    }\n  }\n\n  H = vec.size(), W = vec[0].size();\n\n  rep(i,H)rep(j,W)used[i][j]=false;\n  error = false;\n  dfs2(die,vec,sx,sy);\n  if( error ) return false;\n  rep(i,H)rep(j,W)if(vec[i][j]!='0'&&!used[i][j])return false;\n  return true;\n}\n\ninline void simulate(vector<string> vec){\n  rep(i,2){\n    rep(_,4){\n      if( correct(vec) ) {\n        cout << YES << endl;\n        return;\n      }\n      vec = rotate90(vec);\n    }\n    rep(j,vec.size()) reverse(vec[j].begin(),vec[j].end());\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> T;\n  while( T-- ){\n    vector<string> vec(5);\n    rep(i,5) vec[i] = \"\";\n    rep(i,5) rep(j,5) {\n      cin >> itmp;\n      vec[i] += string(1,(char)('0'+itmp));\n    }\n\n    if( !check(vec) ) {\n      cout << NO << endl;\n      continue;\n    }\n\n    top = -1,dice_tmp = -1;\n    rep(i,vec.size())rep(j,vec[i].size())if(vec[i][j]!='0') {\n      top = vec[i][j] - '1';\n      rep(k,4){\n        int nx = j + dx[k], ny = i + dy[k];\n        if( isValid(vec,nx,ny) ) {\n          if( vec[ny][nx] != '0' ) {\n            dice_tmp = vec[ny][nx] - '1';\n            goto Skip2;\n          }\n        } \n      }\n    }\n  Skip2:;\n    assert( top != -1 && dice_tmp != -1 );\n\n    simulate(vec);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define BOTTOM 0\n#define FRONT 1\n#define RIGHT 2\n#define TOP 3\n#define BACK 4\n#define LEFT 5\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\nint table[6][6];\nint inp[5][5];\nint color[5][5];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nbool visited[5][5];\n\nvoid setting();\nvoid dfs(int &cnt,int y,int x);\nbool is_connect();\n\nbool Construct(int now,int *used){\n#ifdef DEBUG\n  cout << \"NOW STATE\"<<endl;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if (j)cout<<\" \";\n      if (color[i][j] != -1)cout<< color[i][j];\n      else cout << \" \";\n    }\n    cout << endl;\n  }\n  cout << \"NOW STATE END \" << endl;\n#endif\n  if ( now == 6){\n    if ( used[TOP]+used[BOTTOM] == 7 && used[LEFT]+used[RIGHT]==7&&\n\t used[FRONT]+used[BACK]==7)return true;\n    else return false;\n  }\n  int y=-1,x=-1,mycolor;\n  for(int i=0;i<5&&y == -1;i++){\n    for(int j=0;j<5;j++){\n      if ( color[i][j] != -1 && visited[i][j]==false){x=j;y=i;mycolor=color[i][j];break;}\n    }\n  }\n\n  visited[y][x] = true;\n  for(int base=0;base<4;base++){\n    bool isvalid=true;\n    int restore[6][2]={0},point=0;//for return back the data;\n    int restore_used[6]={0};\n    for(int i=0;i<4;i++){\n      int nex=x+dx[i],ney=y+dy[i];\n      if ( nex<0||ney<0||nex>=5||ney>5||inp[ney][nex]==0)continue;\n      if ( color[ney][nex] == -1){\n\tif( used[table[mycolor][(base+i)%4]]!= 0){\n\t  isvalid=false;\n\t  break;\n\t}\n\trestore[point][0]=ney;\n\trestore[point][1]=nex;\n\tcolor[ney][nex]=table[mycolor][(base+i)%4];\n\tused[table[mycolor][(base+i)%4]]=inp[ney][nex];\n\trestore_used[table[mycolor][(base+i)%4]]=1;\n\tpoint++;\n      }else if ( color[ney][nex] != table[mycolor][(base+i)%4]){\n\tisvalid=false;\n\tbreak;\n      }\n    }\n    if ( isvalid == true && Construct(now+1,used))return true;\n    for(int i=0;i<point;i++){\n      int rx=restore[i][1],ry=restore[i][0];\n      color[ry][rx]=-1;\n    }\n    for(int i=0;i<6;i++){\n      if ( restore_used[i] == 1)used[i]=0;      \n    }\n    \n  }\n  visited[y][x]=false;\n  return false;\n}\nbool solve(){\n  int sx=-1,sy=-1;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      visited[i][j] = true;\n      if ( inp[i][j] != 0&&sx==-1){\n\tsx=j;\n\tsy=i;\n      }\n    }\n  }\n  \n  int used[6]={0};\n  fill(&color[0][0],&color[4][5],-1);\n  fill(&visited[0][0],&visited[4][5],false);\n  used[BOTTOM]=inp[sy][sx];\n  color[sy][sx]=BOTTOM;  \n  if ( Construct(1,used))return true;\n  else return false;\n}\n\n\nmain(){\n  setting();\n  int te;\n  cin>>te;\n  while(te--){\n    int isexist[7]={0},cnt=0;\n    fill(&visited[0][0],&visited[4][5],false);\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n\tcin>>inp[i][j];\n\tif ( inp[i][j] != 0 )cnt++,isexist[inp[i][j]]++;\n      }\n    }\n    if ( cnt != 6||isexist[1]!=1||isexist[2]!=1||isexist[3]!=1||isexist[4]!=1||\n\t isexist[5]!=1||isexist[6]!=1 || is_connect() ==false){\n      cout << \"false\"<<endl;\n      continue;\n    }\n#ifdef DEBUG\n    cout << \"connected and only distinct6values\"<<endl;\n#endif    \n    if ( solve() == true){\n      cout << \"true\"<<endl;\n    }else cout << \"false\"<<endl;\n  }\n  \n  return false;\n}\n\n\nvoid dfs(int &cnt,int y,int x){\n  visited[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int nex = x+dx[i],ney=y+dy[i];\n    if ( nex<0||ney<0||nex>=5||ney>=5||inp[ney][nex]==0||visited[ney][nex])continue;\n    dfs(cnt,ney,nex);\n  }\n}\n\nbool is_connect(){\n  int cnt = 0;\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      if ( inp[i][j] != 0){\n\tdfs(cnt,i,j);\n\tif (cnt == 6)return true;\n\telse return false;\n      }\n    }\n  }\n  return false;\n}\n\n\n\nvoid setting(){\n  table[BOTTOM][NORTH]=BACK;\n  table[BOTTOM][EAST]=RIGHT;\n  table[BOTTOM][SOUTH]=FRONT;\n  table[BOTTOM][WEST]=LEFT;\n  \n  table[TOP][NORTH]=BACK;\n  table[TOP][EAST]=LEFT;\n  table[TOP][SOUTH]=FRONT;\n  table[TOP][WEST]=RIGHT;\n\n  table[FRONT][NORTH]=BOTTOM;\n  table[FRONT][EAST]=RIGHT;\n  table[FRONT][SOUTH]=TOP;\n  table[FRONT][WEST]=LEFT;\n\n  table[BACK][NORTH]=TOP;\n  table[BACK][EAST]=RIGHT;\n  table[BACK][SOUTH]=BOTTOM;\n  table[BACK][WEST]=LEFT;\n\n  table[RIGHT][NORTH]=BACK;\n  table[RIGHT][EAST]=TOP;\n  table[RIGHT][SOUTH]=FRONT;\n  table[RIGHT][WEST]=BOTTOM;\n\n  table[LEFT][NORTH]=BACK;\n  table[LEFT][EAST]=BOTTOM;\n  table[LEFT][SOUTH]=FRONT;\n  table[LEFT][WEST]=TOP;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct Dice{\n  int s[6];\n  void roll(char c){\n    int b;\n    if(c == 'E') {\n      b = s[0];\n      s[0] = s[3];\n      s[3] = s[5];\n      s[5] = s[2];\n      s[2] = b;\n    }\n    if(c == 'W'){\n      b = s[0];\n      s[0] = s[2];\n      s[2] = s[5];\n      s[5] = s[3];\n      s[3] = b;\n    }\n\n    if(c == 'N'){\n      b = s[0];\n      s[0] = s[1];\n      s[1] = s[5];\n      s[5] = s[4];\n      s[4] = b;\n    }\n    if(c == 'S'){\n      b = s[0];\n      s[0] = s[4];\n      s[4] = s[5];\n      s[5] = s[1];\n      s[1] = b;\n    }\n  }\n  int top() {return s[0];}\n\n};\n\n#define N 5\nchar dir[] = {'N','E','S','W'};\nint dy[]={-1,0,1,0}; // N,E,S,W\nint dx[]={0,1,0,-1};\n\nint mp[N][N];\nint used[N][N];\nDice dice;\n\nint ans = 1;\n\nbool check(){\n  int cnt[7]={};\n  for(int i=0;i<6;i++) cnt[dice.s[i]]++;\n  for(int i=1;i<=6;i++) if(cnt[i] !=1) return 0;\n\n  int res = 1;\n  res &= dice.s[0]+dice.s[5] == 7;\n  res &= dice.s[1]+dice.s[4] == 7;\n  res &= dice.s[2]+dice.s[3] == 7;\n  return res;\n}\n\n\nvoid dfs(int y,int x,int py,int px){\n  \n  if(used[y][x]++ || dice.s[5] != 0) ans = 0;\n  if(ans == 0) return;\n  dice.s[5] = mp[y][x];\n  \n  for(int i=0;i<4;i++){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(nx<0||ny<0 ||nx>=N ||ny>=N || mp[ny][nx] == 0)continue;\n    if(nx == px && ny == py) continue;\n    dice.roll(dir[i]);\n    dfs(ny,nx,y,x);\n    dice.roll(dir[(i+2)%4]);\n  }\n}\n\n\nsigned main(){\n\n  int q;\n  cin>>q;\n  while(q--){\n\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) cin>>mp[i][j];\n\n    ans = 1;\n    memset(used,0,sizeof(used));\n    for(int i=0;i<6;i++) dice.s[i] = 0;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tif(mp[i][j] > 0) dfs(i,j,-1,-1),i = N,j = N;\n\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++) if(mp[i][j]!=0 && used[i][j] == 0) ans = 0;\n\t  \n\n    ans &= check();\n    cout<<(ans? \"true\":\"false\")<<endl;\n    \n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\nclass dice {\nprivate:\n\tint num[6];\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tint tmp = num[a];\n\t\tnum[a] = num[b];\n\t\tnum[b] = num[c];\n\t\tnum[c] = num[d];\n\t\tnum[d] = tmp;\n\t}\n\npublic:\n\tdice() {\n\t\tmemset(num, 0, sizeof(num));\n\t}\n\n\tbool check() {\n\t\tvector<bool> used(7, false);\n\t\tfor(int i = 0; i < 6; ++i) {\n\t\t\tif(num[i] == 0 || used[num[i]])\n\t\t\t\treturn false;\n\t\t\tused[num[i]] = true;\n\t\t}\n\n\t\treturn num[TOP] + num[BOTTOM] == 7 && num[FRONT] + num[BACK] == 7 && num[LEFT] + num[RIGHT] == 7;\n\t}\n\n\tint& operator[](FACE f) { return num[f]; }\n\tvoid north() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid south() { roll(TOP, FRONT, BOTTOM, BACK); }\n\tvoid east() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid west() { roll(TOP, RIGHT, BOTTOM, LEFT); }\n};\n\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\ndice die;\nint f[5][5];\nbool visited[5][5];\n\nvoid search(int x, int y) {\n\tdie[TOP] = f[y][x];\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= 5 || ny >= 5)\n\t\t\tcontinue;\n\n\t\tif(visited[ny][nx] || !f[ny][nx])\n\t\t\tcontinue;\n\n\t\tswitch(i) {\n\t\tcase 0: die.east(); break;\n\t\tcase 1: die.west(); break;\n\t\tcase 2: die.south(); break;\n\t\tcase 3: die.north(); break;\n\t\t}\n\n\t\tsearch(nx, ny);\n\n\t\tswitch(i) {\n\t\tcase 0: die.west(); break;\n\t\tcase 1: die.east(); break;\n\t\tcase 2: die.north(); break;\n\t\tcase 3: die.south(); break;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tcin >> f[i][j];\n\n\t\tbool ok = false, first = true;\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tif(f[i][j])\n\t\t\t\t\t++cnt;\n\n\t\tif(cnt != 6)\n\t\t\tgoto finish;\n\n\t\tdie = dice();\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < 5; ++i) {\n\t\t\tfor(int j = 0; j < 5; ++j) {\n\t\t\t\tif(f[i][j] && !visited[i][j]) {\n\t\t\t\t\tif(!first)\n\t\t\t\t\t\tgoto finish;\n\n\t\t\t\t\tfirst = true;\n\t\t\t\t\tsearch(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tok = die.check();\n\n\tfinish:;\n\t\tcout << (ok ? \"true\" : \"false\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\n\nvector<string> trim(const vector<string>& vec) {\n  int n,e,s,w;\n  w = IINF, e = -IINF, n = IINF, s = -IINF;\n\n  for(int y=0;y<vec.size();y++){\n    for(int x=0;x<vec[y].size();x++){\n      if(vec[y][x] == '0')continue;\n      w = min(w,x);\n      e = max(e,x);\n      n = min(n,y);\n      s = max(s,y);\n    }\n  }\n  vector<string> ret;\n  for(int y=n;y<=s;y++) ret.push_back(vec[y].substr(w,e-w+1));\n  return ret;\n}\n\nvector<string> rotate90(const vector<string>& piece){\n  vector<string> ret;\n  int h = piece[0].size(), w = piece.size();\n  ret.resize(h);\n  for(int i=0;i<h;i++)ret[i].resize(w);\n  for(int y=0;y<ret.size();y++){\n    for(int x=0;x<ret[0].size();x++){\n      ret[y][x] = piece[ret[0].size()-1-x][y];\n    }\n  }\n  return ret;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nFACE dir[] = {FRONT,LEFT,BACK,RIGHT};\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\ndice<int> makeDice(int top,int front)\n{\n  dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++)\n    {\n      if(around[top][i] == front)\n\t{\n\t  idx = i+1;\n\t  break;\n\t}\n    }\n  //assert(idx != IINF);\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\n//\n\nint T,itmp;\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\nbool used[5][5];\nint counter[6];\n\ninline bool isValid(const vector<string>& vec,int x,int y){\n  return ( 0 <= x && x < vec[0].size() && 0 <= y && y < vec.size() );\n}\n\nvoid dfs(const vector<string> &vec,int x,int y){\n  if( used[y][x] ) return;\n  counter[vec[y][x]-'1']++;\n  used[y][x] = true;\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if( isValid(vec,nx,ny) ) {\n      if( !used[ny][nx] && vec[ny][nx] != '0' ) { \n        dfs(vec,nx,ny);\n      }\n    }\n  }\n}\n\n\n\nbool check(const vector<string> &vec){\n  rep(i,5)rep(j,5) used[i][j] = false;\n  rep(i,6) counter[i] = 0;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' ) {\n    dfs(vec,j,i);\n    goto Skip;\n  }\n Skip:;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' && !used[i][j] ) return false;\n  rep(i,6) if( counter[i] != 1 ) return false;\n  return true;\n}\n\nconst string YES = \"true\", NO = \"false\";\nint top,dice_tmp,H,W;\nbool error;\nconst bool DEBUG = false;\n\ninline void roller(dice<int> &die,int type){\n  if( type == 0 ) { // FRONT to TOP\n    rep(i,3) die.roll_x();\n  } else if( type == 1 ) { // LEFT to TOP\n    die.roll_y();\n  } else if( type == 2 ) { // BACK to TOP\n    die.roll_x();\n  } else { // RIGHT to TOP\n    rep(i,3) die.roll_y();\n  }\n}\n\nvoid dfs2(dice<int> &die,const vector<string>& vec,int x,int y){\n\n  if( error ) return;\n  if( used[y][x] ) return;\n  used[y][x] = true;\n  if( DEBUG )cout << \"(\" << x << \",\" << y << \") = \" << vec[y][x] << \" top = \" << die[TOP]+1  << \" rig = \" << die[RIGHT]+1<< endl;\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx] == '0' ) continue;\n    if( die[dir[i]] != vec[ny][nx]-'1' ) {\n      error = true;\n      return;\n    }\n\n    roller(die,i);\n    dfs2(die,vec,nx,ny);\n    roller(die,(i+2)%4);\n\n  }\n}\n\nbool correct(const vector<string>& vec){\n  dice<int> die = makeDice(top,dice_tmp);\n  int sx = -1, sy = -1;\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j]-'1' == top ) {\n    sx = j, sy = i;\n    break;\n  }\n  //assert( sx != -1 && sy != -1 );\n  if(DEBUG)cout << \"TOP = \" << top << endl;\n  if(DEBUG)rep(i,6) { cout << die[face[i]] << endl; }\n\n  rep(i,4) {\n    int nx = sx + dx[i], ny = sy + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx]-'1' == dice_tmp ) {\n      int debug = 0;\n      while( die[dir[i]] != dice_tmp ){\n        die.roll_z();\n        debug++;\n        //assert(debug<=4);\n      };\n      break;\n    }\n  }\n\n  H = vec.size(), W = vec[0].size();\n\n  rep(i,H)rep(j,W)used[i][j]=false;\n  error = false;\n  if( DEBUG ) {\n  cout << endl;\n  cout << \"is correct???\" << endl;\n  rep(i,H){\n    rep(j,W) cout << vec[i][j];\n    cout << endl;\n  } cout << endl;\n  }\n  dfs2(die,vec,sx,sy);\n  if( error ) return false;\n  rep(i,H)rep(j,W)if(vec[i][j]!='0'&&!used[i][j])return false;\n  return true;\n}\n\ninline void simulate(vector<string> vec){\n\n  rep(i,2){\n    rep(_,4){\n      if( correct(vec) ) {\n        cout << YES << endl;\n        return;\n      }\n      vec = rotate90(vec);\n    }\n    rep(j,vec.size()) reverse(vec[j].begin(),vec[j].end());\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> T;\n  while( T-- ){\n    vector<string> vec(5);\n    rep(i,5) vec[i] = \"\";\n    rep(i,5) rep(j,5) {\n      cin >> itmp;\n      vec[i] += string(1,(char)('0'+itmp));\n    }\n\n    //vec = trim(vec);\n\n    if( !check(vec) ) {\n      cout << NO << endl;\n      continue;\n    }\n\n    top = -1,dice_tmp = -1;\n    rep(i,vec.size())rep(j,vec[i].size())if(vec[i][j]!='0') {\n      top = vec[i][j] - '1';\n      rep(k,4){\n        int nx = j + dx[k], ny = i + dy[k];\n        if( isValid(vec,nx,ny) ) {\n          if( vec[ny][nx] != '0' ) {\n            dice_tmp = vec[ny][nx] - '1';\n            goto Skip2;\n          }\n        } \n      }\n    }\n  Skip2:;\n    assert( top != -1 && dice_tmp != -1 );\n\n    simulate(vec);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\n\nvector<string> trim(const vector<string>& vec) {\n  int n,e,s,w;\n  w = IINF, e = -IINF, n = IINF, s = -IINF;\n\n  for(int y=0;y<vec.size();y++){\n    for(int x=0;x<vec[y].size();x++){\n      if(vec[y][x] == '0')continue;\n      w = min(w,x);\n      e = max(e,x);\n      n = min(n,y);\n      s = max(s,y);\n    }\n  }\n  vector<string> ret;\n  for(int y=n;y<=s;y++) ret.push_back(vec[y].substr(w,e-w+1));\n  return ret;\n}\n\nvector<string> rotate90(const vector<string>& piece){\n  vector<string> ret;\n  int h = piece[0].size(), w = piece.size();\n  ret.resize(h);\n  for(int i=0;i<h;i++)ret[i].resize(w);\n  for(int y=0;y<ret.size();y++){\n    for(int x=0;x<ret[0].size();x++){\n      ret[y][x] = piece[ret[0].size()-1-x][y];\n    }\n  }\n  return ret;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nFACE dir[] = {FRONT,LEFT,BACK,RIGHT};\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\ndice<int> makeDice(int top,int front)\n{\n  dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++)\n    {\n      if(around[top][i] == front)\n\t{\n\t  idx = i+1;\n\t  break;\n\t}\n    }\n  assert(idx != IINF);\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\n//\n\nint T,itmp;\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\nbool used[5][5];\nint counter[6];\n\ninline bool isValid(const vector<string>& vec,int x,int y){\n  return ( 0 <= x && x < vec[0].size() && 0 <= y && y < vec.size() );\n}\n\nvoid dfs(const vector<string> &vec,int x,int y){\n  if( used[y][x] ) return;\n  counter[vec[y][x]-'1']++;\n  used[y][x] = true;\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if( isValid(vec,nx,ny) ) {\n      if( !used[ny][nx] && vec[ny][nx] != '0' ) { \n        dfs(vec,nx,ny);\n      }\n    }\n  }\n}\n\n\n\nbool check(const vector<string> &vec){\n  rep(i,5)rep(j,5) used[i][j] = false;\n  rep(i,6) counter[i] = 0;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' ) {\n    dfs(vec,j,i);\n    goto Skip;\n  }\n Skip:;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' && !used[i][j] ) return false;\n  rep(i,6) if( counter[i] != 1 ) return false;\n  return true;\n}\n\nconst string YES = \"true\", NO = \"false\";\nint top,dice_tmp,H,W;\nbool error;\nconst bool DEBUG = false;\n\ninline void roller(dice<int> &die,int type){\n  if( type == 0 ) { // FRONT to TOP\n    rep(i,3) die.roll_x();\n  } else if( type == 1 ) { // LEFT to TOP\n    die.roll_y();\n  } else if( type == 2 ) { // BACK to TOP\n    die.roll_x();\n  } else { // RIGHT to TOP\n    rep(i,3) die.roll_y();\n  }\n}\n\nvoid dfs2(dice<int> &die,const vector<string>& vec,int x,int y){\n\n  if( error ) return;\n  if( used[y][x] ) return;\n  used[y][x] = true;\n  if( DEBUG )cout << \"(\" << x << \",\" << y << \") = \" << vec[y][x] << \" top = \" << die[TOP]+1  << \" rig = \" << die[RIGHT]+1<< endl;\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx] == '0' ) continue;\n    if( die[dir[i]] != vec[ny][nx]-'1' ) {\n      error = true;\n      return;\n    }\n\n    roller(die,i);\n    dfs2(die,vec,nx,ny);\n    roller(die,(i+2)%4);\n\n  }\n}\n\nbool correct(const vector<string>& vec){\n  dice<int> die = makeDice(top,dice_tmp);\n  int sx = -1, sy = -1;\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j]-'1' == top ) {\n    sx = j, sy = i;\n    break;\n  }\n  assert( sx != -1 && sy != -1 );\n  if(DEBUG)cout << \"TOP = \" << top << endl;\n  if(DEBUG)rep(i,6) { cout << die[face[i]] << endl; }\n\n  rep(i,4) {\n    int nx = sx + dx[i], ny = sy + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx]-'1' == dice_tmp ) {\n      int debug = 0;\n      while( die[dir[i]] != dice_tmp ){\n        die.roll_z();\n        debug++;\n        assert(debug<=4);\n      };\n      break;\n    }\n  }\n\n  H = vec.size(), W = vec[0].size();\n\n  rep(i,H)rep(j,W)used[i][j]=false;\n  error = false;\n  if( DEBUG ) {\n  cout << endl;\n  cout << \"is correct???\" << endl;\n  rep(i,H){\n    rep(j,W) cout << vec[i][j];\n    cout << endl;\n  } cout << endl;\n  }\n  dfs2(die,vec,sx,sy);\n  if( error ) return false;\n  rep(i,H)rep(j,W)if(vec[i][j]!='0'&&!used[i][j])return false;\n  return true;\n}\n\ninline void simulate(vector<string> vec){\n\n  rep(i,2){\n    rep(_,4){\n      if( correct(vec) ) {\n        cout << YES << endl;\n        return;\n      }\n      vec = rotate90(vec);\n    }\n    rep(j,vec.size()) reverse(vec[j].begin(),vec[j].end());\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> T;\n  while( T-- ){\n    vector<string> vec(5);\n    rep(i,5) vec[i] = \"\";\n    rep(i,5) rep(j,5) {\n      cin >> itmp;\n      vec[i] += string(1,(char)('0'+itmp));\n    }\n\n    vec = trim(vec);\n\n    if( !check(vec) ) {\n      cout << NO << endl;\n      continue;\n    }\n\n    top = -1,dice_tmp = -1;\n    rep(i,vec.size())rep(j,vec[i].size())if(vec[i][j]!='0') {\n      top = vec[i][j] - '1';\n      rep(k,4){\n        int nx = j + dx[k], ny = i + dy[k];\n        if( isValid(vec,nx,ny) ) {\n          if( vec[ny][nx] != '0' ) {\n            dice_tmp = vec[ny][nx] - '1';\n            goto Skip2;\n          }\n        } \n      }\n    }\n  Skip2:;\n    assert( top != -1 && dice_tmp != -1 );\n\n    simulate(vec);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\nclass dice {\nprivate:\n\tint num[6];\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tint tmp = num[a];\n\t\tnum[a] = num[b];\n\t\tnum[b] = num[c];\n\t\tnum[c] = num[d];\n\t\tnum[d] = tmp;\n\t}\n\npublic:\n\tdice() {\n\t\tmemset(num, 0, sizeof(num));\n\t}\n\n\tbool check() {\n\t\tvector<bool> used(7, false);\n\t\tfor(int i = 0; i < 6; ++i) {\n\t\t\tif(num[i] == 0 || used[num[i]])\n\t\t\t\treturn false;\n\t\t\tused[num[i]] = true;\n\t\t}\n\n\t\treturn num[TOP] + num[BOTTOM] == 7 && num[FRONT] + num[BACK] == 7 && num[LEFT] + num[RIGHT] == 7;\n\t}\n\n\tint& operator[](FACE f) { return num[f]; }\n\tvoid north() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid south() { roll(TOP, FRONT, BOTTOM, BACK); }\n\tvoid east() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid west() { roll(TOP, RIGHT, BOTTOM, LEFT); }\n};\n\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\ndice die;\nint f[5][5];\nbool visited[5][5];\n\nvoid search(int x, int y) {\n\tdie[TOP] = f[y][x];\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= 5 || ny >= 5)\n\t\t\tcontinue;\n\n\t\tif(visited[ny][nx] || !f[ny][nx])\n\t\t\tcontinue;\n\n\t\tswitch(i) {\n\t\tcase 0: die.east(); break;\n\t\tcase 1: die.west(); break;\n\t\tcase 2: die.south(); break;\n\t\tcase 3: die.north(); break;\n\t\t}\n\n\t\tsearch(nx, ny);\n\n\t\tswitch(i) {\n\t\tcase 0: die.west(); break;\n\t\tcase 1: die.east(); break;\n\t\tcase 2: die.north(); break;\n\t\tcase 3: die.south(); break;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tcin >> f[i][j];\n\n\t\tbool ok = false;\n\t\tint cnt = 0;\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tif(f[i][j])\n\t\t\t\t\t++cnt;\n\n\t\tif(cnt != 6)\n\t\t\tgoto finish;\n\n\t\tdie = dice();\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < 5; ++i) {\n\t\t\tfor(int j = 0; j < 5; ++j) {\n\t\t\t\tif(f[i][j]) {\n\t\t\t\t\tsearch(j, i);\n\t\t\t\t\tgoto loop_escape;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tloop_escape:;\n\n\t\tok = die.check();\n\n\tfinish:;\n\t\tcout << (ok ? \"true\" : \"false\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\n\nvector<string> trim(const vector<string>& vec) {\n  int n,e,s,w;\n  w = IINF, e = -IINF, n = IINF, s = -IINF;\n\n  for(int y=0;y<vec.size();y++){\n    for(int x=0;x<vec[y].size();x++){\n      if(vec[y][x] == '0')continue;\n      w = min(w,x);\n      e = max(e,x);\n      n = min(n,y);\n      s = max(s,y);\n    }\n  }\n  vector<string> ret;\n  for(int y=n;y<=s;y++) ret.push_back(vec[y].substr(w,e-w+1));\n  return ret;\n}\n\nvector<string> rotate90(const vector<string>& piece){\n  vector<string> ret;\n  int h = piece[0].size(), w = piece.size();\n  ret.resize(h);\n  for(int i=0;i<h;i++)ret[i].resize(w);\n  for(int y=0;y<ret.size();y++){\n    for(int x=0;x<ret[0].size();x++){\n      ret[y][x] = piece[ret[0].size()-1-x][y];\n    }\n  }\n  return ret;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nFACE dir[] = {FRONT,LEFT,BACK,RIGHT};\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\ndice<int> makeDice(int top,int front)\n{\n  dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++)\n    {\n      if(around[top][i] == front)\n\t{\n\t  idx = i+1;\n\t  break;\n\t}\n    }\n  //assert(idx != IINF);\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\n//\n\nint T,itmp;\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\nbool used[5][5];\nint counter[6];\n\ninline bool isValid(const vector<string>& vec,int x,int y){\n  return ( 0 <= x && x < vec[0].size() && 0 <= y && y < vec.size() );\n}\n\nvoid dfs(const vector<string> &vec,int x,int y){\n  if( used[y][x] ) return;\n  counter[vec[y][x]-'1']++;\n  used[y][x] = true;\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if( isValid(vec,nx,ny) ) {\n      if( !used[ny][nx] && vec[ny][nx] != '0' ) { \n        dfs(vec,nx,ny);\n      }\n    }\n  }\n}\n\n\n\nbool check(const vector<string> &vec){\n  rep(i,5)rep(j,5) used[i][j] = false;\n  rep(i,6) counter[i] = 0;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' ) {\n    dfs(vec,j,i);\n    goto Skip;\n  }\n Skip:;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' && !used[i][j] ) return false;\n  rep(i,6) if( counter[i] != 1 ) return false;\n  return true;\n}\n\nconst string YES = \"true\", NO = \"false\";\nint top,dice_tmp,H,W;\nbool error;\nconst bool DEBUG = false;\n\ninline void roller(dice<int> &die,int type){\n  if( type == 0 ) { // FRONT to TOP\n    rep(i,3) die.roll_x();\n  } else if( type == 1 ) { // LEFT to TOP\n    die.roll_y();\n  } else if( type == 2 ) { // BACK to TOP\n    die.roll_x();\n  } else { // RIGHT to TOP\n    rep(i,3) die.roll_y();\n  }\n}\n\nvoid dfs2(dice<int> &die,const vector<string>& vec,int x,int y){\n\n  if( error ) return;\n  if( used[y][x] ) return;\n  used[y][x] = true;\n  if( DEBUG )cout << \"(\" << x << \",\" << y << \") = \" << vec[y][x] << \" top = \" << die[TOP]+1  << \" rig = \" << die[RIGHT]+1<< endl;\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx] == '0' ) continue;\n    if( die[dir[i]] != vec[ny][nx]-'1' ) {\n      error = true;\n      return;\n    }\n\n    roller(die,i);\n    dfs2(die,vec,nx,ny);\n    roller(die,(i+2)%4);\n\n  }\n}\n\nbool correct(const vector<string>& vec){\n  dice<int> die = makeDice(top,dice_tmp);\n  int sx = -1, sy = -1;\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j]-'1' == top ) {\n    sx = j, sy = i;\n    break;\n  }\n  //assert( sx != -1 && sy != -1 );\n  if(DEBUG)cout << \"TOP = \" << top << endl;\n  if(DEBUG)rep(i,6) { cout << die[face[i]] << endl; }\n\n  rep(i,4) {\n    int nx = sx + dx[i], ny = sy + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx]-'1' == dice_tmp ) {\n      int debug = 0;\n      while( die[dir[i]] != dice_tmp ){\n        die.roll_z();\n        debug++;\n        //assert(debug<=4);\n      };\n      break;\n    }\n  }\n\n  H = vec.size(), W = vec[0].size();\n\n  rep(i,H)rep(j,W)used[i][j]=false;\n  error = false;\n  if( DEBUG ) {\n  cout << endl;\n  cout << \"is correct???\" << endl;\n  rep(i,H){\n    rep(j,W) cout << vec[i][j];\n    cout << endl;\n  } cout << endl;\n  }\n  dfs2(die,vec,sx,sy);\n  if( error ) return false;\n  rep(i,H)rep(j,W)if(vec[i][j]!='0'&&!used[i][j])return false;\n  return true;\n}\n\ninline void simulate(vector<string> vec){\n\n  rep(i,2){\n    rep(_,4){\n      if( correct(vec) ) {\n        cout << YES << endl;\n        return;\n      }\n      vec = rotate90(vec);\n    }\n    rep(j,vec.size()) reverse(vec[j].begin(),vec[j].end());\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> T;\n  while( T-- ){\n    vector<string> vec(5);\n    rep(i,5) vec[i] = \"\";\n    rep(i,5) rep(j,5) {\n      cin >> itmp;\n      vec[i] += string(1,(char)('0'+itmp));\n    }\n\n    vec = trim(vec);\n\n    if( !check(vec) ) {\n      cout << NO << endl;\n      continue;\n    }\n\n    top = -1,dice_tmp = -1;\n    rep(i,vec.size())rep(j,vec[i].size())if(vec[i][j]!='0') {\n      top = vec[i][j] - '1';\n      rep(k,4){\n        int nx = j + dx[k], ny = i + dy[k];\n        if( isValid(vec,nx,ny) ) {\n          if( vec[ny][nx] != '0' ) {\n            dice_tmp = vec[ny][nx] - '1';\n            goto Skip2;\n          }\n        } \n      }\n    }\n  Skip2:;\n    assert( top != -1 && dice_tmp != -1 );\n\n    simulate(vec);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[7][7];\nint v[10];\nint pat[11][3][5]={\n{{2,3,0,0,0},\n{0,1,2,0,0},\n{0,0,3,1,0}},\n{{2,3,2,0,0},\n{0,0,1,3,1},\n{0,0,0,0,0}},\n{{3,1,0,0,0},\n{0,2,3,2,0},\n{0,1,0,0,0}},\n{{3,1,0,0,0},\n{0,2,3,2,0},\n{0,0,1,0,0}},\n{{3,2,0,0,0},\n{0,1,3,1,0},\n{0,0,0,2,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{3,0,0,0,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{0,3,0,0,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{0,0,3,0,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{0,0,0,3,0}},\n{{0,3,0,0,0},\n{1,2,1,2,0},\n{0,3,0,0,0}},\n{{0,3,0,0,0},\n{1,2,1,2,0},\n{0,0,3,0,0}}\n};\nint to[10][10];\nint tmp[10];\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)scanf(\"%d\",&c[i][j]);\n\t\tbool dame=false;\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\t\tif(c[i][j]){\n\t\t\t\tv[c[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=6;i++)if(v[i]!=1)dame=true;\n\t\tif(dame){\n\t\t\tprintf(\"false\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int s=0;s<2;s++){\n\t\tfor(int r=0;r<4;r++){\n\t\tfor(int i=0;i<11;i++){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int p=0;p<2;p++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<10;k++)tmp[k]=0;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tif(pat[i][k][l]){\n\t\t\t\t\t\t\tif(!c[j+k][p+l])OK=false;\n\t\t\t\t\t\t\ttmp[pat[i][k][l]]+=c[j+k][p+l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1;k<=3;k++)if(tmp[k]!=7)OK=false;\n\t\t\t\tif(OK)ok=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)to[j][4-i]=c[i][j];\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)c[i][j]=to[i][j];\n\t\t}\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)to[i][4-j]=c[i][j];\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)c[i][j]=to[i][j];\n\t\t}\n\t\tif(ok)printf(\"true\\n\");\n\t\telse printf(\"false\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint a[7][7],c[7][7];\nint fn(int x,int y){\n  int ct=0;\n  if(a[y][x]>0&&c[y][x]){\n    c[y][x]=0;\n    ct=1;\n    ct+=fn(x-1,y);\n    ct+=fn(x+1,y);\n    ct+=fn(x,y-1);\n    ct+=fn(x,y+1);\n  }\n  return ct;\n}\nint main(){\n  int i,j,k,l,m;\n  int n;\n  cin>>n;\n  for(i=0;i<n;++i){\n    int b[6]={};\n    memset(a,-1,sizeof(a));\n    for(j=1;j<=5;++j){\n      for(k=1;k<=5;++k){\n\tcin>>a[j][k];\n\tif(a[j][k])\n\t  b[a[j][k]-1]++;\n      }\n    }\n    for(j=0;j<6;++j){\n      if(b[j]!=1)\n\tbreak;\n    }\n    if(j<6){\n      cout<<\"false\"<<endl;\n    }else{\n      memset(c,-1,sizeof(c));\n      for(j=1;j<=5;++j){\n\tfor(k=1;k<=5;++k){\n\t  if(a[j][k])\n\t    break;\n\t}\n\tif(k<=5)\n\t  break;\n      }\n      if(fn(k,j)<6){\n\tcout<<\"false\"<<endl;\n      }else{\n\tmemset(c,-1,sizeof(c));\n\tfor(j=1;j<=5;++j){\n\t  for(k=1;k<=5;++k){\n\t    if(a[j][k]&&c[j][k]){\n\t      int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\t      for(l=0;l<4;++l){\n\t\tfor(m=0;;++m){\n\t\t  if(a[j+dy[l]+dx[l]*m][k+dx[l]+dy[l]*m]>0){\n\t\t    if(a[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]>0&&c[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]&&a[j][k]+a[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]==7){\n\t\t      c[j][k]=c[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]=0;\n\t\t      break;\n\t\t    }\n\t\t  }else{\n\t\t    break;\n\t\t  }\n\t\t}\n\t\tif(c[j][k]==0)\n\t\t  break;\n\t\tfor(m=0;;++m){\n\t\t  if(a[j+dy[l]-dx[l]*m][k+dx[l]-dy[l]*m]>0){\n\t\t    if(a[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]>0&&c[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]&&a[j][k]+a[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]==7){\n\t\t      c[j][k]=c[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]=0;\n\t\t      break;\n\t\t    }\n\t\t  }else{\n\t\t    break;\n\t\t  }\n\t\t}\n\t\tif(c[j][k]==0)\n\t\t  break;\n\t      }\n\t      if(l==4)\n\t\tbreak;\n\t    }\n\t  }\n\t  if(k<=5)\n\t    break;\n\t}\n\tif(j>5)\n\t  cout<<\"true\"<<endl;\n\telse\n\t  cout<<\"false\"<<endl;\n      }      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <queue>\nusing namespace std;\n\n\n// If this structure is used for two-dimensional surface,\n// it assumes that the face id[0] faces the positive direction of the Y axis,\n// the face id[1] faces the positive direction of the X axis\n// and id[2] is top of the dice.\nstruct Dice {\n  int id[6], cnt, x, y;\n  const static int f[3][3];\n\n  Dice() { init(); }\n\n  void init() {\n    for(int i = 0; i < 6; ++i) {\n      id[i] = i;\n    }\n    cnt = 0;\n  }\n\n  // type (0:spin, 1:rollX, 2:rollY)\n  // dir 1( ccw     neg      pos   )\n  //    -1( cw      pos      neg   )\n  void rotate(int type, int dir = 1) {\n    const int *v = f[type];\n    int a,b,c,t; a=v[0]; b=v[1]; c=v[2]; t=id[type];\n    if(dir < 0) swap(a,c);\n    id[type]=id[a]; id[a]=id[b]; id[b]=id[c]; id[c]=t;\n  }\n\n  bool next() {\n    ++cnt;\n    if(cnt == 24) {\n      rotate(0,-1);\n      rotate(1,-1);\n      cnt = 0;\n      return false;\n    }\n    if(cnt == 4*3) {\n      rotate(2,-1);\n      rotate(0,-1);\n    } else if(cnt%4 == 0) {\n      rotate(2);\n    } else {\n      rotate(0);\n    }\n    return true;\n  }\n\n  void roll(int dir) {\n    //const static int dx[] = {1,0,-1,0};\n    //const static int dy[] = {0,1,0,-1};\n    switch(dir) {\n      case 0: rotate(1,-1); break;\n      case 1: rotate(2, 1); break;\n      case 2: rotate(1, 1); break;\n      case 3: rotate(2,-1); break;\n    }\n  }\n\n  bool operator < (const Dice &d) const {\n    for(int i = 0; i < 3; ++i)\n      if(id[i] != d.id[i]) return id[i] < d.id[i];\n    return false;\n  }\n\n  void show() {\n    cout << id[4] << \" / \\\\ \" << id[5] << endl;\n    cout << \" /   \\\\\" << endl;\n    cout << \"|\\\\ \" << id[2] << \" /|\" << endl;\n    cout << \"|\" << id[0] << \"\\\\ /\" << id[1] << \"|\" << endl;\n    cout << \" \\\\ | /\" << endl;\n    cout << \"  \\\\|/\" << endl;\n    cout << \"   \" << id[3] << endl;\n  }\n};\nconst int Dice::f[3][3] = {{4,5,1},{3,4,2},{5,3,0}};\n\n\n\nconst int H = 5;\nconst int W = 5;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nchar G[H][W];\n\nbool check_g() {\n  int sum = 0;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] != '0') ++sum;\n    }\n  }\n  return sum == 6;\n}\n\nbool check_b() {\n  set<char> s;\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] != '0') s.insert(G[i][j]);\n    }\n  }\n  return s.size() == 6;\n}\n\nbool check_ef() {\n  bool vis[H][W];\n  int cnt = 0;\n  fill(vis[0], vis[H], false);\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] != '0' && !vis[i][j]) {\n        if(++cnt != 1) return false;\n        queue<pair<int,int> > que;\n        que.push(make_pair(i,j));\n        vis[i][j] = true;\n\n\n        while(!que.empty()) {\n          int ni = que.front().first;\n          int nj = que.front().second;\n          que.pop();\n          for(int k = 0; k < 4; ++k) {\n            int nni = ni + di[k];\n            int nnj = nj + dj[k];\n            if(nni < 0 || nni >= H) continue;\n            if(nnj < 0 || nnj >= W) continue;\n            if(G[nni][nnj] == '0') continue;\n            if(vis[nni][nnj]) continue;\n            vis[nni][nnj] = true;\n            que.push(make_pair(nni,nnj));\n          }\n        }\n\n\n      }\n    }\n  }\n  return true;\n}\n\nbool check_acd() {\n  for(int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      if(G[i][j] != '0') {\n        queue<Dice> que;\n        bool vis[H][W];\n        Dice d;\n        int num[6];\n        fill(num, num+6, -1);\n        d.y = i;\n        d.x = j;\n        fill(vis[0], vis[H], false);\n        vis[i][j] = true;\n        que.push(d);\n        num[d.id[3]] = G[d.y][d.x] - '0';\n        while(!que.empty()) {\n          d = que.front();\n          que.pop();\n          for(int k = 0; k < 4; ++k) {\n            Dice nd = d;\n            nd.x += dj[k];\n            nd.y += di[k];\n            nd.roll(k);\n            if(nd.x < 0 || nd.x >= W) continue;\n            if(nd.y < 0 || nd.y >= H) continue;\n            if(G[nd.y][nd.x] == '0') continue;\n            if(vis[nd.y][nd.x]) continue;\n            if(num[nd.id[3]] != -1) return false;\n            num[nd.id[3]] = G[nd.y][nd.x] - '0';\n            vis[nd.y][nd.x] = true;\n            que.push(nd);\n          }\n        }\n\n        for(int i = 0; i < 6; ++i) {\n          if(num[i] + num[5-i] != 7) return false;\n        }\n\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool solve() {\n  if(!check_g()) return false;\n  if(!check_b()) return false;\n  if(!check_ef()) return false;\n  if(!check_acd()) return false;\n  return true;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  while(N--) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n      }\n    }\n\n    cout << (solve() ? \"true\" : \"false\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nconst static double EPS = 1e-8;\n\nstruct Face {\n  int diff_x;\n  int diff_y;\n  int num;\n  Face(int x,int y,int n)\n    : diff_x(x),diff_y(y),num(n) {}\n};\n\nclass Dice{\n  int top;\n  int left;\n  int right;\n  int bottom;\n  int front;\n  int rear;\npublic:\n  Dice(){\n    top = -1;\n    front = -1;\n    left = -1;\n    bottom = -1;\n    right = -1;\n    rear = -1;\n  }\n  void print(){\n    printf(\"top:%d\\n\",top);\n    printf(\"front:%d\\n\",front);\n    printf(\"left:%d\\n\",left);\n    printf(\"bottom:%d\\n\",bottom);\n    printf(\"right:%d\\n\",right);\n    printf(\"rear:%d\\n\",rear);\n  }\n  bool check(){\n    if(left + right == 7\n       && top + bottom == 7 \n       && front + rear == 7) return true;\n    return false;\n  }\n  void rotateDice(string dir){\n    if(dir == \"north\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = top;\n      int tmp_bottom = front;\n      int tmp_rear = bottom;\n      int tmp_top = rear;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n \n    else if(dir == \"south\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = bottom;\n      int tmp_bottom = rear;\n      int tmp_rear = top;\n      int tmp_top = front;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n    else if(dir == \"west\"){\n      int tmp_bottom = left;\n      int tmp_top = right;\n      int tmp_left = top;\n      int tmp_right = bottom;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n \n    else if(dir == \"east\"){\n      int tmp_bottom = right;\n      int tmp_top = left;\n      int tmp_left = bottom;\n      int tmp_right = top;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n  }\n \n  int tellTop() const{\n    return top;\n  }\n  void writeTop(int t) {\n    top = t;\n  }\n};\n\nint stage[5][5];\nbool visited[5][5];\nconst string dir[] = {\"north\",\"west\",\"south\",\"east\"};\nvoid dfs(int sx,int sy,Dice& d){\n  d.writeTop(stage[sy][sx]);\n  visited[sy][sx] = true;\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    \n    if(dx >= 5 || dx < 0 || dy >= 5 || dy < 0) continue;\n    if(!visited[dy][dx] && stage[dy][dx] != 0){\n      d.rotateDice(dir[i]);\n      dfs(dx,dy,d);\n      d.rotateDice(dir[(i + 2) % 4]);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int i = 0; i < N; i++){\n\n      int start_x = -1;\n      int start_y = -1;\n      int start_num = -1;\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          scanf(\"%d\",&stage[y][x]);\n          if(stage[y][x] != 0){\n            start_x = x;\n            start_y = y;\n            start_num = stage[y][x];\n          }\n        }\n      }\n      memset(visited,false,sizeof(visited));\n      Dice dice;\n      dfs(start_x,start_y,dice);\n\n      bool over = false;\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          if(stage[y][x] != 0\n             && !visited[y][x]){\n            over = true;\n          }\n        }\n      }\n      printf(\"%s\\n\",(dice.check() && !over) ? \"true\" : \"false\");\n      // dice.print();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef pair<int, int> result;\n\nresult Areas(const string &s, int p = 0);\nresult OneArea(const string &s, int p = 0);\n\nint majority(int n) {\n  return n / 2 + 1;\n}\n\nint majority(vector<int> v) {\n/*  cout << \"majority called: \";\n  REP(i, v.size()) {\n    cout << v[i] << \" \";\n  }\n  cout << endl;*/\n\n  int sum = 0, least = majority(v.size());\n  sort(v.begin(), v.end());\n  for (int i = 0; i < least; i++) { sum += v[i]; }\n\n  return sum;\n}\n\nresult OneArea(const string &s, int p) {\n/*  cout << \"OneArea called: '\" << s.substr(p) << \"'\" << endl;*/\n  p++;\n  if (isdigit(s[p])) {\n    int people = 0;\n    while (isdigit(s[p])){ people = people * 10 + (s[p++] - '0'); }\n    p++;\n/*    printf(\"OneArea returns: (%d, %s)\\n\", \n        majority(people), s.substr(p).c_str());*/\n    return result(majority(people), p);\n  } else {\n    result r = Areas(s, p);\n    r.second ++;\n/*    printf(\"OneArea returns: (%d, %s)\\n\", \n        r.first, s.substr(r.second).c_str()); */\n    return r;\n  }\n}\n\nresult Areas(const string &s, int p) {\n/*  cout << \"Areas called: '\" << s.substr(p) << \"'\" << endl; */\n\n  vector<int> areas;\n  while(s[p] == '[') {\n    result r = OneArea(s, p);\n    areas.push_back(r.first);\n    p = r.second;\n  }\n/*  printf(\"Areas returns: (%d, %s)\\n\",\n      majority(areas), s.substr(p).c_str()); */\n  return result(majority(areas), p);\n}\n\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i, n) {\n    string s;\n    cin >> s;\n    result r = OneArea(s);\n    cout << r.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nconst static double EPS = 1e-8;\n\nstruct Face {\n  int diff_x;\n  int diff_y;\n  int num;\n  Face(int x,int y,int n)\n    : diff_x(x),diff_y(y),num(n) {}\n};\n\nclass Dice{\n  int top;\n  int left;\n  int right;\n  int bottom;\n  int front;\n  int rear;\npublic:\n  Dice(){\n    top = -1;\n    front = -1;\n    left = -1;\n    bottom = -1;\n    right = -1;\n    rear = -1;\n  }\n  void print(){\n    printf(\"top:%d\\n\",top);\n    printf(\"front:%d\\n\",front);\n    printf(\"left:%d\\n\",left);\n    printf(\"bottom:%d\\n\",bottom);\n    printf(\"right:%d\\n\",right);\n    printf(\"rear:%d\\n\",rear);\n  }\n  bool check(){\n    if(left + right == 7\n       && top + bottom == 7 \n       && front + rear == 7) return true;\n    return false;\n  }\n  void rotateDice(string dir){\n    if(dir == \"north\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = top;\n      int tmp_bottom = front;\n      int tmp_rear = bottom;\n      int tmp_top = rear;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n \n    else if(dir == \"south\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = bottom;\n      int tmp_bottom = rear;\n      int tmp_rear = top;\n      int tmp_top = front;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n    else if(dir == \"west\"){\n      int tmp_bottom = left;\n      int tmp_top = right;\n      int tmp_left = top;\n      int tmp_right = bottom;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n \n    else if(dir == \"east\"){\n      int tmp_bottom = right;\n      int tmp_top = left;\n      int tmp_left = bottom;\n      int tmp_right = top;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n  }\n \n  int tellTop() const{\n    return top;\n  }\n  void writeTop(int t) {\n    top = t;\n  }\n};\n\nint stage[5][5];\nbool visited[5][5];\nconst string dir[] = {\"south\",\"west\",\"north\",\"east\"};\nvoid dfs(int sx,int sy,Dice& d){\n  d.writeTop(stage[sy][sx]);\n  visited[sy][sx] = true;\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    \n    if(dx >= 5 || dx < 0 || dy >= 5 || dy < 0) continue;\n    if(!visited[dy][dx] && stage[dy][dx] != 0){\n      d.rotateDice(dir[i]);\n      dfs(dx,dy,d);\n      d.rotateDice(dir[(i + 2) % 4]);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int i = 0; i < N; i++){\n\n      int start_x = -1;\n      int start_y = -1;\n      int start_num = -1;\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          scanf(\"%d\",&stage[y][x]);\n          if(stage[y][x] != 0){\n            start_x = x;\n            start_y = y;\n            start_num = stage[y][x];\n          }\n        }\n      }\n      memset(visited,false,sizeof(visited));\n      Dice dice;\n      dfs(start_x,start_y,dice);\n\n      bool over = false;\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          if(stage[y][x] != 0\n             && !visited[y][x]){\n            over = true;\n          }\n        }\n      }\n      printf(\"%s\\n\",(dice.check() && !over) ? \"true\" : \"false\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nenum {\n  TOP,\n  BOTTOM,\n  RIGHT,\n  LEFT,\n  FRONT,\n  BACK\n};\n\n\nvoid shift(int &a, int &b, int &c, int &d){\n  int tmp = a; a = b; b = c; c = d; d = tmp;\n}\n\nvoid rotate_x(vector<int> &dice){\n    shift(dice[FRONT], dice[TOP], dice[BACK], dice[BOTTOM]);\n}\n\nvoid rotate_y(vector<int> &dice){\n  shift(dice[RIGHT], dice[TOP], dice[LEFT], dice[BOTTOM]);\n}\n\nbool check(vector<int> &dice){\n  return\n    dice[TOP] + dice[BOTTOM] == 7 &&\n    dice[RIGHT] + dice[LEFT] == 7 &&\n    dice[FRONT] + dice[BACK] == 7;\n}\n\nint mesh[5][5];\n\nvoid dfs(int x, int y, vector<int> &dice){\n  dice[BOTTOM] = mesh[x][y];\n  mesh[x][y] = 0;\n  \n  if (x + 1 < 5 && mesh[x + 1][y]){\n    rotate_x(dice);\n    dfs(x + 1, y, dice);\n    rotate_x(dice);\n    rotate_x(dice);\n    rotate_x(dice);\n  }\n\n  if (x > 0 && mesh[x - 1][y]){\n    rotate_x(dice);\n    rotate_x(dice);\n    rotate_x(dice);\n    dfs(x + 1, y, dice);\n    rotate_x(dice);\n  }\n\n  if (y + 1 < 5 && mesh[x][y + 1]){\n    rotate_y(dice);\n    dfs(x, y + 1, dice);\n    rotate_y(dice);\n    rotate_y(dice);\n    rotate_y(dice);\n  }\n\n  if (y > 0 && mesh[x][y - 1]){\n    rotate_y(dice);\n    rotate_y(dice);\n    rotate_y(dice);\n    dfs(x, y - 1, dice);\n    rotate_y(dice);\n  }\n}\n\nbool solve(){\n  vector<int> dice(6, -1);\n  map<int, int> counter;\n  REP(i, 5) REP(j, 5) counter[mesh[i][j]]++;\n\n  if (counter[0] != 19) return false;\n  REP2(i, 1, 7) if (counter[i] != 1) return false;\n  \n  REP(i, 5) REP(j, 5) if (mesh[i][j] > 0){\n    dfs(i, j, dice);\n    bool is_dice = check(dice);\n    bool is_zero = true;\n    REP(k, 5) REP(l, 5) if (mesh[k][l] > 0) is_zero = false;\n    return is_dice && is_zero;\n  }\n  return false;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while (T--){\n    REP(i, 5) REP(j, 5) cin >> mesh[i][j];\n    if (solve()){\n      cout << \"true\" << endl;\n    } else {\n      cout << \"false\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i,a,n) for(ll i=a;i<(ll)(n);i++)\n\nstruct Dice {\n   int b,f,l,r,u,d;\n\n   void RollN()\n  {\n    //  --y;\n    int buff = d;\n    d = f;\n    f = u;\n    u = b;\n    b = buff;\n  }\n\n  void RollS()\n  {\n    // ++y;\n    int buff = d;\n    d = b;\n    b = u;\n    u = f;\n    f = buff;\n  }\n\n  void RollL() // ----->\n  {\n    int buff = f;\n    f = l;\n    l = b;\n    b = r;\n    r = buff;\n  }\n\n  void RollR() // <------\n  {\n    int buff = f;\n    f = r;\n    r = b;\n    b = l;\n    l = buff;\n  }\n\n  void RollE() // .o -> o.\n  {\n    // --x;\n    int buff = d;\n    d = l;\n    l = u;\n    u = r;\n    r = buff;\n  }\n\n\n  void RollW() // o. -> .o\n  {\n    //  ++x;\n    int buff = d;\n    d = r;\n    r = u;\n    u = l;\n    l = buff;\n  }\n\n};\n\n//頑張った\nvoid dfs(int x, int y, int f[5][5], Dice &dice, char c, vector<vector<bool>> visited){\n   if(x >= 5 || x < 0 || y >= 5 || y < 0 || visited[y][x]){\n      return;\n   }\n\n   visited[y][x] = true;\n   if(f[y][x] == 0){\n      return;\n   }\n\n   if(c == 'r') dice.RollL();\n   if(c == 'l') dice.RollR();\n   if(c == 'u') dice.RollS();\n   if(c == 'd') dice.RollN();\n\n   dice.b = f[y][x];\n\n\n   dfs(x+1, y, f, dice, 'r', visited);\n   dfs(x-1, y, f, dice, 'l', visited);\n   dfs(x, y+1, f, dice, 'd', visited);\n   dfs(x, y-1, f, dice, 'u', visited);\n\n   if(c == 'r') dice.RollR();\n   if(c == 'l') dice.RollL();\n   if(c == 'u') dice.RollN();\n   if(c == 'd') dice.RollS();\n}\n\nint main(){\n   int n; cin>>n;\n   while(n--){\n      int f[5][5];\n      vector<int> nums(7, 0);\n      int x, y;\n      for(int i=0; i<5; i++){\n         for(int j=0; j<5; j++){\n            cin>>f[i][j];\n            nums[f[i][j]]++;\n            if(f[i][j] != 0) x=j,y=i;\n         }\n      }\n\n      //1-6の出現回数が1ならok\n      bool flag = false;\n      for(int i=1; i<7; i++){\n         if(nums[i] != 1) flag = true;\n      }\n      if(flag){\n         cout << \"false\" << endl;\n         continue;\n      }\n\n      Dice dice = {0, 0, 0, 0, 0, 0};\n      vector<vector<bool>> visited(5, vector<bool>(5, false));\n      dfs(x, y, f, dice, 'b', visited);\n\n      cout << ((dice.b + dice.f == 7 && dice.l+dice.r == 7 && dice.u+dice.d == 7) ? \"true\" : \"false\") << endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k,l,m;\n  int n;\n  cin>>n;\n  for(i=0;i<n;++i){\n    int a[7][7],b[6]={};\n    memset(a,-1,sizeof(a));\n    for(j=1;j<=5;++j){\n      for(k=1;k<=5;++k){\n\tcin>>a[j][k];\n\tif(a[j][k])\n\t  b[a[j][k]-1]++;\n      }\n    }\n    for(j=0;j<6;++j){\n      if(b[j]!=1)\n\tbreak;\n    }\n    if(j<6){\n      cout<<\"false\"<<endl;\n    }else{\n      int c[7][7];\n      memset(c,-1,sizeof(c));\n      for(j=1;j<=5;++j){\n\tfor(k=1;k<=5;++k){\n\t  if(a[j][k]&&c[j][k]){\n\t    int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\t    for(l=0;l<4;++l){\n\t      for(m=0;;++m){\n\t\tif(a[j+dy[l]+dx[l]*m][k+dx[l]+dy[l]*m]>0){\n\t\t  if(a[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]>0&&c[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]&&a[j][k]+a[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]==7){\n\t\t    c[j][k]=c[j+dy[l]*2+dx[l]*m][k+dx[l]*2+dy[l]*m]=0;\n\t\t    break;\n\t\t  }\n\t\t}else{\n\t\t  break;\n\t\t}\n\t      }\n\t      if(c[j][k]==0)\n\t\tbreak;\n\t      for(m=0;;++m){\n\t\tif(a[j+dy[l]-dx[l]*m][k+dx[l]-dy[l]*m]>0){\n\t\t  if(a[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]>0&&c[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]&&a[j][k]+a[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]==7){\n\t\t    c[j][k]=c[j+dy[l]*2-dx[l]*m][k+dx[l]*2-dy[l]*m]=0;\n\t\t    break;\n\t\t  }\n\t\t}else{\n\t\t  break;\n\t\t}\n\t      }\n\t      if(c[j][k]==0)\n\t\tbreak;\n\t    }\n\t    if(l==4)\n\t      break;\n\t  }\n\t}\n\tif(k<=5)\n\t  break;\n      }\n      if(j>5)\n\tcout<<\"true\"<<endl;\n      else\n\tcout<<\"false\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint F[5][5];\nbool u[5][5];\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct Die{\n  int p[6];\n  bool f;\n  int b;\n  Die():p{},f(),b(){\n  }\n  void set(int x){\n    if(p[0]){\n      f=true;\n    }else{\n      p[0]=x;\n      b|=1<<x;\n    }\n  }\n  void rot(int *x){\n    int t=p[x[0]];\n    p[x[0]]=p[x[1]];\n    p[x[1]]=p[x[2]];\n    p[x[2]]=p[x[3]];\n    p[x[3]]=t;\n  }\n  void rot(int x){\n    if(x>=2){\n      rot(x^2);\n      rot(x^2);\n      rot(x^2);\n    }else{\n      static int r[][4]={\n\t{0,4,5,1},\n\t{0,2,5,3},\n      };\n      rot(r[x]);\n    }\n  }\n  bool is_valid(){\n    return b+2==1<<7&&!f&&p[0]+p[5]==7&&p[1]+p[4]==7&&p[2]+p[3]==7;\n  }\n};\n\nvoid dfs(int y,int x,Die &d){\n  if(y<0||5<=y||x<0||5<=x||F[y][x]==0||u[y][x]++)return;\n  d.set(F[y][x]);\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    d.rot(i);\n    dfs(ny,nx,d);\n    d.rot(2^i);\n  }\n}\n\nint main(){\n  int N;\n  cin>>N;\n  while(N--){\n    bool f=true;\n    int y=0,x=0;\n    int c=0;\n    for(int i=0;i<5;i++){\n      for(int j=0;j<5;j++){\n\tcin>>F[i][j];\n\tif(F[i][j]){\n\t  y=i;\n\t  x=j;\n\t  c++;\n\t}\n      }\n    }\n    fill(u[0],u[5],false);\n    Die d;\n    dfs(y,x,d);\n    cout<<boolalpha<<(c==6&&d.is_valid())<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\nclass dice {\nprivate:\n\tint num[6];\n\n\tvoid roll(FACE a, FACE b, FACE c, FACE d) {\n\t\tint tmp = num[a];\n\t\tnum[a] = num[b];\n\t\tnum[b] = num[c];\n\t\tnum[c] = num[d];\n\t\tnum[d] = tmp;\n\t}\n\npublic:\n\tdice() {\n\t\tmemset(num, 0, sizeof(num));\n\t}\n\n\tbool check() {\n\t\tvector<bool> used(7, false);\n\t\tfor(int i = 0; i < 6; ++i) {\n\t\t\tif(num[i] == 0 || used[num[i]])\n\t\t\t\treturn false;\n\t\t\tused[num[i]] = true;\n\t\t}\n\n\t\treturn num[TOP] + num[BOTTOM] == 7 && num[FRONT] + num[BACK] == 7 && num[LEFT] + num[RIGHT] == 7;\n\t}\n\n\tint& operator[](FACE f) { return num[f]; }\n\tvoid north() { roll(TOP, BACK, BOTTOM, FRONT); }\n\tvoid south() { roll(TOP, FRONT, BOTTOM, BACK); }\n\tvoid east() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n\tvoid west() { roll(TOP, RIGHT, BOTTOM, LEFT); }\n};\n\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\ndice die;\nint f[5][5];\nbool visited[5][5];\n\nvoid search(int x, int y) {\n\tdie[TOP] = f[y][x];\n\tvisited[y][x] = true;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= 5 || ny >= 5)\n\t\t\tcontinue;\n\n\t\tif(visited[ny][nx] || !f[ny][nx])\n\t\t\tcontinue;\n\n\t\tswitch(i) {\n\t\tcase 0: die.east(); break;\n\t\tcase 1: die.west(); break;\n\t\tcase 2: die.south(); break;\n\t\tcase 3: die.north(); break;\n\t\t}\n\n\t\tsearch(nx, ny);\n\n\t\tswitch(i) {\n\t\tcase 0: die.west(); break;\n\t\tcase 1: die.east(); break;\n\t\tcase 2: die.north(); break;\n\t\tcase 3: die.south(); break;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\twhile(n--) {\n\t\tfor(int i = 0; i < 5; ++i)\n\t\t\tfor(int j = 0; j < 5; ++j)\n\t\t\t\tcin >> f[i][j];\n\n\t\tbool ok = false, first = true;\n\t\tdie = dice();\n\t\tmemset(visited, false, sizeof(visited));\n\t\tfor(int i = 0; i < 5; ++i) {\n\t\t\tfor(int j = 0; j < 5; ++j) {\n\t\t\t\tif(f[i][j] && !visited[i][j]) {\n\t\t\t\t\tif(!first)\n\t\t\t\t\t\tgoto finish;\n\n\t\t\t\t\tfirst = true;\n\t\t\t\t\tsearch(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tok = die.check();\n\n\tfinish:;\n\t\tcout << (ok ? \"true\" : \"false\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nvector<int> roll_i(vector<int> dice, int a, int b, int c, int d){\n  vector<int> res = dice;\n  res[a] = dice[b];\n  res[b] = dice[c];\n  res[c] = dice[d];\n  res[d] = dice[a];\n  return res;\n}\nvector<int> roll(vector<int> d, int r){\n  if(r == 0){\n    return roll_i(d, 0, 1, 3, 4);\n  }else if(r == 1){\n    return roll_i(d, 0, 2, 3, 5);\n  }else if(r == 2){\n    return roll_i(d, 0, 4, 3, 1);\n  }else if(r == 3){\n    return roll_i(d, 0, 5, 3, 2);\n  }\n}\nbool solve(int mesh[5][5]){\n  bool used[5][5] = {};\n  int f_face;\n  int sx, sy;\n  REP(y, 5)REP(x, 5)if(mesh[y][x]){\n    f_face = mesh[y][x];\n    sx = x, sy = y;\n    queue<int> qx, qy;\n    qx.push(x); qy.push(y);\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      used[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(valid(nx, ny, 5, 5) && !used[ny][nx] && mesh[ny][nx]){\n          qx.push(nx); qy.push(ny);\n        }\n      }\n    }\n    goto END;\n  }\nEND:\n  int cnt[6] = {};\n  REP(y, 5)REP(x, 5){\n    if(used[y][x]){\n      cnt[mesh[y][x] - 1] ++;\n    }else if(mesh[y][x]){\n      return false;\n    }\n  }\n  REP(i, 6) if(cnt[i] != 1) return false;\n  vector<int> dice_rest;\n  for(int i = 1; i <= 6; i++){\n    if(f_face != i && f_face + i != 7){\n      dice_rest.push_back(i);\n    }\n  }\n  do{\n    bool ok = true;\n    if(dice_rest[0] + dice_rest[2] != 7) continue;\n    vector<int> dice(6);\n    dice[0] = f_face; dice[1] = dice_rest[0]; dice[2] = dice_rest[1];\n    dice[3] = 7 - f_face; dice[4] = dice_rest[2]; dice[5] = dice_rest[3];\n    queue<vector<int> > qd;\n    queue<int> qx, qy;\n    bool used2[5][5] = {};\n    qx.push(sx);\n    qy.push(sy);\n    qd.push(dice);\n    /*\n    int C = 0;\n    printf(\"start:\");\n    debug(dice.begin(), dice.end());\n    */\n    while(!qx.empty()){\n      int x = qx.front(); qx.pop();\n      int y = qy.front(); qy.pop();\n      vector<int> d = qd.front(); qd.pop();\n      /*\n      printf(\"%d: \", mesh[y][x]);\n      debug(d.begin(), d.end());\n      */\n      if(d[0] != mesh[y][x]){\n        ok = false;\n        break;\n      }\n      used2[y][x] = true;\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        vector<int> nd = roll(d, r);\n        if(valid(nx, ny, 5, 5) && !used2[ny][nx] && mesh[ny][nx]){\n          qx.push(nx); qy.push(ny); qd.push(nd);\n        }\n      }\n    }\n    if(ok) return true;\n  }while(next_permutation(dice_rest.begin(), dice_rest.end()));\n  return false;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  while(N--){\n    int mesh[5][5];\n    REP(i, 5)REP(j, 5) cin>>mesh[i][j];\n    if(solve(mesh)) cout<<\"true\"<<endl;\n    else cout<<\"false\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<iomanip>\n\n#define N 5\nusing namespace std;\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nstruct Dice{\n  int D[6];\n  Dice(){for(int i = 0; i < 6; ++i)D[i]=-1;}\n  void roll(int dir){\n    int t;\n    switch(dir){\n    case NORTH:t=D[4];D[4]=D[5];D[5]=D[1];D[1]=D[0];D[0]=t;break;\n    case EAST: t=D[3];D[3]=D[5];D[5]=D[2];D[2]=D[0];D[0]=t;break;\n    case SOUTH:t=D[1];D[1]=D[5];D[5]=D[4];D[4]=D[0];D[0]=t;break;\n    case WEST: t=D[2];D[2]=D[5];D[5]=D[3];D[3]=D[0];D[0]=t;break;\n    }\n  }\n  bool isDice(){\n    for(int i = 0; i < 3;++i){\n      if(D[i]+D[5-i]!=7)return false;\n    }\n    return true;\n  }\n};\n\nstruct state{\n  int i,j,pre;\n  state(int i, int j, int p):i(i),j(j),pre(p){}\n};\n\nbool isinside(int i, int j){\n  return 0<=i&&i<N&&0<=j&&j<N;\n}\n\nbool solve(int M[][N], int sti, int stj, int L){\n  queue<state> Q;\n  set<pair<int,int> > vS;\n  state st(sti,stj,1);\n  Dice d;\n  d.D[0]=M[sti][stj];\n  Q.push(st);\n  int stop=0;\n  while(!Q.empty()){\n    ++stop;\n    if(stop>625)break;\n    state now = Q.front();Q.pop();\n    vS.insert(make_pair(now.i,now.j));\n    for(int k = (now.pre-1+4)%4, nk=0; nk < 4; ++nk){\n      state next(now.i+di[k],now.j+dj[k],k);\n      Dice td=d;\n      if(isinside(next.i,next.j)&&M[next.i][next.j]>0){\n\ttd.roll(k);\n\tif(td.D[0]==-1||td.D[0]==M[next.i][next.j]){\n\t  td.D[0]=M[next.i][next.j];\n\t  Q.push(next);\n\t  d=td;\n\t  break;\n\t}else return false;\n      }\n      ++k;\n      k%=4;\n    }\n  }\n  set<int> S;\n  for(int i = 0; i < 6; ++i){\n    if(d.D[i]>0&&d.D[i]<7)S.insert(d.D[i]);\n  }\n  return (S.size()==6)&&vS.size()==6&&d.isDice()&&L==6;\n}\n\nint main(){\n  int T;\n  \n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n\n    int M[N][N];\n    int sti,stj,l=0;\n    \n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcin >> M[i][j];\n\tif(M[i][j]>0){\n\t  sti=i;\n\t  stj=j;\n\t  ++l;\n\t}\n      }\n    }\n    cout << (solve(M,sti,stj,l)?\"true\":\"false\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nconst static double EPS = 1e-8;\n\nstruct Face {\n  int diff_x;\n  int diff_y;\n  int num;\n  Face(int x,int y,int n)\n    : diff_x(x),diff_y(y),num(n) {}\n};\n\nclass Dice{\n  int top;\n  int left;\n  int right;\n  int bottom;\n  int front;\n  int rear;\npublic:\n  Dice(){\n    top = -1;\n    front = -1;\n    left = -1;\n    bottom = -1;\n    right = -1;\n    rear = -1;\n  }\n  void print(){\n    printf(\"top:%d\\n\",top);\n    printf(\"front:%d\\n\",front);\n    printf(\"left:%d\\n\",left);\n    printf(\"bottom:%d\\n\",bottom);\n    printf(\"right:%d\\n\",right);\n    printf(\"rear:%d\\n\",rear);\n  }\n  bool check(){\n    if(left + right == 7\n       && top + bottom == 7 \n       && front + rear == 7) return true;\n    return false;\n  }\n  void rotateDice(string dir){\n    if(dir == \"north\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = top;\n      int tmp_bottom = front;\n      int tmp_rear = bottom;\n      int tmp_top = rear;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n \n    else if(dir == \"south\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = bottom;\n      int tmp_bottom = rear;\n      int tmp_rear = top;\n      int tmp_top = front;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n    else if(dir == \"west\"){\n      int tmp_bottom = left;\n      int tmp_top = right;\n      int tmp_left = top;\n      int tmp_right = bottom;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n \n    else if(dir == \"east\"){\n      int tmp_bottom = right;\n      int tmp_top = left;\n      int tmp_left = bottom;\n      int tmp_right = top;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n  }\n \n  int tellTop() const{\n    return top;\n  }\n  void writeTop(int t) {\n    top = t;\n  }\n};\n\nint stage[5][5];\nbool visited[5][5];\nconst string dir[] = {\"south\",\"west\",\"north\",\"east\"};\nvoid dfs(int sx,int sy,Dice& d){\n  d.writeTop(stage[sy][sx]);\n  visited[sy][sx] = true;\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    \n    if(dx >= 5 || dx < 0 || dy >= 5 || dy < 0) continue;\n    if(!visited[dy][dx] && stage[dy][dx] != 0){\n      d.rotateDice(dir[i]);\n      dfs(dx,dy,d);\n      d.rotateDice(dir[(i + 2) % 4]);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int i = 0; i < N; i++){\n\n      int start_x = -1;\n      int start_y = -1;\n      int start_num = -1;\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          scanf(\"%d\",&stage[y][x]);\n          if(stage[y][x] != 0){\n            start_x = x;\n            start_y = y;\n            start_num = stage[y][x];\n          }\n        }\n      }\n      memset(visited,false,sizeof(visited));\n      Dice dice;\n      dfs(start_x,start_y,dice);\n      printf(\"%s\\n\",dice.check() ? \"true\" : \"false\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\nclass Cube{\n    public:\n    int f[6];\n    Cube(){}\n    void roll_y(){ roll(0, 2, 5, 3);}\n    void roll_x(){ roll(0, 1, 5, 4);}\n    void roll(int i, int j, int k, int l){\n\tint t = f[i]; f[i] = f[j]; f[j] = f[k]; f[k] = f[l]; f[l] = t;\n    }\n  \n  bool valid(){\n    bool v[6];\n    rep(i, 6) v[i] = false;\n    rep(i, 6) if ( 1 <= f[i]  && f[i] <= 6 ) v[f[i]-1] = true;\n    rep(i, 6) if ( !v[i] ) return false;\n    return f[0]+f[5]==7 && f[1]+f[4]==7 && f[2]+f[3]==7;\n  }\n};\n\nclass State{\n  public:\n  int pi, pj;\n  Cube cube;\n  State(){}\n  State(int pi, int pj):pi(pi),pj(pj){\n    rep(i, 6) cube.f[i] = -1;\n  }\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    rep(i, 6){\n      if ( cube.f[i] == s.cube.f[i] ) continue;\n      return cube.f[i] < s.cube.f[i];\n    }\n    return false;\n  }\n};\n\nint G[7][7];\nset<State> V;\n\nbool dfs(State u){\n  u.cube.f[5] = G[u.pi][u.pj];\n  if ( u.cube.valid() ) return true;\n  V.insert(u);\n\n  State v;\n  int di[4] = {1, -1, 0, 0};\n  int dj[4] = {0, 0, -1, 1};\n  int dp[4] = {1, 4, 3, 2};\n  rep(r, 4){\n    if ( u.cube.f[dp[r]] == -1 && G[u.pi+di[r]][u.pj+dj[r]] ||\n\t u.cube.f[dp[r]] == G[u.pi+di[r]][u.pj+dj[r]] ){\n      v = u;\n      v.pi += di[r]; v.pj += dj[r];\n      if ( dp[r] == 1 ) rep(i, 3) v.cube.roll_x();\n      if ( dp[r] == 4 ) v.cube.roll_x();\n      if ( dp[r] == 3 ) v.cube.roll_y();\n      if ( dp[r] == 2 ) rep(i, 3) v.cube.roll_y();\n      if ( V.find(v) == V.end() && dfs(v) ) return true;\n\n    }\n  }\n}\n\nbool valid(vector<int> d){\n  if ( d.size() != 6 ) return false;\n  sort(d.begin(), d.end());\n  rep(i, 6)\n    if ( i+1 != d[i] ) return false;\n  return true;\n}\n\nmain(){\n  int tcase; cin >> tcase;\n  rep(t, tcase){\n    rep(i, 7) rep(j, 7) G[i][j] = 0;\n    int si, sj;\n    vector<int> d;\n    for ( int i = 1; i <= 5; i++ ){\n      for ( int j = 1; j <= 5; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] ) { \n\t  si = i; sj = j; \n\t  d.push_back(G[i][j]);\n\t}\n      }\n    }\n    State s = State(si, sj);\n    V.clear();\n    if ( valid(d) && dfs(s) ) cout << \"true\" << endl;\n    else cout << \"false\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef pair<int, int> result;\n\nresult Areas(const string &s, int p = 0);\nresult OneArea(const string &s, int p = 0);\n\nint majority(int n) {\n  return n / 2 + 1;\n}\n\nint majority(vector<int> v) {\n/*  cout << \"majority called: \";\n  REP(i, v.size()) {\n    cout << v[i] << \" \";\n  }\n  cout << endl;*/\n\n  int sum = 0, least = majority(v.size());\n  sort(v.begin(), v.end());\n  for (int i = 0; i < least; i++) { sum += v[i]; }\n\n  return sum;\n}\n\nresult OneArea(const string &s, int p) {\n/*  cout << \"OneArea called: '\" << s.substr(p) << \"'\" << endl;*/\n  p++;\n  if (isdigit(s[p])) {\n    int people = 0;\n    while (isdigit(s[p])){ people = people * 10 + (s[p++] - '0'); }\n    p++;\n/*    printf(\"OneArea returns: (%d, %s)\\n\", \n        majority(people), s.substr(p).c_str());*/\n    return result(majority(people), p);\n  } else {\n    result r = Areas(s, p);\n    r.second ++;\n/*    printf(\"OneArea returns: (%d, %s)\\n\", \n        r.first, s.substr(r.second).c_str()); */\n    return r;\n  }\n}\n\nresult Areas(const string &s, int p) {\n/*  cout << \"Areas called: '\" << s.substr(p) << \"'\" << endl; */\n\n  vector<int> areas;\n  while(s[p] == '[') {\n    result r = OneArea(s, p);\n    areas.push_back(r.first);\n    p = r.second;\n  }\n/*  printf(\"Areas returns: (%d, %s)\\n\",\n      majority(areas), s.substr(p).c_str()); */\n  return result(majority(areas), p);\n}\n\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i, n) {\n    string s;\n    cin >> s;\n    result r = OneArea(s);\n    cout << r.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nint field[5][5];\nusing namespace std;\nenum FACE{TOP,BOTTOM,NORTH,SOUTH,WEST,EAST};\nstruct dice{\n  int num[6];\n\n  int &operator[](FACE f) { return num[f]; }\n\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    const int tmp = num[a];\n    num[a] = num[b];\n    num[b] = num[c];\n    num[c] = num[d];\n    num[d] = tmp;\n  }\n\n  void move(int d) {\n    switch(d) {\n    case 0: roll(TOP, SOUTH, BOTTOM, NORTH); break;\n    case 1: roll(TOP, WEST, BOTTOM, EAST);   break;\n    case 2: roll(TOP, NORTH, BOTTOM, SOUTH); break;\n    case 3: roll(TOP, EAST, BOTTOM, WEST);   break;\n    default: assert(false);\n    }\n  }\n};\nbool valid(int x,int y){\n  return x >= 0 && x < 5 && y >= 0 && y < 5;\n}\nvoid dfs(int x,int y,dice &die){\n  \n  die[BOTTOM] = field[y][x];\n  field[y][x] = 0;\n  for(int i =0 ;i < 4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(valid(nx,ny)){\n      if(field[ny][nx]){\n\tdie.move(i);\n\tdfs(nx,ny,die);\n\tdie.move((i+2)%4);\n      }\n    }\n  }\n  \n}\nbool solve(){\n  int cnt[7] = {};\n  for(int i = 0;i < 5;i++){\n    for(int j = 0;j < 5;j++){\n      cin >> field[i][j];\n      cnt[field[i][j]]++;\n    }\n  }\n  for(int i = 1;i <= 6;i++){\n    if(cnt[i] != 1)return false;\n  }\n  dice die;\n  \n  for(int i = 0;i < 5;i++){\n    for(int j = 0;j < 5;j++){\n      if(field[i][j] != 0){\n\tdfs(j,i,die);\n\tgoto unloop;\n      }\n    }\n  }\n unloop:;\n\n  return die[TOP] + die[BOTTOM] == 7 && die[EAST] + die[WEST] == 7 && die[NORTH] + die[SOUTH] == 7;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cout << (solve() ? \"true\" : \"false\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nclass Pattern{\npublic:\n\tint w,h;\n\tchar fig[5][5];\n\tPattern(){}\n\tPattern(int ww,int hh):w(ww),h(hh){}\n};\n\nbool isMatch(const int f[5][5],const Pattern &p){\n\tint w=p.w,h=p.h;\n\n\tint c=0;\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)\tif(f[i][j]!=0)\tc++;\n\tif(c!=6)\treturn false;\n\n\tfor(int i=0;i<6-h;i++)for(int j=0;j<6-w;j++){\n\t\tint cnt[3]={};\n\t\tbool chk[7]={};\n\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++){\n\t\t\tif(!islower(p.fig[y][x]))\tcontinue;\n\t\t\tif(f[i+y][j+x]<=0 || 6<f[i+y][j+x] || chk[f[i+y][j+x]])\tgoto NOMATCH;\n\t\t\tchk[f[i+y][j+x]]=true;\n\t\t\tcnt[p.fig[y][x]-'a']+=f[i+y][j+x];\n\t\t}\n\n\t\tif(cnt[0]==7 && cnt[1]==7 && cnt[2]==7)\treturn true;\n\t\tNOMATCH:;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tchar fig[11][5][6]={\n\t\t{\" c  \",\n\t\t \"abab\",\n\t\t \" c  \"},\n\t\t{\" c  \",\n\t\t \"abab\",\n\t\t \"  c \"},\n\t\t{\" c  \",\n\t\t \"abab\",\n\t\t \"   c\"},\n\t\t{\"  c \",\n\t\t \"abab\",\n\t\t \"   c\"},\n\t\t{\"   c\",\n\t\t \"abab\",\n\t\t \"   c\"},\n\t\t{\"c   \",\n\t\t \"abab\",\n\t\t \"   c\"},\n\t\t{\"ab  \",\n\t\t \" ca \",\n\t\t \"  bc\"},\n\t\t{\"aba  \",\n\t\t \"  cbc\"},\n\t\t{\"ab  \",\n\t\t \" cac\",\n\t\t \"   b\"},\n\t\t{\"ab  \",\n\t\t \" cac\",\n\t\t \"  b \"},\n\t\t{\"ab  \",\n\t\t \" cac\",\n\t\t \" b  \"}\n\t};\n\n\tPattern ptn[88];\n\tptn[ 0]=Pattern(4,3);\n\tptn[ 1]=Pattern(4,3);\n\tptn[ 2]=Pattern(4,3);\n\tptn[ 3]=Pattern(4,3);\n\tptn[ 4]=Pattern(4,3);\n\tptn[ 5]=Pattern(4,3);\n\tptn[ 6]=Pattern(4,3);\n\tptn[ 7]=Pattern(5,2);\n\tptn[ 8]=Pattern(4,3);\n\tptn[ 9]=Pattern(4,3);\n\tptn[10]=Pattern(4,3);\n\tfor(int i=0;i<11;i++){\n\t\tint h=ptn[i].h;\n\t\tfor(int k=0;k<h;k++)\n\t\t\tstrcpy(ptn[i].fig[k],fig[i][k]);\n\t}\n\n\tfor(int i=11;i<22;i++){\n\t\tptn[i]=Pattern(ptn[i-11].w,ptn[i-11].h);\n\t\tint w=ptn[i].w;\n\t\tint h=ptn[i].h;\n\t\tfor(int k=0;k<h;k++){\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\tptn[i].fig[k][w-j-1]=ptn[i-11].fig[k][j];\n\t\t}\n\t}\n\n\tfor(int t=1;t<4;t++){\n\t\tfor(int i=22*t;i<22*(t+1);i++){\n\t\t\tptn[i]=Pattern(ptn[i-22].h,ptn[i-22].w);\n\t\t\tint w=ptn[i-22].w;\n\t\t\tint h=ptn[i-22].h;\n\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\tptn[i].fig[w-j-1][k]=ptn[i-22].fig[k][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tint f[5][5];\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)\tscanf(\"%d\",f[i]+j);\n\n\t\tbool ok=false;\n\t\tfor(int i=0;i<88;i++){\n\t\t\tif(isMatch(f,ptn[i])){ ok=true; break; }\n\t\t}\n\t\tputs(ok?\"true\":\"false\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint c[7][7];\nint v[10];\nint pat[11][3][5]={\n{{2,3,0,0,0},\n{0,1,2,0,0},\n{0,0,3,1,0}},\n{{2,3,2,0,0},\n{0,0,1,3,1},\n{0,0,0,0,0}},\n{{3,1,0,0,0},\n{0,2,3,2,0},\n{0,1,0,0,0}},\n{{3,1,0,0,0},\n{0,2,3,2,0},\n{0,0,1,0,0}},\n{{3,2,0,0,0},\n{0,1,3,1,0},\n{0,0,0,2,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{3,0,0,0,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{0,3,0,0,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{0,0,3,0,0}},\n{{3,0,0,0,0},\n{1,2,1,2,0},\n{0,0,0,3,0}},\n{{0,3,0,0,0},\n{1,2,1,2,0},\n{0,3,0,0,0}},\n{{0,3,0,0,0},\n{1,2,1,2,0},\n{0,0,3,0,0}}\n};\nint to[10][10];\nint tmp[10];\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)scanf(\"%d\",&c[i][j]);\n\t\tbool dame=false;\n\t\tfor(int i=0;i<10;i++)v[i]=0;\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\t\tif(c[i][j]){\n\t\t\t\tv[c[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=6;i++)if(v[i]!=1)dame=true;\n\t\tif(dame){\n\t\t\tprintf(\"false\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tbool ok=false;\n\t\tfor(int s=0;s<2;s++){\n\t\tfor(int r=0;r<4;r++){\n\t\tfor(int i=0;i<11;i++){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tbool OK=true;\n\t\t\t\tfor(int k=0;k<10;k++)tmp[k]=0;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tfor(int l=0;l<5;l++){\n\t\t\t\t\t\tif(pat[i][k][l]){\n\t\t\t\t\t\t\tif(!c[j+k][l])OK=false;\n\t\t\t\t\t\t\ttmp[pat[i][k][l]]+=c[j+k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1;k<=3;k++)if(tmp[k]!=7)OK=false;\n\t\t\t\tif(OK)ok=true;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)to[j][4-i]=c[i][j];\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)c[i][j]=to[i][j];\n\t\t}\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)to[i][4-j]=c[i][j];\n\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++)c[i][j]=to[i][j];\n\t\t}\n\t\tif(ok)printf(\"true\\n\");\n\t\telse printf(\"false\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<iomanip>\n\n#define N 5\nusing namespace std;\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nstruct Dice{\n  int D[6];\n  Dice(){for(int i = 0; i < 6; ++i)D[i]=-1;}\n  void roll(int dir){\n    int t;\n    switch(dir){\n    case NORTH:t=D[4];D[4]=D[5];D[5]=D[1];D[1]=D[0];D[0]=t;break;\n    case EAST: t=D[3];D[3]=D[5];D[5]=D[2];D[2]=D[0];D[0]=t;break;\n    case SOUTH:t=D[1];D[1]=D[5];D[5]=D[4];D[4]=D[0];D[0]=t;break;\n    case WEST: t=D[2];D[2]=D[5];D[5]=D[3];D[3]=D[0];D[0]=t;break;\n    }\n  }\n  bool isDice(){\n    for(int i = 0; i < 3;++i){\n      if(D[i]+D[5-i]!=7)return false;\n    }\n    return true;\n  }\n};\n\nstruct state{\n  int i,j,pre;\n  state(int i, int j, int p):i(i),j(j),pre(p){}\n};\n\nbool isinside(int i, int j){\n  return 0<=i&&i<N&&0<=j&&j<N;\n}\n\nbool solve(int M[][N], int sti, int stj, int L){\n  queue<state> Q;\n  state st(sti,stj,1);\n  int left=L;\n  Dice d;\n  d.D[0]=M[sti][stj];\n  Q.push(st);\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    /*for(int i = 0; i < 6; ++i){\n      cout << d.D[i] << ' ';\n    }\n    cout << endl;*/\n    for(int k = (now.pre-1+4)%4, nk=0; nk < 4; ++nk,k++,k%=4){\n      state next(now.i+di[k],now.j+dj[k],k);\n      Dice td=d;\n      if(isinside(next.i,next.j)&&M[next.i][next.j]>0){\n\ttd.roll(k);\n\t--left;\n\tif(left<0)break;\n\tif(td.D[0]==-1||td.D[0]==M[next.i][next.j]){\n\t  td.D[0]=M[next.i][next.j];\n\t  Q.push(next);\n\t  d=td;\n\t  break;\n\t}else return false;\n      }\n    }\n  }\n  set<int> S;\n  for(int i = 0; i < 6; ++i){\n    if(d.D[i]!=-1)S.insert(d.D[i]);\n  }\n  return (S.size()==6)&&d.isDice();\n}\n\nint main(){\n  int T;\n  \n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n\n    int M[N][N];\n    int sti,stj,l=0;\n    \n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcin >> M[i][j];\n\tif(M[i][j]>0){\n\t  sti=i;\n\t  stj=j;\n\t  ++l;\n\t}\n      }\n    }\n    cout << boolalpha << solve(M,sti,stj,l) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\n//\n\nvector<string> trim(const vector<string>& vec) {\n  int n,e,s,w;\n  w = IINF, e = -IINF, n = IINF, s = -IINF;\n\n  for(int y=0;y<vec.size();y++){\n    for(int x=0;x<vec[y].size();x++){\n      if(vec[y][x] == '0')continue;\n      w = min(w,x);\n      e = max(e,x);\n      n = min(n,y);\n      s = max(s,y);\n    }\n  }\n  vector<string> ret;\n  for(int y=n;y<=s;y++) ret.push_back(vec[y].substr(w,e-w+1));\n  return ret;\n}\n\nvector<string> rotate90(const vector<string>& piece){\n  vector<string> ret;\n  int h = piece[0].size(), w = piece.size();\n  ret.resize(h);\n  for(int i=0;i<h;i++)ret[i].resize(w);\n  for(int y=0;y<ret.size();y++){\n    for(int x=0;x<ret[0].size();x++){\n      ret[y][x] = piece[ret[0].size()-1-x][y];\n    }\n  }\n  return ret;\n}\n\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice() {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n      a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n      a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    T tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\nFACE face[] = {TOP,BOTTOM,FRONT,BACK,LEFT,RIGHT};\nFACE dir[] = {FRONT,LEFT,BACK,RIGHT};\n\nint around[6][4] = \n  {\n    {1,2,4,3},\n    {0,3,5,2},\n    {0,1,5,4},\n    {0,4,5,1},\n    {0,2,5,3},\n    {1,3,4,2}\n  };\n\ndice<int> makeDice(int top,int front)\n{\n  dice<int> ret;\n  ret[TOP] = top, ret[BOTTOM] = 5-top;\n  ret[FRONT] = front, ret[BACK] = 5-front;\n  int idx = IINF;\n  for(int i=0;i<4;i++)\n    {\n      if(around[top][i] == front)\n\t{\n\t  idx = i+1;\n\t  break;\n\t}\n    }\n  assert(idx != IINF);\n  idx %= 4;\n  ret[RIGHT] = around[top][idx], ret[LEFT] = 5-around[top][idx];\n  return ret;\n}\n\n//\n\nint T,itmp;\nint dx[] = {0,-1,0,1};\nint dy[] = {1,0,-1,0};\nbool used[5][5];\nint counter[6];\n\ninline bool isValid(const vector<string>& vec,int x,int y){\n  return ( 0 <= x && x < vec[0].size() && 0 <= y && y < vec.size() );\n}\n\nvoid dfs(const vector<string> &vec,int x,int y){\n  if( used[y][x] ) return;\n  counter[vec[y][x]-'1']++;\n  used[y][x] = true;\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if( isValid(vec,nx,ny) ) {\n      if( !used[ny][nx] && vec[ny][nx] != '0' ) { \n        dfs(vec,nx,ny);\n      }\n    }\n  }\n}\n\n\n\nbool check(const vector<string> &vec){\n  rep(i,5)rep(j,5) used[i][j] = false;\n  rep(i,6) counter[i] = 0;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' ) {\n    dfs(vec,j,i);\n    goto Skip;\n  }\n Skip:;\n\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j] != '0' && !used[i][j] ) return false;\n  rep(i,6) if( counter[i] != 1 ) return false;\n  return true;\n}\n\nconst string YES = \"true\", NO = \"false\";\nint top,dice_tmp,H,W;\nbool error;\nconst bool DEBUG = false;\n\ninline void roller(dice<int> &die,int type){\n  if( type == 0 ) { // FRONT to TOP\n    rep(i,3) die.roll_x();\n  } else if( type == 1 ) { // LEFT to TOP\n    die.roll_y();\n  } else if( type == 2 ) { // BACK to TOP\n    die.roll_x();\n  } else { // RIGHT to TOP\n    rep(i,3) die.roll_y();\n  }\n}\n\nvoid dfs2(dice<int> &die,const vector<string>& vec,int x,int y){\n\n  if( error ) return;\n  if( used[y][x] ) return;\n  used[y][x] = true;\n  if( DEBUG )cout << \"(\" << x << \",\" << y << \") = \" << vec[y][x] << \" top = \" << die[TOP]+1  << \" rig = \" << die[RIGHT]+1<< endl;\n  rep(i,4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx] == '0' ) continue;\n    if( die[dir[i]] != vec[ny][nx]-'1' ) {\n      error = true;\n      return;\n    }\n\n    roller(die,i);\n    dfs2(die,vec,nx,ny);\n    roller(die,(i+2)%4);\n\n  }\n}\n\nbool correct(const vector<string>& vec){\n  dice<int> die = makeDice(top,dice_tmp);\n  int sx = -1, sy = -1;\n  rep(i,vec.size())rep(j,vec[i].size()) if( vec[i][j]-'1' == top ) {\n    sx = j, sy = i;\n    break;\n  }\n  //assert( sx != -1 && sy != -1 );\n  if(DEBUG)cout << \"TOP = \" << top << endl;\n  if(DEBUG)rep(i,6) { cout << die[face[i]] << endl; }\n\n  rep(i,4) {\n    int nx = sx + dx[i], ny = sy + dy[i];\n    if( !isValid(vec,nx,ny) ) continue;\n    if( vec[ny][nx]-'1' == dice_tmp ) {\n      int debug = 0;\n      while( die[dir[i]] != dice_tmp ){\n        die.roll_z();\n        debug++;\n        //assert(debug<=4);\n      };\n      break;\n    }\n  }\n\n  H = vec.size(), W = vec[0].size();\n\n  rep(i,H)rep(j,W)used[i][j]=false;\n  error = false;\n  if( DEBUG ) {\n  cout << endl;\n  cout << \"is correct???\" << endl;\n  rep(i,H){\n    rep(j,W) cout << vec[i][j];\n    cout << endl;\n  } cout << endl;\n  }\n  dfs2(die,vec,sx,sy);\n  if( error ) return false;\n  rep(i,H)rep(j,W)if(vec[i][j]!='0'&&!used[i][j])return false;\n  return true;\n}\n\ninline void simulate(vector<string> vec){\n\n  rep(i,2){\n    rep(_,4){\n      if( correct(vec) ) {\n        cout << YES << endl;\n        return;\n      }\n      vec = rotate90(vec);\n    }\n    rep(j,vec.size()) reverse(vec[j].begin(),vec[j].end());\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> T;\n  while( T-- ){\n    vector<string> vec(5);\n    rep(i,5) vec[i] = \"\";\n    rep(i,5) rep(j,5) {\n      cin >> itmp;\n      vec[i] += string(1,(char)('0'+itmp));\n    }\n\n    //vec = trim(vec);\n\n    if( !check(vec) ) {\n      cout << NO << endl;\n      continue;\n    }\n\n    top = -1,dice_tmp = -1;\n    rep(i,vec.size())rep(j,vec[i].size())if(vec[i][j]!='0') {\n      top = vec[i][j] - '1';\n      rep(k,4){\n        int nx = j + dx[k], ny = i + dy[k];\n        if( isValid(vec,nx,ny) ) {\n          if( vec[ny][nx] != '0' ) {\n            dice_tmp = vec[ny][nx] - '1';\n            goto Skip2;\n          }\n        } \n      }\n    }\n  Skip2:;\n    assert( top != -1 && dice_tmp != -1 );\n\n    simulate(vec);\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n// dice<hoge> di(arr); ÈÇÆé¾·é\n// ±ÌÆ«AarrÍ hoge di[6];Åé¾³êÄ¨èAid ÌlÌÉÊÌlªi[³êÄ¢éKvª éB\n// á¦ÎAid[TOP] = 3 ÈçÎAdi[3] ÌlªTOPÉÝè³êéB\n// TCRÆµÄµ¢©Ç¤©Ì»èÉ equivalent_to ðg¤B\nenum FACE { TOP, BOTTOM, FRONT, BACK, LEFT, RIGHT };\ntemplate <class T>\nclass dice {\npublic:\n  dice(T *v) {\n    id[TOP] = 0; id[FRONT] = 1; id[LEFT] = 2;\n    id[RIGHT] = 3; id[BACK] = 4; id[BOTTOM] = 5;\n    REP(i,6)\n      var[i] = v[i];\n  }\n  T& operator[] (FACE f) { return var[id[f]]; }\n  const T& operator[] (FACE f) const { return var[id[f]]; }\n  bool operator==(const dice<T>& b) const {\n    const dice<T> &a = *this;\n    return a[TOP] == b[TOP] && a[BOTTOM] == b[BOTTOM] &&\n           a[FRONT] == b[FRONT] && a[BACK] == b[BACK] &&\n           a[LEFT] == b[LEFT] && a[RIGHT] == b[RIGHT];\n  }\n  void roll_x() { roll(TOP, BACK, BOTTOM, FRONT); }\n  void roll_y() { roll(TOP, LEFT, BOTTOM, RIGHT); }\n  void roll_z() { roll(FRONT, RIGHT, BACK, LEFT); }\n  vector<dice> all_rolls() {\n    vector<dice> ret;\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        ret.push_back(*this);\n    return ret;\n  }\n  bool equivalent_to(const dice& di) {\n    for (int k = 0; k < 6; (k&1?roll_y():roll_x()),++k)\n      for (int i = 0; i < 4; roll_z(), ++i)\n        if (*this == di) return true;\n    return false;\n  }\nprivate:\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    int tmp = id[a];\n    id[a] = id[b]; id[b] = id[c];\n    id[c] = id[d]; id[d] = tmp;\n  }\n  T var[6];\n  int id[6];\n};\n\n\nint ba[5][5];\nint tmpba[5][5];\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nbool used[6];\n\nbool solve(int x, int y, dice<int> di) {\n  if (used[di[BOTTOM]-1]) return false;\n  used[di[BOTTOM]-1] = 1;\n  tmpba[x][y] = 0;\n\n  //printf(\"%d, %d\\n\", x,y);\n\n  REP(k,4) {\n    int xx = x+dx[k];\n    int yy = y+dy[k];\n    if (xx<0||xx>=5||yy<0||yy>=5) continue;\n    dice<int> tmp = di;\n    if (k == 0) { tmp.roll_x();tmp.roll_x();tmp.roll_x(); }\n    else if (k == 1) tmp.roll_y();\n    else if (k == 2) tmp.roll_x();\n    else { tmp.roll_y();tmp.roll_y();tmp.roll_y(); }\n    \n    if (tmpba[xx][yy] != 0){\n      // cout << k << \" \" << xx << \", \" << yy << \" \";\n      //     cout << tmp[BOTTOM] << endl;\n      if (tmp[BOTTOM] == tmpba[xx][yy]) {\n        if (!solve(xx,yy,tmp)) {\n          return false;\n        }\n      } else\n        return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  while(N--) {\n    int sx = -1, sy;\n    int p;\n    REP(y,5) {\n      REP(x,5) {\n        cin >> ba[x][y];\n        if (ba[x][y] != 0 && sx < 0) {\n          sx = x;\n          sy = y;\n          p = ba[x][y];\n        }\n      }\n    }\n    if (sx < 0) {\n      cout << \"false\" <<endl;\n      continue;\n    }\n    int arr[] = {1,2,3,4,5,6};\n    bool f = 0;\n    do {\n      dice<int> di(arr);\n      if (di[BOTTOM] + di[TOP] != 7 || di[FRONT] + di[BACK] != 7 || di[LEFT] + di[RIGHT] != 7) continue;\n      if (di[BOTTOM] == p) {\n        // cout << \"p = \" << p << endl;\n        // cout << \"front = \" << di[FRONT] << endl;\n        memset(used,0,sizeof(used));\n        memcpy(tmpba, ba, sizeof(ba));\n        if (solve(sx, sy, di)) {\n          f = 1;\n          REP(i,6) {\n            if (!used[i])\n              f = 0;\n          }\n          REP(y,5) REP(x,5)\n            if (tmpba[x][y])\n              f = 0;\n          if (f) break;\n        }\n      }\n    } while(next_permutation(arr, arr+6));\n    if (f)\n      cout << \"true\" << endl;\n    else\n      cout << \"false\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[7][7];\nbool vis[7][7];\nint ans[7];\n\nint r[4][7] = {\n\t{0, 3, 2, 6, 4, 1, 5},\n\t{0, 4, 1, 3, 6, 5, 2},\n\t{0, 5, 2, 1, 4, 6, 3},\n\t{0, 2, 6, 3, 1, 5, 4}\n};\n\nint di[] = {0, -1, 0, 1};\nint dj[] = {1, 0, -1, 0};\n\nvoid dfs(int i, int j, vector <int> v) {\n\tvis[i][j] = 1;\n\tans[v[1]] = a[i][j];\n\t/*\n\tcout << \"------\\n\";\n\tcout << i << ' ' << j << '\\n';\n\tfor(int i = 1; i <= 6; i ++)\n\t\tcout << v[i] << ' ';\n\tcout << '\\n';\n\t*/\n\tfor(int k = 0; k < 4; k ++) {\n\t\tint ni = i + di[k];\n\t\tint nj = j + dj[k];\n\t\tvector <int> u(7);\n\t\tfor(int t = 0; t < 7; t ++)\n\t\t\tu[t] = v[r[k][t]];\n\t\tif(!vis[ni][nj] && a[ni][nj])\n\t\t\tdfs(ni, nj, u);\n\t}\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tint t; cin >> t;\n\twhile(t --) {\n\t\tfor(int i = 1; i <= 5; i ++)\n\t\t\tfor(int j = 1; j <= 5; j ++)\n\t\t\t\tcin >> a[i][j];\n\t\tbool f = 1;\n\t\tfor(int k = 1; k <= 6; k ++) {\n\t\t\tint c = 0;\n\t\t\tfor(int i = 1; i <= 5; i ++)\n\t\t\t\tfor(int j = 1; j <= 5; j ++)\n\t\t\t\t\tc += a[i][j] == k;\n\t\t\tf &= c == 1;\n\t\t}\n\t\tif(!f) {\n\t\t\tcout << \"false\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfill(ans, ans + 6, 0);\n\t\tmemset(vis, 0, sizeof vis);\n\t\tfor(int i = 1; i <= 5; i ++)\n\t\t\tfor(int j = 1; j <= 5; j ++)\n\t\t\t\tif(a[i][j] == 1) {\n\t\t\t\t\tdfs(i, j, {0, 1, 2, 3, 4, 5, 6});\n\t\t\t\t}\n\t\tif(ans[1] + ans[6] == 7 && ans[2] + ans[4] == 7 && ans[3] + ans[5] == 7)\n\t\t\tcout << \"true\\n\";\n\t\telse\n\t\t\tcout << \"false\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<set>\n#include<iomanip>\n\n#define N 5\nusing namespace std;\n\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nstruct Dice{\n  int D[6];\n  Dice(){for(int i = 0; i < 6; ++i)D[i]=-1;}\n  void roll(int dir){\n    int t;\n    switch(dir){\n    case NORTH:t=D[4];D[4]=D[5];D[5]=D[1];D[1]=D[0];D[0]=t;break;\n    case EAST: t=D[3];D[3]=D[5];D[5]=D[2];D[2]=D[0];D[0]=t;break;\n    case SOUTH:t=D[1];D[1]=D[5];D[5]=D[4];D[4]=D[0];D[0]=t;break;\n    case WEST: t=D[2];D[2]=D[5];D[5]=D[3];D[3]=D[0];D[0]=t;break;\n    }\n  }\n  bool isDice(){\n    for(int i = 0; i < 3;++i){\n      if(D[i]+D[5-i]!=7)return false;\n    }\n    return true;\n  }\n};\n\nstruct state{\n  int i,j,pre;\n  state(int i, int j, int p):i(i),j(j),pre(p){}\n};\n\nbool isinside(int i, int j){\n  return 0<=i&&i<N&&0<=j&&j<N;\n}\n\nbool solve(int M[][N], int sti, int stj, int L){\n  queue<state> Q;\n  state st(sti,stj,1);\n  int left=L;\n  Dice d;\n  d.D[0]=M[sti][stj];\n  Q.push(st);\n  while(!Q.empty()){\n    state now = Q.front();Q.pop();\n    for(int k = (now.pre-1+4)%4, nk=0; nk < 4; ++nk){\n      state next(now.i+di[k],now.j+dj[k],k);\n      Dice td=d;\n      if(isinside(next.i,next.j)&&M[next.i][next.j]>0){\n\ttd.roll(k);\n\t--left;\n\tif(left<0)break;\n\tif(td.D[0]==-1||td.D[0]==M[next.i][next.j]){\n\t  td.D[0]=M[next.i][next.j];\n\t  Q.push(next);\n\t  d=td;\n\t  break;\n\t}else return false;\n      }\n      ++k;\n      k%=4;\n    }\n  }\n  set<int> S;\n  for(int i = 0; i < 6; ++i){\n    if(d.D[i]!=-1)S.insert(d.D[i]);\n  }\n  return (S.size()==6)&&d.isDice()&&L==6;\n}\n\nint main(){\n  int T;\n  \n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n\n    int M[N][N];\n    int sti,stj,l=0;\n    \n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tcin >> M[i][j];\n\tif(M[i][j]>0){\n\t  sti=i;\n\t  stj=j;\n\t  ++l;\n\t}\n      }\n    }\n    cout << (solve(M,sti,stj,l)?\"true\":\"false\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef pair<int, int> result;\n\nresult Areas(const string &s, int p = 0);\nresult OneArea(const string &s, int p = 0);\n\nint majority(int n) {\n  return n / 2 + 1;\n}\n\nint majority(vector<int> v) {\n/*  cout << \"majority called: \";\n  REP(i, v.size()) {\n    cout << v[i] << \" \";\n  }\n  cout << endl;*/\n\n  int sum = 0, least = majority(v.size());\n  sort(v.begin(), v.end());\n  for (int i = 0; i < least; i++) { sum += v[i]; }\n\n  return sum;\n}\n\nresult OneArea(const string &s, int p) {\n/*  cout << \"OneArea called: '\" << s.substr(p) << \"'\" << endl;*/\n  p++;\n  if (isdigit(s[p])) {\n    int people = 0;\n    while (isdigit(s[p])){ people = people * 10 + (s[p++] - '0'); }\n    p++;\n/*    printf(\"OneArea returns: (%d, %s)\\n\", \n        majority(people), s.substr(p).c_str());*/\n    return result(majority(people), p);\n  } else {\n    result r = Areas(s, p);\n    r.second ++;\n/*    printf(\"OneArea returns: (%d, %s)\\n\", \n        r.first, s.substr(r.second).c_str()); */\n    return r;\n  }\n}\n\nresult Areas(const string &s, int p) {\n/*  cout << \"Areas called: '\" << s.substr(p) << \"'\" << endl; */\n\n  vector<int> areas;\n  while(s[p] == '[') {\n    result r = OneArea(s, p);\n    areas.push_back(r.first);\n    p = r.second;\n  }\n/*  printf(\"Areas returns: (%d, %s)\\n\",\n      majority(areas), s.substr(p).c_str()); */\n  return result(majority(areas), p);\n}\n\n\nint main() {\n  int n;\n  cin >> n;\n  REP(i, n) {\n    string s;\n    cin >> s;\n    result r = OneArea(s);\n    cout << r.first << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nint field[5][5];\nusing namespace std;\nenum FACE{TOP,BOTTOM,NORTH,SOUTH,WEST,EAST};\nstruct dice{\n  int num[6];\n\n  int &operator[](FACE f) { return num[f]; }\n\n  void roll(FACE a, FACE b, FACE c, FACE d) {\n    const int tmp = num[a];\n    num[a] = num[b];\n    num[b] = num[c];\n    num[c] = num[d];\n    num[d] = tmp;\n  }\n\n  void move(int d) {\n    switch(d) {\n    case 0: roll(TOP, SOUTH, BOTTOM, NORTH); break;\n    case 1: roll(TOP, WEST, BOTTOM, EAST);   break;\n    case 2: roll(TOP, NORTH, BOTTOM, SOUTH); break;\n    case 3: roll(TOP, EAST, BOTTOM, WEST);   break;\n    default: assert(false);\n    }\n  }\n};\nbool valid(int x,int y){\n  return x >= 0 && x < 5 && y >= 0 && y < 5;\n}\nvoid dfs(int x,int y,dice &die){\n  \n  die[BOTTOM] = field[y][x];\n  field[y][x] = 0;\n  for(int i =0 ;i < 4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(valid(nx,ny)){\n      if(field[ny][nx]){\n\t\tdie.move(i);\n\t\tdfs(nx,ny,die);\n\t\tdie.move((i+2)%4);\n      }\n    }\n  }\n  \n}\nbool solve(){\n  int cnt[7] = {};\n  for(int i = 0;i < 5;i++){\n    for(int j = 0;j < 5;j++){\n      cin >> field[i][j];\n      cnt[field[i][j]]++;\n    }\n  }\n  for(int i = 1;i <= 6;i++){\n    if(cnt[i] != 1)return false;\n  }\n  dice die;\n  \n  for(int i = 0;i < 5;i++){\n    for(int j = 0;j < 5;j++){\n      if(field[i][j] != 0){\n\t\tdfs(j,i,die);\n\t\tgoto unloop;\n      }\n    }\n  }\nunloop:;\n\n  return die[TOP] + die[BOTTOM] == 7 && die[EAST] + die[WEST] == 7 && die[NORTH] + die[SOUTH] == 7;\n}\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    cout << (solve() ? \"true\" : \"false\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nenum {\n  TOP,\n  BOTTOM,\n  RIGHT,\n  LEFT,\n  FRONT,\n  BACK\n};\n\n\nvoid shift(int &a, int &b, int &c, int &d){\n  int tmp = a; a = b; b = c; c = d; d = tmp;\n}\n\nvoid rotate_x(vector<int> &dice){\n    shift(dice[FRONT], dice[TOP], dice[BACK], dice[BOTTOM]);\n}\n\nvoid rotate_y(vector<int> &dice){\n  shift(dice[RIGHT], dice[TOP], dice[LEFT], dice[BOTTOM]);\n}\n\nbool check(vector<int> &dice){\n  return\n    dice[TOP] + dice[BOTTOM] == 7 &&\n    dice[RIGHT] + dice[LEFT] == 7 &&\n    dice[FRONT] + dice[BACK] == 7;\n}\n\nint mesh[5][5];\n\nvoid dfs(int x, int y, vector<int> &dice){\n  dice[BOTTOM] = mesh[x][y];\n  mesh[x][y] = 0;\n  \n  if (x + 1 < 5 && mesh[x + 1][y]){\n    rotate_x(dice);\n    dfs(x + 1, y, dice);\n    rotate_x(dice);\n    rotate_x(dice);\n    rotate_x(dice);\n  }\n\n  if (x > 0 && mesh[x - 1][y]){\n    rotate_x(dice);\n    rotate_x(dice);\n    rotate_x(dice);\n    dfs(x + 1, y, dice);\n    rotate_x(dice);\n  }\n\n  if (y + 1 < 5 && mesh[x][y + 1]){\n    rotate_y(dice);\n    dfs(x, y + 1, dice);\n    rotate_y(dice);\n    rotate_y(dice);\n    rotate_y(dice);\n  }\n\n  if (y > 0 && mesh[x][y - 1]){\n    rotate_y(dice);\n    rotate_y(dice);\n    rotate_y(dice);\n    dfs(x, y - 1, dice);\n    rotate_y(dice);\n  }\n}\n\nbool solve(){\n  vector<int> dice(6, -1);\n  REP(i, 5) REP(j, 5) if (mesh[i][j] > 0){\n    dfs(i, j, dice);\n    bool is_dice = check(dice);\n    bool is_zero = true;\n    REP(k, 5) REP(l, 5) if (mesh[k][l] > 0) is_zero = false;\n    return is_dice && is_zero;\n  }\n  return false;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while (T--){\n    REP(i, 5) REP(j, 5) cin >> mesh[i][j];\n    if (solve()){\n      cout << \"true\" << endl;\n    } else {\n      cout << \"false\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {0,1,0,-1};\nconst static int ty[] = {-1,0,1,0};\n\nconst static double EPS = 1e-8;\n\nstruct Face {\n  int diff_x;\n  int diff_y;\n  int num;\n  Face(int x,int y,int n)\n    : diff_x(x),diff_y(y),num(n) {}\n};\n\nclass Dice{\n  int top;\n  int left;\n  int right;\n  int bottom;\n  int front;\n  int rear;\npublic:\n  Dice(){\n    top = -1;\n    front = -1;\n    left = -1;\n    bottom = -1;\n    right = -1;\n    rear = -1;\n  }\n  void print(){\n    printf(\"top:%d\\n\",top);\n    printf(\"front:%d\\n\",front);\n    printf(\"left:%d\\n\",left);\n    printf(\"bottom:%d\\n\",bottom);\n    printf(\"right:%d\\n\",right);\n    printf(\"rear:%d\\n\",rear);\n  }\n  bool check(){\n    if(left + right == 7\n       && top + bottom == 7 \n       && front + rear == 7) return true;\n    return false;\n  }\n  void rotateDice(string dir){\n    if(dir == \"north\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = top;\n      int tmp_bottom = front;\n      int tmp_rear = bottom;\n      int tmp_top = rear;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n \n    else if(dir == \"south\"){\n      //top2fr\n      //fr2bot\n      //bot2rear\n      //rear2top\n \n      int tmp_front = bottom;\n      int tmp_bottom = rear;\n      int tmp_rear = top;\n      int tmp_top = front;\n \n      front = tmp_front;\n      bottom = tmp_bottom;\n      rear = tmp_rear;\n      top = tmp_top;\n    }\n    else if(dir == \"west\"){\n      int tmp_bottom = left;\n      int tmp_top = right;\n      int tmp_left = top;\n      int tmp_right = bottom;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n \n    else if(dir == \"east\"){\n      int tmp_bottom = right;\n      int tmp_top = left;\n      int tmp_left = bottom;\n      int tmp_right = top;\n \n      bottom = tmp_bottom;\n      top = tmp_top;\n      left = tmp_left;\n      right = tmp_right;\n    }\n  }\n \n  int tellTop() const{\n    return top;\n  }\n  void writeTop(int t) {\n    top = t;\n  }\n};\n\nint stage[5][5];\nbool visited[5][5];\nconst string dir[] = {\"north\",\"west\",\"south\",\"east\"};\nvoid dfs(int sx,int sy,Dice& d){\n  d.writeTop(stage[sy][sx]);\n  visited[sy][sx] = true;\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    \n    if(dx >= 5 || dx < 0 || dy >= 5 || dy < 0) continue;\n    if(!visited[dy][dx] && stage[dy][dx] != 0){\n      d.rotateDice(dir[i]);\n      dfs(dx,dy,d);\n      d.rotateDice(dir[(i + 2) % 4]);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    for(int i = 0; i < N; i++){\n\n      int start_x = -1;\n      int start_y = -1;\n      int start_num = -1;\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          scanf(\"%d\",&stage[y][x]);\n          if(stage[y][x] != 0){\n            start_x = x;\n            start_y = y;\n            start_num = stage[y][x];\n          }\n        }\n      }\n      memset(visited,false,sizeof(visited));\n      Dice dice;\n      dfs(start_x,start_y,dice);\n\n      bool over = false;\n      bool same = false;\n      int freq[256] = {};\n      for(int y = 0; y < 5; y++){\n        for(int x = 0; x < 5; x++){\n          freq[stage[y][x]]++;\n          if(stage[y][x] != 0 && freq[stage[y][x]] > 1) same = true;\n          if(stage[y][x] != 0\n             && !visited[y][x]){\n            over = true;\n          }\n        }\n      }\n      printf(\"%s\\n\",(dice.check() && !over && !same) ? \"true\" : \"false\");\n      // dice.print();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\nclass Cube{\n    public:\n    int f[6];\n    Cube(){}\n    void roll_y(){ roll(0, 2, 5, 3);}\n    void roll_x(){ roll(0, 1, 5, 4);}\n    void roll(int i, int j, int k, int l){\n\tint t = f[i]; f[i] = f[j]; f[j] = f[k]; f[k] = f[l]; f[l] = t;\n    }\n  \n  bool valid(){\n    bool v[6];\n    rep(i, 6) v[i] = false;\n    rep(i, 6) if ( 1 <= f[i]  && f[i] <= 6 ) v[f[i]-1] = true;\n    rep(i, 6) if ( !v[i] ) return false;\n    return f[0]+f[5]==7 && f[1]+f[4]==7 && f[2]+f[3]==7;\n  }\n};\n\nclass State{\n  public:\n  int pi, pj;\n  Cube cube;\n  State(){}\n  State(int pi, int pj):pi(pi),pj(pj){\n    rep(i, 6) cube.f[i] = -1;\n  }\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    rep(i, 6){\n      if ( cube.f[i] == s.cube.f[i] ) continue;\n      return cube.f[i] < s.cube.f[i];\n    }\n    return false;\n  }\n};\n\nint G[7][7];\nset<State> V;\n\nbool dfs(State u){\n  u.cube.f[5] = G[u.pi][u.pj];\n  if ( u.cube.valid() ) return true;\n  V.insert(u);\n\n  State v;\n  int di[4] = {1, -1, 0, 0};\n  int dj[4] = {0, 0, -1, 1};\n  int dp[4] = {1, 4, 3, 2};\n  rep(r, 4){\n    if ( u.cube.f[dp[r]] == -1 && G[u.pi+di[r]][u.pj+dj[r]] ||\n\t u.cube.f[dp[r]] == G[u.pi+di[r]][u.pj+dj[r]] ){\n      v = u;\n      v.pi += di[r]; v.pj += dj[r];\n      if ( dp[r] == 1 ) rep(i, 3) v.cube.roll_x();\n      if ( dp[r] == 4 ) v.cube.roll_x();\n      if ( dp[r] == 3 ) v.cube.roll_y();\n      if ( dp[r] == 2 ) rep(i, 3) v.cube.roll_y();\n      if ( V.find(v) == V.end() && dfs(v) ) return true;\n    }\n  }\n  return false;\n}\n\nbool valid(vector<int> d){\n  if ( d.size() != 6 ) return false;\n  sort(d.begin(), d.end());\n  rep(i, 6)\n    if ( i+1 != d[i] ) return false;\n  return true;\n}\n\nmain(){\n  int tcase; cin >> tcase;\n  rep(t, tcase){\n    rep(i, 7) rep(j, 7) G[i][j] = 0;\n    int si, sj;\n    vector<int> d;\n    for ( int i = 1; i <= 5; i++ ){\n      for ( int j = 1; j <= 5; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] ) { \n\t  si = i; sj = j; \n\t  d.push_back(G[i][j]);\n\t}\n      }\n    }\n    State s = State(si, sj);\n    V.clear();\n    if ( valid(d) && dfs(s) ) cout << \"true\" << endl;\n    else cout << \"false\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// Aizu 1118: Nets of Dice\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar net[5][5];\nint f[7];\nchar pat[11][3][5] = { \n\t{{1,0,0,0},{2,3,2,3},{1,0,0,0}}, {{1,0,0,0},{2,3,2,3},{0,1,0,0}}, {{1,0,0,0},{2,3,2,3},{0,0,1,0}},\n\t{{1,0,0,0},{2,3,2,3},{0,0,0,1}}, {{0,1,0,0},{2,3,2,3},{0,1,0,0}}, {{0,1,0,0},{2,3,2,3},{0,0,1,0}},\n\t{{1,2,1,0,0},{0,0,3,2,3},{0 }},  {{1,2,0,0},{0,3,1,3},{0,2,0,0}}, {{1,3,0,0},{0,2,1,2},{0,0,3,0}},\n\t{{1,3,0,0},{0,2,1,2},{0,0,0,3}}, {{1,2,0,0},{0,3,1,0},{0,0,2,3}}};\nint spec[11][3] = { {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4},\t{1,3,4}, \n\t\t\t\t\t{1,3,4}, {0,2,5}, {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4} };\n\nvoid rot90()\n{\n\tint r, c; char t[5][5];\n\tfor (r = 0; r < 5; r++) for (c = 0; c < 5; c++) t[r][c] = net[c][4-r];\n\tmemcpy(net, t, sizeof(net));\n}\n\nvoid rev()\n{\n\tint r, c; char t[5][5];\n\tfor (r = 0; r < 5; r++) for (c = 0; c < 5; c++) t[r][c] = net[r][4-c];\n\tmemcpy(net, t, sizeof(net));\n}\n\nint match()\n{\n\tint i, j, r, c, r2, c2, rr, cc, x, y;\n\n\tfor (r = 0; r < 4; r++) for (c = 0; c < 3; c++) {\n\t\tif (!net[r][c]) continue;\n\t\tfor (i = 0; i < 11; i++) {\n\t\t\trr = r, cc = c;\tif (spec[i][0]) if (cc == 0) continue; else cc--;\n\t\t\tif (rr + spec[i][1] > 5 || cc + spec[i][2] > 5) continue;\n\t\t\tmemset(f, 0, sizeof(f));\n\t\t\tfor (y = 0; y < spec[i][1]; y++) for (x = 0; x < spec[i][2]; x++) {\n\t\t\t\tr2 = rr + y, c2 = cc + x;\n\t\t\t\tif (!net[r2][c2] && pat[i][y][x] > 0 ||\n\t\t\t\t\tnet[r2][c2] > 0 && !pat[i][y][x]) goto Next;\n\t\t\t\tf[pat[i][y][x]] += net[r2][c2];\n\t\t\t}\n\t\t\tfor (j = 1; j <= 3; j++) if (f[j] != 7) break;\n\t\t\tif (j > 3) return 1;\n\t\t\tNext:;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint check()\n{\n\tint i;\n\tif (match()) return 1;\n\tfor (i = 0; i < 3; i++) { rot90(); if (match()) return 1; }\n\trot90(), rev();\n\tif (match()) return 1;\n\tfor (i = 0; i < 3; i++) { rot90(); if (match()) return 1; }\n\treturn 0;\n}\n\nint main()\n{\n\tint n, r, c, x;\n\n\tscanf(\"%d\", &n); while (n-- > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tfor (r = 0; r < 5; r++) for (c = 0; c < 5; c++) {\n\t\t\tscanf(\"%d\", &x), net[r][c] = x, f[x]++;\n\t\t}\n\t\tfor (x = 1; x <= 6; x++) if (f[x] != 1) break;\n\t\tif (x <= 6) puts(\"false\");\n\t\telse puts(check() ? \"true\" : \"false\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1118: Nets of Dice\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar net[5][5];\nint f[7];\nchar pat[11][3][5] = { \n\t{{1,0,0,0},{2,3,2,3},{1,0,0,0}}, {{1,0,0,0},{2,3,2,3},{0,1,0,0}}, {{1,0,0,0},{2,3,2,3},{0,0,1,0}},\n\t{{1,0,0,0},{2,3,2,3},{0,0,0,1}}, {{0,1,0,0},{2,3,2,3},{0,1,0,0}}, {{0,1,0,0},{2,3,2,3},{0,0,1,0}},\n\t{{1,2,1,0,0},{0,0,3,2,3},{0 }},  {{1,2,0,0},{0,3,1,3},{0,2,0,0}}, {{1,3,0,0},{0,2,1,2},{0,0,3,0}},\n\t{{1,3,0,0},{0,2,1,2},{0,0,0,3}}, {{1,2,0,0},{0,3,1,0},{0,0,2,3}}};\nint spec[11][3] = { {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4},\t{1,3,4}, \n\t\t\t\t\t{1,3,4}, {0,2,5}, {0,3,4}, {0,3,4}, {0,3,4}, {0,3,4} };\n\nvoid rot90()\n{\n\tint r, c; char t[5][5];\n\tfor (r = 0; r < 5; r++) for (c = 0; c < 5; c++) t[r][c] = net[c][4-r];\n\tmemcpy(net, t, sizeof(net));\n}\n\nvoid rev()\n{\n\tint r, c; char t[5][5];\n\tfor (r = 0; r < 5; r++) for (c = 0; c < 5; c++) t[r][c] = net[r][4-c];\n\tmemcpy(net, t, sizeof(net));\n}\n\nint match()\n{\n\tint i, j, r, c, rr, cc, x, y, r2, c2;\n\tfor (r = 0; r < 4; r++) for (c = 0; c < 2; c++) {\n\t\tif (!net[r][c]) continue;\n\t\tfor (i = 0; i < 11; i++) {\n\t\t\trr = r, cc = c;\tif (spec[i][0]) if (cc == 0) continue; else cc--;\n\t\t\tif (rr + spec[i][1] > 5 || cc + spec[i][2] > 5) continue;\n\t\t\tmemset(f, 0, sizeof(f));\n\t\t\tfor (y = 0; y < spec[i][1]; y++) for (x = 0; x < spec[i][2]; x++) {\n\t\t\t\tr2 = rr + y, c2 = cc + x;\n\t\t\t\tif (!net[r2][c2] && pat[i][y][x] > 0 ||\n\t\t\t\t\tnet[r2][c2] > 0 && !pat[i][y][x]) goto Next;\n\t\t\t\tf[pat[i][y][x]] += net[r2][c2];\n\t\t\t}\n\t\t\tfor (j = 1; j <= 3; j++) if (f[j] != 7) break;\n\t\t\tif (j > 3) return 1;\n\t\t\tNext:;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint check()\n{\n\tint i;\n\tif (match()) return 1;\n\tfor (i = 0; i < 3; i++) { rot90(); if (match()) return 1; }\n\trev(); if (match()) return 1;\n\tfor (i = 0; i < 3; i++) { rot90(); if (match()) return 1; }\n\treturn 0;\n}\n\nint main()\n{\n\tint n, r, c, x;\n\n\tscanf(\"%d\", &n); while (n-- > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tfor (r = 0; r < 5; r++) for (c = 0; c < 5; c++) {\n\t\t\tscanf(\"%d\", &x), net[r][c] = x, f[x]++;\n\t\t}\n\t\tfor (x = 1; x <= 6; x++) if (f[x] != 1) break;\n\t\tif (x <= 6) puts(\"false\");\n\t\telse puts(check() ? \"true\" : \"false\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1118\n  Title:Net of a dice\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint n;\nint net[11][11];\n\n\nvoid search_pos(int me,int *y,int *x)\n{\n  int i,j;\n\n  for(i=3;i<8;i++)\n    for(j=3;j<8;j++)\n      if(net[i][j]==me)\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t}\n}\n\n\nint ck_rel_pos_sub(int y,int x,int y_,int x_)\n{\n  int i,j,ret;\n\n  //printf(\"yxyx=%d %d %d %d\\n\",y,x,y_,x_);\n\n  if(y+2==y_)\n    {\n      for(i=0;i<=3;i++)\n\t{\n\t  if(x_==x+i)\n\t    {\n\t      ret=-1;\n\t      for(j=0;j<=i;j++)\n\t\t{\n\t\t  //printf(\"ck* %d %d:%d\\n\",y+1,x+j,net[y+1][x+j]);\n\t\t  ret &= (net[y+1][x+j]!=0);\n\t\t}\n\t      if(ret)\n\t\treturn(-1);\n\t    }\n\t}\n      for(i=0;i>=-3;i--)\n\t{\n\t  if(x_==x+i)\n\t    {\n\t      ret=-1;\n\t      for(j=0;j>=i;j--)\n\t\t{\n\t\t  //printf(\"ck+ %d %d:%d\\n\",y+1,x+j,net[y+1][x+j]);\n\t\t  ret &= (net[y+1][x+j]!=0);\n\t\t}\n\t      if(ret)\n\t\treturn(-1);\n\t    }\n\t}\n    }\n  return(0);\n}\n\nint ck_rel_pos(int y,int x,int y_,int x_)\n{\n  if(ck_rel_pos_sub(y,x,y_,x_))\n    return(-1);\n  return(ck_rel_pos_sub(x,y,x_,y_));\n}\n\nint solve()\n{\n  int i,ret[7];\n  int posx[7],posy[7];\n\n  for(i=1;i<=6;i++)\n    {\n      search_pos(i,&posy[i],&posx[i]);\n      //printf(\"%d => %d %d\\n\",i,posy[i],posx[i]);\n    }\n \n  for(i=1;i<=6;i++)\n    ret[i]=ck_rel_pos(posy[i],posx[i],posy[7-i],posx[7-i]);\n  /*\n for(i=1;i<=6;i++)\n   printf(\"[%d]%d|\",i,ret[i]);\n printf(\"\\n\");\n  */\n  return((ret[1]||ret[6]) && (ret[2]||ret[5]) && (ret[3]||ret[4]));\n}\nmain()\n{\n  int i,j,k,ret;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      memset(&net[0][0],0,11*11);\n      \n      for(j=0;j<5;j++)\n\tfor(k=0;k<5;k++)\n\t  scanf(\"%d\",&net[j+3][k+3]);\n\t\n      /*\n      for(j=0;j<5;j++)\n\t{\n\t  for(k=0;k<5;k++)\n\t    printf(\"%d\",net[j+3][k+3]);\n\t  printf(\"\\n\");\n\t}\n      */\n      ret=solve();\n      printf(\"%s\\n\",ret?\"true\":\"false\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1118\n  Title:Net of a dice\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define mysign(x) (((x)>0)?1:(-1))\n#define myabs(x)  (((x)>0)?(x):(-(x)))\nint n;\nint net[11][11];\n\n\nvoid search_pos(int me,int *y,int *x)\n{\n  int i,j;\n\n  for(i=3;i<8;i++)\n    for(j=3;j<8;j++)\n      if(net[i][j]==me)\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t}\n  *x=*y=-1;\n}\n/*\n  check relative position of dice whose added value is 7. \n\n   1  1   1   1    1*6 1*  1*  1*\n   *  **  *** ****      *6  *   *\n   6   6    6    6          *6  * \n                                *6\n\n   where * is 2,3,4,5\n */\nint ck_rel_pos(int y,int x,int y_,int x_)\n{\n  int i,j,ret;\n#ifdef DEBUG\n  printf(\"yxyx=%d %d %d %d\\n\",y,x,y_,x_);\n#endif\n  if(y+2==y_)\n    {\n      for(i=-3;i<=3;i++)\n\t{\n\t  if(x_==x+i)\n\t    {\n\t      ret=-1;\n\t      for(j=0;myabs(j)<=myabs(i);j+=mysign(i))\n\t\t{\n#ifdef DEBUG\n\t\t  printf(\"ck* %d %d:%d\\n\",y+1,x+j,net[y+1][x+j]);\n#endif\n\t\t  ret &= (net[y+1][x+j]!=0);\n\t\t}\n\t      if(ret)\n\t\treturn(-1);\n\t    }\n\t}\n    }\n  if(x+2==x_)\n    {\n      for(i=-3;i<=3;i++)\n\t{\n\t  if(y_==y+i)\n\t    {\n\t      ret=-1;\n\t      for(j=0;myabs(j)<=myabs(i);j+=mysign(i))\n\t\t{\n#ifdef DEBUG\n\t\t  printf(\"ck: %d %d:%d\\n\",y+j,x+1,net[y+j][x+1]);\n#endif\n\t\t  ret &= (net[y+j][x+1]!=0);\n\t\t}\n\t      if(ret)\n\t\treturn(-1);\n\t    }\n\t}\n     }\n  return(0);\n}\n\nint count_dice()\n{\n  int i,j,ret;\n\n  ret=0;\n  for(i=3;i<8;i++)\n    for(j=3;j<8;j++)\n      if(net[i][j])\n\tret++;\n  return(ret);\n}\n\n\nint solve()\n{\n  int i,ret[7];\n  int posx[7],posy[7];\n\n  if(count_dice()!=6)\n    return(0);\n\n  for(i=1;i<=6;i++)\n    {\n      search_pos(i,&posy[i],&posx[i]);\n      if(posy[i]==-1)\n\treturn(0);\n    }\n  for(i=1;i<=6;i++)\n    ret[i]=ck_rel_pos(posy[i],posx[i],posy[7-i],posx[7-i]);\n #ifdef DEBUG2\n for(i=1;i<=6;i++)\n   printf(\"[%d]%d|\",i,ret[i]);\n printf(\"\\n\");\n #endif\n  return((ret[1]||ret[6]) && (ret[2]||ret[5]) && (ret[3]||ret[4]));\n}\nmain()\n{\n  int i,j,k,ret;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      memset(&net[0][0],0,11*11);\n      \n      for(j=0;j<5;j++)\n\tfor(k=0;k<5;k++)\n\t  scanf(\"%d\",&net[j+3][k+3]);\n\n      ret=solve();\n      printf(\"%s\\n\",ret?\"true\":\"false\");\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define mysign(x) (((x)>0)?1:(-1))\n#define myabs(x)  (((x)>0)?(x):(-(x)))\nint n;\nint net[11][11];\n\n\nvoid search_pos(int me,int *y,int *x)\n{\n  int i,j;\n\n  for(i=3;i<8;i++)\n    for(j=3;j<8;j++)\n      if(net[i][j]==me)\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t}\n  *x=*y=-1;\n}\n\nint ck_rel_pos(int y,int x,int y_,int x_)\n{\n  int i,j,r;\n\n  if(y+2==y_)\n    for(i=-3;i<=3;i++)\n      if(x_==x+i)\n\t    {\n\t      r=-1;\n\t      for(j=0;myabs(j)<=myabs(i);j+=mysign(i))\n\t\t  r &= (net[y+1][x+j]!=0);\n\n\t      if(r)\n\t\treturn(r);\n\t    }\n  if(x+2==x_)\n    for(i=-3;i<=3;i++)\n      if(y_==y+i)\n\t    {\n\t      r=-1;\n\t      for(j=0;myabs(j)<=myabs(i);j+=mysign(i))\n\t\t{\n\t\t  r &= (net[y+j][x+1]!=0);\n\t\t}\n\t      if(r)\n\t\treturn(r);\n\t    }\n  return(0);\n}\n\nint count_dice()\n{\n  int i,j,r=0;\n  for(i=3;i<8;i++)\n    for(j=3;j<8;j++)\n      if(net[i][j])\n\tr++;\n  return(r);\n}\n\n\nint solve()\n{\n  int i,r[7];\n  int px[7],py[7];\n\n  if(count_dice()!=6)\n    return(0);\n\n  for(i=1;i<=6;i++)\n    {\n      search_pos(i,&py[i],&px[i]);\n      if(py[i]==-1)\n\treturn(0);\n    }\n  for(i=1;i<=6;i++)\n    r[i]=ck_rel_pos(py[i],px[i],py[7-i],px[7-i]);\n  return((r[1]||r[6]) && (r[2]||r[5]) && (r[3]||r[4]));\n}\nmain()\n{\n  int i,j,k,ret;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      memset(&net[0][0],0,11*11);\n      \n      for(j=0;j<5;j++)\n\tfor(k=0;k<5;k++)\n\t  scanf(\"%d\",&net[j+3][k+3]);\n\n      ret=solve();\n      printf(\"%s\\n\",ret?\"true\":\"false\");\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint T;\n\tfinal int n=5;\n\tint[][] a;\n\n\tvoid run(){\n\t\tT=sc.nextInt();\n\t\tfor(int k=0; k<T; k++){\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t\tprintln(yes+\"\");\n\t\t}\n\t}\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\n\t\tP add(P p){\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tboolean yes;\n\n\tvoid solve(){\n\t\tP[] ps=new P[6];\n\t\tyes=true;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(a[j][i]!=0){\n\t\t\t\t\tif(ps[a[j][i]-1]!=null){\n\t\t\t\t\t\tyes=false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tps[a[j][i]-1]=new P(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<6; i++){\n\t\t\tif(ps[i]==null){\n\t\t\t\tyes=false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// 1~6ツつェ6ツづ?\n\t\t// ツ連ツ個仰青ォ\n\t\tint[][] w=new int[6][6];\n\t\tfor(int j=0; j<6; j++){\n\t\t\tfor(int i=0; i<j; i++){\n\t\t\t\tif(abs(ps[i].x-ps[j].x)+abs(ps[i].y-ps[j].y)==1){\n\t\t\t\t\tw[i][j]=w[j][i]=0;\n\t\t\t\t}else{\n\t\t\t\t\tw[i][j]=w[j][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw[j][j]=0;\n\t\t}\n\t\tfor(int k=0; k<6; k++){\n\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\tfor(int j=0; j<6; j++){\n\t\t\t\t\tw[i][j]=min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean connected=true;\n\t\tfor(int j=0; j<6; j++){\n\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\tconnected&=w[i][j]==0;\n\t\t\t}\n\t\t}\n\t\t// debug(\"connected\", connected);\n\t\tif(!connected){\n\t\t\tyes=false;\n\t\t\treturn;\n\t\t}\n\t\t// ツ連ツ個仰つセツつィ\n\n\t\tArrayList<P>[] lists=new ArrayList[7];\n\n\t\tfor(int i=0; i<7; i++){\n\t\t\tlists[i]=new ArrayList<P>();\n\t\t}\n\n\t\tlists[0].add(new P(1, 0));\n\t\tlists[0].add(new P(2, 0));\n\n\t\tfor(int j=1; j<7; j++){\n\t\t\tint len=(j+1)/2;\n\t\t\tlists[j].add(new P(1, 0));\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tlists[j].add(new P(1, i));\n\t\t\t\t}else{\n\t\t\t\t\tlists[j].add(new P(1, -i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tlists[j].add(new P(2, len));\n\t\t\t}else{\n\t\t\t\tlists[j].add(new P(2, -len));\n\t\t\t}\n\t\t\t// debug(lists[j]);\n\t\t}\n\n\t\tfor(int i=0; i<6; i++){\n\t\t\tP p=ps[i];\n\t\t\tArrayList<P> os=new ArrayList<P>();\n\t\t\tfor(ArrayList<P> list : lists){\n\t\t\t\t// debug(\"list\", list);\n\t\t\t\tfor(int rot=0; rot<4; rot++){\n\t\t\t\t\t// debug(\"rot\", rot);\n\t\t\t\t\t// listツづ罫otツづ可づつつ「ツづ?\n\t\t\t\t\tP last=null;\n\t\t\t\t\tboolean ok=true;\n\t\t\t\t\tfor(int k=0; k<list.size(); k++){\n\t\t\t\t\t\tP q=ps[i].add(rot(list.get(k), rot));\n\t\t\t\t\t\t// debug(\"k\", k, q);\n\t\t\t\t\t\tif(q.x>=0&&q.x<n&&q.y>=0&&q.y<n&&a[q.y][q.x]!=0){\n\t\t\t\t\t\t\tif(k==list.size()-1){\n\t\t\t\t\t\t\t\tlast=q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tos.add(last);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(i, p, os);\n\t\t\tif(os.size()==1){\n\t\t\t\tP q=os.get(0);\n\t\t\t\tif(a[p.y][p.x]+a[q.y][q.x]==7){}else{\n\t\t\t\t\tyes=false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tyes=false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tP rot(P p, int rot){\n\t\tif(rot==0){\n\t\t\treturn new P(p.x, p.y);\n\t\t}else if(rot==1){\n\t\t\treturn new P(-p.y, p.x);\n\t\t}else if(rot==2){\n\t\t\treturn new P(-p.x, -p.y);\n\t\t}else{\n\t\t\treturn new P(p.y, -p.x);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic boolean debug = false;\n\tstatic int[][] floor = new int[5][5];\n\tstatic int[][] ceil = new int[5][5];\n\t\n\tstatic int[][] horizontal = new int[5][6]; //x = 3 means on left of tile x=3\n\tstatic int[][] vertical = new int[6][5]; //y = 3 means on top of tile y=3\n\t\n\tstatic boolean overlapped;\n\t\n\tstatic int lastx;\n\tstatic int lasty;\n\t\n\tstatic void mapOut()\n\t{\n\t\tif(!debug) {return;}\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 5; x++)\n\t\t\t{\n\t\t\t\tif(x < 5 && horizontal[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\" -\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"  \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\n\t\t\tfor(int x = 0; x <= 5; x++)\n\t\t\t{\n\t\t\t\tif(y < 5 && vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < 5 && y < 5)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(floor[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void overlap()\n\t{\n\t\tif(debug)System.out.println(\"OVERLAP\");\n\t\toverlapped = true;\n\t}\n\t\n\tstatic void foldHRight(int x, int y) //floor x and y\n\t{\n\t\tlastx = x+1;\n\t\tlasty = y;\n\t\t//ignore the would-be-overlap right\n\t\tif(debug)System.out.println(\"Folding h-right \" + x + \" \" + y);\n\t\t\n\t\t//bottom\n\t\tif(horizontal[x][y+1] > 0)\n\t\t{\n\t\t\tif(vertical[x+2][y] > 0) {overlap(); return;}\n\t\t\tvertical[x+2][y] = horizontal[x][y+1];\n\t\t\thorizontal[x][y+1] = 0;\n\t\t}\n\t\t\n\t\t//left\n\t\tif(vertical[x][y] > 0)\n\t\t{\n\t\t\tif(horizontal[x+1][y+1] > 0) {overlap(); return;}\n\t\t\thorizontal[x+1][y+1] = vertical[x][y];\n\t\t\tvertical[x][y] = 0;\n\t\t}\n\t\t\n\t\t//top\n\t\tif(horizontal[x][y] > 0)\n\t\t{\n\t\t\tif(vertical[x+1][y] > 0) {overlap(); return;}\n\t\t\tvertical[x+1][y] = horizontal[x][y];\n\t\t\thorizontal[x][y] = 0;\n\t\t}\n\n\t\t//floor\n\t\tif(floor[x][y] > 0)\n\t\t{\n\t\t\tif(floor[x+1][y] > 0) {overlap();return;}\n\t\t\tfloor[x+1][y] = floor[x][y];\n\t\t\tfloor[x][y] = 0;\n\t\t}\n\n\t\t//ceil\n\t\tif(ceil[x][y] > 0)\n\t\t{\n\t\t\tif(ceil[x+1][y] > 0) {overlap();return;}\n\t\t\tceil[x+1][y] = ceil[x][y];\n\t\t\tceil[x][y] = 0;\n\t\t}\n\t}\n\t\n\tstatic void foldHDown(int x, int y) //floor x and y\n\t{\n\t\tlastx = x;\n\t\tlasty = y+1;\n\t\t//ignore the would-be-overlap down\n\t\tif(debug)System.out.println(\"Folding h-down \" + x + \" \" + y + \", roof \" + ceil[x][y]);\n\t\t\n\t\t//right\n\t\tif(vertical[x+1][y] > 0)\n\t\t{\n\t\t\tif(horizontal[x][y+1] > 0) {overlap(); return;}\n\t\t\thorizontal[x][y+1] = vertical[x+1][y];\n\t\t\tvertical[x+1][y] = 0;\n\t\t}\n\t\t\n\t\t//left\n\t\tif(vertical[x][y] > 0)\n\t\t{\n\t\t\tif(horizontal[x+1][y+2] > 0) {overlap(); return;}\n\t\t\thorizontal[x][y+2] = vertical[x][y];\n\t\t\tvertical[x][y] = 0;\n\t\t}\n\t\t\n\t\t//top\n\t\tif(horizontal[x][y] > 0)\n\t\t{\n\t\t\tif(vertical[x][y] > 0) {overlap(); return;}\n\t\t\tvertical[x][y+1] = horizontal[x][y];\n\t\t\thorizontal[x][y] = 0;\n\t\t}\n\n\t\t//floor\n\t\tif(floor[x][y] > 0)\n\t\t{\n\t\t\tif(floor[x][y+1] > 0) {overlap();return;}\n\t\t\tfloor[x][y+1] = floor[x][y];\n\t\t\tfloor[x][y] = 0;\n\t\t}\n\n\t\t//ceil\n\t\tif(ceil[x][y] > 0)\n\t\t{\n\t\t\tif(ceil[x][y+1] > 0) {overlap();return;}\n\t\t\tceil[x][y+1] = ceil[x][y];\n\t\t\tceil[x][y] = 0;\n\t\t}\n\t}\n\t\n\tstatic void ceilFoldRight(int foldx)\n\t{\n\t\t//DISINI\n\t\tif(debug)System.out.println(\"Folding ceil right \" + foldx);\n\t\t//in other words, we assume use of the method that we start the right-folding from the left.\n\t\tlastx = foldx;\n\t\t\n\t\tint x = foldx - 1;\n\t\t\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tif(y <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && vertical[x+2][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+2][y] = floor[x][y];\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(ceil[x][y] != 0 && vertical[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+1][y] = ceil[x][y];\n//\t\t\t\t\tif(vertical[x+2][y] != 0) {System.out.println(\"fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//vertical... we're currently ignoring the vertical to the right which would cause overlap.\n\t\t\t\tif(vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(vertical[x][y] != 0 && floor[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tfloor[x+1][y] = vertical[x][y];\n//\t\t\t\t\tif(vertical[x][y] != 0) {System.out.println(\"newceil from ver \" + x + \" \" + y);}\n\t\t\t\t\tvertical[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//horizontal\n\t\t\tif(horizontal[x][y] != 0 && horizontal[x+1][y] != 0) {overlap();return;}\n\t\t\tif(horizontal[x][y] > 0)\n\t\t\t{\n\t\t\t\thorizontal[x+1][y] = horizontal[x][y];\n\t\t\t\thorizontal[x][y] = 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tstatic void foldRight(int foldx) //vertical-line.\n\t{ //we can assume that we're only folding foldx-1, the ones left to that are already folded to right.\n\t\tif(debug)System.out.println(\"Folding right \" + foldx);\n\t\t//in other words, we assume use of the method that we start the right-folding from the left.\n\t\tlastx = foldx;\n\t\t\n\t\tint x = foldx - 1;\n\t\t\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tif(y <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && vertical[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+1][y] = floor[x][y];\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(ceil[x][y] != 0 && vertical[x+2][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+2][y] = ceil[x][y];\n//\t\t\t\t\tif(vertical[x+2][y] != 0) {System.out.println(\"fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//vertical... we're currently ignoring the vertical to the right which would cause overlap.\n\t\t\t\tif(vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(vertical[x][y] != 0 && ceil[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tceil[x+1][y] = vertical[x][y];\n//\t\t\t\t\tif(vertical[x][y] != 0) {System.out.println(\"newceil from ver \" + x + \" \" + y);}\n\t\t\t\t\tvertical[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//horizontal\n\t\t\tif(horizontal[x][y] > 0)\n\t\t\t{\n\t\t\t\tif(horizontal[x][y] != 0 && horizontal[x+1][y] != 0) {overlap();return;}\n\t\t\t\thorizontal[x+1][y] = horizontal[x][y];\n\t\t\t\thorizontal[x][y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void foldDown(int foldy) //horizontal-line.\n\t{ //we can assume that we're only folding foldy-1, the ones up to that are already folded to down.\n\t\tif(debug)System.out.println(\"Folding down \" + foldy);\n\t\t//in other words, we assume use of the method that we start the down-folding from the top.\n\t\tlasty = foldy;\n\t\t\n\t\tint y = foldy - 1;\n\t\t\n\t\tfor(int x = 0; x <= 5; x++)\n\t\t{\n\t\t\tif(x <= 4)\n\t\t\t{\n\n\t\t\t\t//that one\n\t\t\t\tif(horizontal[x][y+1] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(horizontal[x][y+1] != 0 && floor[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\tif(debug)System.out.println(\"wanna do \" + x + \" \" + y);\n\t\t\t\t\tfloor[x][y+1] = horizontal[x][y+1];\n\t\t\t\t\thorizontal[x][y+1] = 0;\n\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && horizontal[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\thorizontal[x][y+1] = floor[x][y];\n\t//\t\t\t\tif(floor[x][y] > 0) {System.out.println(\"Fromfloor \" + x + \" \" + y);}\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y]>0)\n\t\t\t\t{\n//\t\t\t\t\tif(x == 2 && y == 1) {System.out.println(\"Ceil: \" + ceil[2][1]);}\n\t\t\t\t\tif(ceil[x][y] != 0 && horizontal[x][y+2] != 0) {overlap();return;}\n\t\t\t\t\thorizontal[x][y+2] = ceil[x][y];\n\t\t\t\t\tif(debug && ceil[x][y] > 0) {System.out.println(\"Fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t//horizontal ignoring the one-to-the-down one\n\t\t\t\tif(horizontal[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(horizontal[x][y] != 0 && ceil[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\tceil[x][y+1] = horizontal[x][y];\n\t\t\t\t\tif(debug && horizontal[x][y] > 0) {System.out.println(\"Newceilfrom h \" + x + \" \" + y + \": \" + ceil[x][y+1] + \" at \" + x + \" \" + (y+1));}\n\t\t\t\t\thorizontal[x][y] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//vertical\n\t\t\tif(vertical[x][y] > 0)\n\t\t\t{\n\t\t\t\tif(vertical[x][y] != 0 && vertical[x][y+1] != 0) {overlap();return;}\n\t\t\t\tvertical[x][y+1] = vertical[x][y];\n\t\t\t\tvertical[x][y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint n;\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tn = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\toverlapped = false;\n\t\t\tfloor = new int[5][5];\n\t\t\tceil = new int[5][5];\n\t\t\t\n\t\t\thorizontal = new int[5][6];\n\t\t\tvertical = new int[6][5];\n\t\t\t\n\t\t\tboolean[] numberappeared = new boolean[6];\n\t\t\tint appearednums = 0;\n\t\t\t\n\t\t\tboolean preout = false;\n\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t{\n\t\t\t\t\tfloor[x][y] = scan.nextInt();\n\t\t\t\t\tif(floor[x][y] < 0 || floor[x][y] > 6) \n\t\t\t\t\t{\n\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(floor[x][y] != 0) //valid non-zero number\n\t\t\t\t\t{\n\t\t\t\t\t\tif(numberappeared[floor[x][y]-1])\n\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(floor[x][y] + \" already appeared\");\n\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnumberappeared[floor[x][y]-1] = true;\n\t\t\t\t\t\tappearednums += 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(appearednums > 6) {preout = true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(preout)\n\t\t\t{\n//\t\t\t\tSystem.out.println(\"PRE OUT\");\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint curX = 0;\n\t\t\tboolean xfolding = true;\n\t\t\tboolean foldedxh;\n\t\t\tint xfoldtimes = 0;\n\t\t\t\n\t\t\tfor(curX = 0; curX < 5; curX++)\n\t\t\t{\n\t\t\t\tif(overlapped) {break;}\n\t\t\t\t\n\t\t\t\txfolding = false;\n\t\t\t\tfoldedxh = false;\n\t\t\t\t\n\t\t\t\t//check for vertically-connected floors\n\t\t\t\tboolean prev = false;\n\t\t\t\tboolean prev2 = false;\n\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t{\n\t\t\t\t\tif(floor[curX][ty] > 0)\n\t\t\t\t\t{\n//\t\t\t\t\t\tif(prev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int iy = 1; iy <= ty; iy++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//if there's anything to fold here, fold\n\t\t\t\t\t\t\t\tboolean doit = false;\n\t\t\t\t\t\t\t\tfor(int ttx = 0; ttx <= 4; ttx++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(floor[ttx][iy-1] > 0 && floor[ttx][iy] > 0) //DISINI YG -1\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdoit = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(floor[ttx][iy-1] <= 0)\n\t\t\t\t\t\t\t\t\t\t{\n//\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"WEIRD \" + ttx + \" \" + (iy-1));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(doit)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfoldDown(iy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = true;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\tif(vertical[curX+1][ty] > 0)\n\t\t\t\t\t{\n//\t\t\t\t\t\tif(prev2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int iy = 1; iy <= ty; iy++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//if there's anything to fold here, fold\n\t\t\t\t\t\t\t\tboolean doit2 = false;\n\t\t\t\t\t\t\t\tint lex = 0;\n\t\t\t\t\t\t\t\tfor(int ttx = 1; ttx <= 4; ttx++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(vertical[ttx+1][iy-1] > 0 && vertical[ttx+1][iy] > 0) //DISINI YG -1\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlex = ttx;\n\t\t\t\t\t\t\t\t\t\tdoit2 = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(doit2)\n\t\t\t\t\t\t\t\t{\nif(debug)\t\t\t\t\t\t\t\t\tSystem.out.println(\"DOOO \" + lex + \" \" + ty);\n\t\t\t\t\t\t\t\t\tfoldHDown(lex, iy-1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev2 = true;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev = false;\n\t\t\t\t\t}\t\t\t\t\t\n\n\t\t\t\t\t//\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t{\n\t\t\t\t\tif(floor[curX][ty] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if it's a floor, also check for connections to next x, for the next x-folding\n\t\t\t\t\t\tif(curX < 4 && floor[curX+1][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"Can FR from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\txfolding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(xfolding && curX < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\tfoldRight(curX+1);\n\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\tmapOut();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//cheese h-bar\n\t\t\t\t{\n\t\t\t\t\tif(floor[lastx][lasty] > 0 && horizontal[lastx][lasty] > 0 && horizontal[lastx][lasty+1] > 0 && vertical[lastx][lasty] > 0 && vertical[lastx+1][lasty] == 0 && ceil[lastx][lasty] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(lastx <= 3 && horizontal[lastx+1][lasty+1] > 0 && vertical[lastx+1][lasty] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug) {System.out.println(\"CHEESE\");}\n\t\t\t\t\t\t\tvertical[lastx+1][lasty] = horizontal[lastx+1][lasty+1];\n\t\t\t\t\t\t\thorizontal[lastx+1][lasty+1] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n//\t\t\t\t\t\tif(debug)System.out.println(\"No cheese \" + lastx + \" \" + lasty + \" ceil \" + ceil[lastx][lasty]);\n\t\t\t\t\t}\n\t\t\t\t}\t\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(xfolding == false && curX < 4) //check for XH folding\n\t\t\t\t{\n\t\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(horizontal[curX][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//if it's has a top, also check for connections to next top\n\t\t\t\t\t\t\tif(curX < 4 && horizontal[curX+1][ty] > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"Can FHHHHR from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\t\txfolding = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xfolding && curX < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\t\tfoldHRight(curX,ty);\n\t\t\t\t\t\t\tfoldedxh = true;\n\t\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\telse if(foldedxh == false)\n\t\t\t\t{\n\t\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ceil[curX][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//if it has a ceil, also check for connections to next ceil\n\t\t\t\t\t\t\tif(curX < 4 && ceil[curX+1][ty] > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"Can CCCCC from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\t\t\tceilFoldRight(curX+1);\n\t\t\t\t\t\t\t\tfoldedxh = true;\n\t\t\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t//ceilFoldRight\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean ans;\n\t\t\tif(overlapped)\n\t\t\t{\n\t\t\t\tans = false;\n//\t\t\t\tSystem.out.println(\"overlapped\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(floor[lastx][lasty] > 0 && horizontal[lastx][lasty] > 0 && horizontal[lastx][lasty+1] > 0 && vertical[lastx][lasty] > 0 && vertical[lastx+1][lasty] > 0 && ceil[lastx][lasty] > 0)\n\t\t\t\t{\n\t\t\t\t\tint f = floor[lastx][lasty];\n\t\t\t\t\tint c = ceil[lastx][lasty];\n\t\t\t\t\tint l = horizontal[lastx][lasty];\n\t\t\t\t\tint r = horizontal[lastx][lasty+1];\n\t\t\t\t\tint u = vertical[lastx][lasty];\n\t\t\t\t\tint d = vertical[lastx+1][lasty];\n\t\t\t\t\t\n\t\t\t\t\tif(f + c == 7 && l + r == 7 && u + d == 7)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\nif(debug)\t\t\t\t\t\tSystem.out.println(\"sum\");\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"hole\");\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\nif(debug)\t\t\tSystem.out.println(\"FIN. x = \" + lastx + \", y = \" + lasty + \" roof \" + ceil[lastx][lasty]);\n//\t\t\tSystem.out.println(ceil[lastx+1][lasty]);\n//\t\t\tboolean ans = ;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\nimport org.omg.PortableInterceptor.SYSTEM_EXCEPTION;\n\npublic class Main \n{\n\tstatic boolean debug = false;\n\tstatic int[][] floor = new int[5][5];\n\tstatic int[][] ceil = new int[5][5];\n\t\n\tstatic int[][] horizontal = new int[5][6]; //x = 3 means on left of tile x=3\n\tstatic int[][] vertical = new int[6][5]; //y = 3 means on top of tile y=3\n\t\n\tstatic boolean overlapped;\n\t\n\tstatic int lastx;\n\tstatic int lasty;\n\t\n\tstatic void mapOut()\n\t{\n\t\tif(!debug) {return;}\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 5; x++)\n\t\t\t{\n\t\t\t\tif(x < 5 && horizontal[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\" -\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"  \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\n\t\t\tfor(int x = 0; x <= 5; x++)\n\t\t\t{\n\t\t\t\tif(y < 5 && vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < 5 && y < 5)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(floor[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void overlap()\n\t{\n\t\tif(debug)System.out.println(\"OVERLAP\");\n\t\toverlapped = true;\n\t}\n\t\n\tstatic void foldHRight(int x, int y) //floor x and y\n\t{\n\t\tlastx = x+1;\n\t\tlasty = y;\n\t\t//ignore the would-be-overlap right\n\t\tif(debug)System.out.println(\"Folding h-right \" + x + \" \" + y);\n\t\t\n\t\t//bottom\n\t\tif(horizontal[x][y+1] > 0)\n\t\t{\n\t\t\tif(vertical[x+2][y] > 0) {overlap(); return;}\n\t\t\tvertical[x+2][y] = horizontal[x][y+1];\n\t\t\thorizontal[x][y+1] = 0;\n\t\t}\n\t\t\n\t\t//left\n\t\tif(vertical[x][y] > 0)\n\t\t{\n\t\t\tif(horizontal[x+1][y+1] > 0) {overlap(); return;}\n\t\t\thorizontal[x+1][y+1] = vertical[x][y];\n\t\t\tvertical[x][y] = 0;\n\t\t}\n\t\t\n\t\t//top\n\t\tif(horizontal[x][y] > 0)\n\t\t{\n\t\t\tif(vertical[x+1][y] > 0) {overlap(); return;}\n\t\t\tvertical[x+1][y] = horizontal[x][y];\n\t\t\thorizontal[x][y] = 0;\n\t\t}\n\n\t\t//floor\n\t\tif(floor[x][y] > 0)\n\t\t{\n\t\t\tif(floor[x+1][y] > 0) {overlap();return;}\n\t\t\tfloor[x+1][y] = floor[x][y];\n\t\t\tfloor[x][y] = 0;\n\t\t}\n\n\t\t//ceil\n\t\tif(ceil[x][y] > 0)\n\t\t{\n\t\t\tif(ceil[x+1][y] > 0) {overlap();return;}\n\t\t\tceil[x+1][y] = ceil[x][y];\n\t\t\tceil[x][y] = 0;\n\t\t}\n\t}\n\t\n\tstatic void ceilFoldRight(int foldx)\n\t{\n\t\t//DISINI\n\t\tif(debug)System.out.println(\"Folding ceil right \" + foldx);\n\t\t//in other words, we assume use of the method that we start the right-folding from the left.\n\t\tlastx = foldx;\n\t\t\n\t\tint x = foldx - 1;\n\t\t\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tif(y <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && vertical[x+2][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+2][y] = floor[x][y];\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(ceil[x][y] != 0 && vertical[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+1][y] = ceil[x][y];\n//\t\t\t\t\tif(vertical[x+2][y] != 0) {System.out.println(\"fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//vertical... we're currently ignoring the vertical to the right which would cause overlap.\n\t\t\t\tif(vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(vertical[x][y] != 0 && floor[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tfloor[x+1][y] = vertical[x][y];\n//\t\t\t\t\tif(vertical[x][y] != 0) {System.out.println(\"newceil from ver \" + x + \" \" + y);}\n\t\t\t\t\tvertical[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//horizontal\n\t\t\tif(horizontal[x][y] != 0 && horizontal[x+1][y] != 0) {overlap();return;}\n\t\t\tif(horizontal[x][y] > 0)\n\t\t\t{\n\t\t\t\thorizontal[x+1][y] = horizontal[x][y];\n\t\t\t\thorizontal[x][y] = 0;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n\tstatic void foldRight(int foldx) //vertical-line.\n\t{ //we can assume that we're only folding foldx-1, the ones left to that are already folded to right.\n\t\tif(debug)System.out.println(\"Folding right \" + foldx);\n\t\t//in other words, we assume use of the method that we start the right-folding from the left.\n\t\tlastx = foldx;\n\t\t\n\t\tint x = foldx - 1;\n\t\t\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tif(y <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && vertical[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+1][y] = floor[x][y];\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(ceil[x][y] != 0 && vertical[x+2][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+2][y] = ceil[x][y];\n//\t\t\t\t\tif(vertical[x+2][y] != 0) {System.out.println(\"fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//vertical... we're currently ignoring the vertical to the right which would cause overlap.\n\t\t\t\tif(vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(vertical[x][y] != 0 && ceil[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tceil[x+1][y] = vertical[x][y];\n//\t\t\t\t\tif(vertical[x][y] != 0) {System.out.println(\"newceil from ver \" + x + \" \" + y);}\n\t\t\t\t\tvertical[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//horizontal\n\t\t\tif(horizontal[x][y] > 0)\n\t\t\t{\n\t\t\t\tif(horizontal[x][y] != 0 && horizontal[x+1][y] != 0) {overlap();return;}\n\t\t\t\thorizontal[x+1][y] = horizontal[x][y];\n\t\t\t\thorizontal[x][y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void foldDown(int foldy) //horizontal-line.\n\t{ //we can assume that we're only folding foldy-1, the ones up to that are already folded to down.\n\t\tif(debug)System.out.println(\"Folding down \" + foldy);\n\t\t//in other words, we assume use of the method that we start the down-folding from the top.\n\t\tlasty = foldy;\n\t\t\n\t\tint y = foldy - 1;\n\t\t\n\t\tfor(int x = 0; x <= 5; x++)\n\t\t{\n\t\t\tif(x <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && horizontal[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\thorizontal[x][y+1] = floor[x][y];\n\t//\t\t\t\tif(floor[x][y] > 0) {System.out.println(\"Fromfloor \" + x + \" \" + y);}\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y]>0)\n\t\t\t\t{\n//\t\t\t\t\tif(x == 2 && y == 1) {System.out.println(\"Ceil: \" + ceil[2][1]);}\n\t\t\t\t\tif(ceil[x][y] != 0 && horizontal[x][y+2] != 0) {overlap();return;}\n\t\t\t\t\thorizontal[x][y+2] = ceil[x][y];\n\t\t\t\t\tif(debug && ceil[x][y] > 0) {System.out.println(\"Fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//horizontal ignoring the one-to-the-down one\n\t\t\t\tif(horizontal[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(horizontal[x][y] != 0 && ceil[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\tceil[x][y+1] = horizontal[x][y];\n\t\t\t\t\tif(debug && horizontal[x][y] > 0) {System.out.println(\"Newceilfrom h \" + x + \" \" + y + \": \" + ceil[x][y+1] + \" at \" + x + \" \" + (y+1));}\n\t\t\t\t\thorizontal[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//vertical\n\t\t\tif(vertical[x][y] > 0)\n\t\t\t{\n\t\t\t\tif(vertical[x][y] != 0 && vertical[x][y+1] != 0) {overlap();return;}\n\t\t\t\tvertical[x][y+1] = vertical[x][y];\n\t\t\t\tvertical[x][y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint n;\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tn = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\toverlapped = false;\n\t\t\tfloor = new int[5][5];\n\t\t\tceil = new int[5][5];\n\t\t\t\n\t\t\thorizontal = new int[5][6];\n\t\t\tvertical = new int[6][5];\n\t\t\t\n\t\t\tboolean[] numberappeared = new boolean[6];\n\t\t\tint appearednums = 0;\n\t\t\t\n\t\t\tboolean preout = false;\n\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t{\n\t\t\t\t\tfloor[x][y] = scan.nextInt();\n\t\t\t\t\tif(floor[x][y] < 0 || floor[x][y] > 6) \n\t\t\t\t\t{\n\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(floor[x][y] != 0) //valid non-zero number\n\t\t\t\t\t{\n\t\t\t\t\t\tif(numberappeared[floor[x][y]-1])\n\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(floor[x][y] + \" already appeared\");\n\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnumberappeared[floor[x][y]-1] = true;\n\t\t\t\t\t\tappearednums += 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(appearednums > 6) {preout = true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(preout)\n\t\t\t{\n//\t\t\t\tSystem.out.println(\"PRE OUT\");\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint curX = 0;\n\t\t\tboolean xfolding = true;\n\t\t\tboolean foldedxh;\n\t\t\tint xfoldtimes = 0;\n\t\t\t\n\t\t\tfor(curX = 0; curX < 5; curX++)\n\t\t\t{\n\t\t\t\tif(overlapped) {break;}\n\t\t\t\t\n\t\t\t\txfolding = false;\n\t\t\t\tfoldedxh = false;\n\t\t\t\t\n\t\t\t\t//check for vertically-connected floors\n\t\t\t\tboolean prev = false;\n\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t{\n\t\t\t\t\tif(floor[curX][ty] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(prev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int iy = 1; iy <= ty; iy++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//if there's anything to fold here, fold\n\t\t\t\t\t\t\t\tboolean doit = false;\n\t\t\t\t\t\t\t\tfor(int ttx = 1; ttx <= 4; ttx++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(floor[ttx][iy] > 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdoit = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif(doit)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfoldDown(iy);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = true;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t{\n\t\t\t\t\tif(floor[curX][ty] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if it's a floor, also check for connections to next x, for the next x-folding\n\t\t\t\t\t\tif(curX < 4 && floor[curX+1][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"Can FR from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\txfolding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(xfolding && curX < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\tfoldRight(curX+1);\n\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\tmapOut();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(xfolding == false && curX < 4) //check for XH folding\n\t\t\t\t{\n\t\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(horizontal[curX][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//if it's has a top, also check for connections to next top\n\t\t\t\t\t\t\tif(curX < 4 && horizontal[curX+1][ty] > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"Can FHHHHR from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\t\txfolding = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xfolding && curX < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\t\tfoldHRight(curX,ty);\n\t\t\t\t\t\t\tfoldedxh = true;\n\t\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\telse if(foldedxh == false)\n\t\t\t\t{\n\t\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ceil[curX][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//if it has a ceil, also check for connections to next ceil\n\t\t\t\t\t\t\tif(curX < 4 && ceil[curX+1][ty] > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"Can CCCCC from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\t\t\tceilFoldRight(curX+1);\n\t\t\t\t\t\t\t\tfoldedxh = true;\n\t\t\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceilFoldRight\n\t\t\t}\n\t\t\t\n\t\t\tboolean ans;\n\t\t\tif(overlapped)\n\t\t\t{\n\t\t\t\tans = false;\n//\t\t\t\tSystem.out.println(\"overlapped\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(floor[lastx][lasty] > 0 && horizontal[lastx][lasty] > 0 && horizontal[lastx][lasty+1] > 0 && vertical[lastx][lasty] > 0 && vertical[lastx+1][lasty] > 0 && ceil[lastx][lasty] > 0)\n\t\t\t\t{\n\t\t\t\t\tint f = floor[lastx][lasty];\n\t\t\t\t\tint c = ceil[lastx][lasty];\n\t\t\t\t\tint l = horizontal[lastx][lasty];\n\t\t\t\t\tint r = horizontal[lastx][lasty+1];\n\t\t\t\t\tint u = vertical[lastx][lasty];\n\t\t\t\t\tint d = vertical[lastx+1][lasty];\n\t\t\t\t\t\n\t\t\t\t\tif(f + c == 7 && l + r == 7 && u + d == 7)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"sum\");\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"hole\");\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n//\t\t\tSystem.out.println(\"FIN. x = \" + lastx + \", y = \" + lasty + \" roof \" + ceil[lastx][lasty]);\n//\t\t\tSystem.out.println(ceil[lastx+1][lasty]);\n//\t\t\tboolean ans = ;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\t\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\tnew AOJ1118();\n\t}\n\n\tclass AOJ1118{\n\t\tint top,bottom,east,west,north,south;\n\t\tint[][] map;\n\t\tpublic AOJ1118() {\n\t\t\tint n = in.nextInt();\n\t\t\twhile(n-->0)doIt();\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\ttop=-1;bottom=-1;east=-1;west=-1;north=-1;south=-1;\n\t\t\tmap = new int[5][5];\n\t\t\tboolean used[] = new boolean[7];\n\t\t\tused[0]=true;\n\t\t\tfor(int s=0;s<5;s++)for(int i=0;i<5;i++){\n\t\t\t\tmap[s][i]=in.nextInt();\n\t\t\t\tif(map[s][i]>0){\n\t\t\t\t\tif(!used[map[s][i]])used[map[s][i]]=true;\n\t\t\t\t\telse used[0]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!used[0]){\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\treturn;\n\t\t\t}else if(!(used[1]&&used[2]&&used[3]&&used[4]&&used[5]&&used[6])){\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tDice dice = new Dice(1, 3);\n\t\t\tint sx=-1,sy=-1;\n\t\t\tfor(int y=0;y<5;y++)for(int x=0;x<5;x++)if(map[y][x]>0&&sx==-1&&sy==-1){\n\t\t\t\tsx=x;sy=y;\n\t\t\t}\n\t\t\tbfs(sx, sy, dice);\n//\t\t\tSystem.out.println(dice.toString());\n\t\t\tif(dice.IsDice())System.out.println(\"true\");\n\t\t\telse System.out.println(\"false\");\n\t\t}\n\t\t\n\t\tvoid bfs(int x,int y,Dice dice){\n\t\t\tif(dice.bottom!=-1)return;\n\t\t\tdice.bottom=map[y][x];\n\t\t\tmap[y][x]=0;\n\t\t\tint[] nx={1,0,-1,0};//右、下、左、上\n\t\t\tint[] ny={0,1,0,-1};\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint sx=nx[i]+x;\n\t\t\t\tint sy=ny[i]+y;\n\t\t\t\tif(sy>=0&&sy<5&&sx>=0&&sx<5)if(map[sy][sx]>0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:dice.rotateEast();break;\n\t\t\t\t\tcase 1:dice.rotateSouth();break;\n\t\t\t\t\tcase 2:dice.rotateWest();break;\n\t\t\t\t\tcase 3:dice.rotateNorth();break;\n\t\t\t\t\t}\n\t\t\t\t\tbfs(sx, sy, dice);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tclass Dice{\n\t\t\tprivate int top=-1,bottom=-1,east=-1,west=-1,north=-1,south=-1;\n\t\t\tpublic Dice(int t,int s) {\n\t\t\t\tswitch(t){\n\t\t\t\tcase 1: break;\n\t\t\t\tcase 2: rotateEast(); break;\n\t\t\t\tcase 3: rotateNorth(); break;\n\t\t\t\tcase 4: rotateSouth(); break;\n\t\t\t\tcase 5: rotateWest(); break;\n\t\t\t\tcase 6: reverse(); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean IsDice(){\n\t\t\t\treturn north+south==7&&top+bottom==7&&west+east==7;\n\t\t\t}\n\t\t\tDice copy(){\n\t\t\t\tDice d = new Dice(top,south);\n\t\t\t\td.bottom=bottom;\n\t\t\t\td.east=east;\n\t\t\t\td.west=west;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\tDice rotateEast(){\n\t\t\t\tint temp=east;east=top;top=west;west=bottom;bottom=temp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateWest(){\n\t\t\t\tint tmp=west; west=top; top=east; east=bottom; bottom=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateSouth(){\n\t\t\t\tint tmp=south; south=top; top=north; north=bottom; bottom=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateNorth(){\n\t\t\t\tint tmp=north; north=top; top=south; south=bottom; bottom=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice reverse(){\n\t\t\t\trotateNorth(); rotateNorth(); rotateCW(); rotateCW();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateCW(){\n\t\t\t\tint tmp=north; north=west; west=south; south=east; east=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateCCW(){\n\t\t\t\tint tmp=north; north=east; east=south; south=west; west=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tint getTop(){\n\t\t\t\treturn top;\n\t\t\t}\n\t\t\tint getBottom(){\n\t\t\t\treturn bottom;\n\t\t\t}\n\t\t\tint getEast(){\n\t\t\t\treturn east;\n\t\t\t}\n\t\t\tint getWest(){\n\t\t\t\treturn west;\n\t\t\t}\n\t\t\tint getSourth(){\n\t\t\t\treturn south;\n\t\t\t}\n\t\t\tint getNorth(){\n\t\t\t\treturn north;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"top\"+top+\" north\"+north+\" east\"+east+\" south\"+south+\" west\"+west+\" bottom\"+bottom;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(obj==this)return true;\n\t\t\t\tif(!(obj instanceof Dice))return false;\n\t\t\t\tDice d = (Dice)obj;\n\t\t\t\tif(this.top==d.getTop()&&this.bottom==d.getBottom()&&\n\t\t\t\t\t\tthis.east==d.getWest()&&this.west==d.getWest()&&\n\t\t\t\t\t\tthis.north==d.getNorth()&&this.south==d.getSourth())return true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tclass AOJ1156{\n\t\tpublic AOJ1156() {\n\t\t\twhile(true){\n\t\t\t\tint w = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tint[][] map = new int[h+1][w+1];\n\t\t\t\tfor(int i=1;i<=h;i++)for(int s=1;s<=w;s++)map[i][s]=in.nextInt();\n\t\t\t\t//直進　右折　反転　左折\n\t\t\t\tint meirei[] = new int[4];\n\t\t\t\tfor(int i=0;i<4;i++)meirei[i]=in.nextInt();\n\t\t\t\tRobot robot = new Robot(w, h);\n\t\t\t\twhile(true){//シミュレートしてみる\n\t\t\t\t\tint x = robot.x;\n\t\t\t\t\tint y = robot.y;\n\t\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+map[y][x]);\n\t\t\t\t\tif(map[y][x]==0)robot.fd();\n\t\t\t\t\telse if(map[y][x]==1)robot.right();\n\t\t\t\t\telse if(map[y][x]==2)robot.back();\n\t\t\t\t\telse if(map[y][x]==3)robot.left();\n\t\t\t\t\telse if(map[y][x]==4)break;\n\t\t\t\t\trobot.cost++;\n\t\t\t\t\trobot.map[y][x]=robot.cost;\n\t\t\t\t}\n\n\t\t\t\t//\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t//\t\t\t\t\tfor(int s=1;s<=w;s++)System.out.print(robot.map[i][s]+\" \");\n\t\t\t\t//\t\t\t\t\tSystem.out.println();\n\t\t\t\t//\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t\tclass Robot{\n\t\t\tint x,y,muki,cost;\n\t\t\t//0左 1下 2右 3上\n\t\t\tint nx[] = {-1,0,1,0};\n\t\t\tint ny[] = {0,1,0,-1};\n\t\t\tint[][] map;\n\t\t\tpublic Robot(int w,int h) {\n\t\t\t\tmuki=2;\n\t\t\t\tx=1;y=1;\n\t\t\t\tcost=0;\n\t\t\t\tmap = new int[h+1][w+1];\n\t\t\t}\n\n\t\t\tvoid fd(){\n\t\t\t\tx+=nx[muki];\n\t\t\t\ty+=ny[muki];\n\t\t\t}\n\t\t\tvoid right(){\n\t\t\t\tmuki=(muki+3)%4;\n\t\t\t\tfd();\n\t\t\t}\n\t\t\tvoid left(){\n\t\t\t\tmuki=(muki+1)%4;\n\t\t\t\tfd();\n\t\t\t}\n\t\t\tvoid back(){\n\t\t\t\tmuki=(muki+2)%4;\n\t\t\t\tfd();\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic boolean debug = false;\n\tstatic int[][] input = new int[5][5];\n\tstatic int[][][] nets = \n\t\t{\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,1,0,0}},\n\t\t\t\n\t\t\t{{2,0,0,0,0},\n\t\t\t {1,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{3,0,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\n\t\t\t{{3,0,0,0,0},\n\t\t\t {2,1,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,1,2,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t{{3,2,0,0,0},\n\t\t\t {0,1,3,0,0},\n\t\t\t {0,0,2,1,0},\n\t\t\t {0,0,0,0,0}},\n\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {1,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0}},\t\t\t\t\n\t\t\t\t\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,0,3,2,3},\n\t\t\t {0,0,0,0,0},\n\t\t\t {0,0,0,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t//Flipped ones\n\n\t\t\t{{0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {1,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,2,0,0},\n\t\t\t {1,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,3,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,3,0,0},\n\t\t\t {0,1,2,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {2,1,0,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t{{0,0,2,3,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,0,0,0,0}},\n\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\t\t\t\t\n\t\t\t\t\n\t\t\t{{0,0,1,2,1},\n\t\t\t {3,2,3,0,0},\n\t\t\t {0,0,0,0,0},\n\t\t\t {0,0,0,0,0}},\t\t\t\t\t\n\t\t};\n\t\n\tstatic void printout()\n\t{\n\t\tif(!debug) {return;}\n\t\tfor(int y = 0; y <= 4; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t{\n\t\t\t\tSystem.out.print(input[y][x] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\t\t\n\t}\n\t\n\tstatic void rotate()\n\t{\n\t\tint[][] temp = new int[5][5];\n\t\tfor(int y = 0; y < 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\ttemp[y][x] = input[4-x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\tinput[y][x] = temp[y][x];\n\t\t\t}\n\t\t}\n\t\tgotopleft();\n\t}\n\t\n\tstatic void gotopleft()\n\t{\n\t\t//go left\n\t\tboolean goleft = true;\n\t\t\n\t\twhile(goleft)\n\t\t{\n\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t{\n\t\t\t\tif(input[y][0] != 0)\n\t\t\t\t{\n\t\t\t\t\tgoleft = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(goleft)\n\t\t\t{ //all 0s on the left\n\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[y][x] = input[y][x+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //remove the last ones\n\t\t\t\t\t\t\tinput[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//go top\n\t\tboolean gotop = true;\n\t\t\n\t\twhile(gotop)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\tif(input[0][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tgotop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(gotop)\n\t\t\t{ //all 0s on the top\n\t\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t\t{\n\t\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[y][x] = input[y+1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //remove the last ones\n\t\t\t\t\t\t\tinput[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean checkall()\n\t{\n\t\tgotopleft();\n\t\t\n\t\tfor(int i = 0; i < 20; i++)\n\t\t{\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tprintout();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t}\n\t\treturn false;\n\t}\n\t\t\n\tstatic boolean shapeexactlymatches(int netid)\n\t{ //net, y, x\n\t\tint[][] net = nets[netid];\n\t\tint[] pairfirstnumber = new int[3];\n\t\tint matched = 0;\n\t\tfor(int y = 0; y <= 3; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t{\n//\t\t\t\tSystem.out.println(x + \",\" +y + \": \" + net[y][x]);\n\t\t\t\t\n\t\t\t\tif((input[y][x] == 0)^(net[y][x] == 0))\n\t\t\t\t{\n\t\t\t\t\tif(debug)System.out.println(\"Mismatch quit: \" + x + \" \" + y);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(input[y][x] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint curPair = net[y][x]-1;\n\t\t\t\t\t\tif(pairfirstnumber[curPair] == 0)\n\t\t\t\t\t\t{ //first number of the pair\n\t\t\t\t\t\t\tpairfirstnumber[curPair] = input[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //second number of the pair\n\t\t\t\t\t\t\tif(input[y][x] + pairfirstnumber[curPair] == 7)\n\t\t\t\t\t\t\t{ //good pair!\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"There was no love. Pair: \" + curPair + \" Pairants: \" + pairfirstnumber[curPair] + \" and \" + input[y][x] );\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmatched += 1;\n\t//\t\t\t\t\tSystem.out.println(\"Matching: \" + x + \" \" + y);\n\t\t\t\t\t\tif(matched >= 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"Sixth match at: \" + x + \" \" + y);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) \n\t{\n//\t\tSystem.out.println(\"Ey\");\n\t\tint[][] net = nets[2];\n//\t\tSystem.out.println(net[0][1]);\n//\t\tSystem.out.println(nets[2][0][1]);\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\n\n\t\tint n = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tboolean preout = false;\n\t\t\tboolean[] numberappeared = new boolean[6];\n\t\t\tinput = new int[5][5];\n\t\t\tfor(int y = 0; y <= 4; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t\t{\n\t\t\t\t\tinput[y][x] = scan.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint cur = input[y][x];\n\t\t\t\t\t\n\t\t\t\t\tif(!preout)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cur < 0 || cur > 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(cur > 0)\n\t\t\t\t\t\t\t{ //valid number\n\t\t\t\t\t\t\t\tif(numberappeared[cur-1])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnumberappeared[cur-1] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n//\t\t\trotate();\n//\t\t\tprintout();\n\n\t\t\t//\n//\t\t\tgotopleft();\n//\t\t\trotate();\n//\t\t\tprintout();\n//\t\t\tshapeexactlymatches(0);\n\t\t\t\n\t\t\tif(!preout)\n\t\t\t{\n\t\t\t\tSystem.out.println(checkall());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\nimport org.omg.PortableInterceptor.SYSTEM_EXCEPTION;\n\npublic class Main \n{\n\tstatic boolean debug;\n\tstatic int[][] floor = new int[5][5];\n\tstatic int[][] ceil = new int[5][5];\n\t\n\tstatic int[][] horizontal = new int[5][6]; //x = 3 means on left of tile x=3\n\tstatic int[][] vertical = new int[6][5]; //y = 3 means on top of tile y=3\n\t\n\tstatic boolean overlapped;\n\t\n\tstatic int lastx;\n\tstatic int lasty;\n\t\n\tstatic void mapOut()\n\t{\n\t\tif(!debug) {return;}\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 5; x++)\n\t\t\t{\n\t\t\t\tif(x < 5 && horizontal[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\" -\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"  \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\n\t\t\tfor(int x = 0; x <= 5; x++)\n\t\t\t{\n\t\t\t\tif(y < 5 && vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\"|\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x < 5 && y < 5)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.print(floor[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t\t\n\t}\n\t\n\tstatic void overlap()\n\t{\n\t\tif(debug)System.out.println(\"OVERLAP\");\n\t\toverlapped = true;\n\t}\n\t\n\tstatic void foldHRight(int x, int y) //floor x and y\n\t{\n\t\tlastx = x+1;\n\t\tlasty = y;\n\t\t//ignore the would-be-overlap right\n\t\tif(debug)System.out.println(\"Folding h-right \" + x + \" \" + y);\n\t\t\n\t\t//bottom\n\t\tif(horizontal[x][y+1] > 0)\n\t\t{\n\t\t\tif(vertical[x+2][y] > 0) {overlap(); return;}\n\t\t\tvertical[x+2][y] = horizontal[x][y+1];\n\t\t\thorizontal[x][y+1] = 0;\n\t\t}\n\t\t\n\t\t//left\n\t\tif(vertical[x][y] > 0)\n\t\t{\n\t\t\tif(horizontal[x+1][y+1] > 0) {overlap(); return;}\n\t\t\thorizontal[x+1][y+1] = vertical[x][y];\n\t\t\tvertical[x][y] = 0;\n\t\t}\n\t\t\n\t\t//top\n\t\tif(horizontal[x][y] > 0)\n\t\t{\n\t\t\tif(vertical[x+1][y] > 0) {overlap(); return;}\n\t\t\tvertical[x+1][y] = horizontal[x][y];\n\t\t\thorizontal[x][y] = 0;\n\t\t}\n\n\t\t//floor\n\t\tif(floor[x][y] > 0)\n\t\t{\n\t\t\tif(floor[x+1][y] > 0) {overlap();return;}\n\t\t\tfloor[x+1][y] = floor[x][y];\n\t\t\tfloor[x][y] = 0;\n\t\t}\n\n\t\t//ceil\n\t\tif(ceil[x][y] > 0)\n\t\t{\n\t\t\tif(ceil[x+1][y] > 0) {overlap();return;}\n\t\t\tceil[x+1][y] = ceil[x][y];\n\t\t\tceil[x][y] = 0;\n\t\t}\n\t}\n\t\n\tstatic void foldRight(int foldx) //vertical-line.\n\t{ //we can assume that we're only folding foldx-1, the ones left to that are already folded to right.\n\t\tif(debug)System.out.println(\"Folding right \" + foldx);\n\t\t//in other words, we assume use of the method that we start the right-folding from the left.\n\t\tlastx = foldx;\n\t\t\n\t\tint x = foldx - 1;\n\t\t\n\t\tfor(int y = 0; y <= 5; y++)\n\t\t{\n\t\t\tif(y <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && vertical[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+1][y] = floor[x][y];\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(ceil[x][y] != 0 && vertical[x+2][y] != 0) {overlap();return;}\n\t\t\t\t\tvertical[x+2][y] = ceil[x][y];\n//\t\t\t\t\tif(vertical[x+2][y] != 0) {System.out.println(\"fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//vertical... we're currently ignoring the vertical to the right which would cause overlap.\n\t\t\t\tif(vertical[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(vertical[x][y] != 0 && ceil[x+1][y] != 0) {overlap();return;}\n\t\t\t\t\tceil[x+1][y] = vertical[x][y];\n//\t\t\t\t\tif(vertical[x][y] != 0) {System.out.println(\"newceil from ver \" + x + \" \" + y);}\n\t\t\t\t\tvertical[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//horizontal\n\t\t\tif(horizontal[x][y] != 0 && horizontal[x+1][y] != 0) {overlap();return;}\n\t\t\thorizontal[x+1][y] = horizontal[x][y];\n\t\t\thorizontal[x][y] = 0;\n\t\t}\n\t}\n\t\n\tstatic void foldDown(int foldy) //horizontal-line.\n\t{ //we can assume that we're only folding foldy-1, the ones up to that are already folded to down.\n\t\tif(debug)System.out.println(\"Folding down \" + foldy);\n\t\t//in other words, we assume use of the method that we start the down-folding from the top.\n\t\tlasty = foldy;\n\t\t\n\t\tint y = foldy - 1;\n\t\t\n\t\tfor(int x = 0; x <= 5; x++)\n\t\t{\n\t\t\tif(x <= 4)\n\t\t\t{\n\t\t\t\t//floor\n\t\t\t\tif(floor[x][y]>0)\n\t\t\t\t{\n\t\t\t\t\tif(floor[x][y] != 0 && horizontal[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\thorizontal[x][y+1] = floor[x][y];\n\t//\t\t\t\tif(floor[x][y] > 0) {System.out.println(\"Fromfloor \" + x + \" \" + y);}\n\t\t\t\t\tfloor[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//ceiling\n\t\t\t\tif(ceil[x][y]>0)\n\t\t\t\t{\n//\t\t\t\t\tif(x == 2 && y == 1) {System.out.println(\"Ceil: \" + ceil[2][1]);}\n\t\t\t\t\tif(ceil[x][y] != 0 && horizontal[x][y+2] != 0) {overlap();return;}\n\t\t\t\t\thorizontal[x][y+2] = ceil[x][y];\n\t//\t\t\t\tif(ceil[x][y] > 0) {System.out.println(\"Fromceil \" + x + \" \" + y);}\n\t\t\t\t\tceil[x][y] = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//horizontal ignoring the one-to-the-down one\n\t\t\t\tif(horizontal[x][y] > 0)\n\t\t\t\t{\n\t\t\t\t\tif(horizontal[x][y] != 0 && ceil[x][y+1] != 0) {overlap();return;}\n\t\t\t\t\tceil[x][y+1] = horizontal[x][y];\n\t\t\t\t\thorizontal[x][y] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//vertical\n\t\t\tif(vertical[x][y] > 0)\n\t\t\t{\n\t\t\t\tif(vertical[x][y] != 0 && vertical[x][y+1] != 0) {overlap();return;}\n\t\t\t\tvertical[x][y+1] = vertical[x][y];\n\t\t\t\tvertical[x][y] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) \n\t{\n\t\tint n;\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tn = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\toverlapped = false;\n\t\t\tfloor = new int[5][5];\n\t\t\tceil = new int[5][5];\n\t\t\t\n\t\t\thorizontal = new int[5][6];\n\t\t\tvertical = new int[6][5];\n\t\t\t\n\t\t\tboolean[] numberappeared = new boolean[6];\n\t\t\tint appearednums = 0;\n\t\t\t\n\t\t\tboolean preout = false;\n\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t{\n\t\t\t\t\tfloor[x][y] = scan.nextInt();\n\t\t\t\t\tif(floor[x][y] < 0 || floor[x][y] > 6) \n\t\t\t\t\t{\n\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(floor[x][y] != 0) //valid non-zero number\n\t\t\t\t\t{\n\t\t\t\t\t\tif(numberappeared[floor[x][y]-1])\n\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(floor[x][y] + \" already appeared\");\n\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnumberappeared[floor[x][y]-1] = true;\n\t\t\t\t\t\tappearednums += 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(appearednums > 6) {preout = true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(preout)\n\t\t\t{\n//\t\t\t\tSystem.out.println(\"PRE OUT\");\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint curX = 0;\n\t\t\tboolean xfolding = true;\n\t\t\tboolean xhfolding = true;\n\t\t\tint xfoldtimes = 0;\n\t\t\t\n\t\t\tfor(curX = 0; curX < 5; curX++)\n\t\t\t{\n\t\t\t\tif(overlapped) {break;}\n\t\t\t\t\n\t\t\t\txfolding = false;\n\t\t\t\txhfolding = false;\n\t\t\t\t\n\t\t\t\t//check for vertically-connected floors\n\t\t\t\tboolean prev = false;\n\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t{\n\t\t\t\t\tif(floor[curX][ty] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(prev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int iy = 1; iy <= ty; iy++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfoldDown(iy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = true;\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t{\n\t\t\t\t\tif(floor[curX][ty] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t//if it's a floor, also check for connections to next x, for the next x-folding\n\t\t\t\t\t\tif(curX < 4 && floor[curX+1][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"Can FR from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\txfolding = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(xfolding && curX < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\tfoldRight(curX+1);\n\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\tmapOut();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(xfolding == false && curX < 4) //check for XH folding\n\t\t\t\t{\n\t\t\t\t\tfor(int ty = 0; ty < 5; ty++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(horizontal[curX][ty] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//if it's has a top, also check for connections to next top\n\t\t\t\t\t\t\tif(curX < 4 && horizontal[curX+1][ty] > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"Can FHHHHR from \" + curX + \" \" + ty);\n\t\t\t\t\t\t\t\txfolding = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xfolding && curX < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\txfoldtimes += 1;\n\t\t\t\t\t\t\tfoldHRight(curX,ty);\n\t\t\t\t\t\t\txfolding = false;\n\t\t\t\t\t\t\tmapOut();\n\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean ans;\n\t\t\tif(overlapped)\n\t\t\t{\n\t\t\t\tans = false;\n//\t\t\t\tSystem.out.println(\"overlapped\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(floor[lastx][lasty] > 0 && horizontal[lastx][lasty] > 0 && horizontal[lastx][lasty+1] > 0 && vertical[lastx][lasty] > 0 && vertical[lastx+1][lasty] > 0 && ceil[lastx][lasty] > 0)\n\t\t\t\t{\n\t\t\t\t\tint f = floor[lastx][lasty];\n\t\t\t\t\tint c = ceil[lastx][lasty];\n\t\t\t\t\tint l = horizontal[lastx][lasty];\n\t\t\t\t\tint r = horizontal[lastx][lasty+1];\n\t\t\t\t\tint u = vertical[lastx][lasty];\n\t\t\t\t\tint d = vertical[lastx+1][lasty];\n\t\t\t\t\t\n\t\t\t\t\tif(f + c == 7 && l + r == 7 && u + d == 7)\n\t\t\t\t\t{\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"sum\");\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"hole\");\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tif(debug)System.out.println(\"FIN. x = \" + lastx + \", y = \" + lasty + \" roof \" + ceil[lastx][lasty]);\n\t\t\t\n//\t\t\tboolean ans = ;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\t\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\tpublic Main(){\n\t\t//\t\tnew AOJ0534();\n\t\tnew AOJ1118();\n\t}\n\n\tclass AOJ0534{\n\t\tint n;\n\t\tint[] memo;\n\t\tArrayList<Integer> list;\n\t\tpublic AOJ0534() {\n\t\t\twhile(true){\n\t\t\t\tn=in.nextInt();\n\t\t\t\tif(n==0)break;\n\t\t\t\tdoIt();\n\t\t\t}\n\t\t}\n\n\t\tvoid Spoint(){\n\t\t\tfor(int i=1;i<n-2;i++){\n\t\t\t\tif(memo[i]!=memo[i-1]&&memo[i-1]==memo[i+1]&&memo[i+1]==memo[i+2])list.add(i);\n\t\t\t}\n\t\t\tfor(int i=2;i<n-1;i++){\n\t\t\t\tif(memo[i]!=memo[i-1]&&memo[i-1]==memo[i-2]&&memo[i+1]==memo[i-1])list.add(i);\n\t\t\t}\n\t\t}\n\n\t\tint bfs(int m[]){\n\t\t\tArrayList<Integer> l2 = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<m.length;i++)l2.add(m[i]);\n\t\t\twhile(true){\n\t\t\t\tboolean sw=false;\n\t\t\t\tfor(int i=0;i<l2.size()-3;i++){\n\t\t\t\t\t//\t\t\t\t\tSystem.out.println(l2+\" \"+i);\n\t\t\t\t\tif(l2.get(i)==l2.get(i+1)&&l2.get(i)==l2.get(i+2)&&l2.get(i)==l2.get(i+3)){\n\t\t\t\t\t\tint color=l2.get(i);\n\t\t\t\t\t\t//\t\t\t\t\t\tSystem.out.println(l2+\"::\"+i+\";;\"+color);\n\t\t\t\t\t\tfor(;l2.get(i)==color;){\n\t\t\t\t\t\t\tl2.remove(i);\n\t\t\t\t\t\t\tif(l2.size()-1==i)break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti=0;\n\t\t\t\t\t}\n\t\t\t\t\tif(l2.size()-4==i)sw=true;\n\t\t\t\t}\n\t\t\t\tif(sw)break;\n\t\t\t\tif(m.length<4)break;\n\t\t\t}\n\t\t\treturn l2.size();\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\tlist = new ArrayList<Integer>();\n\t\t\tmemo = new int[n];\n\t\t\tfor(int i=0;i<n;i++)memo[i]=in.nextInt();\n\t\t\tSpoint();\n\t\t\tint cnt=Integer.MAX_VALUE;\n\t\t\tfor(int i=0;i<list.size();i++){\n\t\t\t\tint[] m = memo.clone();\n\t\t\t\tm[list.get(i)]=m[list.get(i)-1];\n\t\t\t\tcnt=Math.min(cnt,bfs(m));\n\t\t\t}\n\t\t\tif(cnt==Integer.MAX_VALUE||list.size()==0)System.out.println(n);\n\t\t\telse System.out.println(cnt);\n\t\t}\n\t}\n\n\tclass AOJ1118{\n\t\tint top,bottom,east,west,north,south;\n\t\tint[][] map;\n\t\tpublic AOJ1118() {\n\t\t\tint n = in.nextInt();\n\t\t\twhile(n-->0)doIt();\n\t\t}\n\n\t\tvoid doIt(){\n\t\t\ttop=-1;bottom=-1;east=-1;west=-1;north=-1;south=-1;\n\t\t\tmap = new int[5][5];\n\t\t\tboolean used[] = new boolean[7];\n\t\t\tused[0]=true;\n\t\t\tint cnt=0;\n\t\t\tfor(int s=0;s<5;s++)for(int i=0;i<5;i++){\n\t\t\t\tmap[s][i]=in.nextInt();\n\t\t\t\tif(map[s][i]>0){\n\t\t\t\t\tif(!used[map[s][i]]){\n\t\t\t\t\t\tused[map[s][i]]=true;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t}\n\t\t\t\t\telse used[0]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!used[0]){\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\treturn;\n\t\t\t}else if(!(used[1]&&used[2]&&used[3]&&used[4]&&used[5]&&used[6])){\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\treturn;\n\t\t\t}else if(cnt!=6){\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tDice dice = new Dice(1, 3);\n\t\t\tint sx=-1,sy=-1;\n\t\t\tfor(int y=0;y<5;y++)for(int x=0;x<5;x++)if(map[y][x]>0&&sx==-1&&sy==-1){\n\t\t\t\tsx=x;sy=y;\n\t\t\t}\n\t\t\tbfs(sx, sy, dice);\n\t\t\tif(dice.IsDice())System.out.println(\"true\");\n\t\t\telse System.out.println(\"false\");\n\t\t}\n\n\n\t\tvoid bfs(int x,int y,Dice dice){\n//\t\t\tSystem.out.println(x+\" \"+y+\" \"+dice.toString());\n\t\t\tif(dice.bottom!=-1)return;\n\t\t\tdice.bottom=map[y][x];\n\t\t\tmap[y][x]=0;\n\t\t\tint[] nx={1,0,-1,0};//右、下、左、上\n\t\t\tint[] ny={0,1,0,-1};\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint sx=nx[i]+x;\n\t\t\t\tint sy=ny[i]+y;\n\t\t\t\tif(sy>=0&&sy<5&&sx>=0&&sx<5)if(map[sy][sx]>0){\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:dice.rotateEast();\n\t\t\t\t\t       bfs(sx, sy, dice);dice.rotateWest();break;\n\t\t\t\t\tcase 1:dice.rotateSouth();\n\t\t\t\t\t       bfs(sx, sy, dice);dice.rotateNorth();break;\n\t\t\t\t\tcase 2:dice.rotateWest();\n\t\t\t\t\t       bfs(sx, sy, dice);dice.rotateEast();break;\n\t\t\t\t\tcase 3:dice.rotateNorth();\n\t\t\t\t\t       bfs(sx, sy, dice);dice.rotateSouth();break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tclass Dice{\n\t\t\tprivate int top=-1,bottom=-1,east=-1,west=-1,north=-1,south=-1;\n\t\t\tpublic Dice(int t,int s) {\n\t\t\t\tswitch(t){\n\t\t\t\tcase 1: break;\n\t\t\t\tcase 2: rotateEast(); break;\n\t\t\t\tcase 3: rotateNorth(); break;\n\t\t\t\tcase 4: rotateSouth(); break;\n\t\t\t\tcase 5: rotateWest(); break;\n\t\t\t\tcase 6: reverse(); break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean IsDice(){\n\t\t\t\treturn north+south==7&&top+bottom==7&&west+east==7;\n\t\t\t}\n\t\t\tDice copy(){\n\t\t\t\tDice d = new Dice(top,south);\n\t\t\t\td.bottom=bottom;\n\t\t\t\td.east=east;\n\t\t\t\td.west=west;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t\tDice rotateEast(){\n\t\t\t\tint temp=east;east=top;top=west;west=bottom;bottom=temp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateWest(){\n\t\t\t\tint tmp=west; west=top; top=east; east=bottom; bottom=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateSouth(){\n\t\t\t\tint tmp=south; south=top; top=north; north=bottom; bottom=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateNorth(){\n\t\t\t\tint tmp=north; north=top; top=south; south=bottom; bottom=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice reverse(){\n\t\t\t\trotateNorth(); rotateNorth(); rotateCW(); rotateCW();\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateCW(){\n\t\t\t\tint tmp=north; north=west; west=south; south=east; east=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tDice rotateCCW(){\n\t\t\t\tint tmp=north; north=east; east=south; south=west; west=tmp;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tint getTop(){\n\t\t\t\treturn top;\n\t\t\t}\n\t\t\tint getBottom(){\n\t\t\t\treturn bottom;\n\t\t\t}\n\t\t\tint getEast(){\n\t\t\t\treturn east;\n\t\t\t}\n\t\t\tint getWest(){\n\t\t\t\treturn west;\n\t\t\t}\n\t\t\tint getSourth(){\n\t\t\t\treturn south;\n\t\t\t}\n\t\t\tint getNorth(){\n\t\t\t\treturn north;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"top\"+top+\" north\"+north+\" east\"+east+\" south\"+south+\" west\"+west+\" bottom\"+bottom;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(obj==this)return true;\n\t\t\t\tif(!(obj instanceof Dice))return false;\n\t\t\t\tDice d = (Dice)obj;\n\t\t\t\tif(this.top==d.getTop()&&this.bottom==d.getBottom()&&\n\t\t\t\t\t\tthis.east==d.getWest()&&this.west==d.getWest()&&\n\t\t\t\t\t\tthis.north==d.getNorth()&&this.south==d.getSourth())return true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tclass AOJ1156{\n\t\tpublic AOJ1156() {\n\t\t\twhile(true){\n\t\t\t\tint w = in.nextInt();\n\t\t\t\tint h = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tint[][] map = new int[h+1][w+1];\n\t\t\t\tfor(int i=1;i<=h;i++)for(int s=1;s<=w;s++)map[i][s]=in.nextInt();\n\t\t\t\t//直進　右折　反転　左折\n\t\t\t\tint meirei[] = new int[4];\n\t\t\t\tfor(int i=0;i<4;i++)meirei[i]=in.nextInt();\n\t\t\t\tRobot robot = new Robot(w, h);\n\t\t\t\twhile(true){//シミュレートしてみる\n\t\t\t\t\tint x = robot.x;\n\t\t\t\t\tint y = robot.y;\n\t\t\t\t\tSystem.out.println(x+\" \"+y+\" \"+map[y][x]);\n\t\t\t\t\tif(map[y][x]==0)robot.fd();\n\t\t\t\t\telse if(map[y][x]==1)robot.right();\n\t\t\t\t\telse if(map[y][x]==2)robot.back();\n\t\t\t\t\telse if(map[y][x]==3)robot.left();\n\t\t\t\t\telse if(map[y][x]==4)break;\n\t\t\t\t\trobot.cost++;\n\t\t\t\t\trobot.map[y][x]=robot.cost;\n\t\t\t\t}\n\n\t\t\t\t//\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t//\t\t\t\t\tfor(int s=1;s<=w;s++)System.out.print(robot.map[i][s]+\" \");\n\t\t\t\t//\t\t\t\t\tSystem.out.println();\n\t\t\t\t//\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t\tclass Robot{\n\t\t\tint x,y,muki,cost;\n\t\t\t//0左 1下 2右 3上\n\t\t\tint nx[] = {-1,0,1,0};\n\t\t\tint ny[] = {0,1,0,-1};\n\t\t\tint[][] map;\n\t\t\tpublic Robot(int w,int h) {\n\t\t\t\tmuki=2;\n\t\t\t\tx=1;y=1;\n\t\t\t\tcost=0;\n\t\t\t\tmap = new int[h+1][w+1];\n\t\t\t}\n\n\t\t\tvoid fd(){\n\t\t\t\tx+=nx[muki];\n\t\t\t\ty+=ny[muki];\n\t\t\t}\n\t\t\tvoid right(){\n\t\t\t\tmuki=(muki+3)%4;\n\t\t\t\tfd();\n\t\t\t}\n\t\t\tvoid left(){\n\t\t\t\tmuki=(muki+1)%4;\n\t\t\t\tfd();\n\t\t\t}\n\t\t\tvoid back(){\n\t\t\t\tmuki=(muki+2)%4;\n\t\t\t\tfd();\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Nets of Dice\npublic class Main{\n\n\tint[][][] dice = {\n\t\t\t{{1,0,0,0},\n\t\t\t {2,3,2,3},\n\t\t\t {1,0,0,0}},\n\t\t\t{{1,0,0,0},\n\t\t\t {2,3,2,3},\n\t\t\t {0,1,0,0}},\n\t\t\t{{1,0,0,0},\n\t\t\t {2,3,2,3},\n\t\t\t {0,0,1,0}},\n\t\t\t{{1,0,0,0},\n\t\t\t {2,3,2,3},\n\t\t\t {0,0,0,1}},\n\t\t\t{{0,1,0,0},\n\t\t\t {2,3,2,3},\n\t\t\t {0,1,0,0}},\n\t\t\t{{0,1,0,0},\n\t\t\t {2,3,2,3},\n\t\t\t {0,0,1,0}},\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,0,3,2,3}},\n\t\t\t{{1,2,0,0},\n\t\t\t {0,3,1,3},\n\t\t\t {0,2,0,0}},\n\t\t\t{{1,2,0,0},\n\t\t\t {0,3,1,3},\n\t\t\t {0,0,2,0}},\n\t\t\t{{1,2,0,0},\n\t\t\t {0,3,1,3},\n\t\t\t {0,0,0,2}},\n\t\t\t{{1,2,0,0},\n\t\t\t {0,3,1,0},\n\t\t\t {0,0,2,3}}\n\t};\n\t\n\tint[][] rot(int[][] a){\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] res = new int[w][h];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)res[j][i]=a[i][w-j-1];\n\t\treturn res;\n\t}\n\tint[][] mirror(int[][] a){\n\t\tint h = a.length, w = a[0].length;\n\t\tint[][] res = new int[h][w];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)res[i][j]=a[i][w-j-1];\n\t\treturn res;\n\t}\n\t\n\tvoid run(){\n\t\tList<int[][]> l = new ArrayList<int[][]>();\n\t\tfor(int k=0;k<4;k++)for(int i=0;i<11;i++){\n\t\t\tl.add(dice[i]);\n\t\t\tl.add(mirror(dice[i]));\n\t\t\tdice[i] = rot(dice[i]);\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\twhile(n--!=0){\n\t\t\tint[][] a = new int[5][5];\n\t\t\tint c = 0, sum = 0;\n\t\t\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\tif(a[i][j]!=0){\n\t\t\t\t\tc++; sum+=1<<(a[i][j]-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c!=6||sum!=63){\n\t\t\t\tSystem.out.println(false); continue;\n\t\t\t}\n\t\t\tboolean res = false;\n\t\t\tint[] add = new int[4];\n\t\t\tfor(int[][] b:l){\n\t\t\t\tint h = b.length, w = b[0].length;\n\t\t\t\tfor(int i=0;i+h<=5;i++)for(int j=0;j+w<=5;j++){\n\t\t\t\t\tArrays.fill(add, 0);\n\t\t\t\t\tboolean match = true;\n\t\t\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++){\n\t\t\t\t\t\tif(b[y][x]==0&&a[i+y][j+x]!=0 || b[y][x]!=0&&a[i+y][j+x]==0)match=false;\n\t\t\t\t\t\tadd[b[y][x]]+=a[i+y][j+x];\n\t\t\t\t\t}\n\t\t\t\t\tif(match&&add[1]==7&&add[2]==7&&add[3]==7)res = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic boolean debug = false;\n\tstatic int[][] input = new int[5][5];\n\tstatic int[][][] nets = \n\t\t{\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,1,0,0}},\n\t\t\t\n\t\t\t{{2,0,0,0,0},\n\t\t\t {1,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{3,0,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\n\t\t\t{{3,0,0,0,0},\n\t\t\t {2,1,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,1,2,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t{{3,2,0,0,0},\n\t\t\t {0,1,3,0,0},\n\t\t\t {0,0,2,1,0},\n\t\t\t {0,0,0,0,0}},\n\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {1,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0}},\t\t\t\t\n\t\t\t\t\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,0,3,2,3},\n\t\t\t {0,0,0,0,0},\n\t\t\t {0,0,0,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {1,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,2,0,0},\n\t\t\t {1,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,3,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,3,0,0},\n\t\t\t {0,1,2,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {2,1,0,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t{{0,0,2,3,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,0,0,0,0}},\n\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\t\t\t\t\n\t\t\t\t\n\t\t\t{{0,0,1,2,1},\n\t\t\t {3,2,3,0,0},\n\t\t\t {0,0,0,0,0},\n\t\t\t {0,0,0,0,0}},\t\t\t\t\t\n\t\t};\n\t\n\tstatic void printout()\n\t{\n\t\tif(!debug) {return;}\n\t\tfor(int y = 0; y <= 4; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t{\n\t\t\t\tSystem.out.print(input[y][x] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\t\t\n\t}\n\t\n\tstatic void rotate()\n\t{\n\t\tint[][] temp = new int[5][5];\n\t\tfor(int y = 0; y < 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\ttemp[y][x] = input[4-x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\tinput[y][x] = temp[y][x];\n\t\t\t}\n\t\t}\n\t\tgotopleft();\n\t}\n\t\n\tstatic void gotopleft()\n\t{\n\t\t//go left\n\t\tboolean goleft = true;\n\t\t\n\t\twhile(goleft)\n\t\t{\n\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t{\n\t\t\t\tif(input[y][0] != 0)\n\t\t\t\t{\n\t\t\t\t\tgoleft = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(goleft)\n\t\t\t{ //all 0s on the left\n\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[y][x] = input[y][x+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //remove the last ones\n\t\t\t\t\t\t\tinput[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//go top\n\t\tboolean gotop = true;\n\t\t\n\t\twhile(gotop)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\tif(input[0][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tgotop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(gotop)\n\t\t\t{ //all 0s on the top\n\t\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t\t{\n\t\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[y][x] = input[y+1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //remove the last ones\n\t\t\t\t\t\t\tinput[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean checkall()\n\t{\n\t\tgotopleft();\n\t\t\n\t\tfor(int i = 0; i < 20; i++)\n\t\t{\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tprintout();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t}\n\t\treturn false;\n\t}\n\t\t\n\tstatic boolean shapeexactlymatches(int netid)\n\t{ //net, y, x\n\t\tint[][] net = nets[netid];\n\t\tint[] pairfirstnumber = new int[3];\n\t\tint matched = 0;\n\t\tfor(int y = 0; y <= 3; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t{\n//\t\t\t\tSystem.out.println(x + \",\" +y + \": \" + net[y][x]);\n\t\t\t\t\n\t\t\t\tif((input[y][x] == 0)^(net[y][x] == 0))\n\t\t\t\t{\n\t\t\t\t\tif(debug)System.out.println(\"Mismatch quit: \" + x + \" \" + y);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(input[y][x] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint curPair = net[y][x]-1;\n\t\t\t\t\t\tif(pairfirstnumber[curPair] == 0)\n\t\t\t\t\t\t{ //first number of the pair\n\t\t\t\t\t\t\tpairfirstnumber[curPair] = input[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //second number of the pair\n\t\t\t\t\t\t\tif(input[y][x] + pairfirstnumber[curPair] == 7)\n\t\t\t\t\t\t\t{ //good pair!\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"There was no love. Pair: \" + curPair + \" Pairants: \" + pairfirstnumber[curPair] + \" and \" + input[y][x] );\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmatched += 1;\n\t//\t\t\t\t\tSystem.out.println(\"Matching: \" + x + \" \" + y);\n\t\t\t\t\t\tif(matched >= 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"Sixth match at: \" + x + \" \" + y);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) \n\t{\n//\t\tSystem.out.println(\"Ey\");\n\t\tint[][] net = nets[2];\n//\t\tSystem.out.println(net[0][1]);\n//\t\tSystem.out.println(nets[2][0][1]);\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\n\n\t\tint n = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tinput = new int[5][5];\n\t\t\tfor(int y = 0; y <= 4; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t\t{\n\t\t\t\t\tinput[y][x] = scan.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n//\t\t\trotate();\n//\t\t\tprintout();\n\n\t\t\t//\n//\t\t\tgotopleft();\n//\t\t\trotate();\n//\t\t\tprintout();\n//\t\t\tshapeexactlymatches(0);\n\t\t\t\n\t\t\tSystem.out.println(checkall());\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main \n{\n\tstatic boolean debug = false;\n\tstatic int[][] input = new int[5][5];\n\tstatic int[][][] nets = \n\t\t{\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\t\n\t\t\t{{1,2,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,1,0,0}},\n\t\t\t\n\t\t\t{{2,0,0,0,0},\n\t\t\t {1,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{3,0,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\n\t\t\t{{3,0,0,0,0},\n\t\t\t {2,1,0,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,1,2,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t{{3,2,0,0,0},\n\t\t\t {0,1,3,0,0},\n\t\t\t {0,0,2,1,0},\n\t\t\t {0,0,0,0,0}},\n\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {1,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {0,2,0,0,0}},\t\t\t\t\n\t\t\t\t\n\t\t\t{{1,2,1,0,0},\n\t\t\t {0,0,3,2,3},\n\t\t\t {0,0,0,0,0},\n\t\t\t {0,0,0,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t//Flipped ones\n\n\t\t\t{{0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\t\n\t\t\t{{0,2,1,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {1,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,2,0,0},\n\t\t\t {1,3,1,0,0},\n\t\t\t {0,2,0,0,0},\n\t\t\t {0,3,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,3,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\n\t\t\t\n\t\t\t{{0,0,3,0,0},\n\t\t\t {0,1,2,0,0},\n\t\t\t {0,3,0,0,0},\n\t\t\t {2,1,0,0,0}},\t\t\t\t\n\t\t\t\n\t\t\t{{0,0,2,3,0},\n\t\t\t {0,3,1,0,0},\n\t\t\t {1,2,0,0,0},\n\t\t\t {0,0,0,0,0}},\n\t\t\t\n\t\t\t{{0,3,0,0,0},\n\t\t\t {0,2,1,0,0},\n\t\t\t {1,3,0,0,0},\n\t\t\t {0,2,0,0,0}},\t\t\t\t\n\t\t\t\t\n\t\t\t{{0,0,1,2,1},\n\t\t\t {3,2,3,0,0},\n\t\t\t {0,0,0,0,0},\n\t\t\t {0,0,0,0,0}},\t\t\t\t\t\n\t\t};\n\t\n\tstatic void printout()\n\t{\n\t\tif(!debug) {return;}\n\t\tfor(int y = 0; y <= 4; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t{\n\t\t\t\tSystem.out.print(input[y][x] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\t\t\n\t}\n\t\n\tstatic void rotate()\n\t{\n\t\tint[][] temp = new int[5][5];\n\t\tfor(int y = 0; y < 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\ttemp[y][x] = input[4-x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y = 0; y < 5; y++)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\tinput[y][x] = temp[y][x];\n\t\t\t}\n\t\t}\n\t\tgotopleft();\n\t}\n\t\n\tstatic void gotopleft()\n\t{\n\t\t//go left\n\t\tboolean goleft = true;\n\t\t\n\t\twhile(goleft)\n\t\t{\n\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t{\n\t\t\t\tif(input[y][0] != 0)\n\t\t\t\t{\n\t\t\t\t\tgoleft = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(goleft)\n\t\t\t{ //all 0s on the left\n\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(x < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[y][x] = input[y][x+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //remove the last ones\n\t\t\t\t\t\t\tinput[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//go top\n\t\tboolean gotop = true;\n\t\t\n\t\twhile(gotop)\n\t\t{\n\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t{\n\t\t\t\tif(input[0][x] != 0)\n\t\t\t\t{\n\t\t\t\t\tgotop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(gotop)\n\t\t\t{ //all 0s on the top\n\t\t\t\tfor(int y = 0; y < 5; y++)\n\t\t\t\t{\n\t\t\t\t\tfor(int x = 0; x < 5; x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y < 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinput[y][x] = input[y+1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //remove the last ones\n\t\t\t\t\t\t\tinput[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean checkall()\n\t{\n\t\tgotopleft();\n\t\t\n\t\tfor(int i = 0; i < 20; i++)\n\t\t{\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t\trotate();\n\t\t\tprintout();\n\t\t\tif(shapeexactlymatches(i)) {return true;}\n\t\t}\n\t\treturn false;\n\t}\n\t\t\n\tstatic boolean shapeexactlymatches(int netid)\n\t{ //net, y, x\n\t\tint[][] net = nets[netid];\n\t\tint[] pairfirstnumber = new int[3];\n\t\tint matched = 0;\n\t\tfor(int y = 0; y <= 3; y++)\n\t\t{\n\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t{\n//\t\t\t\tSystem.out.println(x + \",\" +y + \": \" + net[y][x]);\n\t\t\t\t\n\t\t\t\tif((input[y][x] == 0)^(net[y][x] == 0))\n\t\t\t\t{\n\t\t\t\t\tif(debug)System.out.println(\"Mismatch quit: \" + x + \" \" + y);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(input[y][x] > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint curPair = net[y][x]-1;\n\t\t\t\t\t\tif(pairfirstnumber[curPair] == 0)\n\t\t\t\t\t\t{ //first number of the pair\n\t\t\t\t\t\t\tpairfirstnumber[curPair] = input[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{ //second number of the pair\n\t\t\t\t\t\t\tif(input[y][x] + pairfirstnumber[curPair] == 7)\n\t\t\t\t\t\t\t{ //good pair!\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(debug)System.out.println(\"There was no love. Pair: \" + curPair + \" Pairants: \" + pairfirstnumber[curPair] + \" and \" + input[y][x] );\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tmatched += 1;\n\t//\t\t\t\t\tSystem.out.println(\"Matching: \" + x + \" \" + y);\n\t\t\t\t\t\tif(matched >= 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(debug)System.out.println(\"Sixth match at: \" + x + \" \" + y);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) \n\t{\n//\t\tSystem.out.println(\"Ey\");\n\t\tint[][] net = nets[2];\n//\t\tSystem.out.println(net[0][1]);\n//\t\tSystem.out.println(nets[2][0][1]);\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\n\n\t\tint n = scan.nextInt();\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tboolean preout = false;\n\t\t\tboolean[] numberappeared = new boolean[6];\n\t\t\tinput = new int[5][5];\n\t\t\tfor(int y = 0; y <= 4; y++)\n\t\t\t{\n\t\t\t\tfor(int x = 0; x <= 4; x++)\n\t\t\t\t{\n\t\t\t\t\tinput[y][x] = scan.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint cur = input[y][x];\n\t\t\t\t\t\n\t\t\t\t\tif(!preout)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(cur < 0 || cur > 6)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(cur > 0)\n\t\t\t\t\t\t\t{ //valid number\n\t\t\t\t\t\t\t\tif(numberappeared[cur-1])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpreout = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnumberappeared[cur-1] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n//\t\t\trotate();\n//\t\t\tprintout();\n\n\t\t\t//\n//\t\t\tgotopleft();\n//\t\t\trotate();\n//\t\t\tprintout();\n//\t\t\tshapeexactlymatches(0);\n\t\t\t\n\t\t\tif(!preout)\n\t\t\t{\n\t\t\t\tSystem.out.println(checkall());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(\"false\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\twhile(n-- > 0){\n\t\t\tt = new int[5][5];\n\t\t\tint m = 0;\n\t\t\tboolean[] used = new boolean[7];\n\t\t\tboolean trueFlg = true;\n\n\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tt[i][j] = sc.nextInt();\n\n\t\t\t\t\t//ツ督ッツつカツ青板篠堋つェツ出ツづつォツづづ按つ「ツつゥツづ個確ツ認\n\t\t\t\t\tif(t[i][j] != 0){\n\t\t\t\t\t\tif(!used[t[i][j]]){\n\t\t\t\t\t\t\tm++;\n\t\t\t\t\t\t\tused[t[i][j]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\ttrueFlg = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m != 6) trueFlg = false;\n\n\t\t\t//ツサツイツコツδ債づ青ャツ猟ァツつオツづつ「ツづゥツつゥツづ個確ツ認\n\t\t\tif(trueFlg){\n\t\t\t\tint sy=-1,sx=-1;\n\t\t\t\tfor(sy=0;sy<5;sy++){\n\t\t\t\t\tfor(sx=0;sx<5;sx++) if(t[sy][sx] != 0) break;\n\t\t\t\t\tif(sx != 5) break;\n\t\t\t\t}\n\n\t\t\t\tDice d = new Dice(0,0,0,0,0,0);\n\t\t\t\tmakeDice(d,sx,sy);\n\t\t\t\ttrueFlg = d.isDice();\n\t\t\t}\n\n\t\t\tSystem.out.println(trueFlg ? \"true\" : \"false\");\n\t\t}\n\t}\n\n\tprivate static int[][] t;\n\tprivate static int dx[] = {0,1,0,-1};\n\tprivate static int dy[] = {-1,0,1,0};\n\n\tprivate static void makeDice(Dice d,int x,int y){\n\t\td.b = t[y][x];\n\t\tt[y][x] = 0;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif(nx>=0 && nx<5 && ny>=0 && ny<5 && t[ny][nx]>0){\n\t\t\t\td.move(i);\n\t\t\t\tmakeDice(d,nx,ny);\n\t\t\t\td.move((i+2)%4);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Dice{\n\tint t,b,w,e,n,s;\n\n\tDice(int t,int b,int w,int e,int n,int s){\n\t\tthis.t = t;\n\t\tthis.b = b;\n\t\tthis.w = w;\n\t\tthis.e = e;\n\t\tthis.n = n;\n\t\tthis.s = s;\n\t}\n\n\tboolean isDice(){\n\t\treturn t+b==7 && w+e==7 && n+s==7;\n\t}\n\n\tvoid move(int dir){\n\t\tDice d = this.copy();\n\t\t\t\n\t\tswitch(dir){\n\t\tcase 0:\n\t\t\tt = d.s;\n\t\t\tb = d.n;\n\t\t\tn = d.t;\n\t\t\ts = d.b;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tt = d.w;\n\t\t\tb = d.e;\n\t\t\tw = d.b;\n\t\t\te = d.t;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tt = d.n;\n\t\t\tb = d.s;\n\t\t\tn = d.b;\n\t\t\ts = d.t;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tt = d.e;\n\t\t\tb = d.w;\n\t\t\tw = d.t;\n\t\t\te = d.b;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tDice copy(){\n\t\treturn new Dice(t,b,w,e,n,s);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint T;\n\tfinal int n=5;\n\tint[][] a;\n\n\tvoid run(){\n\t\tT=sc.nextInt();\n\t\tfor(int k=0; k<T; k++){\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t\tprintln(yes+\"\");\n\t\t}\n\t}\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\n\t\tP add(P p){\n\t\t\treturn new P(x+p.x, y+p.y);\n\t\t}\n\n\t\tpublic String toString(){\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tboolean yes;\n\n\tvoid solve(){\n\t\tP[] ps=new P[6];\n\t\tyes=true;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(a[j][i]!=0){\n\t\t\t\t\tif(ps[a[j][i]-1]!=null){\n\t\t\t\t\t\tyes=false;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tps[a[j][i]-1]=new P(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<6; i++){\n\t\t\tif(ps[i]==null){\n\t\t\t\tyes=false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// 1~6ツつェ6ツづ?\n\t\t// ツ連ツ個仰青ォ\n\t\tint[][] w=new int[6][6];\n\t\tfor(int j=0; j<6; j++){\n\t\t\tfor(int i=0; i<j; i++){\n\t\t\t\tif(abs(ps[i].x-ps[j].x)+abs(ps[i].y-ps[j].y)==1){\n\t\t\t\t\tw[i][j]=w[j][i]=0;\n\t\t\t\t}else{\n\t\t\t\t\tw[i][j]=w[j][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw[j][j]=0;\n\t\t}\n\t\tfor(int k=0; k<6; k++){\n\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\tfor(int j=0; j<6; j++){\n\t\t\t\t\tw[i][j]=min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean connected=true;\n\t\tfor(int j=0; j<6; j++){\n\t\t\tfor(int i=0; i<6; i++){\n\t\t\t\tconnected&=w[i][j]==0;\n\t\t\t}\n\t\t}\n\t\t// debug(\"connected\", connected);\n\t\tif(!connected){\n\t\t\tyes=false;\n\t\t\treturn;\n\t\t}\n\t\t// ツ連ツ個仰つセツつィ\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<P>[] lists=new ArrayList[7];\n\n\t\tfor(int i=0; i<7; i++){\n\t\t\tlists[i]=new ArrayList<P>();\n\t\t}\n\n\t\tlists[0].add(new P(1, 0));\n\t\tlists[0].add(new P(2, 0));\n\n\t\tfor(int j=1; j<7; j++){\n\t\t\tint len=(j+1)/2;\n\t\t\tlists[j].add(new P(1, 0));\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tlists[j].add(new P(1, i));\n\t\t\t\t}else{\n\t\t\t\t\tlists[j].add(new P(1, -i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j%2==0){\n\t\t\t\tlists[j].add(new P(2, len));\n\t\t\t}else{\n\t\t\t\tlists[j].add(new P(2, -len));\n\t\t\t}\n\t\t\t// debug(lists[j]);\n\t\t}\n\n\t\tfor(int i=0; i<6; i++){\n\t\t\tP p=ps[i];\n\t\t\tArrayList<P> os=new ArrayList<P>();\n\t\t\tfor(ArrayList<P> list : lists){\n\t\t\t\t// debug(\"list\", list);\n\t\t\t\tfor(int rot=0; rot<4; rot++){\n\t\t\t\t\t// debug(\"rot\", rot);\n\t\t\t\t\t// listツづ罫otツづ可づつつ「ツづ?\n\t\t\t\t\tP last=null;\n\t\t\t\t\tboolean ok=true;\n\t\t\t\t\tfor(int k=0; k<list.size(); k++){\n\t\t\t\t\t\tP q=ps[i].add(rot(list.get(k), rot));\n\t\t\t\t\t\t// debug(\"k\", k, q);\n\t\t\t\t\t\tif(q.x>=0&&q.x<n&&q.y>=0&&q.y<n&&a[q.y][q.x]!=0){\n\t\t\t\t\t\t\tif(k==list.size()-1){\n\t\t\t\t\t\t\t\tlast=q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tos.add(last);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(i, p, os);\n\t\t\tif(os.size()==1){\n\t\t\t\tP q=os.get(0);\n\t\t\t\tif(a[p.y][p.x]+a[q.y][q.x]==7){}else{\n\t\t\t\t\tyes=false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tyes=false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tP rot(P p, int rot){\n\t\tif(rot==0){\n\t\t\treturn new P(p.x, p.y);\n\t\t}else if(rot==1){\n\t\t\treturn new P(-p.y, p.x);\n\t\t}else if(rot==2){\n\t\t\treturn new P(-p.x, -p.y);\n\t\t}else{\n\t\t\treturn new P(p.y, -p.x);\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nNS = 5\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\nXM = 0\nXP = 1\nYM = 2\nYP = 3\nZM = 4\nZP = 5\n\n### subroutines\n\ndef check_dice(sts)\n  sx = sy = 0\n  while sts[sy][sx] == 0\n    sx += 1\n    if sx >= NS\n      sx = 0\n      sy += 1\n      return false if sy >= NS\n    end\n  end\n  #p [sx, sy]\n\n  folded = NS.times.map{NS.times.map{false}}\n  folded[sy][sx] = true\n  sides = []\n  sides[ZM] = sts[sy][sx]\n  q = [[sx, sy, ZM, [XP, YM, XM, YP]]]\n\n  while ! q.empty?\n    x, y, sd, edges = q.shift\n\n    for d in (0..3)\n      x0 = x + DXYS[d][0]\n      y0 = y + DXYS[d][1]\n      if x0 >= 0 && x0 < NS && y0 >= 0 && y0 < NS &&\n          sts[y0][x0] != 0 && ! folded[y0][x0]\n        folded[y0][x0] = true\n\n        d2 = (d + 2) % 4\n        sd2 = (sd ^ 1)\n\n        sd0 = edges[d]\n        edges0 = edges.clone\n        edges0[d] = sd2\n        edges0[d2] = sd\n\n        return false if ! sides[sd0].nil?\n        sides[sd0] = sts[y0][x0]\n\n        sd1 = (sd0 ^ 1)\n        return false if ! sides[sd1].nil? && sides[sd0] + sides[sd1] != 7\n\n        q << [x0, y0, sd0, edges0]\n      end\n    end\n  end\n\n  for i in (0..5)\n    return false if sides[i].nil?\n  end\n\n  true\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  sts = []\n\n  sn = 0\n  dcnts = [0] * 7\n  invalid = false\n\n  NS.times do\n    ds = gets.split.map(&:to_i)\n    sts << ds\n\n    for d in ds\n      next if d == 0\n      sn += 1\n      invalid = true if dcnts[d] > 0\n      dcnts[d] += 1\n    end\n  end\n  #p sts\n  #p [invalid, dcnts]\n\n  if invalid || sn != 6\n    puts 'false'\n    next\n  end\n\n  puts (check_dice(sts) ? 'true' : 'false')\nend"
  },
  {
    "language": "Ruby",
    "code": "class Die\n  attr_accessor :front, :back, :top, :bottom, :left, :right\n  def initialize\n  @front, @back, @top, @bottom, @left, @right = 6.times.map{0}\n  end\n  def check?\n    return false if [@front, @back, @top, @bottom, @left, @right].any?(&:zero?)\n    return false unless [@front + @back, @left + @right, @top + @bottom].all?{|v| v == 7}\n    true\n  end\n  def rotate(direction)\n    case direction\n      when :top\n        @top, @front, @bottom, @back = @front, @bottom, @back, @top\n      when :bottom\n        @top, @front, @bottom, @back = @back, @top, @front, @bottom\n      when :clockwise\n        @left, @front, @right, @back = @front, @right, @back, @left\n      when :counterclockwise\n        @left, @front, @right, @back = @back, @left, @front, @right\n    end\n  end\nend\n\n@net = Array.new\n@die = Die.new\ndef dfs(i, j)\n  if (0 < j) && (@net[i][j - 1] != 0)\n    @die.rotate(:counterclockwise)\n    @die.front = @net[i][j - 1]\n    @net[i][j - 1] = 0\n    dfs(i, j - 1)\n    @die.rotate(:clockwise)\n  end\n  if (j + 1 < 5) && (@net[i][j + 1] != 0)\n    @die.rotate(:clockwise)\n    @die.front = @net[i][j + 1]\n    @net[i][j + 1] = 0\n    dfs(i, j + 1)\n    @die.rotate(:counterclockwise)\n  end\n  if (i + 1 < 5) && (@net[i + 1][j] != 0)\n    @die.rotate(:top)\n    @die.front = @net[i + 1][j]\n    @net[i + 1][j] = 0\n    dfs(i + 1, j)\n    @die.rotate(:bottom)\n  end\nend\n\ngets.to_i.times do\n  @die = Die.new\n  @net = Array.new\n  count = Hash.new{0}\n  5.times do @net << gets.split.map(&:to_i) end\n  5.times do |i|\n    5.times do |j|\n      v = @net[i][j]\n      next if v.zero?\n      count[v] += 1\n    end\n  end\n  unless (1..6).all?{|n| count[n] == 1} # 1-6が不揃い\n    puts \"false\"\n    next\n  end\n  5.times do |i|\n    5.times do |j|\n      next if @net[i][j].zero?\n      @die.front = @net[i][j]\n      @net[i][j] = 0\n      dfs(i, j)\n    end\n  end\n  puts @die.check? ? \"true\" : \"false\"\nend"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef op(v1,v2):\n    vr=(v1[1]*v2[2]-v1[2]*v2[1], v1[2]*v2[0]-v1[0]*v2[2],  v1[0]*v2[1]-v1[1]*v2[0])\n    if vr==(0,0,0):\n        return v1\n    else:\n        return vr\n\nclass Dice:\n    def __init__(self):\n        self.vlist=[(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)]\n        self.face={}\n        self.nums=[]\n        for i in (-1,1):\n            self.face[(i,0,0)]=0\n            self.face[(0,i,0)]=0\n            self.face[(0,0,i)]=0\n    def rotate(self,v2):\n        Nd=copy.deepcopy(self.face)\n        for v in self.vlist:\n            nv=op(v,v2)\n            Nd[nv]=self.face[v]\n        self.face=copy.deepcopy(Nd)\n        #self.top=op(self.top,v2)\n    def fill(self,n):\n        self.face[(1,0,0)]=n\n        self.nums.append(n)\n    def check(self):\n        ans=1\n        if len(self.nums)!=6:\n            ans=0\n        else:\n            for i in range(1,7):\n                if i not in self.nums:\n                    ans=0\n            if (self.face[(-1,0,0)]+self.face[(1,0,0)]!=7 or self.face[(0,-1,0)]+self.face[(0,1,0)]!=7 or self.face[(0,0,-1)]+self.face[(0,0,1)]!=7):\n                ans=0\n        return ans\n        \ndef fd(D,A,i,j):\n    if A[i][j]!=0:\n        D.fill(A[i][j])\n        dt=D.vlist\n        A[i][j]=0\n        if A[i-1][j]!=0:\n            D.rotate((0,-1,0))\n            fd(D,A,i-1,j)\n        if A[i+1][j]!=0:\n            D.rotate((0,1,0))\n            fd(D,A,i+1,j)    \n        if A[i][j-1]!=0:\n            D.rotate((0,0,1))\n            fd(D,A,i,j-1)\n        if A[i][j+1]!=0:\n            D.rotate((0,0,-1))\n            fd(D,A,i,j+1)\n        D.vlist=dt\n\n    \nN=int(raw_input())\nfor p in range(N):\n    A=[[0 for i in range(7)] for j in range(7)]\n    D=Dice()\n    for i in range(1,6):\n        A[i][1:6]=[int(x) for x in raw_input().split()]\n    for i in range(7):\n        for j in range(7):\n            if A[i][j]!=0:\n                fd(D,A,i,j)\n    if D.check():\n        print 'true'\n    else:\n        print 'false'"
  },
  {
    "language": "Rust",
    "code": "use std::ascii::AsciiExt;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Position {\n    x: i32, y: i32\n}\nimpl Position {\n    fn right(&self) -> Position {\n        Position{x: self.x + 1, y: self.y}\n    }\n    fn left(&self) -> Position {\n        Position{x: self.x - 1, y: self.y}\n    }\n    fn up(&self) -> Position {\n        Position{x: self.x, y: self.y - 1}\n    }\n    fn down(&self) -> Position {\n        Position{x: self.x, y: self.y + 1}\n    }\n}\n#[derive(Copy, Clone, Debug)]\nstruct Dice {\n    top: usize, up: usize, right: usize,\n    position: Position\n}\nimpl Dice {\n    fn all_type(position: Position) -> Vec<Dice> {\n        vec![Dice{top: 1, up: 2, right: 3, position: position}, Dice{top: 1, up: 3, right: 2, position: position}]\n    }\n    fn all_faces(&self) -> Vec<Dice> {\n        let mut result = vec![*self];\n        for i in 0 .. 5 {\n            let l = if i & 1 == 0 {\n                Dice{top: 7 - result[i].right, up: result[i].up, right: result[i].top, position: self.position}\n            }else {\n                Dice{top: 7 - result[i].up, up: result[i].top, right: result[i].right, position: self.position}\n            };\n            result.push(l);\n        }\n        result\n    }\n    fn twisted(&self) -> Vec<Dice> {\n        let mut result = vec![*self];\n        for i in 0 .. 3 {\n            let l = result[i].rotate_clockwise();\n            result.push(l);\n        }\n        result\n    }\n    fn new(top: usize, position: Position) -> Vec<Dice> {\n        Dice::all_type(position).into_iter().flat_map(|dice| dice.all_faces().into_iter().filter(|d| d.top == top)).into_iter().flat_map(|d| d.twisted()).collect()\n    }\n    fn all_next(&self) -> Vec<Dice> {\n        vec![self.rotate_up(), self.rotate_right(), self.rotate_left(), self.rotate_down()]\n    }\n    fn rotate_up(&self) -> Dice {\n        Dice{top: 7 - self.up, up: self.top, right: self.right, position: self.position.up()}\n    }\n    fn rotate_right(&self) -> Dice {\n        Dice{top: 7 - self.right, up: self.up, right: self.top, position: self.position.right()}\n    }\n    fn rotate_down(&self) -> Dice {\n        Dice{top: self.up, up: 7 - self.top, right: self.right, position: self.position.down()}\n    }\n    fn rotate_left(&self) -> Dice {\n        Dice{top: self.right, up: self.up, right: 7 - self.top, position: self.position.left()}\n    }\n    fn rotate_clockwise(&self) -> Dice {\n        Dice{top: self.top, up: 7 - self.right, right: self.up, position: self.position}\n    }\n}\nfn exists_all_face_once(state: &Vec<Vec<usize>>) -> bool {\n    let mut count = vec![0usize; 7];\n    for line in state {\n        for &c in line {\n            count[c] += 1;\n        }\n    }\n    count[1..].iter().all(|&c| c == 1)\n}\n\nfn can_put(state: &Vec<Vec<usize>>) -> bool {\n    if !exists_all_face_once(state) {return false;}\n    let &(r, c) = (0 .. state.len()).into_iter().flat_map(|y| (0 .. state[y].len()).into_iter().map(|x| (y, x)).find(|&(y, x)| state[y][x] == 1)).collect::<Vec<_>>().first().unwrap();\n    for start in Dice::new(1, Position{x: c as i32, y: r as i32}) {\n        let mut stack = vec![start];\n        let mut is_appear = vec![vec![false; state[0].len()]; state.len()];\n        is_appear[r][c] = true;\n        while let Some(top) = stack.pop() {\n            for next in top.all_next() {\n                if next.position.y < 0 || state.len() as i32 <= next.position.y || next.position.x < 0 || state[next.position.y as usize].len() as i32 <= next.position.x {continue;}\n                if is_appear[next.position.y as usize][next.position.x as usize] {continue;}\n                if state[next.position.y as usize][next.position.x as usize] != next.top { continue; }\n                is_appear[next.position.y as usize][next.position.x as usize] = true;\n                stack.push(next);\n            }\n        }\n        if is_appear.into_iter().map(|line| line.into_iter().filter(|&b| b).count()).sum::<usize>() == 6 {\n            return true\n        }\n    }\n    false\n}\n\nfn main() {\n    read!(n: usize);\n    for _ in 0 .. n {\n        read!(state: [[usize]; 5]);\n        println!(\"{}\", if can_put(&state) {\"true\"} else {\"false\"});\n    }\n}\n"
  }
]