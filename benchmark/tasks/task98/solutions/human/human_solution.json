[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint w,h;\nint sx,sy,gx,gy;\nint n;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nbool used[120][120];\nint f[120][120];\nvoid set(int c,int d,int x,int y)\n{\n\tif(d==0)\n\t{\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nbool judge()\n{\n\tif(f[sx][sy]!=f[gx][gy])return false;\n\tmemset(used,false,sizeof(used));\n\tqueue<P> q;\n\tq.push(mp(sx,sy));\n\tused[sx][sy]=true;\n\twhile(!q.empty())\n\t{\n\t\tP a=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nx=a.fi+dx[i],ny=a.sec+dy[i];\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)continue;\n\t\t\tif(used[nx][ny]||f[nx][ny]!=f[a.fi][a.sec])continue;\n\t\t\tif(nx==gx&&ny==gy)return true;\n\t\t\tused[nx][ny]=true;\n\t\t\tq.push(mp(nx,ny));\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(w==0&&h==0)break;\n\t\tscanf(\"%d %d\",&sy,&sx);\n\t\tscanf(\"%d %d\",&gy,&gx);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&y,&x);\n\t\t\tset(c,d,x,y);\n\t\t}\n\t\tif(judge())puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[128][128];\nbool mem[128][128];\nint xg,yg;\nint w,h;\nvoid dfs(int x,int y,int col){\n    if(x < 1 || y < 1 || x > w || y > h)return ;\n    if(mem[y][x])return ;\n    if(stage[y][x] != col)return ;\n    mem[y][x] = true;\n    rep(i,4){\n        if(col == stage[y+dy[i]][x+dx[i]]){\n            dfs(x + dx[i], y + dy[i], col);\n        }\n    }\n    return ;\n}\nint main(){\n    while(scanf(\"%d%d\",&w,&h),w|h){\n        memset(stage,0,sizeof(stage));\n        rep(i,128)rep(j,128)mem[i][j] = false;\n        int xs,ys;\n        scanf(\"%d%d\",&xs,&ys);\n        scanf(\"%d%d\",&xg,&yg);\n         \n        int n;\n        scanf(\"%d\",&n);\n \n        rep(q,n){\n            int c,d,x,y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            if(d == 0){\n                reps(i,x,x+4){\n                    reps(j,y,y+2){\n                        stage[j][i] = c;\n                    }\n                }\n            }\n            else{\n                reps(i,x,x+2){\n                    reps(j,y,y+4){\n                        stage[j][i] = c;\n                    }\n                }\n            }\n        }\n        dfs(xs,ys,stage[ys][xs]);\n        bool f = mem[yg][xg];\n        (f) ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y, color;\n\tvector< vector< int > > field;\n\tqueue< complex< int > > que;\n\tbool exist;\n\t\n\twhile(cin >> w >> h, w){\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\tfield.resize(w);\n\t\tfor(int i = 0; i < w; ++i) field[i].resize(h);\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 2; ++j){\n\t\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\texist = false;\n\t\tif(field[xs - 1][ys - 1] != 0){\n\t\t\tque.push(complex< int >(xs - 1, ys - 1));\n\t\t\tcolor = field[xs - 1][ys - 1];\n\t\t\t\n\t\t\twhile(!que.empty()){\n\t\t\t\tcomplex< int > pos = que.front();\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tif(pos.real() == xg - 1 && pos.imag() == yg - 1){\n\t\t\t\t\texist = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.real() > 0 && field[pos.real() - 1][pos.imag()] == color) que.push(pos + complex< int >(-1, 0));\n\t\t\t\tif(pos.real() < w - 1 && field[pos.real() + 1][pos.imag()] == color) que.push(pos + complex< int >(1, 0));\n\t\t\t\tif(pos.imag() > 0 && field[pos.real()][pos.imag() - 1] == color) que.push(pos + complex< int >(0, -1));\n\t\t\t\tif(pos.imag() < h - 1 && field[pos.real()][pos.imag() + 1] == color) que.push(pos + complex< int >(0, 1));\n\t\t\t\t\n\t\t\t\tfield[pos.real()][pos.imag()] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (exist ? \"OK\" : \"NG\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define dr direction\n#define cl color\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nclass Block{\npublic:\n    int color;// 1~5\n    int direction;// 0:-, 1:|\n    int x, y;\n    void init(int c, int d, int xx, int yy);\n};\n\nvoid Block::init(int c, int d, int xx, int yy){\n    color=c;\n    direction=d;\n    x=xx;\n    y=yy;\n}\n\nint w, h, xs, ys, xg, yg, n;\nint fld[100][100], dis[100][100];\nconst pii dxdy[]={{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nconst int inf=1e8;\n\nstring solve(){// bfs\n    queue<pii> qu;\n    qu.push(make_pair(ys, xs));\n    int C=fld[ys][xs];\n    fill(dis[0], dis[100], inf);\n    dis[ys][xs]=0;\n\n    if(C==0) return \"NO\";\n    while(!qu.empty()){\n        pii now=qu.front(); qu.pop();\n        if(now.fi==yg&&now.se==xg){\n            return \"OK\";\n        }\n\n        for(int k=0; k<4; k++){\n            pii nx=make_pair(now.fi+dxdy[k].fi, now.se+dxdy[k].se);\n            if(!(0<=nx.fi&&nx.fi<h&&0<=nx.se&&nx.se<w)) continue;\n            if(fld[nx.fi][nx.se]!=C) continue;\n            if(dis[nx.fi][nx.se]!=inf) continue;\n\n            dis[nx.fi][nx.se]=dis[now.fi][now.se]+1;\n            qu.push(nx);\n        }\n    }\n\n    return \"NO\";\n}\n\nint main(){\n\n    while(1){\n        cin>> w>> h;\n        if(w==0&&h==0) break;\n        cin>> xs>> ys>> xg>> yg>> n;\n        xs--; ys--; xg--; yg--;\n        Block block[n];\n        for(int i=0; i<n; i++){\n            int c, d, xx, yy;\n            cin>> c>> d>> xx>> yy;\n            xx--; yy--;\n            block[i].init(c, d, xx, yy);\n        }\n\n        // make field\n        fill(fld[0], fld[100], 0);\n        for(int k=0; k<n; k++){\n            int X=block[k].x, Y=block[k].y;\n            if(block[k].dr==0){\n                for(int i=0; i<2; i++){\n                    for(int j=0; j<4; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }else{\n                for(int i=0; i<4; i++){\n                    for(int j=0; j<2; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }\n        }\n/*\n        for(int i=0; i<w; i++){\n            for(int j=0; j<h; j++){\n                cout<< fld[i][j]<<\" \";\n            }\n            cout<< endl;\n        }\n//*/\n        cout<< solve()<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nint w, h;\nint xs, ys, xg, yg, n, c, d, x, y;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid put_b(int a[][105]) {\n  int X, Y;\n  if(d == 0) X = 4, Y = 2;\n  else X = 2, Y = 4 ;\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j < X; j++)\n      a[y + i][x + j] = c;\n}\n\nbool bfs(int a[][105]) {\n  int cs = a[ys][xs];\n  if(cs != a[yg][xg]) return false;\n\n  cout << ys << xs << endl;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while(que.size()) {\n    P p = que.front();\n    que.pop();\n    if(p.first == xg && p.second == yg) return true;\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second +dy[i];\n      if(0 < nx && nx <= w && 0 < ny && ny <= h && a[ny][nx] == cs) {\n\tque.push(P(nx, ny));\n\ta[ny][nx] = 0;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  while(cin >> w >> h, w != 0 || h != 0) {\n    int a[105][105] = {};\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n  \n    while(n--) {\n      cin >> c >> d >> x >> y;\n      put_b(a);\n    }\n    \n    /*  for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++)\n      cout << a[i][j];\n      cout << endl;\n      }*/\n    if(bfs(a) == true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n#include <queue>\n#include <complex>\n#include <climits>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint maze[110][110];\nint f[110][110];\nint w, h, xs, ys, xg, yg, res = 0;\nint color;\n\nvoid dfs(int cx, int cy){\n\tif(f[cx][cy]) return ;\n\tf[cx][cy] = 1;\n\tif(cx == xg && cy == yg){\n\t\tres = 1;\n\t\treturn ;\n\t}\n\tfor(int dx=-1; dx<=1; ++dx){\n\t\tfor(int dy=-1; dy<=1; ++dy){\n\t\t\tif(abs(dx-dy) != 1) continue;\n\t\t\tint nx = cx + dx, ny = cy + dy;\n\t\t\tif(maze[nx][ny] == color){\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<110; ++i){\n\t\t\tfor(int j=0; j<110; ++j){\n\t\t\t\tmaze[i][j] = 0;\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j=y; j<=y+1; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+3; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d == 1){\n\t\t\t\tfor(int j=y; j<=y+3; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+1; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor = maze[xs][ys];\n\t\tif(color == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(xs, ys);\n\n\t\tif(res){\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0,w,h;\nint block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nint block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nint map[size_max][size_max];\n\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\n\nvoid chek(int w, int h)\n{\n\tint i, j;\n\tfor (i = 0; i <= h + 1; i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue<PR> QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t//\tchek(w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = map[ys][xs];\n\n\t\tnow = make_pair(ys, xs);\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] == -1)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = make_pair(now.Y + my[i], now.X + mx[i]);\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint b[100][100];\nint vis[100][100];\n\nint w, h;\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w + h) {\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\txs--, ys--, xg--, yg--;\n\n\t\tmemset(b, 0, sizeof b);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--, y--;\n\t\t\tint H = 2, W = 4;\n\t\t\tif(d == 1) swap(H, W);\n\t\t\tfor(int dx = 0; dx < W; dx++) {\n\t\t\t\tfor(int dy = 0; dy < H; dy++) {\n\t\t\t\t\tb[y + dy][x + dx] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(b[ys][xs] == 0 || b[ys][xs] != b[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push({ xs, ys });\n\t\tmemset(vis, 0, sizeof vis);\n\t\tvis[ys][xs] = 1;\n\t\twhile(q.size()) {\n\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\tq.pop();\n\t\t\tint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(in(nx, ny) && b[y][x] == b[ny][nx] && vis[ny][nx] == 0) {\n\t\t\t\t\tvis[ny][nx] = 1;\n\t\t\t\t\tq.push({ nx, ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vis[yg][xg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, w, h, xs, ys, xg, yg, f[105][105] = { 0 }, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, used[105][105] = { 0 };\nbool flag;\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (xg == nx&&yg == ny) {\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif (used[ny][nx]) continue;\n\t\tif (1 <= nx&&nx <= w && 1 <= ny&&ny <= h&&f[ny][nx]>0) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused[ys][xs] = 1;\n\t\tdfs(ys, xs);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x][i, y]\nbool isOK;\nint xs, ys, xg, yg;\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;\n        for(int i=0;i<102;i++){\n            for(int j=0;j<102;j++)\n                Board[j][i] = 0;\n        }\n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2, hb = 2;\n            d?hb:wb = 4;\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint w,h;\nint sx,sy;\nint gx,gy;\nint n;\n\nvector<vector<int>> field;\nint de[] = {1, 0, -1, 0};\n\nvoid dfs(int x ,int y, int c) {\n  if(x < 1 || x > w || y < 1 || y > h || field[x][y] != c) return;\n  field[x][y] = -1;\n  dfs(x + 1, y, c);\n  dfs(x - 1, y, c);\n  dfs(x, y + 1, c);\n  dfs(x, y - 1, c);\n}\n\nint main() {\n  while(cin >> w >> h, w && h) {\n    field.assign(101, vector<int>(101, 0));\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n    int dd[] = {4, 2};\n    for(int i = 0;i < n;i++) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      for(int xx = x; xx < x + dd[d];xx++) {\n        for(int yy = y;yy < y + dd[d ^ 1];yy++) {\n          field[xx][yy] = c;\n        }\n      }\n    }\n    if(field[sx][sy] == 0) {\n      cout << \"NG\" << endl;\n      continue;\n    }\n    dfs(sx, sy, field[sx][sy]);\n    if(field[gx][gy] == -1) {\n      cout << \"OK\" << endl;\n    }\n    else {\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nint di[] = {1, 0, -1, 0}, dj[] = {0, 1, 0, -1};\n\nvoid solve() {\n  int w, h;\n  while (cin >> w >> h, w) {\n    int sx, sy, gx, gy, n;\n    cin >> sx >> sy >> gx >> gy >> n;\n    sx--, sy--, gx--, gy--;\n    vvi v(h, vi(w));\n    rep(i, n) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--;\n      y--;\n      rep(i, 2 + d * 2) rep(j, 4 - d * 2) v[y + i][x + j] = c;\n    }\n    int roadColor = v[sy][sx];\n    function<bool(int, int)> dfs = [&](int i, int j) {\n      if (i < 0 || j < 0 || i >= h || j >= w || v[i][j] != roadColor) return false;\n      if (i == gy && j == gx) return true;\n      v[i][j] = -1;\n      bool b  = false;\n      rep(k, 4) b |= dfs(i + di[k], j + dj[k]);\n      return b;\n    };\n    cout << (dfs(sy, sx) ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint map[128][128];\nint sx, sy, gx, gy;\nint sc;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool dfs(int ty, int tx)\n{\n\tif (ty == gy && tx == gx){\n\t\treturn (true);\n\t}\n\t\n\tmap[ty][tx] = -1;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tif (map[ty + dy[i]][tx + dx[i]] == sc){\n\t\t\tif (dfs(ty + dy[i], tx + dx[i]) == true){\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (false);\n}\n\nint main()\n{\n\tint w, h;\n\tint n;\n\t\n\twhile (scanf(\"%d %d\", &w, &h) && w){\n\t\tmemset(map, -1, sizeof(map));\n\t\tscanf(\"%d %d\", &sx, &sy);\n\t\tscanf(\"%d %d\", &gx, &gy);\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint col, dir, tx, ty;\n\t\t\tscanf(\"%d %d %d %d\", &col, &dir, &tx, &ty);\n\t\t\tif (dir == 0){\n\t\t\t\tfor (int dy = 0; dy < 2; dy++){\n\t\t\t\t\tfor (int dx = 0; dx < 4; dx++){\n\t\t\t\t\t\tmap[ty + dy][tx + dx] = col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int dy = 0; dy < 4; dy++){\n\t\t\t\t\tfor (int dx = 0; dx < 2; dx++){\n\t\t\t\t\t\tmap[ty + dy][tx + dx] = col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc = map[sy][sx];\n\t\tprintf(\"%s\\n\", ~sc && dfs(sy, sx) == true ? \"OK\" : \"NG\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nconst float PI = 3.1415926;\nstatic const int INFTY = (1<<30);\n\nusing namespace std;\n\nint B[102][102];\nint M[102][102];\nint w, h, xs, ys, xg, yg, n, res;\n \nvoid bfs(int x, int y, int c) {\n  if(x <= 0 || y <= 0 || x > w || y > h)\n    return;\n  if(B[x][y] != c)\n    return;\n  if(M[x][y] == 1) {\n    return;\n  } else {\n    M[x][y] = 1;\n  }\n  if(x == xg && y == yg) {\n    res = 1;\n    return; \n  }\n  bfs(x+1, y, c);\n  bfs(x, y+1, c);\n  bfs(x-1, y, c);\n  bfs(x, y-1, c);\n}\n\nint main() {\n  while(cin >> w >> h, w) {\n    // ?????????\n    rep(i, w) {\n      rep(j, h) {\n        B[i][j] = 0;\n        M[i][j] = 0;\n      }\n    }\n    res = 0;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    // ??????????????????\n    rep(i, n) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      \n      B[x][y] = c;\n      B[x+1][y] = c;\n      B[x][y+1] = c;\n      B[x+1][y+1] = c;\n      if ( d == 0 ) {\n        B[x+2][y] = c;\n        B[x+3][y] = c;\n        B[x+2][y+1] = c;\n        B[x+3][y+1] = c;\n      } else {\n        B[x][y+2] = c;\n        B[x][y+3] = c;\n        B[x+1][y+2] = c;\n        B[x+1][y+3] = c;\n      }        \n    }\n    bfs(xs, ys, B[xs][ys]);\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nbool dfs(vector<vector<int> > &g);\n\nint sx, sy, gx, gy;\nint w, h;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint main()\n{\n\n    while (cin >> w >> h, (w|h) ) {\n        w++;\n        h++;\n        vector<vector<int> > graph(w, vector<int>(h, 0));\n        cin >> sx >> sy >> gx >> gy;\n        int blocks;\n        cin >> blocks; \n        loop(i, blocks){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if (d) {\n                for (int j = x; j < x+2; j++) {\n                    for (int k = y; k < y+4; k++) {\n                        graph[j][k] = c;\n                    }\n                }\n            } else {\n                for (int j = x; j < x+4; j++) {\n                    for (int k = y; k < y+2; k++) {\n                        graph[j][k] = c;\n                    }\n                }\n            }\n        }\n        cout << ((dfs(graph))?\"OK\":\"NG\") << endl;\n    }\n    return 0;\n}\n\nbool dfs(vector<vector<int> > &g)\n{\n    int cl = g[sx][sy];\n    vector<vector<bool> > check(w, vector<bool>(h, false));\n    queue<i_i > q;\n    q.push(mp(sx,sy));\n    while(!q.empty()){\n        int x = q.front().first, y = q.front().second;\n        q.pop();\n        if(x == gx && y == gy){\n            return true;\n        }\n        if(check[x][y]){\n            continue;\n        } else {\n            check[x][y] = true;\n        }\n\n        loop(i, 4) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (0 < nx && nx < w && 0 < ny && ny < h){\n                if (g[nx][ny] == cl){\n                    q.push(mp(nx,ny));\n                }\n            }\n        }\n\n    }\n    return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\nstring res = \"NG\";\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i)).at(y+j) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  int temp = board[nx][ny];\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && temp==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && temp==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && temp==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && temp==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      --object[i].x; --object[i].y;\n      object[i].write(board);\t    \n    }\n    func(board,xs,ys);\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint x[MAX_N][MAX_N], y[MAX_N][MAX_N];\nint H, W, N, X, Y, C, D, SX, SY, GX, GY;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) { break; }\n\t\tcin >> SX >> SY >> GX >> GY >> N;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = 0; y[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tif (D == 0) {\n\t\t\t\tfor (int j = Y; j < Y + 2; j++) {\n\t\t\t\t\tfor (int k = X; k < X + 4; k++) {\n\t\t\t\t\t\tx[j][k] = C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (D == 1) {\n\t\t\t\tfor (int j = Y; j < Y + 4; j++) {\n\t\t\t\t\tfor (int k = X; k < X + 2; k++) {\n\t\t\t\t\t\tx[j][k] = C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> >Q; Q.push(make_pair(SY, SX)); y[SY][SX] = 1;\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint a1 = pa.first; int a2 = pa.second;\n\t\t\tif (y[a1 - 1][a2] == 0 && a1 - 1 >= 1 && x[a1][a2] == x[a1 - 1][a2]) { y[a1 - 1][a2] = 1; Q.push(make_pair(a1 - 1, a2)); }\n\t\t\tif (y[a1 + 1][a2] == 0 && a1 + 1 <= H && x[a1][a2] == x[a1 + 1][a2]) { y[a1 + 1][a2] = 1; Q.push(make_pair(a1 + 1, a2)); }\n\t\t\tif (y[a1][a2 - 1] == 0 && a2 - 1 >= 1 && x[a1][a2] == x[a1][a2 - 1]) { y[a1][a2 - 1] = 1; Q.push(make_pair(a1, a2 - 1)); }\n\t\t\tif (y[a1][a2 + 1] == 0 && a2 + 1 <= W && x[a1][a2] == x[a1][a2 + 1]) { y[a1][a2 + 1] = 1; Q.push(make_pair(a1, a2 + 1)); }\n\t\t}\n\t\tif (y[GY][GX] == 1) { cout << \"OK\" << endl; }\n\t\tif (y[GY][GX] == 0) { cout << \"NG\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n&#160;\nusing namespace std;\n&#160;\nint map[101][101];\nint xg, yg;\nint w, h;\nint col;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nbool flag;\n&#160;\nvoid dfs(int x, int y)\n{\n&#160;&#160;&#160;&#160;map[y][x] = 0;\n&#160;\n&#160;&#160;&#160;&#160;if (x == xg && y == yg) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag = true;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ;\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;for (int i = 0; i < 4; i++) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int nx = x + dx[i];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int ny = y + dy[i];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (map[ny][nx] == col)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dfs(nx, ny);\n&#160;&#160;&#160;&#160;}\n}\n&#160;\nvoid setblock(int c, int d, int bx, int by)\n{\n&#160;&#160;&#160;&#160;int wlim = 4, hlim = 2;\n&#160;\n&#160;&#160;&#160;&#160;if (d == 1) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wlim = 2;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hlim = 4;\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;for (int y = 0; y < hlim; y++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int x = 0; x < wlim; x++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;map[by + y][bx + x] = c;\n}\n&#160;\n&#160;\nint main()\n{\n&#160;&#160;&#160;&#160;while (cin >> w >> h, w || h) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int xs, ys;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int n;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int y = 0; y < h; y++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int x = 0; x < w; x++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;map[y][x] = 0;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin >> xs >> ys >> xg >> yg >> n;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xs--, ys--, xg--, yg--;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i < n; i++) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int c, d, x, y;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin >> c >> d >> x >> y;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x--, y--;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;setblock(c, d, x, y);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;col = map[ys][xs];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag = false;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (col)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dfs(xs, ys);\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (flag)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << \"OK\" << endl;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << \"NG\" << endl;\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nint Block(int,int);\nint c,d,x,y,xg,yg,w,h,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(Block(xs,ys))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nint Block(int X,int Y)\n{\n\t\n\t//printf(\"%d\",M);\n\tprintf(\"%d %d\\n\",X,Y);\n\tif(X == xg && Y == yg)\n\t\treturn 1;\n\tif(MAP[Y][X] != M || MF[Y][X] == 1 || X < 1 || Y < 1 || X > w || Y > h) return 0;\n\tMF[Y][X] = 1;\n\treturn Block(X,Y-1) || Block(X,Y+1) || Block(X-1,Y) || Block(X+1,Y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint N;\nint W,H;\npair<int,int>s;\npair<int,int>g;\nint sc;\nint map[103][103]={0};\nbool flag[103][103]={0};\nint ans=0;\n\nbool se(int x,int y){\n\tif(x==g.first && y==g.second)ans=1;\n\tfor(int i=0;i<4;i++){\n\t\tint xx=x+dx[i];\n\t\tint yy=dy[i]+y;\n\t\tif(xx>=0 &&yy>=0 &&xx<W &&yy<H && sc==map[xx][yy]&& flag[xx][yy]==0){\n\t\t\tflag[xx][yy]=1;\n\t\t\tse(xx,yy);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\t\n\twhile(cin>>W>>H>>s.first>>s.second>>g.first>>g.second>>N,H,W){\n\t\tint d,c,x,y;\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tsc=map[s.first][s.second];\n\t\tflag[s.first][s.second]=1;\n\t\t\n\t\tse(s.first,s.second);\n\t\tif(ans)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\tans=0;\n\t\tint map[103][103]={0};\n\t\tbool flag[103][103]={0};\n\t\t/*\n\t\tif(se(s.first,s.second))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t*/\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nconst int dy[4] = {-1, 1, 0, 0};\nconst int dx[4] = {0, 0, -1, 1};\nconst int MAX_W = 102, MAX_H = 102;\nint maze[MAX_H][MAX_W];\nint w, h, xs, ys, xg, yg, color;\n\nvoid solve() {\n  memset(maze, 0, sizeof maze);\n  int n;\n  cin>>xs>>ys>>xg>>yg>>n;\n  rep(i,n) {\n    int c, d, x, y;\n    cin>>c>>d>>x>>y;\n    //cout<<c<<d<<x<<y<<endl;\n    if (d == 0) {\n      REP(j,x,x+4) REP(k,y,y+2) maze[k][j] = c;\n    } else {\n      REP(j,x,x+2) REP(k,y,y+4) maze[k][j] = c;\n    }\n  }\n  \n  /*\n  rep(i,h+1) {\n    rep(j,w+1) cout<<maze[i][j];\n    cout<<endl;\n  }*/\n  \n  if (maze[ys][xs] == 0) {\n    cout<<\"NG\"<<endl;\n    return;\n  } else {\n    color = maze[ys][xs];\n  }\n  \n  bool flag = false;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while (!que.empty() && !flag) {\n    P p = que.front(); que.pop();\n    int tx = p.first, ty = p.second;\n    if (tx == xg && ty == yg) {\n      flag = true; continue;\n    }\n    if (maze[ty][tx] == 0) continue;\n    maze[ty][tx] = 0;\n    \n    rep(z,4) {\n      int ttx = tx + dx[z], tty = ty + dy[z];\n      if (ttx < 1 || tty < 1 || ttx >= w || tty >= h) continue;\n      if (maze[tty][ttx] != color) continue;\n      que.push(P(ttx, tty));\n    }\n  }\n  \n  if (flag) {\n    cout<<\"OK\"<<endl;\n  } else {\n    cout<<\"NG\"<<endl;\n  }\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>w>>h, w||h) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define BLANK 0\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nbool dfs(int color, int x, int y, int gx, int gy, vector<vector<int> >& blocks){\n  if(x == gx && y == gy){ return true; }\n  blocks[x][y] = BLANK;\n  for(int i = 0; i < 4; i++)\n    if(blocks[x + dx[i]][y + dy[i]] == color)\n      if(dfs(color, x + dx[i], y + dy[i], gx, gy, blocks))\n        return true;\n  return false;\n}\n\n\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n    int sx ,sy, gx, gy;\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n\n    int n;\n    cin >> n;\n\n    vector<vector<int> > blocks(w + 2, vector<int>(h + 2, BLANK));\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      int now_w = (d == 0) ? 4 : 2;\n      int now_h = (d == 0) ? 2 : 4;\n      for(int j = 0; j < now_w; j++)\n        for(int k = 0; k < now_h; k++)\n          blocks[x + j][y + k] = c;\n    }\n\n    // ????????????\n    if(blocks[sx][sy] == BLANK){\n      cout << \"NG\" << endl;\n      return 0;\n    }\n\n    // ??????\n    if(dfs(blocks[sx][sy], sx, sy, gx, gy, blocks)){ cout << \"OK\" << endl; }\n    else{ cout << \"NG\" << endl; }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<cstdio>\nusing namespace std;\n\n#define X_MAX 100+10\n#define Y_MAX 100+10\n\n#define Vertical 1\n#define Horizontal 0\n\nint my[4] = { 1,-1,0,0 };\nint mx[4] = { 0,0,1,-1 };\n\nstruct ST\n{\n\tint came[Y_MAX][X_MAX];\n\tint now_y;\n\tint now_x;\n};\n\n\nvoid paint_V(int*map , int col)\n{\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\nvoid paint_H(int*map, int col)\n{\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\n\nvoid chek(int map[Y_MAX][X_MAX],int lx,int ly)\n{\n\tint i, j;\n\tfor (i = 0; i <= ly+1;i++)\n\t{\n\t\tfor (j = 0; j <= lx+1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nint main(void)\n{\n\tST an = {0}, tmp;\n\tstack<ST> ma;\n\n\tint lx, ly, n;\n\tint sx, sy, gx, gy;\n\tint col, VorH,set_x,set_y;\n\tint i, j;\n\n\twhile ((cin >> lx >> ly), lx!=0&&ly!=0)\n\t{\n\t\tint goal = 0;\n\t\tint map[Y_MAX][X_MAX] = { 0 };\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> col >> VorH >> set_x >> set_y;\n\t\t\tif (VorH == Vertical)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_V(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_H(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s_col = map[sy][sx];\n\t\tif (s_col == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tan.now_y = sy;\n\t\tan.now_x = sx;\n\t\tma.push(an);\n\n\t\t//chek(map, lx, ly);\n\n\t\twhile (!ma.empty())\n\t\t{\n\t\t\tan = ma.top();\n\t\t\tma.pop();\n\t\t\tan.came[an.now_y][an.now_x] = 1;\n\n\t\t\t//printf(\"y=%d,x=%d\\n\", an.now_y, an.now_x);\n\t\t\t//chek(an.came, lx, ly);\n\n\t\t\tif (an.now_y == gy && an.now_x == gx)\n\t\t\t{\n\t\t\t\tgoal = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp = an;\n\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (map[an.now_y + my[i]][an.now_x + mx[i]] == s_col && an.came[an.now_y + my[i]][an.now_x + mx[i]] == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp.now_y = an.now_y + my[i];\n\t\t\t\t\ttmp.now_x = an.now_x + mx[i];\n\t\t\t\t\tma.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (goal == 1)\n\t\t{\n\t\t\twhile (!ma.empty())\n\t\t\t{\n\t\t\t\tma.pop();\n\t\t\t}\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define MAX 101\n\nusing namespace std;\n\nint field[MAX][MAX];\nint w, h;\nint sx, sy, gx, gy;\nint scol;\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nbool dfs(int x, int y) {\n\tfield[y][x] = 0;\n\tif(x == gx && y == gy) return true;\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx <= w && nx > 0 && ny <= h && ny > 0) {\n\t\t\tif(field[ny][nx] == scol) dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tint n;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(i, n) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\trep(i, (d ? 4 : 2)) rep(j, (d ? 2 : 4)) field[y + i][x + j] = c;\n\t\t}\n\t\trep(i, h) {\n\t\t\trep(j, w) cout << field[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\tscol = field[sy][sx]; \n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tboard[i][j]=0;\n\tcheak[i][j]=0;\n      }\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    if(dfs(xs-1,ys-1)==true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==board[ys][xs] && cheak[yn][xn]==0){\n      if(dfs(xn,yn)==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint width,height,table[100][100];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= height-1 && col >= 0 && col <= width-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int row,int col){\n\tint tmp = table[row][col];\n\ttable[row][col] = 7;\n\n\tif(rangeCheck(row-1,col) == true && table[row-1][col] == tmp)recursive(row-1,col);\n\tif(rangeCheck(row+1,col) == true && table[row+1][col] == tmp)recursive(row+1,col);\n\tif(rangeCheck(row,col-1) == true && table[row][col-1] == tmp)recursive(row,col-1);\n\tif(rangeCheck(row,col+1) == true && table[row][col+1] == tmp)recursive(row,col+1);\n}\n\nint main(){\n\n\tint x_s,y_s,x_g,y_g,n,color,dist,x,y;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&width,&height);\n\t\tif(width == 0 && height == 0)break;\n\n\t\tfor(int i = 0; i < height; i++)\n\t\t{\n\t\t\tfor(int k = 0; k < width; k++)table[i][k] = 0;\n\t\t}\n\n\t\tscanf(\"%d %d\",&x_s,&y_s);\n\t\tscanf(\"%d %d\",&x_g,&y_g);\n\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d %d %d\",&color,&dist,&x,&y);\n\n\t\t\tif(dist == 0){\n\t\t\t\tfor(int row = 0; row < 2; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\ttable[y-1+row][x-1+col] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 2; col++){\n\t\t\t\t\t\ttable[y-1+row][x-1+col] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecursive(y_s-1,x_s-1);\n\n\t\tif(table[y_g-1][x_g-1] == 7)printf(\"OK\\n\");\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,c,d,x,y,nok,sc;\nint fld[101][101];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||fx<0||fx>w-1||fy<0||fy>h-1)return;\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        nok=0;\n        fill(fld[0],fld[0]+101*101,-1);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[ys-1][xs-1];\n       /* for(int j=0;j<h;j++){\n            for(int k=0;k<w;k++){\n                cout<<fld[j][k];\n            }\n            cout<<endl;\n        }*/\n        if(fld[0][0]!=-1){\n            dfs(0,0);\n        }\n        /*for(int j=0;j<h;j++){\n            for(int k=0;k<w;k++){\n                cout<<fld[j][k];\n            }\n            cout<<endl;\n        }*/\n        if(fld[yg-1][xg-1]==0)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\n\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\" << \"\\n\";\n\t}else{\n\t\tcout << \"NG\" << \"\\n\";\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[102][102];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[xg-1][yg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(xs+1,ys) + solve(xs,ys+1)+ solve(xs-1,ys) + solve(xs,ys-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nint w,h;\nbool** flags;\nchar** map;\n\nclass Point{\npublic:\n\tint X,Y;\n};\n\ntemplate <class T> T** NewArray(int w,int h){\n\tT** r = new T*[w];\n\tfor(int i=0;i<w;i++){\n\t\tr[i] = new T[h];\n\t\tfor(int j=0;j<h;j++){\n\t\t\tr[i][j] = 0;\n\t\t}\n\t}\n\treturn r;\n}\n\ntemplate <class T> void RemoveArray(T** array,int w,int h){\n\tfor(int i=0;i<h;i++){\n\t\tdelete[] array[i];\n\t}\n\tdelete[] array;\n}\n\nbool Check(int x,int y,int c){\n\tif(x<0){return false;}\n\tif(y<0){return false;}\n\tif(x>=w){return false;}\n\tif(y>=h){return false;}\n\tif(flags[x][y]){return false;}\n\tif(map[x][y] != c){return false;}\n\treturn true;\n}\n\nbool Solve(int sx,int sy,int gx,int gy){\n\t//printf(\"(%2d,%2d)->(%2d,%2d)\\n\",sx,sy,gx,gy);\n\tchar c = map[sx][sy];\n\tqueue<Point> pts;\n\tflags = NewArray<bool>(w + 1,h + 1);\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tflags[i][j] = false;\n\t\t}\n\t}\n\tPoint p,pp;\n\tp.X = sx;\n\tp.Y = sy;\n\tpts.push(p);\n\tflags[sx][sy] = true;\n\t\n\tbool res = false;\n\t\n\twhile(pts.size() > 0){\n\t\tp = pts.front();\n\t\tpts.pop();\n\t\tif(flags[gx][gy] == true){\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\t\tpp = p;\n\t\tpp.X -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.X += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t}\n\t\n\tRemoveArray<bool>(flags,w + 1,h + 1);\n\treturn res;\n}\n\nint main(){\n\tint xs,ys,xg,yg;\n\t\n\twhile(scanf(\"%d %d\",&w,&h) && w && h){\n\t\tw+=1;\n\t\th+=1;\n\t\tmap = NewArray<char>(w + 1,h + 1);\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\txs -= 1;\n\t\tys -= 1;\n\t\txg -= 1;\n\t\tyg -= 1;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tint c,d,x,y;\n\t\tint xx,yy;\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t//printf(\"%d \",map[i][j]);\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\txx = 4;\n\t\t\t\tyy = 2;\n\t\t\t}else{\n\t\t\t\txx = 2;\n\t\t\t\tyy = 4;\n\t\t\t}\n\t\t\tx-=1;\n\t\t\ty-=1;\n\t\t\tfor(int j=0;j<xx;j++){\n\t\t\t\tfor(int k=0;k<yy;k++){\n\t\t\t\t\t//printf(\"(%2d+%2d,%2d+%2d) = %d\\n\",k,j,y,k,c);\n\t\t\t\t\tmap[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t//printf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t\n\t\t\n\t\tif(Solve(xs,ys,xg,yg)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tRemoveArray<char>(map,w + 1,h + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint show=0;\nint w,h,sx,sy,gx,gy,d[101][101],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dy[i],nx=p.second+dx[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>w>>h){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<y+2+di*2;j++)for(int k=x;k<x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[sy][sx];\n\t\tif(!C)cout<<\"NG\"<<endl;\n\t\telse bfs();\n\t\tif(show){\n\t\t\tfor(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(field[i][j])cout<<field[i][j];else cout<<\" \";}cout<<endl;}\n\t\t\tfor(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(d[i][j]<INF)cout<<d[i][j]<<\" \";else cout<<\"  \";}cout<<endl;}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[100][100] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y && di < h; di++){\n                for(int dj = x;dj < dw + x && dj < w;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[100][100] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xg][yg] != C || C == 0)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n        }\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n/*\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<field[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl<<endl;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<vis[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std ;\n\nint map[ 100 ][ 100 ] ;\nint w ,h ;\nint gx ,gy ;\nint way ;\n\nstruct ST\n{\n\tint x ;\n\tint y ;\n} ;\n\nST s ;\n\nvoid ans()\n{\n\tqueue< ST > que ;\n\tint mx[ 4 ] = { 1 ,0 ,0 ,-1 } ;\n\tint my[ 4 ] = { 0 ,1 ,-1 ,0 } ;\n\tbool came[ 100 ][ 100 ] = { false } ;\n\tque.push( s ) ;\n\tcame[ s.y ][ s.x ] = true ;\n\twhile( ! que.empty() )\n\t{\n\t\ts = que.front() ;\n\t\tif( s.x == gx && s.y == gy )\n\t\t{\n\t\t\tcout << \"OK\" << endl ;\n\t\t\treturn ;\n\t\t}\n\t\tque.pop() ;\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\ts.x += mx[ i ] ;\n\t\t\ts.y += my[ i ] ;\n\t\t\tif( came[ s.y ][ s.x ] == false && map[ s.y ][ s.x ] == way )\n\t\t\t{\n\t\t\t\tcame[ s.y ][ s.x ] = true ;\n\t\t\t\tque.push( s ) ;\n\t\t\t\ts.x -= mx[ i ] ;\n\t\t\t\ts.y -= my[ i ] ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NG\" << endl ;\n\treturn ;\n}\n\n\nint main()\n{\n\twhile( cin >> w >> h ,h )\n\t{\n\t\tint n ;\n\t\tint color ,muki ,x ,y ;\n\t\tcin >> s.x >> s.y ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\twhile( n )\n\t\t{\n\t\t\tn-- ;\n\t\t\tcin >> color >> muki >> x >> y ;\n\t\t\tx-- ;\n\t\t\ty-- ;\n\t\t\tif( muki )\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 2 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgx-- ;\n\t\ts.x-- ;\n\t\tgy-- ;\n\t\ts.y-- ;\n\t\tway = map[ s.y ][ s.x ] ;\n\t\tif( map[ gy ][ gx ] == way )\n\t\t{\n\t\t\tans() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl ;\n\t\t}\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define MAX 100\n\nstruct in {\n\tint c;\n\tint d;\n\tpair<int, int> p;\n};\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\nint w, h, n;\npair<int, int> st, gl;\nint map[MAX+2][MAX+2];//map[X][Y]\nvector<in> info;\nbool f;\n\nbool dfs(int x, int y, int c) {\n\tif (map[x][y] != c) return false;\n\tmap[x][y] = -1;\n\tif (x==gl.first&&y==gl.second) return true;\n\tfor (int i=0; i<4; i++) {\n\t\tif (x+dx[i]<0 || y+dy[i]<0 || x+dx[i]>=w+2 || y+dy[i]>=h+2) continue;\n\t\tif (dfs(x+dx[i], y+dy[i], c)) return true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> w >> h, w||h) {\n\t\tcin >> st.first >> st.second >> gl.first >> gl.second >> n;\n\t\tinfo.clear();\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tin t;\n\t\t\tcin >> t.c >> t.d >> t.p.first >> t.p.second;\n\t\t\tinfo.push_back(t);\n\t\t}\n\n\t\tmemset(map, 0, sizeof(map));\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint W=4, H=2;\n\t\t\tif (info[i].d) { int t=W; W=H; H=t; }\n\t\t\tfor (int x=0; x<W; x++)\n\t\t\tfor (int y=0; y<H; y++)\n\t\t\t\tmap[info[i].p.first+x][info[i].p.second+y] = info[i].c;\n\t\t}\n\n\t\tcout << ((dfs(st.first, st.second, map[st.first][st.second])) ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<stack>\n\nusing namespace std ;\n\nint w ,h ,n ;\nint sx ,sy ,gx ,gy ;\n\nstruct P\n{\n\tint x ;\n\tint y ;\n} ;\n\nbool came[ 110 ][ 110 ] ;\n\nint map[ 110 ][ 110 ] ;\n\nvoid high( int x ,int y ,int c )\n{\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid wide( int x ,int y ,int c )\n{\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && !w )\n\t\t\treturn 0 ;\n\t\tcin >> sx >> sy >> gx >> gy >> n ;\n\tmemset( came ,false ,sizeof came ) ;\n\tmemset( map ,0 ,sizeof map ) ;\n\n\tstack< P > st ;\n\n\tint c ,d ,x ,y ;\n\tint d1 ,d2 ;\n\tfor( int k = 0 ; k < n ; k++ )\n\t{\n\t\tcin >> c >> d >> x >> y ;\n\t\td ? high( x ,y ,c ) : wide( x ,y ,c ) ;\n\t\t/*if( d )\n\t\t{\n\t\t\td1 = 2 ;\n\t\t\td2 = 4 ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td1 = 4 ;\n\t\t\td2 = 2 ;\n\t\t}\n\t\tfor( int i = 0 ; i < d1 ; i++ )\n\t\t{\n\t\t\tfor( int j = 0 ; j < d2 ; j++ )\n\t\t\t\tmap[ y + i ][ x + j ] = c ;\n\t\t}*/\n\t}\n\nfor( int i = 0 ; i <= h + 1 ; i++ )\n{\n\tfor( int j = 0 ; j <= w + 1 ; j++ )\n\t\tcout << map[ i ][ j ] ;\n\tcout << endl ;\n}\n\n\tif( map[ sy ][ sx ] != map[ gy ][ gx ] )\n\t{\n\t\tprintf( \"NG\\n\" ) ;\n\t\tcontinue ;\n\t}\n\n\tc = map[ gy ][ gx ] ;\n\n\tfor( int i = 1 ; i <= h ; i++ )\n\t{\n\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t{\n\t\t\tif( c == map[ i ][ j ] )\n\t\t\t\tcame[ i ][ j ] = true ;\n\t\t}\n\t}\n\n\td = 1 ;\n\tP l ;\n\tl.x = sx ;\n\tl.y = sy ;\n\tst.push( l ) ;\n\n\tcame[ sy ][ sx ] = false ;\n\n\twhile( !st.empty() )\n\t{\n\n\t\tP p = st.top() ;\n\t\tst.pop() ;\n\n\t\tif( p.x == gx && p.y == gy )\n\t\t{\n\t\t\td = 0 ;\n\t\t\tbreak ;\n\t\t}\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\tint mx[] = { 1 ,0 ,0 ,-1 } ;\n\t\t\tint my[] = { 0 ,1 ,-1 ,0 } ;\n\t\t\tint xx = p.x + mx[ i ] ;\n\t\t\tint yy = p.y + my[ i ] ;\n\t\t\tif( xx > 0 && x <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\t{\n\t\t\t\tcame[ yy ][ xx ] = false ;\n\t\t\t\tl.x = xx ;\n\t\t\t\tl.y = yy ;\n\t\t\t\tst.push( l ) ;\n\t\t\t}\n\t\t}\n\t}\n\td ? printf( \"NG\\n\" ) : printf( \"OK\\n\" ) ;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 102\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid input_data(void);  //データ入力用関数\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\nvoid clear(void);       //データの初期化\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[102][102];\nint data[102][102];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0)break; //ループ終了条件\n\n    input_data();\n\n    make_mass();\n\n    solve();\n\n    /*printf(\"%d\\n\",goal);*/\n\n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n\n    /*    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",data[i][j]);\n      }\n      printf(\"     \");\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",mass[i][j]);\n      }\n      printf(\"\\n\");\n      }                          */\n    clear();\n\n  }\n\n  return 0;\n}\nvoid input_data(void){\n\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n\n    cin>>n;\n\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n\n    }\n\n    return;\n}\nvoid make_mass(void){\n\n  int i,j;\n  int scolor,fcolor;\n\n    /*マスの作成*/\n    for(i=0;i<n;i++){\n\tswitch(d[i]){\n\tcase 0:              //横向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]][x[i]+j]=c[i];\n\t    mass[y[i]+1][x[i]+j]=c[i];\n\t  }\n\t  break;\n\tcase 1:              //縦向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]+j][x[i]]=c[i];\n\t    mass[y[i]+j][x[i]+1]=c[i];\n\t  }\n\t  break;\n\t}\n      }\n\n    scolor=mass[sy][sx];\n    fcolor=mass[gy][gx];\n\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(scolor!=mass[i][j]){\n\t    mass[i][j]=0;\n\t  }\n\t}\n      }\n\n    return;\n}\nvoid solve(void){\n\n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n\n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n\n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=data[p.second][p.first]+1;\n      }\n    }\n  }\n  return;\n}\n\n\nvoid clear(void){\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      mass[i][j]==0;\n    }\n  }\n  goal=0;\n\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] )\n{\n\tcame[ y ][ x ] = false ;\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t{\n\t\t\tcame[ yy ][ xx ] = false ;\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t\t}\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tcame[ gy ][ gx ] = false ;\t//\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy;\nint mas[101][101],used[101][101];\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nvoid make_map(int x,int y,int chk,int color){\n  if(chk == 0){\n    for(int i=y;i<y+2;i++){\n      for(int j=x;j<x+4;j++) mas[i][j] = color;\n    }\n  }\n  else {\n    for(int i=y;i<y+4;i++){\n      for(int j=x;j<x+2;j++) mas[i][j] = color;\n    }\n  }\n}\n\nbool dfs(int x,int y){\n  used[y][x] = true;\n  if(x == gx && y == gy) return true;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h && mas[ny][nx] == mas[sy][sx] && !used[ny][nx]) dfs(nx,ny);\n  }\n  return used[gy][gx];\n}\n\nint main(){\n  int n;\n  while(cin >> w >> h,w||h){\n    fill_n(mas[0],101*101,0);\n    memset(used,false,sizeof(used));\n    cin >> sx >> sy >> gx >> gy >> n;\n    --sx; --sy; --gx; --gy;\n    while(n--){\n      int c,d,x,y; cin >> c >> d >> x >> y; --x; --y;\n      make_map(x,y,d,c);\n    }\n    cout << (dfs(sx,sy)? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint H,W,sy,sx,gy,gx;\nint N;\n\nint C[100][100];\nbool vis[100][100];\n\nvoid dfs(int y,int x){\n    vis[y][x]=true;\n    rep(i,4){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||C[ny][nx]!=C[y][x]||vis[ny][nx])continue;\n        dfs(ny,nx);\n    }\n}\n\nsigned main(){\n    while(cin>>W>>H,W||H){\n        cin>>sx>>sy>>gx>>gy;\n        cin>>N;\n        sy--;sx--;gy--;gx--;\n        memset(C,0,sizeof(C));\n        rep(i,N){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--;y--;\n            for(int dy=0;dy<2;dy++){\n                for(int dx=0;dx<4;dx++){\n                    int ny,nx;\n                    if(!d)ny=y+dy,nx=x+dx;\n                    else ny=y+dx,nx=x+dy;\n                    C[ny][nx]=c;\n                }\n            }\n        }\n        if(!C[sy][sx]){\n            cout<<\"NG\"<<endl;\n            continue;\n        }\n        memset(vis,0,sizeof(vis));\n        dfs(sy,sx);\n        if(vis[gy][gx])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101] = {};\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc) return;\n\t\tfunc(x + nx[i], y + ny[i]);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> c >> d >> x >> y;\n\t\tif (d == 0){\n\t\t\tbw = 4;\n\t\t\tbh = 2;\n\t\t}\n\t\telse{\n\t\t\tbw = 2;\n\t\t\tbh = 4;\n\t\t}\n\t\tfor (int j = 0; j < bh; j++){\n\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t}\n\tbc = stage[1][1];\n\tfunc(1, 1);\n\tif (ans == true) cout << \"OK\\n\";\n\telse cout << \"NG\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint w, h;\nint xs, ys, xg, yg;\nint cs;\n\nbool isOK = false;\n\nvoid calc(int (&field)[101][101], int x, int y){\n\n\tfield[x][y] = -1;\n\n\tif (x == xg&&y == yg)isOK = true;\n\n\tif (x < w - 1 && field[x + 1][y] == cs)calc(field, x + 1, y);\n\tif (x > 0 && field[x - 1][y] == cs)calc(field, x - 1, y);\n\tif (y < h - 1 && field[x][y + 1] == cs)calc(field, x, y + 1);\n\tif (y > 0 && field[x][y - 1] == cs)calc(field, x, y - 1);\n\n}\n\nint main(){\n\n\twhile (std::cin >> w >> h){\n\n\t\tif (w == 0 && h == 0)break;\n\n\t\tstd::cin >> xs >> ys >> xg >> yg;\n\n\t\txs--, ys--, xg--, yg--;\n\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tint field[101][101];\n\t\tfor (int i = 0; i < 100; i++){\n\t\t\tfor (int j = 0; j < 100; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\n\t\t\tx--, y--;\n\n\t\t\tif (d == 0){\n\t\t\t\tfor (int j = y; j < y + 2; j++){\n\t\t\t\t\tfor (int k = x; k < x + 4; k++){\n\t\t\t\t\t\tfield[k][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d == 1){\n\t\t\t\tfor (int j = y; j < y + 4; j++){\n\t\t\t\t\tfor (int k = x; k < x + 2; k++){\n\t\t\t\t\t\tfield[k][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcs = field[xs][ys];\n\n\t\tcalc(field, xs, ys);\n\n\t\tif (cs != 0 && isOK)std::cout << \"OK\" << std::endl;\n\t\telse std::cout << \"NG\" << std::endl;\n\n\t\tisOK = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\n\nvoid DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='w')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_Y(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='y')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_G(int Y,int X,int Xg,int Yg,int &c){\n  if((Y==Xg&&X==Yg)||(c!= 0)){\n    c=1;\n  }\n  if(F[Y][X]!='g'){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1, X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_B(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='b')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_R(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='r')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n}\n\nint main(){\n\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      F[j][i]='0';\n    }\n  }\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  cin>>w>>h;\n  while(1){\n    //int a=0;\n    //int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    int c[n];\n    int d[n];\n    int x[n];\n    int y[n];\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      //int a=0;\n      //int b=0;\n      if(d[i]==0) {\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n    if((w==0)&&(h==0))\n      break;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n        F[i][j]='0';\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint b[101][101];\nbool f[101][101];\n\nvoid maze(int x, int y) {\n\tf[x][y] = 1;\n\n\tint cl = b[xs][ys];\n\n\tif (x < w && !f[x + 1][y] && b[x + 1][y] == cl)\n\t\tmaze(x + 1, y);\n\n\tif (x > 1 && !f[x - 1][y] && b[x - 1][y] == cl)\n\t\tmaze(x - 1, y);\n\n\tif (y < h && !f[x][y + 1] && b[x][y + 1] == cl)\n\t\tmaze(x, y + 1);\n\n\tif (y > 1 && !f[x][y - 1] && b[x][y - 1] == cl)\n\t\tmaze(x, y - 1);\n}\n\nint main()\n{\n\tcin >> w >> h;\n\n\twhile (w != 0 || h != 0) {\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tif (d) {\n\t\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\t\tb[x + i][y + j] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 2; i++)\n\t\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\t\tb[x + j][y + i] = c;\n\t\t\t}\n\t\t}\n\n\t\tmaze(xs, ys);\n\n\t\tif (f[xg][yg])\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\n\t\tcin >> w >> h;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n    /*\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++)cout << grid[i][j];\n      cout << endl;\n    }\n    */\n    int color = grid[ys][xs];    \n    queue<P> q;\n    if(color){\n      q.push(P(ys,xs));\n      \n      while(q.size()){\n\tP p = q.front();q.pop();\n\ty = p.first;\n\tx = p.second;\n\tif(yg == y && xg == x){\n\t  cout << \"OK\\n\";\n\t  q.push(P(y,x));\n\t  break;\n\t}\n\tvisit[y][x] = true;\n\t\n\tint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\tfor(int i=0;i<4;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t\n\t  if(sx<0 || sy<0 || w<=sx || h<=sy)continue;\n\t  \n\t  if(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\t  q.push(P(sy,sx));\n\t}\n      }\n    }\n    if(q.empty())cout << \"NG\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\n \nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = -1;\n \n  meiro(W+1,H  ,c);\n  meiro(W-1  ,H,c);\n  meiro(W,H+1 ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n \n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 10;\n      }\n    }\n \n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n \n    int n;\n    cin >> n;\n \n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n \n    meiro(xs,ys,C[xs][ys]);\n \n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 00;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0) break;\n        int sy,sx,gy,gx;\n        cin >> sx >> sy >> gx >> gy;\n        sx--,sy--,gx--,gy--;\n        int n;\n        cin >> n;\n        vector<vector<int> > color(h,vector<int>(w));\n        for(int block=0;block<n;block++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            x--;y--;\n            // yoko\n            if(d == 0){\n                for(int i=0;i<2;i++){\n                    for(int j=0;j<4;j++){\n                        color[y+i][x+j] = c;\n                    }\n                }\n            }else{\n                for(int i=0;i<4;i++){\n                    for(int j=0;j<2;j++){\n                        color[y+i][x+j] = c;\n                    }\n                }\n            }\n        }\n        // for(int i=0;i<h;i++){\n        //     for(int j=0;j<w;j++){\n        //         cerr << color[i][j];\n        //     }\n        //     cerr << endl;\n        // }\n        int c = color[sy][sx];\n        vector<vector<char> > visited(h,vector<char>(w));\n        queue<pair<int,int> > Q;\n        Q.push(make_pair(sy,sx));\n        while(not Q.empty()){\n            int y = Q.front().first;\n            int x = Q.front().second;\n            Q.pop();\n\n            if(y >= h or y < 0 or x >= w or x < 0) continue;\n            if(color[y][x] != c) continue;\n            if(visited[y][x]) continue;\n            visited[y][x] = true;\n            for(int i=0;i<4;i++){\n                Q.push(make_pair(y+dy[i],x+dx[i]));\n            }\n        }\n        if(visited[gy][gx]){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\nusing namespace std;\n\nint map[200][200];\nbool reach[200][200];\nint w, h;\n\ntypedef struct {\n\tint x;\n\tint y;\n} SIZE;\n\nSIZE size[2] = {\n\t{4, 2}, {2, 4}\n};\n\nint angle[][2] = {\n\t{-1, 0}, {0, -1}, {1, 0}, {0, 1}\n};\n\nvoid search(int x, int y)\n{\n\tif (map[x][y] == 0 || x <= 0 || x > w || y <= 0 || y > h){\n\t\treturn;\n\t}\n\t\n\treach[x][y] = true;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tif (\n\t\treach[x + angle[i][0]][y + angle[i][1]] == false &&\n\t\tmap[x + angle[i][0]][y + angle[i][1]] == map[x][y]\n\t\t){\n//\t\t\treach[x + angle[i][0]][y + angle[i][1]] = true;\n\t\t\tsearch(x + angle[i][0], y + angle[i][1]);\n\t\t}\n\t}\n}\n\t\t\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(map, 0, sizeof(reach));\n\t\t\n\t\tint xs, ys;\n\t\tscanf(\"%d %d\", &xs, &ys);\n\t\t\n\t\tint xg, yg;\n\t\tscanf(\"%d %d\", &xg, &yg);\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tfor (int j = 0; j < size[d].y; j++){\n\t\t\t\tfor (int k = 0; k < size[d].x; k++){\n\t\t\t\t\tmap[x + k][y + j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%d \", map[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n*/\t\t\n\t\tsearch(xs, ys);\n/*\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%d \", reach[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n*/\t\t\n\t\tif (reach[xg][yg]){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c || Y > w || X > h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 00;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[101][101];\n\nvoid Block(int c, int d, int x, int y){\n\tif(d==0){\n    \tfor(int i=0;i<4;i++){\n    \t\tF[y][x+i]=c;\n\t\t\tF[y+1][x+i]=c;\n    \t}\n  \t}else{\n    \tfor(int i=0;i<4;i++){\n    \t\tF[y+i][x]=c;\n    \t\tF[y+i][x+1]=c;\n    \t}\n\t}\n}\nvoid DFS(int y,int x,int c){\n\tif(F[y][x]!=c)\n\t\treturn;\n\n\tF[y][x] = 6;\n\n    DFS(y-1,x  ,c);\n    DFS(y  ,x+1,c);\n    DFS(y+1,x  ,c);\n    DFS(y  ,x-1,c);\n}\nint main(){\n\twhile(true){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0){break;}\n\t\tint xs,ys;\n\t\tcin>>xs>>ys;\n\t\tint xg,yg;\n\t\tcin>>xg>>yg;\n\t\tint n;\n\t\tcin>>n;\n\t\tint c,d,x,y;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tBlock(c,d,x,y);\n\t\t}\n\t\tDFS(ys,xs,F[ys][xs]);\n\t\tif(F[yg][xg]==6){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\tque.push(S);\nbool check(short maze[MAX][MAX])\n{\n\t\n\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<queue>\nusing namespace std;\nint field[128][128];\nbool memo[128][128];\nint dx[] = {-1,0,0,1},dy[] = {0,-1,1,0};\nint w,h;\nvoid func(int x,int y,int c){\n\tif(x < 0 || y < 0 || x >= w || y >= h)return;\n\tif(memo[y][x])return ;\n\tif(field[y][x] != c)return ;\n\tmemo[y][x] = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tfunc(x+dx[i],y+dy[i],c);\n\t}\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w,h){\n\t\tint xs,ys,xg,yg,n;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = x; j < x + 4; j++){\n\t\t\t\t\tfield[y][j] = c;\n\t\t\t\t\tfield[y+1][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < y + 4; j++){\n\t\t\t\t\tfield[j][x] = c;\n\t\t\t\t\tfield[j][x+1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunc(xs,ys,field[ys][xs]);\n\t\tcout << (memo[yg][xg]==1?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint fie[101][101],ans,gol[101][101],st[101][101],col,muki,bx,by;\nint bex[4]={0,1,0,-1},bey[4]={1,0,-1,0},cou,a,b;\n    int sx,sy,gx,gy,n;\nint func(int y,int x){\n    if(fie[sy][sx]==-1)return 0;\n    if(y<1||x<1||y>b||x>a)return 0;\n    if(fie[y][x]==ans){\n        fie[y][x]=0;\n        for(int i=0;i<4;i++){\n            func(y+bey[i],x+bex[i]);\n        }\n    }\n    return 0;\n}\nint main(){\n    for(;;){\n        cin>>a>>b;\n        if(a==0&&b==0)break;\n        fill(fie[0],fie[0]+101*101,-1);\n        fill(vis[0],vis[0]+101*101,true);\n        cin>>sx>>sy>>gx>>gy;\n        cin>>n;\n        for(int i=0;i<n;i++){\n            cin>>col>>muki>>bx>>by;\n            if(muki==0){\n                for(int i=0;i<=1;i++){\n                    for(int j=0;j<=3;j++){\n                        fie[by+i][bx+j]=col;\n                    }\n                }\n            }\n            if(muki==1){\n                for(int i=0;i<=3;i++){\n                    for(int j=0;j<=1;j++){\n                        fie[by+i][bx+j]=col;\n                    }\n                }\n            }\n        }\n        ans=fie[sy][sx];\n        if(fie[sy][sx]!=0){\n            func(sy,sx);\n        }\n        /*for(int i=1;i<=a;i++){\n            for(int j=1;j<=b;j++){\n                cout<<fie[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(!fie[gy][gx])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        cou=0;\n        /*for(int i=1;i<=a;i++){\n            for(int j=1;j<=b;j++){\n                cout<<fie[i][j];\n            }\n            cout<<endl;\n        }*/\n    }\nreturn 0;\n}\n/*6 5\n1 1\n5 5\n3\n2 0 1 1\n2 0 2 3\n2 0 2 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct cordinate{\n        int y;\n        int x;\n};\ncordinate SIZE,Start,Goal;\nstruct Blocks{\n        int color;\n        int direction;\n        int y;\n        int x;\n};\nBlocks block[200];\nint N,board[200][200];\nint Color,dp[200][200];\nint recursion(int y,int x){\n        int res=0;\n        if(y==Goal.y && x==Goal.x){\n                res=1;\n        }\n        else if(dp[y][x]!=-1)\n                return dp[y][x];\n        else{\n                dp[y][x]=0;\n                if(board[y+1][x]==Color && dp[y+1][x]==-1)\n                        res+=recursion(y+1,x);\n                if(board[y-1][x]==Color && dp[y-1][x]==-1)\n                        res+=recursion(y-1,x);\n                if(board[y][x+1]==Color && dp[y][x+1]==-1)\n                        res+=recursion(y,x+1);\n                if(board[y][x-1]==Color && dp[y][x-1]==-1)\n                        res+=recursion(y,x-1);\n        }\n        return dp[y][x]=res;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<100 ; i++ )\n                        for(int j=0 ; j<100 ; j++ ){\n                                dp[i][j]=-1;\n                                board[i][j]=0;\n                        }\n                cin >> SIZE.x >> SIZE.y;\n                if(SIZE.x+SIZE.y==0)\n                        break;\n                cin >> Start.x >> Start.y;\n                cin >> Goal.x >> Goal.y;\n                cin >> N;\n                for(int i=0 ; i<N ; i++ ){\n                        cin >> block[i].color >> block[i].direction;\n                        cin >> block[i].x >> block[i].y;\n                        if(block[i].direction){\n                                for(int l=block[i].y ; l<block[i].y+4 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+2 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                        else{\n                                for(int l=block[i].y ; l<block[i].y+2 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+4 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                }\n                Color=board[Start.y][Start.x];\n                if(Color==0){\n                        cout<<\"NG\"<<endl;\n                        break;\n                }\n                if(recursion(Start.y,Start.x)>0)\n                        cout <<\"OK\"<<endl;\n                else\n                        cout <<\"NG\"<<endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy,d[100][100],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<=y+2+di*2;j++)for(int k=x;k<=x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tbfs();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h){\n    int xs,ys,xg,yg;\n    bool Map[h+10][w+10]={};\n    bool flag=false;\n    cin>>xs>>ys>>xg>>yg;\n    xs--;ys--;xg--;yg--;\n    int n;cin>>n;\n    int Map2[h+10][w+10]={};\n    Map[ys][xs]=true;\n    queue<pair<int,int> >que;\n    que.push(mp(ys,xs));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      if(d==0){\n\tfor(int i=y;i<y+2;i++)\n\t  for(int j=x;j<x+4;j++)\n\t    Map2[i][j]=c;\n      }else if(d==1){\n\tfor(int i=y;i<y+4;i++)\n\t  for(int j=x;j<x+2;j++)\n\t    Map2[i][j]=c;\n      }\n    }\n    int vx[4]={0,-1,0,1};\n    int vy[4]={1,0,-1,0};\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      if(now.F==yg&&now.S==xg){\n\tflag=true;\n\tbreak;\n      }\n      for(int kk=0;kk<4;kk++){\n\tint as=now.F+vx[kk];int bs=now.S+vy[kk];\n\tif(as<h&&as>=0&&bs<w&&bs>=0&&Map2[now.F][now.S]==Map2[as][bs]&&!Map[as][bs]){\n\t  que.push(mp(as,bs));\n\t  Map[as][bs]=true;\n\t}\n      }\n    }\n    if(flag)\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[x+1][y+1]=c;\n             F[x+2][y+1]=c;\n             F[x+3][y+1]=c;\n             F[x+4][y+1]=c;  \n             F[x+1][y+2]=c;\n             F[x+2][y+2]=c;\n             F[x+3][y+2]=c;\n             F[x+4][y+2]=c;   \n         }\n         if(d==1){\n             F[x+1][y+1]=c;\n             F[x+1][y+2]=c;\n             F[x+1][y+3]=c;\n             F[x+1][y+4]=c;  \n             F[x+2][y+1]=c;\n             F[x+2][y+2]=c;\n             F[x+2][y+3]=c;\n             F[x+2][y+4]=c;   \n         }\n      }\n      if(F[xs][xy]!=1&&F[xs][xy]!=2&&F[xs][xy]!=3&&F[xs][xy]!=4&&F[xs][xy]!=5)\n         cout << \"NG\" << endl;\n      else{\n         DFS(xs+1,ys+1,c);\n         if(F[xg+1][yg+1]==6)\n            cout << \"OK\" << endl;\n         else\n            cout << \"NG\" << endl;\n         for(int i=1;i<=w;i++)\n            for(int j=1;j<=h;j++)\n               F[i][j]=0;\n      }\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <string>\n\n#define Pa pair<int,int>\n\nusing namespace std;\n\n\nstring bfs(int a[101][101], int sx, int sy, int gx, int gy, int w, int h)\n{\n\tint s, t, m = a[sy][sx];\n\tint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\tbool vis[101][101];\n\tstring str = \"NG\";\n\tqueue<Pa> que;\n\tPa pa;\n\tfill(&vis[1][1], &vis[h][w], true);\n\t\n\tque.push(Pa(sy, sx));\n\tvis[sy][sx] = false;\n\t\n\twhile(!que.empty()){\n\t\tpa = que.front();\n\t\tque.pop();\n\t\tif(pa.first == gy && pa.second == gx){\n\t\t\tstr = \"OK\";\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ts = pa.first + dy[i];\n\t\t\tt = pa.second + dx[i];\n\t\t\tif(1 <= s && s <= h && 1 <= t && t <= w){\n\t\t\t\tif(vis[s][t] && m == a[s][t]){\n\t\t\t\t\tque.push(Pa(s, t));\n\t\t\t\t\tvis[s][t] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str;\n}\n\nint main()\n{\n\tint a[101][101], w, h, sx, sy, gx, gy, s, t, u, v, n;\n\t\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[1][1], &a[h][w], 0);\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u >> v;\n\t\t\tif(t == 0){\n\t\t\t\tfor(int i = v; i <= v+1; i++){\n\t\t\t\t\tfor(int j = u; j <= u+3; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i = v; i <= v+3; i++){\n\t\t\t\t\tfor(int j = u; j <= u+1; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, sx, sy, gx, gy, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 100;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\n\nvoid dfs(int x, int y){\n    maze[x][y] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) flag = 1;\n                dfs(nx, ny);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[x-1+dx][y-1+dy] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[x-1+dx][y-1+dy] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[xs-1][ys-1]) maze[i][j] = 0;\n\n    //search\n    dfs(xs-1, ys-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[y+1][x+1]=c;\n             F[y+1][x+2]=c;\n             F[y+1][x+3]=c;\n             F[y+1][x+4]=c;  \n             F[y+2][x+1]=c;\n             F[y+2][x+2]=c;\n             F[y+2][x+3]=c;\n             F[y+2][x+4]=c;   \n         }\n         else{\n             F[y+1][x+1]=c;\n             F[y+2][x+1]=c;\n             F[y+3][x+1]=c;\n             F[y+4][x+1]=c;  \n             F[y+1][x+2]=c;\n             F[y+2][x+2]=c;\n             F[y+3][x+2]=c;\n             F[y+4][x+2]=c;   \n         }\n      }\n      if(F[ys+1][xs+1]==1&&F[ys+1][xs+1]==2&&F[ys+1][xs+1]==3&&F[ys+1][xs+1]==4&&F[ys+1][xs+1]==5)\n         DFS(ys+1,xs+1,F[ys+1][xs+1]);\n      if(F[yg+1][xg+1]==F[ys+1][xs+1])\n         cout << \"OK\" << endl;\n      else\n         cout << \"NG\" << endl;\n      /*for(int i=1;i<=w;i++)\n         for(int j=1;j<=h;j++)\n            F[i][j]=0;*/\n      \n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[y+1][x+1]=c;\n             F[y+1][x+2]=c;\n             F[y+1][x+3]=c;\n             F[y+1][x+4]=c;  \n             F[y+2][x+1]=c;\n             F[y+2][x+2]=c;\n             F[y+2][x+3]=c;\n             F[y+2][x+4]=c;   \n         }\n         if(d==1){\n             F[y+1][x+1]=c;\n             F[y+2][x+1]=c;\n             F[y+3][x+1]=c;\n             F[y+4][x+1]=c;  \n             F[y+1][x+2]=c;\n             F[y+2][x+2]=c;\n             F[y+3][x+2]=c;\n             F[y+4][x+2]=c;   \n         }\n      }\n      if(F[ys+1][xs+1]!=1&&F[ys+1][xs+1]!=2&&F[ys+1][xs+1]!=3&&F[ys+1][xs+1]!=4&&F[ys+1][xs+1]!=5)\n         cout << \"NG\" << endl;\n      else{\n         DFS(ys+1,xs+1,c);\n         if(F[yg+1][xg+1]==6)\n            cout << \"OK\" << endl;\n         else\n            cout << \"NG\" << endl;\n         for(int i=1;i<=w;i++)\n            for(int j=1;j<=h;j++)\n               F[i][j]=0;\n      }\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<functional>\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint c,d,x,y;\nint map[101][101];\nint flg=0,temp;\nvoid func(int ,int);\nusing namespace std;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0){\n\t\t\tbreak;\n\t\t}\n\t\tint i,j,k;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(k=0;k<=1;k++){\n\t\t\t\t\tfor(j=0;j<=3;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\t\tfor(j=0;j<=1;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(j=1;j<=10;j++){\n\t\t\t\tfor(k=1;k<=10;k++){\n\t\t\t\t\tprintf(\"%d \",map[j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\t\tflg=0;\n\t\tif(map[ys][xs]==map[yg][xg] && map[ys][xs]!=0){\n\t\t\ttemp=map[ys][xs];\n\t\t\tmap[ys][xs]=0;\n\t\t\tfunc(ys,xs);\n\t\t}/*\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(flg==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\nvoid func(int yy,int xx){\n\tint dy[4]={0,1,0,-1},dx[4]={1,0,-1,0};\n\tint i;\n\tif(flg==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tyy=yy+dy[i];\n\t\t\txx=xx+dx[i];\n\t\t\tif(yy<=h && yy>=1 && xx<=w && xx>=1 && map[yy][xx]==temp){\n\t\t\t\tmap[yy][xx]=0;\n\t\t\t\tif(xg==xx && yg==yy){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfunc(yy,xx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0)\n        ca = 10;\n      else if(i == n-1)\n        ca = 0;\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\n\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, newc;\nint board[100][100];\t//添字は行、列の順\nint dirx[] = {-1, 0, 0, 1};\nint diry[] = {0, -1, 1, 0};\n//xs,ysから接する同じ色のところを100に置き換えていく\nvoid dfs(int x, int y)\n{\n\tboard[y][x] = 6;\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tint nx, ny;\n\t\t\n\t\tnx = x + dirx[i];\n\t\tny = y + diry[i];\n\t\t\n\t\tif (0<=nx && nx<w && 0<=ny && ny<h && board[ny][nx]==newc)\n\t\t{\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile (cin >> w >> h)\n\t{\n\t\tif (w == 0 && h == 0) break;\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\t//board初期化\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\t//横向き\n\t\t\t\tboard[y-1][x-1] = board[y-1][x] = board[y-1][x+1] = board[y-1][x+2] = c;\n\t\t\t\tboard[y][x-1] = board[y][x] = board[y][x+1] = board[y][x+2] = c;\n\t\t\t} else {\n\t\t\t\t//縦向き\n\t\t\t\tboard[y-1][x-1] = board[y][x-1] = board[y+1][x-1] = board[y+2][x-1] = c;\n\t\t\t\tboard[y-1][x] = board[y][x] = board[y+1][x] = board[y+2][x] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnewc = board[ys-1][xs-1];\n\t\tdfs(xs-1, ys-1);\n\t\tif (board[yg-1][xg-1] == 6)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t\n\t\t\n\t\t//テスト出力\n\t\t/*\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tcout << board[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool is_maze(vector<vector<int> > grid, const pair<int,int>& start, const pair<int,int>& goal)\n{\n  const int W = grid.size();\n  const int H = grid[0].size();\n  const int color = grid[start.first][start.second];\n  queue<pair<int,int> > q;\n  q.push(start);\n  grid[start.first][start.second] = -1;\n  while (!q.empty()) {\n    const pair<int,int> p = q.front();\n    q.pop();\n    if (p == goal) {\n      return true;\n    }\n\n    for (int d = 0; d < 4; d++) {\n      static const int dir_w[] = {-1, 1, 0, 0};\n      static const int dir_h[] = {0, 0, -1, 1};\n      const int next_w = p.first + dir_w[d];\n      const int next_h = p.second + dir_h[d];\n      if (next_w >= 0 && next_w < W && next_h >= 0 && next_h < H\n          && grid[next_w][next_h] == color) {\n        q.push(make_pair(next_w, next_h));\n        grid[next_w][next_h] = -1;\n      }\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H && W != 0) {\n    vector<vector<int> > grid(W, vector<int>(H, 0));\n    pair<int,int> start, goal;\n    cin >> start.first >> start.second;\n    --start.first;  --start.second;\n    cin >> goal.first >> goal.second;\n    --goal.first; --goal.second;\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      --x;  --y;\n      if (d == 1) {\n        // vert\n        for (int i = 0; i < 4; i++) {\n          grid[x][y+i] = grid[x+1][y+i] = c;\n        }\n      } else {\n        // horiz\n        for (int i = 0; i < 4; i++) {\n          grid[x+i][y] = grid[x+i][y+1] = c;\n        }\n      }\n    }\n    cout << (is_maze(grid, start, goal) ? \"OK\" : \"NG\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\nconst int ax[2][8] = {\n\t{0, 1, 2, 3, 0, 1, 2, 3},\n\t{0, 0, 0, 0, 1, 1, 1, 1}\n};\n\nconst int ay[2][8] = {\n\t{0, 0, 0, 0, 1, 1, 1, 1},\n\t{0, 1, 2, 3, 0, 1, 2, 3}\n};\n\nint W, H, sx, sy, gx, gy, n, board[110][110];\n\nbool dfs(int x, int y) {\n\tif (x == gx && y == gy) return true;\n\tint c = board[y][x];\n\tboard[y][x] = -1;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 1 || W < nx || ny < 1 || H < ny) continue;\n\t\tif (board[ny][nx] != c) continue;\n\t\tif (dfs(nx, ny)) return true;\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tmemset(board, -1, sizeof(board));\n\t\t\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor_(a,0,8) board[y + ay[d][a]][x + ax[d][a]] = c;\n\t\t}\n\t\t\n\t\tif (board[sy][sx] != -1 && dfs(sx, sy)) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nint map[size_max][size_max];\n\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\n\nvoid chek(int w, int h)\n{\n\tint i, j;\n\tfor (i = 0; i <= h + 1; i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue<PR> QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t\t//chek(w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tnow = make_pair(ys, xs);\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] != -1)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = make_pair(now.Y + my[i], now.X + mx[i]);\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <utility>\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nint sx,sy,gx,gy;\nint w,h,n;\nint g[1000][1000];\nbool valid(int y, int x){ return 0<=x && x<w && 0<=y && y<h; }\n\nint main(){\n    while(cin>>w>>h && w){\n        cin>>sx>>sy>>gx>>gy;\n        sx--,sy--,gx--,gy--;\n        cin>>n;\n        rep(i,h)rep(j,w)g[i][j]=0;\n        rep(i,n){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            g[y][x]=c;\n            if(d==0)x++;else y++;\n            g[y][x]=c;\n        }\n        int C=g[sy][sx];\n        rep(i,h)rep(j,w)g[i][j]= (g[i][j]==C) ? C : 0;\n        bool vis[1000][1000]={};\n        vis[sy][sx]=true;\n        if(C){\n            stack<pii> s;\n            vis[sy][sx]=true;\n            s.emplace(sy,sx);\n            while(s.size()){\n                int y,x;\n                tie(y,x) = s.top();s.pop();\n                rep(d,4){\n                    int nx=x+dx[d],ny=y+dy[d];\n                    if(!valid(nx,ny))continue;\n                    if(vis[ny][nx])continue;\n                    vis[ny][nx]=true;\n                    s.emplace(ny,nx);\n                }\n            }\n        }\n        puts(vis[gy][gx] ? \"OK\" : \"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==0)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint  map[100][100];\nbool visited[100][100];\nint  w,h;\nint  xs,ys;\nint  xg,yg;\nint  n;\n\nint dfs(int x,int y) {\n\tstatic int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\tif(x==xg&&y==yg) return 1;\n\tvisited[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&map[x][y]==map[nx][ny]&&!visited[nx][ny]) {\n\t\t\tif(dfs(nx,ny)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint c,d,x,y;\n\n\twhile(1) {\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d %d\",&xs,&ys);xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg);xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);x--;y--;\n\t\t\tint X,Y;\n\t\t\tif(d==1) {\n\t\t\t\tX=2;Y=4;\n\t\t\t}else {\n\t\t\t\tX=4;Y=2;\n\t\t\t}\n\t\t\tfor(int j=0;j<X;j++) {\n\t\t\t\tfor(int k=0;k<Y;k++) {\n\t\t\t\t\tmap[x+j][y+k]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<int,int> P;\nP S,G;\nint w,h;\nint maze[MAX][MAX];\nint color;\n\nbool check()\n{\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tint nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G)\n\t\t\treturn true;\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tint n,c,d,x,y;\n\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(check())\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n/*\n\t\trep(i,y){\n\t\t\trep(j,x)\n\t\t\t\tprintf(\"%2d\", maze[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\n*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define mp(a,b) make_pair(a,b)\n#define DEBUG(x) cerr<<#x<<\":\"<<x<<endl;\n\nint W, H;\nint SX, SY, GX, GY;\n\nint field[100][100];\n\ninline bool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid setBlock(int c, int d, int x, int y) {\n\tif(d == 0) {\n\t\tfor(int dy = 0; dy < 2; dy++) {\n\t\t\tfor(int dx = 0; dx < 4; dx++) {\n\t\t\t\tfield[x + dx][y + dy] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse if(d == 1) {\n\t\tfor(int dy = 0; dy < 4; dy++) {\n\t\t\tfor(int dx = 0; dx < 2; dx++) {\n\t\t\t\tfield[x + dx][y + dy] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tassert(false);\n}\n\nvoid pv() {\n\tcerr << endl;\n\tcerr << \"-----\" << endl;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < H; x++)\n\t\t\tcerr << field[x][y];\n\t\tcerr << endl;\n\t}\n\tcerr << \"-----\" << endl;\n}\n\nbool visit[100][100];\n\nint main() {\n\tfor(; cin >> W >> H;) {\n\t\tcin >> SX >> SY >> GX >> GY;\n\t\tSX--, SY--, GX--, GY--;\n\n\t\tmemset(field, 0, sizeof field);\n\t\tmemset(visit, 0, sizeof visit);\n\t\t\n\t\tint N; cin >> N;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--, y--;\n\t\t\tsetBlock(c, d, x, y);\n\t\t}\n\n\t\tqueue<P> Q;\n\t\tQ.push(mp(SX, SY));\n\t\tvisit[SX][SY] = true;\n\n\t\tint C = field[SX][SY];\n\n\t\tbool f = false;\n\t\twhile(!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif(p.first == GX && p.second == GY) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint dx[4] = {1, 0, -1, 0};\n\t\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif(inRange(nx, ny) && field[nx][ny] == C && visit[nx][ny] == false) {\n\t\t\t\t\tvisit[nx][ny] = true;\n\t\t\t\t\tQ.push(mp(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (f ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[102][102],MF[102][102];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(Y>0 && X>0){\n\t\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n\t\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n\t\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n\t\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c || Y > w || X > h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\t\n\t\tif(ban[x+1][y]==ban[xs][ys]&&!visited[x][y]){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&!visited[x][y]){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0,visited[i][j]=false;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif ((W == 0) && (H == 0)) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][yg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\tint u[150][150],p,v[150][150],xg,yg,q,dx[]={1,0,-1,0},dy[]={0,1,0,-1},w,h;\nvoid ret(int x,int y){\n\tint a,b,i;\n\tv[y][x]=1;\n\tif(xg==x&&yg==y)\n\t\tp++;\n\telse\n\tfor(i=0;i<4;i++){\n\t\ta=x+dx[i];\n\t\tb=y+dy[i];\n\t\tif(a<1||a>w||b<1||b>h||v[b][a]==1)\n\t\t\tcontinue;\n\t\telse if(u[b][a]==q)\n\t\t\tret(a,b);\n\t}\n}\nint main(){\n\tint xs,ys,c,d,x,y,n;\n\twhile(cin>>w>>h,w||h){\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\tv[i][j]=0;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\t\tscanf(\"%d %d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int k=0;k<n;k++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0)\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tu[i+y][j+x]=c;\n\t\t\telse \n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\tu[i+y][j+x]=c;\n\t\t}\n\t\tq=u[ys][xs];\n\t\tp=0;\n\t\tret(xs,ys);\n\t\tif(p>0)\n\t\t\tprintf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,c,d,x,y,nok,sc;\nint fld[101][101];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||fx<0||fx>w-1||fy<0||fy>h-1)return;\n    if(fx==xg-1&&fy==yg-1){\n        if(sc==fld[fy][fx])nok=1;\n    }\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        nok=0;\n        fill(fld[0],fld[0]+101*101,0);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[ys-1][xs-1];\n        /*for(int j=0;j<h;j++){\n            for(int k=0;k<w;k++){\n                cout<<fld[j][k];\n            }\n            cout<<endl;\n        }*/\n        if(fld[0][0]!=0){\n            dfs(0,0);\n        }\n        if(nok==1)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define TATE 1\n#define YOKO 0\nint main(void){\n    int map[101][101];\n    int board[101][101];\n    int T[]={0,-1,1,0};\n    int Y[]={1,0,0,-1};\n    int w,h,xs,xg,ys,yg,n,color,muki,x,y;\n    struct ST {\n        int x;\n        int y;\n    };\n    ST RE;\n    ST GO;\n    queue<ST> Q;\n    while(1){\n        memset(map,0,sizeof(map));\n        memset(board,0,sizeof(board));\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys>>xg>>yg>>n;\n        for(int i=0;i<n;i++){\n            cin>>color>>muki>>x>>y;\n            if(muki==YOKO){\n                for(int j=0;j<4;j++){\n                    board[y][x+j]=board[y+1][x+j]=color;\n                }\n            }\n            else{\n                for(int j=0;j<4;j++){\n                    board[y+j][x]=board[y+j][x+1]=color;\n                }\n            }\n        }\n       /* for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        RE.x=xs;\n        RE.y=ys;\n        map[ys][xs]=1;\n        Q.push(RE);\n        int flag=0;\n        while(!Q.empty()){\n            RE=Q.front();\n            Q.pop();\n            if(RE.x==xg&&RE.y==yg&&board[RE.y][RE.x]==board[yg][xg]){\n                flag=1;\n                //cout<<RE.x<<\" \"<<RE.y<<endl;\n                break;\n            }\n            else{\n                for(int i=0;i<4;i++){\n                    GO=RE;\n                    if(GO.x+Y[i]>0&&GO.y+T[i]>0&&GO.x+Y[i]<101&&GO.y+T[i]<101&&board[GO.y+T[i]][GO.x+Y[i]]==board[yg][xg]&&map[GO.y+T[i]][GO.x+Y[i]]!=1){\n                        GO.x+=Y[i];\n                        GO.y+=T[i];\n                        map[GO.y][GO.x]=1;\n                        Q.push(GO);\n                    }\n                }\n            }\n        }\n       /* for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(flag==1){\n            cout<<\"OK\"<<endl;\n        }\n        else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x <= w && y>=0 && y<= h);\n}\nint main(void){\n\tconst int dx[4]={0,1,0,-1};\n\tconst int dy[4]={1,0,-1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<=w;i++){\n\t\t\tfor(int j=0;j<=h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x+k][y+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs][ys];\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs;\n\t\tqy[0]=ys;\n\t\tf=1;\n/*\n\t\tfor(int i=0;i<=h;i++){\n\t\t\tfor(int j=0;j<=w;j++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tprintf(\"%d %d\\n\",c,m[xg][yg]);*/\n\t\twhile(f && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dy[i];\n\t\t\t\ty = qy[p] + dx[i];\n\t\t\t\tif(is(x,y) && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx[p+cnt] = x;\n\t\t\t\t\tqy[p+cnt] = y;\n\t\t\t\t\tif(x == xg && y == yg)f=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}\n\t\tputs(f?\"NG\":\"OK\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0 && mas[ys][xs]==mas[yg][xg]){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n\tgoal=0;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) 0<=a&&a<b\nusing namespace std;\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nint w,h,xs,ys,xg,yg,n,c,d,x,y,f[100][100];\nbool dfs(int y,int x){\n\tf[y][x]=0;\n\tif(y==yg&&x==xg)return 1;\n\tbool r=0;\n\trep(d,4){\n\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\tif(ck(ny,h)&&ck(nx,w)&&f[ny][nx]==c)r=r||dfs(ny,nx);\n\t}\n\treturn r;\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w)f[i][j]=0;\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\trep(i,n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\trep(j,(d?2:4))rep(k,(d?4:2))f[y+k][x+j]=c;\n\t\t}\n\t\tc=f[ys][xs];\n\t\tcout<<(c>0&&dfs(ys,xs)?\"OK\":\"NG\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid DFS(int x,int y,int c){\n    if(f[x][y]!=c)  return;\n\n    f[x][y]=10;\n    DFS(x+1,y,c);\n    DFS(x-1,y,c);\n    DFS(x,y+1,c);\n    DFS(x,y-1,c);\n}\n\nvoid print(int w,int h){\n    for(int i=1;i<=w;i++){\n        for(int j=1;j<=h;j++){\n            cout<<f[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    while(true){\n        cin>>w>>h;\n        if(w+h==0)  break;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                f[i][j]=-1;\n            }\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        for(int i=0;i<n;i++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            if(d==0){\n                for(int j = 0; j<4; j++){\n                    for(int k = 0; k<2; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }else{\n                for(int j = 0; j<2; j++){\n                    for(int k = 0; k<4; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }\n        }\n        //print(w,h);\n        DFS(xs,ys,f[xs][ys]);\n        //print(w,h);\n        if(f[xg][yg]==10){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[1024][1024];\nint xg,yg;\nint w,h;\nbool dfs(int x,int y,int col){\n\tif(x == xg && y == yg && stage[x][y] == col){\n\t\treturn true;\n\t}\n\trep(i,4){\n\t\tif(stage[x+dx[i]][y+dy[i]] == 0)continue;\n\t\tif(col == stage[x+dx[i]][y+dy[i]]){\n\t\t\treturn dfs(x + dx[i], y + dy[i], col);\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w|h){\n\t\tmemset(stage,0,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\n\t\trep(q,n){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\treps(i,x,x+4){\n\t\t\t\t\treps(j,y,y+2){\n\t\t\t\t\t\tstage[j][i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\treps(i,x,x+2){\n\t\t\t\t\treps(j,y,y+4){\n\t\t\t\t\t\tstage[j][i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(dfs(xs,ys,stage[xs][ys])) ? puts(\"OK\") : puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int h, int w, int color) {\n\tif (map[h][w] != color)\n\t\treturn;\n\tmap[h][w] = 0;\n\troute(h, w + 1, color);\n\troute(h + 1, w, color);\n\troute(h, w - 1, color);\n\troute(h - 1, w, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> h >> w >> xs >> ys >> xg >> yg >> n;\n\t\tif (h == 0 && w == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y+1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j <= 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\tif (map[xg][yg]==0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2&&y1+h1>=y2)||(x2==x1+w1&&y1<=y2+h2&&y1+h1>=y2)||(y1==y2+h2&&x1<=x2+w2&&x1+w1>=x2)||(y2==y1+h1&&x1<=x2+w2&&x2<=x1+w1))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\tque.push(*it);\n\t\t}\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define rep2(i, n) for(int i = 1; i <= n; ++i)\n#define INF 0\n#define MAX 102\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n \nint field[102][102];\nint h, w, sx, sy, gx, gy, n;\nint col, dire, x, y;\nint scol;\n\nbool dfs(int nx, int ny) {\n\tif(nx == gx && ny == gy) return true;\n\tfield[nx][ny] = -1;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tint nex = nx + dx[i];\n\t\tint ney = ny + dy[i];\n\t\tif(0 < nex && nex <= w && 0 < ney && ney <= h && scol == field[nex][ney]) {\n\t\t\tif(dfs(nex, ney)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(1) {\n\t\tscol = INF;\n\t\tcin >> h >> w;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tfor(int j = 1; j <= w; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif(h == 0 && w == 0) break;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(k, n) {\n\t\t\tcin >> col >> dire >> x >> y;\n\t\t\tif(dire == 1) {\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\tfor(int j = 0; j < 2; ++j) field[x+j][y+i] = col;\n\t\t\t\t}a\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\t\t\tfor(int j = 0; j < 4; ++j) field[x+j][y+i] = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscol = field[sx][sy];\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n    if (d == 0)//yokonaga\n    {\n        loop(i, 2)\n        {\n            loop(j, 4)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n    else//tatenaga\n    {\n        loop(i, 4)\n        {\n            loop(j, 2)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n}\n    bool a=false;\nbool dfs(int nx, int ny)\n{\n    if (nx == gx&&ny == gy)return true;\n    if (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n    grid_visited[nx][ny] = true;\n    if((nx+1) >= 0 && ny >= 0 && (nx+1) < h && ny < w)if(grid[nx + 1][ny]== grid[nx][ny])a|=dfs(nx + 1, ny);\n    if(nx >= 0 && (ny+1) >= 0 && nx < h && (ny+1) < w)if(grid[nx][ny+1]== grid[nx][ny])a|=dfs(nx, ny+1);\n    if((nx-1) >= 0 && ny >= 0 && (nx-1) < h && ny < w)if(grid[nx - 1][ny]== grid[nx][ny])a|=dfs(nx - 1, ny);\n    if(nx >= 0 && (ny-1) >= 0 && nx < h && (ny-1) < w)if(grid[nx][ny-1]== grid[nx][ny])a|=dfs(nx, ny-1);\n    //return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n    return a;\n    return false;\n}\nint main()\n{\n    while (1)\n    {\n        cin >> w >> h;\n        if (!w && !h) break;\n        else\n        {\n            cin >> sx >> sy >> gx >> gy >> n;\n            sx--; sy--; gx--; gy--;\n            loop(i, n)\n            {\n                int c, d, x, y;\n                cin >> c >> d >> x >> y;\n                x--; y--;\n                input(c, d, x, y);\n            }\n            /*loop(i, h)\n            {\n                loop(j, w)\n                {\n                    cout << grid[i][j] << \" \";\n                }\n                cout << endl;\n            }*/\n            a=false;\n            \n            cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nbool dfs(int x,int y,int color);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    memset(board,0,sizeof(board));\n    memset(cheak,0,sizeof(cheak));\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    xs--,ys--,xg--,yg--;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      x--,y--;\n      board[y][x]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]][x+b[j]]=c;\n\telse board[y+b[j]][x+a[j]]=c;\n      }\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs,ys,board[ys][xs])==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y,int color){\n  board[y][x]=0;\n  if(x==xg && y==yg) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==color && board[yn][xn]!=0){\n      if(dfs(xn,yn,board[yn][xn])==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<h;i++){\n\t\t\tfor(j=1;j<w;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tif(brock[ys][xs]!=brock[yg][xg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=ys;\n\t\t\tma.b=xs;\n\t\t\tma.c=brock[ys][xs];\n\t\t\tds[ys][xs]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==yg&&ba.b==xg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[yg][xg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=h&&ba.b+q[i]>0&&ba.b+q[i]<=w&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nint F[1000][1000];\n\n//?????????????????????\nvoid r(int yy,int xx,int z){\n if(F[yy][xx]!=z){\n\treturn ;\n }\n\nF[yy][xx]=10;\n\nr(yy-1,xx,z);\nr(yy,xx+1,z);\nr(yy+1,xx,z);\nr(yy,xx-1,z);\n\n}\n\n\n\n\nint main(){\n int w,h,xs,ys,xg,yg,n;\n int c,d,x,y;\n\nwhile(1){\n cin>>w>>h;\n\n//?????????????????????0???????????????\n if(w==0&&h==0)break;\n//???????????????????????????????????\\?????°????±??????£???????????????\n cin>>xs>>ys>>xg>>yg>>n;\n\n//n?????°???????????????????????????\nfor(int i=0;i<n;i++){\n\tcin>>c>>d>>x>>y;//?????????????????¨????????±????????????\n\tif(d==0){\n\t\tF[x  ][y]=c;\n\t\tF[x+1][y]=c;\n \t\tF[x+2][y]=c;\n \t\tF[x+3][y]=c;\n \t\tF[x  ][y+1]=c;\n \t\tF[x+1][y+1]=c;\n \t\tF[x+2][y+1]=c;\n \t\tF[x+3][y+1]=c;\n\t}\n\tif(d==1){\n\t\tF[x][y  ]=c;\n \t\tF[x][y+1]=c;\n\t\tF[x][y+2]=c;\n\t\tF[x][y+3]=c;\n \t\tF[x+1][y  ]=c;\n\t\tF[x+1][y+1]=c;\n\t\tF[x+1][y+2]=c;\n \t\tF[x+1][y+3]=c;\n\t}\n}\n\n//??\\????????????????????????\n\n\n//??????????????????\nr(xs,ys,F[xs][ys]);\n//??´???????????????\nif(F[xg][yg]==10){\n\tcout<<\"OK\"<<endl;\n}else{\n\tcout<<\"NG\"<<endl;\n}\n//???????????????????????????\nfor(int i=1;i<=w;i++){\n\tfor(int g=1;g<=w;g++){\n\t\tF[i][g]=6;\n\t}\n}\n//?????????????????????\n}\nreturn 0;\n}\n\n\n\n\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<MAX+2; i++ ) {\n      for ( int j=0; j<MAX+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n\n    next.push(ys*1000 + xs );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    /*\n      for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n      cout << map[i+1][j+1];\n      }\n      cout << endl;\n      }\n      cout << endl;\n    */\n    int xn,yn;\n    if ( map[yg][xg] == sc ) {\n\twhile ( !next.empty() ) {\n\t  point = next.front();\n\t  next.pop();\n\t  xn = point%1000;\n\t  yn = point/1000;\n\n\t  if (map[yn][xn] == 0 )\n\t    continue;\n\n\t  if (point == yg*1000+xg) {\n\t    goal = true;\n\t    break;\n\t  }\n\n\t  for ( int i=0; i<4; i++ ) {\n\t    if ( check[yn+dy[i]][xn+dx[i]] ) {\n\t      check[yn+dy[i]][xn+dx[i]] = false;\n\t      if ( map[yn+dy[i]][xn+dx[i]] == sc ) {\n\t\tnext.push((yn+dy[i])*1000+ xn +dx[i]);\n\t      }\n\t    }\n\t  }\n\t}\n\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint xs, ys;\nint xg, yg;\nint maze[102][102];\n\nusing P = pair<int, int>;\nvoid solve() {\n    int c = maze[ys][xs];\n    queue<P> que;\n    que.push(P(ys, xs));\n    set<P> visited;\n    visited.insert(P(ys, xs));\n    bool ok = false;\n    while (que.size()) {\n        auto p = que.front();\n        que.pop();\n        int y = p.first;\n        int x = p.second;\n        if (yg == y && xg == x) ok = true;\n        rep(k, 4) {\n            int ny = y + dy[k];\n            int nx = x + dx[k];\n            if (ny < 0 || nx < 0) continue;\n            if (h <= ny || w <= nx) continue;\n            if (maze[ny][nx] != c) continue;\n            if (visited.count(P(ny, nx))) continue;\n            visited.insert(P(ny, nx));\n            que.push(P(ny, nx));\n        }\n    }\n    cout << (ok ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        int n;\n        cin >> n;\n        rep(i, n) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                rep(i, 2) rep(j, 4) maze[y + i][x + j] = c;\n            } else {\n                rep(i, 4) rep(j, 2) maze[y + i][x + j] = c;\n            }\n        }\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconst int size = 110;\nint board[size][size];\nint visited[size][size];\nint xblocks[2][8] = { {0, 1, 2, 3, 0, 1, 2, 3},\n\t\t      {0, 0, 0, 0, 1, 1, 1, 1} };\nint yblocks[2][8] = { {0, 0, 0, 0, 1, 1, 1, 1},\n\t\t      {0, 1, 2, 3, 0, 1, 2, 3} };\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nint main() {\n  int w,h,xs,ys,xg,yg,n,c,d,x,y;\n  while(cin>>w>>h, w|h) {\n    for(int i=0; i<size; ++i)\n      for(int j=0; j<size; ++j) {\n\tboard[i][j] = 0;\n\tvisited[i][j] = 0;\n      }\n\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0; i<n; ++i) {\n      cin>>c>>d>>x>>y;\n      for(int j=0; j<8; ++j)\n\tboard[x+xblocks[d][j]][y+yblocks[d][j]] = c;\n    }\n\n    queue<pair<int,int> > Q;\n    Q.push(pair<int,int>(xs,ys));\n    while(!Q.empty()) {\n      pair<int,int> pos = Q.front(); Q.pop();\n      int nx = pos.first,ny = pos.second;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = 1;\n      if(nx == xg && ny == yg) {\n\tcout<<\"OK\"<<endl;\n\tgoto NEXT;\n      }\n\n      for(int i=0; i<4; ++i) {\n\tif(nx+dx[i] >= 0 && nx+dx[i] <= w &&\n\t   ny+dy[i] >= 0 && ny+dy[i] <= h &&\n\t   board[ny][nx] == board[ny+dy[i]][nx+dx[i]])\n\t  Q.push(pair<int,int>(nx+dx[i],ny+dy[i]));\n      }\n      board[ny][nx] = -1;\n    }\n    cout<<\"NG\"<<endl;\n  NEXT:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint block[100][100];\nint visited[100][100];\nbool memo[100][100];\nint w, h, xs, ys, xg, yg, n;\nint d[2][4]={{0,0,-1,1},{-1,1,0,0}};\nbool dfs(int x, int y) {\n    if (visited[y][x]) return memo[y][x];\n    if (x==xg-1&&y==yg-1) return true;\n    visited[y][x]=1;\n    for (int i=0; i<4; i++) {\n        int nx=x+d[0][i], ny=y+d[1][i];\n        if (nx>=0&&nx<w&&ny>=0&&ny<h&&block[y][x]==block[ny][nx]) {\n            if (dfs(nx,ny)) {\n                memo[y][x]=true;\n                return true;\n            }\n        }\n    }\n    memo[y][x]=false;\n    return false;\n}\nint main() {\n    while (scanf(\"%d%d\",&w,&h)) {\n        if (!w&&!h) break;\n        for (int i=0; i<100; i++) for (int j=0; j<100; j++) {\n            visited[i][j]=0;\n            block[i][j]=0;\n            memo[i][j]=false;\n        }\n        scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n        for (int i=0; i<n; i++) {\n            int c, d, x, y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            if (d) {\n                for (int j=y-1; j<y+3; j++) {\n                    for (int k=x-1; k<x+1; k++) {\n                        block[j][k]=c;\n                    }\n                }\n            } else {\n                for (int j=x-1; j<x+3; j++) {\n                    for (int k=y-1; k<y+1; k++) {\n                        block[k][j]=c;\n                    }\n                }\n            }\n        }\n        /*for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            printf(\"%d%c\",block[i][j],j==w-1?'\\n':' ');\n        }*/\n        if (dfs(xs,ys)) puts(\"OK\");\n        else puts(\"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      //if(c == 0)\n        //c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[105][105];\nint xg , yg , sc;\n\nvoid dfs(int x , int y ,int w , int h){\n\tif(x==xg&&y==yg) {\n\t\tb=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=sc || board[tx][ty]==0 || b ) continue;\n\t\tdfs( tx , ty , w , h );\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w|h){\n\t\tint xs , ys , n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) ;\n\t\telse  dfs( xs , ys , w , h );\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sy >> sx >> gy >> gx;\n        // sx--, sy--, gx--, gy--;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(H+1, vector<int>(W+1));\n        vector<vector<int> > used(H+1, vector<int>(W+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> y >> x;\n            // x--, y--;\n            if (!dir) {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        for (auto i : d) {\n            for (auto j : i) cout << j;\n            cout << endl;\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx <= H && 0 <= ny && ny <= W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint t[200][200],vd[200][200];\nint W,H,sx,sy,gx,gy,n,key;\n\nbool inField(int y,int x){\n  if(y<0||y>=H)return false;\n  if(x<0||x>=W)return false;\n  return true;\n}\n\nbool solve(int y,int x){\n  if(y==gy&&x==gx)return true;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(!inField(ny,nx))continue;\n    if(t[ny][nx]!=key)continue;\n    if(vd[ny][nx]==1)continue;\n    vd[ny][nx]=1;\n    if( solve(ny,nx) ) return true;\n  }\n  return false;\n}\n\nvoid init(){\n  for(int i=0;i<200;i++)\n    for(int j=0;j<200;j++)\n      t[i][j]=vd[i][j]=-1;\n}\n\nint main(){\n  int a,b,x,y;\n  while(cin>>W>>H){\n    if(W==0&&H==0)break;\n    init();\n    cin>>sx>>sy>>gx>>gy>>n;\n    sx--,sy--,gx--,gy--;\n    for(int k=0;k<n;k++){\n      cin>>a>>b>>x>>y;\n      x--,y--;\n      for(int i=0;i<(b==0?2:4);i++)\n\tfor(int j=0;j<(b==0?4:2);j++)\n\t  t[y+i][x+j]=a;\n    }\n    key=t[sy][sx];\n    cout<<(key!=-1&&solve(sy,sx)?\"OK\":\"NG\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 10;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tfor (int i = 0; i < 102; i++)\n\t\t\tfor (int j = 0; j < 102; j++)\n\t\t\t\tmap[i][j] = 0;\n\t\tcin >> w >> h;\t\t\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tcin>>xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 1) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\t\n\t\tif (map[xg][yg]==10)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\n\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y;\nint board[100][100];\t//添字は行、列の順\nint dirx[] = {-1, 0, 0, 1};\nint diry[] = {0, -1, 1, 0};\n//xs,ysから接する同じ色のところを100に置き換えていく\nvoid dfs(int x, int y)\n{\n\tboard[y][x] = 6;\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tint nx, ny;\n\t\t\n\t\tnx = x + dirx[i];\n\t\tny = y + diry[i];\n\t\t\n\t\tif (0<=nx && nx<w && 0<=ny && ny<h && board[ny][nx]==c)\n\t\t{\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile (cin >> w >> h)\n\t{\n\t\tif (w == 0 && h == 0) break;\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\t//board初期化\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\t//横向き\n\t\t\t\tboard[y-1][x-1] = board[y-1][x] = board[y-1][x+1] = board[y-1][x+2] = c;\n\t\t\t\tboard[y][x-1] = board[y][x] = board[y][x+1] = board[y][x+2] = c;\n\t\t\t} else {\n\t\t\t\t//縦向き\n\t\t\t\tboard[y-1][x-1] = board[y][x-1] = board[y+1][x-1] = board[y+2][x-1] = c;\n\t\t\t\tboard[y-1][x] = board[y][x] = board[y+1][x] = board[y+2][x] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(xs-1, ys-1);\n\t\tif (board[yg-1][xg-1] == 6)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t\n\t\t/*\n\t\t//テスト出力\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tcout << board[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nvoid fun(int y,int x){\n    if(map[y][x]==map[ys][xs]){\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y+1][x+1]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+2);\n    fun(y,x-2);\n    fun(y+2,x);\n    fun(y-2,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        fun(ys,xs);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nbool bfs(pair<int,int> [2],int [102][102]);\n\nint main(void){\n\tint w,h,xs,ys,xg,yg,n,board[102][102],dr[2][2]={4,2,2,4};\n\tpair<int,int> sg[2];\n\n\twhile(true){\n\t\tcin >> w >> h;\n\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tsg[0] = make_pair(xs,ys);\n\t\tsg[1] = make_pair(xg,yg);\n\n\t\tfor(int i=0;i<h+2;i++)\n\t\t\tfor(int j=0;j<w+2;j++)\n\t\t\t\tboard[j][i]=0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor(int j=0;j<dr[d][0];j++)\n\t\t\t\tfor(int k=0;k<dr[d][1];k++)\n\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t}\n\n\t\tcout << (bfs(sg,board)?\"OK\":\"NG\");\n\t\tcout << endl;\n\n\t}\n\n\treturn 0;\n}\n\nbool bfs(pair<int,int> sg[2],int board[102][102]){\n\tqueue< pair<int,int> > Q;\n\tpair<int,int> cur;\n\tint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1},c;\n\n\tQ.push(sg[0]);\n\tcur=Q.front();\n\tc=board[cur.first][cur.second];\n\n\twhile(!Q.empty()&&c!=0){\n\t\tcur=Q.front();\n\t\tQ.pop();\n\t\tboard[cur.first][cur.second]=0;\n\n\t\tif(cur==sg[1])\n\t\t\treturn true;\n\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(board[cur.first+dx[i]][cur.second+dy[j]]==c)\n\t\t\t\t\tQ.push(make_pair(cur.first+dx[i],cur.second+dy[j]));\n\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nchar start;\nvoid fun(int y,int x){\n    if(map[y][x]==start){\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y][x]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+1);\n    fun(y,x-1);\n    fun(y+1,x);\n    fun(y-1,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        start=map[ys][xs];\n        if(map[ys][xs]==0||map[yg][xg]==0);\n        else\n        \tfun(ys,xs);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w,h;\nint sx,sy,gx,gy;\nint n,c,d,x,y;\nint g[200][200];\nbool use[200][200];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nvoid rec(int Y,int X, char c){\n  if(use[Y][X])return;\n  use[Y][X] = true;\n\n  for(int i=0;i<4;i++){\n    int ny = Y+dy[i], nx = X+dx[i];\n    if(ny<1 || nx<1 || ny>h || nx>w)continue;\n    if(g[ny][nx] == c)rec(ny,nx,c);\n  }\n}\n\nint main(){\n  while(cin >> w >> h,w||h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++)g[i][j] = 0;\n    }\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d==0){\n\tfor(int j=0;j<2;j++){\n\t  for(int k=0;k<4;k++){\n\t    g[y+j][x+k] = c;\n\t  }\n\t}\n      }else{\n\tfor(int j=0;j<4;j++){\n\t  for(int k=0;k<2;k++){\n\t    g[y+j][x+k] = c;\n\t  }\n\t}\n      }\n    }\n\n    if(!g[sy][sx] || !g[gy][gx] || g[sy][sx] != g[gy][gx]){\n      cout << \"NG\\n\";\n    }else{\n      rec(sy,sx,g[sy][sx]);\n      cout << (use[gy][gx]?\"OK\":\"NG\") << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid DFS(int x,int y,int c){\n    if(f[x][y]!=c)  return;\n\n    f[x][y]=10;\n    DFS(x+1,y,c);\n    DFS(x-1,y,c);\n    DFS(x,y+1,c);\n    DFS(x,y-1,c);\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    while(true){\n        cin>>w>>h;\n        if(w+h==0)  break;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                f[i][j]=-1;\n            }\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        for(int i=0;i<n;i++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            if(d==0){\n                for(int j = 0; j<4; j++){\n                    for(int k = 0; k<2; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }else{\n                for(int j = 0; j<2; j++){\n                    for(int k = 0; k<4; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }\n        }\n        DFS(xs,ys,f[xs][ys]);\n        if(f[xg][yg]==10){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[2000];\n\nstd::queue<int> que;\nstd::list<int> adjacive[2000];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=-1;\n\t\tgoal=-1;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\t\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w-1>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h-1>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w-1>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h-1>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\n\t\tmakelist(n);\n\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2-1&&y1+h1-1>=y2)||(x2==x1+w1&&y1<=y2+h2-1&&y1+h1-1>=y2)||(y1==y2+h2&&x1<=x2+w2-1&&x1+w1-1>=x2)||(y2==y1+h1&&x1<=x2+w2-1&&x1+w1-1>=x2))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\n\tif(start==-1||goal==-1)return false;\n\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\t\tque.push(*it);\n\t\t}\n\t\tadjacive[survey].clear();\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {-1, 0, 1, 0};\n\nbool fill(vector<vector<int> > &v, int x, int y, int gx, int gy) {\n    if(x == gx && y == gy) return true;\n\n    int W = v.size();\n    int H = v[0].size();\n    int clr = v[x][y];\n    v[x][y] = 0;\n\n    for(int i = 0; i < 4; ++i) {\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n\n        if(0 <= xx && xx < W && 0 <= yy && yy < H) {\n            if(v[xx][yy] == clr) {\n                if(fill(v, xx, yy, gx, gy)) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while(true) {\n        int W, H;\n        int sx, sy, gx, gy;\n        int N;\n\n        cin >> W >> H;\n        if(!W && !H) break;\n        cin >> sx >> sy >> gx >> gy >> N;\n        --sx; --sy; --gx; --gy;\n\n        vector<vector<int> > v(W, vector<int>(H, 0));\n        for(int i = 0; i < N; ++i) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            --x; --y;\n            int w = d ? 2 : 4;\n            int h = d ? 4 : 2;\n            for(int dx = 0; dx < w; ++dx) \n                for(int dy = 0; dy < h; ++dy)\n                    v[x+dx][y+dy] = c;\n        }\n\n        if(v[sx][sy] != 0 && fill(v, sx, sy, gx, gy)) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint c,d,x,y;\nint map[101][101];\nint flg=0,temp;\nvoid func(int ,int);\nusing namespace std;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0){\n\t\t\tbreak;\n\t\t}\n\t\tint i,j,k;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(k=0;k<=1;k++){\n\t\t\t\t\tfor(j=0;j<=3;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d==1){\n\t\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\t\tfor(j=0;j<=1;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=w;i++){\n\t\t\tfor(j=1;j<=h;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tflg=0;\n\t\tif(map[xs][ys]==map[xg][yg] && map[xs][ys]!=0){\n\t\t\ttemp=map[xs][ys];\n\t\t\tmap[xs][ys]=0;\n\t\t\tfunc(ys,xs);\n\t\t}\n\t\tif(flg==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\nvoid func(int yy,int xx){\n\tint dy[4]={0,1,0,-1},dx[4]={1,0,-1,0};\n\tint i;\n\tfor(i=0;i<4;i++){\n\t\tyy=yy+dy[i];\n\t\txx=xx+dx[i];\n\t\tif(yy<=h && yy>=1 && xx<=w && xx>=1 && map[xx][yy]==temp){\n\t\t\tmap[xx][yy]=0;\n\t\t\tif(xg==xx && yg==yy){\n\t\t\t\tflg=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfunc(yy,xx);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nbool dfs(int ys,int xs,int yg,int xg,int c){\n  if(f[ys][xs]!=c)return 0;\n\n  if(ys==yg && xs==xg)return 1;;\n\n  f[ys][xs]=0;\n\n  bool flag=0;\n  flag += dfs(ys+1,xs,yg,xg,c);\n  flag += dfs(ys-1,xs,yg,xg,c);\n  flag += dfs(ys,xs+1,yg,xg,c);\n  flag += dfs(ys,xs-1,yg,xg,c);\n  return flag;\n}\n\nvoid set(int c,bool d,int x,int y){\n  if(d==0){\n    for(int i=0; i<4; i++){\n      f[y][x+i]=c;\n      f[y+1][x+i]=c;\n    }\n  }else if(d==1){\n    for(int i=0; i<4; i++){\n      f[y+i][x]=c;\n      f[y+i][x+1]=c;\n    }\n  }\n}\n\nint main(){\n  while(1){\n\n  int w,h;\n  cin >> w >> h;\n  if(w==0 && h==0)break;\n\n  int xs,ys;\n  cin >> xs >> ys;\n  int xg,yg;\n  cin >> xg >> yg;\n  int n;\n  cin >> n;\n\n  for(int i=0; i<n; i++){\n    bool d;\n    int c,x,y;\n    cin >> c >> d >> x >> y;\n    set(c,d,x,y);\n  }\n\n  if(dfs(ys,xs,yg,xg,f[ys][xs])){\n    cout << \"OK\\n\";\n  }else{\n    cout << \"NG\\n\";\n  }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid solve(vector<vector<int> > &v,int x,int y,int c,int w,int h){\n  if(x<1||y<1||w<x||h<y)return;\n  if(v[y][x]!=c)return;\n  v[y][x]=6;\n  solve(v,x+1,y,c,w,h);\n  solve(v,x-1,y,c,w,h);\n  solve(v,x,y-1,c,w,h);\n  solve(v,x,y+1,c,w,h);\n}\n\nint main(void){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int xs,ys,xg,yg,n;\n    vector<vector<int> > field(101);\n    for(int i=0;i<101;++i)field[i].resize(101);\n    cin>>xs>>ys>>xg>>yg>>n;\n    for(int i=0,c,d,x,y;i<n;++i){\n      cin>>c>>d>>x>>y;\n      if(d){\n        for(int j=y;j<y+4;++j)\n          for(int k=x;k<x+2;++k)\n            field[j][k]=c;\n      }else{\n        for(int j=y;j<y+2;++j)\n          for(int k=x;k<x+4;++k)\n            field[j][k]=c;\n      }\n    }\n    solve(field,xs,ys,field[ys][xs],w,h);\n    //for(int i=1;i<=h;++i){for(int j=1;j<=w;++j) cerr<<field[i][j]<<\" \";cerr<<endl;}\n    cout<<((field[yg][xg]==6)?\"OK\":\"NG\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\n\nint DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='w'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_Y(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='y'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_G(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='g'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\nint DFS_B(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='b'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n  int DFS_R(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='r'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n\nint main(){\n  int c[5];\n  int d[1];\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  int x[n];\n  int y[n];\n  cin>>w>>h;\n  while(w!=0){\n    int a=0;\n    int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n        int a=0;\n        int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      cnt=DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      cnt=DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      cnt=DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      cnt=DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      cnt=DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint moveTo[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\nint stage[100][100];\n\nvoid paint(int c,int d,int x,int y){\n\t//c:1~5 d: 0:horizonal 1:vertical\n\tif(d==0){\n\t\tfor(int i=x;i<x+4;i++){\n\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg){\n\tint cs = stage[ys][xs];\n\tint cg = stage[yg][xg];\n\tif(cs != cg) return false;\n\n\tqueue<P> que;\n\tque.push(P(xs,ys));\n\n\twhile(!que.empty()){\n\t\tint sx = que.front().first;\n\t\tint sy = que.front().second;\n\t\t\n\t\tif(sx == xg && sy == yg) return true;\n\t\tque.pop();\n\n\t\tstage[sy][sx] = -1;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = sx + moveTo[i][0];\n\t\t\tint dy = sy + moveTo[i][1];\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(stage[dy][dx] != cs || stage[dy][dx] == -1) continue;\n\t\t\tque.push(P(dx,dy));\n\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\n\t\tint xg,yg;\n\t\tscanf(\"%d %d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\t//c:1~5 d: 0:horizonal 1:vertical\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tpaint(c,d,x-1,y-1);\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(w,h,xs-1,ys-1,xg-1,yg-1) ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint main()\n{\n  int w, h;\n  while (cin >> w >> h) {\n    if ((w|h) == 0)\n      break;\n\n    int xs, ys, xg, yg;\n    cin >> xs >> ys >> xg >> yg;\n    --xs;\n    --ys;\n    --xg;\n    --yg;\n\n    int c;\n    cin >> c;\n    vector<vector<int> > block(h, vector<int>(w, -1));\n    for (int i = 0; i < c; ++i) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      --x;\n      --y;\n\n      if (d == 0) {\n\tfor (int j = 0; j < 4; ++j)\n\t  block[y][x+j] = block[y+1][x+j] = c;\n      } else {\n\tfor (int j = 0; j < 4; ++j)\n\t  block[y+j][x] = block[y+j][x+1] = c;\n      }\n    }\n\n    string ans = \"NG\";\n    queue<pair<int, int> > que;\n    que.push(make_pair(xs, ys));\n    vector<vector<int> > visited(h, vector<int>(w, 0));\n    while (!que.empty()) {\n      const pair<int, int> p = que.front();\n      que.pop();\n\n      if (p.second == yg && p.first == xg) {\n\tans = \"OK\";\n\tbreak;\n      }\n\n      if (visited[p.second][p.first])\n\tcontinue;\n      visited[p.second][p.first] = 1;\n\n      for (int d = 0; d < 4; ++d) {\n\tint x = p.first + dx[d];\n\tint y = p.second + dy[d];\n\tif (x < 0 || w <= x || y < 0 || h <= y ||\n\t    block[p.second][p.first] != block[y][x] || visited[y][x])\n\t  continue;\n\tque.push(make_pair(x, y));\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 0207\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct UF {\n\tvector <int> data;\n\tint cnt;\n\tUF(int n) : data(n, -1), cnt(n) {}\n\tbool merge(int a, int b){\n\t\ta = root(a), b = root(b);\n\t\tif (a != b){\n\t\t\tcnt--;\n\t\t\tif (data[b] < data[a]) std::swap(a, b);\n\t\t\tdata[a] += data[b];\n\t\t\tdata[b] = a;\n\t\t}\n\t\treturn a != b;\n\t}\n\tbool same(int a, int b){\n\t\treturn root(a) == root(b);\n\t}\n\tint root(int a){\n\t\treturn data[a] >= 0 ? data[a] = root(data[a]) : a;\n\t}\n\tint size(int a){\n\t\treturn ~data[root(a)];\n\t}\n\tint count(){\n\t\treturn cnt;\n\t}\n};\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w){\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\n\t\tint field[128][128] = {};\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tfor (int j = 0; j < 4; j++){\n\t\t\t\tfor (int k = 0; k < 2; k++){\n\t\t\t\t\tint jj = j, kk = k;\n\t\t\t\t\tif (d == 0) swap(jj, kk);\n\t\t\t\t\tjj += y; kk += x;\n\t\t\t\t\tfield[jj][kk] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tUF uf(128*128);\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (field[i][j] == 0) continue;\n\t\t\t\tif (field[i][j] == field[i][j + 1]){\n\t\t\t\t\tuf.merge(i * w + j, i * w + j + 1);\n\t\t\t\t}\n\t\t\t\tif (field[i][j] == field[i + 1][j]){\n\t\t\t\t\tuf.merge(i * w + j, i * w + w + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsy--; sx--; gx--; gy--;\n\t\tif (uf.same(sy * w + sx, gy * w + gx)){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint w,h;\nint map[105][105];\nint xg,yg;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid mapout()\n{\n  cout<<endl;\n  for(int xx=0;xx<h;xx++,cout<<endl)\n    for(int yy=0;yy<w;yy++)\n      if(map[xx][yy]!=-1)\n      cout<<map[xx][yy];\n      else\n\tcout<<\"X\";\n  cout<<endl;\n}\n\nbool check(int x,int y)\n{\n  //  cout<<\"check \"<<x<<\" \"<<y<<\";\"<<map[x][y]<<endl;\n  if(x==xg&&y==yg)\n    return true;\n  int buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]>0&&x+dx[i]<=h&&\n\t y+dy[i]>0&&y+dy[i]<=w&&\n\t buf==map[x+dx[i]][y+dy[i]] &&\n\t map[x+dx[i]][y+dy[i]]!=-1 &&\n\t check(x+dx[i],y+dy[i]))\n\treturn true;\n    }\n\n  \n  return false;\n}\n\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>xs>>ys;\n      cin>>xg>>yg;\n      //      xs--;ys--;\n      //      xg--;yg--;\n      \n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  ///  x--;y--;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      //   mapout();\n      //\t cout<<xs<<\" \"<<ys<<\" \"<<map[xs][ys]<<endl;\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;\n      // mapout();\n    }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\n\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, newc;\nint board[100][100];\t//添字は行、列の順\nint dirx[] = {-1, 0, 0, 1};\nint diry[] = {0, -1, 1, 0};\n//xs,ysから接する同じ色のところを100に置き換えていく\nvoid dfs(int x, int y)\n{\n\tboard[y][x] = 6;\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tint nx, ny;\n\t\t\n\t\tnx = x + dirx[i];\n\t\tny = y + diry[i];\n\t\t\n\t\tif (0<=nx && nx<w && 0<=ny && ny<h && board[ny][nx]==newc)\n\t\t{\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile (cin >> w >> h)\n\t{\n\t\tif (w == 0 && h == 0) break;\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\t//board初期化\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\t//横向き\n\t\t\t\tboard[y-1][x-1] = board[y-1][x] = board[y-1][x+1] = board[y-1][x+2] = c;\n\t\t\t\tboard[y][x-1] = board[y][x] = board[y][x+1] = board[y][x+2] = c;\n\t\t\t} else {\n\t\t\t\t//縦向き\n\t\t\t\tboard[y-1][x-1] = board[y][x-1] = board[y+1][x-1] = board[y+2][x-1] = c;\n\t\t\t\tboard[y-1][x] = board[y][x] = board[y+1][x] = board[y+2][x] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tnewc = board[ys-1][xs-1];\n\t\tdfs(xs-1, ys-1);\n\t\tif (board[yg-1][xg-1] == 6)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t\n\t\t\n\t\t//テスト出力\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tcout << board[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[105][105];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\t//memset(board,0,sizeof(board));\n\t\tfor(int i=0;i<105;++i){\n\t\t\tfor(int j=0;j<105;++j){\n\t\t\t\tboard[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n\n\n\n#define MAX 150\n\nint map[MAX][MAX];\n\nvoid makemap(int c, int d, int x, int y);\n\nint bfs(int xs,int ys,int xg,int yg);\n\nint main()\n{\n\tint w,h,xs,ys,xg,yg,n,c,d,x,y;\n\t//int flag=1;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)\n\t\t\treturn 0;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\n\t\t/*w=20;\n\t\th=20;\n\t\tif (flag==0)\n\t\t{\n\t\t\txs=1;\n\t\t\tys=1;\n\t\t\txg=9;\n\t\t\tyg=9;\n\t\t\tn=7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txs=9;\n\t\t\tys=9;\n\t\t\txg=1;\n\t\t\tyg=1;\n\t\t\tn=6;\n\t\t}サンプルデータ入力*/\n\t\tfor(int i=0;i<MAX;i++)\n\t\t\tfor(int j=0;j<MAX;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t/*if (flag==0)\n\t\t{\n\t\t\tmakemap(2,0,1,1);\n\t\t\tmakemap(5,1,1,3);\n\t\t\tmakemap(2,1,3,3);\n\t\t\tmakemap(1,1,5,2);\n\t\t\tmakemap(5,1,7,3);\n\t\t\tmakemap(2,0,2,7);\n\t\t\tmakemap(2,0,6,8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmakemap(2,0,1,1);\n\t\t\tmakemap(1,0,5,1);\n\t\t\tmakemap(2,1,1,3);\n\t\t\tmakemap(5,0,1,7);\n\t\t\tmakemap(3,1,5,5);\n\t\t\tmakemap(4,1,8,5);\n\t\t}サンプルデータ入力２*/\n\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tmakemap(c,d,x,y);\n\t\t}\n\t\t\n\n\t\t/*for(int i=0;i<MAX;i++)\n\t\t{\n\t\t\tfor(int j=0;j<MAX;j++)\n\t\t\t\tprintf(\"%d\",map[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}マップの表示*/\n\n\t\tif(bfs(xs,ys,xg,yg)==0)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n}\n\treturn 0;\n}\n\nvoid makemap(int c, int d, int x, int y)\n{\n\tif(d==0)\n\t\tfor(int i=x+1;i<x+5;i++)\n\t\t\tfor(int j=y+1;j<y+3;j++)\n\t\t\t\tmap[i][j]=c;\n\telse\n\t\tfor(int i=x+1;i<x+3;i++)\n\t\t\tfor(int j=y+1;j<y+5;j++)\n\t\t\t\tmap[i][j]=c;\n}\n\nint bfs(int xs,int ys,int xg,int yg)\n{\n\tint startcolor=map[xs][ys];\n\tint nowx=xs,nowy=ys;\n\tusing namespace std;\n\tqueue<int> x;\n\tqueue<int> y;\n\twhile(1)\n\t{\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}\n\t/*bool visit[MAX][MAX];\n\tfor(int i=0;i<MAX;i++)\n\t\tfor(int j=0;j<MAX;j++)\n\t\t\tvisit[i][j]=0;\n\twhile(1)\n\t{\n\t\t//visit[nowx][nowy]=1;\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor && visit[nowx-1][nowy]==0)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor && visit[nowx][nowy-1]==0)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor && visit[nowx][nowy+1]==0)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor && visit[nowx+1][nowy]==0)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "def g;gets.split.map &:to_i;end\nwhile(w,h=g)[0]>0\nt,u=s=g;e=g\nm=[v=[6]*(w+2)]+(1..h).map{[6]+[0]*w<<6}<<v\ng[0].times{c,d,x,y=g;o=d<1?4:2;m[y,6-o].map{|i|i[x,o]=[c]*o}}\nq=[s]\nc=m[t][u]\n(q.uniq!;a,b=q.shift;m[a][b]=7;[[a,b+1],[a,b-1],[a+1,b],[a-1,b]].map{|i,j|m[i][j]==c&&q<<[i,j]})while q[0]&&q[0]!=e\nputs q[0]?:OK:\"NG\"end"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <functional> //sort(A,A.end(),greater<int>());???????????????\n#include <queue>\n#include <stack>\n#include <vector>\n\n#define INF 10 << 10\n#define MP make_pair\n\nint map[124][124];\nbool map_flg[124][124];\nint x_move[] = { 0,0,1,-1 };\nint y_move[] = { -1,1,0,0 };\n\nint main() {\n\tint w, h;\n\n\twhile (cin >> w >> h && w != 0 && h != 0) {\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(map_flg, true, sizeof(map_flg));\n\t\tint xs, ys;\n\t\tint xg, yg;\n\t\tint n;\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint x_, y_;\n\t\t\tif (d == 0) {\n\t\t\t\tx_ = 4;\n\t\t\t\ty_ = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_ = 2;\n\t\t\t\ty_ = 4;\n\t\t\t}\n\t\t\tfor (int j = y; j < y + y_; ++j) {\n\t\t\t\tfor (int j2 = x; j2 < x + x_; ++j2) {\n\t\t\t\t\tmap[j][j2] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (map[ys][xs] != map[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstack<pair<int, int> > st;\n\t\tst.push(MP(xs, ys));\n\t\tint m_c = map[ys][xs];\n\t\tbool flg = false;\n\t\twhile (!st.empty()) {\n\t\t\tint x = st.top().first, y = st.top().second;\n\t\t\tst.pop();\n\t\t\tmap_flg[y][x] = false;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint x_ = x + x_move[i], y_ = y + y_move[i];\n\t\t\t\tif (map[y_][x_] == m_c && map_flg[y_][x_]) {\n\t\t\t\t\tif (y_ == yg && x_ == xg) {\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tst.push(MP(x_, y_));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flg) { break; }\n\t\t}\n\n\t\tif (flg) { cout << \"OK\" << endl; }\n\t\telse { cout << \"NG\" << endl; }\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL p=7+1e+9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint W, H;\nint xs, ys, xg, yg;\nint N, C;\nint maze[128][128];\n\nint dfs(int x, int y){\n\tif(x == xg && y == yg)\n\t\treturn 1;\n\tmaze[y][x] = 0;\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(maze[ny][nx] == C){\n\t\t\tif(dfs(nx, ny))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin >> W >> H && (W || H)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tcin >> xs >> ys >> xg >> yg >> N;\n\t\tint c, d, x, y;\n\t\tREP(i,N){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,2)\n\t\t\t\t\tREP(k,4)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(j,4)\n\t\t\t\t\tREP(k,2)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t\tC = maze[ys][xs];\n\t\tif(C == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(dfs(xs, ys)){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "include<iostream>\nusing namespace std;\n#define MAX_H 100\n#define MAX_W 100\n#define INF 1000;\nint h,w;\nint field[MAX_H][MAX_W];\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nvoid dfs(int y,int x,const int sc){\n\tif(y<=0 || x<=0 || y>h || x>w)return;\n\tif(field[y][x]==sc){\n\t\tfield[y][x]=0;\n\t\tfor(int i=0;i<4;i++)dfs(y+dy[i],x+dx[i],sc);\n\t}\n\treturn;\n}\nint main(){\n\tint sx,sy,gx,gy,n;\n\twhile(cin>>w>>h){\n        if(!w && !h)break;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=0;i<MAX_H;i++){\n\t\t\tfor(int j=0;j<MAX_W;j++){\n\t\t\t\t\tfield[i][j]=INF;\n\t\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tif(d)field[y+j][x+i]=c;\n\t\t\t\t\telse field[y+i][x+j]=c;\t\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\tdfs(sy,sx,field[sy][sx]);\t\t\n\t\tif(field[gy][gx])cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\t\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <stack>\n# include <cstring>\n\ntypedef std::pair<int, int> P;\n\nconstexpr int INF = (int)1e7;\nconstexpr int MAX = 100;\n\nint w, h;\nint board[MAX][MAX];\nP start, goal;\nint n;\nint d[MAX][MAX], dx[4] = { 1,-1,0,0 }, dy[4] = { 0,0,1,-1 };\n\nbool dfs(P s, P g) {\n\tbool res = false;\n\tfor (int i = 0; i < h; ++i)\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\td[i][j] = INF;\n\tstd::stack<P> stk;\n\tstk.push(s);\n\td[s.second][s.first] = 0;\n\twhile (!stk.empty()) {\n\t\tP p = stk.top(); stk.pop();\n\t\tif (p == g) {\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nx = p.first + dx[i];\n\t\t\tint ny = p.second + dy[i];\n\t\t\tif (0 <= nx&&nx < w &&\n\t\t\t\t0 <= ny&&ny < h&&\n\t\t\t\td[ny][nx] == INF&&board[ny][nx] == board[p.second][p.first]) {\n\t\t\t\td[ny][nx] = d[p.second][p.first] + 1;\n\t\t\t\tstk.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> w >> h;\n\t\tif (w + h == 0)\n\t\t\tbreak;\n\t\tstd::memset(board, 0, sizeof(board));\n\n\t\tstd::cin >> start.first >> start.second\n\t\t\t>> goal.first >> goal.second >> n;\n\t\t--start.first;\n\t\t--start.second;\n\t\t--goal.first;\n\t\t--goal.second;\n\t\tint c, d, x, y;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\t\tint& a = (d) ? board[y - 1 + i][x - 1 + j] : board[y - 1 + j][x - 1 + i];\n\t\t\t\t\ta = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(start, goal))\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\telse\n\t\t\tstd::cout << \"NG\" << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nint dx[] ={-1,0,1,0};\nint dy[] ={0,-1,0,1};\n\nint w, h, sx, sy, gx, gy, n;\nint c, d, x, y, nx, ny;\n\nint dat[110][110];\nbool used[110][110];\n\nbool outOfRange(int x, int y){\n\tif(x > w || x < 1 || y > h || y < 1) return true;\n\treturn false;\n}\n\n\nint main(){\n\twhile(cin>>w>>h && w && h){\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\trep(i, 110) rep(j, 110) dat[i][j] = 0, used[i][j] = false;\n\t\trep(i, n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tdat[x+j][y+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tdat[x+k][y+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pair<int, pii> > q;\n\t\tpair<int, pii> p;\n\t\tq.push(mp(0, mp(sx, sy)));\n\t\tused[sx][sy] = true;\n\t\tbool ans = false;\n\n\t\twhile(!q.empty()){\n\t\t\tp = q.front(); q.pop();\n\t\t\tc = p.fi;\n\t\t\tx = p.se.fi;\n\t\t\ty = p.se.se;\n\t\t\tif(x == gx && y == gy){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(outOfRange(nx, ny) || used[nx][ny] == true) continue;\n\t\t\t\tif(dat[x][y]==dat[nx][ny]){\n\t\t\t\t\tq.push(mp(c+1, mp(nx, ny)));\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ans?\"OK\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint main() {\n\tint w, h, sx, sy, gx, gy, n;\n\twhile (cin >> w >> h, w) {\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tint map[110][110] = {};\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y;\n\t\t\tmap[x][y] = c;\n\t\t\tmap[x][y + 1] = c;\n\t\t\tmap[x + 1][y] = c;\n\t\t\tmap[x + 1][y + 1] = c;\n\t\t\tif (d == 0) {\n\t\t\t\tmap[x + 2][y] = c;\n\t\t\t\tmap[x + 2][y + 1] = c;\n\t\t\t\tmap[x + 3][y] = c;\n\t\t\t\tmap[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[x][y + 2] = c;\n\t\t\t\tmap[x + 1][y + 2] = c;\n\t\t\t\tmap[x][y + 3] = c;\n\t\t\t\tmap[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> >q;\n\t\tint p = map[sx][sy];\n\t\tif (p == 0)goto museum;\n\t\tq.push(make_pair(sx, sy));\n\t\twhile (q.size()) {\n\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\tq.pop();\n\t\t\tmap[x][y] = 0;\n\t\t\tif (x == gx&&y == gy)goto heaven;\n\t\t\tif (map[x][y - 1] == p)q.push(make_pair(x, y - 1));\n\t\t\tif (map[x][y + 1] == p)q.push(make_pair(x, y + 1));\n\t\t\tif (map[x - 1][y] == p)q.push(make_pair(x - 1, y));\n\t\t\tif (map[x + 1][y] == p)q.push(make_pair(x + 1, y));\n\t\t}\n\t\tmuseum:cout << \"NG\\n\"; goto park;\n\theaven:cout << \"OK\\n\";\n\tpark:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint W, H, GoalX, GoalY, TargetColor;\nint MapData[101][101];\nconst int Dx[] = {1,0,-1,0}; // right,down,left,up\nconst int Dy[] = {0,1,0,-1};\n\n\nvoid setBlock(int c, int d, int x, int y) {\n\tint lenX, lenY;\n\n\tif (d == 1) {\n\t\tlenX = x + 2;\n\t\tlenY = y + 4;\n\t}\n\telse {\n\t\tlenX = x + 4;\n\t\tlenY = y + 2;\n\t}\n\n\tfor (int i = y; i < lenY; ++i) {\n\t\tfor (int j = x; j < lenX; ++j) {\n\t\t\tMapData[i][j] = c;\n\t\t}\n\t}\n}\n\nbool solve(int x, int y) {\n\tint nowX, nowY;\n\n\tif (x == GoalX && y == GoalY) {\n\t\treturn true;\n\t}\n\n\tMapData[y][x] = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tnowX = x + Dx[i];\n\t\tnowY = y + Dy[i];\n\n\t\tif (nowX<1 || nowX>W || nowY<1 || nowY>H) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (MapData[nowY][nowX] == TargetColor && solve(nowX, nowY)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint n, c, d, x, y, startX, startY;\n\n\twhile (cin >> W >> H, W) {\n\t\tcin >> startX >> startY >> GoalX >> GoalY >> n;\n\t\tmemset(MapData, 0, sizeof(MapData));\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tsetBlock(c, d, x, y);\n\t\t}\n\n\t\tTargetColor = MapData[startY][startX];\n\t\t//cout << \"startColor:\" << TargetColor << endl;\n\t\tif (TargetColor == 0) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (solve(startX, startY)) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( !color[x][y] )\n\t\treturn false;\n\tif ( color[x][y] == color[x + 1][y] && dp[x + 1][y] )\n\t\tif ( solve(x + 1, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] && dp[x][y + 1] )\n\t\tif ( solve(x, y + 1) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] && dp[x][y - 1] )\n\t\tif ( solve(x, y - 1) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] && dp[x - 1][y] )\n\t\tif ( solve(x - 1, y) )\n\t\t\treturn true;\n\tdp[x][y] = false;\n\treturn false;\n}\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i <= board_range_w + 1; i++ ){\n\t\t\tfor ( int j = 0; j <= board_range_h + 1; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t\tdp[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( !block_quarter ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( solve(start_x, start_y) ) \n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint s,t,u,v,n,c,d,x,y,i,j,f[102][102],a[4]={1,0,-1,0};int rec(int x,int y){if(f[x][y]==c)for(int i=4;i-->0;f[x][y]=9)rec(x+a[i],y+a[(i+3)%4]);}main(){for(;std::cin>>x>>y>>s>>t>>u>>v>>n,x;puts(f[u][v]-9?\"NG\":\"OK\")){for(j=0;j++<101;)for(i=0;i++<101;)f[i][j]=0;for(;n-->0;c=f[s][t]){std::cin>>c>>d>>x>>y;for(i=2;d&i-->0;)for(j=4;j-->0;)f[x+i][y+j]=c;for(i=4;!d&i-->0;)for(j=2;j-->0;)f[x+i][y+j]=c;}c&&rec(s,t);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 1000000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nint block[101][101];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h,xs,ys,xg,yg,n;\nstring ans;\n\nvoid dfs(int x,int y,bool f[][101]){\n\tif(x==xg&&y==yg){\n\t\tans=\"OK\";\n\t\treturn;\n\t}\n\tfor(int i=0; i<4; ++i){\n\t\tint nx,ny;\n\t\tnx=x+dx[i];\n\t\tny=y+dy[i];\n\t\tif(1<=nx&&nx<=w&&1<=ny&&ny<=h&&block[ny][nx]==block[ys][xs]&&!f[ny][nx]){\n\t\t\tf[ny][nx]=true;\n\t\t\tdfs(nx,ny,f);\n\t\t\tf[nx][ny]=false;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h){\n\tif(w==0&&h==0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tblock[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int j=0; j<2; ++j){\n\t\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\t\tblock[y+j][x+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int j=0; j<4; ++j){\n\t\t\t\t\tfor(int k=0; k<2; ++k){\n\t\t\t\t\t\tblock[y+j][x+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f[101][101];\n\t\tmemset(f,0,sizeof(f));\n\t\tf[xs][ys]=true;\n\t\tans=\"NG\";\n\t\tdfs(xs,ys,f);\n\t\tcout << ans << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n\n\n\n//マップの大きさの最大値\n#define MAP_MAX\t\t100\n//最初の歩数\n#define START\t\t1000000\n//マップの配列\nint wh_map[MAP_MAX + 1][MAP_MAX + 1];\n//縦・横に進むための配列\nint h_tate[4] = {1 , -1 , 0 , 0};\nint h_yoko[4] = {0 , 0 , 1 , -1};\n\n\n\n//----- blockの情報を持つ構造体 -----//\ntypedef struct block\n{\n\tint iro;\n\tint muki;\n\tint x;\n\tint y;\n}S_block;\n\n\n\n//----- 答えを返す関数 -----//\nbool f_ans(int , int  , int , int , int , int);\n\n\n//----- ブロックの入力は長くなるので関数で -----//\nint f_block_syokika(S_block[] , int , int , int);\n\n\n\n//----- マップを-1で初期化する変数 -----//\nvoid f_mapsyokika(void);\n\n\n\n//----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(メモリ節約のために構造体は参照で受ける) -----//\nvoid f_okmap(S_block[] , int , int , int , int);\n\n\n\n\n//*****----- main -----*****//\n\nint main(void)\n{\n\t//ボードの大きさ\n\tint tate = 0 , yoko = 0;\n\t//スタートの座標\n\tint startx = 0 , starty = 0;\n\t//ゴール座標\n\tint goalx = 0 , goaly = 0;\n\t//ブロックの個数\n\tint n = 0;\n\t//スタートと同じ色\n\tint startcolor = 0;\n\n\twhile (1)\n\t{\n\t\t//それぞれ入力\n\t\tscanf(\"%d%d\" , &tate , &yoko);\n\t\tif (tate == 0 && yoko == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t//スタート・ゴール座標\n\t\tscanf(\"%d%d\" , &startx , &starty);\n\t\tscanf(\"%d%d\" , &goalx , &goaly);\n\t\t//ブロックの個数\n\t\tscanf(\"%d\" , &n);\n\n\t\t//ブロックの分だけ領域を確保する\n\t\tS_block *s_block = new S_block[n];\n\n\t\t//関数で初期化\n\t\tstartcolor = f_block_syokika(s_block , n , starty , startx);\n\t\t//次にマップを初期化\n\t\tf_mapsyokika();\n\n\t\t//mapにSTARTを振り分ける\n\t\tf_okmap(s_block , starty , startx , startcolor , n);\n\n\t\tif (f_ans(starty , startx , goaly , goalx , tate , yoko) == true)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\n\t\t//一度メモリを解放\n\t\tdelete []s_block;\n\t}\n}\n\n\n\n\n//*****----- ブロックの情報を入力する関数 -----*****//\n\nint f_block_syokika(S_block s_data[] , int n , int starty , int startx)\n{\n\t//スタートの色を取り出す変数\n\tint startcolor = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\" , &s_data[i].iro , &s_data[i].muki , &s_data[i].x , &s_data[i].y);\n\n\t\t//色を取り出す(横向きなら)\n\t\tif (s_data[i].muki == 1)\n\t\t{\n\t\t\t//横向きに設置したと仮定し、その中にスタート座標が含まれているかどうか調べる\n\t\t\tif ((starty <= s_data[i].y + 1 && starty >= s_data[i].y) && (startx >= s_data[i].x && startx <= s_data[i].x + 3))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t\t//縦向きだった\n\t\telse\n\t\t{\n\t\t\t//縦向きに設置したと仮定し、その中にスタート座標が含まれているか調べる\n\t\t\tif ((starty <= s_data[i].y + 3 && starty >= s_data[i].y) && (startx >= s_data[i].x && startx <= s_data[i].x + 1))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t}\n\n\t//初期座標の値を返す\n\treturn startcolor;\n}\n\n\n\n//*****----- 答えを求める関数 -----*****//\n\nbool f_ans(int starty , int startx , int goaly , int goalx , int tateindex , int yokoindex)\n{\n\t//幅優先探索で使うｙとｘ\n\tstd::queue<int> x;\n\tstd::queue<int> y;\n\n\t//最初の座標をキューに追加\n\ty.push(starty);\n\tx.push(startx);\n\t\n\n\t//キューがなくなるまで\n\twhile (!x.empty())\n\t{\n\t\t//ｙ座標とｘ座標を取り出す\n\t\tint yy = y.front();\n\t\tint xx = x.front();\n\t\t//デキュー\n\t\ty.pop();\n\t\tx.pop();\n\n\t\t//ゴールにたどり着いた\n\t\tif (yy == goaly && xx == goalx)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t//今いる座標の値を吹っ飛ばす\n\t\twh_map[yy][xx] = -1;\n\n\t\t//四方に散れるか調べる\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t//次に進む座標を取得\n\t\t\tint nexty = yy + h_tate[i];\n\t\t\tint nextx = xx + h_yoko[i];\n\n\t\t\t//まずは範囲内かどうか調べる\n\t\t\tif (nexty >= 1 && nexty <= tateindex && nextx >= 1 && nextx <= yokoindex)\n\t\t\t{\n\t\t\t\t//そこが通れる場所且つブロックの色が同じとき\n\t\t\t\tif (wh_map[nexty][nextx] == START)\n\t\t\t\t{\n\t\t\t\t\t//ｙとｘをそれぞれ追加\n\t\t\t\t\ty.push(nexty);\n\t\t\t\t\tx.push(nextx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\n//*****----- マップを初期化する関数 -----*****//\n\nvoid f_mapsyokika(void)\n{\n\tfor (int i = 1; i < MAP_MAX + 1; i++)\n\t{\n\t\tfor (int j = 1; j < MAP_MAX + 1; j++)\n\t\t{\n\t\t\twh_map[i][j] = -1;\n\t\t}\n\t}\n}\n\n\n\n//*****----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(構造体は配列) -----*****//\n\nvoid f_okmap(S_block s_data[] , int starty , int startx , int startcolor , int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s_data[i].iro == startcolor)\n\t\t{\n\t\t\t//縦か横かによって挙動が変わる\n\t\t\tif (s_data[i].muki == 0)\n\t\t\t{\n\t\t\t\t//2 * 4マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0;k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + j][s_data[i].x + k] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//横だった\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 4 * 2マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + k][s_data[i].x + j] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  if(F[xs][ys] == 10){\ncout << \"NG\" << endl;\ncontinue;\n}\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nint dx[]={0,0,0,0,1,1,1,1};\nint dy[]={0,1,2,3,0,1,2,3};\nint fx[]={-1,0,0,1};\nint fy[]={0,-1,1,0};\nsigned main(){\n\tint a,b;\n\twhile(cin>>a>>b,a||b){\n\t\tint c,d,e,f,g;\n\tscanf(\"%d%d%d%d%d\",&c,&d,&e,&f,&g);\n\tc--;d--;e--;f--;\n\tchar h[100][100]{};\n\tfor(int i=0;i<g;i++){\n\t\tint j,k,l,m;\n\t\tscanf(\"%d%d%d%d\",&j,&k,&l,&m);\n\t\tl--;m--;\n\t\tif(k){\n\t\t\tfor(int n=0;n<8;n++)h[l+dx[n]][m+dy[n]]=j;\n\t\t}\n\t\telse{\n\t\t\tfor(int n=0;n<8;n++)h[l+dy[n]][m+dx[n]]=j;\n\t\t}\n\t}\n\tqueue<P>Q;\n\tint s[100][100];\nfor(int ss=0;ss<a;ss++){\n\tfor(int qq=0;qq<b;qq++)s[ss][qq]=-1;\n}\n\ts[c][d]=0;\n\tQ.push(P(c,d));\n\twhile(Q.size()){\n\t\tP w=Q.front();\n\t\tQ.pop();\n\t\tif(w==P(e,f)){break;}\n\t\tfor(int z=0;z<4;z++){\n\t\t\tint lx=(w).first+fx[z];\n\t\t\tint ly=(w).second+fy[z];\n\t\t\tif(lx>=0&&lx<a&&ly>=0&&ly<b&&h[lx][ly]==h[c][d]&&s[lx][ly]==-1){\n\t\t\t\ts[lx][ly]=s[(w).first][(w).second]+1;\n\t\t\t\tQ.push(P(lx,ly));\n\t\t\t}\n\t\t}\n\t}\nif(s[e][f]!=-1)printf(\"OK\\n\");\nelse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<queue>\n\n\n\n//マップの大きさの最大値\n#define MAP_MAX\t\t100\n//最初の歩数\n#define START\t\t1000000\n//マップの配列\nint wh_map[MAP_MAX + 1][MAP_MAX + 1];\n//縦・横に進むための配列\nint h_tate[4] = {1 , -1 , 0 , 0};\nint h_yoko[4] = {0 , 0 , 1 , -1};\n\n\n\n//----- blockの情報を持つ構造体 -----//\ntypedef struct block\n{\n\tint iro;\n\tint muki;\n\tint x;\n\tint y;\n}S_block;\n\n\n\n//----- 答えを返す関数 -----//\nbool f_ans(int , int  , int , int , int , int);\n\n\n//----- ブロックの入力は長くなるので関数で -----//\nint f_block_syokika(S_block* , int , int , int);\n\n\n\n//----- マップを-1で初期化する変数 -----//\nvoid f_mapsyokika(void);\n\n\n\n//----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(メモリ節約のために構造体は参照で受ける) -----//\nvoid f_okmap(S_block[] , int , int , int , int);\n\n\n\n\n//*****----- main -----*****//\n\nint main(void)\n{\n\t//ボードの大きさ\n\tint tate = 0 , yoko = 0;\n\t//スタートの座標\n\tint startx = 0 , starty = 0;\n\t//ゴール座標\n\tint goalx = 0 , goaly = 0;\n\t//ブロックの個数\n\tint n = 0;\n\t//スタートと同じ色\n\tint startcolor = 0;\n\n\twhile (1)\n\t{\n\t\t//それぞれ入力\n\t\tscanf(\"%d%d\" , &tate , &yoko);\n\t\tif (tate == 0 && yoko == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t//スタート・ゴール座標\n\t\tscanf(\"%d%d\" , &startx , &starty);\n\t\tscanf(\"%d%d\" , &goalx , &goaly);\n\t\t//ブロックの個数\n\t\tscanf(\"%d\" , &n);\n\n\t\t//ブロックの分だけ領域を確保する\n\t\tS_block *s_block = new S_block[n];\n\n\t\t//関数で初期化\n\t\tstartcolor = f_block_syokika(s_block , n , starty , startx);\n\t\t//次にマップを初期化\n\t\tf_mapsyokika();\n\n\t\t//mapにSTARTを振り分ける\n\t\tf_okmap(s_block , starty , startx , startcolor , n);\n\n\t\tif (f_ans(starty , startx , goaly , goalx , tate , yoko) == true)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\n\t\t//一度メモリを解放\n\t\tdelete []s_block;\n\t}\n}\n\n\n\n\n//*****----- ブロックの情報を入力する関数 -----*****//\n\nint f_block_syokika(S_block *s_data , int n , int starty , int startx)\n{\n\t//スタートの色を取り出す変数\n\tint startcolor = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\" , &s_data[i].iro , &s_data[i].muki , &s_data[i].x , &s_data[i].y);\n\n\t\t//色を取り出す(横向きなら)\n\t\tif (s_data[i].muki == 1)\n\t\t{\n\t\t\t//横向きに設置したと仮定し、その中にスタート座標が含まれているかどうか調べる\n\t\t\tif ((starty <= s_data[i].y && starty >= s_data[i].y - 1) && (startx >= s_data[i].x && startx <= s_data[i].x + 3))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t\t//縦向きだった\n\t\telse\n\t\t{\n\t\t\t//縦向きに設置したと仮定し、その中にスタート座標が含まれているか調べる\n\t\t\tif ((starty <= s_data[i].y && starty >= s_data[i].y - 3) && (startx >= s_data[i].x && s_data[i].x + 1))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t}\n\n\t//初期座標の値を返す\n\treturn startcolor;\n}\n\n\n\n//*****----- 答えを求める関数 -----*****//\n\nbool f_ans(int starty , int startx , int goaly , int goalx , int tateindex , int yokoindex)\n{\n\t//幅優先探索で使うｙとｘ\n\tstd::queue<int> x;\n\tstd::queue<int> y;\n\n\t//最初の座標をキューに追加\n\ty.push(starty);\n\tx.push(startx);\n\n\t\n\tfor (int i = 1; i <= tateindex; i++)\n\t{\n\t\tfor (int j = 1; j <= yokoindex; j++)\n\t\t{\n\t\t\tif (wh_map[i][j] == START)\n\t\t\t{\n\t\t\t\tprintf(\"■\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"□\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\n\n\t//キューがなくなるまで\n\twhile (!x.empty())\n\t{\n\t\t//ｙ座標とｘ座標を取り出す\n\t\tint yy = y.front();\n\t\tint xx = x.front();\n\t\t//デキュー\n\t\ty.pop();\n\t\tx.pop();\n\n\t\t//ゴールにたどり着いた\n\t\tif (yy == goaly && xx == goalx)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t//今いる座標の値を吹っ飛ばす\n\t\twh_map[yy][xx] = -1;\n\n\t\t//四方に散れるか調べる\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t//次に進む座標を取得\n\t\t\tint nexty = yy + h_tate[i];\n\t\t\tint nextx = xx + h_yoko[i];\n\n\t\t\t//まずは範囲内かどうか調べる\n\t\t\tif (nexty >= 1 && nexty <= tateindex && nextx >= 1 && nextx <= yokoindex)\n\t\t\t{\n\t\t\t\t//そこが通れる場所且つブロックの色が同じとき\n\t\t\t\tif (wh_map[nexty][nextx] == START)\n\t\t\t\t{\n\t\t\t\t\t//ｙとｘをそれぞれ追加\n\t\t\t\t\ty.push(nexty);\n\t\t\t\t\tx.push(nextx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\n//*****----- マップを初期化する関数 -----*****//\n\nvoid f_mapsyokika(void)\n{\n\tfor (int i = 1; i < MAP_MAX + 1; i++)\n\t{\n\t\tfor (int j = 1; j < MAP_MAX + 1; j++)\n\t\t{\n\t\t\twh_map[i][j] = -1;\n\t\t}\n\t}\n}\n\n\n\n//*****----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(構造体は配列) -----*****//\n\nvoid f_okmap(S_block s_data[] , int starty , int startx , int startcolor , int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s_data[i].iro == startcolor)\n\t\t{\n\t\t\t//縦か横かによって挙動が変わる\n\t\t\tif (s_data[i].muki == 0)\n\t\t\t{\n\t\t\t\t//2 * 4マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0;k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + j][s_data[i].x + k] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//横だった\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 4 * 2マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + k][s_data[i].x + j] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint fie[102][102];\nint check[102][102];\ntypedef struct state{\n  int x;\n  int y;\n  int cost;\n  state(int x,int y,int cost):x(x),y(y),cost(cost){}\n};\nint w,h;\nint xg,yg;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvoid makefie(int c,int d,int x,int y){\n  int xm=0,ym=0;\n  //cout << \"oo\";\n  //fflush(stdout);\n  if(d){ xm=2; ym=4;}\n  else{ xm=4; ym=2;}\n  for(int i=x; i < x+xm; i++){\n    for(int j=y; j < y+ym; j++)\n      fie[i][j]=c;\n  }\n  //  cout << \"ee\";\n  // fflush(stdout);\n}\nint solve(int x,int y,int c){\n  queue <state> q;\n  q.push( state(x,y,0) );\n  // cout << x << \" \" << y << \" \"<<endl;\n  while(!q.empty()){\n    state p = q.front(); q.pop();\n    int cost = p.cost;\n    for(int i=0;i<4;i++){\n      int nx=p.x+dx[i];\n      int ny=p.y+dy[i];\n      if(nx <= 0 || nx >w || ny <= 0 || ny>h) continue;\n      if(fie[nx][ny]!=c) continue;\n      if(nx==xg && ny==yg) return 1;\n      if(check[nx][ny]!=-1) continue;\n      check[nx][ny]=cost+1;\n      q.push( state(nx,ny,cost+1) );\n      //  cout << nx << \" \" << ny << \" \"<< cost+1<<endl;\n    }\n  }\n  return 0;\n}\nmain(){\n  int n;\n  int xs,ys;\n  while(1){\n    cin >> w >>h;\n    if(w==0 && h==0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    memset(fie,0,sizeof(fie));\n    memset(check,-1,sizeof(check));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      makefie(c,d,x,y);\n    }\n\n    if(fie[xs][ys]==0){ cout << \"NG\"<<endl; continue;}\n    int res=solve(xs,ys,fie[xs][ys]);\n    if(res) cout << \"OK\" <<endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint n,a,sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tint xx = x;\n\tint yy = y;\n\n\tif(xx == gx && yy == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\txx++;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\txx--;\n\tyy++;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\t\t\n\txx--;\n\tyy--;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\t\t\t\n\txx++;\n\tyy--;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n}\n\nint main(){\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tcin >> n >> a;\n\t\tif(!n && !a)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0){\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+4; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+2; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n\n  DFS(xs,ys,F[xs][ys]);\n  if(xs == 8){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h;\nint field[101][101];\nint gx,gy;\nint sc;\nbool search(int x,int y)\n{\n\tbool flag = false;\n\tif(x == gx && y == gy)\n\t\tflag = true;\n\telse{\n\t\tint vectorx[4] = {-1,0,1,0},vectory[4] = {0,-1,0,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x+vectorx[i] >= 0 && y+vectory[i] >= 0 && x+vectorx[i] < w && y+vectory[i] < h){\n\t\t\t\tif(field[x+vectorx[i]][y+vectory[i]] == sc){\n\t\t\t\t\tfield[x][y] = 0;\n\t\t\t\t\tflag |= search(x+vectorx[i],y+vectory[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tint n,c,x,y;\n\t\tbool d;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint vectorx,vectory;\n\t\t\tif(d == 0){\n\t\t\t\tvectorx = 4;vectory = 2;\n\t\t\t}else{\n\t\t\t\tvectorx = 2;vectory = 4;\n\t\t\t}\n\t\t\tfor(int j=0;j<vectorx;j++){\n\t\t\t\tfor(int k=0;k<vectory;k++){\n\t\t\t\t\tfield[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc = field[sx][sy];\n\t\tif(search(sx,sy))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nint xg, yg;\nint data[100][100];\nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\nbool visited[100][100];\nbool dfs(int, int, int);\n\nmain(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n\n    int xs, ys, n;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    xs--;\n    ys--;\n    xg--;\n    yg--;\n\n    cin >> n;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--;\n      y--;\n      if(d==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    data[i+y][j+x]=c;\n\t  }\n\t}\n      }else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<4;j++){\n\t    data[i+y][j+x]=c;\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tvisited[i][j]=false;\n      }\n    }\n\n    if(dfs(ys, xs, data[ys][xs])){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}\n\nbool dfs(int y, int x, int c){\n  if(y==yg && x==xg){\n    return true;\n  }\n  visited[y][x]=true;\n  bool ans=false;\n  for(int i=0;i<4;i++){\n    int ty=y+dy[i];\n    int tx=x+dx[i];\n    if(ty>=0 && ty<h){\n      if(tx>=0 && tx<w){\n\tif(data[ty][tx]==c && !visited[ty][tx]){\n\t  ans=dfs(ty, tx, c);\n\t  if(ans) break;\n\t}\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint board[100][100];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc|| board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\tint xs , ys;\n\tint n;\n\twhile(cin >> w >> h , w|h){\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint w,h;\nint sx,sy,gx,gy;\nint n;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nbool used[120][120];\nint f[120][120];\nvoid set(int c,int d,int x,int y)\n{\n\tif(d==0)\n\t{\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nbool judge()\n{\n\tif(f[sx][sy]!=f[gx][gy])return false;\n\tmemset(used,false,sizeof(used));\n\tqueue<P> q;\n\tq.push(mp(sx,sy));\n\tused[sx][sy]=true;\n\twhile(!q.empty())\n\t{\n\t\tP a=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nx=a.fi+dx[i],ny=a.sec+dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\tif(used[nx][ny]||f[nx][ny]!=f[a.fi][a.sec])continue;\n\t\t\tif(nx==gx&&ny==gy)return true;\n\t\t\tused[nx][ny]=true;\n\t\t\tq.push(mp(nx,ny));\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(w==0&&h==0)break;\n\t\tscanf(\"%d %d\",&sy,&sx);\n\t\tscanf(\"%d %d\",&gy,&gx);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&y,&x);\n\t\t\tset(c,d,x,y);\n\t\t}\n\t\tif(judge())puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nint w, h;\n\nint map[200][200];\n\nvoid search(int x, int y, int col){\n\tif(x < 0 || y < 0 || x >= w || y >= h){\n\t\treturn;\n\t}\n\tif(map[x][y] != col || map[x][y] == 0){\n\t\treturn;\n\t}\n\tmap[x][y] = 0;\n\tsearch(x - 1, y, col);\n\tsearch(x + 1, y, col);\n\tsearch(x, y - 1, col);\n\tsearch(x, y + 1, col);\n}\n\nint main(){\n\t\n\t\n\twhile(true){\n\t\t\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint xs, ys, xg, yg;\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\t\n\t\tint n;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tfor(int i = 0; i <= w; i++){\n\t\t\tfor(int j = 0; j <= h; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int loop = 0; loop < n; loop++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int dx = 0; dx < 4; dx++){\n\t\t\t\t\tfor(int dy = 0; dy < 2; dy++){\n\t\t\t\t\t\tmap[x + dx][y + dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int dx = 0; dx < 2; dx++){\n\t\t\t\t\tfor(int dy = 0; dy < 4; dy++){\n\t\t\t\t\t\tmap[x + dx][y + dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t}else{\n\t\t\tsearch(xs, ys, map[xs][ys]);\n\t\t\tif(map[xg][yg] == 0){\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tcout << map[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <string>\n\n#define Pa pair<int,int>\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstring bfs(int a[101][101], int sx, int sy, int gx, int gy, int w, int h)\n{\n\tint s, t, m = a[sy][sx];\n\tbool vis[101][101];\n\tstring str = \"NG\";\n\tqueue<Pa> que;\n\tPa pa;\n\tfill(&vis[0][0], &vis[h+1][w+1], true);\n\t\n\tque.push(Pa(sy, sx));\n\tvis[sy][sx] = false;\n\t\n\twhile(!que.empty()){\n\t\tpa = que.front();\n\t\tque.pop();\n\t\tif(pa.first == gy && pa.second == gx){\n\t\t\tstr = \"OK\";\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ts = pa.first + dy[i];\n\t\t\tt = pa.second + dx[i];\n\t\t\tif(1 <= s && s <= h && 1 <= t && t <= w){\n\t\t\t\tif(vis[s][t] && m == a[s][t]){\n\t\t\t\t\tque.push(Pa(s, t));\n\t\t\t\t\tvis[s][t] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str;\n}\n\nint main()\n{\n\tint a[101][101], w, h, sx, sy, gx, gy, s, t, u, v, n;\n\t\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[0][0], &a[h+1][w+1], -1);\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u >> v;\n\t\t\tif(t == 0){\n\t\t\t\tfor(int i = v; i <= v+1; i++){\n\t\t\t\t\tfor(int j = u; j <= u+3; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i = v; i <= v+3; i++){\n\t\t\t\t\tfor(int j = u; j <= u+1; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, sx, sy, gx, gy, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    \n    bfs();\n    \n    if(goal==1){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n    \n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\td[ny][nx]=0;\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\n\nint DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return 0;\n  }\n  if(Y == xg && X == yg){\n    return 1;\n  }\n\n  F[Y][X] = 0;\n  return(DFS(Y-1,X  ,c) || DFS(Y  ,X+1,c) || DFS(Y+1  ,X,c) || DFS(Y  ,X-1,c));\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n\n  if(DFS(xs,ys,F[xs][ys]) == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h){\n    int xs,ys,xg,yg;\n    bool Map[h+10][w+10]={};\n    bool flag=false;\n    cin>>xs>>ys>>xg>>yg;\n    xs--;ys--;xg--;yg--;\n    int n;cin>>n;\n    int Map2[h+10][w+10]={};\n    Map[ys][xs]=true;\n    queue<pair<int,int> >que;\n    que.push(mp(ys,xs));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      if(d==0){\n\tfor(int i=y;i<y+2;i++)\n\t  for(int j=x;j<x+4;j++)\n\t    Map2[i][j]=c;\n      }else if(d==1){\n\tfor(int i=y;i<y+4;i++)\n\t  for(int j=x;j<x+2;j++)\n\t    Map2[i][j]=c;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)\n\tcout<<Map2[i][j]<<\" \";\n      cout<<endl;\n    }\n    int vx[4]={0,-1,0,1};\n    int vy[4]={1,0,-1,0};\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      if(now.F==yg&&now.S==xg){\n\tflag=true;\n\tbreak;\n      }\n      for(int kk=0;kk<4;kk++){\n\tint as=now.F+vx[kk];int bs=now.S+vy[kk];\n\tif(as<h&&as>=0&&bs<w&&bs>=0&&Map2[now.F][now.S]==Map2[as][bs]&&!Map[as][bs]){\n\t  que.push(mp(as,bs));\n\t  Map[as][bs]=true;\n\t}\n      }\n    }\n    if(flag)\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n\n    int color = grid[ys][xs];\n\n    queue<P> q;\n    q.push(P(ys,xs));\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      y = p.first;\n      x = p.second;\n      if(yg == y && xg == x){\n\tcout << \"OK\\n\";\n\tq.push(P(y,x));\n\tbreak;\n      }\n      visit[y][x] = true;\n     \n      int dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n      for(int i=0;i<4;i++){\n\tint sx = x+dx[i],sy = y+dy[i];\n\t\n\tif(sx<0 || sy<0 || w<=sx || h<=sy)continue;\n\t\n\tif(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\tq.push(P(sy,sx));\n      }\n    }\n    if(q.empty())cout << \"NG\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,c,d,x,y,nok,sc;\nint fld[101][101];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||fx<0||fx>w-1||fy<0||fy>h-1)return;\n    if(fx==xg-1&&fy==yg-1){\n        if(sc==fld[fy][fx])nok=1;\n    }\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        nok=0;\n        fill(fld[0],fld[0]+101*101,0);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[ys-1][xs-1];\n        for(int j=0;j<h;j++){\n            for(int k=0;k<w;k++){\n                cout<<fld[j][k];\n            }\n            cout<<endl;\n        }\n        if(fld[0][0]!=0){\n            dfs(0,0);\n        }\n        if(nok==1)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\\n\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) { return false; }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h+1; i++) {\n                for (int j = 0; j <= w+1; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tint fld[100][100] = {};\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sy >> sx >> gy >> gx >> n;\n\t\tsy--; sx--; gy--; gx--;\n\t\twhile (n--)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> y >> x;\n\t\t\ty--; x--;\n\t\t\tif (d)\n\t\t\t{\n\t\t\t\tREP(i, 4)REP(j, 2) fld[x + i][y + j] = c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, 2)REP(j, 4) fld[x + i][y + j] = c;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(i, h)\n\t\t{\n\t\t\tREP(j, w) cout << fld[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tqueue<P> que;\n\t\tque.push(P(sx, sy));\n\t\tbool f = false;\n\t\tint color = fld[sx][sy];\n\t\twhile (que.size())\n\t\t{\n\t\t\tif (color == 0) break;\n\t\t\tint tx = que.front().first, ty = que.front().second;\n\t\t\tfld[tx][ty] = 0;\n\t\t\tque.pop();\n\t\t\tif (tx == gx&&ty == gy)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\t\tif (valid(nx, ny, h, w) && fld[nx][ny] == color) que.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\tfor(int y = 0; y < 102; y++){\n\t\tfor(int x = 0; x < 102; x++){\n\t\t\tF[y][x] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(F[ys][xs] != -1){\n\t\tif(DFS(xs, ys, xg, yg, F[ys][xs])){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//インクルード文\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <stdlib.h>\n#include <cstdio>\n#include <string>\n//#include <assert.h>\n\n//:std省略\nusing namespace std;\n\n//グローバル変数\nint f[1000][1000];\n\n//マクロ指定\n#define fc f[x + j][y + l] = c\n\n//深さ優先探索( dfs = Depth - First Search )\nvoid dfs(int a, int b, int c) {\n\n\tif (f[a][b] == c) {\n\n\n\t\tf[a][b] = 10;\n\t\tdfs(a + 1, b, c);\n\t\tdfs(a - 1, b, c);\n\t\tdfs(a, b + 1, c);\n\t\tdfs(a, b - 1, c);\n\n\n\t}\n\n//\telse return;\n\n}\n\n//メイン文\nint main(){\n\n\tint w, h, n = 0;\n\tint i, j, l;\n\tint xs, ys; \n\tint xg, yg;\n\n\tconst int cnt = w + h;\n\n\tfor(;;) {\n\t\tcin >> w >> h;\n\n\t\t\n\t\tif ( cnt == 0) break;\n\t\t\n\t\tfor (i = 1; i <= h; ++i) {\n\t\t\tfor (j = 1; j <= w; ++j) {\n\t\t\t\tf[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\n\t\t\tcin >> c >> d;\n\t\t\tcin >> x >> y;\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l = 0; l < 2; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {//d==1\n\n\t\t\t\t\n\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l= 0; l < 4; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l = 0; l < 4; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l= 0; l < 2; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n*/\n\n\n\t\tdfs(xs, ys, f[xs][ys]);\n\n\n//\t\tchar gg = 'OK';\n//\t\tchar ggwp = 'NG';\n\n\n\t\t\n\n\t\tif (f[xg][yg] == 10) printf(\"OK\\n\");\n\n\t\telse \t\t         printf(\"NG\\n\");\n\n\n\n\t\t\t//\t\t\tassert(i == 10);\n\t\t\t//\t\t\tassert(i = 9);\n\t\t\t//\t\t\tassert(i = 8);\n\t\t\t//\t\t\tassert(i = 7);\n\t\t\t//\t\t\tassert(i = 6);\n\t\t\t//\t\t\tassert(i = 5);\n\t\t\t//\t\t\tassert(i = 4);\n\t\t\t//\t\t\tassert(i = 3);\n\t\t\t//\t\t\tassert(i = 2);\n\t\t\t//\t\t\tassert(i = 1);\n\n\t\t\n\n\n\t}\n\treturn 0;\n}\n\n/*\n\n\n20 20\n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\ntypedef std::pair<int, int> P;\n\nint w, h;\nint field[100][100];\nint xs, ys, xg, yg;\nint n;\nconst int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n\nint main()\n{\n\twhile( std::cin >> w >> h, w | h )\n\t{\n\t\tmemset( field, 0, sizeof( field ) );\n\n\t\tstd::cin >> xs >> ys >> xg >> yg >> n;\n\t\tfor( int i = 0; i != n; ++i )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\tfor( int j = 0; j != 8; ++j )\n\t\t\t{\n\t\t\t\tint nx = x + ( d ? j % 2 : j / 2 ),\n\t\t\t\t\tny = y + ( d ? j / 2 : j % 2 );\n\n\t\t\t\tfield[ny-1][nx-1] = c;\n\t\t\t}\n\t\t}\n\n\t\tstd::queue<P> que;\n\t\tint col = field[ys-1][xs-1];\n\t\tbool ans = false;\n\t\tque.push( P( xs, ys ) );\n\n\t\twhile( !que.empty() )\n\t\t{\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif( p.first == xg && p.second == yg )\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfield[p.second-1][p.first-1] = 0;\n\n\t\t\tfor( int i = 0; i != 4; ++i )\n\t\t\t{\n\t\t\t\tint nx = p.first + dx[i],\n\t\t\t\t\tny = p.second + dy[i];\n\t\t\t\t\n\t\t\t\tif( nx > 0 && nx <= w && ny > 0 && ny <= h && field[ny-1][nx-1] && field[ny-1][nx-1] == col )\n\t\t\t\t\tque.push( P( nx, ny ) );\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << ( ans ? \"OK\" : \"NG\" ) << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xx[4] = {0, 1, 0, -1};\nint yy[4] = {1, 0, -1, 0};\nint block[100][100];\nbool put[100][100];\nint already[100][100];\nint w, h;\nint xs, ys;\nint xg, yg;\nbool dfs(int nex, int ney);\n\nint main(){\n  int n;\n  \n  while(1){\n    memset(block, 0, sizeof(block));\n    memset(already, 0, sizeof(already));\n    memset(put, 0, sizeof(put));\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      int wide, high;\n      cin >> c >> d >> x >> y;\n      if(d){\n\twide = 2; high = 4;\n      }\n      else{\n\twide = 4; high = 2;\n      }\n      for(int j = 0; j < high; j++){\n\tfor(int k = 0; k < wide; k++){\n\t  block[y+j][x+k] = c;\n\t  put[y+j][x+k] = true;\n\t}\n      }\n    }\n    bool ans = false;\n    if(block[ys][xs] == block[yg][xg]){\n      ans = dfs(xs, ys);\n      if(ans) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int nex, int ney){\n  already[nex][ney] = 1;\n  if(nex == xg && ney == yg) return true;\n  for(int i = 0; i < 4; i++){\n    int nx = nex + xx[i];\n    int ny = ney + yy[i];\n    if(0 <= nx && 0 <= ny && ny < h && nx < w && put[ny][nx] && !already[ny][nx] && block[ys][xs] == block[ny][nx]) return dfs(nx, ny);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    bfs();\n    \n    \n    if(goal==1){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        // sx--, sy--, gx--, gy--;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(H+1, vector<int>(W+1));\n        vector<vector<int> > used(H+1, vector<int>(W+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            // x--, y--;\n            if (dir) {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx <= H && 0 <= ny && ny <= W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int board[][102] ,int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( board , tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\tint board[102][102];\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(board ,xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list< std::pair<int,int> > adjacive;\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2&&y1+h1>=y2)||(x2==x1+w1&&y1<=y2+h2&&y1+h1>=y2)||(y1==y2+h2&&x1<=x2+w2&&x1+w1>=x2)||(y2==y1+h1&&x1<=x2+w2&&x2<=x1+w1))\n\t\t\t\t{\n\t\t\t\t\tadjacive.push_back(std::pair<int ,int>(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\tque.push(start);\n\t\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list< std::pair<int,int> >::iterator it=adjacive.begin();it!=adjacive.end();it++)\n\t\t{\n\t\t\tif(it->first==survey)\n\t\t\t{\n\t\t\t\tque.push(it->second);\n\t\t\t}\n\t\t}\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint board[110][110];\nbool used[110][110];\n\nint dx1[8] = {0,1,2,3,0,1,2,3};\nint dy1[8] = {0,0,0,0,1,1,1,1};\n\nint dx2[8] = {0,0,0,0,1,1,1,1};\nint dy2[8] = {0,1,2,3,0,1,2,3};\n\nbool dfs(int x, int y, int xg, int yg, int color) {\n    if (board[y][x] != color || used[y][x] || x <= 0 || y <= 0 || w < x || h < y) {\n        return false;\n    }\n    if (x == xg && y == yg) {\n        return true;\n    }\n    used[y][x] = true;\n    bool ret = false;\n    ret |= dfs(x+1, y, xg, yg, color);\n    ret |= dfs(x-1, y, xg, yg, color);\n    ret |= dfs(x, y+1, xg, yg, color);\n    ret |= dfs(x, y-1, xg, yg, color);\n    return ret;\n}\n\nint main() {\n    while (cin >> w >> h, (w || h)) {\n        memset(board, 0, sizeof board);\n        cin >> xs >> ys >> xg >> yg >> n;\n        int c, d, x, y;\n        for (int i=0; i<n; ++i) {\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                for (int i=0; i<8; ++i) {\n                    board[y + dy1[i]][x + dx1[i]] = c;\n                }\n            } else {\n                for (int i=0; i<8; ++i) {\n                    board[y + dy2[i]][x + dx2[i]] = c;\n                }\n            }\n        }\n        memset(used, false, sizeof used);\n        if (board[ys][xs] && dfs(xs, ys, xg, yg, c)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c || c != 0)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\t/*for (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "int board[101][101];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mp[101][101];\nint w, h;\nint gx, gy;\n\nint dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\n\nbool dfs(int y, int x, int c)\n{\n\tif (y < 1 || y > h || x < 1 || x > w || mp[y][x] != c) return false;\n\n\tif (y == gy && x == gx) return true;\n\n\tmp[y][x] = 0;\n\n\tbool res = false;\n\n\tfor (int i = 0; i < 4; ++i) res = res || dfs(y + dy[i], x + dx[i], c);\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w || h) {\n\t\tint sx, sy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tint n; cin >> n;\n\t\twhile (n--) {\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y;\n\t\t\tif (d) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) for (int j = 0; j < 2; ++j) mp[y+i][x+j] = c;\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < 2; ++i) for (int j = 0; j < 4; ++j) mp[y+i][x+j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcout << (dfs(sy, sx, mp[sy][sx]) ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[y+1][x+1]=c;\n             F[y+1][x+2]=c;\n             F[y+1][x+3]=c;\n             F[y+1][x+4]=c;  \n             F[y+2][x+1]=c;\n             F[y+2][x+2]=c;\n             F[y+2][x+3]=c;\n             F[y+2][x+4]=c;   \n         }\n         else{\n             F[y+1][x+1]=c;\n             F[y+2][x+1]=c;\n             F[y+3][x+1]=c;\n             F[y+4][x+1]=c;  \n             F[y+1][x+2]=c;\n             F[y+2][x+2]=c;\n             F[y+3][x+2]=c;\n             F[y+4][x+2]=c;   \n         }\n      }\n      if(F[ys+1][xs+1]!=1&&F[ys+1][xs+1]!=2&&F[ys+1][xs+1]!=3&&F[ys+1][xs+1]!=4&&F[ys+1][xs+1]!=5)\n         cout << \"NG\" << endl;\n      else\n         DFS(ys+1,xs+1,F[ys][xs]);\n      if(F[yg+1][xg+1]==F[ys+1][xs+1])\n         cout << \"OK\" << endl;\n      else\n         cout << \"NG\" << endl;\n      for(int i=1;i<=w;i++)\n         for(int j=1;j<=h;j++)\n            F[i][j]=0;\n      \n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, w, h, xs, ys, xg, yg, f[105][105] = { 0 }, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, used[105][105] = { 0 }, color = 0;\nbool flag;\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (xg == nx&&yg == ny) {\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif (used[ny][nx]) continue;\n\t\tif (1 <= nx&&nx <= w && 1 <= ny&&ny <= h&&f[ny][nx] == color) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 105; i++) {\n\t\t\tfor (int j = 0; j < 105; j++) {\n\t\t\t\tf[i][j] = 0;\n\t\t\t\tused[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused[ys][xs] = 1;\n\t\tcolor = f[ys][xs];\n\t\tdfs(ys, xs);\n\t\tif (color == 0) {//?????????????????????????????????\n\t\t\tcout << \"NG\" << endl; continue;\n\t\t}\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\n \nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = -1;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n \n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n \n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n \n    int n;\n    cin >> n;\n \n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n \n    meiro(xs,ys,C[xs][ys]);\n \n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint map[101][101];\nint xg, yg;\nint w, h;\nint col;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nbool flag;\n\nvoid dfs(int x, int y)\n{\n  map[y][x] = 0;\n  \n  if (x == xg && y == yg) {\n    flag = true;\n    return ;\n  }\n  \n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    \n    if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n      continue;\n    else if (map[ny][nx] == col)\n      dfs(nx, ny);\n    }\n}\n\nvoid setblock(int c, int d, int bx, int by)\n{\n  int wlim = 4, hlim = 2;\n  \n  if (d == 1) {\n    wlim = 2;\n    hlim = 4;\n  }\n  \n  for (int y = 0; y < hlim; y++)\n    for (int x = 0; x < wlim; x++)\n      map[by + y][bx + x] = c;\n}\n\n \nint main()\n{\n  while (cin >> w >> h, w || h) {\n    int xs, ys;\n    int n;\n    \n    for (int y = 0; y < h; y++)\n      for (int x = 0; x < w; x++)\n                map[y][x] = 0;\n    \n    cin >> xs >> ys >> xg >> yg >> n;\n    \n    xs--, ys--, xg--, yg--;\n    for (int i = 0; i < n; i++) {\n      int c, d, x, y;\n             \n      cin >> c >> d >> x >> y;\n      x--, y--;            \n      setblock(c, d, x, y);\n    }\n    col = map[ys][xs];\n    flag = false;\n    if (col)\n      dfs(xs, ys);\n \n    if (flag)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n  \n    for(int y=0; y<=h; y++){\n      for(int x=0; x<=w; x++){\n          F[y][x] = 0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=0;\n\t\tgoal=0;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2&&y1+h1>=y2)||(x2==x1+w1&&y1<=y2+h2&&y1+h1>=y2)||(y1==y2+h2&&x1<=x2+w2&&x1+w1>=x2)||(y2==y1+h1&&x1<=x2+w2&&x2<=x1+w1))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tbool visited[1280]={false};\n\tint survey;\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\tif(visited[*it]==false)\n\t\t\t{\n\t\t\t\tque.push(*it);\n\t\t\t\tvisited[*it]=true;\n\t\t\t}\n\t\t}\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n;\nstring res = \"NG\";\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i)).at(y+j) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  int temp = board[nx][ny];\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && temp==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && temp==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && temp==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && temp==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Block *object[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      object[i] = new Block();\n      cin >> object[i]->color;\n      cin >> object[i]->direction;\n      cin >> object[i]->x;\n      cin >> object[i]->y;\n      --object[i]->x; --object[i]->y;\n      object[i]->write(board);\t    \n    }\n    func(board,xs,ys);\n    cout << res << endl;\n    delete[] *object;\n    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//23\n#include<iostream>\n\nusing namespace std;\n\nint w,h;\n\nvoid ff(int (*g)[101],int c,int y,int x){\n  if(1<=y&&y<=h&&1<=x&&x<=w&&g[y][x]==c){\n    g[y][x]=-1;\n    int d[]={0,1,0,-1,0};\n    for(int i=0;i<4;i++){\n      ff(g,c,y+d[i],x+d[i+1]);\n    }\n  }\n}\n\nint main(){\n  for(;cin>>w>>h,w|h;){\n    int g[101][101]={{}};\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    while(n--){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      for(int i=0;i<2+2*d;i++){\n\tfor(int j=0;j<4-2*d;j++){\n\t  g[i+y][j+x]=c;\n\t}\n      }\n    }\n    ff(g,g[sy][sx],sy,sx);\n    cout<<((g[gy][gx]==-1)?\"OK\":\"NG\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\n\nvoid DFS(int Y,int X,char C){\n\tif(F[Y][X]!=C)\n\t\treturn;\n\n\tF[Y][X]='.';\n\t\n\tDFS(Y-1,X,C);\n\tDFS(Y,X+1,C);\t\n\tDFS(Y+1,X,C);\n\tDFS(Y,X-1,C);\n\n}\n\n\nint main(){\nwhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0&&h==0)\n\t\tbreak;\n\t\n\tint xs,ys,xg,yg;\n\tcin>>xs>>ys>>xg>>yg;\n\tint n;\n\tcin>>\n#include<iostream>\nusing namespace std;\n\nchar F[102][102];\n\nvoid DFS(int Y,int X,char C){\n\tif(F[Y][X]!=C)\n\t\treturn;\n\n\tF[Y][X]='.';\n\t\n\tDFS(Y-1,X,C);\n\tDFS(Y,X+1,C);\t\n\tDFS(Y+1,X,C);\n\tDFS(Y,X-1,C);\n\n}\n\n\nint main(){\nwhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0&&h==0)\n\t\tbreak;\n\t\n\tint xs,ys,xg,yg;\n\tcin>>xs>>ys>>xg>>yg;\n\tint n;\n\tcin>>n;\n\tchar C;\n\tfor(int i=0;i<n;i++){\n\t\tint d,x,y;\n\t\tchar c;\n\t\tcin>>c;\n\t\tcin>>d>>x>>y;\n\t\tif(d==0){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tF[y+j][x+l]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tF[y+j][x+l]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC=F[ys][xs];\n\tif(C!=0){\n\t\tDFS(ys,xs,C);\n\t\tif(F[yg][xg]=='.'&&F[ys][xs]=='.'){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t}else{\n\t\tcout<<\"NG\"<<endl;\n\t}\n\t\n\t\n}\nreturn 0;\n}n;\n\tchar C;\n\tfor(int i=0;i<n;i++){\n\t\tint d,x,y;\n\t\tchar c;\n\t\tcin>>c;\n\t\tcin>>d>>x>>y;\n\t\tif(d==0){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\tF[y+j][x+l]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tF[y+j][x+l]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tC=F[ys][xs];\n\tif(C!=0){\n\t\tDFS(ys,xs,C);\n\t\tif(F[yg][xg]=='.'&&F[ys][xs]=='.'){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t}else{\n\t\tcout<<\"NG\"<<endl;\n\t}\n\t\n\t\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<queue>\nusing namespace std;\nint field[128][128];\nint dx[] = {-1,0,0,1},dy[] = {0,-1,1,0};\nint w,h;\nvoid func(int x,int y,int c){\n\tif(x < 0 || y < 0 || x >= w || y >= h)return ;\n\tif(field[y][x] == -1 || field[y][x] == 0)return ;\n\tif(field[y][x] != c)return ;\n\tfield[y][x] = -1;\n\tfor(int i = 0; i < 4; i++){\n\t\tfunc(x+dx[i],y+dy[i],c);\n\t}\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w,h){\n\t\tint xs,ys,xg,yg,n;\n\t\tmemset(field,0,sizeof(field));\n\t\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = x; j < x + 4; j++){\n\t\t\t\t\tfield[y][j] = c;\n\t\t\t\t\tfield[y+1][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < y + 4; j++){\n\t\t\t\t\tfield[j][x] = c;\n\t\t\t\t\tfield[j][x+1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunc(xs,ys,field[ys][xs]);\n\t\tcout << (field[yg][xg]==-1?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<functional>\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint c,d,x,y;\nint map[101][101];\nint flg=0,temp;\nvoid func(int ,int);\nusing namespace std;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0){\n\t\t\tbreak;\n\t\t}\n\t\tint i,j,k;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==1){\n\t\t\t\tfor(k=0;k<=1;k++){\n\t\t\t\t\tfor(j=0;j<=3;j++){\n\t\t\t\t\t\tmap[x+k][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d==0){\n\t\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\t\tfor(j=0;j<=1;j++){\n\t\t\t\t\t\tmap[x+k][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tflg=0;\n\t\tif(map[xs][ys]==map[xg][yg] && map[xs][ys]!=0){\n\t\t\ttemp=map[xs][ys];\n\t\t\tmap[xs][ys]=0;\n\t\t\tfunc(xs,ys);\n\t\t}\n\t\tif(flg==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\t/*for(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t}\n\treturn 0;\n}\nvoid func(int xx,int yy){\n\tint dy[4]={0,1,0,-1},dx[4]={1,0,-1,0};\n\tint i;\n\tif(flg==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tyy=yy+dy[i];\n\t\t\txx=xx+dx[i];\n\t\t\tif(yy<=h && yy>=1 && xx<=w && xx>=1 && map[xx][yy]==temp){\n\t\t\t\tmap[xx][yy]=0;\n\t\t\t\tif(xg==xx && yg==yy){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfunc(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<list>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { \nassert(b!=0);\nreturn a * inv(b);\n }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,-1,0,1 };\nstruct Node {\n\tNode(int a, int b, int c) {\n\t\tatime = a;\n\t\tx = b;\n\t\ty = c;\n\t}\n\tint atime;\n\tint x;\n\tint y;\n};\nclass Compare {\npublic:\n\tbool operator()(const Node& l, const Node& r) {\n\t\treturn l.atime < r.atime;\n\t}\n};\n\n\nint main() {\n\twhile(1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w)return 0;\n\t\tvector<vector<int>> maze(h+2, vector<int>(w+2,0));\n\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d) {\n\t\t\t\tfor (int ax = 0; ax < 4; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\tmaze[y+ay][x+ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 4; ++ay) {\n\t\t\t\t\t\tmaze[y + ay][x + ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < maze.size(); ++i) {\n\t\t\tfor (int j = 0; j < maze[0].size(); ++j) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint color = maze[ys][xs];\n\t\tif (!color||color!=maze[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<bool>>times(h+2 , vector<bool>(w+2, false));\n\n\t\tpriority_queue<Node,vector<Node>,Compare> qu;\n\t\t qu.emplace(0,xs,ys);\n\t\t bool flag=false;\n\t\twhile (!qu.empty()) {\n\t\t\tNode an(qu.top());\n\t\t\tqu.pop();\n\t\t\tif (an.x == xg&&an.y == yg) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tif (maze[an.y + dy[i]][an.x + dx[i]] == color) {\n\t\t\t\t\t\tif (times[an.y + dy[i]][an.x + dx[i]]) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tqu.push(Node{ an.atime + 1,an.x + dx[i], an.y + dy[i] });\n\t\t\t\t\t\t\ttimes[an.y + dy[i]][an.x + dx[i]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"OK\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\nbool MazeJudge;\nint xg,yg;\n\nchar ItoC(int i){\n\tif(i==1){\n\t\treturn '1';\n\t}else if(i==2){\n\t\treturn '2';\n\t}else if(i==3){\n\t\treturn '3';\n\t}else if(i==4){\n\t\treturn '4';\n\t}else if(i==5){\n\t\treturn '5';\n\t}\n}\n\nvoid DFS(int X,int Y,char C)\n{\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\tF[X][Y] = '.';\n\n\tif(X==xg&&Y==yg){\n\t\tMazeJudge = true;\n\t\treturn;\n\t}\n\t\n\tDFS(X-1,Y  ,C);\n\tDFS(X  ,Y+1,C);\n\tDFS(X+1,Y  ,C);\n\tDFS(X  ,Y-1,C);\n}\n\t\n\nint main()\n{\n\twhile(true){\n\n\t\t//デバッグ用迷路表示\n\t\t/*for(int j=0;j<102;j++){\n\t\t\tfor(int i=0;i<102;i++){\n\t\t\t\tF[i][j] = '0';\n\t\t\t}\n\t\t}*/\n\n\t\tMazeJudge = false;\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tint xs,ys;\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n    \t\t\tchar color = ItoC(c);\n\t\t\tif(d==0){\n\t\t\t\tF[x  ][y  ] = color;\n\t\t\t\tF[x+1][y  ] = color;\n\t\t\t\tF[x+2][y  ] = color;\n\t\t\t\tF[x+3][y  ] = color;\n\t\t\t\tF[x  ][y+1] = color;\n\t\t\t\tF[x+1][y+1] = color;\n\t\t\t\tF[x+2][y+1] = color;\n\t\t\t\tF[x+3][y+1] = color;\n\t\t\t}else if(d==1){\n\t\t\t\tF[x  ][y  ] = color;\n\t\t\t\tF[x+1][y  ] = color;\n\t\t\t\tF[x  ][y+1] = color;\n\t\t\t\tF[x+1][y+1] = color;\n\t\t\t\tF[x  ][y+2] = color;\n\t\t\t\tF[x+1][y+2] = color;\n\t\t\t\tF[x  ][y+3] = color;\n\t\t\t\tF[x+1][y+3] = color;\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//デバッグ用迷路表示\n\t\t/*for(int j=0;j<102;j++){\n\t\t\tfor(int i=0;i<102;i++){\n\t\t\t\tcout << F[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tchar rc = F[xs][ys];\n\t\tDFS(xs,ys,rc);\n\t\tif(MazeJudge==true){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else if(MazeJudge==false){\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n\n    canGo[x][y] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_x][next_y]) {\n            bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> h >> w;\n    std::vector<std::string> ans;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w + 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        if (start != goal) {\n            ans.push_back(\"NG\");\n            \n            break;\n        }\n        for (int i = 0; i <= h; i++) {\n            for (int j = 0; j <= w; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nconst float PI = 3.1415926;\nstatic const int INFTY = (1<<30);\n\nusing namespace std;\n\nint B[102][102];\nint M[102][102];\nint w, h, xs, ys, xg, yg, n, res;\n \nvoid bfs(int x, int y, int c) {\n  if(x <= 0 || y <= 0 || x > w+1 || y > h+1)\n    return;\n  if(B[x][y] != c)\n    return;\n  if(M[x][y] == 1) {\n    return;\n  } else {\n    M[x][y] = 1;\n  }\n  if(x == xg && y == yg) {\n    res = 1;\n    return; \n  }\n  bfs(x+1, y, c);\n  bfs(x, y+1, c);\n  bfs(x-1, y, c);\n  bfs(x, y-1, c);\n}\n\nint main() {\n  while(cin >> w >> h, w) {\n    // ?????????\n    rep(i, w+1) {\n      rep(j, h+1) {\n        B[i][j] = 0;\n        M[i][j] = 0;\n      }\n    }\n    res = 0;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    // ??????????????????\n    rep(i, n) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      \n      B[x][y] = c;\n      B[x+1][y] = c;\n      B[x][y+1] = c;\n      B[x+1][y+1] = c;\n      if ( d == 0 ) {\n        B[x+2][y] = c;\n        B[x+3][y] = c;\n        B[x+2][y+1] = c;\n        B[x+3][y+1] = c;\n      } else {\n        B[x][y+2] = c;\n        B[x][y+3] = c;\n        B[x+1][y+2] = c;\n        B[x+1][y+3] = c;\n      }        \n    }\n    if(B[xs][ys] != 0)\n      bfs(xs, ys, B[xs][ys]);\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\t\nbool check(short maze[MAX][MAX])\n{\n\tque.push(S);\n\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t\trep(i,MAX){\n\t\t\trep(j,MAX)\n\t\t\t\tmaze[i][j] = -10;\n\t\t}\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] == -10 && maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvector<vi> v(h, vi(w));\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tsx--; sy--; gx--; gy--;\n\t\tint n; cin >> n;\n\t\twhile (n--)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif (d==0)\n\t\t\t{\n\t\t\t\tREP(i, 4)REP(j, 2)\n\t\t\t\t{\n\t\t\t\t\tv[y+j][x+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, 2)REP(j, 4)\n\t\t\t\t{\n\t\t\t\t\tv[y+j][x+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint co = v[sx][sy];\n\t\tif (co == 0)\n\t\t{\n\t\t\tputs(\"NG\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<P> que;\n\t\tque.push(P(sx, sy));\n\t\tbool f = false;\n\t\twhile (que.size())\n\t\t{\n\t\t\tP tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint tx = tmp.first, ty = tmp.second;\n\t\t\tif (tx == gx&&ty == gy)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tx][ty] = 0;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\t\tif (valid(nx, ny, w, h) && v[nx][ny] == co) que.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint moveTo[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\nint stage[100][100];\n\nvoid paint(int c,int d,int x,int y){\n\t//c:1~5 d: 0:horizonal 1:vertical\n\tif(d==0){\n\t\tfor(int i=x;i<x+4;i++){\n\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg){\n\tint cs = stage[ys][xs];\n\tint cg = stage[yg][xg];\n\tif(cs != cg) return false;\n\n\tqueue<P> que;\n\tque.push(P(xs,ys));\n\n\twhile(!que.empty()){\n\t\tint sx = que.front().first;\n\t\tint sy = que.front().second;\n\t\t\n\t\tif(sx == xg && sy == yg) return true;\n\t\tque.pop();\n\n\t\tstage[sy][sx] = -1;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = sx + moveTo[i][0];\n\t\t\tint dy = sy + moveTo[i][1];\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(stage[dy][dx] != cs || stage[dy][dx] == -1) continue;\n\t\t\tque.push(P(dx,dy));\n\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\n\t\tint xg,yg;\n\t\tscanf(\"%d %d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\t//c:1~5 d: 0:horizonal 1:vertical\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tpaint(c,d,x,y);\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(w,h,xs,ys,xg,yg) ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint a,b,c,d;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y]||color==0)return 0;\n\tM[x][y]=9;\n\tif(x==c&&y==d)return 1;\n\tif(walk(x+1,y,color)||\n\t\t\twalk(x-1,y,color)||\n\t\t\twalk(x,y+1,color)||\n\t\t\twalk(x,y-1,color))return 1;\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>a>>b>>c>>d;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalk(a,b,M[a][b]);\n\t\tif(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[200][200]={},sx,sy,gx,gy;\nint f(int i,int j){\n\tif(i==gy && j==gx)\n\t\treturn 1;\n\tif(a[i+1][j]==a[sy][sx])\n\t\tif(f(i+1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j+1]==a[sy][sx])\n\t\tif(f(i,j+1)==1)\n\t\t\treturn 1;\n\tif(a[i-1][j]==a[sx][sy])\n\t\tif(f(i-1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j-1]==a[sx][sy])\n\t\tif(f(i,j-1)==1)\n\t\t\treturn 1;\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint w,h,n,c,d,x,y;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)\n\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\ta[i][j]=0;\n\t\tcin>>sx>>sy;\n\t\tcin>>gx>>gy;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t}\n\t\tif(a[sx][sy]!=a[gx][gy])\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sy,sx)==0)\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sx,sy)==1)\n\t\tcout<<\"OK\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    //memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0 && mas[ys][xs]==mas[yg][xg]){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n\tgoal=0;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      cout << endl;\n\n      if(x[i]==1 &&y[i]==1){\n        cbase = c[i];\n      }\n    }\n\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 0 || F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    /*for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}*/\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = (int)1e9;\n\nint board[128][128];\n\nint main()\n{\n    int w, h;\n\n    while (scanf(\"%d %d\", &w, &h), w){\n        int xs, ys;\n        int xg, yg;\n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n\n        int n;\n        scanf(\"%d\", &n);\n        memset(board, 0, 128 * 128);\n        while (n-- > 0){\n            int c, d, x, y;\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\n            board[y][x] = board[y][x + 1] = c;\n            board[y + 1][x] = board[y + 1][x + 1] = c;\n            if (d == 0){\n                board[y][x + 2] = board[y][x + 3] = c;\n                board[y + 1][x + 2] = board[y + 1][x + 3] = c;\n            }\n            else {\n                board[y + 2][x] = board[y + 3][x] = c;\n                board[y + 2][x + 1] = board[y + 3][x + 1] = c;\n            }\n        }\n\n        queue<P> que;\n        bool flag = false;\n        int color = board[ys][xs];\n\n        if (color == 0){\n            puts(\"NA\");\n            continue;\n        }\n        for (que.push(P(xs, ys)); que.size(); que.pop()){\n            P p = que.front();\n            int x = p.first;\n            int y = p.second;\n\n            if (board[y][x] != color) continue;\n\n            if (x == xg && y == yg){\n                flag = true;\n                break;\n            }\n            board[y][x] = 0;\n            que.push(P(x + 1, y));\n            que.push(P(x - 1, y));\n            que.push(P(x, y + 1));\n            que.push(P(x, y - 1));\n        }\n\n        puts(flag ? \"OK\" : \"NG\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool b;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint board[105][105];\n\nvoid dfs(int x , int y , int w , int h , int xg , int yg , int c){\n\tif(x==xg&&y==yg) {\n\t\tb=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=c || board[tx][ty]==0 || b ) continue;\n\t\tdfs( tx,ty,w,h,xg,yg,c);\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\t/*\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse */ dfs( xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint N;\nint W,H;\npair<int,int>s;\npair<int,int>g;\nint sc;\nint map[103][103]={0};\nbool flag[103][103]={0};\nint ans=0;\n\nbool se(int x,int y){\n\tif(x==g.first && y==g.second)ans=1;\n\tfor(int i=0;i<4;i++){\n\t\tint xx=x+dx[i];\n\t\tint yy=dy[i]+y;\n\t\tif(xx>=0 &&yy>=0 &&xx<W &&yy<H && sc==map[xx][yy]&& flag==0){\n\t\t\tflag[xx][yy]=1;\n\t\t\tse(xx,yy);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\t\n\twhile(cin>>W>>H>>s.first>>s.second>>g.first>>g.second>>N && W && H){\n\t\tint d,c,x,y;\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tsc=map[s.first][s.second];\n\t\tflag[s.first][s.second]=1;\n\t\tif(se(s.first,s.second))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n//#include<windows.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k,l,m;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\t\n/*\t\t\t\tfor(l=0;l<h;l++)\n\t\t\t\t{\n\t\t\t\t\tfor(m=0;m<w;m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d \",map[l][m]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%dツ行\\n\",l);\n\t\t\t\t}\n\t\t\t\tgetchar();\n\t\t\t\tsystem(\"cls\");\n*/\n\t\t\t\t\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"migi\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"hidari\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i-1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a=0;\nint F[102][102];\nvoid DFS(int Xs,int Ys,int c,int Xg,int Yg){\n  if(F[Xs][Ys]!=c){\n    return;\n  }else if(Xs==Xg&&Ys==Yg){\n    a=1;\n    return;\n  }\n F[Xs][Ys]=0;\n DFS(Xs-1,Ys,c,Xg,Yg);\n DFS(Xs,Ys-1,c,Xg,Yg);\n DFS(Xs+1,Ys,c,Xg,Yg);\n DFS(Xs,Ys+1,c,Xg,Yg);\n}\n\nint main(){\n  while(1){\n    a=0;\n   int w,h,xs,ys,xg,yg,n,C;\n   cin>>w>>h;\n   if(w==0&&h==0){\n     break;\n   }\n   cin>>xs>>ys>>xg>>yg>>n;\n   int c[n],d[n],x[n],y[n];\n   for(int i=0;i<n;i++){\n     cin>>c[i]>>d[i]>>x[i]>>y[i];\n     if(xs==x[i]&&ys==y[i]){\n       C=c[i];\n     }\n      for(int j=0;j<4;j++){\n        for(int k=0;k<2;k++){\n          if(d[i]==0){\n           F[x[i]+j][y[i]+k]=c[i];\n         }else{\n           F[x[i]+k][y[i]+j]=c[i];\n         }\n       }\n     }\n    }\n    DFS(xs,ys,C,xg,yg);\n    if(a==1){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool dfs(int xs,int ys,int xg,int yg,vector<vector<bool> >& canGo){\ncanGo[xs][ys]=false;\nif(xs==xg&&ys==yg)return true;\nif(canGo[xs+1][ys]){if(dfs(xs+1,ys,xg,yg,canGo))return true;}\nif(canGo[xs-1][ys]){if(dfs(xs-1,ys,xg,yg,canGo))return true;}\nif(canGo[xs][ys+1]){if(dfs(xs,ys+1,xg,yg,canGo))return true;}\nif(canGo[xs][ys-1]){if(dfs(xs,ys-1,xg,yg,canGo))return true;}\nreturn false;\n}\nint main(void){\nint w,h,xs,ys,xg,yg,n;\nbool ans,endflag;\nvector<vector<bool> > blockmap;\nwhile(true){\ncin>>w>>h;\nif(w==0&&h==0)break;\ncin>>xs>>ys>>xg>>yg>>n;\nblockmap=vector<vector<bool> >(w+2,vector<bool>(h+2,true));\nfor(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin>>c>>d>>x>>y;\n    if(c!=2){\n        blockmap[x+1][y+1]=false;\n        blockmap[x+2][y+1]=false;\n        blockmap[x+1][y+2]=false;\n        blockmap[x+2][y+2]=false;\n        if(d==0){\n            blockmap[x+3][y+1]=false;\n            blockmap[x+3][y+2]=false;\n            blockmap[x+4][y+1]=false;\n            blockmap[x+4][y+2]=false;\n        }\n        else {\n            blockmap[x+1][y+2]=false;\n            blockmap[x+2][y+3]=false;\n            blockmap[x+1][y+4]=false;\n            blockmap[x+2][y+4]=false;\n        }\n    }\n}\nans=dfs(xs+1,ys+1,xg+1,yg+1,blockmap);\nif(ans)cout<<\"OK\"<<endl;\nelse cout<<\"NG\"<<endl;\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n// #define int long long\n#define pb push_back\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\n \ntemplate <class X> void print(X Target){ cout << Target << '\\n'; }\n\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint w, h;\nint xs, ys, xg, yg;\nint mp[128][128];\nbool field[128][128];\n\nvoid dfs(int y, int x, int color)\n{\n  if (x < 1 || x > w || y < 1 || y > h) return;\n  if (field[y][x]) return;\n  field[y][x] = true;\n  for (int i = 0; i < 4; i++){\n    if (mp[y + dy[i]][x + dx[i]] == color){\n      dfs(y + dy[i], x + dx[i], color);\n    }\n  }\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  int n;\n\n  while (cin >> w >> h, w || h){\n    memset(field, false, sizeof(field));\n    memset(mp, 0, sizeof(mp));\n    cin >> xs >> ys >> xg >> yg >> n;\n    for (int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      if (d){\n        for (int j = 0; j < 4; j++){\n          for (int k = 0; k < 2; k++){\n            mp[y + j][x + k] = c;\n          }\n        }\n      }\n      else {\n        for (int j = 0; j < 2; j++){\n          for (int k = 0; k < 4; k++){\n            mp[y + j][x + k] = c;\n          }\n        }\n      }\n    }\n    dfs(ys, xs, mp[ys][xs]);\n    (field[yg][xg]) ? print(\"OK\") : print(\"NG\");\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\t\nbool check(short maze[MAX][MAX])\n{\n\tque.push(S);\n\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*********\n深さ優先探索\n**********/\n\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define MAX 101\n\nint w,h,n,i,j,ii,count=-1;\nint sx,sy,gx,gy;\nint c,d,x,y;\nint bord[MAX][MAX][MAX]={0};\nint num;\n\n//プロトタイプ宣言\nint bfs(int x,int y);\n\n\n\nint main(){\n  \n  while(1){\n\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0) break;\n    else{\n      count++;\n\n    scanf(\"%d %d\",&sx,&sy);\n    scanf(\"%d %d\",&gx,&gy);\n    scanf(\"%d\",&n);\n    \n    for(ii=0;ii<n;ii++){\n      \n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      x-=1; y-=1;\n      \n      if(d==0){\n\tfor(i=0;i<2;i++){\n\t  for(j=0;j<4;j++){\n\t    bord[count][y+i][x+j]=c;\n\t  }\n\t}\n      }\n      \n      else{\n\tfor(i=0;i<4;i++){\n\t  for(j=0;j<2;j++){\n\t    bord[count][y+i][x+j]=c;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //こっからは探索!!\n    sx-=1; sy-=1;\n    gx-=1; gy-=1;\n    num=bord[count][sy][sx];\n    \n    bfs(sx,sy);\n    \n    if(bord[count][gy][gx]==-1) printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    }\n\n  }\n  return 0;\n}\n\n\n\nint bfs(int x,int y){\n    \n  if(x<w && y<h){\n    //今いるところを、-1に置き換える\n    bord[count][y][x]=-1;\n    \n    //移動する4方向を調べる\n    if(0<=x && x<w && 0<=y-1 && y-1<h && bord[count][y-1][x]==num) bfs(x,y-1);\n    if(0<=x-1 && x-1<w && 0<=y && y<h && bord[count][y][x-1]==num) bfs(x-1,y);\n    if(0<=x+1 && x+1<w && 0<=y && y<h && bord[count][y][x+1]==num) bfs(x+1,y);\n    if(0<=x && x<w && 0<=y+1 && y+1<h && bord[count][y+1][x]==num) bfs(x,y+1);\n  }\n  \n  else return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nint F[1000][1000];\n\n//?????????????????????\nvoid r(int yy,int xx,int z){\n if(F[yy][xx]!=z){\n\treturn ;\n }\n\nF[yy][xx]=10;\n\nr(yy-1,xx,z);\nr(yy,xx+1,z);\nr(yy+1,xx,z);\nr(yy,xx-1,z);\n\n}\n\n\n\n\nint main(){\n int w,h,xs,ys,xg,yg,n;\n int c,d,x,y;\n\nwhile(1){\n cin>>w>>h;\n\n//?????????????????????0???????????????\n if(w==0&&h==0)break;\n//???????????????????????????????????\\?????°????±??????£???????????????\n cin>>xs>>ys>>xg>>yg>>n;\n\n//n?????°???????????????????????????\nfor(int i=0;i<n;i++){\n\tcin>>c>>d>>x>>y;//?????????????????¨????????±????????????\n\tif(d==0){\n\t\tF[x  ][y]=c;\n\t\tF[x+1][y]=c;\n \t\tF[x+2][y]=c;\n \t\tF[x+3][y]=c;\n \t\tF[x  ][y+1]=c;\n \t\tF[x+1][y+1]=c;\n \t\tF[x+2][y+1]=c;\n \t\tF[x+3][y+1]=c;\n\t}\n\tif(d==1){\n\t\tF[x][y  ]=c;\n \t\tF[x][y+1]=c;\n\t\tF[x][y+2]=c;\n\t\tF[x][y+3]=c;\n \t\tF[x+1][y  ]=c;\n\t\tF[x+1][y+1]=c;\n\t\tF[x+1][y+2]=c;\n \t\tF[x+1][y+3]=c;\n\t}\n}\n\n//??\\????????????????????????\n\n\n//??????????????????\nr(xs,ys,F[xs][ys]);\n//??´???????????????\nif(F[xg][yg]==10){\n\tcout<<\"OK\"<<endl;\n}else{\n\tcout<<\"NG\"<<endl;\n}\n//???????????????????????????\nfor(int i=1;i<=w;i++){\n\tfor(int g=1;g<=w;g++){\n\t\tF[i][g]=6;\n\t}\n}\n//?????????????????????\n}\nreturn 0;\n}\n\n\n\n\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\n\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=1;i<=100;i++){     //Boardの初期化\n            for(int j=1;j<=100;j++)\n                Board[j][i] = -1;\n        } \n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0){\n        ca = 1000;\n        break;\n      }else if(i == n-1){\n        ca = 1000;\n      }\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[102][102];\nbool visited[102][102];\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\nint d_x[] = {1, 0, -1, 0};\nint d_y[] = {0, -1, 0, 1};\nint sc;\n\nbool search(int y, int x) {\n  if (visited[y][x] || field[y][x] == 0 || field[y][x] != sc) {return false;}  \n  if (y == yg && x == xg) {\n    return true;\n  }\n  visited[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    if (search(y + d_y[i], x + d_x[i])) {return true;}\n  }\n  return false;\n}\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d \", &w, &h);\n    if (w == 0 && h == 0) {\n      break;\n    }\n    scanf(\"%d %d \", &xs, &ys);\n    scanf(\"%d %d \", &xg, &yg);\n    scanf(\"%d \", &n);\n    for (int i = 0; i < 102; i++) {\n      fill(field[i], &field[i][102], 0);\n      fill(visited[i], &visited[i][102], false);\n    }\n    for (int i = 0; i < n; i++) {\n      int c, d, x, y;\n      scanf(\"%d %d %d %d \", &c, &d, &x, &y);\n      for (int i = 0; i < 2; i++) {\n\tfor (int j = 0; j < 4; j++) {\n\t  if (d == 0) {\n\t    field[y + i][x + j] = c;\n\t  } else {\n\t    field[y + j][x + i] = c;\n\t  }\n\t}\n      }\n    }\n    /*for (int i = 1; i <= h; i++) {\n      for (int j = 1; j <= w; j++) {\n\tprintf(\"%d \", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    sc = field[ys][xs];\n    if (search(ys, xs)) {cout << \"OK\" << endl;}\n    else {cout << \"NG\" << endl;}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<queue>\n#include<stack>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint block[100][100];\nbool maze = false;\nint w, h;\n\nvoid Lnitialization(int w,int h){\n\tfor (int i = 1; i <= h; i++){\n\t\tfor (int j = 1; j <= w; j++){\n\t\t\tblock[i][j] = 0;\n\t\t}\n\t}\n}\nvoid Side(int c,int x,int y){\n\tfor (int i = y; i < y + 2; i++){\n\t\tfor (int j = x; j < x + 4; j++){\n\t\t\tblock[i][j] = c;\n\t\t}\n\t}\n}\nvoid Longitudinal(int c,int x,int y){\n\tfor (int i = y; i < y + 4; i++){\n\t\tfor (int j = x; j < x + 2; j++){\n\t\t\tblock[i][j] = c;\n\t\t}\n\t}\n}\nvoid solve(int xs, int ys, int xg, int yg,int c){\n\n\tif (xs<0 || xs>w || ys<0 || ys>h || block[ys][xs] != c) return;\n\tif (ys == yg && xs == xg) {\n\t\tmaze = true;\n\t\treturn;\n\t}\n\tblock[ys][xs] = -1;\n\n\tsolve(xs+1, ys, xg, yg, c);\n\tsolve(xs-1, ys, xg, yg, c);\n\tsolve(xs, ys+1, xg, yg, c);\n\tsolve(xs, ys-1, xg, yg, c);\n\n\treturn;\n}\n\n// block[xx][xx]???-1?????£?????´??? return;\n// block[xx][xx]??????????????§????????´??? return;\n// block[xx][xx]?????´???????????£?????´??????true AND re:start\n\nint main(){\n\tint xs, ys;\n\tint xg, yg;\n\tint n;\n\tint c, d, x, y;\n\twhile (cin >> w >> h, w, h){\n\t\tLnitialization(w, h);\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) Side(c, x, y);\n\t\t\telse if (d == 1) Longitudinal(c, x, y);\n\t\t}\n\t\tc = block[ys][xs];\n\t\tsolve(xs, ys, xg, yg, c);\n\t\tif (maze) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t\tmaze = false;\n \t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[100][100]={},sx,sy,gx,gy;\nint f(int i,int j){\n\tif(i==gy && j==gx)\n\t\treturn 1;\n\tif(a[i+1][j]==a[sy][sx])\n\t\tif(f(i+1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j+1]==a[sy][sx])\n\t\tif(f(i,j+1)==1)\n\t\t\treturn 1;\n\tif(a[i-1][j]==a[sx][sy])\n\t\tif(f(i-1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j-1]==a[sx][sy])\n\t\tif(f(i,j-1)==1)\n\t\t\treturn 1;\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint w,h,n,c,d,x,y;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)\n\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\ta[i][j]=0;\n\t\tcin>>sx>>sy;\n\t\tcin>>gx>>gy;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t}\n\t\tif(a[sx][sy]!=a[gx][gy])\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sy,sx)==0)\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sx,sy)==1)\n\t\tcout<<\"OK\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    int xs,ys,xg,yg,n;\n    cin>>xs>>ys>>xg>>yg>>n;\n    int maze[w][h];\n    memset(maze,0,sizeof(maze));\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      rep(i,4-d*2)rep(j,2+d*2)maze[x+i][y+j]=c;\n    }\n    queue<PI> Q;\n    if(maze[xs][ys]== 0 || maze[xs][ys]!=maze[xg][yg] || maze[xg][yg]==0){\n      puts(\"NG\");\n      continue;\n    }\n    bool goal=false;\n    Q.push(mp(xs,ys));\n    int dp[w][h];\n    memset(dp,0,sizeof(dp));\n    dp[xs][ys]=1;\n    while(!Q.empty()){\n      int cx=Q.front().f,cy=Q.front().s;Q.pop();\n      if(cx==xg && cy==yg){\n        goal=true;\n        break;\n      }\n      rep(i,4){\n        int nx=cx+dx[i],ny=cy+dy[i];\n        if(nx<0 || nx>=w || ny<0 || ny>=h || dp[nx][ny])continue;\n        if(maze[nx][ny]!=maze[xs][ys])continue;\n        dp[nx][ny]=1;\n        Q.push(mp(nx,ny));\n      }\n    }\n    cout<<(goal?\"OK\":\"NG\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\nvector < vector <int> > block_map;\nvector < vector <bool> > visited;\n\nint xs, ys;\nint xg, yg;\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, -1, 0, 1 };\n\nint abs( int n )\n{\n\tif ( n < 0 )\n\t\treturn -n;\n\treturn n;\n}\n\nint getMD( int x, int y )\n{\n\treturn abs(xg-x) + abs(yg-y);\n}\n\nbool dfs( int x, int y, int now, int depth )\n{\n\tif ( x == xg && y == yg )\n\t\treturn true;\n\tif ( now + getMD(x,y) > depth )\n\t\treturn false;\n\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif ( nx < 0 || nx >= w || ny < 0 || ny >= h )\n\t\t\tcontinue;\n\n\t\tif ( visited[ny][nx] == false && block_map[ny][nx] == block_map[ys][xs] )\n\t\t{\n\t\t\tvisited[ny][nx] = true;\n\t\t\tif ( dfs( nx, ny, now + 1, depth ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\tcin >> w >> h;\n\t\tif ( w == 0 && h == 0 )\n\t\t\tbreak;\n\n\t\tblock_map = vector < vector <int> >( h, vector <int>(w,0) );\n\t\tvisited = vector < vector <bool> >( h, vector <bool>(w,false) );\n\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\txs--;\n\t\tys--;\n\t\txg--;\n\t\tyg--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( d == 0 )\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 2; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 4; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 4; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 2; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvisited[ys][xs] = true;\n\t\tbool ok_flag = false;\n\t\tfor ( int i = 0; i < w + h; i++ )\n\t\t{\n\t\t\tif ( dfs( xs, ys, 0, i ) )\n\t\t\t{\n\t\t\t\tok_flag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( ok_flag )\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != goal) {\n            ans.push_back(\"NG\");\n            \n            break;\n        }\n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint w,h,n,sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tint xx = x+1;\n\tint yy = y;\n\n\tif(xx == gx && yy == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tif(xx <= w)\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\txx = x;\n\tyy = y+1;\n\tif(yy <= h)\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\txx = x-1;\n\tyy = y;\n\tif(xx >= 1)\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\t\t\t\n\txx = x;\n\tyy = y-1;\n\tif(yy >= 1)\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n}\n\nint main(){\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tcin >> w >> h;\n\t\tif(!w && !h)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0)\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+4; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t\telse\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+2; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nbool dfs(vector<vector<int> > &g);\n\nint sx, sy, gx, gy;\nint n, m; \nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint main()\n{\n\nwhile(cin >> n >> m,(n|m)){\n m++; n++;\n vector<vector<int> > graph(m,vector<int>(n,0));\n \n cin>>sx>>sy>>gx>>gy;\n int bl;  cin>>bl;\n loop(i, bl){\n  int a,b,c,t; cin>>a>>b>>c>>t;\n  if(b){\n   for(int j=t;j<t+2;j++){\n    for(int k=c;k<c+4;k++){\n     graph[k][j] = a;\n    }\n   } \n  } else {\n   for(int j=c;j<c+2;j++){\n    for(int k=t;k<t+4;k++){\n     graph[k][j] = a;\n    }\n   }\n  }\n }\ncout << (dfs(graph)) ? \"OK\" : \"NG\" << endl;\n}\nreturn 0;\n}\n\nbool dfs(vector<vector<int> > &g) {\nint cl = g[sx][sy];\nvector<vector<bool> > vsed(m,vector<bool>(n,false));\nqueue<i_i > q;\nq.push(mp(sx,sy));\nwhile(!q.empty()){\nint x = q.top().first, y = q.top().second;\nq.pop();\nif(x == gx && y == gy){\nreturn true;\n}\nif(vsed[x][y]){\ncontinue;\n} else {\nvsed[x][y]=true;\n}\n\nloop(i, 4) {\nint nx = x +dx[i], ny = y +dy[i];\nif(0<nx && nx < n && 0<ny && ny < m){\nif(g[nx][ny] == cl){\nq.push(mp(nx,ny));\n}\n} \n}\n\n}\nreturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H, xs, ys, xg, yg, N;\nint g[128][128];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nint start;\n\nint dfs(int y, int x){\n  //  printf(\"%d %d\\n\", y, x);\n  if(y == yg && x == xg) return 1;\n  g[y][x] = 0;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || ny >= H || nx < 0 || nx >= W || g[ny][nx] != start) continue;\n    if(dfs(ny, nx)) return 1;\n  }\n  return 0;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W+H){\n    scanf(\"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &N); xs--; ys--; xg--; yg--;\n    memset(g, -1, sizeof(g));\n    rep(i, N){\n      int c, d, x, y;\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y); x--; y--;\n      if(!d){\n\trep(i, 2) rep(j, 4) g[i+y][j+x] = c;\n      }else{\n\trep(i, 4) rep(j, 2) g[i+y][j+x] = c;\n      }\n    }\n    start = g[ys][xs];\n    /*    rep(i, H){\n      rep(j, W) printf(\"%d\", g[i][j]); puts(\"\");\n      }*/\n\n    puts(dfs(ys, xs)?\"OK\":\"NG\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nint sx, sy, gx, gy;\nint n, m; \n\nint main()\n{\n\nwhile(cin >> n >> m,(n|m)){\n m++; n++;\n vector<vector<int> > graph(m,vector<int>(n,0));\n \n cin>>sx>>sy>>gx>>gy;\n int bl;  cin>>bl;\n loop(i, bl){\n  int a,b,c,t; cin>>a>>b>>c>>t;\n  if(b){\n   for(int j=t;j<t+2;j++){\n    for(int k=c;k<c+4;k++){\n     graph[k][j] = a;\n    }\n   } \n  } else {\n   for(int j=c;j<c+2;j++){\n    for(int k=t;k<t+4;k++){\n     graph[k][j] = a;\n    }\n   }\n  }\n }\ncout<<(dfs(graph))?\"OK\":\"NG\"<<endl;\n}\nreturn 0;\n}\n\nbool dfs(vector<vector<int> > &g) {\nint cl = g[sx][sy];\nvector<vector<bool> > vsed(m,vector<bool>(n,false));\nqueue<i_i > q;\nq.push(mp(sx,sy));\nwhile(!q.empty()){\nint x = q.top().first, y = q.top().second;\nq.pop();\nif(x == gx && y == gy){\nreturn true;\n}\nif(vsed[x][y]){\ncontinue;\n} else {\nvsed[x][y]=true;\n}\n\nloop(i, 4) {\nint nx = x +dx[i], ny = y +dy[i];\nif(0<nx && nx < n && 0<ny && ny < m){\nif(g[nx][ny] == cl){\nq.push(mp(nx,ny));\n}\n} \n}\n\n}\nreturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=0;\n\t\tgoal=0;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2&&y1+h1>=y2)||(x2==x1+w1&&y1<=y2+h2&&y1+h1>=y2)||(y1==y2+h2&&x1<=x2+w2&&x1+w1>=x2)||(y2==y1+h1&&x1<=x2+w2&&x2<=x1+w1))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\t\tque.push(*it);\n\t\t}\n\t\tadjacive[survey].clear();\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[101][101]={0},v[101][101]={0};\nint root(int x,int y,int vmap[][101]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[y][x]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\t\tfor(int e=y;e<y+2;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int e=y;e<y+4;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int i1=0;i1<101;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define BLANK 0\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nbool dfs(int color, int x, int y, int gx, int gy, vector<vector<int> >& blocks){\n  if(x == gx && y == gy){ return true; }\n  blocks[x][y] = BLANK;\n  for(int i = 0; i < 4; i++)\n    if(blocks[x + dx[i]][y + dy[i]] == color)\n      if(dfs(color, x + dx[i], y + dy[i], gx, gy, blocks))\n        return true;\n  return false;\n}\n\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n    int sx, sy, gx, gy;\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n\n    int n;\n    cin >> n;\n\n    vector<vector<int> > blocks(w + 2, vector<int>(h + 2, BLANK));\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      int now_w = (d == 0) ? 4 : 2;\n      int now_h = (d == 0) ? 2 : 4;\n      for(int j = 0; j < now_w; j++)\n        for(int k = 0; k < now_h; k++)\n          blocks[x + j][y + k] = c;\n    }\n\n    // ????????????\n    if(blocks[sx][sy] == BLANK){\n      cout << \"NG\" << endl;\n      continue;\n    }\n\n    // ??????\n    if(dfs(blocks[sx][sy], sx, sy, gx, gy, blocks)){ cout << \"OK\" << endl; }\n    else{ cout << \"NG\" << endl; }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg, w,h;\n\nvoid dfs(int target, int x, int y){\n    if(x < 0 || y < 0 || x >= w || y >= h) return;\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 0;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n}\n\nint main(){\n    int xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,105) rep(j,105) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        xs--; ys--; xg--; yg--;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second \nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,sx,sy,gx,gy,fc;\nint imap[110][110];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\nbool found;\nvoid Init(){\n  for(int i=0;i<110;i++){\n    for(int j=0;j<110;j++){\n      imap[i][j] = -1;\n    }\n  }\n}\n\nvoid display(){\n for(int i=0;i<=h;i++){\n      for(int j=0;j<=w;j++){\n\tprintf(\"%3d \",imap[i][j]);\n      }\n      cout << endl;\n    }\n}\n\nvoid draw(int c,int d,int x,int y){\n  int limy,limx;\n  limy = d==1?4:2;\n  limx = d==1?2:4;\n  for(int i=0;i<limy && i<=h;i++){\n    for(int j=0;j<limx && j<=w;j++){\n      imap[y+i][x+j] = c;\n    }\n  }\n}\n\nvoid rec(int px,int py){\n  if(px == gx && py == gy){\n    found = true;\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = px+dx[i], ny = py+dy[i];\n    if(!found && 0<=nx && nx <=w && 0<=ny && ny<=h && imap[ny][nx] == fc){\n      imap[ny][nx] = -1;\n      rec(nx,ny);\n    }\n  }\n}\n\n\nbool isMaze(){\n  rec(sx,sy);\n  if(found)return true;\n  return false;\n}\n\nint main(){\n  int n,c,d,x,y;\n  while(cin >> w >> h  && w && h){\n    found = false;\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n    Init();\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      draw(c,d,x,y);\n    }\n\n    \n    fc = imap[sy][sx];\n    if(fc == -1)cout << \"NG\" << endl;\n    else{\n      if(isMaze())cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n    int w,h,xs,ys,n;\n    while(1){\n        Flag=0;\n        memset(MAP,0,sizeof(MAP));\n        memset(MF,0,sizeof(MF));\n        scanf(\"%d %d\",&w,&h);\n        if(w == 0 && h == 0) break;\n        scanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n        scanf(\"%d\",&n);\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            haichi();\n        }\n        /*for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                printf(\"%d\",MAP[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        M = MAP[ys][xs];//\n        if(MAP[ys][xs] == MAP[yg][xg])\n            Block(xs,ys);\n        if(Flag==1)\n            printf(\"OK\\n\");\n        else\n            printf(\"NG\\n\");\n    }\n    return 0;\n}\n \nvoid haichi(void)\n{\n    if(d==0){\n        MAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n        MAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n    }\n    else if(d==1){\n        MAP[y][x]=c;MAP[y][x+1]=c;\n        MAP[y+1][x]=c;MAP[y+1][x+1]=c;\n        MAP[y+2][x]=c;MAP[y+2][x+1]=c;\n        MAP[y+3][x]=c;MAP[y+3][x+1]=c;\n    }\n}\n \nvoid Block(int X,int Y)\n{\n    MF[Y][X] = 1;\n    //printf(\"%d\",M);\n    if(X == xg && Y == yg)\n        Flag = 1;\n    if(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n    if(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n    if(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n    if(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(color!=0){\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\td[ny][nx]=0;\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 0;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y+1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\tif (map[xg][yg]==0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 10;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h;\t\t\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tcin>>xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\t\n\t\tif (map[xg][yg]==10)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2015/07/03 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y, int X, int C)\n{\n\tif(F[Y][X]!=C)\n\t\treturn;\n\n\tF[Y][X] = 6;\n\n\tDFS(Y-1, X, C);\t\t// 上\n\tDFS(Y, X+1, C);\t\t// 右\n\tDFS(Y+1, X, C);\t\t// 下\n\tDFS(Y, X-1, C);\t\t// 左\n}\n\nint main()\n{\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\n\t\tfor(int y=0; y<=h+1; y++){\n\t\t\tfor(int x=0; x<=w+1; x++){\n\t\t\t\tF[y][x] = 0;\t\t// 初期化\n\t\t\t}\n\t\t}\n\n\t\tint xs, ys;\n\t\tcin >> xs >> ys;\n\n\t\tint xg, yg;\n\t\tcin >> xg >> yg;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tF[y][x] = F[y][x+1] = F[y+1][x] = F[y+1][x+1] = c;\n\n\t\t\tif(d==0){\n\t\t\t\tF[y][x+2] = F[y][x+3] = F[y+1][x+2] = F[y+1][x+3] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tF[y+2][x] = F[y+2][x+1] = F[y+3][x] = F[y+3][x+1] = c;\n\t\t\t}\n\t\t}\n\n\t\tif(F[ys][xs]==0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif(F[yg][xg]==6){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nstruct Data{\n\tint y, x;\n\tData(){}\n\tData(int _y, int _x){\n\t\ty = _y; x = _x;\n\t}\n};\n\nint fld[100][100];\n\nvoid PaintFld(int c, int x, int y, int w, int h){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfld[y + i][x + j] = c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint W, H;\n\twhile(cin >> W >> H, W || H){\n\t\tfill_n( (int*)fld, 100*100, 0 );\n\t\tint Xs, Ys, Xg, Yg, N, C, D, X, Y;\n\t\tcin >> Xs >> Ys >> Xg >> Yg >> N;\n\t\tXs--; Ys--; Xg--; Yg--;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tX--; Y--;\n\t\t\tif(D == 0) PaintFld(C, X, Y, 4, 2);\n\t\t\telse PaintFld(C, X, Y, 2, 4);\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tbool memo[100][100] = {}, ans = false;\n\t\tq.push( Data(Xs, Ys) );\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\n\t\t\tif(fld[q_front.y][q_front.x] == 0 ||\n\t\t\t   fld[q_front.y][q_front.x] != fld[Ys][Xs])\n\t\t\t\tcontinue;\n\n\t\t\tif(q_front.y == Yg && q_front.x == Xg){\n\t\t\t\tans = true; break;\n\t\t\t}\n\n\t\t\tif(memo[q_front.y][q_front.x]) continue;\n\t\t\tmemo[q_front.y][q_front.x] = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\tint nx = q_front.x + dx[i];\n\n\t\t\t\tif(ny < 0 || H <= ny || nx < 0 || W <= nx)\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push( Data(ny, nx) );\n\t\t\t}\n\t\t}\n\n\t\tif(ans) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y, int before_x, int before_y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( !color[x][y] ){\n\t\treturn dp[x][y] = false;\n\t}\n\tif ( x == 0 || y == 0 )\n\t\treturn dp[x][y] = false;\n\tif ( color[x][y] == color[x + 1][y] && x + 1 != before_x && dp[x + 1][y] )\n\t\tif ( solve(x + 1, y, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] && y + 1 != before_y && dp[x][y + 1] )\n\t\tif ( solve(x, y + 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] && y - 1 != before_y && dp[x][y - 1] )\n\t\tif ( solve(x, y - 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] && x - 1 != before_x && dp[x - 1][y] )\n\t\tif ( solve(x - 1, y, x, y) )\n\t\t\treturn true;\n\treturn dp[x][y] = false;\n}\n\n\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i < 1000; i++ ){\n\t\t\tfor ( int j = 0; j < 1000; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t\tdp[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\t//ブロック情報\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( block_quarter == 0 ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( solve(start_x, start_y, start_x, start_y) )\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nint w,h,xs,ys,xg,yg,n,cc;\nint field[100][100];\nbool flag;\n\nvoid dfs(int x,int y,int c){\n\tif(flag) return;\n\tif(x == xg && y == yg) {\n\t\tflag = true;\n\t\treturn;\n\t}\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < w && ny >= 0 && ny < h && field[nx][ny] == c){\n\t\t\tfield[nx][ny] = 0;\n\t\t\tdfs(nx,ny,c);\n\t\t\tfield[nx][ny] = c;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif(!w) break;\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tfor(int j = 0;j < h;j++) field[i][j] = 0;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n; xs--;ys--;xg--;yg--;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int k = 0;k < 2;k++){\n\t\t\t\t\tfor(int j = 0;j < 4;j++) field[x + k - 1][y + j - 1] = c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tfor(int j = 0;j < 2;j++) field[x + k - 1][y + j - 1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(field[xs][ys] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcc = field[xs][ys];\n\t\tfield[xs][ys] = 0;\n\t\tdfs(xs,ys,cc);\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\t\nbool check(short maze[MAX][MAX])\n{\n\tque.push(S);\n\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t/*\trep(i,MAX){\n\t\t\trep(j,MAX)\n\t\t\t\tmaze[i][j] = -10;\n\t\t}*/\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(/*maze[S.second][S.first] > 0 && */maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint a[100][100],b[100][100];\nbool o[100][100];\nbool l;\nvoid solve(int w,int h,int xg, int yg,int c,int n,int m) {\n\tif (m<h-1&&a[n][m+1] == c) {\n\t\tb[n][m + 1] = min(b[n][m] + 1, b[n][m + 1]);\n\t\tif (n == xg&&m + 1 == yg) {\n\t\t\tl = true; return;\n\t\t}\n\t\ta[n][m + 1] = 0;\n\t\tsolve(w,h,xg, yg, c, n, m + 1);\n\t}\n\tif (m > 0 && a[n][m - 1] == c) {\n\t\tb[n][m - 1] = min(b[n][m] + 1, b[n][m - 1]);\n\t\tif (n == xg&&m - 1 == yg) {\n\t\t\tl = true;\n\t\t\treturn;\n\t\t}\n\t\ta[n][m - 1] = 0;\n\t\tsolve(w, h, xg, yg, c, n, m - 1);\n\t}\n\tif (n<w - 1 && a[n+1][m ] == c) {\n\t\tb[n+1][m] = min(b[n][m] + 1, b[n+1][m]);\n\t\tif (n + 1 == xg&&m == yg) { l = true; return; }\n\t\ta[n + 1][m] = 0;\n\t\tsolve(w, h, xg, yg, c, n+1,m);\n\t}\n\tif (n>0 && a[n-1][m] == c) {\n\t\tb[n-1][m] = min(b[n][m] + 1, b[n-1][m]);\n\t\tif (n == xg&&m == yg) { l = true; return; }\n\t\ta[n - 1][m] = 0;\n\t\tsolve(w, h, xg, yg, c, n-1, m);\n\t}\n}\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h&&w != 0 && h != 0) {\n\t\tint xs, ys, xg, yg,n;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tb[i][j] = 10000;\n\t\t\t\to[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> y >> x;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int z = 0; z < 2; z++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) \n\t\t\t\t\t\ta[x + z-1][y + j-1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int z = 0; z < 2; z++) \n\t\t\t\t\t\ta[x + j-1][y + z-1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = a[xs-1][ys-1];\n\t\ta[xs-1][ys-1] = 0;\n\t\tl=false;\n\t\tif(k!=0)\n\t\t\tsolve(w,h,xg-1, yg-1, k,xs-1,ys-1);\n\t\tif (l) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n\nint field[102][102];//y,x\nbool flag;\nint sx,sy,gx,gy,col;\nstd::map<int, bool> memo;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tif(field[y][x] != col || memo[1000*x+y])\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tmemo[1000*x+y] = true;\n\tDFS(x+1, y);\n\tif(flag)\n\t\treturn;\n\tDFS(x, y+1);\n\tif(flag)\n\t\treturn;\n\tDFS(x-1, y);\n\tif(flag)\n\t\treturn;\n\tDFS(x, y-1);\n}\n\nint main(){\n\tint n,c,d,bx,by;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tmemo.clear();\n\n\t\tstd::cin >> c >> d;\n\t\tif(!c && !d)\n\t\t\treturn 0;\n\n\t\tstd::cin >> sx >> sy;\n\t\tstd::cin >> gx >> gy;\n\n\t\tstd::cin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tstd::cin >> c >> d >> bx >> by;\n\t\t\tif(d==0)\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+4; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t\telse\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+2; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t}\n\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include<cstdio>\n#include<queue>\n\n\n\n//マップの大きさの最大値\n#define MAP_MAX\t\t100\n//最初の歩数\n#define START\t\t1000000\n//マップの配列\nint wh_map[MAP_MAX + 1][MAP_MAX + 1];\n//縦・横に進むための配列\nint h_tate[4] = {1 , -1 , 0 , 0};\nint h_yoko[4] = {0 , 0 , 1 , -1};\n\n\n\n//----- blockの情報を持つ構造体 -----//\ntypedef struct block\n{\n\tint iro;\n\tint muki;\n\tint x;\n\tint y;\n}S_block;\n\n\n\n//----- 答えを返す関数 -----//\nbool f_ans(int , int  , int , int , int , int);\n\n\n//----- ブロックの入力は長くなるので関数で -----//\nint f_block_syokika(S_block[] , int , int , int);\n\n\n\n//----- マップを-1で初期化する変数 -----//\nvoid f_mapsyokika(void);\n\n\n\n//----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(メモリ節約のために構造体は参照で受ける) -----//\nvoid f_okmap(S_block[] , int , int , int , int);\n\n\n\n\n//*****----- main -----*****//\n\nint main(void)\n{\n\t//ボードの大きさ\n\tint tate = 0 , yoko = 0;\n\t//スタートの座標\n\tint startx = 0 , starty = 0;\n\t//ゴール座標\n\tint goalx = 0 , goaly = 0;\n\t//ブロックの個数\n\tint n = 0;\n\t//スタートと同じ色\n\tint startcolor = 0;\n\n\twhile (1)\n\t{\n\t\t//それぞれ入力\n\t\tscanf(\"%d%d\" , &tate , &yoko);\n\t\tif (tate == 0 && yoko == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t//スタート・ゴール座標\n\t\tscanf(\"%d%d\" , &startx , &starty);\n\t\tscanf(\"%d%d\" , &goalx , &goaly);\n\t\t//ブロックの個数\n\t\tscanf(\"%d\" , &n);\n\n\t\t//ブロックの分だけ領域を確保する\n\t\tS_block *s_block = new S_block[n];\n\n\t\t//関数で初期化\n\t\tstartcolor = f_block_syokika(s_block , n , starty , startx);\n\t\t//次にマップを初期化\n\t\tf_mapsyokika();\n\n\t\t//mapにSTARTを振り分ける\n\t\tf_okmap(s_block , starty , startx , startcolor , n);\n\n\t\tif (f_ans(starty , startx , goaly , goalx , tate , yoko) == true)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\n\t\t//一度メモリを解放\n\t\tdelete []s_block;\n\t}\n}\n\n\n\n\n//*****----- ブロックの情報を入力する関数 -----*****//\n\nint f_block_syokika(S_block s_data[] , int n , int starty , int startx)\n{\n\t//スタートの色を取り出す変数\n\tint startcolor = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\" , &s_data[i].iro , &s_data[i].muki , &s_data[i].x , &s_data[i].y);\n\n\t\t//色を取り出す(横向きなら)\n\t\tif (s_data[i].muki == 0)\n\t\t{\n\t\t\t//横向きに設置したと仮定し、その中にスタート座標が含まれているかどうか調べる\n\t\t\tif ((starty <= s_data[i].y + 1 && starty >= s_data[i].y) && (startx >= s_data[i].x && startx <= s_data[i].x + 3))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t\t//縦向きだった\n\t\telse\n\t\t{\n\t\t\t//縦向きに設置したと仮定し、その中にスタート座標が含まれているか調べる\n\t\t\tif ((starty <= s_data[i].y + 3 && starty >= s_data[i].y) && (startx >= s_data[i].x && startx <= s_data[i].x + 1))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t}\n\n\t//初期座標の値を返す\n\treturn startcolor;\n}\n\n\n\n//*****----- 答えを求める関数 -----*****//\n\nbool f_ans(int starty , int startx , int goaly , int goalx , int tateindex , int yokoindex)\n{\n\t//幅優先探索で使うｙとｘ\n\tstd::queue<int> x;\n\tstd::queue<int> y;\n\n\t//最初の座標をキューに追加\n\ty.push(starty);\n\tx.push(startx);\n\n\t//キューがなくなるまで\n\twhile (!x.empty())\n\t{\n\t\t//ｙ座標とｘ座標を取り出す\n\t\tint yy = y.front();\n\t\tint xx = x.front();\n\t\t//デキュー\n\t\ty.pop();\n\t\tx.pop();\n\n\t\t//ゴールにたどり着いた\n\t\tif (yy == goaly && xx == goalx)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t//今いる座標の値を吹っ飛ばす\n\t\twh_map[yy][xx] = -1;\n\n\t\t//四方に散れるか調べる\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t//次に進む座標を取得\n\t\t\tint nexty = yy + h_tate[i];\n\t\t\tint nextx = xx + h_yoko[i];\n\n\t\t\t//まずは範囲内かどうか調べる\n\t\t\tif (nexty >= 1 && nexty <= tateindex && nextx >= 1 && nextx <= yokoindex)\n\t\t\t{\n\t\t\t\t//そこが通れる場所且つブロックの色が同じとき\n\t\t\t\tif (wh_map[nexty][nextx] == START)\n\t\t\t\t{\n\t\t\t\t\t//ｙとｘをそれぞれ追加\n\t\t\t\t\ty.push(nexty);\n\t\t\t\t\tx.push(nextx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\n//*****----- マップを初期化する関数 -----*****//\n\nvoid f_mapsyokika(void)\n{\n\tfor (int i = 1; i < MAP_MAX + 1; i++)\n\t{\n\t\tfor (int j = 1; j < MAP_MAX + 1; j++)\n\t\t{\n\t\t\twh_map[i][j] = -1;\n\t\t}\n\t}\n}\n\n\n\n//*****----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(構造体は配列) -----*****//\n\nvoid f_okmap(S_block s_data[] , int starty , int startx , int startcolor , int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s_data[i].iro == startcolor)\n\t\t{\n\t\t\t//縦か横かによって挙動が変わる\n\t\t\tif (s_data[i].muki == 0)\n\t\t\t{\n\t\t\t\t//2 * 4マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0;k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + j][s_data[i].x + k] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//横だった\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 4 * 2マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + k][s_data[i].x + j] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n \nusing namespace std;\n \n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\n \nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0-1};\n \ntypedef pair<int ,int > P;\n \nchar maze[105][105];\n \nint sx,sy;\nint gx,gy;\nint w,h;\n \nchar sc;        //スタート地点のカラー\n \n//stdin\n//stdout\n \nvoid dfs(int x,int y)\n{\n    maze[y][x]='9';\n \n    rep(i,4)\n    {\n/*        for(int j=-1;j<=1;j++)\n        {*/\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n \n            if(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[ny][nx]==sc)\n            {\n                dfs(nx,ny);\n            }\n \n/*        }*/\n    }\n    return ;\n}\n \nvoid solve()\n{\n \n    rep(i,101)\n        rep(j,101)\n        maze[i][j]='0';\n \n    int n;\n    char c;\n    int d;\n    int x,y;\n \n    cin>>sx>>sy;\n    cin>>gx>>gy;\n \n    cin>>n;\n \n    rep(i,n)\n    {\n        cin>>c>>d>>x>>y;\n \n        if(d==1)\n        {\n            rep(i,2)\n            {\n                rep(j,4)\n                {\n                    maze[y+j][x+i]=c;\n \n                }\n            }\n        }\n        else if (d==0)\n        {\n            rep(i,4)\n            {\n                rep(j,2)\n                {\n                    maze[y+j][x+i]=c;\n \n                }\n            }\n        }\n \n    }\n//6 6\n//1 1\n//3 6\n//2\n//1 0 1 1\n//1 1 3 3\n//  rep(i,w+1)\n//  {\n//      rep(j,h+1)\n//      {\n//          cout<<maze[i][j];\n//\n//      }\n//      cout<<endl;\n//  }\n//\n//  cout<<maze[gx][gy]<<endl;\n \n    if(maze[sy][sx]=='0')\n    {\n        cout<<\"NG\"<<endl;\n        return;\n    }\n    else\n    {\n        sc=maze[sy][sx];\n        dfs(sx,sy);\n    }\n     \n    //rep(i,w+1)\n    //{\n    //  rep(j,h+1)\n    //  {\n    //      cout<<maze[i][j];\n \n    //  }\n    //  cout<<endl;\n    //}\n \n    if(maze[gy][gx]=='9')\n    {\n        cout<<\"OK\"<<endl;\n        return;\n    }\n    else\n    {\n        cout<<\"NG\"<<endl;\n        return;\n    }\n \n \n \n}\n \nint main()\n{\n \n    while(cin>>w>>h)\n    {\n        if(w==0 && h==0)\n        {\n            return 0;\n        }\n        else\n        {\n            solve();\n        }\n    }\n \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n \nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n    \n    g[y][x] = -1;\n    \n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n         \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            dfs(nx, ny);\n        }\n    }\n    return;\n}\n \nint main(){ \n    while(1){\n        int n, c, d, x, y;\n        flag = false;\n        g[101][101] = {};\n        \n        cin >> weight >> hight;\n \n        if(weight == 0 && hight == 0){\n            break;\n        }\n         \n        cin >> sx >> sy >> gx >> gy >> n;\n         \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n             \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n         \n        sc = g[sy][sx];\n        dfs(sx, sy);\n         \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\t\tint cx = p.second, cy = p.first;\n\n\t\tif (y == gy&&x == gx)break;\n\n\t\tREP(i, 4){\n\t\t\tint nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h){\n\t\t\t\tif (table[ny][nx] == table[cy][cx]\n\t\t\t\t\t&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[cy][cx] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve();\n\n\t\tif (dis[gy][gx] != INF&&table[sy][sx] != 0 && table[gy][gx] != 0)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 101;\n\nint maze[MAX][MAX];\nbool come[MAX][MAX];\nP s,g;\nint W,H,c;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  memset(maze,0,sizeof(maze));\n}\n\n\nvoid input_B(){\n  int n;\n  cin >> n;\n  while(n--){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d){\n      for(int i = y; i < y+4; i++)\n\tfor(int j = x; j < x+2; j++)\n\t  maze[i][j] = c;\n    }else{\n      for(int i = y; i < y+2; i++)\n\tfor(int j = x; j < x+4; j++)\n\t  maze[i][j] = c;\n    }\n  }\n}\n\n\nvoid solve(P p){\n  \n  if(come[p.second][p.first] == false){\n    come[p.second][p.first] = true;\n    for(int i = 0; i < 4; i++)\n      if(0 < p.first+dx[i] && p.first+dx[i] <= W &&\n\t 0 < p.second+dy[i] && p.second+dy[i] <= H &&\n\t maze[p.second][p.first] == c) solve(P(p.first+dx[i],p.second+dy[i]));\n  }\n}\n\nvoid print(){\n  for(int i = 1; i < H; i++){\n    for(int j = 1; j < W; j++)// cout << come[i][j];\n      cout << maze[i][j];\n    cout << endl;\n  }\n\n}\n\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    cin >> s.first >> s.second;\n    cin >> g.first >> g.second;\n    input_B();\n    c = maze[s.second][s.first];\n    solve(s);\n    //print();\n    if(come[g.second][g.first] && c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nstruct point{\n\tint x;\n\tint y;\n};\nint m[101][101];\nint w,h,r;\npoint gp;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gp.x)&&!(y-gp.y))r=1;\n\tif(x>0&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>0&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d;\n\t//spÍX^[gn_ÌÀWAgpÍS[n_ÌÀW\n\tpoint sp,bp;\n\t\n\twhile(1){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>w>>h;\n\t\tif(!w&&!h)return 0;\n\t\tstd::cin>>sp.x>>sp.y;\n\t\tstd::cin>>gp.x>>gp.y;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bp.x>>bp.y;\n\t\t\tint bw,bh;\n\t\t\td?bw=2,bh=4:bh=2,bw=4;\n\t\t\tfor(int y=bp.y;y<=bp.y+bh;y++){\n\t\t\t\tfor(int x=bp.x;x<=bp.x+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sp.x][sp.y])dfs(sp.x,sp.y,m[sp.x][sp.y]),m[sp.x][sp.y] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint dx[] = {0, 1, 0, 1}, dy[] = {0, 0, 1, 1};\nstruct P{ int x, y; };\nint main()\n{\n\tint w, h;\n\twhile(cin >> w >> h && (w || h))\n\t{\n\t\tvector<vint> field(w, vint(h, 0));\n\t\tP s, g;\n\t\tcin >> s.x >> s.y >> g.x >> g.y;\n\t\ts.x--, s.y--, g.x--, g.y--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i, n)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i]][y + dy[i]] = c;\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i] + 2 * !d][y + dy[i] + 2 * d] = c;\n\t\t}\n\n\t\t\n\t\tint c = field[s.x][s.y];\n\t\t/*\n\t\tif(!c || !field[g.x][g.y])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t*/\n\n\t\trep(i, h) rep(j, w)\n\t\t\tcout << field[j][i] << (j + 1 == w ? \"\\n\" : \" \");\n\n\t\tqueue<P> que;\n\t\tfor(que.push(s); !que.empty(); que.pop())\n\t\t{\n\t\t\tP p = que.front();\n\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tint nx = p.x + dx[i], ny = p.y + dy[i];\n\t\t\t\t\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[nx][ny] == c)\n\t\t\t\t{\n\t\t\t\t\tfield[nx][ny] = -1;\n\t\t\t\t\tP next; next.x = nx, next.y = ny;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (field[g.x][g.y] == -1? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\t\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][y]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][y]&&visited[x][y]=false;){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\nstatic const int dx[4] = {1, 0, -1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\n\nint w, h, sx, sy, gx, gy, G[MAX+2][MAX+2];\n \nbool dfs( int x, int y, int color ){\n    if ( color == 0 || G[x][y] != color ) return false;\n    if ( x == gx && y == gy ) return true;\n    G[x][y] = 0;\n    for ( int r = 0; r < 4; r++ ){\n\tif ( dfs(x + dx[r], y + dy[r], color) ) return true;\n    }\n    return false;\n}\n\nmain(){\n    int n, c, d, px, py, ww, hh;\n    while( cin >> w >> h && w ){\n\tcin >> sx >> sy >> gx >> gy >> n;\n\tfor ( int y = 0; y < h+2; y++ )\n\t    for ( int x = 0; x < w+2; x++ ) G[x][y] = 0;\n\tfor ( int i = 1; i <=n; i++ ){\n\t    cin >> c >> d >> px >> py;\n\t    if ( d == 0 ) { ww = 4; hh = 2; }\n\t    else { ww = 2; hh = 4; }\n\t    for ( int y = 0; y <= hh-1; y++ ){\n\t\tfor ( int x = 0; x <= ww-1; x++ ) {\n\t\t    G[px+x][py+y] = c;\n\t\t}\n\t    }\n\t}\n\tif ( dfs(sx, sy, G[sx][sy]) ) cout << \"OK\" << endl;\n\telse cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[110][110];\n\nvoid dfs(int x , int y , int w , int h , int xg , int yg , int c){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h ||board[tx][ty]!=c || board[tx][ty]==0 || b  ) continue;\n\t\tdfs( tx,ty,w,h,xg,yg,c);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs( xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint xs, ys;\nint xg, yg;\nint maze[102][102];\n\nusing P = pair<int, int>;\nvoid solve() {\n    int c = maze[ys][xs];\n    queue<P> que;\n    que.push(P(ys, xs));\n    set<P> visited;\n    visited.insert(P(ys, xs));\n    bool ok = false;\n    while (que.size()) {\n        auto p = que.front();\n        que.pop();\n        int y = p.first;\n        int x = p.second;\n        if (yg == y && xg == x) ok = true;\n        rep(k, 4) {\n            int ny = y + dy[k];\n            int nx = x + dx[k];\n            if (ny < 0 || nx < 0) continue;\n            if (h <= ny || w <= nx) continue;\n            if (maze[ny][nx] != c) continue;\n            if (visited.count(P(ny, nx))) continue;\n            visited.insert(P(ny, nx));\n            que.push(P(ny, nx));\n        }\n    }\n    cout << (ok ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        rep(i, 102) rep(j, 102) maze[i][j] = -1;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        xs--, ys--;\n        xg--, yg--;\n        int n;\n        cin >> n;\n        rep(_, n) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                rep(i, 2) rep(j, 4) maze[y + i][x + j] = c;\n            } else {\n                rep(i, 4) rep(j, 2) maze[y + i][x + j] = c;\n            }\n        }\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,a,n,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,false,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]){\n\t\t\tif(block(Y,X)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<stack>\nstruct p{\n\tint x;\n\tint y;\n};\nusing namespace std;\nint main(){\n\tint w,h,sx,sy,gx,gy,n,c,d,x,y,i,j,k,o;\n\tint map[100][100];\n\tint used[100][100];\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tp v,u;\n\tstack<p> s;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(used,0,sizeof(used));\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx--;\n\t\tsy--;\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tgx--;\n\t\tgy--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(!d){\n\t\t\t\tfor(j=y;j<y+2;j++){\n\t\t\t\t\tfor(k=x;k<x+4;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=y;j<y+4;j++){\n\t\t\t\t\tfor(k=x;k<x+2;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx]){\n\t\t\tprintf(\"NG\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tv.x=sx;\n\t\tv.y=sy;\n\t\ts.push(v);\n\t\to=0;\n\t\twhile(!s.empty()){\n\t\t\tv=s.top();\n\t\t\ts.pop();\n\t\t\tif(used[v.y][v.x]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tused[v.y][v.x]=1;\n\t\t\t}\n\t\t\tif(v.x==gx&&v.y==gy){\n\t\t\t\to=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(u.x>=0&&u.x<w&&u.y>=0&&u.y<h&&map[u.y][u.x]==map[sy][sx]){\n\t\t\t\t\ts.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint field[101][101],b[101][101],X,Y,n,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},I,sX,sY,gX,gY,ans=-1,sgc;\nint func(int x,int y){\n\tfor(I=0;I<4;I++){\n\t\tint xx=x+dx[I];\n\t\tint yy=y+dy[I];\n\t\tif(xx>0&&yy>0&&xx<=X&&yy<=Y&&field[xx][yy]==sgc&&b[xx][yy]==0){\n\t\t\tif(xx==gX&&yy==gY){\n\t\t\t\tif(ans==-1)ans=b[x][y];\n\t\t\t\telse ans=min(b[x][y]+1,ans);\n\t\t\t}\n\t\t\telse{\n\t\t\tb[xx][yy]=b[x][y]+1;\n\t\t\tfunc(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,i2,c,d,x,y;\n\tcin>>X>>Y;\n\twhile(X!=0){\n\t\tcin>>sX>>sY>>gX>>gY>>n;\n\t\tans=-1;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tc=0;\n\t\t\td=0;\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t\tfor(i2=1;i2<=100;i2++){\n\t\t\t\tfield[i][i2]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+2][y]=c;\n\t\t\t\tfield[x+3][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+2][y+1]=c;\n\t\t\t\tfield[x+3][y+1]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x][y+2]=c;\n\t\t\t\tfield[x][y+3]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+1][y+2]=c;\n\t\t\t\tfield[x+1][y+3]=c;\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++)cout<<field[i2][i];\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tsgc=field[sX][sY];\n\t\tfunc(sX,sY);\n\t\tif(ans==-1)cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\tcin>>X>>Y;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[101][101] = {{0},{0},};\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n    \n    while(true){\n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy >> n;\n            Solve s(w, h, sx, sy, gx, gy);\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\\n\";\n            }else{\n                cout << \"NG\\n\";\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar B[102][102];\nbool isOK = false;\nvoid setBlock(int c,int d,int x,int y){\n\tchar Cl = '\\0';\n\tswitch(c){\n\t\tcase 1:Cl='W';break;\n\t\tcase 2:Cl='Y';break;\n\t\tcase 3:Cl='G';break;\n\t\tcase 4:Cl='B';break;\n\t\tcase 5:Cl='R';break;\n\t}\n\tif(d == 0){\n\t\tfor(int i = x; i <= x+3;i++){\n\t\t\tfor(int  j = y;j <= y+1;j++){\n\t\t\t\tB[i][j] = Cl;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(int i = x; i <= x+1;i++){\n\t\t\tfor(int  j = y;j <= y+3;j++){\n\t\t\t\tB[i][j] = Cl;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Check(int x, int y,int xG,int yG,char c){\n\tif(B[x][y] != c || isOK){\n\t\treturn;\n\t}\n\tB[x][y] = '.';\n\tif(x == xG && y == yG){\n\t\tisOK=true;\n\t\treturn;\n\t}\t\n\tCheck(x  ,y-1,xG,yG,c);\n\tCheck(x+1,y  ,xG,yG,c);\n\tCheck(x  ,y+1,xG,yG,c);\n\tCheck(x-1,y  ,xG,yG,c);\n}\n\nint main(){\n\tint W,H,xS,yS,xG,yG,n;\n\twhile(cin >> W >> H){\n\t\tisOK=false;\n\t\tif(W == 0 && H == 0){\n\t\t\tbreak;\n\t\t}\n\t\tcin >> xS >> yS >> xG >> yG >> n;\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tsetBlock(c,d,x,y);\n\t\t}\n\t\tCheck(xS,yS,xG,yG,B[xS][yS]);\n\t\tif(isOK){\n\t\t\tcout << \"OK\\n\";\n\t\t}else{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nint maps[100][100];\nint color;\nint gy,gx,sy,sx;\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\nint muki[2][2]={\n  {2,4},\n  {4,2}\n};\n    \n  \n\nbool dfs(int y,int x);\n\nint main(){\n  int n;\n  int c,d,y,x;\n  while(cin >> w >> h,w | h){\n    memset(maps,-1,sizeof(maps));\n    cin >> sx >> sy >> gx >> gy;\n    sx--;sy--;gx--;gy--;\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n      cin >> c >> d >> x >> y;\n      for(int j = 0; j < muki[d][0]; j++){\n\tfor(int k = 0;k < muki[d][1]; k++){\n\t  maps[y - 1 + j][x - 1 + k] = c;\n\t  if(y - 1 + j == sy && x - 1 + k == sx){\n\t    color = maps[sy][sx] = c;\n\t  }\n\t}\n      }\n    }\n\n    /* for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tprintf(\"%3d\",maps[i][j]);\n      }\n      cout<<endl;\n      }*/\n\n    if(dfs(sy,sx))cout << \"OK\" << endl;\n    else cout << \"NO\" << endl;\n    \n    /*\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tprintf(\"%3d\",maps[i][j]);\n      }\n      cout<<endl;\n      }*/\n\n  }\n}\n\nbool dfs(int y,int x){\n  maps[y][x] = -1;\n  if(gy==y && gx==x){\n    return true;\n  }\n  bool b = false;\n  for(int i=0;i<4;i++){\n    int vy=y+dy[i];\n    int vx=x+dx[i];\n    if(vy >= 0 && vy < h && vx >= 0 && vx < w && maps[vy][vx] != -1 && maps[vy][vx] == color){\n      b = b | dfs(vy,vx);\n    }\n  }\n  return b;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int,int> pii;\n\nconst int margin = 2;\nint maze[128][128];\nbool visited[128][128];\nint h, w;\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tfor(int i = 0; i < 128; i++){\n\t\t\tfor(int j = 0; j < 128; j++) {\n\t\t\t\tmaze[i][j] = -1;\n\t\t\t\tvisited[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tpii s, g;\n\t\tcin >> s.x >> s.y; s.x--; s.y--;\n\t\tcin >> g.x >> g.y; g.x--; g.y--;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint c, d, x_, y_;\n\t\t\tint l[][2] = {{2,4},{4,2}};\n\t\t\tcin >> c >> d >> x_ >> y_; x_--; y_--;\n\t\t\tfor(int i = 0; i < l[d][0]; i++) {\n\t\t\t\tfor(int j = 0; j < l[d][1]; j++) {\n\t\t\t\t\tmaze[y_+i + margin][x_+j + margin] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pii> q;\n\t\tq.push(s);\n\t\tbool flg = false;\n\t\twhile(!q.empty()) {\n\t\t\tpii cur;\n\t\t\tcur = q.front(); q.pop();\n\n\t\t\tif(cur == g) {\n\t\t\t\tflg = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint dx[] = {1,-1,0,0};\n\t\t\tint dy[] = {0,0,1,-1};\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tif(maze[cur.y+margin][cur.x+margin] == maze[cur.y+dy[i]+margin][cur.x+dx[i]+margin] && !visited[cur.y+dy[i]+margin][cur.x+dx[i]+margin]) {\n\t\t\t\t\tq.push(pii(cur.x+dx[i], cur.y+dy[i]));\n\t\t\t\t\tvisited[cur.y+dy[i]+margin][cur.x+dx[i]+margin] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(flg)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -2;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=-1;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -2){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n        //c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint board[102][102];\nbool visited[102][102];\n\nint w, h, xg, yg;\n\nclass Point{\npublic:\n\tint x, y;\n\n\tPoint(int xx, int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n};\n\nconst int UNDEFINED = 0;\nbool judge(int, int);\nint main(void){\n\tconst int BLOCK_WIDTH = 2;\n\tconst int BLOCK_HEIGHT = 4;\n\n\tfor(int i = 0; i < 102; i ++)\n\t\tfor(int j = 0; j < 102; j ++){\n\t\t\tboard[i][j] = UNDEFINED;\n\t\t\tvisited[i][j] = false;\n\t\t}\t\n\tfor(int xs, ys, n; cin >> w >> h >> xs >> ys >> xg >> yg >> n, w, h;){\n\t\tfor(int i = 1; i <= w; i ++){\n\t\t\tfor(int j = 1; j <= h; j ++){\n\t\t\t\tboard[j][i] = UNDEFINED;\n\t\t\t\tvisited[j][i] = false;\n\t\t\t}\n\t\t}\n\n\t\twhile(n --){\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint width = (!d) ? BLOCK_HEIGHT:BLOCK_WIDTH;\n\t\t\tint height = (!d) ? BLOCK_WIDTH:BLOCK_HEIGHT;\n\n\t\t\tfor(int curX = x; curX <= x + width; curX ++)\n\t\t\t\tfor(int curY = y; curY <= y + height; curY ++)\n\t\t\t\t\tboard[curX][curY] = c;\n\t\t}\n\t\tcout << ((judge(xs, ys)) ? \"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n\nbool judge(int firstX, int firstY){\n\tqueue<Point> q; Point p(firstX, firstY);\n\tq.push(p);\n\tvisited[firstY][firstX] = true;\n\n\tint targetColor = board[firstY][firstX];\n\tif(targetColor == UNDEFINED) return false;\n\t\n\twhile(!q.empty()){\n\t\tif(visited[yg][xg]) return true;\n\t\tPoint currentNode = q.front(); q.pop();\n\n\t\tfor(int delta = -1; delta <= 1; delta += 2){\n\t\t\tfor(int a = 0; a < 2; a ++){\n\t\t\t\tPoint nextNode(currentNode.x + ((a)?delta:0), currentNode.y + ((a)?0:delta));\n\n\t\t\t\tif(!visited[nextNode.y][nextNode.x] && board[nextNode.y][nextNode.x] == targetColor){\n\t\t\t\t\tq.push(nextNode);\n\t\t\t\t\tvisited[nextNode.y][nextNode.x] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=1;i<=100;i++){     //Boardの初期化\n            for(int j=1;j<=100;j++)\n                Board[j][i] = -1;\n        }\n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h,f=0;\nvoid block(int ,int);\nint main()\n{\n\tint i,n,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,false,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]&&R!=0){\n\t\t\tblock(Y,X);\n\t\t\tif(f==1) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nvoid block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=true;\n\tif(ga==a&&gb==b) f=1;\n\t\tif(map[b][a+1]==R&&N[b][a+1]==false) block(b,a+1); //???\n\t\tif(map[b+1][a]==R&&N[b+1][a]==false) block(b+1,a); //???\n\t\tif(map[b][a-1]==R&&N[b][a-1]==false) block(b,a-1); //???\n\t\tif(map[b-1][a]==R&&N[b-1][a]==false) block(b-1,a); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nint W,H,sx,sy,gx,gy,color;\nint dx[8]={0,0,0,0,1,1,1,1},dy[8]={0,1,2,3,0,1,2,3},cx[4]={-1,0,0,1},cy[4]={0,-1,1,0};\nvvi field;\nvvb used;\n\nbool solve(int x,int y,int color,vvb& used){\n\tused[x][y]=1;\n\tif(x==gx&&y==gy) return 1;\n\tfor(int i=0;i<4;i++){\n\t\tint tmpx=x+cx[i],tmpy=y+cy[i];\n\t\tif(tmpx>=0&&tmpx<W&&tmpy>=0&&tmpy<H&&field[tmpx][tmpy]==color&&!used[tmpx][tmpy]){\n\t\t\tif(solve(tmpx,tmpy,color,used)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(!W) break;\n\t\tfield=vvi(W,vi(H));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\t\tint n;\n\t\tcin>>n;\n\t\tint c,d,x,y;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(d){\n\t\t\t\tfor(int i=0;i<8;i++) field[x+dx[i]][y+dy[i]]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<8;i++) field[x+dy[i]][y+dx[i]]=c;\n\t\t\t}\n\t\t}\n\t\tif(!field[sx][sy]) cout<<\"NG\"<<endl;\n\t\telse {\n\t\t\tint color=field[sx][sy];\n\t\t\tused=vvb(H,vb(W));\n\t\t\tif(solve(sx,sy,color,used)) cout<<\"OK\"<<endl;\n\t\t\telse cout<<\"NG\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 0207\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid maze_fill(vector<vector<int> > &maze, int c, int d, int x, int y){\n\tint w, h;\n\tif(d == 0){\n\t\tw = 4;\n\t\th = 2;\n\t}else{\n\t\tw = 2;\n\t\th = 4;\n\t}\n\n\tfor(int i=y;i<y+h;i++)\n\t\tfor(int j=x;j<x+w;j++)\n\t\t\tmaze[i][j] = c;\n}\n\nvoid search(vector<vector<int> > &maze, int x, int y, int c){\n\tmaze[y][x] = 6;\n\n\tif(maze[y-1][x] == c)\n\t\tsearch(maze, x, y-1, c);\n\t\n\tif(maze[y][x-1] == c)\n\t\tsearch(maze, x-1, y, c);\n\t\n\tif(maze[y+1][x] == c)\n\t\tsearch(maze, x, y+1, c);\n\t\n\tif(maze[y][x+1] == c)\n\t\tsearch(maze, x+1, y, c);\n}\n\nint main(){\n\twhile(1){\n\t\tint w, h, xs, ys, xg, yg, n;\n\t\tvector<vector<int> > maze;\n\n\t\tcin>>w>>h;\n\t\tif((w == 0) && (h == 0))\n\t\t\tbreak;\n\n\t\tmaze.resize(h+2);\n\t\tfor(int i=0;i<h+2;i++)\n\t\t\tmaze[i].resize(w+2);\n\n\t\tfor(int i=0;i<h+2;i++){\n\t\t\tif((i == 0) || (i == h+1)){\n\t\t\t\tfor(int j=0;j<w+2;j++)\n\t\t\t\t\tmaze[i][j] = 9;\n\t\t\t}else{\n\t\t\t\tmaze[i][0] = 9;\n\t\t\t\tmaze[i][w+1] = 9;\n\t\t\t\tfor(int j=1;j<w+1;j++)\n\t\t\t\t\tmaze[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin>>xs>>ys;\n\t\tcin>>xg>>yg;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tmaze_fill(maze, c, d, x, y);\n\t\t}\n\t\t\n\t\tsearch(maze, xs, ys, maze[ys][xs]);\n\n\t\tif(maze[ys][xs] == maze[yg][xg])\n\t\t\tcout<<\"OK\"<<endl;\n\t\telse\n\t\t\tcout<<\"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid put(int,int,int,int);\nvoid tansaku(int,int);\n\nconst int nashi=-1;\nconst int tootta=10;\n\nint field[102][102];\nint main(int argc,char* argv[]){\n\twhile(1){\n\t\tint x_size,y_size;\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tint n;\n\t\tscanf(\"%d %d\",&x_size,&y_size);\n\t\tif(x_size==0)\n\t\t\treturn 0;\n\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i=0;i<y_size+2;i++)\n\t\t\tfor(int j=0;j<x_size+2;j++)\n\t\t\t\tfield[i][j]=nashi;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tput(c,d,x,y);\n\t\t}\n\n\t\ttansaku(sx,sy);\n\t\tif(field[gy][gx]==tootta)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n}\n\nvoid put(int c,int d,int x,int y){\n\tconst int size[2][2]={{4,2},{2,4}};\n\tfor(int i=0;i<size[d][1];i++){\n\t\tfor(int j=0;j<size[d][0];j++){\n\t\t\tfield[y+i][x+j]=c;\n\t\t}\n\t}\n}\n\nvoid tansaku(int sx,int sy){\n\tint c=field[sy][sx];\n\tfield[sy][sx]=tootta;\n\tif(field[sy][sx-1]==c)\n\t\ttansaku(sx-1,sy);\n\tif(field[sy][sx+1]==c)\n\t\ttansaku(sx+1,sy);\n\tif(field[sy-1][sx]==c)\n\t\ttansaku(sx,sy-1);\n\tif(field[sy+1][sx]==c)\n\t\ttansaku(sx,sy+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h,f=0;\nvoid block(int ,int);\nint main()\n{\n\tint i,n,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,false,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]&&R!=0){\n\t\t\tblock(Y,X);\n\t\t\tif(f==1) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nvoid block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=true;\n\tif(ga==a&&gb==b) f=1;\n\t\tif(map[b][a+1]==R&&N[b][a+1]==false) block(b,a+1); //???\n\t\tif(map[b+1][a]==R&&N[b+1][a]==false) block(b+1,a); //???\n\t\tif(map[b][a-1]==R&&N[b][a-1]==false) block(b,a-1); //???\n\t\tif(map[b-1][a]==R&&N[b-1][a]==false) block(b-1,a); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<list>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { \nassert(b!=0);\nreturn a * inv(b);\n }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,-1,0,1 };\nstruct Node {\n\tNode(int a, int b, int c) {\n\t\ttime = a;\n\t\tx = b;\n\t\ty = c;\n\t}\n\tint time;\n\tint x;\n\tint y;\n};\nclass Compare {\npublic:\n\tbool operator()(const Node& l, const Node& r) {\n\t\treturn l.time < r.time;\n\t}\n};\n\n\nint main() {\n\twhile(1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w)return 0;\n\t\tvector<vector<int>> maze(h+2, vector<int>(w+2,0));\n\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d) {\n\t\t\t\tfor (int ax = 0; ax < 4; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\tmaze[y+ay][x+ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 4; ++ay) {\n\t\t\t\t\t\tmaze[y + ay][x + ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint color = maze[ys][xs];\n\t\tif (!color) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<vector<bool>>times(h, vector<bool>(w, false));\n\n\t\tpriority_queue<Node,vector<Node>,Compare> qu;\n\t\t qu.emplace(0,xs,ys);\n\t\t bool flag=false;\n\t\twhile (!qu.empty()) {\n\t\t\tNode an(qu.top());\n\t\t\tqu.pop();\n\t\t\tif (an.x == xg&&an.y == yg) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tif (maze[an.y + dy[i]][an.x + dx[i]] == color) {\n\t\t\t\t\t\tif (times[an.y + dy[i]][an.x + dx[i]]) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tqu.push(Node{ an.time + 1,an.x + dx[i], an.y + dy[i] });\n\t\t\t\t\t\t\ttimes[an.y + dy[i]][an.x + dx[i]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"OK\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<h;i++){\n\t\t\tfor(j=1;j<w;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tif(brock[ys][xs]!=brock[yg][xg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[ys][xs];\n\t\t\tds[ys][xs]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==yg&&ba.b==xg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[yg][xg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=h&&ba.b+q[i]>0&&ba.b+q[i]<=w&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\t\tint cx = p.second, cy = p.first;\n\n\t\tif (y == gy&&x == gx)break;\n\n\t\tREP(i, 4){\n\t\t\tint nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h){\n\t\t\t\tif (table[ny][nx] == table[cy][cx]\n\t\t\t\t\t&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[cy][cx] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsolve();\n\n\t\tif (dis[gy][gx] != INF&&table[sy][sx] != 0 && table[gy][gx] != 0)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}\n\n//REP(i, h){\n//\tREP(j, w){\n//\t\tcout << table[i][j] << \" \";\n//\t}\n//\tcout << endl;\n//}\n//cout << \"!\" << endl;\n//solve();\n//REP(i, h){\n//\tREP(j, w){\n//\t\tcout << dis[i][j] << \" \";\n//\t}\n//\tcout << endl;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[101][101];\n\nint DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='w'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_Y(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='y'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_G(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='g'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\nint DFS_B(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='b'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n  int DFS_R(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='r'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n\nint main(){\n  int c[5];\n  int d[1];\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  int x[n];\n  int y[n];\n  cin>>w>>h;\n  while(w!=0){\n    int a=0;\n    int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n        int a=0;\n        int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      cnt=DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      cnt=DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      cnt=DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      cnt=DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      cnt=DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nbool dfs(int ys,int xs,int yg,int xg,int c){\n  if(f[ys][xs]!=c)return 0;\n\n  if(ys==yg && xs==xg)return 1;;\n\n  f[ys][xs]=0;\n\n  bool flag=0;\n  flag += dfs(ys+1,xs,yg,xg,c);\n  flag += dfs(ys-1,xs,yg,xg,c);\n  flag += dfs(ys,xs+1,yg,xg,c);\n  flag += dfs(ys,xs-1,yg,xg,c);\n  return flag;\n}\n\nvoid set(int c,bool d,int x,int y){\n  if(d==0){\n    for(int i=0; i<4; i++){\n      f[y][x+i]=c;\n      f[y+1][x+i]=c;\n    }\n  }else if(d==1){\n    for(int i=0; i<4; i++){\n      f[y+i][x]=c;\n      f[y+i][x+1]=c;\n    }\n  }\n}\n;\nint main(){\n  while(1){\n\n  int w,h;\n  cin >> w >> h;\n  if(w==0 && h==0)break;\n\n  int xs,ys;\n  cin >> xs >> ys;\n  int xg,yg;\n  cin >> xg >> yg;\n  int n;\n  cin >> n;\n\n  for(int i=0; i<n; i++){\n    bool d;\n    int c,x,y;\n    cin >> c >> d >> x >> y;\n    set(c,d,x,y);\n  }\n\n  if(dfs(ys,xs,yg,xg,f[ys][xs])){\n    cout << \"OK\\n\";\n  }else{\n    cout << \"NG\\n\";\n  }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint show=0;\nint w,h,sx,sy,gx,gy,d[101][101],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<y+2+di*2;j++)for(int k=x;k<x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tbfs();\n\t\tif(show)for(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(field[i][j])cout<<field[i][j];else cout<<\" \";}cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint W, H, sx, sy, gx, gy, N, c, d, x, y, r[111][111], vis[111][111];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint main() {\n\twhile(cin >> W >> H, W | H) {\n\t\tcin >> sx >> sy >> gx >> gy; sx--, sy--, gx--, gy--;\n\t\tmemset(r, 0, sizeof(r));\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\t\t\tint zx = (d ? 2 : 4), zy = (d ? 4 : 2);\n\t\t\tfor(int j = 0; j < zy; j++) {\n\t\t\t\tfor(int k = 0; k < zx; k++) {\n\t\t\t\t\tr[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis)); vis[sy][sx] = 1;\n\t\tqueue<pair<int, int> > que; que.push(make_pair(sx, sy));\n\t\twhile(!que.empty()) {\n\t\t\tpair<int, int> v = que.front(); que.pop();\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint tx = v.first + dx[i], ty = v.second + dy[i];\n\t\t\t\tif(0 <= tx && tx < W && 0 <= ty && ty < H && !vis[ty][tx] && r[ty][tx] == r[v.second][v.first]) {\n\t\t\t\t\tvis[ty][tx] = 1;\n\t\t\t\t\tque.push(make_pair(ty, tx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (vis[gy][gx] ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nbool ans;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\t\tint cx = p.second, cy = p.first;\n\n\t\tif (y == gy&&x == gx)break;\n\n\t\tREP(i, 4){\n\t\t\tint nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif (nx >= 1 && nx <= w&&ny >= 1 && ny <= h){\n\t\t\t\tif (table[ny][nx] == table[cy][cx]\n\t\t\t\t\t&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[cy][cx] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tans = 0;\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tdis[sy][sx] = 1;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//REP(i, h){\n\t\t//\tREP(j, w){\n\t\t//\t\tcout << table[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << \"!\" << endl;\n\t\t//solve();\n\t\t//REP(i, h){\n\t\t//\tREP(j, w){\n\t\t//\t\tcout << dis[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tif (dis[gy][gx] != INF&&table[sy][sx] != 0 && table[gy][gx] != 0)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  if(w == 0 && h == 0)\n    break;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }\n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nvoid Showboard(int w, int h){\n    for(int i=1;i<=h;i++){\n        for(int j=0;j<=w;j++)\n            cout << Board[i][j] << \"\";\n        cout << endl;\n    }\n    cout << endl;\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=1;i<=100;i++){     //Boardの初期化\n            for(int j=1;j<=100;j++)\n                Board[j][i] = -1;\n        }\n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        Showboard(w, h);\n\n        DFS(Board[xs][ys], xs, ys);\n\n        Showboard(w, h);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 102\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid input_data(void);  //データ入力用関数\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\nvoid clear(void);       //データの初期化\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0)break; //ループ終了条件\n\n    input_data();\n\n    make_mass();\n\n    solve();\n\n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",mass[i][j]);\n      }\n      printf(\"     \");\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",data[i][j]);\n      }\n      printf(\"\\n\");\n  }\n  }\n\n  return 0;\n}\nvoid input_data(void){\n\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n\n    cin>>n;\n\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n\n    }\n\n    return;\n}\nvoid make_mass(void){\n\n  int i,j;\n  int scolor,fcolor;\n\n    /*マスの作成*/\n    for(i=0;i<n;i++){\n\tswitch(d[i]){\n\tcase 0:              //横向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]][x[i]+j]=c[i];\n\t    mass[y[i]+1][x[i]+j]=c[i];\n\t  }\n\t  break;\n\tcase 1:              //縦向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]+j][x[i]]=c[i];\n\t    mass[y[i]+j][x[i]+1]=c[i];\n\t  }\n\t  break;\n\t}\n      }\n\n    scolor=mass[sx][sy];\n    fcolor=mass[gx][gy];\n\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(scolor!=mass[i][j]){\n\t    mass[i][j]=0;\n\t  }\n\t}\n      }\n\n    return;\n}\nvoid solve(void){\n\n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n\n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n\n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n        c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(Y>0 && X>0){\n\t\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n\t\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n\t\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n\t\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    switch(d[i]){\n    case 0:              //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n      break;\n    case 1:              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n      break;\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[x+1][y+1]=c;\n             F[x+2][y+1]=c;\n             F[x+3][y+1]=c;\n             F[x+4][y+1]=c;  \n             F[x+1][y+2]=c;\n             F[x+2][y+2]=c;\n             F[x+3][y+2]=c;\n             F[x+4][y+2]=c;   \n         }\n         if(d==1){\n             F[x+1][y+1]=c;\n             F[x+1][y+2]=c;\n             F[x+1][y+3]=c;\n             F[x+1][y+4]=c;  \n             F[x+2][y+1]=c;\n             F[x+2][y+2]=c;\n             F[x+2][y+3]=c;\n             F[x+2][y+4]=c;   \n         }\n      }\n      DFS(xs+1,ys+1,c);\n      if(F[xg+1][yg+1]==6)\n         cout << \"OK\" << endl;\n      else\n         cout << \"NG\" << endl;\n      for(int i=1;i<=w;i++)\n         for(int j=1;j<=h;j++)\n            F[i][j]=0;\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color && count == 0){\n\t\tif(x == xg && y == yg){\n\t\t\tcount = 1;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\nusing namespace std;\nint fx[4]={1,-1,0,0},fy[4]={0,0,1,-1};\nint main(void)\n{\n\tint **board;\n\tint bx,by;\n\tint sx,sy;\n\tint gx,gy;\n\tint bnum;\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&bx,&by);\n\t\tif(bx==0&&by==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tboard=new int*[by];\n\t\tfor(int f1=0;f1<by;f1++)\n\t\t{\n\t\t\tboard[f1]=new int[bx];\n\t\t\tfor(int f2=0;f2<bx;f2++)\n\t\t\t{\n\t\t\t\tboard[f1][f2]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tscanf(\"%d\",&bnum);\n\t\tfor(int f1=0;f1<bnum;f1++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tx--;y--;\n\t\t\tif(!d)\n\t\t\t{\n\t\t\t\tfor(int f2=0;f2<2;f2++)\n\t\t\t\t{\n\t\t\t\t\tfor(int f3=0;f3<4;f3++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[y+f2][x+f3]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int f2=0;f2<4;f2++)\n\t\t\t\t{\n\t\t\t\t\tfor(int f3=0;f3<2;f3++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[y+f2][x+f3]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int f1=0;f1<by;f1++)\n\t\t{\n\t\t\tfor(int f2=0;f2<bx;f2++)\n\t\t\t{\n\t\t\t\tprintf(\"%d\",board[f1][f2]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tint st_col=board[sy-1][sx-1];\n\t\tint gl_col=board[gy-1][gx-1];\n\t\tif(st_col!=gl_col||st_col==0||gl_col==0)\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t\tdelete []board;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<pair<int,int> > que;\n\t\tque.push(make_pair(sy,sx));\n\t\tint flg=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tpair<int,int> buf=que.front();que.pop();\n\t\t\tif(buf.first==gy-1&&buf.second==gx-1)\n\t\t\t{\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\t\tdelete []board;\n\t\t\t\tflg=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tboard[buf.first][buf.second]=9;\n\t\t\tfor(int f1=0;f1<4;f1++)\n\t\t\t{\n\t\t\t\tif(buf.first+fy[f1]>=0&&buf.first+fy[f1]<by&&\n\t\t\t\t\tbuf.second+fx[f1]>=0&&buf.second+fx[f1]<bx)\n\t\t\t\t{\n\t\t\t\t\tif(board[buf.first+fy[f1]][buf.second+fx[f1]]==st_col)\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(make_pair(buf.first+fy[f1],buf.second+fx[f1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"NG\\n\");\n\t\t/*\n\t\tfor(int f1=0;f1<by;f1++)\n\t\t{\n\t\t\tfor(int f2=0;f2<bx;f2++)\n\t\t\t{\n\t\t\t\tprintf(\"%d\",board[f1][f2]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tdelete []board;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass Point{\npublic:\n\tPoint() : x(0), y(0){}\n\tPoint(int ax, int ay) : x(ax), y(ay){}\n\tint x, y;\n};\n\nint field[100][100] = {0};\nbool checked[100][100] = {0};\nint w, h, n;\nPoint s, g;\n\nconst Point dire4[4] = {Point(-1, 0), Point(1, 0), Point(0, -1), Point(0, 1)};\n\nbool isEnabled(int x, int y){\n\treturn (0 <= x && x < w && 0 <= y && y < h);\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\t\n\t\tfor(int y = 0;y < h;y++){\n\t\t\tfor(int x = 0;x < w;x++){\n\t\t\t\tfield[x][y] = 0;\n\t\t\t\tchecked[x][y] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> s.x >> s.y >> g.x >> g.y >> n;\n\t\ts.x--; s.y--; g.x--; g.y--;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tint tw = ((d == 0)? 4 : 2), th = ((d == 0)? 2 : 4);\n\t\t\tfor(int iy = 0;iy < th;iy++){\n\t\t\t\tfor(int ix = 0;ix < tw;ix++){\n\t\t\t\t\tfield[x + ix][y + iy] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool res = false;\n\t\t\n\t\tqueue<Point> que;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tPoint p = que.front();\n\t\t\tque.pop();\n\t\t\tif(p.x == g.x && p.y == g.y){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint x = p.x + dire4[i].x, y = p.y + dire4[i].y;\n\t\t\t\tif(isEnabled(x, y) && field[p.x][p.y] == field[x][y] && !checked[x][y]){\n\t\t\t\t\tque.push(Point(x, y));\n\t\t\t\t\tchecked[x][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(res) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\nbool is_goal = false;\n#define START 20\n#define GOAL 30\n\nvoid DFS(int h,int w,int c){\n\n  if(!is_goal){\n\n    if(Array[h][w] == GOAL){\n      is_goal = true;\n      return;\n    }\n\n    if(Array[h][w] != c || Array[h][w] == 0){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 0;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n  }\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n      is_goal = false;\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n\n      cin >> Goal[0] >> Goal[1];\n\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n            //cout << i << \" \" << j << endl;\n          }\n        }\n      }\n      Array[Goal[0]][Goal[1]] = GOAL;\n      /*for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          cout << Array[i][j];\n        }\n        cout << endl;\n      }*/\n\n      DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n\n      if(is_goal){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<list>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { \nassert(b!=0);\nreturn a * inv(b);\n }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,-1,0,1 };\nstruct Node {\n\tNode(int a, int b, int c) {\n\t\tatime = a;\n\t\tx = b;\n\t\ty = c;\n\t}\n\tint atime;\n\tint x;\n\tint y;\n};\nclass Compare {\npublic:\n\tbool operator()(const Node& l, const Node& r) {\n\t\treturn l.atime < r.atime;\n\t}\n};\n\n\nint main() {\n\twhile(1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w)return 0;\n\t\tvector<vector<int>> maze(w+h+2, vector<int>(w+h+2,0));\n\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d) {\n\t\t\t\tfor (int ax = 0; ax < 4; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\tmaze[y+ay][x+ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 4; ++ay) {\n\t\t\t\t\t\tmaze[y + ay][x + ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < maze.size(); ++i) {\n\t\t\tfor (int j = 0; j < maze[0].size(); ++j) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint color = maze[ys][xs];\n\t\tif (!color||color!=maze[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<bool>>times(h, vector<bool>(w, false));\n\n\t\tpriority_queue<Node,vector<Node>,Compare> qu;\n\t\t qu.emplace(0,xs,ys);\n\t\t bool flag=false;\n\t\twhile (!qu.empty()) {\n\t\t\tNode an(qu.top());\n\t\t\tqu.pop();\n\t\t\tif (an.x == xg&&an.y == yg) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tif (maze[an.y + dy[i]][an.x + dx[i]] == color) {\n\t\t\t\t\t\tif (times[an.y + dy[i]][an.x + dx[i]]) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tqu.push(Node{ an.atime + 1,an.x + dx[i], an.y + dy[i] });\n\t\t\t\t\t\t\ttimes[an.y + dy[i]][an.x + dx[i]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"OK\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\n\nint field[100][100];\nint pathToGoal[100][100];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint dfs(int x, int y, int goalX, int goalY, int color) {\n    pathToGoal[y][x] = 1;\n    if (x == goalX && y == goalY) {\n        return 1;\n    }\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < w && 0 <= ny && ny < h && pathToGoal[ny][nx] == -1 && field[ny][nx] == color) {\n            res += dfs(nx, ny, goalX, goalY, color);\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            return 0;\n        }\n\n        for (int i = 0; i < 100; ++i) {\n            for (int j = 0; j < 100; ++j) {\n                field[i][j] = -1;\n                pathToGoal[i][j] = -1;\n            }\n        }\n\n        int xs, ys;\n        int xg, yg;\n        int n;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        xs--;\n        ys--;\n        xg--;\n        yg--;\n        for (int i = 0; i < n; ++i) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--;\n            y--;\n            if (d == 0) {\n                for (int p = 0; p < 2; ++p) {\n                    for (int q = 0; q < 4; ++q) {\n                        field[y + p][x + q] = c;\n                    }\n                }\n            }\n            else {\n                for (int p = 0; p < 4; ++p) {\n                    for (int q = 0; q < 2; ++q) {\n                        field[y + p][x + q] = c;\n                    }\n                }\n            }\n        }\n\n        if (dfs(xs, ys, xg, yg, field[xs][ys]) > 0) {\n            cout << \"OK\" << endl;\n        }\n        else {\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    goal=0;\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==0 && h==0)break;\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    else if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  if(scolor==mass[gy][gx]){\n  \n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n  }\n  else {\n    cout<<\"NG\"<<endl;\n  }\n\n  }\n  \n  return 0;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint needleX[4]={0,1,0,-1};\nint needleY[4]={1,0,-1,0};\n\nbool dfs(int x,int y,int xg,int yg,vector<vector<bool> > &map){\n  if(x==xg && y==yg) return true;\n\n  map[x][y]=false;\n\n  for(int i=0;i<4;i++){\n    int nextx=needleX[i]+x;\n    int nexty=needleY[i]+y;\n\n    if(map[nextx][nexty]){\n      bool flag=dfs(nextx,nexty,xg,yg,map);\n      if(flag) return true;\n    }\n  }\n  return false;\n    \n}\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W==0 && H==0)break;\n        \n        int xs,ys,xg,yg;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        int n;\n        cin >> n;\n        vector<vector<int> > cmap(W+2,vector<int>(H+2,0));\n\tvector<vector<bool> > map(W+2,vector<bool>(H+2,false));\n\n\tfor(int i=0;i<n;i++){\n\t  int color,d,x,y;\n\t  cin >> color >> d >> x >> y;\n\t  for(int j=0;j<2;j++){\n            for(int k=0;k<4;k++){\n\t      if(d==1)cmap[x+j][y+k]=color;\n\t      else cmap[x+k][y+j]=color;\n\t    }\n\t  }\n\t}\n\t/*\n\tfor(int i=0;i<W+2;i++){\n\t  for(int j=0;j<H+2;j++){\n\t    cout << \" \" << cmap[i][j];\n\t  }\n\t  cout << endl;\n\t} \n\t*/ \n        int c=cmap[xs][ys];\n\tfor(int i=1;i<=W;i++){\n\t  for(int j=1;j<=H;j++){\n\t    if(cmap[i][j]==c)map[i][j]=true;\n\t  }\n\t}\n\tif(!(map[xs][ys] && map[xg][yg])){\n\t  cout << \"NG\" << endl;\n\t  return 0;\n\t}\n\t/*\n\tfor(int i=0;i<W+2;i++){\n\t  for(int j=0;j<H+2;j++){\n\t    if(map[i][j])cout << \".\";\n\t    else cout << \"#\";\n\t  }\n\t  cout << endl;\n\t}\n\tcout << endl;\n\t*/\n        bool flag=dfs(xs,ys,xg,yg,map);\n        if(flag) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\t\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nvoid fun(int y,int x){\n    if(map[y][x]==map[ys][xs]){\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y+1][x+1]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+2);\n    fun(y,x-2);\n    fun(y+2,x);\n    fun(y-2,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        if(map[ys][xs]==0||map[yg][xg]==0);\n        else\n        \tfun(ys,xs);\n        for(int i=1;i<w;i++){\n        \tfor(int j=1;j<h;j++){\n        \t\tcout << map[i][j];\n        \t}\n        \tcout << endl;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nint w,h;\nint xs,ys,xg,yg;\nint data[150][150];\nbool searched[150][150];\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nbool ans;\nbool dfs(int x, int y,int col){\n\t// cout << x << \" \" << y << endl;\n\tsearched[x][y] = true;\n\tif(x == xg && y == yg){\n\t\tans = true;\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= h || ny >= w) continue;\n\t\tif(data[nx][ny] == col && searched[nx][ny] == false) dfs(nx,ny,col);\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tREP(i,150) REP(j,150) data[i][j] = 0;\n\t\tREP(i,150) REP(j,150) searched[i][j] = false;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tswap(xs,ys);\n\t\tswap(xg,yg);\n\t\tint n;\n\t\tcin >> n;\n\t\tREP(i,n){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tswap(x,y);\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,4){\n\t\t\t\t\tREP(k,2){\n\t\t\t\t\t\tdata[x+k][y+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tREP(j,2){\n\t\t\t\t\tREP(k,4){\n\t\t\t\t\t\tdata[x+k][y+j] = c;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout << endl;\n\t\t// REP(i,20){\n\t\t// \tREP(j,20) cout << data[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\t\tans = false;\n\t\tif(dfs(xs,ys,data[xs][ys])) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define rep2(i, n) for(int i = 1; i <= n; ++i)\n#define INF 0\n#define MAX 102\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n \nint field[102][102];\nint h, w, sx, sy, gx, gy, n;\nint col, dire, x, y;\nint scol;\n\nbool dfs(int nx, int ny) {\n\tif(nx == gx && ny == gy) return true;\n\tfield[nx][ny] = -1;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tint nex = nx + dx[i];\n\t\tint ney = ny + dy[i];\n\t\tif(0 < nex && nex <= w && 0 < ney && ney <= h && scol == field[nex][ney]) {\n\t\t\tif(dfs(nex, ney)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(1) {\n\t\tscol = INF;\n\t\tcin >> h >> w;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tfor(int j = 1; j <= w; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif(h == 0 && w == 0) break;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(k, n) {\n\t\t\tcin >> col >> dire >> x >> y;\n\t\t\tif(dire == 1) {\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\tfor(int j = 0; j < 2; ++j) field[x+j][y+i] = col;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\t\t\tfor(int j = 0; j < 4; ++j) field[x+j][y+i] = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscol = field[sx][sy];\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define dr direction\n#define cl color\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nclass Block{\npublic:\n    int color;// 1~5\n    int direction;// 0:-, 1:|\n    int x, y;\n    void init(int c, int d, int xx, int yy);\n};\n\nvoid Block::init(int c, int d, int xx, int yy){\n    color=c;\n    direction=d;\n    x=xx;\n    y=yy;\n}\n\nint w, h, xs, ys, xg, yg, n;\nint fld[100][100], dis[100][100];\nconst pii dxdy[]={{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nconst int inf=1e8;\n\nstring solve(){// bfs\n    queue<pii> qu;\n    qu.push(make_pair(ys, xs));\n    int C=fld[ys][xs];\n    fill(dis[0], dis[100], inf);\n    dis[ys][xs]=0;\n\n    if(C==0) return \"NO\";\n    while(!qu.empty()){\n        pii now=qu.front(); qu.pop();\n        if(now.fi==yg&&now.se==xg){\n            return \"OK\";\n        }\n\n        for(int k=0; k<4; k++){\n            pii nx=make_pair(now.fi+dxdy[k].fi, now.se+dxdy[k].se);\n            if(!(0<=nx.fi&&nx.fi<h&&0<=nx.se&&nx.se<w)) continue;\n            if(fld[nx.fi][nx.se]!=C) continue;\n            if(dis[nx.fi][nx.se]!=inf) continue;\n\n            dis[nx.fi][nx.se]=dis[now.fi][now.se]+1;\n            qu.push(nx);\n        }\n    }\n\n    return \"NO\";\n}\n\nint main(){\n\n    while(1){\n        cin>> w>> h;\n        if(w==0&&h==0) break;\n        cin>> xs>> ys>> xg>> yg>> n;\n        xs--; ys--; xg--; yg--;\n        Block block[n];\n        for(int i=0; i<n; i++){\n            int c, d, xx, yy;\n            cin>> c>> d>> xx>> yy;\n            xx--; yy--;\n            block[i].init(c, d, xx, yy);\n        }\n\n        // make field\n        for(int k=0; k<n; k++){\n            int X=block[k].x, Y=block[k].y;\n            if(block[k].dr==0){\n                for(int i=0; i<2; i++){\n                    for(int j=0; j<4; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }else{\n                for(int i=0; i<4; i++){\n                    for(int j=0; j<2; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }\n        }\n//*\n        for(int i=0; i<w; i++){\n            for(int j=0; j<h; j++){\n                cout<< fld[i][j]<<\" \";\n            }\n            cout<< endl;\n        }\n//*/\n        cout<< solve()<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[101][101]={0},v[101][101]={0};\nint root(int x,int y,int vmap[][101]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\t\tfor(int e=y;e<y+2;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int e=y;e<y+4;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int i1=0;i1<101;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,c,d,x,y,nok,sc;\nint fld[101][101];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||nok==1||fx<0||fx>w-1||fy<0||fy>h-1)return;\n    if(fx==xg-1&&fy==yg-1){\n        if(sc==fld[fy][fx])nok=1;\n    }\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        nok=0;\n        fill(fld[0],fld[0]+101*101,0);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[ys-1][xs-1];\n        /*for(int j=0;j<h;j++){\n            for(int k=0;k<w;k++){\n                cout<<fld[j][k];\n            }\n            cout<<endl;\n        }*/\n        dfs(0,0);\n        if(nok==1)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n  cin >> w >> h;\n  if(w == 0 && h == 0)\n    break;\n\n  cin >> xs >> ys >> xg >> yg >> n;\n  \n   for(int y=0; y<=h; y++){\n     for(int x=0; x<=w; x++){\n   F[y][x] = 0;\n     }\n   }\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n    if (d == 0)//yokonaga\n    {\n        loop(i, 2)\n        {\n            loop(j, 4)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n    else//tatenaga\n    {\n        loop(i, 4)\n        {\n            loop(j, 2)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n}\n    bool a=false;\nbool dfs(int nx, int ny)\n{\n    if (nx == gx&&ny == gy)return true;\n    if (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n    grid_visited[nx][ny] = true;\n    if((nx+1) >= 0 && ny >= 0 && (nx+1) < h && ny < w)if(grid[nx + 1][ny]== grid[nx][ny])a|=dfs(nx + 1, ny);\n    if(nx >= 0 && (ny+1) >= 0 && nx < h && (ny+1) < w)if(grid[nx][ny+1]== grid[nx][ny])a|=dfs(nx, ny+1);\n    if((nx-1) >= 0 && ny >= 0 && (nx-1) < h && ny < w)if(grid[nx - 1][ny]== grid[nx][ny])a|=dfs(nx - 1, ny);\n    if(nx >= 0 && (ny-1) >= 0 && nx < h && (ny-1) < w)if(grid[nx][ny-1]== grid[nx][ny])a|=dfs(nx, ny-1);\n    //return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n    return a;\n    return false;\n}\nint main()\n{\n    while (1)\n    {\n        cin >> w >> h;\n        if (!w && !h) break;\n        else\n        {\n            cin >> sx >> sy >> gx >> gy >> n;\n            sx--; sy--; gx--; gy--;\n            loop(i, n)\n            {\n                int c, d, x, y;\n                cin >> c >> d >> x >> y;\n                x--; y--;\n                input(c, d, x, y);\n            }\n            /*loop(i, h)\n            {\n                loop(j, w)\n                {\n                    cout << grid[i][j] << \" \";\n                }\n                cout << endl;\n            }*/\n            a=false;\n            \n            cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n// #define int long long\n#define pb push_back\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\n \ntemplate <class X> void print(X Target){ cout << Target << '\\n'; }\n\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint w, h;\nint xs, ys, xg, yg;\nint mp[128][128];\nbool check[128][128];\n\nvoid dfs(int y, int x, int color)\n{\n  if (x < 1 || x > w || y < 1 || y > h) return;\n  if (check[y][x]) return;\n  check[y][x] = true;\n  for (int i = 0; i < 4; i++){\n    if (mp[y + dy[i]][x + dx[i]] == color){\n      dfs(y + dy[i], x + dx[i], color);\n    }\n  }\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  int n;\n\n  while (cin >> w >> h, w || h){\n    memset(check, false, sizeof(check));\n    memset(mp, 0, sizeof(mp));\n    cin >> xs >> ys >> xg >> yg >> n;\n    for (int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      if (d){\n        for (int j = 0; j < 4; j++){\n          for (int k = 0; k < 2; k++){\n            mp[y + j][x + k] = c;\n          }\n        }\n      }\n      else {\n        for (int j = 0; j < 2; j++){\n          for (int k = 0; k < 4; k++){\n            mp[y + j][x + k] = c;\n          }\n        }\n      }\n    }\n    dfs(ys, xs, mp[ys][xs]);\n    (check[yg][xg]) ? print(\"OK\") : print(\"NG\");\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint i,j;\nint a[105][105];\nint used[105][105];\nint h,w;\n\nvoid search(int y,int x,int c){\n  if(x<0 || y<0 || y>=h || x>=w || a[y][x]!=c)return;\n  if(used[y][x])return;\n  used[y][x]++;\n  int i;\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  rep(i,4)\n    search(y+dy[i],x+dx[i],c);\n  return;\n}\nint main(void) {\n  while(1){\n    cin>>h>>w;\n    if(h==0 && w==0)break;\n    rep(i,h)rep(j,w)used[i][j]=0;\n    int xs,ys,xg,yg,n;\n    cin>>xs>>ys;\n    xs--;ys--;\n    cin>>xg>>yg;\n    xg--;yg--;\n    cin>>n;\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      int p[8]={0,0,0,0,1,1,1,1};\n      int q[8]={0,1,2,3,0,1,2,3};\n      if(d)\n        rep(j,8)\n          a[y+q[j]][x+p[j]]=c;\n      else\n        rep(j,8)\n          a[y+p[j]][x+q[j]]=c;\n    }\n    if(a[ys][xs]==0){\n      cout<<\"NG\"<<endl;\n      continue;\n    }\n    search(ys,xs,a[ys][xs]);//dfs                         \n    if(used[yg][xg])\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[101][101]={},sx,sy,gx,gy;\nint f(int i,int j){\n\tif(i==gy && j==gx)\n\t\treturn 1;\n\tif(a[i+1][j]==a[sy][sx])\n\t\tif(f(i+1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j+1]==a[sy][sx])\n\t\tif(f(i,j+1)==1)\n\t\t\treturn 1;\n\tif(a[i-1][j]==a[sx][sy])\n\t\tif(f(i-1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j-1]==a[sx][sy])\n\t\tif(f(i,j-1)==1)\n\t\t\treturn 1;\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint w,h,n,c,d,x,y;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)\n\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\ta[i][j]=0;\n\t\tcin>>sx>>sy;\n\t\tcin>>gx>>gy;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t}\n\t\tif(a[sx][sy]!=a[gx][gy])\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sy,sx)==0)\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sx,sy)==1)\n\t\tcout<<\"OK\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a[102][102],color;\n\nvoid dfs(int x,int y){\n   \n    a[y][x] = 9;\n    \n    if(a[y+1][x] == color){\n      dfs(x,y+1);\n    }\n    if(a[y][x+1] == color){\n      dfs(x+1,y);\n    }\n    if(a[y-1][x] == color){\n      dfs(x,y-1);\n    } \n    if(a[y][x-1] == color){\n      dfs(x-1,y);\n    }\n \n} \n\nint main(){\n\n  int xs,ys,xg,yg,n,c,d,x,y,w,h;\n\n  while(1){\n  \n    cin >>w>>h;\n    \n    if(w == 0 && h == 0)break;\n\n    for(int i = 0 ; i < 102 ; i++){\n      for(int j = 0 ; j < 102 ; j++){\n\ta[i][j]=0;\n      }\n    }\n\n    cin >>xs>>ys;\n    cin >>xg>>yg;\n\n    cin >>n;\n\n    for(int i = 0 ; i < n ; i++){\n      \n      cin >> c >> d >> x >> y;\n      \n      if( d == 0 ){\n\tfor(int i = 0 ; i < 2 ; i++){\n\t  for(int j = 0 ; j < 4 ; j++){\n\t    a[i+y][j+x] = c;\n\t  }\n\t}\n      }else{\n\tfor(int i = 0 ; i < 4 ; i++){\n\t  for(int j = 0 ; j < 2 ; j++){\n\t    a[i+y][j+x] = c;\n\t  }\n\t}\n      }\n    \n    }\n    \n    /*\n      for(int i = 0 ; i < h+2 ; i ++){\n      for(int j = 0 ; j < w+2 ; j++){\n      cout << a[i][j];\n      }\n      cout <<endl;\n      }\n      cout <<endl;\n    */\n  \n    if(a[ys][xs] != 0){\n      color = a[ys][xs];\n      dfs(xs,ys);\n    }\n    \n    /*\n      for(int i = 0 ; i < h+2 ; i ++){\n      for(int j = 0 ; j < w+2 ; j++){\n      cout << a[i][j];\n      }\n      cout <<endl;\n      }\n    */\n    \n    if(a[yg][xg] == 9){\n      cout <<\"OK\"<<endl;\n    }else{\n      cout <<\"NG\"<<endl;\n    }\n    \n  }      \n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvector<vi> v(h, vi(w));\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tsx--; sy--; gx--; gy--;\n\t\tint n; cin >> n;\n\t\twhile (n--)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif (d==0)\n\t\t\t{\n\t\t\t\tREP(i, 4)REP(j, 2)\n\t\t\t\t{\n\t\t\t\t\tv[x + i][y + j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, 2)REP(j, 4)\n\t\t\t\t{\n\t\t\t\t\tv[x + i][y + j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint co = v[sx][sy];\n\t\tif (co == 0)\n\t\t{\n\t\t\tputs(\"NG\");\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<P> que;\n\t\tque.push(P(sx, sy));\n\t\tbool f = false;\n\t\twhile (que.size())\n\t\t{\n\t\t\tP tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint tx = tmp.first, ty = tmp.second;\n\t\t\tif (tx == gx&&ty == gy)\n\t\t\t{\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv[tx][ty] = 0;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\t\tif (valid(nx, ny, h, w) && v[nx][ny] == co) que.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid setblock(int c, int d, int x, int y){\n  if(d==0){\n    for(int i=0;i<4;i++){\n      F[y][x+i]=c;\n      F[y+1][x+i]=c;\n    }\n  }else{\n    for(int i=0;i<2;i++){\n      F[y+i][x]=c;\n      F[y+i][x+1]=c;\n    }\n  }\n\n}\n\nvoid DFS(int Y, int X, int c){\n  if(F[Y][X]!=c)\n    return;\n\n  F[Y][X] = 6;\n\n  DFS(Y-1, X  ,c);\n  DFS(Y  , X+1,c);\n  DFS(Y+1, X  ,c);\n  DFS(Y  , X-1,c);\n}\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  cin >> w >> h;\n  cin >> xs >> ys;\n  cin >> xg >> yg;\n  cin >> n;\n  for(int i=0; i<n; i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    setblock(c,d,x,y);\n  }\n\n  char S=F[ys][xs];\n  DFS(xs,ys,F[xs][ys]);\n  if(F[ys][xs]==6){\n    cout << \"OK\" << endl;\n  }else{\n    cout << \"NO\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <iomanip>\n#include <vector>\n\nusing namespace std;\n\n\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y;\nint board[100][100];\t//添字は行、列の順\nint dirx[] = {-1, 0, 0, 1};\nint diry[] = {0, -1, 1, 0};\n//xs,ysから接する同じ色のところを100に置き換えていく\nvoid dfs(int x, int y)\n{\n\tboard[y][x] = 6;\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tint nx, ny;\n\t\t\n\t\tnx = x + dirx[i];\n\t\tny = y + diry[i];\n\t\t\n\t\tif (0<=nx && nx<w && 0<=ny && ny<h && board[ny][nx]==c)\n\t\t{\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile (cin >> w >> h)\n\t{\n\t\tif (w == 0 && h == 0) break;\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\t//board初期化\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tboard[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\t//横向き\n\t\t\t\tboard[y-1][x-1] = board[y-1][x] = board[y-1][x+1] = board[y-1][x+2] = c;\n\t\t\t\tboard[y][x-1] = board[y][x] = board[y][x+1] = board[y][x+2] = c;\n\t\t\t} else {\n\t\t\t\t//縦向き\n\t\t\t\tboard[y-1][x-1] = board[y][x-1] = board[y+1][x-1] = board[y+2][x-1] = c;\n\t\t\t\tboard[y-1][x] = board[y][x] = board[y+1][x] = board[y+2][x] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(xs, ys);\n\t\tif (board[yg-1][xg-1] == 6)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t\n\t\t/*\n\t\t//テスト出力\n\t\tfor (int i=0; i<h; i++)\n\t\t{\n\t\t\tfor (int j=0; j<w; j++)\n\t\t\t{\n\t\t\t\tcout << board[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0){\n        ca = 10;\n        break;\n      }else if(i == n-1){\n        ca = 0;\n      }\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint needleX[4] = {-1, 0, 1, 0};\nint needleY[4] = {0, 1, 0, -1};\n\nbool dfs(int x, int y, int goalx, int goaly,vector<vector<int> >& canGo){\n\n    //??´??????????????????????????????true\n    if(x == goalx && y == goaly){ return true; }\n\n    //???????????°????????¢?´¢???????????????\n    canGo[x][y] = false;\n\n    //???????????????????????¢?´¢\n    for(int i = 0; i < 4; i++){\n        int nextx = x + needleX[i];\n        int nexty = y + needleY[i];\n\n        //?????????????????????\n        if(canGo[nextx][nexty]){\n            bool flag = dfs(nextx, nexty, goalx, goaly, canGo);\n            if(flag){\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nint block(int w, int h){\n\n    //0 0??§??????\n    if(w == 0 && h == 0){return 0;}\n\n    //??????????????±??\\???\n    int xs, ys, xg, yg;\n    int n;\n    int c, d, inputX, inputY;\n    vector<vector<int> > canGo(h + 2, vector<int>(w + 2, 0));\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n\n    //??????????????????\n    for(int i = 1; i <= n; i++){\n        cin >> c >> d >> inputX >> inputY;\n        if(d == 0){\n            for(int j = 0; j < 4; j++){\n                for(int k = 0; k < 2; k++){\n                    canGo[inputY + k][inputX + j] = c;\n                }\n            }\n        }else{\n            for(int j = 0; j < 2; j++){\n                for(int k = 0; k < 4; k++){\n                    canGo[inputY + k][inputX + j] = c;\n                }\n            }\n        }   \n    }\n    /*??????????????¨???\n    cout << canGo[ys][xs] << endl;\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            cout << canGo[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n    */\n\n    //????????????bool????????¨?????????\n    int load = canGo[ys][xs];\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            if(canGo[i][j] == load){\n                canGo[i][j] = 1;\n            }else{\n                canGo[i][j] = 0;\n            }\n        }\n    }\n    \n    // ??±???????????¢?´¢????????????????????????\n    bool result = dfs(xs,ys,xg,yg,canGo);\n    if(result){\n        return 1;\n    }else{\n        return 2;\n    }\n\n    \n}\n\nint main(void){\n    int i = 0;\n    int array[30];\n    int w, h;\n    while(1){\n        cin >> w >> h;\n        array[i] = block(w, h);\n        if(array[i] == 0){break;}\n        i++;\n    }\n    for(int j = 0; j < i; j++){\n        if(array[j] == 1){cout << \"OK\" << endl;}\n        else {cout << \"NG\" << endl;}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\nstatic const int dx[4] = {1, 0, -1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nint w, h, sx, sy, gx, gy, G[MAX+2][MAX+2];\nbool dfs( int x, int y, int color ){\n if ( color == 0 || G[x][y] != color ) return false;\n if ( x == gx && y == gy ) return true;\n G[x][y] = 0;\n for ( int r = 0; r < 4; r++ ){\nif ( dfs(x + dx[r], y + dy[r], color) ) return true;\n }\n return false;\n}\nmain(){\n int n, c, d, px, py, ww, hh;\n while( cin >> w >> h && w ){\ncin >> sx >> sy >> gx >> gy >> n;\nfor ( int y = 0; y < h+2; y++ )\n for ( int x = 0; x < w+2; x++ ) G[x][y] = 0;\nfor ( int i = 1; i <=n; i++ ){\n cin >> c >> d >> px >> py;\n if ( d == 0 ) { ww = 4; hh = 2; }\n else { ww = 2; hh = 4; }\n for ( int y = 0; y <= hh-1; y++ )\nfor ( int x = 0; x <= ww-1; x++ ) G[px+x][py+y] = c;\n}\nif ( dfs(sx, sy, G[sx][sy]) ) cout << \"OK\" << endl;\nelse cout << \"NG\" << endl;\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dxdy[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}  };\n\nbool doFill(vector<vector<char> >& brd, int i, int j, int w, int h, char c){\n    if( i < 0 || j < 0 || i >= h || j >= w ) return false;\n    if(brd[i][j] == 'G') return true;\n    else if(brd[i][j] == c) brd[i][j] = '*';\n    else return false;\n    bool b = false;\n    for(int k = 0; k < 4; ++k){\n       b |= doFill(brd, i+dxdy[k][0], j+dxdy[k][1], w, h, c);\n    }\n    return b;\n}\n\nint main(){\n    int w,h;\n    int sx, sy;\n    int gx, gy;\n    int n;\n    int i,j;\n    cin >> w >> h;\n    if(!w && !h) return 0;\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n    sx--; sy--; gx--; gy--;\n    vector< vector<char> > board(h,vector<char>(w));\n    for(i=0;i<h;++i)\n        for(j=0;j<w;++j) board[i][j] = '.';\n    while(n--){\n        char c;\n        int d, x, y;\n        cin >> c >> d >> x >> y;\n        x--; y--;\n        for(i=0;i<2;++i){\n            for(j=0;j<4;++j) {\n                if(d == 1) \n                    board[y+j][x+i] = c;\n                else\n                    board[y+i][x+j] = c;\n            }\n        }\n    }\n    board[gy][gx] = 'G';\n    if(doFill(board, sy, sx, w, h, board[sy][sx])){\n        cout << \"OK\" << endl;\n    } else {\n        cout << \"NG\" << endl;\n    }/*\n    for(i=0;i<h;++i) {\n        for(j=0;j<w;++j) cout << board[i][j];\n        cout << endl;\n    }\n    cout << endl;\n    */return main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif(F[ys][xs]!=0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][yg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n\n#define MAX 150\n\nint map[MAX][MAX];\n\nvoid makemap(int c, int d, int x, int y);\n\nint bfs(int xs,int ys,int xg,int yg);\n\nint main()\n{\n\tint w,h,xs,ys,xg,yg,n,c,d,x,y;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)\n\t\t\treturn 0;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i=0;i<MAX;i++)\n\t\t\tfor(int j=0;j<MAX;j++)\n\t\t\t\tmap[i][j]=0;\n\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tmakemap(c,d,x,y);\n\t\t}\n\t\t\n\n\n\t\tif(bfs(xs,ys,xg,yg)==0)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n}\n\treturn 0;\n}\n\nvoid makemap(int c, int d, int x, int y)\n{\n\tif(d==0)\n\t\tfor(int i=x+1;i<x+5;i++)\n\t\t\tfor(int j=y+1;j<y+3;j++)\n\t\t\t\tmap[i][j]=c;\n\telse\n\t\tfor(int i=x+1;i<x+3;i++)\n\t\t\tfor(int j=y+1;j<y+5;j++)\n\t\t\t\tmap[i][j]=c;\n}\n\nint bfs(int xs,int ys,int xg,int yg)\n{\n\tint startcolor=map[xs][ys];\n\tint nowx=xs,nowy=ys;\n\tusing namespace std;\n\tqueue<int> x;\n\tqueue<int> y;\n\twhile(1)\n\t{\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }\n    if(C[xg][yg] != -1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\\#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0)\n        ca = 10\n      else if(i == n-1)\n        c = 0:\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint W,H, f[100][100];\nbool memo[100][100];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nvoid dfs(int x, int y, int c)\n{\n\tmemo[x][y]=1;\n\t\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint tx=x+dx[i], ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=W||ty>=H) continue;\n\t\tif(f[tx][ty]!=c) continue;\n\t\tif(memo[tx][ty]) continue;\n\t\tdfs(tx,ty,c);\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &W,&H), (W||H))\n\t{\n\t\tint xs,ys,xg,yg,N;\n\t\tscanf(\"%d%d%d%d%d\", &xs,&ys,&xg,&yg,&N);\n\t\txs--;ys--;xg--;yg--;\n\t\twhile(N--)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\", &c,&d,&x,&y);\n\t\t\tx--; y--;\n\t\t\t\n\t\t\tint w=2, h=4;\n\t\t\tif(d==0) swap(w,h);\n\t\t\tfor(int i=y; i<y+h; i++)\n\t\t\tfor(int j=x; j<x+w; j++)\n\t\t\t\tf[j][i]=c;\n\t\t}\n\t\t\n\t\tmemset(memo,0,sizeof(memo));\n\t\tdfs(xs,ys,f[xs][ys]);\n\t\t\n\t\tputs(memo[xg][yg]?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0)\n        ca = 10\n      else if(i == n-1)\n        c = 0:\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       \n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint block[100][100];\nint visited[100][100];\nbool memo[100][100];\nint w, h, xs, ys, xg, yg, n;\nint d[2][4]={{0,0,-1,1},{-1,1,0,0}};\nbool dfs(int x, int y) {\n    if (visited[y][x]) return memo[y][x];\n    if (x==xg-1&&y==yg-1) return true;\n    visited[y][x]=1;\n    for (int i=0; i<4; i++) {\n        int nx=x+d[0][i], ny=y+d[1][i];\n        if (nx>=0&&nx<w&&ny>=0&&ny<h&&block[y][x]==block[ny][nx]) {\n            if (dfs(nx,ny)) {\n                memo[y][x]=true;\n                return true;\n            }\n        }\n    }\n    memo[y][x]=false;\n    return false;\n}\nint main() {\n    while (scanf(\"%d%d\",&w,&h)) {\n        if (!w&&!h) break;\n        memset(block, 0, sizeof(block));\n        scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n        for (int i=0; i<n; i++) {\n            int c, d, x, y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            if (d) {\n                for (int j=y-1; j<y+3; j++) {\n                    for (int k=x-1; k<x+1; k++) {\n                        block[j][k]=c;\n                    }\n                }\n            } else {\n                for (int j=x-1; j<x+3; j++) {\n                    for (int k=y-1; k<y+1; k++) {\n                        block[k][j]=c;\n                    }\n                }\n            }\n        }\n        /*for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            printf(\"%d%c\",block[i][j],j==w-1?'\\n':' ');\n        }*/\n        if (dfs(xs,ys)) puts(\"OK\");\n        else puts(\"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n//インクルード文\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <stdlib.h>\n#include <cstdio>\n#include <string>\n//#include <assert.h>\n\n//:std省略\nusing namespace std;\n\n//グローバル変数\nint f[1000][1000];\n\n//マクロ指定\n#define fc f[x + j][y + l] = c\n\n//深さ優先探索( dfs = Depth - First Search )\nvoid dfs(int a, int b, int c) {\n\n\tif (f[a][b] == c) {\n\n\n\t\tf[a][b] = 10;\n\t\tdfs(a + 1, b, c);\n\t\tdfs(a - 1, b, c);\n\t\tdfs(a, b + 1, c);\n\t\tdfs(a, b - 1, c);\n\n\n\t}\n\n//\telse return;\n\n}\n\n//メイン文\nint main(){\n\n\tint w=0, h=0, n = 0;\n\tint i, j, l;\n\tint xs, ys; \n\tint xg, yg;\n\n\t\n\n\tfor (;;) {\n\t\tcin >> w >> h;\n\n\t\tconst int cnt = w + h;\n\t\t\n\t\tif ( cnt == 0) break;\n\t\t\n\t\tfor (i = 1; i <= h; ++i) {\n\t\t\tfor (j = 1; j <= w; ++j) {\n\t\t\t\tf[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\n\t\t\tcin >> c >> d;\n\t\t\tcin >> x >> y;\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l = 0; l < 2; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {//d==1\n\n\t\t\t\t\n\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l= 0; l < 4; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l = 0; l < 4; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l= 0; l < 2; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n*/\n\n\n\t\tdfs(xs, ys, f[xs][ys]);\n\n\n//\t\tchar gg = 'OK';\n//\t\tchar ggwp = 'NG';\n\n\n\t\t\n\n\t\tif (f[xg][yg] == 10) printf(\"OK\\n\");\n\n\t\telse \t\t         printf(\"NG\\n\");\n\n\n\n\t\t\t//\t\t\tassert(i == 10);\n\t\t\t//\t\t\tassert(i = 9);\n\t\t\t//\t\t\tassert(i = 8);\n\t\t\t//\t\t\tassert(i = 7);\n\t\t\t//\t\t\tassert(i = 6);\n\t\t\t//\t\t\tassert(i = 5);\n\t\t\t//\t\t\tassert(i = 4);\n\t\t\t//\t\t\tassert(i = 3);\n\t\t\t//\t\t\tassert(i = 2);\n\t\t\t//\t\t\tassert(i = 1);\n\n\t\t\n\n\n\t}\n\treturn 0;\n}\n\n/*\n\n\n20 20\n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[w][h] = 0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n\n    }\n    ans = 0;\n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg]){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x < w && y>=0 && y< h);\n}\nint main(void){\n\tconst int dx[4]={0,1,0,-1};\n\tconst int dy[4]={1,0,-1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\t//printf(\"%d %d\\n\",w,h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x-1+k][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs-1][ys-1];\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs-1;\n\t\tqy[0]=ys-1;\n\t\tf=1;\n/*\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\t\tprintf(\"%d\\n\",c);*/\n\t\twhile(f && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dy[i];\n\t\t\t\ty = qy[p] + dx[i];\n\t\t\t\tif(is(x,y) && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx[p+cnt] = x;\n\t\t\t\t\tqy[p+cnt] = y;\n\t\t\t\t\tif(x == xg-1 && y == yg-1)f=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}\n\t\tputs(f?\"NG\":\"OK\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nchar start;\nvoid fun(int y,int x){\n    if(map[y][x]==start){\n    \tcout << 1 << endl;\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y][x]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+1);\n    fun(y,x-1);\n    fun(y+1,x);\n    fun(y-1,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        start=map[ys][xs];\n        if(map[ys][xs]==0||map[yg][xg]==0);\n        else\n        \tfun(ys,xs);\n        for(int i=1;i<w;i++){\n        \tfor(int j=1;j<h;j++){\n        \t\tcout << map[i][j];\n        \t}\n        \tcout << endl;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define reep(i,n,m) for(int i=(n);i<(m);i++)\n#define rep(i,n) reep(i,0,n)\n\nbool flg[150][150];\nint fld[150][150];\nint w,h;\nint xg,yg;\nbool ans;\n\nvoid check(int c,int x,int y){\n    if(fld[y][x]!=c){\n        return;\n    }\n\n    if(x == xg && y == yg){\n        ans = true;\n        return;\n    }\n\n    if(flg[y][x]){\n        return;\n    }\n    flg[y][x] = true;\n\n    int dx[] = {0,0,1,-1};\n    int dy[] = {1,-1,0,0};\n    rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(nx<=0 || nx>w || ny<=0 || ny>h){\n            continue;\n        }\n        check(c,nx,ny);\n    }\n}\n\nint main(){\n    while(cin >> w >> h,w+h){\n        rep(i,150){rep(k,150){flg[i][k]=false;}}\n        ans = false;\n        int xs,ys;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n\n        int n;\n        cin >> n;\n        rep(i,n){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            int width,height;\n            if(d == 0){\n                width = 4;\n                height = 2;\n            }else{\n                width = 2;\n                height = 4;\n            }\n\n            reep(ny,y,y+height){\n                reep(nx,x,x+width){\n                    fld[ny][nx] = c;\n                }\n            }\n        }\n\n        reep(i,1,6){\n            check(i,xs,ys);\n        }\n        if(ans){\n            puts(\"OK\");\n        }else{\n            puts(\"NG\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[x][y]==0 || c==0)  return;\n  if(map[x][y]!=c && map[x][y]!=9)  return;\n  if(map[x][y]==9){\n    map[x][y]=7;\n    return;\n  } \n  map[x][y]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[N][N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0)  break;\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<2;k++)\n          for(l=0;l<4;l++)\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n      }else if(d[i][j]==1){\n        for(k=0;k<4;k++)\n          for(l=0;l<2;l++)\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n      }\n    }\n    map[xg[i]][yg[i]]=9;\n    search(map,xs[i],ys[i],map[xs[i]][ys[i]]);\n    if(map[xg[i]][yg[i]]==7)        printf(\"OK\\n\");\n    else if(map[xg[i]][yg[i]]==9)   printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\\n\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[110][110];\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight - 1;\n    board_hight  = Board_Hight  - 1;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    while(true){\n        int w, h, sx, sy, gx, gy, n, c, d, x, y;\n        \n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy;\n            \n            Solve s(w, h, sx, sy, gx, gy);\n            \n            cin >> n;\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\\n\";\n            }else{\n                cout << \"NG\\n\";\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[100][100] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y && di < h; di++){\n                for(int dj = x;dj < dw + x && dj < w;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[100][100] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xg][yg] != C || C == 0)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        }\n/*\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<field[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl<<endl;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<vis[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        //cout<<C<<\"---\"<<field[xg][yg]<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nclass node{\npublic:\n\tint x,y;\n\tvoid set(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tbool check(int w,int h){\n\t\tif(x>=0&&y>=0){\n\t\t\tif(x<=w&&y<=h) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nint main(){\n\tint w,h;\n\twhile(1){\n\t\t//printf(\"w:%d,h:%d\\n\",w,h);\n\t\tint xs,ys,xg,yg,n,c,dir,x,y;\n\t\tint i,j;\n\t\tint color[101][101];\n\t\tint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\t\tbool visited[101][101];\n\t\tqueue<node> q;\n\t\tnode a;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\n\t\twhile(n--){\n\t\t\tscanf(\"%d%d%d%d\",&c,&dir,&x,&y);\n\t\t\tif(dir==0){\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+j][y+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+i][y+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta.set(xs,ys);\n\t\tq.push(a);\n\t\tvisited[a.x][a.y]=true;\n\t\twhile(!q.empty()){\n\t\t\ta = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\ta.x += dx[i];\n\t\t\t\ta.y += dy[i];\n\t\t\t\tif(!a.check(w,h)&&(color[xs][ys]==color[a.x][a.y])&&!visited[a.x][a.y]){\n\t\t\t\t\tq.push(a);\n\t\t\t\t\tif(a.x==xg&&a.y==yg) break;\n\t\t\t\t\tvisited[a.x][a.y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(visited[xg][yg]) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nclass cordinate\n{\n\npublic:\n\tint x;\n\tint y;\n\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\n\n\t\tint w;\n\t\tint h;\n\t\tcin >> w >> h; \n\t\tif(w == 0 && h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tw = 110;\n\t\th = 110;\n\t\t\n\t\tint xs;\n\t\tint ys;\n\t\tcin >> xs >> ys;\n\t\tint xg;\n\t\tint yg;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<vector<int >> vobj;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tvector<int> lineobj;\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tlineobj.push_back(0);\n\n\t\t\t}\n\t\t\tvobj.push_back(lineobj);\n\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 2][y] = c;\n\t\t\t\tvobj[x + 3][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 2][y + 1] = c;\n\t\t\t\tvobj[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x][y + 2] = c;\n\t\t\t\tvobj[x][y + 3] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 2] = c;\n\t\t\t\tvobj[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\n\t\tint startColor;\n\t\tstartColor = vobj[xs - 1][ys - 1];\n\t\tqueue<cordinate> que;\n\n\t\tcordinate obj;\n\t\tobj.x = xs - 1;\n\t\tobj.y = ys - 1;\n\t\tque.push(obj);\n\t\tbool flag = false;\n\t\twhile(1)\n\t\t{\n\t\t\tif(startColor == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcordinate buf;\n\t\t\tbuf = que.front();\n\t\t\tque.pop();\n\n\t\t\tint bx;\n\t\t\tint by;\n\t\t\tbx = buf.x;\n\t\t\tby = buf.y;\n\t\t\tif(bx == xg - 1 && by == yg - 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif(bx + dx[i] >= 0 && bx + dx[i] <= h - 1)\n\t\t\t\t{\n\t\t\t\t\tif(by + dy[i] >= 0 && by + dy[i] <= w - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vobj[bx + dx[i]][by + dy[i]] == startColor)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcordinate newObject;\n\t\t\t\t\t\t\tnewObject.x = bx + dx[i];\n\t\t\t\t\t\t\tnewObject.y = by + dy[i];\n\t\t\t\t\t\t\tque.push(newObject);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvobj[bx][by] = -1;\n\n\t\t\tif(que.size() == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(flag == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t/*for(int i = 0; i < w - 1; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < h - 1; j++)\n\t\t\t{\n\t\t\t\tcout << vobj[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}  */\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101];\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y, int lastp){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc || i == lastp) return;\n\t\tfunc(x + nx[i], y + ny[i], (i + 2) % 4);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\twhile (1){\n\t\tfor (int i = 0; i < 101; i++){\n\t\t\tfor (int j = 0; j < 101; j++){\n\t\t\t\tstage[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tbw = 4;\n\t\t\t\tbh = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbw = 2;\n\t\t\t\tbh = 4;\n\t\t\t}\n\t\t\tfor (int j = 0; j < bh; j++){\n\t\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = stage[ys][xs];\n\t\tif (bc == 0){\n\t\t\tcout << \"NG\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tfunc(1, 1, -1);\n\t\tif (ans == true) cout << \"OK\\n\";\n\t\telse cout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h;\nint field[100][100];\nint gx,gy;\nint sc;\nbool search(int x,int y)\n{\n\tbool flag = false;\n\tif(x == gx && y == gy)\n\t\tflag = true;\n\telse{\n\t\tint vectorx[4] = {-1,0,1,0},vectory[4] = {0,-1,0,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x+vectorx[i] >= 0 && y+vectory[i] >= 0 && x+vectorx[i] < w && y+vectory[i] < h){\n\t\t\t\tif(field[x+vectorx[i]][y+vectory[i]] == sc){\n\t\t\t\t\tfield[x][y] = 0;\n\t\t\t\t\tflag |= search(x+vectorx[i],y+vectory[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tint n,c,x,y;\n\t\tbool d;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint vectorx,vectory;\n\t\t\tif(d == 0){\n\t\t\t\tvectorx = 4;vectory = 2;\n\t\t\t}else{\n\t\t\t\tvectorx = 2;vectory = 4;\n\t\t\t}\n\t\t\tfor(int j=0;j<vectorx;j++){\n\t\t\t\tfor(int k=0;k<vectory;k++){\n\t\t\t\t\tfield[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc = field[sx][sy];\n\t\tif(search(sx,sy))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nbool bfs(pair<int,int> [2],int [102][102]);\n\nint main(void){\n\tint w,h,xs,ys,xg,yg,n,board[102][102],dr[2][2]={4,2,2,4};\n\tpair<int,int> sg[2];\n\n\twhile(true){\n\t\tcin >> w >> h;\n\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tsg[0] = make_pair(xs,ys);\n\t\tsg[1] = make_pair(xg,yg);\n\n\t\tfor(int i=0;i<h+2;i++)\n\t\t\tfor(int j=0;j<w+2;j++)\n\t\t\t\tboard[j][i]=0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor(int j=0;j<dr[d][0];j++)\n\t\t\t\tfor(int k=0;k<dr[d][1];k++)\n\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t}\n\n\t\tcout << (bfs(sg,board)?\"OK\":\"NG\");\n\t\tcout << endl;\n\n\t}\n\n\treturn 0;\n}\n\nbool bfs(pair<int,int> sg[2],int board[102][102]){\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c || Y >w || X>h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=0;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n        c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<utility>\nusing namespace std;\nchar m[128][128];\nvoid PutSquare(int x, int y, int c)\n{\n\tm[y][x] = m[y+1][x] = m[y+1][x+1] = m[y][x+1] = static_cast<char>(c);\n}\nbool CanReach(int sx,int sy,int gx,int gy)\n{\n\tbool f[128][128]={};\n\n\ttypedef pair<int,int>P;\n\tqueue<P>q;\n\tq.push(P(sx,sy));\n\n\tconst char c = m[sy][sx];\n\tif(!c)\n\t\treturn false;\n\tconst int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\twhile(!q.empty())\n\t{\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif(f[p.second][p.first] || c!=m[p.second][p.first])\n\t\t\tcontinue;\n\t\tif(p.first==gx && p.second==gy)\n\t\t\treturn true;\n\t\tf[p.second][p.first] = true;\n\t\tfor(int i=0; i<4; ++i)\n\t\t\tq.push(P(p.first+dx[i],p.second+dy[i]));\n\t}\n\treturn false;\n}\nint main()\n{\n\tint h, w;\n\tint sx, sy;\n\tint gx, gy;\n\tint n;\n\tint c, d, x, y;\n\twhile(scanf(\"%d%d\",&w,&h),h)\n\t{\n\t\tmemset(m,0,sizeof(m));\n\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tPutSquare(x,y,c);\n\t\t\tif(d==0)\n\t\t\t\tPutSquare(x+2,y,c);\n\t\t\telse\n\t\t\t\tPutSquare(x,y+2,c);\n\t\t}\n\t\tputs(CanReach(sx,sy,gx,gy) ? \"OK\" :\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool dfs(int y, int x, int c, int gy, int gx, vector<vector<int> > &field){\n    if(field[y][x] != c) return false;\n    if(y==gy && x==gx) return true;\n    field[y][x] = 0;\n    for(int i=0; i<4; i++){\n        if(dfs(y+dy[i], x+dx[i], c, gy, gx, field)) return true;\n    }\n    return false;\n}\n\nint main(){\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(w==0) break;\n\n        int sx,sy, gx,gy, n;\n        cin >> sx >> sy >> gx >> gy >> n;\n        vector<vector<int> > b(h+2, vector<int>(w+2, 0));\n        for(int i=0; i<n; i++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            for(int r=0; r<2; r++){\n                b[y][x] = b[y+1][x] = b[y][x+1] = b[y+1][x+1] = c;\n                if(d == 0){\n                    x += 2;\n                }else{\n                    y += 2;\n                }\n            }\n        }\n\n        if(b[sy][sx] == 0 || !dfs(sy, sx, b[sy][sx], gy, gx, b)){\n            cout << \"NG\" << endl;\n        }else{\n            cout << \"OK\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tif(sx < gy)\n\t\tDFSr(x,y);\n\telse\n\t\tDFSl(x,y);\n}\n\nvoid DFSr(int x, int y){\n\tif(field[y][x] != col)\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tDFSr(x+1, y);\n\tif(flag)\n\t\treturn;\n\tDFSr(x, y+1);\n\tif(flag)\n\t\treturn;\n\tDFSr(x, y-1);\n\tif(flag)\n\t\treturn;\n\tDFSr(x-1, y);\n}\n\nvoid DFSl(int x, int y){\n\tif(field[y][x] != col)\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tDFSl(x-1, y);\n\tif(flag)\n\t\treturn;\n\tDFSl(x, y+1);\n\tif(flag)\n\t\treturn;\n\tDFSl(x, y-1);\n\tif(flag)\n\t\treturn;\n\tDFSl(x+1, y);\n}\n\nint main(){\n\tint n,c,d,bx,by;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\n\t\tstd::cin >> c >> d;\n\t\tif(!c && !d)\n\t\t\treturn 0;\n\n\t\tstd::cin >> sx >> sy;\n\t\tstd::cin >> gx >> gy;\n\n\t\tstd::cin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tstd::cin >> c >> d >> bx >> by;\n\t\t\tif(d==0)\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+4; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t\telse\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+2; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t}\n\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nchar start;\nvoid fun(int y,int x){\n    if(map[y][x]==start){\n    \tcout << 1 << endl;\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y][x]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+1);\n    fun(y,x-1);\n    fun(y+1,x);\n    fun(y-1,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        start=map[ys][xs];\n        /*if(map[ys][xs]==0||map[yg][xg]==0);\n        else*/\n        \tfun(ys,xs);\n        /*for(int i=1;i<w;i++){\n        \tfor(int j=1;j<h;j++){\n        \t\tcout << map[i][j];\n        \t}\n        \tcout << endl;\n        }*/\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint dx[2][8] = { { 0, 1, 2, 3, 0, 1, 2, 3 }, { 0, 1, 0, 1, 0, 1, 0, 1 } };\nint dy[2][8] = { { 0, 0, 0, 0, 1, 1, 1, 1 }, { 0, 0, 1, 1, 2, 2, 3, 3 } };\n\nint dx2[4] = {1, 0, -1, 0};\nint dy2[4] = {0, -1, 0, 1};\n\nstruct Point\n{\n\tint x, y;\n\tPoint(){};\n\tPoint(int a, int b)\n\t{\n\t\tx = a;\n\t\ty = b;\n\t}\n};\n\nvoid solve()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w || h)\n\t{\n\t\tvector< vector<int> > field(h + 1, vector<int>(w + 1));\n\t\tPoint start, goal;\n\t\tcin >> start.x >> start.y >> goal.x >> goal.y;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint c, d;\n\t\t\tPoint p;\n\t\t\tcin >> c >> d >> p.x >> p.y;\n\t\t\tfor (int j = 0; j < 8; ++j)\n\t\t\t{\n\t\t\t\tint nextX = p.x + dx[d][j];\n\t\t\t\tint nextY = p.y + dy[d][j];\n\t\t\t\tfield[nextY][nextX] = c;\n\t\t\t}\n\t\t}\n\t\tif (field[start.y][start.x] != field[goal.y][goal.x])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<Point> que;\n\t\tque.push(start);\n\t\tbool isOK = false;\n\t\tdeque< deque<bool> > isUsed(h + 1, deque<bool>(w + 1));\n\t\tisUsed[start.y][start.x] = true;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tPoint p = que.front();\n\t\t\tque.pop();\n\t\t\tif (p.x == goal.x && p.y == goal.y)\n\t\t\t{\n\t\t\t\tisOK = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint nx = p.x + dx2[i];\n\t\t\t\tint ny = p.y + dy2[i];\n\t\t\t\t\n\t\t\t\tif ((1 <= nx && nx <= w) && (1 <= ny && ny <= h) && field[ny][nx] == field[start.y][start.x] && isUsed[ny][nx] == false)\n\t\t\t\t{\n\t\t\t\t\tisUsed[ny][nx] = true;\n\t\t\t\t\tque.push(Point(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isOK)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define TATE 1\n#define YOKO 0\n\nstruct ST {\n        int x;\n        int y;\n    };\n\nint main(void){\n    int map[101][101];\n    int board[101][101];\n    int T[]={0,-1,1,0};\n    int Y[]={1,0,0,-1};\n    int w,h,xs,xg,ys,yg,n,color,muki,x,y;\n    \n    ST RE;\n    ST GO;\n    queue <ST> Q;\n    while(1){\n        memset(map,0,sizeof(map));\n        memset(board,0,sizeof(board));\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys>>xg>>yg>>n;\n        for(int i=0;i<n;i++){\n            cin>>color>>muki>>x>>y;\n            if(muki==YOKO){\n                for(int j=0;j<4;j++){\n                    board[y][x+j]=board[y+1][x+j]=color;\n                }\n            }\n            else{\n                for(int j=0;j<4;j++){\n                    board[y+j][x]=board[y+j][x+1]=color;\n                }\n            }\n        }\n       /* for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        RE.x=xs;\n        RE.y=ys;\n        map[ys][xs]=1;\n        Q.push(RE);\n        int flag=0;\n        while(!Q.empty()){\n            RE=Q.front();\n            Q.pop();\n            if(RE.x==xg&&RE.y==yg&&board[RE.y][RE.x]==board[yg][xg]){\n                flag=1;\n                //cout<<RE.x<<\" \"<<RE.y<<endl;\n                break;\n            }\n            else{\n                for(int i=0;i<4;i++){\n                    GO=RE;\n                    if(GO.x+Y[i]>0&&GO.y+T[i]>0&&GO.x+Y[i]<101&&GO.y+T[i]<101&&board[GO.y+T[i]][GO.x+Y[i]]==board[yg][xg]&&map[GO.y+T[i]][GO.x+Y[i]]!=1){\n                        GO.x+=Y[i];\n                        GO.y+=T[i];\n                        map[GO.y][GO.x]=1;\n                        Q.push(GO);\n                    }\n                }\n            }\n        }\n       /* for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(flag==1){\n            cout<<\"OK\"<<endl;\n        }\n        else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint xg,yg,c,sc,ans,block[101][101],w,h;\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nint idou(int x,int y)\n{\n    if(x == xg&&y == yg)\n    {\n        ans = 1;\n        return 0;\n    }\n    if(sc == 0)return 0;\n    block[x][y] = 0;\n    for(int i = 0; i < 4; i++)\n    {\n        if(block[x + dx[i]][y + dy[i]] == sc)idou(x + dx[i],y + dy[i]);\n    }\n    return 0;\n}\nint main()\n{\n    while(1)\n    {\n        int xs,ys,n,d,x,y;\n        ans = 0;\n        for(int i = 0; i < w; i++)\n        {\n            for(int j = 0; j < h; j++)\n            {\n                block[i][j] = 0;\n            }\n        }\n        scanf(\"%d%d\",&w,&h);\n        if(w == 0&&h == 0)break;\n        scanf(\"%d%d\",&ys,&xs);\n        scanf(\"%d%d\",&yg,&xg);\n        scanf(\"%d\",&n);\n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%d%d%d%d\",&c,&d,&y,&x);\n            if(d == 1)\n            {\n                for(int i = 0; i < 2; i++)\n                {\n                    for(int j = 0; j < 4; j++)\n                    {\n                        block[x + j][y + i] = c;\n                    }\n                }\n            }\n            if(d == 0)\n            {\n                for(int i = 0; i < 2; i++)\n                {\n                    for(int j = 0; j < 4; j++)\n                    {\n                        block[x + i][y + j] = c;\n                    }\n                }\n            }\n        }\n        sc = block[xs][ys];\n        //block[xg][yg] = 9;\n        /*for(int i = 0; i < w; i++)\n        {\n            for(int j = 0; j < h; j++)\n            {\n                printf(\"%d\",block[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        idou(xs,ys);\n        if(ans == 1)printf(\"OK\\n\");\n        else printf(\"NG\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[101][101]={0},v[101][101]={0};\nint root(int x,int y,int vmap[][101]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>0&&fy<=h&&fx>0&&fx<=w&&vmap[fy][fx]==0){\n\t\t\tvmap[y][x]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\t\tfor(int e=y;e<y+2;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int e=y;e<y+4;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int i1=0;i1<101;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint w,h;\nint map[101][101];\nint xg,yg;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid mapout()\n{\n  for(int xx=0;xx<h;xx++,cout<<endl)\n    for(int yy=0;yy<w;yy++)\n      if(map[xx][yy]!=-1)\n      cout<<map[xx][yy];\n      else\n\tcout<<\"X\";\n}\n\nbool check(int x,int y)\n{\n  //  cout<<\"check \"<<x<<\" \"<<y<<\";\"<<map[x][y]<<endl;\n  if(x==xg&&y==yg)\n    return true;\n  int buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]>=0&&x+dx[i]<h&&\n\t y+dy[i]>=0&&y+dy[i]<w&&\n\t buf==map[x+dx[i]][y+dy[i]] &&\n\t map[x+dx[i]][y+dy[i]]!=-1 &&\n\t check(x+dx[i],y+dy[i]))\n\treturn true;\n    }\n\n  \n  return false;\n}\n\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>xs>>ys;\n      cin>>xg>>yg;\n      xs--;ys--;\n      xg--;yg--;\n      \n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  x--;y--;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      ///   mapout();\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;\n    }\n  \n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       F[0][-1] = 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint count=0;\n\tint H,W,xg,yg,xs,ys,n;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2 || H<4 || W<4)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor(int o=ys;o<=yg;o++){\n\t\tfor(int j=xs;j<=xg;j++){\n\t\t\tcout<<F[j][o];\n\t\t}\n\t\tcout<<endl;\n\t}\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==0)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 102\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid input_data(void);  //データ入力用関数\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\nvoid clear(void);       //データの初期化\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n memset(mass,0,sizeof(mass));\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0)break; //ループ終了条件\n\n    input_data();\n\n    make_mass();\n\n    solve();\n    if(scolor!=0 && mass[sy][sx]==mass[gy][gx]){\n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n    }\n    else {\n      cout<<\"NG\"<<endl;\n    }\n\n    clear();\n  }\n\n  return 0;\n}\nvoid input_data(void){\n\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n\n    cin>>n;\n\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n\n    }\n\n    return;\n}\nvoid make_mass(void){\n\n  int i,j;\n\n    /*マスの作成*/\n    for(i=0;i<n;i++){\n\tswitch(d[i]){\n\tcase 0:              //横向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]][x[i]+j]=c[i];\n\t    mass[y[i]+1][x[i]+j]=c[i];\n\t  }\n\t  break;\n\tcase 1:              //縦向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]+j][x[i]]=c[i];\n\t    mass[y[i]+j][x[i]+1]=c[i];\n\t  }\n\t  break;\n\t}\n      }\n\n    scolor=mass[sy][sx];\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(scolor!=mass[i][j]){\n\t  mass[i][j]=0;\n\t}\n      }\n    }\n    \n    return;\n}\nvoid solve(void){\n\n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n\n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n\n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\nvoid clear(){\n  goal=0;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool saiki( char stage[101][101], int xs, int ys, int xg, int yg, int w, int h, bool data[101][101] )\n{\n\tdata[xs][ys] = true;\n\tif( xs == xg && ys == yg ) return true;\n\tif( xs + 1 <= w && stage[xs + 1][ys] == stage[xs][ys] && data[xs + 1][ys] == false )if( saiki( stage, xs + 1, ys, xg, yg, w, h, data ) ) return true;\n\tif( xs - 1 >= 1 && stage[xs - 1][ys] == stage[xs][ys] && data[xs - 1][ys] == false ) if( saiki( stage, xs - 1, ys, xg, yg, w, h, data ) ) return true;\n\tif( ys + 1 <= h && stage[xs][ys + 1] == stage[xs][ys] && data[xs][ys + 1] == false ) if( saiki( stage, xs, ys + 1, xg, yg, w, h, data ) ) return true;\n\tif( ys - 1 >= 1 && stage[xs][ys - 1] == stage[xs][ys] && data[xs][ys - 1] == false ) if( saiki( stage, xs, ys - 1, xg, yg, w, h, data  ) ) return true;\n\n\treturn false;\n}\n\n\nint main(int argc, char const* argv[])\n{\n\tchar stage[101][101];\n\tbool data[101][101];\n\tint w,h;\n\tint xs,ys;\n\tint xg,yg;\n\tint n;\n\n\twhile( cin >> w >> h && w != 0 ){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor( int i = 0;i < 101;i++ ){\n\t\t\tfor( int j = 0;j < 101;j++ ){\n\t\t\t\tstage[i][j] = 0;\n\t\t\t\tdata[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor( int i = 0;i < n;i++ ){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tif( d == 0 ){\n\t\t\t\tfor( int j = 0;j < 2;j++ ){\n\t\t\t\t\tfor( int k = 0;k < 4;k++ ){\n\t\t\t\t\t\tstage[k + x][j + y] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if( d == 1 ){\n\t\t\t\tfor( int j = 0;j < 4;j++ ){\n\t\t\t\t\tfor( int k = 0;k < 2;k++ ){\n\t\t\t\t\t\tstage[k + x][j + y] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( saiki( stage, xs, ys, xg, yg, w, h ,data ) ) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c || b.mass[y][x]==0)return;\n    b.mass[y][x]=0;\n    if(x==gx&&y==gy){goal_flag=true;return;}\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n  int goal_x,goal_y;\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        b.mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nenum class Color {\n\tgoal, white, yellow, green, blue, red, null\n};\nvoid recursive(std::vector<std::vector<Color>> &vector, const int &x, const int &y, const Color c) {\n\tif (0 <= x && x < vector.at(0).size() && 0 <= y && y < vector.size() && vector.at(y).at(x) == c) {\n\t\tvector.at(y).at(x) = Color::goal;\n\t\trecursive(vector, x, y - 1, c); recursive(vector, x + 1, y, c); recursive(vector, x, y + 1, c); recursive(vector, x - 1, y, c);\n\t}\n}\nvoid fill(std::vector<std::vector<Color>> &vector, const int &x, const int &y, const Color &c) {\n\tfor (auto i = 0; i < 2; ++i) {\n\t\tfor (auto j = 0; j < 2; ++j) {\n\t\t\tvector.at(y + i).at(x + j) = c;\n\t\t}\n\t}\n}\nint main() {\n\tint w, h;\n\tstd::cin >> w >> h;\n\twhile (w != 0) {\n\t\tstd::vector<std::vector<Color>> vector(h, std::vector<Color>(w, Color::null));\n\t\tint start_x, start_y;\n\t\tstd::cin >> start_x >> start_y;\n\t\tint goal_x, goal_y;\n\t\tstd::cin >> goal_x >> goal_y;\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\tfill(vector, x - 1, y - 1, Color(c));\n\t\t\tfill(vector, x + 1 - 2 * d, y - 1 + 2 * d, Color(c));\n\t\t}\n\t\trecursive(vector, start_x - 1, start_y - 1, vector.at(start_y).at(start_x));\n\t\tif (vector.at(goal_y - 1).at(goal_x - 1) == Color::goal) {\n\t\t\tstd::cout << \"OK\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"NG\\n\";\n\t\t}\n\t\tstd::cin >> w >> h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif ((W == 0) && (H == 0)) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nint board[100][100], h, w, xs, ys, xg, yg, n;\nbool mem[100][100];\nint col;\n\n\nbool dfs(int x, int y)\n{\n  bool b = false;\n  if(x == xg && y == yg)\n    return true;\n  if(mem[x][y])\n    return false;\n\n  mem[x][y] = true;\n  b = false;\n  if(x < w - 1 && board[x + 1][y] == col)\n  {\n    b |= dfs(x + 1, y);\n  }\n  if(!b && x > 0 && board[x - 1][y] == col)\n  {\n    b |= dfs(x - 1, y);\n  }\n  if(!b && y < h - 1 && board[x][y + 1] == col)\n  {\n    b |= dfs(x, y + 1);\n  }\n  if(!b && y > 0 && board[x][y - 1] == col)\n  {\n    b |= dfs(x, y - 1);\n  }\n  return b;\n}\n\n\nint main()\n{\n  while(true)\n  {\n    cin >> w >> h;\n    if(!w)\n      break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    for(int i = 0; i < n; i++)\n    {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      board[x][y] = d;\n      if(d == 0)\n        board[x][y + 1] = c; \n      else\n        board[x + 1][y] = c;\n\n    }\n    col = board[xs][ys];\n    if(dfs(xs, ys))\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 102\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid input_data(void);  //データ入力用関数\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\nvoid clear(void);       //データの初期化\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0)break; //ループ終了条件\n\n    input_data();\n\n    make_mass();\n\n    solve();\n\n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n\n  }\n\n  return 0;\n}\nvoid input_data(void){\n\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n\n    cin>>n;\n\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n\n    }\n\n    return;\n}\nvoid make_mass(void){\n\n  int i,j;\n  int scolor,fcolor;\n\n    /*マスの作成*/\n    for(i=0;i<n;i++){\n\tswitch(d[i]){\n\tcase 0:              //横向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]][x[i]+j]=c[i];\n\t    mass[y[i]+1][x[i]+j]=c[i];\n\t  }\n\t  break;\n\tcase 1:              //縦向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]+j][x[i]]=c[i];\n\t    mass[y[i]+j][x[i]+1]=c[i];\n\t  }\n\t  break;\n\t}\n      }\n\n    scolor=mass[sy][sx];\n    fcolor=mass[gy][gx];\n\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(scolor!=mass[i][j]){\n\t    mass[i][j]=0;\n\t  }\n\t}\n      }\n\n    return;\n}\nvoid solve(void){\n\n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n\n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n\n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=data[p.second][p.first]+1;\n      }\n    }\n  }\n  return;\n}\n\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nqueue <pair<int,int> > blocks;\nint w,h,xs,ys,n,xg,yg,c,d,x,y,area[105][105];\nbool flag=false;\nvoid solve(int x,int y,int c);\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0&&h==0)break;\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=0;i<n;i++){\n            cin >> c >> d >> x >> y;\n            if(d==0){\n            for(int j=y;j<y+2;j++){\n                for(int k=x;k<x+4;k++){\n                    area[k][j]=c;\n                }\n            }\n            }else{\n            for(int j=y;j<y+4;j++){\n                for(int k=x;k<x+2;k++){\n                    area[k][j]=c;\n                    }\n                }\n            }\n        }\n        if(area[xs][ys]!=area[xg][yg]);\n        else {\n        blocks.push(make_pair(xs,ys));\n        solve(blocks.front().first,blocks.front().second,area[xs][ys]);\n        }\n        if(flag==true)cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n        flag=false;\n        fill(area[0],area[104],0);\n    }\n\nreturn 0;\n}\n\nvoid solve(int x,int y,int c){\n    if(!blocks.empty()){\n    blocks.pop();\n    if(x==xg&&y==yg){\n        flag=true;\n        while(!blocks.empty())blocks.pop();\n    }else{\n        area[x][y]=0;\n        if(area[x-1][y]==c)blocks.push(make_pair(x-1,y));\n        if(area[x][y-1]==c)blocks.push(make_pair(x,y-1));\n        if(area[x+1][y]==c)blocks.push(make_pair(x+1,y));\n        if(area[x][y+1]==c)blocks.push(make_pair(x,y+1));\n        solve(blocks.front().first,blocks.front().second,c);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct P {\n\tint x, y;\n};\n\nint main() {\n\tint W, H;\n\twhile ( cin >> W >> H, W || H ) {\n\t\tint sx, sy; cin >> sx >> sy; --sx, --sy;\n\t\tint gx, gy; cin >> gx >> gy; --gx, --gy;\n\t\tint n; cin >> n;\n\t\tint m[5][100][100] = {0};\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, X, Y; cin >> c >> d >> X >> Y; --X, --Y, --c;\n\t\t\tint w, h;\n\t\t\tif (d == 0) w = 4, h = 2;\n\t\t\telse w = 2, h = 4;\n\t\t\tfor (int y = 0; y < h; ++y) {\n\t\t\t\tfor (int x = 0; x < w; ++x) {\n\t\t\t\t\tm[c][Y+y][X+x] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c = -1;\n\t\tfor (int i = 0; i < 5; ++i) {\n\t\t\tif (m[i][gy][gx]) c = i;\n\t\t}\n\t\tbool ans = false;\n\t\tif (c > -1) {\n\t\t\tqueue<P> Q; Q.push( (P){sx, sy} );\n\t\t\twhile ( !Q.empty() ) {\n\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\tif (p.x < 0 || p.x >= W || p.y < 0 || p.y >= H) continue;\n\t\t\t\tif (!m[c][p.y][p.x]) continue;\n\t\t\t\tm[c][p.y][p.x] = 0;\n\n\t\t\t\tif (p.x == gx && p.y == gy) {\n\t\t\t\t\tans = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tQ.push( (P){p.x+1, p.y} );\n\t\t\t\tQ.push( (P){p.x-1, p.y} );\n\t\t\t\tQ.push( (P){p.x, p.y+1} );\n\t\t\t\tQ.push( (P){p.x, p.y-1} );\n\t\t\t}\n\t\t}\n\t\tif (ans) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// WA.\n#include<iostream>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg;\nint mat[102][102];\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, 1, -1, 0};\n\nvoid init(){\n    for(int i = 0; i < 102; i++){\n        for(int j = 0; j < 102; j++){\n            mat[i][j] = 0;\n        }\n    }\n}\n\nbool bfs(){\n    int c = mat[xs][ys];\n    stack<pair<int,int>> s;\n    s.push({xs,ys});\n    bool visit[102][102] = {};\n    \n    while(!s.empty()){\n        pair<int,int> now = s.top(); \n        s.pop();\n        \n        if(now.first == xg && now.second == yg){\n            return true;\n        }\n        \n        visit[now.first][now.second] = true;\n        \n        for(int i = 0; i < 4; i++){\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n            \n            if(mat[nx][ny] == c && !visit[nx][ny]){\n                s.push({nx,ny});\n            }\n        }\n    }\n    \n    return false;\n}\n\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        cout << w << \" \" << h << endl;\n        if(w + h == 0)  break;\n        cin >> xs >> ys >> xg >> yg;\n        \n        init();\n        \n        int n;\n        cin >> n;\n        \n        int c, d, x, y;\n        while(n-- > 0){\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                for(int i = 0; i < 2; i++){\n                    for(int j = 0; j < 4; j++){\n                        mat[x+i][y+j] = c;\n                    }\n                }\n            }else if(d == 1){\n                for(int i = 0; i < 4; i++){\n                    for(int j = 0; j < 2; j++){\n                        mat[x+i][y+j] = c;\n                    }\n                }\n            }\n        }\n        \n        if(bfs())   cout << \"OK\" << endl;\n        else        cout << \"NG\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=0;\n      }\n    }\n    \n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\nif(F[xs][ys]==0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n  DFS(xs,ys,F[xs][ys]);\n\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[120][120] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y; di++){\n                for(int dj = x;dj < dw + x;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[120][120] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xg][yg] != C || C == 0)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(1 <= p.x && p.x <= w && 1 <= p.y && p.y <= h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        }\n/*\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<field[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl<<endl;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<vis[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        //cout<<C<<\"---\"<<field[xg][yg]<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool b;\n\nvoid dfs(const vector<vector<int> >& v ,int x , int y , int w , int h , int xg , int yg , int sc){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(v[tx][ty]!=sc || v[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( v , tx,ty,w,h,xg,yg,sc);\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tvector<vector<int> > board(101);\n\t\tfor(int i=0;i<101;++i) board[i].resize(101);\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(board ,xs,ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid setblock(int c, int d, int x, int y){\n  if(d==0){\n    for(int i=0;i<4;i++){\n      F[y][x+i]=c;\n      F[y+1][x+i]=c;\n    }\n  }else{\n    for(int i=0;i<4;i++){\n      F[y+i][x]=c;\n      F[y+i][x+1]=c;\n    }\n  }\n\n}\n\nvoid DFS(int Y, int X, int c){\n  if(F[Y][X]!=c)\n    return;\n\n  F[Y][X] = 6;\n\n  DFS(Y-1, X  ,c);\n  DFS(Y  , X+1,c);\n  DFS(Y+1, X  ,c);\n  DFS(Y  , X-1,c);\n}\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(true){\n  cin >> w >> h;\n  for(int i=0;i<h;i++){\n   for(int k=0;k<w;k++){\n     F[i][k]=-1;\n   }\n  }\n  if(w==0&&h==0){\n    break;\n  }\n  cin >> xs >> ys;\n  cin >> xg >> yg;\n  cin >> n;\n  for(int i=0; i<n; i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    setblock(c,d,x,y);\n  }\n\n  DFS(ys,xs,F[ys][xs]);\n  if(F[yg][xg]==6){\n    cout << \"OK\" << endl;\n  }else{\n    cout << \"NG\" << endl;\n  }\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == 7)\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[100][100]={0},v[100][100]={0};\nint root(int x,int y,int vmap[][100]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int i1=0;i1<100;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xx[4] = {0, 1, 0, -1};\nint yy[4] = {1, 0, -1, 0};\nint block[100][100];\nint already[100][100];\nint w, h;\nint xs, ys;\nint xg, yg;\nbool dfs(int nex, int ney);\n\nint main(){\n  int n;\n  \n  while(1){\n    memset(block, 0, sizeof(block));\n    memset(already, 0, sizeof(already));\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      int wide, high;\n      cin >> c >> d >> x >> y;\n      if(d){\n\twide = 2; high = 4;\n      }\n      else{\n\twide = 4; high = 2;\n      }\n      for(int j = 0; j < high; j++){\n\tfor(int k = 0; k < wide; k++){\n\t  block[y+j][x+k] = c;\n\t}\n      }\n    }\n    bool ans = false;\n    if(block[ys][xs] == block[yg][xg]){\n      ans = dfs(xs, ys);\n      if(ans) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int nex, int ney){\n  already[nex][ney] = 1;\n  if(nex == xg && ney == yg) return true;\n  for(int i = 0; i < 4; i++){\n    int nx = nex + xx[i];\n    int ny = ney + yy[i];\n    if(0 <= nx && 0 <= ny && ny < h && nx < w && !already[ny][nx] && block[ys][xs] == block[ny][nx]) return dfs(nx, ny);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define MAX 101\n\nusing namespace std;\n\nint field[MAX][MAX];\nbool went[MAX][MAX];\nint w, h;\nint sx, sy, gx, gy;\nint scol;\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nbool dfs(int x, int y) {\n\twent[y][x] = true;\n\tif(x == gx && y == gy) return true;\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx <= w && nx > 0 && ny <= h && ny > 0 && !went[ny][nx]) {\n\t\t\tif(field[ny][nx] == scol) dfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(went, false, sizeof(went));\n\t\tint n;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(i, n) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\trep(i, (d ? 4 : 2)) rep(j, (d ? 2 : 4)) field[y + i][x + j] = c;\n\t\t}\n\t\t/*rep(i, h) {\n\t\t\trep(j, w) cout << field[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tscol = field[sy][sx]; \n\t\tif(dfs(sx, sy) && scol != 0) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint field[101][101],b[101][101],X,Y,n,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},I,sX,sY,gX,gY,ans,sgc;\nint func(int x,int y){\n\tfor(I=0;I<4;I++){\n\t\tint xx=x+dx[I];\n\t\tint yy=y+dy[I];\n\t\tif(xx>0&&yy>0&&xx<=X&&yy<=Y&&field[xx][yy]==sgc&&b[xx][yy]==0){\n\t\t\tif(xx==gX&&yy==gY){\n\t\t\t\tif(ans==-1)ans=b[x][y];\n\t\t\t\telse ans=min(b[x][y]+1,ans);\n\t\t\t}\n\t\t\telse{\n\t\t\tb[xx][yy]=b[x][y]+1;\n\t\t\tfunc(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,i2,c,d,x,y;\n\tcin>>X>>Y;\n\twhile(X!=0){\n\t\tcin>>sX>>sY>>gX>>gY>>n;\n\t\tans=-1;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tc=0;\n\t\t\td=0;\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t\tfor(i2=1;i2<=100;i2++){\n\t\t\t\tfield[i][i2]=0;\n\t\t\t\tb[i][i2]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+2][y]=c;\n\t\t\t\tfield[x+3][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+2][y+1]=c;\n\t\t\t\tfield[x+3][y+1]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x][y+2]=c;\n\t\t\t\tfield[x][y+3]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+1][y+2]=c;\n\t\t\t\tfield[x+1][y+3]=c;\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++)cout<<field[i2][i];\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tsgc=field[sX][sY];\n\t\tfunc(sX,sY);\n\t\tif(ans==-1)cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\tcin>>X>>Y;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint map[110][110];\nint com[110][110];\nint lx,ly,sx,sy,gx,gy;\nint py[4]={1,0,-1,0};\nint px[4]={0,1,0,-1};\nint fl;\nint mei(int zx,int zy ,int cei[][110])\n{\n\tint i;\n\tif(zx==gx && zy==gy)\n\t{\n\t\tfl=1;\n\t\treturn 0;\n\t}\n\tcei[zy][zx]=1;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(cei[zy+py[i]][zx+px[i]]==0 && map[sy][sx]==map[zy+py[i]][zx+px[i]])\n\t\t{\n\t\t\tmei(zx+px[i],zy+py[i],cei);\n\t\t\tif(fl) return 0;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n,col,muk,vx,vy;\n\tint i,j,t;\n\twhile(cin >> lx >> ly, lx!=0 && ly!=0)\n\t{\n\t\tfl=0;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(com,0,sizeof(com));\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> col >> muk >> vx >> vy;\n\t\t\tif(muk==0)\n\t\t\t{\n\t\t\t\tfor(j=vy;j<2+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<4+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=vy;j<4+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<2+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmei(sx,sy,com);\n\t\tif(fl) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, j) FOR(i, 0, j)\n#define rep2(i, k) for(int i = 1; i <= k; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define INF (1 << 30)\n\nusing namespace std;\n \nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint field[105][105], use[105][105];\nint h, w, sx, sy, gx, gy, n;\nint scol;\n\nvoid make_map(int x,int y,int chk,int color){\n  if(chk == 0){\n    for(int i=y;i<y+2;i++){\n      for(int j=x;j<x+4;j++) field[i][j] = color;\n    }\n  }\n  else {\n    for(int i=y;i<y+4;i++){\n      for(int j=x;j<x+2;j++) field[i][j] = color;\n    }\n  }\n}\n\nbool dfs(int x,int y){\n  use[y][x] = true;\n  if(x == gx && y == gy) return true;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h && field[ny][nx] == field[sy][sx] && !use[ny][nx]) dfs(nx,ny);\n  }\n  return use[gy][gx];\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(use, false, sizeof(use));\n\t\tint scol = 0;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\t--sx; --sy; --gx; --gy;\n\t\tcin >> n;\n\t\twhile(n--){\n     \t\tint c,d,x,y; cin >> c >> d >> x >> y; --x; --y;\n      \t\tmake_map(x,y,d,c);\n    \t}\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=9;\n\tDFScolor(X-1,Y,color);\n\tDFScolor(X,Y+1,color);\n\tDFScolor(X+1,Y,color);\n\tDFScolor(X,Y-1,color);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==9)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,a,n,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]){\n\t\t\tif(block(Y,X)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\nstatic const int dx[4] = {1, 0, -1, 0};\nstatic const int dy[4] = {0, -1, 0, 1};\nint w, h, sx, sy, gx, gy, G[MAX+2][MAX+2];\nbool dfs( int x, int y, int color ){\nif ( color == 0 || G[x][y] != color ) return false;\nif ( x == gx && y == gy ) return true;\nG[x][y] = 0;\nfor ( int r = 0; r < 4; r++ ){\nif ( dfs(x + dx[r], y + dy[r], color) ) return true;\n}\nreturn false;\n}\nmain(){\nint n, c, d, px, py, ww, hh;\nwhile( cin >> w >> h && w ){\ncin >> sx >> sy >> gx >> gy >> n;\nfor ( int y = 0; y < h+2; y++ )\nfor ( int x = 0; x < w+2; x++ ) G[x][y] = 0;\nfor ( int i = 1; i <=n; i++ ){\ncin >> c >> d >> px >> py;\nif ( d == 0 ) { ww = 4; hh = 2; }\nelse { ww = 2; hh = 4; }\nfor ( int y = 0; y <= hh-1; y++ )\nfor ( int x = 0; x <= ww-1; x++ ) G[px+x][py+y] = c;\n}\nif ( dfs(sx, sy, G[sx][sy]) ) cout << \"OK\" << endl;\nelse cout << \"NG\" << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\nbool MazeJudge;\nint xg,yg;\n\nchar ItoC(int i){\n\tif(i==1){\n\t\treturn '1';\n\t}else if(i==2){\n\t\treturn '2';\n\t}else if(i==3){\n\t\treturn '3';\n\t}else if(i==4){\n\t\treturn '4';\n\t}else if(i==5){\n\t\treturn '5';\n\t}\n}\n\nvoid DFS(int X,int Y,char C)\n{\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\tF[X][Y] = '.';\n\n\tif(X==xg&&Y==yg){\n\t\tMazeJudge = true;\n\t\treturn;\n\t}\n\t\n\tDFS(X-1,Y  ,C);\n\tDFS(X  ,Y+1,C);\n\tDFS(X+1,Y  ,C);\n\tDFS(X  ,Y-1,C);\n}\n\t\n\nint main()\n{\n\twhile(true){\n\n\t\t//デバッグ用迷路表示\n\t\t/*for(int j=0;j<102;j++){\n\t\t\tfor(int i=0;i<102;i++){\n\t\t\t\tF[i][j] = '0';\n\t\t\t}\n\t\t}*/\n\n\t\tMazeJudge = false;\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tint xs,ys;\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n    \t\t\tchar color = ItoC(c);\n\t\t\tif(d==0){\n\t\t\t\tF[x  ][y  ] = color;\n\t\t\t\tF[x+1][y  ] = color;\n\t\t\t\tF[x+2][y  ] = color;\n\t\t\t\tF[x+3][y  ] = color;\n\t\t\t\tF[x  ][y+1] = color;\n\t\t\t\tF[x+1][y+1] = color;\n\t\t\t\tF[x+2][y+1] = color;\n\t\t\t\tF[x+3][y+1] = color;\n\t\t\t}else if(d==1){\n\t\t\t\tF[x  ][y  ] = color;\n\t\t\t\tF[x+1][y  ] = color;\n\t\t\t\tF[x  ][y+1] = color;\n\t\t\t\tF[x+1][y+1] = color;\n\t\t\t\tF[x  ][y+2] = color;\n\t\t\t\tF[x+1][y+2] = color;\n\t\t\t\tF[x  ][y+3] = color;\n\t\t\t\tF[x+1][y+3] = color;\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//デバッグ用迷路表示\n\t\t/*for(int j=0;j<102;j++){\n\t\t\tfor(int i=0;i<102;i++){\n\t\t\t\tcout << F[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tchar rc = F[xs][ys];\n\t\tDFS(xs,ys,rc);\n\t\tif(MazeJudge==true){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else if(MazeJudge==false){\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nvoid putblock(int x,int y,int c,int d);\nbool bfs(std::pair<int,int> start,std::pair<int,int> goal);\n\nstd::queue< std::pair<int,int> > que;\nint board[102][102];\nbool visited[102][102];\n\nint main()\n{\n\tint n,w,h,x,y,c,d,xs,ys,xg,yg;\n\t\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tmemset(board,0,sizeof(board));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tputblock(x,y,c,d);\n\t\t}\n\t\tif(bfs(std::pair<int,int>(xs,ys),std::pair<int,int>(xg,yg)))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid putblock(int x,int y,int c,int d)\n{\n\tint h,w;\n\tif(d==0)\n\t{\n\t\th=2;\n\t\tw=4;\n\t}\n\telse\n\t{\n\t\th=4;\n\t\tw=2;\n\t}\n\tfor(int i=y;i<y+h;i++)\n\t{\n\t\tfor(int j=x;j<x+w;j++)\n\t\t{\n\t\t\tboard[i][j]=c;\n\t\t}\n\t}\n}\n\nbool bfs(std::pair<int,int> start,std::pair<int,int> goal)\n{\n\tint x,y;\n\tif(board[start.second][start.first]==0||board[goal.second][goal.first]==0)return false;\n\tque.push(start);\n\twhile(!que.empty())\n\t{\n\t\tx=que.front().first;\n\t\ty=que.front().second;\n\t\tque.pop();\n\n\t\tif(!visited[y][x])\n\t\t{\n\t\t\tvisited[y][x]=true;\n\t\t\tif(board[y-1][x]==board[y][x])que.push(std::pair<int,int>(x-1,y));\n\t\t\tif(board[y+1][x]==board[y][x])que.push(std::pair<int,int>(x+1,y));\n\t\t\tif(board[y][x-1]==board[y][x])que.push(std::pair<int,int>(x,y-1));\n\t\t\tif(board[y][x+1]==board[y][x])que.push(std::pair<int,int>(x,y+1));\n\n\t\t\tif(x==goal.first&&y==goal.second)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n\n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n        \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            g[y][x] = 8;\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main(){ \n    while(cin >> weight >> hight){\n        if(weight == 0 && hight == 0){\n            break;\n        }\n        \n        int dn, c, d, x, y;\n        flag = false;\n        g[101][101] = {};\n        \n        cin >> sx >> sy >> gx >> gy >> dn;\n        \n        for(int i = 0;i < dn;i++){\n            cin >> c >> d >> x >> y;\n            \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n        \n        sc = g[sy][sx];\n        dfs(sx, sy);\n        \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint needleX[4] = {-1, 0, 1, 0};\nint needleY[4] = {0, 1, 0, -1};\n\nbool dfs(int x, int y, int goalx, int goaly,vector<vector<int> >& canGo){\n\n    //??´??????????????????????????????true\n    if(x == goalx && y == goaly){ return true; }\n\n    //???????????°????????¢?´¢???????????????\n    canGo[x][y] = false;\n\n    //???????????????????????¢?´¢\n    for(int i = 0; i < 4; i++){\n        int nextx = x + needleX[i];\n        int nexty = y + needleY[i];\n\n        //?????????????????????\n        if(canGo[nextx][nexty]){\n            bool flag = dfs(nextx, nexty, goalx, goaly, canGo);\n            if(flag){\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nint block(int w, int h){\n\n    //0 0??§??????\n    if(w == 0 && h == 0){return 0;}\n\n    //??????????????±??\\???\n    int xs, ys, xg, yg;\n    int n;\n    int c, d, inputX, inputY;\n    vector<vector<int> > canGo(h + 2, vector<int>(w + 2, 0));\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n\n    //??????????????????\n    for(int i = 1; i <= n; i++){\n        cin >> c >> d >> inputX >> inputY;\n        if(d == 0){\n            for(int j = 0; j < 4; j++){\n                for(int k = 0; k < 2; k++){\n                    canGo[inputY + k][inputX + j] = c;\n                }\n            }\n        }else{\n            for(int j = 0; j < 2; j++){\n                for(int k = 0; k < 4; k++){\n                    canGo[inputY + k][inputX + j] = c;\n                }\n            }\n        }   \n    }\n    /*??????????????¨???\n    cout << canGo[ys][xs] << endl;\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            cout << canGo[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n    */\n\n    //????????????bool????????¨?????????\n    int load = canGo[ys][xs];\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            if(canGo[i][j] == load){\n                canGo[i][j] = 1;\n            }else{\n                canGo[i][j] = 0;\n            }\n        }\n    }\n    \n    // ??±???????????¢?´¢????????????????????????\n    bool result = dfs(xs,ys,xg,yg,canGo);\n    if(result){\n        return 1;\n    }else{\n        return 2;\n    }\n\n    \n}\n\nint main(void){\n    int i = 0;\n    int array[30];\n    int w, h;\n    while(1){\n        cin >> w >> h;\n        array[i] = block(w, h);\n        if(array[i] == 0){break;}\n        i++;\n    }\n    for(int j = 0; j < i; j++){\n        if(array[j] == 1){cout << \"OK\" << endl;}\n        else {cout << \"NG\" << endl;}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nchar start;\nvoid fun(int y,int x){\n    if(map[y][x]==start){\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y][x]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+1);\n    fun(y,x-1);\n    fun(y+1,x);\n    fun(y-1,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        start=map[ys][xs];\n        if(map[ys][xs]==0||map[yg][xg]==0);\n        else\n        \tfun(ys,xs);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { 1, 0, -1, 0 };\n\nconst int ax[2][8] = {\n\t{0, 1, 2, 3, 0, 1, 2, 3},\n\t{0, 0, 0, 0, 1, 1, 1, 1}\n};\n\nconst int ay[2][8] = {\n\t{0, 0, 0, 0, 1, 1, 1, 1},\n\t{0, 1, 2, 3, 0, 1, 2, 3}\n};\n\nint W, H, sx, sy, gx, gy, n, board[110][110];\n\nbool dfs(int x, int y) {\n\tif (x == gx && y == gy) return true;\n\tint c = board[y][x];\n\tboard[y][x] = -1;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 1 || W <= nx || ny < 1 || H <= ny) continue;\n\t\tif (board[ny][nx] != c) continue;\n\t\tif (dfs(nx, ny)) return true;\n\t}\n\t\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tmemset(board, -1, sizeof(board));\n\t\t\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor_(a,0,8) board[y + ay[d][a]][x + ax[d][a]] = c;\n\t\t}\n\t\t\n\t\tif (board[sy][sx] != -1 && dfs(sx, sy)) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n#define  MAX 100\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint field[MAX][MAX]; \nint w,h;\nint xs,ys,xg,yg;\nint n;\nint color;\nbool flag = false;\n\nvoid blockset(int a,int b,int xx,int yy){\n\tif(b == 0){\n\t\tfield[yy][xx] = a;\t\n\t\tfield[yy][xx+1] = a;\t\n\t\tfield[yy][xx+2] = a;\t\n\t\tfield[yy][xx+3] = a;\t\n\t\tfield[yy+1][xx] = a;\t\n\t\tfield[yy+1][xx+1] = a;\t\n\t\tfield[yy+1][xx+2] = a;\t\n\t\tfield[yy+1][xx+3] = a;\t\n\t}else if(b == 1){\n\t\tfield[yy][xx] = a;\t\n\t\tfield[yy+1][xx] = a;\t\n\t\tfield[yy+2][xx] = a;\t\n\t\tfield[yy+3][xx] = a;\t\n\t\tfield[yy][xx+1] = a;\t\n\t\tfield[yy+1][xx+1] = a;\t\n\t\tfield[yy+2][xx+1] = a;\t\n\t\tfield[yy+3][xx+1] = a;\n\t}\n}\n\nvoid dfs(int x,int y){\n\tfield[y][x] = 0;\n\t\n\tif(x == xg && y == yg){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h){\n\t\t\tcontinue;\n\t\t}else if(field[ny][nx] == color){\n\t\t\tdfs(nx,ny);\n\t\t} \n\t}\n\t\n\t\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--;\n\t\tys--;\n\t\txg--;\n\t\tyg--;\n\t\tcin >> n;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tblockset(c,d,x,y);\n\t\t}\n\t\tcolor = field[ys][xs];\n\t\tflag = false;\n\t\tif(color)dfs(xs,ys);\n\n\t\tif(flag){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nchar start;\nvoid fun(int y,int x){\n    if(map[y][x]==start){\n    \tcout << 1 << endl;\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y][x]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+1);\n    fun(y,x-1);\n    fun(y+1,x);\n    fun(y-1,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        start=map[ys][xs];\n        if(map[ys][xs]==0||map[yg][xg]==0);\n        else\n        \tfun(ys,xs);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\tusing namespace std;\n\tint xs,ys,w,h,n,ban[111][111],xg,yg;bool visited[101][101];\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(c-1||ban[x][y]!=c)return false;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x+1][y]==false){\n\t\t\tvisited[x+1][y]=true;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y+1]==false){\n\t\t\tvisited[x][y+1]=true;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][ys]&&visited[x-1][y]==false){\n\t\t\tvisited[x-1][y]=true;\n\t\t\tif(dfs(x-1,y,c))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][ys]&&visited[x][y-1]==false){\n\t\t\tvisited[x][y-1]=true;\n\t\t\tif(dfs(x,y-1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool dfs(int xs,int ys,int xg,int yg,vector<vector<bool> >& canGo){\ncanGo[xs][ys]=false;\nif(xs==xg&&ys==yg)return true;\nif(canGo[xs+1][ys]){if(dfs(xs+1,ys,xg,yg,canGo))return true;}\nif(canGo[xs-1][ys]){if(dfs(xs-1,ys,xg,yg,canGo))return true;}\nif(canGo[xs][ys+1]){if(dfs(xs,ys+1,xg,yg,canGo))return true;}\nif(canGo[xs][ys-1]){if(dfs(xs,ys-1,xg,yg,canGo))return true;}\nreturn false;\n}\nint main(void){\nint w,h,xs,ys,xg,yg,n;\nbool ans;\nvector<vector<bool> > blockmap;\nwhile(true){\ncin>>w>>h;\nif(w==0&&h==0)break;\ncin>>xs>>ys>>xg>>yg>>n;\nblockmap=vector<vector<bool> >(w+2,vector<bool>(h+2,false));\nfor(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin>>c>>d>>x>>y;\n    if(c==2){\n        blockmap[x+1][y+1]=true;\n        blockmap[x+2][y+1]=true;\n        blockmap[x+1][y+2]=true;\n        blockmap[x+2][y+2]=true;\n        if(d==0){\n            blockmap[x+3][y+1]=true;\n            blockmap[x+3][y+2]=true;\n            blockmap[x+4][y+1]=true;\n            blockmap[x+4][y+2]=true;\n        }\n        else {\n            blockmap[x+1][y+2]=true;\n            blockmap[x+2][y+3]=true;\n            blockmap[x+1][y+4]=true;\n            blockmap[x+2][y+4]=true;\n        }\n    }\n}\nans=dfs(xs+1,ys+1,xg+1,yg+1,blockmap);\nif(ans)cout<<\"OK\"<<endl;\nelse cout<<\"NG\"<<endl;\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint board[100][100],w,h,xg,yg;\nbool f(int y,int x){\n\tboard[y][x] = 0;\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\tif(y == yg - 1 && x == xg -1) return true;\n\tfor(i = 0;i < 4;i++){\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\t\t\tif(board[y+dy[i]][x+dx[i]] == 2){\n\t\t\t\tif(f(y+dy[i],x+dx[i])) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint xs,ys,n,i,c,d,x,y,j,k;\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx -= 1;\n\t\t\ty -= 1;\n\t\t\tif(d == 0){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(board[y - 1][x - 1] == 2){\n\t\t\tif(f(ys - 1,xs -1)) cout << \"OK\" << endl;\n\t\t\telse cout << \"NG\" << endl;\n\t\t}\n\t\telse cout << \"NG\" << endl;\n\t\tfor(j = 0;j < 100;j++){\n\t\t\tfor(i = 0;i < 100;i++){\n\t\t\t\tboard[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint main(){\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tw+=2, h+=2;\n\t\tvector<vi> v(h, vi(w, 0));\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\twhile(n--){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint bw = d?2:4;\n\t\t\tint bh = d?4:2;\n\t\t\trep(i, bh) rep(j, bw) v[y+i][x+j] = c;\n\t\t}\n\n\t\tqueue<P> q;\n\t\tq.push(MP(xs, ys));\n\t\tint c = v[ys][xs];\n\t\tbool ok = false;\n\t\tif(c) while(!q.empty()){\n\t\t\tP p = q.front();\n\t\t\tq.pop();\n\n\t\t\tif(v[p.Y][p.X] != c) continue;\n\t\t\tv[p.Y][p.X] = 0;\n\n\t\t\tif(p == MP(xg, yg)){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint x = p.X + dx[i];\n\t\t\t\tint y = p.Y + dy[i];\n\t\t\t\tq.push(MP(x, y));\n\t\t\t}\n\t\t}\n\t\tcout << (ok?\"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    return;\n  if(F[Y][X] != c || Y > w || X > h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 0;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing V = vector<int>;\nusing VV = vector<V>;\nusing P = pair<int, int>;\n\nint main() {\n\tint dx[] = {4, 2}, dy[] = {2, 4};\n\tfor (int w, h; w = in(), h = in();) {\n\t\tP s = {in() - 1, in() - 1}, g = {in() - 1, in() - 1};\n\t\tint n = in();\n\t\tVV m(h, V(w));\n\t\twhile (n--) {\n\t\t\tint c = in(), d = in(), x = in() - 1, y = in() - 1;\n\t\t\tfor (int i = 0; i < dy[d]; i++)\n\t\t\t\tfor (int j = 0; j < dx[d]; j++)\n\t\t\t\t\tm[i + y][j + x] = c;\n\t\t}\n\t\tfunction<bool(int, int, int)> f = [&](int x, int y, int c) {\n\t\t\tif (x == g.first && y == g.second)\n\t\t\t\treturn true;\n\t\t\tint dx = 1, dy = 0;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = x + dx, ty = y + dy;\n\t\t\t\tif (tx >= 0 && ty >= 0 && tx < w && ty < h && m[ty][tx] == c) {\n\t\t\t\t\tm[ty][tx] = 0;\n\t\t\t\t\tif (f(tx, ty, c))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswap(dx, dy *= -1);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tint c = m[s.second][s.first];\n\t\tm[s.second][s.first] = 0;\n\t\toutl(c ? f(s.first, s.second, c) ? \"OK\" : \"NG\" : \"NG\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint f[200][200];\nint v[200][200];\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint xs,ys,xg,yg;\n\t\tscanf(\"%d%d%d%d\",&xs,&ys,&xg,&yg);\n\t\txs--;ys--;xg--;yg--;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<200;i++)\n\t\t\tfor(int j=0;j<200;j++)\n\t\t\t\tf[i][j]=v[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint p,q,r,s;scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tr--;s--;\n\t\t\tif(q==0){\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tfor(int k=0;k<2;k++)\n\t\t\t\t\t\tf[r+j][s+k]=p;\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\tf[r+j][s+k]=p;\n\t\t\t}\n\t\t}\n\t\tif(f[xs][ys]!=f[xg][yg]||!f[xs][ys]){\n\t\t\tprintf(\"NG\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<pair<int,int> >Q;\n\t\tv[xs][ys]=1;\n\t\tQ.push(make_pair(xs,ys));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&!v[row+dx[i]][col+dy[i]]&&f[row+dx[i]][col+dy[i]]==f[row][col]){\n\t\t\t\t\tv[row+dx[i]][col+dy[i]]=1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v[xg][yg])printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint table[100][100];\nint memo[100][100];\n\nint w, h;\nint xs, ys, xg, yg;\nint n;\n\nvoid solve(int xs, int ys, int c)\n{\n\tif( memo[xs][ys] ) {\n\t\treturn;\n\t}\n\n\tif( !( -1 < xs && xs < w && -1 < ys && ys < h && table[xs][ys] == c ) ) {\n\t\tmemo[xs][ys] = 1;\n\t\treturn;\n\t}\n\t\n\tif( xs == xg && ys == yg ) {\n\t\tmemo[xs][ys] = 1;\n\t\tcout << \"OK\" << endl;\n\t\tthrow \"OK\";\n\t}\n\n\tmemo[xs][ys] = 1;\t\n\n\tsolve(xs+1, ys, c);\n\tsolve(xs, ys+1, c);\t\n\tsolve(xs-1, ys, c);\n\tsolve(xs, ys-1, c);\n\n\treturn;\n}\n\nint main(int argc, char* argv[])\n{\n\twhile(1) {\n\n\t\tfor( int i = 0; i < 100; i++ ) {\n\t\t\tfor( int j = 0; j < 100; j++ ) {\n\t\t\t\ttable[i][j] = 0;\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t}\t\t\n\n\t\tcin >> w >> h;\n\n\t\tif( w == 0 && h == 0 )\n\t\t\tbreak;\n\t\t\t\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor( int i = 0; i < n; i++ ) {\n\n\t\t\tint c; cin >> c;\n\t\t\tint d; cin >> d;\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\tif( d == 0 ) {\n\n\t\t\t\ttable[x][y] = c;\n\t\t\t\ttable[x][y+1] = c;\n\n\t\t\t\ttable[x+1][y] = c;\n\t\t\t\ttable[x+1][y+1] = c;\n\n\t\t\t\ttable[x+2][y] = c;\n\t\t\t\ttable[x+2][y+1] = c;\n\n\t\t\t\ttable[x+3][y] = c;\n\t\t\t\ttable[x+3][y+1] = c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\n\n\t\t\t} else {\n\n\t\t\t\ttable[x][y] = c;\n\t\t\t\ttable[x+1][y] = c;\n\n\t\t\t\ttable[x][y+1] = c;\n\t\t\t\ttable[x+1][y+1] = c;\n\n\t\t\t\ttable[x][y+2] = c;\n\t\t\t\ttable[x+1][y+2] = c;\n\t\t\t\t\n\t\t\t\ttable[x][y+3] = c;\n\t\t\t\ttable[x+1][y+3] = c;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif( table[xs][ys] )\n\t\t\t\tsolve(xs, ys, table[xs][ys]);\n\t\t\tcout << \"NG\" << endl;\n\t\t} catch(...) {\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 0 || F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\n \nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = -1;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n \n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 1919810;\n      }\n    }\n \n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n \n    int n;\n    cin >> n;\n \n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n \n    meiro(xs,ys,C[xs][ys]);\n \n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint fie[102][102];\nint check[102][102];\ntypedef struct state{\n  int x;\n  int y;\n  int cost;\n  state(int x,int y,int cost):x(x),y(y),cost(cost){}\n};\nint w,h;\nint xg,yg;\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvoid makefie(int c,int d,int x,int y){\n  int xm=0,ym=0;\n  //cout << \"oo\";\n  //fflush(stdout);\n  if(d){ xm=2; ym=4;}\n  else{ xm=4; ym=2;}\n  for(int i=x; i < x+xm; i++){\n    for(int j=y; j < y+ym; j++)\n      fie[i][j]=c;\n  }\n  //  cout << \"ee\";\n  // fflush(stdout);\n}\nint solve(int x,int y,int c){\n  queue <state> q;\n  q.push( state(x,y,0) );\n  // cout << x << \" \" << y << \" \"<<endl;\n  while(!q.empty()){\n    state p = q.front(); q.pop();\n    int cost = p.cost;\n    for(int i=0;i<4;i++){\n      int nx=p.x+dx[i];\n      int ny=p.y+dy[i];\n      if(nx <= 0 || nx >w || ny <= 0 || ny>=h) continue;\n      if(fie[nx][ny]!=c) continue;\n      if(nx==xg && ny==yg) return 1;\n      if(check[nx][ny]!=-1) continue;\n      check[nx][ny]=cost+1;\n      q.push( state(nx,ny,cost+1) );\n      //  cout << nx << \" \" << ny << \" \"<< cost+1<<endl;\n    }\n  }\n  return 0;\n}\nmain(){\n  int n;\n  int xs,ys;\n  while(1){\n    cin >> w >>h;\n    if(w==0 && h==0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    memset(fie,0,sizeof(fie));\n    memset(check,-1,sizeof(check));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      makefie(c,d,x,y);\n    }\n\n    int res=solve(xs,ys,fie[xs][ys]);\n    if(res) cout << \"OK\" <<endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX_H 100\n#define MAX_W 100\n#define INF 1000;\nint h,w;\nint field[MAX_H+1][MAX_W+1];\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nvoid dfs(int y,int x,const int sc){\n\tif(y<=0 || x<=0 || y>h || x>w)return;\n\tif(field[y][x]==sc){\n\t\tfield[y][x]=0;\n\t\tfor(int i=0;i<4;i++)dfs(y+dy[i],x+dx[i],sc);\n\t}\n\treturn;\n}\nint main(){\n\tint sx,sy,gx,gy,n;\n\twhile(cin>>w>>h){\n        if(!w && !h)break;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=0;i<MAX_H;i++){\n\t\t\tfor(int j=0;j<MAX_W;j++){\n\t\t\t\t\tfield[i][j]=INF;\n\t\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tif(d)field[y+j][x+i]=c;\n\t\t\t\t\telse field[y+i][x+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sy,sx,field[sy][sx]);\n\t\tif(field[gy][gx])cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint map[150][150]={};\nint gone[150][150];\n\nint gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nbool dfs(int nx,int ny){\n\tif(gone[nx][ny])return false;\n\tgone[nx][ny]=1;\n\tif(nx == gx && ny == gy)return true;\n\tbool res = false;\n\trep(i,4){\n\t\tint tx = nx+dx[i],ty=ny+dy[i];\n\t\tif(map[tx][ty]!=map[nx][ny])continue;\n\t\tres |= dfs(tx,ty);\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint w,h;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tint sx,sy,n;\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\tmemset(map,0,sizeof(map));\n\t\trep(i,n){\n\t\t\tint c,d,nx,ny;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&nx,&ny);\n\t\t\tint fx=2,fy=4;\n\t\t\tif(d==0)swap(fx,fy);\n\t\t\trep(x,fx)rep(y,fy){\n\t\t\t\tmap[x+nx][y+ny]=c;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(y,20)rep(x,20){\n\t\t\tprintf(\"%d%c\",map[x][y],x==19?'\\n':' ');\n\t\t}*/\n\t\tif(dfs(sx,sy))printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    goal=0;\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==0 && h==0)break;\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    else if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  if(gx==sx && gy==sy)cout<<\"OK\"<<endl;\n\n  else if(scolor==mass[gy][gx]){\n  \n    solve();\n    \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n    }\n  }\n  else {\n    cout<<\"NG\"<<endl;\n  }\n\n  }\n  \n  return 0;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n\n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n        \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            g[y][x] = 8;\n            dfs(nx, ny);\n        }\n    }\n}\n\nint main(){ \n    while(1){\n        cin >> weight >> hight;\n\n        if(weight == 0 && hight == 0){\n            break;\n        }\n        \n        int dn, c, d, x, y;\n        flag = false;\n        g[101][101] = {};\n        \n        cin >> sx >> sy >> gx >> gy >> dn;\n        \n        for(int i = 0;i < dn;i++){\n            cin >> c >> d >> x >> y;\n            \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n        \n        sc = g[sy][sx];\n        dfs(sx, sy);\n        \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define rep(i, a, b) for(int i = a; i < b; i ++)\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint map[100][100] = {0};\nint map2[100][100] = {0};\nvoid exp(int x, int y, int c) {\n  if(x <= 0 || w <= x || y <= 0 || h <= y) return;\n  if(map[x][y] != c || map2[x][y] == 1) return;\n\n  map2[x][y] = 1;\n\n  exp(x-1, y, c);\n  exp(x+1, y, c);\n  exp(x, y-1, c);\n  exp(x, y+1, c);\n\n  return;\n}\n\nint main() {\n  while(cin >> w >> h >> xs >> ys >> xg >> yg >> n, w) {\n    rep(i, 0, h) {\n      rep(j, 0, w) {\n\tmap[j][i] = 0;\n\tmap2[j][i] = 0;\n      }\n    }\n\n    int block[4];\n    int start[4];\n    rep(i, 0, n) {\n      rep(lp, 0, 4) {\n\tcin >> block[lp];\n      }\n\n      switch(block[1]) {\n      case(0):\n\trep(y, 0, 2) {\n\t  rep(x, 0, 4) {\n\t    map[block[2]+x][block[3]+y] = block[0];\n\t  }\n\t}\n\tbreak;\n      case(1):\n\trep(y, 0, 4) {\n\t  rep(x, 0, 2) {\n\t    map[block[2]+x][block[3]+y] = block[0];\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    if(map[xs][ys] == 0 || map[xg][yg] == 0 || map[xs][ys] != map[xg][yg]) {\n      cout << \"NG\" << endl;\n    }\n    else {\n      exp(xs, ys, map[xs][ys]);\n      cout << ((map2[xg][yg] == 1)?(\"OK\"):(\"NG\")) << endl;\n    }\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n    if (d == 0)//yokonaga\n    {\n        loop(i, 2)\n        {\n            loop(j, 4)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n    else//tatenaga\n    {\n        loop(i, 4)\n        {\n            loop(j, 2)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n}\n    bool a=false;\nbool dfs(int nx, int ny)\n{\n    if (nx == gx&&ny == gy)return true;\n    if (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n    grid_visited[nx][ny] = true;\n    if(nx+1 >= 0 && ny >= 0 && nx+1 < h && ny < w)if(grid[nx + 1][ny]== grid[nx][ny])a|=dfs(nx + 1, ny);\n    if(nx >= 0 && ny+1 >= 0 && nx < h && ny+1 < w)if(grid[nx][ny+1]== grid[nx][ny])a|=dfs(nx, ny+1);\n    if(nx-1 >= 0 && ny >= 0 && nx-1 < h && ny < w)if(grid[nx - 1][ny]== grid[nx][ny])a|=dfs(nx - 1, ny);\n    if(nx >= 0 && ny-1 >= 0 && nx < h && ny-1 < w)if(grid[nx][ny-1]== grid[nx][ny])a|=dfs(nx, ny-1);\n    //return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n    return a;\n    return false;\n}\nint main()\n{\n    while (1)\n    {\n        cin >> w >> h;\n        if (!w && !h) break;\n        else\n        {\n            cin >> sx >> sy >> gx >> gy >> n;\n            sx--; sy--; gx--; gy--;\n            loop(i, n)\n            {\n                int c, d, x, y;\n                cin >> c >> d >> x >> y;\n                x--; y--;\n                input(c, d, x, y);\n            }\n            /*loop(i, h)\n            {\n                loop(j, w)\n                {\n                    cout << grid[i][j] << \" \";\n                }\n                cout << endl;\n            }*/\n            a=false;\n            \n            cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nint t[200][200];\nint gxx,gyy;\nint dfs(int x,int y,int c){\n\tif( t[y][x] != c ) return false;\n\tif( y == gyy && x == gxx) {\n\t\treturn true;\n\t}\n\tt[y][x] = 0;\n\tif( dfs(x+1,y,c) ) return true;\n\tif( dfs(x-1,y,c) ) return true;\n\tif( dfs(x+0,y-1,c) ) return true;\n\tif( dfs(x+0,y+1,c) ) return true;\n\t\n\treturn false;\n\n}\nint main(){\n\tint w,h;\n\twhile(cin >> w >> h && w ){\n\t\tmemset(t,0,sizeof(t));\n\t\tint xs,ys,xg,yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tgxx = xg;\n\t\tgyy = yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int _ = 0 ; _ < n ; _++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\trep(i,2)rep(j,4) t[y+i][x+j] = c;\n\t\t\t}else{\n\t\t\t\trep(i,4)rep(j,2) t[y+i][x+j] = c;\n\t\t\t}\n\t\t}\n\t\tif( t[ys][xs] == 0 ){\n\t\t\tcout << \"NG\" << endl;\n\t\t}else{\n\t\t\tcout << (dfs(xs,ys,t[ys][xs])?\"OK\":\"NG\") << endl;\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n\n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n        \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            g[y][x] = 8;\n            dfs(nx, ny);\n        }\n    }\n}\n\nvoid disp(){\n    for(int i = 0;i < hight;i++){\n        for(int j = 0;j < weight;j++){\n            cout << g[i][j];\n        }cout << endl;\n    }\n}\n\nint main(){\n    int dn, c, d, x, y;\n    \n    while(cin >> weight >> hight){\n        if(weight == 0 && hight == 0){\n            break;\n        }\n        \n        g[101][101] = {};\n        \n        cin >> sx >> sy >> gx >> gy >> dn;\n        \n        for(int i = 0;i < dn;i++){\n            cin >> c >> d >> x >> y;\n            \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n        \n        sc = g[sy][sx];\n        flag = false;\n        dfs(sx, sy);\n        \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint w,h;\nint masu[100][100];\nint uramasu[100][100];\nint stx,sty;\nint gox,goy;\nint flg;\n\nvoid saiki(int x,int y,int col){\n\t\n\tif(x==gox && y==goy){\n\t\tflg=1;\n\t}\n\t\n\tif(x+1<w && masu[x+1][y]==col && uramasu[x+1][y]==0){\n\t\turamasu[x+1][y]=1;\n\t\tsaiki(x+1,y,col);\n\t}\n\t\n\tif(y+1<h && masu[x][y+1]==col && uramasu[x][y+1]==0){\n\t\turamasu[x][y+1]=1;\n\t\tsaiki(x,y+1,col);\n\t}\n\t\n\tif(x-1>=0 && masu[x-1][y]==col && uramasu[x-1][y]==0){\n\t\turamasu[x-1][y]=1;\n\t\tsaiki(x-1,y,col);\n\t}\n\t\n\tif(y-1>=0 && masu[x][y-1]==col && uramasu[x][y-1]==0){\n\t\turamasu[x][y-1]=1;\n\t\tsaiki(x,y-1,col);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tflg=0;\n\t\tif(w==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d%d\",&stx,&sty);\n\t\tscanf(\"%d%d\",&gox,&goy);\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\t\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\turamasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tswitch(d){\n\t\t\t\tcase 0:\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tmasu[i+x][j+y]=c;\n\t\t\t\t\t}\n\t\t\t\t}break;\n\t\t\t\t\n\t\t\t\tcase 1:\n\t\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tmasu[i+x][j+y]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(masu[stx][sty]!=0){\n\t\t\tsaiki(stx,sty,masu[stx][sty]);\n\t\t\tmasu[stx][sty]=8;\n\t\t}\n\t\t\n\t\tif(flg==0){\n\t\t\tputs(\"NG\");\n\t\t}else{\n\t\t\tputs(\"OK\");\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=-1;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n  int goal_x,goal_y;\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        b.mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\n\nvoid Maze(int X,int Y,int C){\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\tif(X==xg&&Y==yg)\n\t\tcout << \"OK\"<<endl;\n\t\treturn;\n\n\n\tF[X][Y]='.';\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\n\tcout <<\"NG\"<<endl;\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tint N=0;\n\t\twhile(N<n){\n\t\t\tcin >>c>>d>>x>>y;\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++)\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++)\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t}\n\t\t\tN++;\n\t\t}\n\t\t\t//for(int i=1; i<=h; i++){\n\t\t\t\t\t//for(int j=1; j<=w; j++){\n\t\t\t\t\t\t//cout <<F[j][i];\n\t\t\t\t\t//}\n\t\t\t\t//cout << endl;\n\t\t\t//}\n\t\t\n\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n\n#define MAX 110\n\nint map[MAX][MAX];\n\nvoid makemap(int c, int d, int x, int y);\n\nint bfs(int xs,int ys,int xg,int yg);\n\nint main()\n{\n\tint w,h,xs,ys,xg,yg,n,c,d,x,y;\n\twhile(1)\n\t{\n\tscanf(\"%d%d\",&w,&h);\n\tif(w==0 && h==0)\n\t\treturn 0;\n\tscanf(\"%d%d\",&xs,&ys);\n\tscanf(\"%d%d\",&xg,&yg);\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0;i<MAX;i++)\n\t\tfor(int j=0;j<MAX;j++)\n\t\t\tmap[i][j]=0;\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\tmakemap(c,d,x,y);\n\t}\n\n\tif(bfs(xs+1,ys+1,xg+1,yg+1)==0)\n\t\tprintf(\"OK\\n\");\n\telse\n\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid makemap(int c, int d, int x, int y)\n{\n\tif(d==0)\n\t\tfor(int i=x+1;i<x+5;i++)\n\t\t\tfor(int j=y+1;j<y+3;j++)\n\t\t\t\tmap[i][j]=c;\n\telse\n\t\tfor(int i=x+1;i<x+3;i++)\n\t\t\tfor(int j=y+1;j<y+5;j++)\n\t\t\t\tmap[i][j]=c;\n}\n\nint bfs(int xs,int ys,int xg,int yg)\n{\n\tint startcolor=map[xs][ys];\n\tint nowx=xs,nowy=ys;\n\tusing namespace std;\n\tqueue<int> x;\n\tqueue<int> y;\n\twhile(1)\n\t{\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nint m[100][100], w, h, xs, ys, xg, yg, n;\nint c, d, x, y, col;\n\n\nbool solve(int X, int Y){\n    if(X < 0 || X >= w || Y < 0 || Y >= h) return false;\n\n    if(m[Y][X] != col) return false;\n    if(Y == yg && X == xg) return true;\n\n    m[Y][X] = 0;\n\n    if(solve(X + 1, Y)) return true;\n    if(solve(X - 1, Y)) return true;\n    if(solve(X, Y + 1)) return true;\n    if(solve(X, Y - 1)) return true;\n\n    return false;\n}\n\n\nint main(){\n    while(scanf(\"%d %d\", &w, &h) != EOF){\n        if(w == 0 && h == 0) break;\n\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                m[i][j] = 0;\n            }\n        }\n\n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n        scanf(\"%d\", &n);\n\n        xs--; ys--;\n        xg--; yg--;\n\n        for(int i = 0; i < n; i++){\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n            x--; y--;\n\n            if(d == 0){\n                for(int i = y; i < y + 2; i++){\n                    for(int j = x; j < x + 4; j++){\n                        m[i][j] = c;\n                    }\n                }\n            }else if(d == 1){\n                for(int i = y; i < y + 4; i++){\n                    for(int j = x; j < x + 2; j++){\n                        m[i][j] = c;\n                    }\n                }\n            }\n        }\n\n        col = m[ys][xs];\n        if(col == 0){\n            printf(\"NG\\n\");\n            continue;\n        }\n        if(solve(xs, ys)){\n            printf(\"OK\\n\");\n        }else{\n            printf(\"NG\\n\");\n        }\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define repeat(n, i) for(int i=0; i<(n); i++)\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\n\nint st_color;\n\nint board[300][300];\n\n#define VISITED 6\n\nbool get_input() {\n    cin >> w >> h;\n    if (w == 0 && h == 0) return false;\n//    board.resize(h);\n//    repeat(h, i) board[i].resize(w);\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    repeat(n, i) {\n        int c, d, x, y;\n        cin >> c >> d >> x >> y;\n        if (d == 0) {\n            for (int j = y-1; j < y-1+4; j++) {\n                for (int k = x-1; k < x-1+2; k++) {\n                    board[j][k] = c;\n                }\n            }\n        } else {\n            for (int j = y-1; j < y-1+2; j++) {\n                for (int k = x-1; k < x-1+4; k++) {\n                    board[j][k] = c;\n                }\n            }\n        }\n    }\n    st_color = board[ys-1][xs-1];\n    return true;\n}\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool possible;\nvoid dfs(int x, int y) {\n    board[y-1][x-1] = VISITED;\n    if (x == xg && y == yg) {\n        possible = true;\n        return;\n    }\n    repeat(4, i) {\n        int nx = x+dx[i], ny = y+dy[i];\n        if (1 <= nx && nx <= w && 1 <= ny && ny <= h) {\n            if (board[ny-1][nx-1] != VISITED) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    possible = false; dfs(xs, ys);\n    if (possible) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n}\n\nint main() {\n    while (get_input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define SORT(c) sort((c).begin(),(c).end())\n#define DESCSORT(c) sort(c.begin(), c.end(), greater<int>())\n\nconst float PI = 3.1415926;\nstatic const int INFTY = (1<<30);\n\nusing namespace std;\n\nint B[102][102];\nint M[102][102];\nint w, h, xs, ys, xg, yg, n, res;\n \nvoid bfs(int x, int y, int c) {\n  if(x <= 0 || y <= 0 || x > w || y > h)\n    return;\n  if(B[x][y] != c)\n    return;\n  if(M[x][y] == 1) {\n    return;\n  } else {\n    M[x][y] = 1;\n  }\n  if(x == xg && y == yg) {\n    res = 1;\n    return; \n  }\n  bfs(x+1, y, c);\n  bfs(x, y+1, c);\n  bfs(x-1, y, c);\n  bfs(x, y-1, c);\n}\n\nint main() {\n  while(cin >> w >> h, w) {\n    // ?????????\n    rep(i, w) {\n      rep(j, h) {\n        B[i][j] = 0;\n        M[i][j] = 0;\n      }\n    }\n    res = 0;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    // ??????????????????\n    rep(i, n) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      \n      B[x][y] = c;\n      B[x+1][y] = c;\n      B[x][y+1] = c;\n      B[x+1][y+1] = c;\n      if ( d == 0 ) {\n        B[x+2][y] = c;\n        B[x+3][y] = c;\n        B[x+2][y+1] = c;\n        B[x+3][y+1] = c;\n      } else {\n        B[x][y+2] = c;\n        B[x][y+3] = c;\n        B[x+1][y+2] = c;\n        B[x+1][y+3] = c;\n      }        \n    }\n    if(B[xs][ys] != 0)\n      bfs(xs, ys, B[xs][ys]);\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, b[101][101];\nint dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n\nbool dfs(int x, int y){\n  fprintf(stderr, \"%d %d\\n\", x, y);\n  int nx, ny;\n  b[x][y] = 0;\n  if(x == xg && y == yg) return true;\n  bool r = 0;\n  rep(i, 4){\n    nx = x + dx[i]; ny = y + dy[i];\n    if(nx >= 0 && nx < h && ny >= 0 && ny < w && b[nx][ny]==c)r=r||dfs(nx, ny);\n  }\n  return r;\n}\n\nint main(){\n  while(scanf(\"%d %d\", &w, &h) && w && h){\n    memset(b, 0, sizeof(b));\n    scanf(\"%d%d%d%d\", &ys, &xs, &yg, &xg);\n    scanf(\"%d\", &n);\n    rep(i, n){\n      scanf(\"%d%d%d%d\", &c, &d, &y, &x);\n      rep(j, (d>0?4:2)) rep(k, (d>0?2:4)) b[x + j][y + k] = c;\n    }\n    rep(i, h){\n      rep(j, w) printf(\"%d \", b[i][j]);\n      puts(\"\");\n    }\n    c = b[xs][ys];\n    if(dfs(xs, ys)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h){\n    int xs,ys,xg,yg;\n    bool Map[h+10][w+10]={};\n    bool flag=false;\n    cin>>xs>>ys>>xg>>yg;\n    int n;cin>>n;\n    int Map2[h+10][w+10]={};\n    Map[ys][xs]=true;\n    queue<pair<int,int> >que;\n    que.push(mp(ys,xs));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      if(d==0){\n\tfor(int i=y;i<y+2;i++)\n\t  for(int j=x;j<x+4;j++)\n\t    Map2[i][j]=c;\n      }else if(d==1){\n\tfor(int i=y;i<y+4;i++)\n\t  for(int j=x;j<x+2;j++)\n\t    Map2[i][j]=c;\n      }\n    }\n    int vx[4]={0,-1,0,1};\n    int vy[4]={1,0,-1,0};\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      if(now.F==xg&&now.S==yg){\n\tflag=true;\n\tbreak;\n      }\n      for(int kk=0;kk<4;kk++){\n\tint as=now.F+vx[kk];int bs=now.S+vy[kk];\n\tif(as<h&&as>=0&&bs<w&&bs>=0&&Map2[now.F][now.S]==Map2[as][bs]&&!Map[as][bs]){\n\t  que.push(mp(as,bs));\n\t  Map[as][bs]=true;\n\t}\n      }\n    }\n    if(flag)\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX_W 100\n#define MAX_H 100\n\nint board[MAX_H + 1][MAX_W + 1];\nbool ans = false;\n\nvoid swapAB(int a[], int b[]);\nvoid resetBoard();\nvoid setBoard(int c, int d, int x, int y);\nvoid loop(int xn, int yn, int xg, int yg, int c);\nvoid disp(int w, int h);\n\nint main(){\n    int w, h;\n    while(cin >>w >>h){\n        if(w == 0 && h == 0) break;\n        int xs, ys, xg, yg, n;\n        resetBoard();\n        ans = false;\n        cin >>xs >>ys >>xg >>yg >>n;\n        for(int i = 0; i < n; i++){\n            int c, d, x, y;\n            cin >>c >>d >>x >>y;\n            setBoard(c, d, x, y);\n        }\n//        disp(w, h);\n        if(board[ys][xs] == 0){\n            cout <<\"NG\" <<endl;\n        } else{\n            loop(xs, ys, xg, yg, board[ys][xs]);\n            if(ans) cout <<\"OK\" <<endl;\n            else cout <<\"NG\" <<endl;\n        }\n    }\n    return 0;\n}   \n\nvoid swapAB(int a[], int b[]){\n    for(int i = 0; i < 8; i++){\n        int tmp = a[i];\n        a[i] = b[i];\n        b[i] = tmp;\n    }\n}\n\nvoid resetBoard(){\n    for(int i = 0; i <= MAX_H; i++){\n        for(int j = 0; j <= MAX_W; j++){\n            board[i][j] = 0;\n        }\n    }\n}\n\nvoid setBoard(int c, int d, int x, int y){\n    int xm[] = {0, 1, 2, 3, 0, 1, 2, 3}, ym[] = {0, 0, 0, 0, 1, 1, 1, 1};\n    if(d == 1) swapAB(xm, ym);\n    for(int i = 0; i < 8; i++){\n        int tmpx = x + xm[i], tmpy = y + ym[i];\n        if(tmpx > 0 || tmpy > 0 || tmpx <= MAX_W || tmpy <= MAX_H){\n            board[tmpy][tmpx] = c;\n        }\n    }\n}\nvoid loop(int xn, int yn, int xg, int yg, int c){\n    if(xn == xg && yn == yg){\n        ans = true;\n    } else{\n        board[yn][xn] = 0;\n        int xm[] = {0, 1, 0, -1}, ym[] = {-1, 0, 1, 0};\n        for(int i = 0; i < 4; i++){\n            int tmpx = xn + xm[i], tmpy = yn + ym[i];\n            //            cout <<\"tmpx = \" <<tmpx <<\", tmpy = \" <<tmpy <<endl;\n            if(tmpx > 0 && tmpy > 0 && tmpx <= MAX_W && tmpy <= MAX_H && board[tmpy][tmpx] == c){\n                loop(tmpx, tmpy, xg, yg, c);\n            }\n        }\n    }\n}\n\nvoid disp(int w, int h){\n    for(int i = 0; i <= h; i++){\n        for(int j = 0; j <= w; j++){\n            cout <<board[i][j];\n        }\n        cout <<endl;\n    }\n}\n\n//0, 01:15:08"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\nbool is_goal = false;\n#define START 20\n#define GOAL 30\n\nvoid DFS(int h,int w,int c){\n\n  if(!is_goal){\n\n    if(Array[h][w] == GOAL){\n      is_goal = true;\n      return;\n    }\n\n    if(Array[h][w] != c || Array[h][w] == 0){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 0;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n  }\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n      is_goal = false;\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n      cin >> Goal[0] >> Goal[1];\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n      Array[Goal[0]][Goal[1]] = GOAL;\n      /*for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          cout << Array[i][j];\n        }\n        cout << endl;\n      }*/\n\n      DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n\n      if(is_goal){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "include <iostream>\nusing namespace std;\n\nint F[101][102];\n\nvoid DFS(int Y, int X, int c) {\n        //cout << Y << \" \" << X << endl;\n        if (F[Y][X] != c || F[Y][X] == 0)\n                return;\n        F[Y][X] = 10;\n        DFS(Y - 1, X, c);//???\n                                                 //DFS(Y - 1, X+1, A_ito);//??????\n        DFS(Y, X + 1, c);//???\n                                                 //DFS(Y + 1, X+1, A_ito);//??????\n        DFS(Y + 1, X, c);//???\n                                                 //DFS(Y + 1, X-1, A_ito);//??????\n        DFS(Y, X - 1, c);//???\n                                                 //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n        int xs, ys, xg, yg, n;\n        int c, d, x, y;\n        int W = 0, H = 0;\n\n        while (!(W == H == 0)) {\n                cin >> W >> H;\n                cin >> xs >> ys >> xg >> yg >> n;\n                for (int i = 1;i <= n;i++) {\n                        cin >> c >> d >> x >> y;\n                        if (d == 0) {\n                                F[x][y] = c;\n                                F[x][y + 1] = c;\n                                F[x + 1][y] = c;\n                                F[x + 1][y + 1] = c;\n                                F[x + 2][y] = c;\n                                F[x + 2][y + 1] = c;\n                                F[x + 3][y] = c;\n                                F[x + 3][y + 1] = c;\n                        }\n                        if (d == 1) {\n                                F[x][y] = c;\n                                F[x + 1][y] = c;\n                                F[x][y + 1] = c;\n                                F[x + 1][y + 1] = c;\n                                F[x][y + 2] = c;\n                                F[x + 1][y + 2] = c;\n                                F[x][y + 3] = c;\n                                F[x + 1][y + 3] = c;\n                        }\n                }\n                DFS(ys, xs, F[ys][xs]);\n\n                if (F[yg][xg] == 10) {\n                        cout << \"OK\" << endl;\n                }\n                else { cout << \"NG\"<<endl; }\n                for (int i = 0;i < H;i++) {\n                        for (int j = 0;j < W;j++) {\n                                F[i][j] = 0;\n                        }\n                }\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0)\n        ca = 10;\n      else if(i == n-1)\n        c = 0;\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 101\n\nint H, W, sx, sy, gx, gy;\nint color, dir, field[MAX][MAX];\n\nstruct P{\n  int x, y;\n  P(int x, int y) : x(x), y(y) {}\n};\n\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n\nbool check(int y, int x){\n  if(0 <= y && y < H && 0 <= x && x < W){\n    return true;\n  }\n  return false;\n}\n\nvoid paint(int y, int x){\n  if(!dir){\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < 4 ; j++){\n        field[y+i][x+j] = color;\n      }\n    }\n  }else{\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n        field[y+i][x+j] = color;\n      }\n    }\n\n  }\n}\n\nbool bfs(){\n  bool used[MAX][MAX];\n  memset(used, false, sizeof(used));\n  used[sy][sx] = true;\n\n  queue<P> Q;\n  Q.push(P(sx, sy));\n\n  while(!Q.empty()){\n    P p = Q.front(); Q.pop();\n\n    if(p.x == gx && p.y == gy){\n      return true;\n    }\n\n    if(field[p.y][p.x] == -1) continue;\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n\n      if(!check(ny, nx) || used[ny][nx] || \n         field[p.y][p.x] != field[ny][nx]) continue;\n\n      used[ny][nx] = true;\n      Q.push(P(nx, ny));     \n    }\n  }\n\n  return false;\n}\n\nint main(){\n  int n, x, y;\n  while(cin >> W >> H, (W | H)){\n    memset(field, -1, sizeof(field));\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    sy--, sx--, gy--, gx--;\n\n    for(int i = 0 ; i < n ; i++){\n      cin >> color >> dir >> x >> y;\n      y--, x--;\n      paint(y, x);\n    }\n\n    cout << (bfs() ? \"OK\" : \"NG\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[101][101];\nint w,h; \nint color;\nint xg,yg;\n\nbool dfs(int y,int x) {\n  if ( map[y][x] != color ) return 0;\n  map[y][x] = 10;\n  bool f=0;\n  if ( y-1 >= 1 ) f|=dfs( y-1 , x );\n  \n  if ( y+1 <= h ) f|=dfs( y+1 , x );\n  if ( x-1 >= 1 ) f|=dfs( y , x-1 );\n  if ( x+1 <= w ) f|=dfs( y , x+1 );\n  \n  if ( y==yg && x==xg ) return 1; \n  return f;\n\n}\n\nint main() {\n  while ( cin >> w >> h ,w+h ) {\n    for(int i=1; i<=h; i++) {\n      for(int j=1; j<=w; j++) map[i][j]=0;\n    }\n    int xs,ys; cin >> xs >> ys;\n    cin >> xg >> yg;\n    int n; cin >> n;\n    while ( n > 0 ) {\n      n--;\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if ( d == 1 ) {\n\n\tfor ( int i = y; i < y+4; i++ ) {\n\t  for ( int j = x; j < x+2; j++ ) map[i][j] = c;\n\t}\n      \n      } else if ( d == 0 ) {\n\tfor ( int i = y; i < y+2; i++ ) {\n\t  for ( int j = x; j < x+4; j++ ) map[i][j] = c;\n\t}\n      }\n      \n    }\n    color = map[ys][xs];\n    if ( dfs(ys,xs) ) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#pragma region defins\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\n#pragma endregion\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n    if (d == 0)//yokonaga\n    {\n        loop(i, 2)\n        {\n            loop(j, 4)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n    else//tatenaga\n    {\n        loop(i, 4)\n        {\n            loop(j, 2)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n}\nbool dfs(int nx, int ny)\n{\n    if (nx == gx&&ny == gy)return true;\n    if (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n    grid_visited[nx][ny] = true;\n    bool a=false;\n    if(grid[nx + 1][ny]== grid[nx][ny])a|=dfs(nx + 1, ny);\n    if(grid[nx][ny+1]== grid[nx][ny])a|=dfs(nx, ny+2);\n    if(grid[nx - 1][ny]== grid[nx][ny])a|=dfs(nx - 1, ny);\n    if(grid[nx][ny-1]== grid[nx][ny])a|=dfs(nx, ny-1);\n    //return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n    return a;\n    return false;\n}\nint main()\n{\n    while (1)\n    {\n        cin >> w >> h;\n        if (!w && !h) break;\n        else\n        {\n            cin >> sx >> sy >> gx >> gy >> n;\n            sx--; sy--; gx--; gy--;\n            loop(i, n)\n            {\n                int c, d, x, y;\n                cin >> c >> d >> x >> y;\n                x--; y--;\n                input(c, d, x, y);\n            }\n            /*loop(i, h)\n            {\n                loop(j, w)\n                {\n                    cout << grid[i][j] << \" \";\n                }\n                cout << endl;\n            }*/\n            cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint map[150][150]={};\nint gone[150][150];\n\nint gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nbool dfs(int nx,int ny){\n\tif(gone[nx][ny])return false;\n\tgone[nx][ny]=1;\n\tif(nx == gx && ny == gy)return true;\n\tbool res = false;\n\trep(i,4){\n\t\tint tx = nx+dx[i],ty=ny+dy[i];\n\t\tif(map[tx][ty]!=map[nx][ny])continue;\n\t\tres |= dfs(tx,ty);\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint w,h;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tint sx,sy,n;\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(gone,0,sizeof(gone));\n\t\trep(i,n){\n\t\t\tint c,d,nx,ny;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&nx,&ny);\n\t\t\tint fx=2,fy=4;\n\t\t\tif(d==0)swap(fx,fy);\n\t\t\trep(x,fx)rep(y,fy){\n\t\t\t\tmap[x+nx][y+ny]=c;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(y,20)rep(x,20){\n\t\t\tprintf(\"%d%c\",map[x][y],x==19?'\\n':' ');\n\t\t}*/\n\t\tif(dfs(sx,sy))printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = '.';\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n \n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c || Y > w || X > h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid draw(int c,int d,int x,int y){\n    if(d){\n        for(int i=x;i<x+2;i++){\n            for(int j=y;j<y+4;y++){\n                f[i][j]=c;\n            }\n        }\n    }else{\n        for(int i=x;i<x+4;i++){\n               for(int j=y;j<y+2;y++){\n                    f[i][j]=c;\n                }\n        }\n    }\n}\n\nbool judge(int c,int x,int y){\n    if(c==f[x][y]){\n        return true;\n    }\n    return false;\n}\n\nbool DFS(int xs,int ys,int xg,int yg){\n    if(xs!=xg||ys!=yg){\n        if(judge(f[xs][ys],xs+1,ys)){\n            if(DFS(xs+1,ys,xg,yg)){\n                return true;\n            }\n        }\n          \n        if(judge(f[xs][ys],xs-1,ys)){\n            if(DFS(xs-1,ys,xg,yg)){\n                return true;\n            }\n        }\n        if(judge(f[xs][ys],xs,ys+1)){\n            if(DFS(xs,ys+1,xg,yg)){\n                return true;\n            }\n        }\n        if(judge(f[xs][ys],xs,ys-1)){\n            if(DFS(xs,ys,xg,yg-1)){\n                return true;\n            }\n        }\n        if(!(judge(f[xs][ys],xs+1,ys)||judge(f[xs][ys],xs-1,ys)||judge(f[xs][ys],xs,ys+1)||judge(f[xs][ys],xs,ys-1))){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    int c;\n    int d,x,y;\n    while(1){\n        cin>>w>>h;\n        if(w==0&&h==0)  break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            draw(c,d,x,y);\n        }\n        if(DFS(xs,ys,xg,yg)){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[101][101]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(ban[x][y+1]==CHECKED&&ban[x+1][y]==CHECKED)return false;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==c){\n\t\t\tban[x+1][y]=CHECKED;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c){\n\t\t\tban[x][y+1]=CHECKED;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] ,int map[][ 110 ] )\n{\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\tcame[ y ][ x ] = false ;\n\tmap[ y ][ x ] = -1 ;\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\treturn ok_or_ng( xx ,yy ,came ,map ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tif( map[ gy ][ gx ] == map[ sy ][ sx ] )\n\t\t\tok_or_ng( sx ,sy ,came ,map ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t\telse\n\t\t\tprintf( \"NG\\n\" ) ;\n\t\t/*if( came[ gy ][ gx ] ){\n\t\tfor( int i = 0 ; i <= h + 1 ; i++ )\n\t\t{\n\t\t\tfor( int j = 0 ; j <= w + 1 ; j++ )\n\t\t\t\tcout << map[ i ][ j ] ;\n\t\t\tcout << endl ;\n\t\t}}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint map[100][100];\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c,d,x,y;\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint dfs(int x,int y,int cl) {\n\tif(x==xg-1&&y==yg-1) return 1;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&map[nx][ny]==cl) {\n\t\t\tif(dfs(nx,ny,cl)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\twhile(1) {\n\t\tmemset(map,0,sizeof(map));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\t\tscanf(\"%d %d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tint dx,dy;\n\t\t\tif(d) dx=2,dy=4; else dx=4,dy=2;\n\t\t\tfor(int i=0;i<dx;i++) {\n\t\t\t\tfor(int j=0;j<dy;j++) {\n\t\t\t\t\tmap[x-1+i][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs-1][ys-1]!=map[xg-1][yg-1]) {\n\t\t\tprintf(\"NG\\n\");\n\t\t}else {\n\t\t\tprintf(\"%s\\n\",dfs(xs-1,ys-1,c)?\"OK\":\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <stdio.h>\nusing namespace std;\nint gx,gy,sx,sy;\nint map[102][102];\nbool flag[102][102];\nint xx[]={3,1};\nint yy[]={1,3};\nint xv[]={0,1,0,-1};\nint yv[]={1,0,-1,0};\nvoid cal(int X,int Y){\n\tflag[X][Y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(map[X][Y]==map[X+xv[i]][Y+yv[i]]&&!flag[X+xv[i]][Y+yv[i]]){\n\t\t\tcal(X+xv[i],Y+yv[i]);\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int w,h,n;cin>>w>>h,w;){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(flag,0,sizeof(flag));\n\t\tcin>>sx>>sy;\n\t\tcin>>gx>>gy;\n\t\tfor(cin>>n;n>0;n--){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tfor(int X=x;X<=x+xx[d];X++){\n\t\t\t\tfor(int Y=y;Y<=y+yy[d];Y++){\n\t\t\t\t\tmap[X][Y]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sx][sy])cal(sx,sy);\n\t\tif(flag[gx][gy])cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint w, h, board[101][101], xg, yg;\nbool visited[101][101];\n\nbool search(int x, int y, int c) {\n    if (x == xg && y == yg) {\n        return true;\n    }\n    visited[y][x] = true;\n    for (int i = 0; i < 4; i++) {\n        int px = x + dx[i], py = y + dy[i];\n        if (px < 1 || w < px || py < 1 || h < py) continue;\n        if (visited[py][px] || board[py][px] != c) continue;\n        if (search(px, py, c)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int i, j, xs, ys, n, c, d, x, y;\n\n    while (cin >> w >> h, w) {\n        for (i = 1; i <= h; i++) {\n            for (j = 1; j <= w; j++) {\n                board[i][j] = 0;\n                visited[i][j] = false;\n            }\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        while (n--) {\n            cin >> c >> d >> x >> y;\n            int bw = d==0? 4: 2;\n            int bh = 6 - bw;\n            for (i = y; i < y+bh; i++) {\n                for (j = x; j < x+bw; j++) {\n                    board[i][j] = c;\n                }\n            }\n        }\n\n        if (board[ys][xs] == board[yg][xg] &&\n            search(xs, ys, board[ys][xs])) {\n            cout << \"OK\";\n        }\n        else {\n            cout << \"NG\";\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0)\n        ca = 10;\n      else if(i == n-1)\n        ca = 0;\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=10;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif ((W == 0) && (H == 0)) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 1) {\n\t\t\t\tF[y    ][x    ] = c;\n\t\t\t\tF[y    ][x + 1] = c;\n\t\t\t\tF[y + 1][x    ] = c;\n\t\t\t\tF[y + 1][x + 1] = c;\n\t\t\t\tF[y + 2][x    ] = c;\n\t\t\t\tF[y + 2][x + 1] = c;\n\t\t\t\tF[y + 3][x    ] = c;\n\t\t\t\tF[y + 3][x + 1] = c;\n\t\t\t}\n\t\t\tif (d == 0) {\n\t\t\t\tF[y    ][x    ] = c;\n\t\t\t\tF[y + 1][x    ] = c;\n\t\t\t\tF[y    ][x + 1] = c;\n\t\t\t\tF[y + 1][x + 1] = c;\n\t\t\t\tF[y    ][x + 2] = c;\n\t\t\t\tF[y + 1][x + 2] = c;\n\t\t\t\tF[y    ][x + 3] = c;\n\t\t\t\tF[y + 1][x + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n//#include<windows.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k,l,m;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\tint maps=0;\n\tint flag;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\tflag=0;\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\telse\n\t\t\t\t\t\tmaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\t\n/*\n\t\t\t\tfor(m=0;m<h;m++)\n\t\t\t\t{\n\t\t\t\t\tfor(l=0;l<w;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d \",map[l][m]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%dツ行\\n\",l);\n\t\t\t\t}\n\t\t\t\tgetchar();\n\t\t\t\tsystem(\"cls\");\n*/\n\t\t\t\t\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"migi\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"hidari\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i-1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tmaps--;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign && maps==0)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\n\t\t\t\t\tfor(m=0;m<h;m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(l=0;l<w;l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((map[m][l]==sign && map[m][l+1]==7) || (map[m][l]==sign && map[m-1][l]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ti=m;\n\t\t\t\t\t\t\t\tj=l;\n\t\t\t\t\t\t\t\tflag=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tans=2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\");\n\t\t}\n\t}\n}\n/*\n20 20 \n1 1\n2 7\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\t\nbool check(short maze[MAX+1][MAX+1])\n{\n\tque.push(S);\n\n\tcolor = maze[S.second][S.first];\n\tif(color < 0)\n\t\treturn false;\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX+1][MAX+1];\n\twhile(cin >> w >> h, w){\n\t/*\trep(i,MAX){\n\t\t\trep(j,MAX)\n\t\t\t\tmaze[i][j] = -10;\n\t\t}*/\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\t\tG.first /= 2;\n\t\tG.second /= 2;\n\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(/*maze[S.second][S.first] > 0 && */maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint w, h;\nint xs, ys, xg, yg;\nint cs;\n\nint calc(std::vector<std::vector<int> >&v, int x, int y){\n\n\tint res = 0;\n\n\tv[x][y] = 0;\n\n\tif (y == xg&&x == yg)return 1;\n\n\tif (x < h - 2 && v[x + 1][y] == cs)res += calc(v, x + 1, y);\n\tif (x > 0 && v[x - 1][y] == cs)res += calc(v, x - 1, y);\n\tif (y < w - 2 && v[x][y + 1] == cs)res += calc(v, x, y + 1);\n\tif (y > 0 && v[x][y - 1] == cs)res += calc(v, x, y - 1);\n\n\treturn res;\n}\n\nint main(){\n\n\twhile (std::cin >> w >> h){\n\n\t\tif (w == 0 && h == 0)break;\n\n\t\tstd::cin >> xs >> ys >> xg >> yg;\n\n\t\txs--, ys--, xg--, yg--;\n\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tstd::vector<std::vector<int> >v(h, std::vector<int>(w, 0));\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\n\t\t\tx--, y--;\n\n\t\t\tif (d == 0){\n\t\t\t\tfor (int j = y; j < y + 2; j++){\n\t\t\t\t\tfor (int k = x; k < x + 4; k++){\n\t\t\t\t\t\tv[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d == 1){\n\t\t\t\tfor (int j = y; j < y + 4; j++){\n\t\t\t\t\tfor (int k = x; k < x + 2; k++){\n\t\t\t\t\t\tv[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcs = v[ys][xs];\n\n\t\tif (cs == v[yg][xg] && cs != 0){\n\t\t\tif (calc(v, ys, xs))std::cout << \"OK\" << std::endl;\n\t\t\telse std::cout << \"NG\" << std::endl;\n\t\t}\n\t\telse std::cout << \"NG\" << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\t\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][y]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][y]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid DFS(int x,int y,int c){\n    if(f[x][y]!=c)  return;\n\n    f[x][y]=10;\n    DFS(x+1,y,c);\n    DFS(x-1,y,c);\n    DFS(x,y+1,c);\n    DFS(x,y-1,c);\n}\n\nvoid print(int w,int h){\n    for(int i=1;i<=w;i++){\n        for(int j=1;j<=h;j++){\n            cout<<f[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    while(true){\n        cin>>w>>h;\n        if(w+h==0)  break;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                f[i][j]=-1;\n            }\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        for(int i=0;i<n;i++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            if(d==0){\n                for(int j = 0; j<4; j++){\n                    for(int k = 0; k<2; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }else{\n                for(int j = 0; j<2; j++){\n                    for(int k = 0; k<4; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }\n        }\n        //print(w,h);\n        DFS(xs,ys,f[xs][ys]);\n        print(w,h);\n        if(f[xg][yg]==10){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg, w,h;\n\nvoid dfs(int target, int x, int y){\n    if(x < 0 || y < 0 || x >= w || y >= h) return;\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 9;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n    return;\n}\n\nint main(){\n    int xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,h) rep(j,w) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        xs--; ys--; xg--; yg--;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i)).at(y+j) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if( nx==xg && ny==yg) flag = 1;\n  else if( w<=nx+1 || h<=ny+1) return;\n  if(board[nx][ny]==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if(board[nx][ny]==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  string res;\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      object[i].write(board);\n    }\n    func(board,xs,ys);\n    if(flag==1) res = \"OK\";\n    else res = \"NG\";\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=-1;\n\t\tgoal=-1;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2-1&&y1+h1-1>=y2)||(x2==x1+w1&&y1<=y2+h2-1&&y1+h1-1>=y2)||(y1==y2+h2&&x1<=x2+w2-1&&x1+w1-1>=x2)||(y2==y1+h1&&x1<=x2+w2-1&&x1+w1-1>=x2))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\t\tque.push(*it);\n\t\t}\n\t\tadjacive[survey].clear();\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nint Block(int,int);\nint c,d,x,y,xg,yg,w,h,M,Flag;\nint MAP[102][102],MF[102][102];\nint main(void)\n{\n\tint xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(Block(xs,ys))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nint Block(int X,int Y)\n{\n\t\n\t//printf(\"%d\",M);\n\t//printf(\"%d %d\\n\",X,Y);\n\tif(X == xg && Y == yg)\n\t\treturn 1;\n\tif(MAP[Y][X] != M || MF[Y][X] == 1 || X < 1 || Y < 1 || X > w || Y > h) return 0;\n\tMF[Y][X] = 1;\n\treturn Block(X,Y-1) || Block(X,Y+1) || Block(X-1,Y) || Block(X+1,Y);\n}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <algorithm>\n//using namespace std;\n// \n//int N;  // ??????????????° (1 <= N <= 100)\n//int W;  // ??????????????????????????? (1 <= W <= 10000)\n// \n//struct Item {\n//    int v;  // ??????????????? (1 <= v <= 1000)\n//    int w;  // ??????????????? (1 <= w <= 1000)\n//};\n//Item items[101];    // ??????????????±\n// \n//int C[101][10001];  // ??????????????????????¨???????????????????????¬??????????\n///*\n//    C[i][w] :\n//    ???????????????????????\\?????????or??\\???????????????i????????????????????§????????????\n//    ??????????????????????¨????w????????£???????????????????????§??????????´??????????\n//*/\n//\n//int maxv = 0;  // ?????????????¨?????????§???\n// \n//// ??????????????????????????°????????¢??°\n//void debug_print(int i, int w)\n//{\n//    char key_wait;\n// \n//    cout << \"  C[i][w] = max(C[i-1][w], C[i-1][w - items[i].w] + items[i].v);\" << endl;\n//    cout << \"->C[\" << i << \"][\" << w << \"] = max(C[\" << i - 1 << \"][\" << w << \"], C[\" << i - 1 << \"][\" << w << \" - \" << items[i].w << \"] + \" << items[i].v << \")\" << endl;\n// \n//    for (int iii = 0; iii <= N; ++iii) {\n//        for (int www = 0; www <= W; ++www) {\n//            if (C[iii][www] == -1) {\n//                cout << \" x\";\n//            }\n//            else {\n//                cout << \" \" << C[iii][www];\n//            }\n//        }\n//        cout << endl;\n//    }\n// \n//    cin >> key_wait;\n//}\n// \n// \n//int main()\n//{\n//    int i, w;\n// \n//    cin >> N >> W;\n// \n//    // ?????? = 0, ?????? = 0 ???????????????????????\\???????????????\n//    // ?????????????????¨??§?????????????????????????°??????????????????????????????????\n//    items[0].v = 0;\n//    items[0].w = 0;\n//    for (i = 1; i <= N; ++i) {\n//        cin >> items[i].v >> items[i].w;\n//    }\n// \n//    /*\n//    ???????????°????????¨????????????-1??§?????????\n//    ??????????§£??????????????£??????\n//    ????????????????????????????????????????????????\n//    */\n//    for (i = 0; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            C[i][w] = -1;\n//        }\n//    }\n// \n//    // ??¢????????????????????\\??£???????????´????????????0\n//    for (w = 0; w <= W; ++w) {\n//        C[0][w] = 0;\n//    }\n// \n//    for (i = 1; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            // ?????????????????????i??????????????????????????\\???????????´???\n//            if (w - items[i].w < 0) {\n//                C[i][w] = C[i - 1][w];\n//            }\n//            // ?????????????????????i????????????????????\\??????????£????????????´??????\n//            // i????????????????????\\???????????£??????????????????\n//            // i????????????????????\\???????????????w????????£??????????????????????????????\n//            // ????????§????????????????´??????????\n//            else {\n//                C[i][w] = max(C[i - 1][w], C[i - 1][w - items[i].w] + items[i].v);\n//            }\n//            maxv = max(maxv, C[i][w]);\n// \n//            // ???????????°????????¨??¢??°\n//            // ???????????????????????¢??????????????°AOJ??§Accepted??????????????????\n//            debug_print(i, w);\n//        }\n//    }\n// \n//    cout << maxv << endl;\n// \n//    return 0;\n//}\n/*\n#include <iostream>\n#include <string>\nusing namespace std;\n\n#define REP( i, a )     for( int i = 0; i < a; i++ )\n#define RREP( i, a )    for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin, (A).end()\n\ntemplate <typename T>\nvoid debug( const T& outData ) {\n\tcout << outData << endl;\n}\n\ntemplate <typename T>\nvoid debugAr( const T& outData[], const int& loopNum ) {\n\n\tfor( int i = 0; i < loopNum; i++ ) cout << outData[i] << endl;\n\n}\n\nint main()\n{\n\n\tint a;\n\tstring str;\n\n\tcin >> a >> str;\n\n\tdebug( a );\n\tdebug( str );\n\n\treturn 0;\n\n}\n*/\n\n/*#ifndef DEBUG_H\n#define DEBUG_H\n\n#include <iostream>\n\n#define REP( i, a )  for( int i = 0; i < a; i++ )\n#define RREP( i, a ) for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin(), (A).end()\n\ntemplate <typename T>\nvoid prt( T outData )\n{\n\nstd::cout << outData << endl;\n\n}\n\n\n\n#endif\n\n\n??£????????????\n*/\n\n/*\n#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int N=100;\n\nint main(){\nint i,n,j,p[N+1],m[N+1][N+1],k;\ncin>>n;\nfor(i=1;i<=n;i++){\ncin>>p[i-1]>>p[i];\n}\nfor(i=1;i<=n;i++) m[i][i]=0;\nfor(i=2;i<=n;i++){\nfor(i=1;i<=n;i++){\nint j=i+i-1;\nm[i][j]=(i<<21);\nfor(k=10;k<=j-1;j++){\n}\n}\n}\nm[i][j]=min(m[i][j]=\n\n*/\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0,w,h;\nint block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nint block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint map[110][110];\nint com[110][110];\nint lx,ly,sx,sy,gx,gy;\nint py[4]={1,0,-1,0};\nint px[4]={0,1,0,-1};\nint fl;\nint mei(int zx,int zy ,int cei[][110])\n{\n\tint i;\n\tif(zx==gx && zy==gy)\n\t{\n\t\tfl=1;\n\t\treturn 0;\n\t}\n\tcei[zy][zx]=1;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(cei[zy+py[i]][zx+px[i]]==0 && map[sy][sx]==map[zy+py[i]][zx+px[i]])\n\t\t{\n\t\t\tmei(zx+px[i],zy+py[i],cei);\n\t\t\tif(fl) return 0;\n\t\t}\n\t}\n\tcei[zy][zx]=0;\n\treturn 0;\n}\nint main()\n{\n\tint n,col,muk,vx,vy;\n\tint i,j,t;\n\twhile(cin >> lx >> ly, lx!=0 && ly!=0)\n\t{\n\t\tfl=0;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(com,0,sizeof(com));\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> col >> muk >> vx >> vy;\n\t\t\tif(muk==0)\n\t\t\t{\n\t\t\t\tfor(j=vy;j<2+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<4+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=vy;j<4+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<2+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmei(sx,sy,com);\n\t\tif(fl) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 100;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\n\nvoid dfs(int x, int y){\n    maze[x][y] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) flag = 1;\n                dfs(nx, ny);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[x-1+dx][y-1+dy] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[x-1+dx][y-1+dy] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[xs][ys]) maze[i][j] = 0;\n\n    //search\n    dfs(xs-1, ys-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n \nusing namespace std;\n \n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\n \nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n \ntypedef pair<int ,int > P;\n \nchar maze[105][105];\n \nint sx,sy;\nint gx,gy;\nint w,h;\n \nchar sc;        //スタート地点のカラー\n \n//stdin\n//stdout\n \nvoid dfs(int x,int y)\n{\n    maze[y][x]='9';\n \n    rep(i,4)\n    {\n/*        for(int j=-1;j<=1;j++)\n        {*/\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n \n            if(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[ny][nx]==sc)\n            {\n                dfs(nx,ny);\n            }\n \n/*        }*/\n    }\n    return ;\n}\n \nvoid solve()\n{\n \n    rep(i,101)\n        rep(j,101)\n        maze[i][j]='0';\n \n    int n;\n    char c;\n    int d;\n    int x,y;\n \n    cin>>sx>>sy;\n    cin>>gx>>gy;\n \n    cin>>n;\n \n    rep(i,n)\n    {\n        cin>>c>>d>>x>>y;\n \n        if(d==1)\n        {\n            rep(j,2)\n            {\n                rep(k,4)\n                {\n                    maze[y+k][x+j]=c;\n \n                }\n            }\n        }\n        else if (d==0)\n        {\n            rep(j,4)\n            {\n                rep(k,2)\n                {\n                    maze[y+k][x+j]=c;\n \n                }\n            }\n        }\n \n    }\n//6 6\n//1 1\n//3 6\n//2\n//1 0 1 1\n//1 1 3 3\n//  rep(i,w+1)\n//  {\n//      rep(j,h+1)\n//      {\n//          cout<<maze[i][j];\n//\n//      }\n//      cout<<endl;\n//  }\n//\n//  cout<<maze[gx][gy]<<endl;\n \n    if(maze[sy][sx]=='0')\n    {\n        cout<<\"NG\"<<endl;\n        return;\n    }\n    else\n    {\n        sc=maze[sy][sx];\n        dfs(sx,sy);\n    }\n     \n    //rep(i,w+1)\n    //{\n    //  rep(j,h+1)\n    //  {\n    //      cout<<maze[i][j];\n \n    //  }\n    //  cout<<endl;\n    //}\n \n    if(maze[gy][gx]=='9')\n    {\n        cout<<\"OK\"<<endl;\n        return;\n    }\n    else\n    {\n        cout<<\"NG\"<<endl;\n        return;\n    }\n \n \n \n}\n \nint main()\n{\n \n    while(cin>>w>>h)\n    {\n        if(w==0 && h==0)\n        {\n            return 0;\n        }\n        else\n        {\n            solve();\n        }\n    }\n \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <string>\n\n#define Pa pair<int,int>\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstring bfs(int a[101][101], int sx, int sy, int gx, int gy, int w, int h)\n{\n\tint s, t, m = a[sy][sx];\n\tbool vis[101][101];\n\tstring str = \"NG\";\n\tqueue<Pa> que;\n\tPa pa;\n\tfill(&vis[0][0], &vis[h+1][w+1], true);\n\t\n\tque.push(Pa(sy, sx));\n\tvis[sy][sx] = false;\n\t\n\twhile(!que.empty()){\n\t\tpa = que.front();\n\t\tque.pop();\n\t\tif(pa.first == gy && pa.second == gx){\n\t\t\tstr = \"OK\";\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ts = pa.first + dy[i];\n\t\t\tt = pa.second + dx[i];\n\t\t\tif(1 <= s && s <= h && 1 <= t && t <= w){\n\t\t\t\tif(vis[s][t] && m == a[s][t]){\n\t\t\t\t\tque.push(Pa(s, t));\n\t\t\t\t\tvis[s][t] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str;\n}\n\nint main()\n{\n\tint a[101][101], w, h, sx, sy, gx, gy, s, t, u, v, n;\n\t\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[0][0], &a[h+1][w+1], 0);\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u >> v;\n\t\t\tif(t == 0){\n\t\t\t\tfor(int i = v; i <= v+1; i++){\n\t\t\t\t\tfor(int j = u; j <= u+3; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i = v; i <= v+3; i++){\n\t\t\t\t\tfor(int j = u; j <= u+1; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, sx, sy, gx, gy, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n#define BLANK 0\n#define LONG 4\n#define SHORT 2\n#define HORIZONTAL 0\n#define VERTICAL 1\n#define VISITED 9\n\nint field[MAX+2][MAX+2];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nvoid rec(int x,int y,int c)\n{\n  int i;\n  if(field[x][y]!=c)return;\n  field[x][y]=VISITED;\n  for(i=0;i<4;i++)rec(x+dx[i],y+dy[i],c);\n  return;\n}\n\nint main()\n{\n  int w,h,xs,ys,xg,yg,n,c,d,x,y;\n  int i,j;\n  while(cin>>w>>h>>xs>>ys>>xg>>yg>>n,w|h){\n    for(j=1-1;j<=h+1;j++)for(i=1-1;i<=w+1;i++)field[i][j]=BLANK;\n    while(n-->0){\n      cin>>c>>d>>x>>y;\n      if(d==HORIZONTAL)\n\tfor(i=0;i<LONG;i++)for(j=0;j<SHORT;j++)field[x+i][y+j]=c;\n      else\n\tfor(i=0;i<SHORT;i++)for(j=0;j<LONG;j++)field[x+i][y+j]=c;\n    }\n    if(field[xs][ys]!=BLANK)rec(xs,ys,field[xs][ys]);\n    puts(field[xg][yg]==VISITED?\"OK\":\"NG\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <utility>\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nint sx,sy,gx,gy;\nint w,h,n;\nint g[1000][1000];\nbool valid(int y, int x){ return 0<=x && x<w && 0<=y && y<h; }\n\nint main(){\n    while(cin>>w>>h && w){\n        cin>>sx>>sy>>gx>>gy;\n        sx--,sy--,gx--,gy--;\n        rep(i,h)rep(j,w)g[i][j]=0;\n        cin>>n;\n        rep(i,n){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n            if(d==0)x+=2;else y+=2;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n        }\n        int C=g[sy][sx];\n        // cout<<C<<endl;\n        // rep(i,h){\n        //     rep(j,w){\n        //         cout<<g[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        rep(i,h)rep(j,w)g[i][j]= (g[i][j]==C) ? C : 0;\n\n        bool vis[1000][1000]={};\n        vis[sy][sx]=true;\n        if(C){\n            stack<pii> s;\n            vis[sy][sx]=true;\n            s.emplace(sy,sx);\n            while(s.size()){\n                int y,x;\n                tie(y,x) = s.top();s.pop();\n                rep(d,4){\n                    int nx=x+dx[d],ny=y+dy[d];\n                    if(!valid(ny,nx))continue;\n                    if(vis[ny][nx])continue;\n                    if(!g[ny][nx])continue;\n                    vis[ny][nx]=true;\n                    s.emplace(ny,nx);\n                }\n            }\n            // rep(i,h){\n            //     rep(j,w){\n            //         cout<<vis[i][j];\n            //     }\n            //     cout<<endl;\n            // }\n        }\n        puts(C && vis[gy][gx] ? \"OK\" : \"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c || !b.mass[y][x])return;\n    b.mass[y][x]=0;\n    if(x==gx&&y==gy){goal_flag=true;return;}\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n  int goal_x,goal_y;\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        b.mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x < w && y>=0 && y< h);\n}\nint main(void){\n\tconst int dx[4]={0,1,0,-1};\n\tconst int dy[4]={1,0,-1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\t//printf(\"%d %d\\n\",w,h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x-1+k][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs-1][ys-1];\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs-1;\n\t\tqy[0]=ys-1;\n\t\tf=c!=0;\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t\twhile(f && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dy[i];\n\t\t\t\ty = qy[p] + dx[i];\n\t\t\t\tif(is(x,y) && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx[p+cnt] = x;\n\t\t\t\t\tqy[p+cnt] = y;\n\t\t\t\t\tif(x == xg-1 && y == yg-1)f=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}\n\t\tputs(f?\"NG\":\"OK\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint map[105][105];\nint xg,yg;\nint w,h;\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nbool check(int x,int y)\n{\n  if(x==xg && y==yg)\n    return true;\n  if(map[x][y]==-1)\n    return false;\n  if(x>h||y>w||x<=0||y<=0)\n    return false;\n  \n  char buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]<=h && x+dx[i]>0 &&\n\t y+dy[i]<=w && y+dy[i]>0 &&\n\t map[x+dx[i]][y+dy[i]]==buf && \n\t check(x+dx[i],y+dy[i])\n\t )\n\treturn true;\n    }\n  return false;\n}\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>xs>>ys;\n      cin>>xg>>yg;\n      int n;\n      cin>>n;\n      for(int i=0;i<n;i++)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;      \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int ys,int xs);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--;ys--;xg--;yg--;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n      x[i]--;y[i]--;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j][k] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys,xs))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0 || maps[ys][xs] != gc){\n    return 0;\n  }\n  else if(ys == yg && xs == xg){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=1;i<=100;i++){    //Boardの初期化\n            for(int j=1;j<=100;j++)\n                Board[j][i] = -1;\n        } \n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n        \n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n\nint dx[] ={-1,0,1,0};\nint dy[] ={0,-1,0,1};\n\nint w, h, sx, sy, gx, gy, n;\nint c, d, x, y, nx, ny;\n\nint dat[110][110];\nbool used[110][110];\n\nbool outOfRange(int x, int y){\n\tif(x > w || x < 1 || y > h || y < 1) return true;\n\treturn false;\n}\n\n\nint main(){\n\twhile(cin>>w>>h && w && h){\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\trep(i, 110) rep(j, 110) dat[i][j] = 0, used[i][j] = false;\n\t\trep(i, n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tdat[x+j][y+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\t\t\tdat[x+k][y+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pair<int, pii> > q;\n\t\tpair<int, pii> p;\n\t\tq.push(mp(0, mp(sx, sy)));\n\t\tused[sx][sy] = true;\n\t\tbool ans = false;\n\n\t\twhile(!q.empty()){\n\t\t\tp = q.front(); q.pop();\n\t\t\tc = p.fi;\n\t\t\tx = p.se.fi;\n\t\t\ty = p.se.se;\n\t\t\tif(x == gx && y == gy){\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(outOfRange(nx, ny) || used[nx][ny] == true) continue;\n\t\t\t\tif(dat[x][y]==dat[nx][ny]){\n\t\t\t\t\tq.push(mp(c+1, mp(nx, ny)));\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(ans?\"OK\":\"NG\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    int cbase;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=cbase;\n          }\n        }\n      }\n    }\n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }\n    if(C[xg][yg] != -1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) { return false; }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h+1; i++) {\n                for (int j = 0; j <= w+1; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> w >> h;\n    }\n    for (std::string i : ans) {\n        std::cout << i << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\nint flag;\n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n     flag = 1;\n     return;\n  }\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n \n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  flag = 0;\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nchar F[102][102];\n \nvoid DFS(int Y,int X,char c){\n  if(F[Y][X]!=c){\n    return;\n  }\n \n  F[Y][X] = '0';\n \n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n \nint main(){\n  while(1){\n  int N,M;\n  cin >> N >> M;\n  if(N==0&&M==0)\n    break;\n \n  for(int h=1;h<=N;h++){\n    for(int w=1;w<=M;w++){\n      cin>>F[h][w];\n    }\n  }\n \n  int cnt=0;\n  for(int h=1;h<=N;h++){\n    for(int w=1;w<=M;w++){\n      if(F[h][w]=='@'){\n        cnt++;\n        DFS(h,w,'@');\n      }else if(F[h][w]=='#'){\n        cnt++;\n        DFS(h,w,'#');\n      }else if(F[h][w]=='*'){\n          cnt++;\n          DFS(h,w,'*');\n      }\n    }\n  }\n  cout<<cnt<<endl;\n}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint field[101][101],b[101][101],X,Y,n,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},I,sX,sY,gX,gY,ans,sgc;\nint func(int x,int y){\n\tfor(I=0;I<4;I++){\n\t\tint xx=x+dx[I];\n\t\tint yy=y+dy[I];\n\t\tif(xx>0&&yy>0&&xx<=X&&yy<=Y&&field[xx][yy]==sgc&&b[xx][yy]==0){\n\t\t\tif(xx==gX&&yy==gY){\n\t\t\t\tif(ans==-1)ans=b[x][y];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\tb[xx][yy]=b[x][y]+1;\n\t\t\tfunc(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,i2,c,d,x,y;\n\tcin>>X>>Y;\n\twhile(X!=0){\n\t\tcin>>sX>>sY>>gX>>gY>>n;\n\t\tans=-1;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tc=0;\n\t\t\td=0;\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t\tfor(i2=1;i2<=100;i2++){\n\t\t\t\tfield[i][i2]=0;\n\t\t\t\tb[i][i2]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+2][y]=c;\n\t\t\t\tfield[x+3][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+2][y+1]=c;\n\t\t\t\tfield[x+3][y+1]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x][y+2]=c;\n\t\t\t\tfield[x][y+3]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+1][y+2]=c;\n\t\t\t\tfield[x+1][y+3]=c;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++)cout<<field[i2][i]<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t\tsgc=field[sX][sY];\n\t\tfunc(sX,sY);\n\t\tfor(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++){\n\t\t\t\tif(b[i2][i]<10)cout<<' '<<b[i2][i]<<' ';\n\t\t\t\telse cout<<b[i2][i]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tif(ans==-1)cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\tcin>>X>>Y;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\nint n, m;\nint cl[ 100 ][ 100 ];\n\nint main() {\n\tqueue<PII> q;\n\tset<PII> s;\n\twhile ( ~scanf(\"%d %d\", &n, &m) && n && m ) {\n\t\tCLR( cl );\n\t\tbool can = false;\n\t\tint sx, sy, gx, gy;\n\t\tscanf( \"%d %d\", &sx, &sy );\n\t\t--sx;\n\t\t--sy;\n\t\tscanf( \"%d %d\", &gx, &gy );\n\t\t--gx;\n\t\t--gy;\n\t\tint k;\n\t\tscanf( \"%d\", &k );\n\t\tfor ( int i = 0; i < k; i++ ) {\n\t\t\tint c, d, x, y;\n\t\t\tscanf( \"%d %d %d %d\", &c, &d, &x, &y );\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tif ( d ) {\n\t\t\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\t\t\tfor ( int j = 0; j < 2; j++ ) {\n\t\t\t\t\t\tcl[ y + i ][ x + j ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor ( int i = 0; i < 2; i++ ) {\n\t\t\t\t\tfor ( int j = 0; j < 4; j++ ) {\n\t\t\t\t\t\tcl[ y + i ][ x + j ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.push( MP( sx, sy ) );\n\t\twhile ( q.size() ) {\n\t\t\tint x = q.front().first;\n\t\t\tint y = q.front().second;\n\t\t\tq.pop();\n\t\t\tif ( s.count( MP( x, y ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ts.insert( MP( x, y ) );\n\t\t\tif ( x == gx && y == gy ) {\n\t\t\t\tcan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\t\tif ( x + dx[ i ] < 0 || x + dx[ i ] == n || y + dy[ i ] < 0 || y + dy[ i ] == m || cl[ y ][ x ] != cl[ y + dy[ i ] ][ x + dx[ i ] ] ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push( MP( x + dx[ i ], y + dy[ i ] ) );\n\t\t\t}\n\t\t}\n\t\tprintf( \"%s\\n\", can ? \"OK\" : \"NG\" );\n\t\twhile ( q.size() ) {\n\t\t\tq.pop();\n\t\t}\n\t\ts.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==c){\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c){\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(/*dfs(xs,ys,ban[xs][ys])*/1)cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\n#define START 20\n\nvoid DFS(int h,int w,int c){\n\n\n    if(Array[h][w] == GOAL){\n      is_goal = true;\n      return;\n    }\n\n    if(Array[h][w] != c || Array[h][w] == 0 || Array[h][w] == 6){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 6;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n      cin >> Goal[0] >> Goal[1];\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n      \n      /*for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          cout << Array[i][j];\n        }\n        cout << endl;\n      }*/\n      if(Array[Start[0]][Start[1]] != 0){\n        DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n      }\n      if(Array[Goal[0]][Goal[1]] == 6){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nvvi tmp;\nint dx[]={0,0,1,-1};\nint dy[]={-1,1,0,0};\nvoid solve(int x,int y){\n\ttmp[x][y]=-1;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(tmp[nx][ny]==2)solve(nx,ny);\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n+2,vi(m+2));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tcin>>n;\n\t\twhile(n--){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tif(!b)rep(i,4)rep(j,2)in[c+i][d+j]=a;\n\t\t\telse rep(i,2)rep(j,4)in[c+i][d+j]=a;\n\t\t}\n\t\ttmp=in;\n\t\tif(in[sx][sy]==2)solve(sx,sy);\n\t\t//rep(i,in.size()){rep(j,in[0].size())cout<<in[i][j]<<\" \";cout<<endl;}\n\t\t//cout<<endl;\n\t\t//rep(i,tmp.size()){rep(j,tmp[0].size())cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t\tcout<<((in[sx][sy]==2&&in[gx][gy]==2&&tmp[gx][gy]==-1)?\"OK\":\"NG\")<<endl;\n\t\t//rep(i,22){rep(j,22)cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\tif(F[xg][yg]==0)\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\tif(F[xg][yg]!=0)\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\n#include <string.h>\n#include <complex>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = 1<<29;\n\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\nint field[100][100];\n\nint w,h;\nint xs,ys,xg,yg;\n\nbool dfs(int y,int x){\n    if(field[y][x]==0) return false;\n    if(y==yg && x==xg) return true;\n    int c = field[y][x];\n    field[y][x] = 0;\n    for(int i=0;i<4;i++){\n        int nextx = x+dx[i], nexty = y+dy[i];\n        if(0<=nextx&&nextx<w&&0<=nexty&&nexty<h && c==field[nexty][nextx]){\n            if(dfs(nexty,nextx)) return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w==0)break;\n\n        scanf(\"%d%d%d%d\",&xs,&ys,&xg,&yg);\n        xs--;ys--;xg--;yg--;\n\n        int n;\n        scanf(\"%d\",&n);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                field[i][j] = 0;\n            }\n        }\n        for(int k=0;k<n;k++){\n            int c,d,x,y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            x--;y--;\n            int tate=2,yoko=4;\n            if(d) swap(tate,yoko);\n            for(int i=y;i<y+tate;i++){\n                for(int j=x;j<x+yoko;j++){\n                    field[i][j] = c;\n                }\n            }\n        }\n        /*\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                printf(\"%2d\",field[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        */\n\n\n        if(dfs(ys,xs))cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       \n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n \n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#pragma region defins\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\n#pragma endregion\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int >> grid(105, vector<int>(105));\nvector <vector<bool >> grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\treturn (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\t\tloop(j, w)\n\t\t\t\t{\n\t\t\t\t\tcout << grid[i][j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y;\n\tstate(int x, int y) : x(x), y(y) {};\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h+1, vi(w+1));\n\t\tvvi visit(h+1, vi(w+1));\n\t\t\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(d) {\n\t\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> S;\n\t\tS.push(state(xs, ys));\n\t\tbool goal = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.front();\n\t\t\tS.pop();\n\n\t\t\tif(st.x == xg && st.y == yg) {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx, ny;\n\t\t\tREP(d, 4) {\n\t\t\t\tnx = st.x + dx[d];\n\t\t\t\tny = st.y + dy[d];\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny < h) {\n\t\t\t\t\tif(!visit[ny][nx] && field[ny][nx] == field[ys][xs]) {\n\t\t\t\t\t\tvisit[ny][nx] = 1;\n\t\t\t\t\t\tS.push(state(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(goal) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std ;\n\nint w , h ;\nint gx , gy , color , ans ;\nint map[101][101] = {} ;\nint dx[] = { 0,1,0,-1 } ;\nint dy[] = { 1,0,-1,0 } ;\n\nvoid judge( int nx , int ny ){\n\tif( nx==gx && ny==gy ) ans = 1 ;\n\t\n\tmap[nx][ny] = 0 ;\n\t\n\tfor( int i=0 ; i<4 ; i++ ){\n\t\tif( nx+dx[i]>0 && nx+dx[i]<=w && ny+dy[i]>0 && ny+dy[i]<=h )\n\t\t\tif( map[nx+dx[i]][ny+dy[i]] == color )\n\t\t\t\tjudge( nx+dx[i] , ny+dy[i] ) ;\n\t}\n}\n\nint main(){\n\t\n\tint sx , sy ;\n\tint n ;\n\tint c , d , x , y ;\n\tint a , b ;\n\t\n\twhile(1){\n\t\tcin >> w >> h ;\n\t\tif( w==0 && h==0 ) break;\n\t\t\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\t\n\t\tfor( int i=0 ; i<n ; i++ ){\n\t\t\tcin >> c >> d ;\n\t\t\tcin >> x >> y ;\n\t\t\tif( d==0 ){\n\t\t\t\ta = 4 ;\n\t\t\t\tb = 2 ;\n\t\t\t}else {\n\t\t\t\ta = 2 ;\n\t\t\t\tb = 4 ;\n\t\t\t}\n\t\t\t\n\t\t\tfor( int j=x ; j<=x+a ; j++ ){\n\t\t\t\tfor( int k=y ; k<=y+b ; k++ ){\n\t\t\t\t\tmap[j][k] = c ;\n\t\t\t\t\tif( sx==j && sy==k ) color = c ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans = 0 ;\n\t\tjudge( sx , sy ) ;\n\t\t\n\t\tif( ans == 1 ) cout << \"OK\" << endl ;\n\t\telse cout << \"NG\" << endl ;\n\t\t\n\t\tfor( int i=1 ; i<w ; i++ )\n\t\t\tfor( int j=1 ; j<h ; j++ )\n\t\t\t\tmap[i][j] = 0 ;\n\t}\n\t\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(xs,ys));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nvvi tmp;\nint q;\nint dx[]={0,0,1,-1};\nint dy[]={-1,1,0,0};\nvoid solve(int x,int y){\n\ttmp[x][y]=-1;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(tmp[nx][ny]==q){solve(nx,ny);}\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n+2,vi(m+2));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tcin>>n;\n\t\twhile(n--){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tif(!b)rep(i,4)rep(j,2)in[c+i][d+j]=a;\n\t\t\telse rep(i,2)rep(j,4)in[c+i][d+j]=a;\n\t\t}\n\t\ttmp=in;\n\t\t//rep(i,in.size()){rep(j,in[0].size())cout<<in[i][j]<<\" \";cout<<endl;}\n\t\tif(in[sx][sy]){\n\t\t\tq=in[sx][sy];\n\t\t\tsolve(sx,sy);\n\t\t}\n\t\t//cout<<endl;\n\t\t//rep(i,tmp.size()){rep(j,tmp[0].size())cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t\tcout<<((in[sx][sy]==2&&in[gx][gy]==2&&tmp[gx][gy]==-1)?\"OK\":\"NG\")<<endl;\n\t\t//rep(i,22){rep(j,22)cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(ans == 1) return ;\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1,yi);\n        solve(xi,yi-1);\n        solve(xi+1,yi);\n        solve(xi,yi+1);\n    }\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(block));\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            //cout << x << \",\"<< y << endl;\n            if(d==1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        if(c==0) {cout <<\"NG\" << endl; continue;}\n        \n        //cout << xs << \" \" << ys << \" \" << c << endl;\n        //cout <<\"input \" << endl;\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconst int size = 110;\nint board[size][size];\nint visited[size][size];\nint xblocks[2][8] = { {0, 1, 2, 3, 0, 1, 2, 3},\n\t\t      {0, 0, 0, 0, 1, 1, 1, 1} };\nint yblocks[2][8] = { {0, 0, 0, 0, 1, 1, 1, 1},\n\t\t      {0, 1, 2, 3, 0, 1, 2, 3} };\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nint main() {\n  int w,h,xs,ys,xg,yg,n,c,d,x,y;\n  while(cin>>w>>h, w|h) {\n    for(int i=0; i<size; ++i)\n      for(int j=0; j<size; ++j) {\n\tboard[i][j] = 0;\n\tvisited[i][j] = 0;\n      }\n\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0; i<n; ++i) {\n      cin>>c>>d>>x>>y;\n      for(int j=0; j<8; ++j)\n\tboard[x+xblocks[d][j]][y+yblocks[d][j]] = c;\n    }\n\n    queue<pair<int,int> > Q;\n    Q.push(pair<int,int>(xs,ys));\n    while(!Q.empty()) {\n      pair<int,int> pos = Q.front(); Q.pop();\n      int nx = pos.first,ny = pos.second;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = 1;\n      if(nx == xg && ny == yg) {\n\tcout<<\"OK\"<<endl;\n\tgoto NEXT;\n      }\n\n      for(int i=0; i<4; ++i) {\n\tif(nx+dx[i] > 0 && nx+dx[i] <= w &&\n\t   ny+dy[i] > 0 && ny+dy[i] <= h &&\n\t   board[ny][nx] == board[ny+dy[i]][nx+dx[i]])\n\t  Q.push(pair<int,int>(nx+dx[i],ny+dy[i]));\n      }\n      board[ny][nx] = -1;\n    }\n    cout<<\"NG\"<<endl;\n  NEXT:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nvvint vv;\npii s,g;\nvvint used;\nint dd[]={1,0,-1,0,1};\nbool foo(pii a,int c){\n\tif(used[a.F][a.S]) return false;\n\tif(vv[a.F][a.S]!=c) return false;\n\tused[a.F][a.S]=1;\n\tif(a==g) return true;\n\trep(i,4){\n\t\tpii next=a;\n\t\tnext.F+=dd[i];\n\t\tnext.S+=dd[i+1];\n\t\tif(0<=next.F&&next.F<h&&0<=next.S&&next.S<w){\n\t\t\tif(foo(next,c)) return true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid mainmain(){\n\twhile(cin>>w>>h,w||h){\n\t\tinitvv(vv,h,w,0);\n\t\tused=vv;\n\t\tcin>>s.S>>s.F>>g.S>>g.F;\n\t\ts.F--;s.S--;\n\t\tg.F--;g.S--;\n\t\tint n;\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>d>>c;\n\t\t\tc--;\n\t\t\td--;\n\t\t\tif(b==0){\n\t\t\t\tvv[c][d]=vv[c][d+1]=vv[c][d+2]=vv[c][d+3]=a;\n\t\t\t\tvv[c+1][d]=vv[c+1][d+1]=vv[c+1][d+2]=vv[c+1][d+3]=a;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvv[c][d]=vv[c+1][d]=vv[c+2][d]=vv[c+3][d]=a;\n\t\t\t\tvv[c][d+1]=vv[c+1][d+1]=vv[c+2][d+1]=vv[c+3][d+1]=a;\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\n\t\t\t}\n\t\t}\n\t\tif(vv[s.F][s.S]==0){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse if(foo(s,vv[s.F][s.S])){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0){\n        ca = 1000;\n        break;\n      }else if(i == n-1){\n        ca = 0;\n      }\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<h+2; i++ ) {\n      for ( int j=0; j<w+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n    next.push(y*1000 + x );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n\tcout << map[i+1][j+1];\n      }\n      cout << endl;\n    }\n    cout << endl;\n\n    if ( map[yg][xg] == sc ) {\n\t\n      while ( !next.empty() ) {\n\tpoint = next.front();\n\tnext.pop();\n\n\tcheck[point/1000][point%1000] = false;\n\tif (map[point/1000][point%1000] == 0 )\n\t  continue;\n\n\tif (point == yg*1000+xg) {\n\t  if ( sc == map[yg][xg] )\n\t    goal = true;\n\t  break;\n\t}\n\tfor ( int i=0; i<4; i++ ) {\n\t  if ( check[point/1000+dy[i]][point%1000+dx[i]] ) {\n\t    check[point/1000+dy[i]][point%1000+dx[i]] = false;\n\t    if ( map[point/1000+dy[i]][point%1000+dx[i]] == sc ) {\n\t      next.push((point/1000+dy[i])*1000+point%1000+dx[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n\n\n  }\n\n\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <algorithm>\n//using namespace std;\n// \n//int N;  // ??????????????° (1 <= N <= 100)\n//int W;  // ??????????????????????????? (1 <= W <= 10000)\n// \n//struct Item {\n//    int v;  // ??????????????? (1 <= v <= 1000)\n//    int w;  // ??????????????? (1 <= w <= 1000)\n//};\n//Item items[101];    // ??????????????±\n// \n//int C[101][10001];  // ??????????????????????¨???????????????????????¬??????????\n///*\n//    C[i][w] :\n//    ???????????????????????\\?????????or??\\???????????????i????????????????????§????????????\n//    ??????????????????????¨????w????????£???????????????????????§??????????´??????????\n//*/\n//\n//int maxv = 0;  // ?????????????¨?????????§???\n// \n//// ??????????????????????????°????????¢??°\n//void debug_print(int i, int w)\n//{\n//    char key_wait;\n// \n//    cout << \"  C[i][w] = max(C[i-1][w], C[i-1][w - items[i].w] + items[i].v);\" << endl;\n//    cout << \"->C[\" << i << \"][\" << w << \"] = max(C[\" << i - 1 << \"][\" << w << \"], C[\" << i - 1 << \"][\" << w << \" - \" << items[i].w << \"] + \" << items[i].v << \")\" << endl;\n// \n//    for (int iii = 0; iii <= N; ++iii) {\n//        for (int www = 0; www <= W; ++www) {\n//            if (C[iii][www] == -1) {\n//                cout << \" x\";\n//            }\n//            else {\n//                cout << \" \" << C[iii][www];\n//            }\n//        }\n//        cout << endl;\n//    }\n// \n//    cin >> key_wait;\n//}\n// \n// \n//int main()\n//{\n//    int i, w;\n// \n//    cin >> N >> W;\n// \n//    // ?????? = 0, ?????? = 0 ???????????????????????\\???????????????\n//    // ?????????????????¨??§?????????????????????????°??????????????????????????????????\n//    items[0].v = 0;\n//    items[0].w = 0;\n//    for (i = 1; i <= N; ++i) {\n//        cin >> items[i].v >> items[i].w;\n//    }\n// \n//    /*\n//    ???????????°????????¨????????????-1??§?????????\n//    ??????????§£??????????????£??????\n//    ????????????????????????????????????????????????\n//    */\n//    for (i = 0; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            C[i][w] = -1;\n//        }\n//    }\n// \n//    // ??¢????????????????????\\??£???????????´????????????0\n//    for (w = 0; w <= W; ++w) {\n//        C[0][w] = 0;\n//    }\n// \n//    for (i = 1; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            // ?????????????????????i??????????????????????????\\???????????´???\n//            if (w - items[i].w < 0) {\n//                C[i][w] = C[i - 1][w];\n//            }\n//            // ?????????????????????i????????????????????\\??????????£????????????´??????\n//            // i????????????????????\\???????????£??????????????????\n//            // i????????????????????\\???????????????w????????£??????????????????????????????\n//            // ????????§????????????????´??????????\n//            else {\n//                C[i][w] = max(C[i - 1][w], C[i - 1][w - items[i].w] + items[i].v);\n//            }\n//            maxv = max(maxv, C[i][w]);\n// \n//            // ???????????°????????¨??¢??°\n//            // ???????????????????????¢??????????????°AOJ??§Accepted??????????????????\n//            debug_print(i, w);\n//        }\n//    }\n// \n//    cout << maxv << endl;\n// \n//    return 0;\n//}\n/*\n#include <iostream>\n#include <string>\nusing namespace std;\n\n#define REP( i, a )     for( int i = 0; i < a; i++ )\n#define RREP( i, a )    for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin, (A).end()\n\ntemplate <typename T>\nvoid debug( const T& outData ) {\n\tcout << outData << endl;\n}\n\ntemplate <typename T>\nvoid debugAr( const T& outData[], const int& loopNum ) {\n\n\tfor( int i = 0; i < loopNum; i++ ) cout << outData[i] << endl;\n\n}\n\nint main()\n{\n\n\tint a;\n\tstring str;\n\n\tcin >> a >> str;\n\n\tdebug( a );\n\tdebug( str );\n\n\treturn 0;\n\n}\n*/\n\n/*#ifndef DEBUG_H\n#define DEBUG_H\n\n#include <iostream>\n\n#define REP( i, a )  for( int i = 0; i < a; i++ )\n#define RREP( i, a ) for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin(), (A).end()\n\ntemplate <typename T>\nvoid prt( T outData )\n{\n\nstd::cout << outData << endl;\n\n}\n\n\n\n#endif\n\n\n??£????????????\n*/\n\n/*\n#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int N=100;\n\nint main(){\nint i,n,j,p[N+1],m[N+1][N+1],k;\ncin>>n;\nfor(i=1;i<=n;i++){\ncin>>p[i-1]>>p[i];\n}\nfor(i=1;i<=n;i++) m[i][i]=0;\nfor(i=2;i<=n;i++){\nfor(i=1;i<=n;i++){\nint j=i+i-1;\nm[i][j]=(i<<21);\nfor(k=10;k<=j-1;j++){\n}\n}\n}\nm[i][j]=min(m[i][j]=\n\n*/\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0,w,h;\nint block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nint block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    //memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0 && mas[ys][xs]==mas[yg][xg]){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n\tgoal=0;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<list>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define debug(x) cout << x << endl;\nusing namespace std;\n\nint xstart, ystart;\nint xgoal, ygoal;\nint load;\nbool check;\n\nvoid answer(int maze[][1000], int x, int y){\n    if(load == maze[x][y]){\n        maze[x][y] = 0;\n    }else{\n        return;\n    }\n    if(x == xgoal && y == ygoal){\n        cout << \"OK\" << endl;\n        check = true;\n        return;\n    }\n    answer(maze, x+1,y);\n    answer(maze, x,y+1);\n    answer(maze, x,y-1);\n    answer(maze, x-1,y);\n}\n\nint main(){\n    int width, height;\n    int n;\n    int color, direction, x, y;\n\n    while(cin >> width >> height, height){\n        int maze[1000][1000];\n        check = false;\n        cin >> xstart >> ystart >> xgoal >> ygoal >> n;\n        rep(i,n){\n            cin >> color >> direction >> x >> y;\n            if(direction == 0){\n                maze[x][y] = color;\n                maze[x+1][y] = color;\n                maze[x+2][y] = color;\n                maze[x+3][y] = color;\n                maze[x][y+1] = color;\n                maze[x+1][y+1] = color;\n                maze[x+2][y+1] = color;\n                maze[x+3][y+1] = color;\n            }else{\n                maze[x][y] = color;\n                maze[x][y+1] = color;\n                maze[x][y+2] = color;\n                maze[x][y+3] = color;\n                maze[x+1][y+1] = color;\n                maze[x+1][y+2] = color;\n                maze[x+1][y+3] = color;\n                maze[x+1][y+4] = color;\n            }\n        }\n        load = maze[xstart][ystart];\n        answer(maze, xstart, ystart);\n        if(check == false){\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint g[105][105];\n\nvoid dfs(int a,int b,int p)\n{\n\tif(g[a][b]!=p)return;\n\n\tg[a][b]=-1;\n\n\tdfs(a+1,b,p);\n\tdfs(a-1,b,p);\n\tdfs(a,b+1,p);\n\tdfs(a,b-1,p);\n\t}\n\nint main()\n{\n\tint w,h,sx,sy,gx,gy,n;\n\twhile(true)\n\t{\t\n\t\tfor(int i=0;i<105;i++){\n\t\t\tfor(int j=0;j<105;j++){\n\t\t\t\tg[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)break;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\t\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tg[y][x]=c;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tg[y][x+1]=c;\n\t\t\t\tg[y][x+2]=c;\n\t\t\t\tg[y][x+3]=c;\n\t\t\t\tg[y+1][x]=c;\n\t\t\t\tg[y+1][x+1]=c;\n\t\t\t\tg[y+1][x+2]=c;\n\t\t\t\tg[y+1][x+3]=c;\n\t\t\t\t}\n\t\t\telse{\n\t\t\t\tg[y+1][x]=c;\n\t\t\t\tg[y+2][x]=c;\n\t\t\t\tg[y+3][x]=c;\n\t\t\t\tg[y][x+1]=c;\n\t\t\t\tg[y+1][x+1]=c;\n\t\t\t\tg[y+2][x+1]=c;\n\t\t\t\tg[y+3][x+1]=c;\n\t\t\t\t}\n\t\t\t}\n\t\n\tint p=g[sy][sx];\n\tif(p!=0)dfs(sy,sx,p);\n\tif(g[gy][gx]==-1){\n\t\tcout <<\"OK\" << endl;\n\t\t}\n\telse{\n\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint board[102][102];\nbool visited[102][102];\n\nint w, h, xg, yg;\n\nclass Point{\npublic:\n\tint x, y;\n\n\tPoint(int xx, int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n};\n\nbool judge(int, int);\nint main(void){\n\tconst int UNDEFINED = 0;\n\tconst int BLOCK_WIDTH = 2;\n\tconst int BLOCK_HEIGHT = 4;\n\n\tfor(int i = 0; i < 102; i ++)\n\t\tfor(int j = 0; j < 102; j ++){\n\t\t\tboard[i][j] = UNDEFINED;\n\t\t\tvisited[i][j] = false;\n\t\t}\t\n\tfor(int xs, ys, n; cin >> w >> h >> xs >> ys >> xg >> yg >> n, w, h;){\n\t\tfor(int i = 1; i <= w; i ++){\n\t\t\tfor(int j = 1; j <= h; j ++){\n\t\t\t\tboard[j][i] = UNDEFINED;\n\t\t\t\tvisited[j][i] = false;\n\t\t\t}\n\t\t}\n\n\t\twhile(n --){\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint width = (!d) ? BLOCK_HEIGHT:BLOCK_WIDTH;\n\t\t\tint height = (!d) ? BLOCK_WIDTH:BLOCK_HEIGHT;\n\n\t\t\tfor(int curX = x; curX <= x + width; curX ++)\n\t\t\t\tfor(int curY = y; curY <= y + height; curY ++)\n\t\t\t\t\tboard[curX][curY] = c;\n\t\t}\n\t\tcout << ((judge(xs, ys)) ? \"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n\nbool judge(int firstX, int firstY){\n\tqueue<Point> q; Point p(firstX, firstY);\n\tq.push(p);\n\tvisited[firstY][firstX] = true;\n\n\tint targetColor = board[firstY][firstX];\n\t\n\twhile(!q.empty()){\n\t\tif(visited[yg][xg]) return true;\n\t\tPoint currentNode = q.front(); q.pop();\n\n\t\tfor(int delta = -1; delta <= 1; delta += 2){\n\t\t\tfor(int a = 0; a < 2; a ++){\n\t\t\t\tPoint nextNode(currentNode.x + ((a)?delta:0), currentNode.y + ((a)?0:delta));\n\n\t\t\t\tif(!visited[nextNode.y][nextNode.x] && board[nextNode.y][nextNode.x] == targetColor){\n\t\t\t\t\tq.push(nextNode);\n\t\t\t\t\tvisited[nextNode.y][nextNode.x] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(ans == 1) return ;\n    //cout << xi <<\" \" << yi << endl;\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1,yi);\n        solve(xi,yi-1);\n        solve(xi+1,yi);\n        solve(xi,yi+1);\n    }\n    else return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(block));\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            //cout << x << \",\"<< y << endl;\n            if(d==1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        if(c==0) {cout <<\"NG\" << endl; continue;}\n        \n        //cout << xs << \" \" << ys << \" \" << c << endl;\n        //cout <<\"input \" << endl;\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint color,gx,gy;\nbool maze;\n\nvoid DFS1(int Y,int X){\n    if(F[Y][X]!=color)return;\n    if(Y==gy&&X==gx)maze=true;\n    \n    F[Y][X]=0;\n    \n    DFS1(Y-1,X  );\n    DFS1(Y  ,X-1);\n    DFS1(Y  ,X+1);\n    DFS1(Y+1,X  );\n}\n\nint main(){\n    int N,M,sx,sy,n;\n    cin >> N >> M;\n    while(N!=0&&M!=0){\n        cin >> sx >> sy >> gx >> gy >> n;\n        int c,d,nx,ny;\n        for(int i=0;i<n;i++){\n            cin >> c >> d >> nx >> ny;\n            for(int y=ny;y<ny+2*(1+d);y++){\n                for(int x=nx;x<nx+2*(2-d);x++){\n                    F[y][x] = c;\n                }\n            }\n        }\n\n        color = F[sy][sx];\n        maze = false;\n        if(color!=0){\n            DFS1(sy,sx);\n        }\n        cout << (maze?\"OK\":\"NG\") << endl;\n        for(int y=0;y<102;y++){\n            for(int x=0;x<102;x++){\n                F[y][x] = 0;\n            }\n        }\n        cin >> N >> M;\n    }\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint H,W,sy,sx,gy,gx;\nint N;\n\nint C[100][100];\nbool vis[100][100];\n\nsigned main(){\n    while(cin>>W>>H,W||H){\n        cin>>sx>>sy>>gx>>gy;\n        cin>>N;\n        sy--;sx--;gy--;gx--;\n        memset(C,0,sizeof(C));\n        rep(i,N){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--;y--;\n            for(int dy=0;dy<2;dy++){\n                for(int dx=0;dx<4;dx++){\n                    int ny,nx;\n                    if(!d)ny=y+dy,nx=x+dx;\n                    else ny=y+dx,nx=x+dy;\n                    C[ny][nx]=c;\n                }\n            }\n        }\n        if(!C[sy][sx]){\n            cout<<\"NG\"<<endl;\n            continue;\n        }\n\n        memset(vis,0,sizeof(vis));\n        queue<pint>que;\n        que.push(pint(sy,sx));\n        vis[sy][sx]=true;\n        while(que.size()){\n            int y,x;\n            tie(y,x)=que.front();\n            que.pop();\n            rep(i,4){\n                int ny=y+dy[i],nx=x+dx[i];\n                if(ny<0||ny>=H||nx<0||nx>=W||C[y][x]!=C[ny][nx]||vis[ny][nx])continue;\n                vis[ny][nx]=true;\n                que.push(pint(ny,nx));\n            }\n        }\n        if(vis[gy][gx])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint show=0;\nint w,h,sx,sy,gx,gy,d[101][101],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dy[i],nx=p.second+dx[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>w>>h){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<y+2+di*2;j++)for(int k=x;k<x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tif(!C)cout<<\"NG\"<<endl;\n\t\telse bfs();\n\t\tif(show){\n\t\t\tfor(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(field[i][j])cout<<field[i][j];else cout<<\" \";}cout<<endl;}\n\t\t\tfor(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(d[i][j]<INF)cout<<d[i][j]<<\" \";else cout<<\"  \";}cout<<endl;}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\n\nint fie[200][200];\nint color;\nint w,h;\nint sx,sy,gx,gy,n;\n\nvoid dfs(int y,int x){\n    int dx[]={1,0,-1,0};\n    int dy[]={0,1,0,-1};\n    fie[y][x]=9;\n    \n    rep(i,4){\n        if( 0<=x+dx[i] && x+dx[i]<w  &&  0<=y+dy[i] && y+dy[i]<h  &&  fie[ y+dy[i] ][ x+dx[i] ]==color ){\n            dfs(y+dy[i],x+dx[i]);\n        }\n    }\n}\n\n\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0&&h==0)break;\n        rep(i,200)rep(j,200)fie[i][j]=0;\n        \n        cin>>sx>>sy>>gx>>gy>>n;\n        sx--,sy--,gx--,gy--;\n        rep(i,n){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            \n            if(d==0){\n                int dx[]={0,0,1,1,2,2,3,3};\n                int dy[]={0,1,0,1,0,1,0,1};\n                rep(i,8) fie[y+dy[i]][x+dx[i]]=c;\n            }else{\n                int dx[]={0,1,0,1,0,1,0,1};\n                int dy[]={0,0,1,1,2,2,3,3};\n                rep(i,8) fie[y+dy[i]][x+dx[i]]=c;\n            }\n        }\n        \n        color=fie[sy][sx];\n        dfs(sy,sx);\n        if(fie[gy][gx]==9)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,color;\nstring res = \"NG\";\nvoid write(Matrix &board,int c, int d, int x, int y){\n  int width,length;\n  if(d == 0){ width = 4; length =2; }\n  if(d == 1){ width = 2; length =4; }\n  for(int i=0; i<width; ++i){\n    for(int j=0; j<length; ++j)\n      board[x+i][y+j]=c;\n  }\n}\nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && color==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && color==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && color==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && color==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  int c,d,x,y;\n  while(cin >> w >> h,w||h){\n    if( w==0 && h==0) return 0;\n    res = \"NG\";\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> c >> d >> x >> y;\n      --x; --y;\n      write(board,c,d,x,y);\n    }\n    color = board[xs][ys];\n    func(board,xs,ys);\n    cout << res << endl;\n    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint w,h;\n\tint xs,ys;\n\tint xg,yg;\n\tint n;\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tint field[101][101];\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfill(field[i],field[i]+101,0);\n\n\t\tcin>>xs>>ys;\n\t\tcin>>xg>>yg;\n\t\txs--;ys--;xg--;yg--;\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;y--;\n\t\t\tif(d==0){\n\t\t\t\tfor(int j = y; j < 2+y; j++){\n\t\t\t\t\tfor(int k = x; k < x + 4; k++){\n\t\t\t\t\t\tfield[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < 4+y; j++){\n\t\t\t\t\tfor(int k = x; k < x + 2; k++){\n\t\t\t\t\t\tfield[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// bfs\n\t\tint c=field[ys][xs];\n\t\t//if(c==0){\n\t\t//\tcout<<\"NG\"<<endl;\n\t\t//\tcontinue;\n\t\t//}\n\t\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\t\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\n\t\tconst int dy[]={-1,0,0,1};\n\t\tconst int dx[]={0,-1,1,0};\n\n\t\tbool passed[101][101];\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfill(passed[i],passed[i]+101,false);\n\n\t\tprv->push(make_pair(xs,ys));\n\n\t\tbool fin=false;\n\t\twhile(prv->size()){\n\t\t\twhile(prv->size()){\n\t\t\t\tpair<int,int> p = prv->front();\n\t\t\t\tprv->pop();\n\t\t\t\tif(p.first==yg&&p.second==xg){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(passed[p.first][p.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tpassed[p.first][p.second]=true;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]==c&&!passed[ny][nx]){\n\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tswap(prv,nxt);\n\t\t}\n\t\tif(fin){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"NG\"<<endl;\n\t\tdelete prv,nxt;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <utility>\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nint sx,sy,gx,gy;\nint w,h,n;\nint g[1000][1000];\nbool valid(int y, int x){ return 0<=x && x<w && 0<=y && y<h; }\n\nint main(){\n    while(cin>>w>>h && w){\n        cin>>sx>>sy>>gx>>gy;\n        sx--,sy--,gx--,gy--;\n        rep(i,h)rep(j,w)g[i][j]=0;\n        cin>>n;\n        rep(i,n){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n            if(d==0)x+=2;else y+=2;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n        }\n        int C=g[sy][sx];\n        // cout<<C<<endl;\n        // rep(i,h){\n        //     rep(j,w){\n        //         cout<<g[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        rep(i,h)rep(j,w)g[i][j]= (g[i][j]==C) ? C : 0;\n\n        bool vis[1000][1000]={};\n        vis[sy][sx]=true;\n        if(C){\n            stack<pii> s;\n            vis[sy][sx]=true;\n            s.emplace(sy,sx);\n            while(s.size()){\n                int y,x;\n                tie(y,x) = s.top();s.pop();\n                rep(d,4){\n                    int nx=x+dx[d],ny=y+dy[d];\n                    if(!valid(nx,ny))continue;\n                    if(vis[ny][nx])continue;\n                    vis[ny][nx]=true;\n                    s.emplace(ny,nx);\n                }\n            }\n        }\n        puts(C && vis[gy][gx] ? \"OK\" : \"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid DFS(int x,int y,int c){\n    if(f[x][y]!=c)  return;\n\n    f[x][y]=10;\n    DFS(x+1,y,c);\n    DFS(x-1,y,c);\n    DFS(x,y+1,c);\n    DFS(x,y-1,c);\n}\n\nvoid print(int w,int h){\n    for(int i=1;i<=w;i++){\n        for(int j=1;j<=h;j++){\n            cout<<f[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    while(true){\n        cin>>w>>h;\n        if(w+h==0)  break;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                f[i][j]=-1;\n            }\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        for(int i=0;i<n;i++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            if(d==0){\n                for(int j = 0; j<4; j++){\n                    for(int k = 0; k<2; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }else{\n                for(int j = 0; j<2; j++){\n                    for(int k = 0; k<4; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }\n        }\n        //print(w,h);\n        DFS(xs,ys,f[xs][ys]);\n        //print(w,h);\n        if(f[xg][yg]==10){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101] = {};\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc) return;\n\t\tfunc(x + nx[i], y + ny[i]);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> c >> d >> x >> y;\n\t\tif (d == 0){\n\t\t\tbw = 4;\n\t\t\tbh = 2;\n\t\t}\n\t\telse{\n\t\t\tbw = 2;\n\t\t\tbh = 4;\n\t\t}\n\t\tfor (int j = 0; j < bh; j++){\n\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t}\n\tbc = stage[1][1];\n\tfunc(1, 1);\n\tif (ans == true) cout << \"OK\\n\";\n\telse cout << \"NG\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 120;\n\nint maze[MAX][MAX];\nbool come[MAX][MAX];\nP s,g;\nint W,H,c;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  memset(maze,0,sizeof(maze));\n}\n\n\nvoid input_B(){\n  int n;\n  cin >> n;\n  while(n--){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d){\n      for(int i = y; i < y+4; i++)\n\tfor(int j = x; j < x+2; j++)\n\t  maze[i][j] = c;\n    }else{\n      for(int i = y; i < y+2; i++)\n\tfor(int j = x; j < x+4; j++)\n\t  maze[i][j] = c;\n    }\n  }\n}\n\n\nvoid solve(P p){\n  \n  if(come[p.second][p.first] == false){\n    come[p.second][p.first] = true;\n    for(int i = 0; i < 4; i++)\n      if(0 < p.first+dx[i] && p.first+dx[i] <= W &&\n\t 0 < p.second+dy[i] && p.second+dy[i] <= H &&\n\t maze[p.second][p.first] == c) solve(P(p.first+dx[i],p.second+dy[i]));\n  }\n}\n\nvoid print(){\n  for(int i = 1; i < H; i++){\n    for(int j = 1; j < W; j++)// cout << come[i][j];\n      cout << maze[i][j];\n    cout << endl;\n  }\n\n}\n\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    cin >> s.first >> s.second;\n    cin >> g.first >> g.second;\n    input_B();\n    c = maze[s.second][s.first];\n    solve(s);\n    //print();\n    if(come[g.second][g.first] && c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint moveTo[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\nint stage[100][100];\n\nvoid paint(int c,int d,int x,int y){\n\t//c:1~5 d: 0:horizonal 1:vertical\n\tif(d==0){\n\t\tfor(int i=x;i<x+4;i++){\n\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg){\n\tint cs = stage[ys][xs];\n\tint cg = stage[yg][xg];\n\tif(cs != cg) return false;\n\n\tqueue<P> que;\n\tque.push(P(ys,xs));\n\n\twhile(!que.empty()){\n\t\tint sx = que.front().first;\n\t\tint sy = que.front().second;\n\t\t\n\t\tif(sx == xg && sy == yg) return true;\n\t\tque.pop();\n\n\t\tstage[sy][sx] = -1;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = sx + moveTo[i][0];\n\t\t\tint dy = sy + moveTo[i][1];\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(stage[dy][dx] != cs || stage[dy][dx] == -1) continue;\n\t\t\tque.push(P(dx,dy));\n\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tint xs,ys;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\n\t\tint xg,yg;\n\t\tscanf(\"%d %d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\t//c:1~5 d: 0:horizonal 1:vertical\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tpaint(c,d,x,y);\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(w,h,xs,ys,xg,yg) ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nconst int MAX_W = 100, MAX_H = 100;\n\ntypedef std::pair<int,int> P;\nint map[MAX_H + 1][MAX_W + 1], w, h;\n\nint bfs(P sp, P gp, int c){\n\t//½±Æª é©ði[\n\tint f[MAX_H + 1][MAX_W + 1] = {{0}};\n\tstd::queue<P> q;\n\tq.push(P(sp.first, sp.second));\n\t\n\twhile(q.size()){\n\t\tP p = q.front(); q.pop();\n\t\t//S[Å«½ç¬÷\n\t\tif(p.first == gp.first && p.second == gp.second)return 1;\n\t\t\n\t\tint vy[4] = {-1, 1, 0, 0}, vx[4] = {0, 0, -1, 1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = p.first + vx[i], ny = p.second + vy[i];\n\t\t\tif(nx >= 0 && nx <= w && ny >= 0 && ny <= h && map[ny][nx] == c && !f[ny][nx])\n\t\t\t\tq.push(P(nx,ny)), f[ny][nx] = 1;\n\t\t}\n\t}\n\n\t//ÅãÜÅS[Å«È¢Èç¸s\n\treturn 0;\n}\n\nint main(){\n\tP sp, gp;\n\twhile(std::cin >> w >> h, w && h){\n\t\tmemset(map,0,sizeof(map));\n\t\tstd::cin >> sp.first >> sp.second;\n\t\tstd::cin >> gp.first >> gp.second;\n\n\t\tint n;\n\t\tstd::cin >> n;\n\t\t//ubNÌÝu\n\t\twhile(n--){\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint mx, my;\n\t\t\tif(d)//w < h\n\t\t\t\tmy = 4, mx = 2;\n\t\t\telse//w > h\n\t\t\t\tmx = 4, my = 2;\n\t\t\tfor(int i=y;i<y+my;i++)\n\t\t\t\tfor(int j=x;j<x+mx;j++)\n\t\t\t\t\tmap[i][j] = c;\n\t\t}\n\n\t\tint sc = map[sp.second][sp.first];\n\n\t\t//bfsÅS[Å«é©mF\n\t\tif(bfs(sp, gp, sc))std::cout << \"OK\" << std::endl;\n\t\telse std::cout << \"NG\" << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h, n;\nint xs,ys, xg,yg;\nint c,d,x,y;\nchar board[100][100];\n\nbool rec(int y, int x, char c){\n  if( y<0 || x<0 )\n    return false;\n  if( y>=h || x>=w )\n    return false;\n\n  if( board[y][x] !=c )\n    return false;\n\n  if( y==yg && x==xg )\n    return true;\n  board[y][x] = 9;\n\n  int dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\n  for( int z=0;z<4;z++ ){\n    if( rec(y+dy[z], x+dx[z], c) )\n      return true;\n  }\n\n  return false;\n}\nint main(){\n  while(cin>>w>>h,w){\n    for( int i=0;i<h;i++ )\n      for( int j=0;j<w;j++ )\n\tboard[i][j] = 0;\n\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    xs--;ys--;\n    xg--;yg--;\n\n    cin >> n;\n    while(n--){\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      int li=d?4:2; // d==0 => yoko\n      int lj=d?2:4;\n\n      for( int i=0;i<li;i++ )\n\tfor( int j=0;j<lj;j++ )\n\t  board[y+i][x+j] = c;\n    }\n    if( rec(ys, xs, board[ys][xs]) )\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n    /*\n    for( int i=0;i<h;i++ ){\n      for( int j=0;j<w;j++ )\n\tcout << (int)board[i][j];\n      cout << endl;\n    }\n    */\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg,ok;\n\nvoid Maze(int X,int Y,int C){\n\t//cout << X<<Y<<F[X][Y]<<endl;\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\t\n\n\tif(X==xg&&Y==yg){\n\t\tcout << \"OK\"<<endl;\n\t\tok++;\n\t}\n\n\tF[X][Y]='.';\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tok=0;\n\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\t\tfor(int i=1; i<=w; i++)\n\t\t\tfor(int j=1; j<=h; j++)\n\t\t\t\tF[j][i]=0;\n\n\n\t\t//for(int i=0; i<=101;i++){\n\t\t\t//F[0][i]=6;\n\t\t\t//F[i][0]=6;\n\t\t//}\n\n\t\tfor(int i=1; i<=w;i++){\n\t\t\t\tF[w+1][i]=6;\n\t\t\t\tF[0][i]=6;\n\t\t}\n\t\tfor(int i=1; i<=h;i++){\n\t\t\t\tF[i][h+1]=6;\n\t\t\t\tF[i][0]=6;\n\t\t}\n\n\t\tint N=0;\n\t\twhile(N<n){\n//cout <<N;\n\t\t\tcin >>c>>d>>x>>y;\n//cout<<c<<d<<x<<y<<endl;\n\t\t\tif(d){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tF[i][j]=c;\n//cout <<F[i][j];\n\t\t\t\t}\n//cout <<endl;\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tF[i][j]=c;\n//cout <<F[i][j];\n\t\t\t\t\t}\n//cout <<endl;\n\t\t\t}\n\t\t\tN++;\n\t\t}\n\nfor(int i=0; i<=101; i++){\n\tfor(int j=0; j<=101; j++){\n\t\tcout <<F[j][i];\n\t\t}\n\tcout << endl;\n}\n\t\t\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t\tif(ok==0)\n\t\t\tcout <<\"NG\"<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\nint board[100][100];\nbool memo[100][100];\nint w, h;\n\nvoid judge(int x, int y, int c){\n  if(x<0 || y<0 || x>=w || y>=h)return;\n  if(board[y][x]!=c)return;\n  if(memo[y][x])return;\n  memo[y][x] = 1;\n  judge(x-1, y, c);\n  judge(x+1, y, c);\n  judge(x, y-1, c);\n  judge(x, y+1, c);\n  return;\n}\nint main(){\n  int xs, ys, xg, yg, n, i, j, k, c, d, x, y;\n  while(cin>> w >> h, w+h){\n    for(i=0; i<100; i++){\n      for(j=0; j<100; j++){\n        board[i][j] = 0;\n      }\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d==0){\n        for(j=y-1; j<y+1; j++){\n          for(k=x-1; k<x+3; k++){\n            board[j][k] = c;\n          }\n        }\n      }else{\n        for(j=y-1; j<y+3; j++){\n          for(k=x-1; k<x+1; k++){\n            board[j][k] = c;\n          }\n        }\n      }\n    }\n    judge(xs-1, ys-1, board[ys-1][xs-1]);\n    if(memo[yg-1][xg-1]==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main()\n{\n\tstatic int board[101][101],wf[10300][10300];\n\tint dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\n\tfor(int w,h;cin>>w>>h,w;){\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)board[i][j]=-1;\n\t\tint xs,ys,xg,yg,n;\tcin>>xs>>ys>>xg>>yg>>n;\n\t\twhile(n--){\n\t\t\tint c,d,x,y;\tcin>>c>>d>>x>>y;\n\t\t\tfor(int i=0;i<(d?4:2);i++)for(int j=0;j<(d?2:4);j++)board[y+i][x+j]=c;\n\t\t}\n\n\t\tif(board[ys][xs]!=board[yg][xg])\tcout<<\"NG\"<<endl;\n\t\telse{\n\t\t\tint clr=board[ys][xs];\n\t\t\tfor(int i=1;i<=w*h;i++)for(int j=1;j<=w*h;j++)wf[i][j]=1000000;\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(board[i][j]==clr){\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tint xx=j+dx[k],yy=i+dy[k];\n\t\t\t\t\t\t\tif(0<xx&&xx<=w&&0<yy&&yy<=h&&board[yy][xx]==clr)\n\t\t\t\t\t\t\t\twf[w*i+j][w*yy+xx]=wf[w*yy+xx][w*i+j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k=1;k<=w*h;k++)for(int i=1;i<=w*h;i++)for(int j=1;j<=w*h;j++)\n\t\t\t\twf[i][j]=min(wf[i][j],wf[i][k]+wf[k][j]);\n\n\t\t\tcout<<(wf[w*ys+xs][w*yg+xg]==0?\"OK\":\"NG\")<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       F[0][102] = 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h; i++) {\n                for (int j = 0; j <= w; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\nint flag;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n     flag = 1;\n     return;\n  }\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  flag = 0;\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[102][102] = {};\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc) return;\n\t\tfunc(x + nx[i], y + ny[i]);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\twhile (1){\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tbw = 4;\n\t\t\t\tbh = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbw = 2;\n\t\t\t\tbh = 4;\n\t\t\t}\n\t\t\tfor (int j = 0; j < bh; j++){\n\t\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = stage[1][1];\n\t\tif (bc == 0) cout << \"NG\\n\";\n\t\tfunc(1, 1);\n\t\tif (ans == true) cout << \"OK\\n\";\n\t\telse cout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c,d,x,y;\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(x == xs &&y == ys){\n        cbase = c;\n      }\n\n      if(d == 0 && c == cbase){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n      if(d==1 && c==cbase){\n        for(int j = x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    meiro(xs,ys,cbase);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }\n    if(C[xg][yg] != -1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\n\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\" << \"\\n\";\n\t}else{\n\t\tcout << \"NG\" << \"\\n\";#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\nbool isfirst = true;\nwhile(true){\n\tif(isfirst){\n\t\tisfirst = false;\n\t}else{\n\t\tcout << endl;\n\t}\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\";\n\t}else{\n\t\tcout << \"NG\";\n\t}\n}\n\treturn 0;\n}\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\t// used[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n\tgoal=0;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\nvector < vector <int> > block_map;\nvector < vector <bool> > visited;\n\nint xs, ys;\nint xg, yg;\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, -1, 0, 1 };\n\nbool dfs( int x, int y )\n{\n\tif ( block_map[x][y] != block_map[xg][yg] )\n\t\treturn false;\n\tif ( x == xg && y == yg )\n\t\treturn true;\n\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif ( nx < 0 || nx >= w || ny < 0 || ny >= h )\n\t\t\tcontinue;\n\n\t\tif ( visited[ny][nx] == false && block_map[ny][nx] == block_map[ys][xs] )\n\t\t{\n\t\t\tvisited[ny][nx] = true;\n\t\t\tif ( dfs( nx, ny ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvisited[ny][nx] = false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\tcin >> w >> h;\n\t\tif ( w == 0 && h == 0 )\n\t\t\tbreak;\n\n\t\tblock_map = vector < vector <int> >( h, vector <int>(w,0) );\n\t\tvisited = vector < vector <bool> >( h, vector <bool>(w,false) );\n\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\txs--;\n\t\tys--;\n\t\txg--;\n\t\tyg--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( d == 0 )\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 2; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 4; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 4; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 2; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dfs( xs, ys ) )\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// based on http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2784229#1\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n  if (x == goalx && y == goaly) { return true; }\n  canGo[y][x] = false;\n  for (int i = 0; i < 4; i++) {\n    int next_x = x + needleX[i];\n    int next_y = y + needleY[i];\n \n    if (canGo[next_y][next_x]) {\n      bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n      if (flag)\n        return true;\n    }\n  }\n  return false;\n}\nint main(void) {\n  int h, w, n;\n  std::cin >> w >> h;\n  std::vector<std::string> ans;\n  while(!(h == 0 && w == 0)){\n    int color=-1, orient, leftX, leftY;\n    int sx, sy, gx, gy;\n    std::cin >> sx >> sy >> gx >> gy;\n    std::vector<std::vector<int>> board(h + 2, std::vector<int>(w + 2, 0));\n    std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n    std::cin >> n;\n    int start = -1, goal = -1;\n    for (int i = 0; i < n; i++) {\n      std::cin >> color >> orient >> leftX >> leftY;\n \n \n      if (orient == 0) {\n        for (int j = 0; j <= 3; j++) {\n          for (int k = 0; k <= 1; k++) {\n            board[leftY + k][leftX + j] = color;\n            if (leftX + j == sx && leftY + k == sy) {\n              start = color;\n            }\n            else if (leftX + j == gx && leftY + k == gy) {\n              goal = color;\n            }\n          }\n        }\n \n      }\n      else {\n        for (int j = 0; j <= 1; j++) {\n          for (int k = 0; k <= 3; k++) {\n            board[leftY + k][leftX + j] = color;\n            if (leftX + j == sx && leftY + k == sy) {\n              start = color;\n            }\n            else if (leftX + j == gx && leftY + k == gy) {\n              goal = color;\n            }\n          }\n        }\n      }\n    }\n\n    // for (int i = 0; i <= h; i++) {\n    //   for (int j = 0; j <= w; j++) {\n    //     std::cerr << board[i][j] << \" \";\n    //   }\n    //   std::cerr << std::endl;\n    // }\n    \n    if (start != -1) {\n      for (int i = 0; i <= h; i++) {\n        for (int j = 0; j <= w; j++) {\n          if (board[i][j] == start) {\n            canGo[i][j] = true;\n          }\n        }\n      }\n    }\n\n    if (start != goal || start == -1) {\n      ans.push_back(\"NG\");\n      std::cin >> w >> h;\n      continue;\n    }\n\n    bool result = dfs(sx, sy, gx, gy, canGo);\n    if (result) { ans.push_back(\"OK\"); }\n    else { ans.push_back(\"NG\"); }\n    std::cin >> w >> h;\n  }\n  int anssize = ans.size();\n  for (int i = 0; i < anssize; i++) {\n    std::cout << ans[i] << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 120;\n\nint maze[MAX][MAX];\nbool come[MAX][MAX];\nP s,g;\nint W,H,c;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  memset(maze,0,sizeof(maze));\n}\n\n\nvoid input_B(){\n  int n;\n  cin >> n;\n  while(n--){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d){\n      for(int i = y; i < y+4; i++)\n\tfor(int j = x; j < x+2; j++)\n\t  maze[i][j] = c;\n    }else{\n      for(int i = y; i < y+2; i++)\n\tfor(int j = x; j < x+4; j++)\n\t  maze[i][j] = c;\n    }\n  }\n}\n\n\nvoid solve(P p){\n  \n  if(come[p.second][p.first] == false){\n    come[p.second][p.first] = true;\n    for(int i = 0; i < 4; i++)\n      if(0 < p.first+dx[i] && p.first+dx[i] <= W &&\n\t 0 < p.second+dy[i] && p.second+dy[i] <= H &&\n\t maze[p.second+dy[i]][p.first+dx[i]] == c) solve(P(p.first+dx[i],p.second+dy[i]));\n  }\n}\n\nvoid print(){\n  for(int i = 1; i < H; i++){\n    for(int j = 1; j < W; j++)// cout << come[i][j];\n      cout << maze[i][j];\n    cout << endl;\n  }\n\n}\n\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    cin >> s.first >> s.second;\n    cin >> g.first >> g.second;\n    input_B();\n    c = maze[s.second][s.first];\n    solve(s);\n    //print();\n    if(come[g.second][g.first] && c) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  //DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n\nusing namespace std;\ntypedef pair<int, int> P;\nint maze[100][100];\nbool used[100][100];\nint main()\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n//\tcut here before submit \n//\tfreopen (\"testcase.block\", \"r\", stdin );\n\tint w, h;\n\n\twhile (cin >> w >> h && w && h ){\n\t\tmemset (maze, 0, sizeof(maze ) );\n\t\tmemset (used, false, sizeof (used ) );\n\n\t\tP start, goal;\n\t\tcin >> start.first >> start.second;\n\t\tstart.first--; start.second--;\n\t\tcin >> goal.first >> goal.second;\n\t\tgoal.first--; goal.second--;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tint color, dir;\n\t\t\tP block;\n\t\t\tcin >> color >> dir >> block.first >> block.second;\n\t\t\tblock.first--; block.second--;\n\t\t\tif (dir == 0 ){\n\t\t\t\tfor (int col = 0; col < 4; ++col ){\n\t\t\t\t\tmaze[block.second][block.first+col] = color;\n\t\t\t\t\tmaze[block.second+1][block.first+col] = color;\n\t\t\t\t} // end for\n\t\t\t}else{\n\t\t\t\tfor (int row = 0; row < 4; ++row ){\n\t\t\t\t\tmaze[block.second+row][block.first] = color;\n\t\t\t\t\tmaze[block.second+row][block.first+1] = color;\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t} // end for\n\t\tqueue<P> que;\n\t\tque.push (P(start.first, start.second ) );\n\t\tint search_color = maze[start.second][start.first];\n\t\tbool found = false;\n\n\t\twhile (!que.empty() ){\n\t\t\tP curr = que.front(); que.pop();\n\t\t\tint x = curr.first;\n\t\t\tint y = curr.second;\n\t\t\tif (x == goal.first && y == goal.second ){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t\tused[y][x] = true;\n\t\t\tfor (int k = 0; k < 4; ++k ){\n\t\t\t\tint nx = x + dir[k][0];\n\t\t\t\tint ny = y + dir[k][1];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h )\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((maze[ny][nx] == search_color) && !used[ny][nx] ){\n\t\t\t\t\tP next; next.first = nx; next.second = ny;\n\t\t\t\t\tque.push (next );\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end while\n\n\t\tif (found )\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 0;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = map[xs][ys];\n\t\tif(color!=0)\n\t\t\troute(xs, ys, color);\n\t\tif (map[xg][yg]==0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring ans;\nint w,h,gx,gy;\nint map[110][110];\nint dx_[4] = {0,1,0,-1};\nint dy_[4] = {1,0,-1,0};\nint dx[2][8] = {\n\t{0,1,2,3,0,1,2,3},\n\t{0,1,0,1,0,1,0,1}\n};\nint dy[2][8] = {\n\t{0,0,0,0,1,1,1,1},\n\t{0,0,1,1,2,2,3,3},\n};\nvoid solve(int x,int y,int color){\n\tif( ans == \"OK\" || color == 0 /*|| map[y][x] != color*/ ) return;\n\t//if( x<0 || x>w || y<0 || y>h ) return;\n\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx_[i];\n\t\tint my = y + dy_[i];\n\t\tif( mx<0 || mx>w || my<0 || my>h ) continue;\n\t\t//cout << \"x:\" << x << \" y:\" << y << endl;\n\t\t\n\t\tif( map[my][mx] == color ){\n\t\t\tif( mx == gx && my == gy ){\n\t\t\t\tans = \"OK\";\n\t\t\t}else{\n\t\t\t\tmap[my][mx] = 0;\n\t\t\t\tsolve( mx , my , color );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid debug(){\n\tchar c[6] = {' ','#','$','*','+','@'};\n\tcout << \"w:\" << w << \" h:\" << h << \" map : \" << endl;\n\tfor(int y=0 ; y<h ; ++y ){\n\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\tcout << c[ map[y][x] ];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint sx,sy,n;\n\t\n\twhile( cin >> w >> h , w|h ){\n\t\tans = \"NG\";\n\t\tfor(int y=0 ; y<110 ; ++y )\n\t\t\tfor(int x=0 ; x<110 ; ++x )\n\t\t\t\tmap[y][x] = 0;\n\n\t\tcin >> sx >> sy >> gx >> gy >> n ;\n\t\tfor(int i=0 ; i<n ; ++i ){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor(int j=0 ; j<8 ; j++){\n\t\t\t\tint mx = x + dx[d][j];\n\t\t\t\tint my = y + dy[d][j];\n\t\t\t\tmap[my][mx] = c;\n\t\t\t}\n\t\t}\n\t\t//debug();\n\t\t//map[sy][sx] = 0;\n\t\tsolve( sx , sy , map[sy][sx] );\n\t\t//cout << \"sx:\" << sx << \" sy:\" << sy << endl;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        // sx--, sy--, gx--, gy--;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(W+1, vector<int>(H+1));\n        vector<vector<int> > used(W+1, vector<int>(H+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            // x--, y--;\n            if (dir) {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx <= H && 0 <= ny && ny <= W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = j;i<k;i++)\nint w,h,xs,ys,xg,yg,n;\nint m[102][102];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool DFS(int x,int y,int c){\n  if(m[x][y]!=c)return false;\n  if(x==xg && y == yg)return true;\n  m[x][y]=-1;\n  bool ans =false;\n  rep(i,0,4){\n    ans = max(ans,DFS(x+dx[i],y+dy[i],c));\n  }\n  return ans;\n}\nint main(){\n  cin >>w>>h;\n  while(w!=0){\n    cin>>xs>>ys>>xg>>yg>>n;\n    xs++;\n    ys++;\n    xg++;\n    yg++;\n    rep(i,0,102)rep(j,0,102)m[i][j]=-1;\n    rep(i,0,n){\n      int c,d,x,y;\n      cin >>c>>d>>x>>y;\n      x++;\n      y++;\n      if(d==0){\n        rep(j,x,x+4)rep(k,y,y+2)m[j][k]=c;\n      }else{\n        rep(j,x,x+2)rep(k,y,y+4)m[j][k]=c;\n      }\n    }\n    string ans[2]={\"NG\",\"OK\"};\n    if(m[xs][ys]==-1)cout <<\"NG\"<<endl;\n    else cout << ans[DFS(xs,ys,m[xs][ys])]<<endl;\n    cin >> w>>h;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nbool dfs(vector<vector<int> > &g);\n\nint sx, sy, gx, gy;\nint n, m; \nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint main()\n{\n\nwhile(cin >> n >> m,(n|m)){\n m++; n++;\n vector<vector<int> > graph(m,vector<int>(n,0));\n \n cin>>sx>>sy>>gx>>gy;\n int bl;  cin>>bl;\n loop(i, bl){\n  int a,b,c,t; cin>>a>>b>>c>>t;\n  if(!b){\n   for(int j=t;j<t+2;j++){\n    for(int k=c;k<c+4;k++){\n     graph[j][k] = a;\n    }\n   } \n  } else {\n   for(int j=c;j<c+2;j++){\n    for(int k=t;k<t+4;k++){\n     graph[j][k] = a;\n    }\n   }\n  }\n }\ncout << ((dfs(graph)) ? \"OK\" : \"NG\") << endl;\n}\nreturn 0;\n}\n\nbool dfs(vector<vector<int> > &g) {\nint cl = g[sy][sx];\nvector<vector<bool> > vsed(m,vector<bool>(n,false));\nqueue<i_i > q;\nq.push(mp(sx,sy));\nwhile(!q.empty()){\nint x = q.front().first, y = q.front().second;\nq.pop();\nif(x == gx && y == gy){\nreturn true;\n}\nif(vsed[y][x]){\ncontinue;\n} else {\nvsed[y][x]=true;\n}\n\nloop(i, 4) {\nint nx = x +dx[i], ny = y +dy[i];\nif(0<nx && nx < n && 0<ny && ny < m){\nif(g[ny][nx] == cl){\nq.push(mp(nx,ny));\n}\n} \n}\n\n}\nreturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) { return false; }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h+1; i++) {\n                for (int j = 0; j <= w+1; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    for (std::string i : ans) {\n        std::cout << i << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(), (c).end()\n#define contains(c, x) ((c).find(x) != (c).end())\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) REP(i, 0, (n))\n\nusing namespace std;\n\nint a[101][101];\nint dx[] = { -1, 1, 0, 0 };\nint dy[] = { 0, 0, -1, 1 };\nint main()\n{\n\tint w, h, sx, sy, gx, gy, n;\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (!(w | h)) break;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tsx--, sy--, gx--, gy--;\n\t\tint c, d, x, y;\n\t\trep(k, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tREP(i, y-1, y+1) REP(j, x-1, x+3) a[i][j] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tREP(i, y-1, y+3) REP(j, x-1, x+1) a[i][j] = c;\n\t\t\t}\n\t\t}\n\t\tif (a[sy][sx] != a[gy][gx]) {\n\t\t\tputs(\"NG\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool f = false;\n\t\tqueue<pair<int, int> > q;\n\t\tset<pair<int, int> > s;\n\t\tpair<int, int> start = mp(sy, sx);\n\t\tpair<int, int> goal = mp(gy, gx);\n\t\tq.push(start);\n\t\ts.insert(start);\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> t = q.front(); q.pop();\n\t\t\tif (t == goal) { f = true; break; }\n\t\t\trep(i, 4) {\n\t\t\t\tint r = t.first + dy[i];\n\t\t\t\tint c = t.second + dx[i];\n\t\t\t\tif (r < 0 || r >= h || c < 0 || c >= w) continue;\n\t\t\t\tif (a[sy][sx] != a[r][c] || contains(s, mp(r, c))) continue;\n\t\t\t\tq.push(mp(r, c));\n\t\t\t\ts.insert(mp(r, c));\n\t\t\t}\n\t\t}\n\t\tputs((f ? \"OK\" : \"NG\"));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint W, H, sx, sy, gx, gy, N, c, d, x, y, r[111][111], vis[111][111];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint main() {\n\twhile(cin >> W >> H, W | H) {\n\t\tcin >> sx >> sy >> gx >> gy; sx--, sy--, gx--, gy--;\n\t\tmemset(r, 0, sizeof(r));\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\t\t\tint zx = (d ? 2 : 4), zy = (d ? 4 : 2);\n\t\t\tfor(int j = 0; j < zy; j++) {\n\t\t\t\tfor(int k = 0; k < zx; k++) {\n\t\t\t\t\tr[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis)); vis[sy][sx] = 1;\n\t\tqueue<pair<int, int> > que; que.push(make_pair(sx, sy));\n\t\twhile(!que.empty()) {\n\t\t\tpair<int, int> v = que.front(); que.pop();\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint tx = v.first + dx[i], ty = v.second + dy[i];\n\t\t\t\tif(0 <= tx && tx < W && 0 <= ty && ty < H && !vis[ty][tx] && r[ty][tx] == r[v.second][v.first]) {\n\t\t\t\t\tvis[ty][tx] = 1;\n\t\t\t\t\tque.push(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (vis[gy][gx] ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n       /* for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nvoid putblock(int x,int y,int c,int d);\nbool bfs(std::pair<int,int> start,std::pair<int,int> goal);\n\nstd::queue< std::pair<int,int> > que;\nint board[102][102];\nbool visited[102][102];\n\nint main()\n{\n\tint n,w,h,x,y,c,d,xs,ys,xg,yg;\n\t\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tmemset(board,0,sizeof(board));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tputblock(x,y,c,d);\n\t\t}\n\t\tif(bfs(std::pair<int,int>(xs,ys),std::pair<int,int>(xg,yg)))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid putblock(int x,int y,int c,int d)\n{\n\tint h,w;\n\tif(d==0)\n\t{\n\t\th=2;\n\t\tw=4;\n\t}\n\telse\n\t{\n\t\th=4;\n\t\tw=2;\n\t}\n\tfor(int i=y;i<y+h;i++)\n\t{\n\t\tfor(int j=x;j<x+w;j++)\n\t\t{\n\t\t\tboard[i][j]=c;\n\t\t}\n\t}\n}\n\nbool bfs(std::pair<int,int> start,std::pair<int,int> goal)\n{\n\tint x,y;\n\tif(board[start.second][start.first]==0||board[goal.second][goal.first]==0)return false;\n\tque.push(start);\n\twhile(!que.empty())\n\t{\n\t\tque.pop();\n\t\tx=que.front().first;\n\t\ty=que.front().second;\n\t\t\n\t\tif(!visited[y][x])\n\t\t{\n\t\t\tvisited[y][x]=true;\n\t\t\tif(board[y-1][x]==board[y][x])que.push(std::pair<int,int>(x-1,y));\n\t\t\tif(board[y+1][x]==board[y][x])que.push(std::pair<int,int>(x+1,y));\n\t\t\tif(board[y][x-1]==board[y][x])que.push(std::pair<int,int>(x,y-1));\n\t\t\tif(board[y][x+1]==board[y][x])que.push(std::pair<int,int>(x,y+1));\n\n\t\t\tif(x==goal.first&&y==goal.second)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nbool solve(vvi& field,int x,int y,int xg,int yg,int c)\n{\n\tif(field[y][x]==0)\n\t\treturn false;\n\tif(field[y][x]!=c)\n\t\treturn false;\n\tif(x==xg && y==yg)\n\t\treturn true;\n\tfield[y][x]=-1;\n\tbool res=0;\n\tres|=solve(field,x-1,y,xg,yg,c);\n\tres|=solve(field,x+1,y,xg,yg,c);\n\tres|=solve(field,x,y-1,xg,yg,c);\n\tres|=solve(field,x,y+1,xg,yg,c);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tint xs,ys,xg,yg,n; cin>>xs>>ys>>xg>>yg>>n;\n\t\tvvi field(110,vi(110));\n\t\trep(k,n){\n\t\t\tint c,d,x,y; cin>>c>>d>>x>>y;\n\t\t\tif(d)\n\t\t\t\trep(i,4) rep(j,2)\n\t\t\t\t\tfield[y+i][x+j]=c;\n\t\t\telse\n\t\t\t\trep(i,2) rep(j,4)\n\t\t\t\t\tfield[y+i][x+j]=c;\n\t\t}\n\t\tcout<<(solve(field,xs,ys,xg,yg,field[ys][xs])?\"OK\":\"NG\")<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==1 &&y[i]==1){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[101][101];\nint w,h; \nint color;\nint xg,yg;\n\nbool dfs(int y,int x) {\n  if ( map[y][x] != color ) return 0;\n  map[y][x] = 10;\n  if ( y-1 >= 1 ) dfs( y-1 , x );\n  if ( y+1 <= h ) dfs( y+1 , x );\n  if ( x-1 >= 1 ) dfs( y , x-1 );\n  if ( x+1 <= w ) dfs( y , x+1 );\n  \n  if ( map[yg][xg]==10 ) return 1; \n  return 0;\n\n}\n\nint main() {\n  while ( cin >> w >> h ,w+h ) {\n    for(int i=1; i<=h; i++) {\n      for(int j=1; j<=w; j++) map[i][j]=0;\n    }\n    int xs,ys; cin >> xs >> ys;\n    cin >> xg >> yg;\n    int n; cin >> n;\n    while ( n > 0 ) {\n      n--;\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if ( d == 1 ) {\n\n\tfor ( int i = y; i < y+4; i++ ) {\n\t  for ( int j = x; j < x+2; j++ ) map[i][j] = c;\n\t}\n      \n      } else if ( d == 0 ) {\n\tfor ( int i = y; i < y+2; i++ ) {\n\t  for ( int j = x; j < x+4; j++ ) map[i][j] = c;\n\t}\n      }\n      \n    }\n    color = map[ys][xs];\n    if ( dfs(ys,xs) ) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n    if (d == 0)//yokonaga\n    {\n        loop(i, 2)\n        {\n            loop(j, 4)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n    else//tatenaga\n    {\n        loop(i, 4)\n        {\n            loop(j, 2)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n}\nbool dfs(int nx, int ny)\n{\n    if (nx == gx&&ny == gy)return true;\n    if (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n    grid_visited[nx][ny] = true;\n    bool a=false;\n    if(nx+1 >= 0 && ny >= 0 && nx+1 < h && ny < w)if(grid[nx + 1][ny]== grid[nx][ny])a|=dfs(nx + 1, ny);\n    if(nx >= 0 && ny+1 >= 0 && nx < h && ny+1 < w)if(grid[nx][ny+1]== grid[nx][ny])a|=dfs(nx, ny+1);\n    if(nx-1 >= 0 && ny >= 0 && nx-1 < h && ny < w)if(grid[nx - 1][ny]== grid[nx][ny])a|=dfs(nx - 1, ny);\n    if(nx >= 0 && ny-1 >= 0 && nx < h && ny-1 < w)if(grid[nx][ny-1]== grid[nx][ny])a|=dfs(nx, ny-1);\n    //return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n    return a;\n    return false;\n}\nint main()\n{\n    while (1)\n    {\n        cin >> w >> h;\n        if (!w && !h) break;\n        else\n        {\n            cin >> sx >> sy >> gx >> gy >> n;\n            sx--; sy--; gx--; gy--;\n            loop(i, n)\n            {\n                int c, d, x, y;\n                cin >> c >> d >> x >> y;\n                x--; y--;\n                input(c, d, x, y);\n            }\n            /*loop(i, h)\n            {\n                loop(j, w)\n                {\n                    cout << grid[i][j] << \" \";\n                }\n                cout << endl;\n            }*/\n            cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[101][101] = {{0},{0},};\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    while(true){\n        int w, h, sx, sy, gx, gy, n, c, d, x, y;\n        \n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy >> n;\n            Solve s(w, h, sx, sy, gx, gy);\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\\n\";\n            }else{\n                cout << \"NG\\n\";\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif ((W != 0) && (H != 0)) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][yg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid draw(int c,int d,int x,int y){\n    if(d){\n        for(int i=x;i<x+2;i++){\n            for(int j=y;j<y+4;y++){\n                f[i][j]=c;\n            }\n        }\n    }else{\n        for(int i=x;i<x+4;i++){\n               for(int j=y;j<y+2;y++){\n                    f[i][j]=c;\n                }\n        }\n    }\n}\n\nbool judge(int c,int x,int y){\n    if(c==f[x][y]){\n        return true;\n    }\n    return false;\n}\n\nbool DFS(int xs,int ys,int xg,int yg){\n    if(xs!=xg||ys!=yg){\n        if(judge(f[xs][ys],xs+1,ys)){\n            if(DFS(xs+1,ys,xg,yg)){\n                return true;\n            }\n        }\n          \n        if(judge(f[xs][ys],xs-1,ys)){\n            if(DFS(xs-1,ys,xg,yg)){\n                return true;\n            }\n        }\n        if(judge(f[xs][ys],xs,ys+1)){\n            if(DFS(xs,ys+1,xg,yg)){\n                return true;\n            }\n        }\n        if(judge(f[xs][ys],xs,ys-1)){\n            if(DFS(xs,ys,xg,yg-1)){\n                return true;\n            }\n        }\n        if(judge(f[xs][ys],xs+1,ys)&&judge(f[xs][ys],xs-1,ys)&&judge(f[xs][ys],xs,ys+1)&&judge(f[xs][ys],xs,ys-1)){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    int c;\n    int d,x,y;\n    while(1){\n        cin>>w>>h;\n        if(w==0&&h==0)  break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            draw(c,d,x,y);\n        }\n        if(DFS(xs,ys,xg,yg)){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<h;i++){\n\t\t\tfor(j=1;j<w;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tif(brock[ys][xs]!=brock[yg][xg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=ys;\n\t\t\tma.b=xs;\n\t\t\tma.c=brock[ys][xs];\n\t\t\tds[ys][xs]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==yg&&ba.b==xg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[yg][xg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=h&&ba.b+q[i]>0&&ba.b+q[i]<=w&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 105\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color){\n\t\t\tmap[x][y] = 9;\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> ys >> xs;\n\t\tcin >> yg >> xg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvoid dfs(int a[][110] ,int x , int y , int w , int h , int xg , int yg , int c){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif( a[tx][ty]!=c || a[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( a,tx,ty,w,h,xg,yg,c);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tint board[110][110]={0};\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs(board , xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == 7)\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint n,sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tint xx = x+1;\n\tint yy = y;\n\n\tif(xx == gx && yy == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\txx = x;\n\tyy = y+1;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\txx = x-1;\n\tyy = y;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\t\t\t\n\txx = x;\n\tyy = y-1;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n}\n\nint main(){\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tcin >> c >> d;\n\t\tif(!c && !d)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0){\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+4; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+2; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[101][101]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(ban[x][y+1]==CHECKED&&ban[x+1][y]==CHECKED)return false;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==c){\n\t\t\tban[x+1][y]=CHECKED;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c){\n\t\t\tban[x][y+1]=CHECKED;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y, int before_x, int before_y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( !color[x][y] ){\n\t\tdp[x][y] = false;\n\t\treturn false;\n\t}\n\tif ( color[x][y] == color[x + 1][y] && x + 1 != before_x && dp[x + 1][y] )\n\t\tif ( solve(x + 1, y, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] && y + 1 != before_y && dp[x][y + 1] )\n\t\tif ( solve(x, y + 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] && y - 1 != before_y && dp[x][y - 1] )\n\t\tif ( solve(x, y - 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] && x - 1 != before_x && dp[x - 1][y] )\n\t\tif ( solve(x - 1, y, x, y) )\n\t\t\treturn true;\n\tdp[x][y] = false;\n\treturn false;\n}\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i < 1000; i++ ){\n\t\t\tfor ( int j = 0; j < 1000; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t\tdp[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\t//ブロック情報\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( !block_quarter ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( solve(start_x, start_y, start_x, start_y) )\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nclass node{\npublic:\n\tint x,y;\n\tvoid set(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tbool check(int w,int h){\n\t\tif(x>=0&&y>=0){\n\t\t\tif(x<=w&&y<=h) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nint main(){\n\t\n\tint w,h,xs,ys,xg,yg,n,c,dir,x,y;\n\tint i,j;\n\tint color[101][101];\n\tint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\tbool visited[101][101];\n\tqueue<node> q;\n\tnode a;\n\n\tscanf(\"%d%d\",&w,&h);\n\tscanf(\"%d%d\",&xs,&ys);\n\tscanf(\"%d%d\",&xg,&yg);\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tscanf(\"%d%d\",&c,&dir,&x,&y);\n\t\tif(dir==0){\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<4;j++) color[x+j][y+i] = c;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<4;j++) color[x+i][y+j] = c;\n\t\t\t}\n\t\t}\n\t}\n\ta.set(xs,ys);\n\t\n\tq.push(a);\n\tvisited[a.x][a.y]=true;\n\twhile(!q.empty()){\n\t\ta = q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\ta.x += dx[i];\n\t\t\ta.y += dy[i];\n\t\t\tif(!a.check(w,h)&&(color[xs][ys]==color[a.x][a.y])&&!visited[a.x][a.y]){\n\t\t\t\tq.push(a);\n\t\t\t\tif(a.x==xg&&a.y==yg) break;\n\t\t\t\tvisited[a.x][a.y] = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(visited[xg][yg]) printf(\"OK\\n\");\n\telse printf(\"NG\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    int cbase;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(x==xs && y==ys){\n        cbase = c;\n      }\n\n      if(d==0 && c==cbase){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=cbase;\n          }\n        }\n      }\n      if(d==1 && c==cbase){\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=cbase;\n          }\n        }\n      }\n    }\n    meiro(xs,ys,cbase);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }\n    if(C[xg][yg] != -1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint map[110][110];\nint ans;\nint w,h,n;\n\nvoid serch(int xx,int yy,int gx,int gy,int color)\n{\n\tmap[yy][xx]=0;\n\t\n\tint nex[4]={1,0,-1,0};\n\tint ney[4]={0,1,0,-1};\n\tif(xx==gx && yy==gy)\n\t{\n\t\tans=1;\n\t\treturn ;\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tif(map[yy+ney[i]][xx+nex[i]]==color)\n\t\t{\n\t\t\tserch(xx+nex[i],yy+ney[i],gx,gy,color);\n\t\t\tif(ans==1)\n\t\t\t\treturn ;\n\t\t}\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tint sx,sy,ex,ey;\n\tint i,j,k;\n\tint c,d,x,y;\n\tfor(;;)\n\t{\n\t\tcin >> w >> h ;\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<110;i++)\n\t\t\tfor(j=0;j<110;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t\n\t\tcin >> sx >> sy >> ex >> ey >> n ;\n\t\t\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<2;j++)\n\t\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\t\tmap[y+j][x+k]=c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[y+j][x+k]=c;\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=0)\n\t\t\tserch(sx,sy,ex,ey,map[sy][sx]);\n\t\t\n\t\tif(ans==1)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(H, vector<int>(W));\n        vector<vector<int> > used(H, vector<int>(W));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            if (dir) {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx < H && 0 <= ny && ny < W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nclass Solve{\nprivate:\n    int board[101][101];\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n \nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X;\n    start_y      = Start_Y;\n    goal_x       = Goal_X;\n    goal_y       = Goal_Y;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n     \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n             \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n \nint main(){\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n     \n    while(cin >> w >> h){\n        if(w == 0 && h == 0) break;\n        cin >> sx >> sy >> gx >> gy;\n        Solve s(w, h, sx, sy, gx, gy);\n         \n        cin >> n;\n         \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n            s.set_Block(c, d, x, y);\n        }\n         \n        if(s.check()){\n            cout << \"OK\\n\";\n        }else{\n            cout << \"NG\\n\";\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\nusing namespace std;\nstruct q{\n    int x,y,color,cnt;\n};\nqueue <q> pipe;\nq Main,sub;\nint sy,sx;\nint gy,gx;\nint w,h,n;\nint board[101][101];\nint visited[101][101];\nint state[4];\n\nvoid put(int mode,int color,int x,int y);\n\nint main(void){\n    cin>>w>>h;\n    while(w!=0&&h!=0){\n        cin>>sx>>sy;\n        cin>>gx>>gy;\n        cin>>n;\n        memset(board,0,sizeof(board));\n        memset(visited,0,sizeof(visited));\n        for(int i=0;i<n;i++){\n            cin>>state[0]>>state[1]>>state[2]>>state[3];\n            put(state[1],state[0],state[2],state[3]);\n        }\n        \n        Main.x=sx;\n        Main.y=sy;\n        Main.cnt=0;\n        Main.color=board[sx][sy];\n        visited[sx][sy]=1;\n        pipe.push(Main);\n        \n        int mx,fx[]={0,1,0,-1};\n        int my,fy[]={1,0,-1,0};\n        \n        while(!pipe.empty()){\n            Main=pipe.front();\n            pipe.pop();\n            for(int i=0;i<4;i++){\n                mx=Main.x+fx[i];\n                my=Main.y+fy[i];\n                if(mx>=1&&mx<=100&&my>=1&&my<=100&&Main.color==board[mx][my]&&visited[mx][my]==0){\n                    sub=Main; visited[mx][my]=1;\n                    sub.x=mx; sub.y=my; sub.cnt++;\n                    pipe.push(sub);\n                }\n            }\n        }\n        if(visited[gx][gy]==1){cout<<\"OK\"<<endl;}\n        else{cout<<\"NG\"<<endl;}\n        cin>>w>>h;\n    }\n}\n\nvoid put(int mode,int color,int x,int y){\n    int X[2],Y[2];\n    X[0]=4; Y[0]=2;\n    X[1]=2; Y[1]=4;\n    for(int i=x;i<x+X[mode];i++){\n        for(int j=y;j<y+Y[mode];j++){\n            board[i][j]=color;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg,ok;\n\nvoid Maze(int X,int Y,int C){\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\t\n\n\tif(X==xg&&Y==yg){\n\t\tcout << \"OK\"<<endl;\n\t\tok++;\n\t}\n\n\tF[X][Y]='.';\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tok=0;\n\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\t\tfor(int i=1; i<=w; i++)\n\t\t\tfor(int j=1; j<=h; j++)\n\t\t\t\tF[j][i]=0;\n\n\t\tfor(int i=1; i<=w;i++){\n\t\t\t\tF[w+1][i]=6;\n\t\t\t\tF[0][i]=6;\n\t\t}\n\t\tfor(int i=1; i<=h;i++){\n\t\t\t\tF[i][h+1]=6;\n\t\t\t\tF[i][0]=6;\n\t\t}\n\n\t\tint N=0;\n\t\twhile(N<n){\n\t\t\tcin >>c>>d>>x>>y;\n\n\t\t\tif(d){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tN++;\n\t\t}\n\n/*for(int i=0; i<=h+1; i++){\n\tfor(int j=0; j<=w+1; j++){\n\t\tcout <<F[j][i];\n\t\t}\n\tcout << endl;\n}*/\n\t\t\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t\tif(ok==0)\n\t\t\tcout <<\"NG\"<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "// based on http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2784229#1\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n  if (x == goalx && y == goaly) { return true; }\n  canGo[y][x] = false;\n  for (int i = 0; i < 4; i++) {\n    int next_x = x + needleX[i];\n    int next_y = y + needleY[i];\n \n    if (canGo[next_y][next_x]) {\n      bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n      if (flag)\n\treturn true;\n    }\n  }\n  return false;\n}\nint main(void) {\n  int h, w, n;\n  std::cin >> w >> h;\n  std::vector<std::string> ans;\n  while(h!=0|| w!=0){\n    int color=-1, orient, leftX, leftY;\n    int sx, sy, gx, gy;\n    std::cin >> sx >> sy >> gx >> gy;\n    std::vector<std::vector<int>> board(h + 2, std::vector<int>(w + 2, 0));\n    std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n    std::cin >> n;\n    int start = -1, goal = -1;\n    for (int i = 0; i < n; i++) {\n      std::cin >> color >> orient >> leftX >> leftY;\n \n \n      if (orient == 0) {\n\tfor (int j = 0; j <= 3; j++) {\n\t  for (int k = 0; k <= 1; k++) {\n\t    board[leftY + k][leftX + j] = color;\n\t    if (leftX + j == sx && leftY + k == sy) {\n\t      start = color;\n\t    }\n\t    else if (leftX + j == gx && leftY + k == gy) {\n\t      goal = color;\n\t    }\n\t  }\n\t}\n \n      }\n      else {\n\tfor (int j = 0; j <= 1; j++) {\n\t  for (int k = 0; k <= 3; k++) {\n\t    board[leftY + k][leftX + j] = color;\n\t    if (leftX + j == sx && leftY + k == sy) {\n\t      start = color;\n\t    }\n\t    else if (leftX + j == gx && leftY + k == gy) {\n\t      goal = color;\n\t    }\n\t  }\n\t}\n      }\n    }\n    /*for (int i = 0; i <= w; i++) {\n      for (int j = 0; j <= h; j++) {\n      std::cout << board[i][j] << \" \";\n      }\n      std::cout << std::endl;\n      }*/\n    if (start != -1) {\n      for (int i = 0; i <= h; i++) {\n\tfor (int j = 0; j <= w; j++) {\n\t  if (board[i][j] == start) {\n\t    canGo[i][j] = true;\n\t  }\n\t}\n      }\n    }\n\n    if (start != goal || start == -1) {\n      ans.push_back(\"NG\");\n      continue;\n    }\n\n    bool result = dfs(sx, sy, gx, gy, canGo);\n    if (result) { ans.push_back(\"OK\"); }\n    else { ans.push_back(\"NG\"); }\n    std::cin >> w >> h;\n  }\n  int anssize = ans.size();\n  for (int i = 0; i < anssize; i++) {\n    std::cout << ans[i] << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nstruct Data{\n\tint y, x;\n\tData(){}\n\tData(int _y, int _x){\n\t\ty = _y; x = _x;\n\t}\n};\n\nint fld[100][100];\n\nvoid PaintFld(int c, int y, int x, int h, int w){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfld[y+i][x+j] = c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint W, H;\n\twhile(cin >> W >> H, W || H){\n\t\tfill_n( (int*)fld, 100*100, 0 );\n\t\tint Xs, Ys, Xg, Yg, N, C, D, X, Y;\n\t\tcin >> Xs >> Ys >> Xg >> Yg >> N;\n\t\tXs--; Ys--; Xg--; Yg--;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tX--; Y--;\n\t\t\tif(D == 0) PaintFld(C, Y, X, 2, 4);\n\t\t\telse PaintFld(C, Y, X, 4, 2);\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tbool memo[100][100] = {}, ans = false;\n\t\tq.push( Data(Ys, Xs) );\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\n\t\t\tif( fld[q_front.y][q_front.x] == 0 ||\n\t\t\t\tfld[q_front.y][q_front.x] != fld[Ys][Xs] )\n\t\t\t\tcontinue;\n\n\t\t\tif(q_front.y == Yg && q_front.x == Xg){\n\t\t\t\tans = true; break;\n\t\t\t}\n\n\t\t\tif(memo[q_front.y][q_front.x]) continue;\n\t\t\tmemo[q_front.y][q_front.x] = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\tint nx = q_front.x + dx[i];\n\t\t\t\tif(ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n\t\t\t\tq.push( Data(ny, nx) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ans) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define BLANK 0\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nbool dfs(int color, int x, int y, int gx, int gy, vector<vector<int> >& blocks){\n  if(x == gx && y == gy){ return true; }\n  blocks[x][y] = BLANK;\n  for(int i = 0; i < 4; i++)\n    if(blocks[x + dx[i]][y + dy[i]] == color)\n      if(dfs(color, x + dx[i], y + dy[i], gx, gy, blocks))\n        return true;\n  return false;\n}\n\n\n\nint main(void){\n  while(true){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){ break; }\n\n    int sx ,sy, gx, gy;\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n\n    int n;\n    cin >> n;\n\n    vector<vector<int> > blocks(w + 2, vector<int>(h + 2, BLANK));\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      int now_w = (d == 0) ? 4 : 2;\n      int now_h = (d == 0) ? 2 : 4;\n      for(int j = 0; j < now_w; j++)\n        for(int k = 0; k < now_h; k++)\n          blocks[x + j][y + k] = c;\n    }\n\n    // ????????????\n    if(blocks[sx][sy] == BLANK){\n      cout << \"NG\" << endl;\n      return 0;\n    }\n    \n    if(dfs(blocks[sx][sy], sx, sy, gx, gy, blocks)){ cout << \"OK\" << endl; }\n    else{ cout << \"NG\" << endl; }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int size = 101;\nint B[size][size];\nint V[size][size];\n\ntypedef pair <int, int> PII;\ntypedef queue <PII> QUEUE;\n\nint main() {\n    int w, h;\n    while ( cin >> w >> h && w && h ) {\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                B[i][j] = 0;\n                V[i][j] = 0;\n            }\n        }\n        int xs, ys, xg, yg;\n        cin >> xs >> ys >> xg >> yg;\n        xs --;\n        ys --;\n        xg --;\n        yg --;\n        int n;\n        cin >> n;\n        for ( int i = 0; i < n; ++ i ) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x --;\n            y --;\n            for ( int j = 0; j < ( d ? 4 : 2 ); ++ j ) {\n                for ( int k = 0; k < ( d ? 2 : 4 ); ++ k ) {\n                    int nx = x + k;\n                    int ny = y + j;\n                    B[ny][nx] = c;\n                }\n            }\n        }\n\n        // for ( int i = 0; i < h; ++ i ) {\n        //             for ( int j = 0; j < w; ++ j ) {\n        //                 cout << B[i][j];\n        //             }\n        //             cout << endl;\n        //         }\n        //         cout << endl;\n\n        if ( ! B[ys][xs] || ! B[yg][xg] ) {\n            cout << \"NG\" << endl;\n            continue;\n        }\n        \n        PII start( xs, ys );\n        V[ys][xs] = 1;\n        QUEUE Q;\n        Q.push( start );\n        bool flag = true;\n        while ( ! Q.empty() ) {\n            PII node = Q.front();\n            Q.pop();\n\n            int x = node.first;\n            int y = node.second;\n            const int dx[4] = { 1, -1, 0, 0 };\n            const int dy[4] = { 0, 0, 1, -1 };\n\n            if ( x == xg && y == yg ) {\n                cout << \"OK\" << endl;\n                flag = false;\n                break;\n            }\n            \n            for ( int i = 0; i < 4; ++ i ) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if ( nx < 0 || nx >= w ) continue;\n                if ( ny < 0 || ny >= h ) continue;\n                if ( B[y][x] != B[ny][nx] ) continue;\n                if ( V[ny][nx] ) continue;\n                V[ny][nx] = 1;\n                PII next( ny, nx );\n                Q.push( next );\n            }\n        }\n\n        if ( flag ) cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX_H 100\n#define MAX_W 100\n#define INF 1000;\nint h,w;\nint field[MAX_H][MAX_W+1];\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nvoid dfs(int y,int x,const int sc){\n\tif(y<=0 || x<=0 || y>=h || x>=w)return;\n\tif(field[y][x]==sc){\n\t\tfield[y][x]=0;\n\t\tfor(int i=0;i<4;i++)dfs(y+dy[i],x+dx[i],sc);\n\t}\n\treturn;\n}\nint main(){\n\tint sx,sy,gx,gy,n;\n\twhile(cin>>w>>h,w&&h){\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=0;i<MAX_H;i++){\n\t\t\tfor(int j=0;j<MAX_W;j++){\n\t\t\t\t\tfield[i][j]=INF;\n\t\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tif(d)field[y+j][x+i]=c;\n\t\t\t\t\telse field[y+i][x+j]=c;\t\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\n\t\tdfs(sy,sx,field[sy][sx]);\t\t\n\t\tif(field[gy][gx])cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint block[100][100];\nint visited[100][100];\nbool memo[100][100];\nint w, h, xs, ys, xg, yg, n;\nint d[2][4]={{0,0,-1,1},{-1,1,0,0}};\nbool dfs(int x, int y) {\n    if (visited[y][x]) return memo[y][x];\n    if (x==xg-1&&y==yg-1) return true;\n    visited[y][x]=1;\n    for (int i=0; i<4; i++) {\n        int nx=x+d[0][i], ny=y+d[1][i];\n        if (nx>=0&&nx<w&&ny>=0&&ny<h&&block[y][x]==block[ny][nx]) {\n            if (dfs(nx,ny)) {\n                memo[y][x]=true;\n                return true;\n            }\n        }\n    }\n    memo[y][x]=false;\n    return false;\n}\nint main() {\n    while (scanf(\"%d%d\",&w,&h)) {\n        if (!w&&!h) break;\n        scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n        for (int i=0; i<n; i++) {\n            int c, d, x, y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            if (d) {\n                for (int j=y-1; j<y+3; j++) {\n                    for (int k=x-1; k<x+1; k++) {\n                        block[j][k]=c;\n                    }\n                }\n            } else {\n                for (int j=x-1; j<x+3; j++) {\n                    for (int k=y-1; k<y+1; k++) {\n                        block[k][j]=c;\n                    }\n                }\n            }\n        }\n        /*for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            printf(\"%d%c\",block[i][j],j==w-1?'\\n':' ');\n        }*/\n        if (dfs(xs,ys)) puts(\"OK\");\n        else puts(\"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\ntypedef pair<int,int> pii;\n\nint w,h;\nint xs, ys, xg, yg;\nint ba[100][100];\n\nint dx[] = {-1,0,0,1};\nint dy[] = {0,-1,1,0};\n\nbool solve() {\n  queue<pii> Q;\n  bool visited[w][h];\n  memset(visited, 0, sizeof(visited));\n  Q.push(pii(xs,ys));\n  int col = ba[xs][ys];\n  while(Q.size()){\n    pii a = Q.front();\n    int x = a.first, y = a.second;\n    Q.pop();\n//    printf(\"%d %d   %d\\n\", x,y, visited[x][y]);\n    visited[x][y] = 1;\n    REP(k,4) {\n      int xx = x + dx[k];\n      int yy = y + dy[k];\n      //    cout << \" \" <<x << endl;\n      if (xx<0 || w<=xx || yy<0 || h<=yy) continue;\n      if (visited[xx][yy]) continue;\n      if (col != ba[xx][yy]) continue;\n      \n      if (xx == xg && yy == yg)\n        return true;\n      //cout << xx << \". \" << yy << endl;\n      Q.push(pii(xx,yy));\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin>>w>>h,w+h) {\n    cin >>xs>>ys>>xg>>yg;\n    xs--;ys--;xg--;yg--;\n    int n;\n    cin >> n;\n    REP(i,n) {\n      int c,d,x,y;\n      cin >> c>>d>>x>>y;\n      x--;y--;\n      REP(i,8) {\n        if (d==0)\n          ba[x+i%4][y+i/4] = c;\n        else\n          ba[x+i/4][y+i%4] = c;\n      }\n    }\n    // REP(y,h) {\n    //   REP(x,w)\n    //     cout << ba[x][y] << \" \";\n    //   cout << endl;\n    // }\n    if (solve())\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n if(W==xg && H==yg){\n   ans = 1;\n   return;\n }\n \n if(C[W][H]!=c){\n   return;\n }\n \n C[W][H] = '.';\n \n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n \nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n \n   if(w==0 && h==0){\n     break;\n   }\n \n   int xs,ys;\n   cin >> xs >> ys;\n \n   cin >> xg >> yg;\n \n   int n;\n   cin >> n;\n   int c[n],d[n],x[n],y[n];\n \n   int cbase;\n \n   for(int i=0;i<n;i++){\n     cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n     if(d[i]==0){\n       for(int j=x[i];j<x[i]+4;j++){\n         for(int k=y[i];k<y[i]+2;k++){\n           C[j][k]=c[i];\n         }\n       }\n     }\n     if(d[i]==1){\n       for(int j=x[i];j<x[i]+2;j++){\n         for(int k=y[i];k<y[i]+4;k++){\n           C[j][k]=c[i];\n         }\n       }\n     }\n \n     if(x[i]==1 &&y[i]==1){\n       cbase = c[i];\n     }\n   }\n   ans = 0;\nif(cbase == 0){\n cout << \"NG\"<<endl;\n continue;\n}\n   meiro(xs,ys,cbase);\n \n   if(ans==1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n \n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[101][101];\n\nvoid DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='w')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_Y(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='y')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_G(int Y,int X,int Xg,int Yg,int &c){\n  if((Y==Xg&&X==Yg)||(c!=0)){\n    c=1;\n  }\n  if(F[Y][X]!='g'){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_B(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='b')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_R(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='r')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n}\n\nint main(){\n\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      F[j][i]='0';\n    }\n  }\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  cin>>w>>h;\n  while(1){\n    //int a=0;\n    //int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    int c[n];\n    int d[n];\n    int x[n];\n    int y[n];\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      //int a=0;\n      //int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n    if((w==0)&&(h==0))\n      break;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n        F[i][j]='0';\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint bord[101][101]={},playx[2],playy[2];\nint movex[]={1,0,-1,0},movey[]={0,1,0,-1};\nint serch(int x,int y,int color)\n{\n    if(color==0)return 0;\n    int now=0;\n    bord[y][x]=0;\n    if(x==playx[1]&&y==playy[1])return 1;\n    for(int i=0;i<4&&now==0;i++)\n        if(bord[movey[i]+y][movex[i]+x]==color)now=serch(movex[i]+x,movey[i]+y,color);\n    return now;\n}\nint main()\n{\n    int  h,w;\n    while(cin>>h>>w,h,w){\n        for(int i=0;i<=h+1;i++){\n                for(int j=0;j<=w+1;j++)bord[i][j]=0;\n        }\n        for(int i=0;i<2;i++)cin>>playx[i]>>playy[i];\n        int n;\n        cin>>n;\n        for(int i=0,co,mu,x,y;i<n;i++){\n            cin>>co>>mu>>x>>y;\n            for(int j=0;j<4;j++){\n                if(mu==1){\n                    bord[y+j][x]=co;\n                    bord[y+j][x+1]=co;\n                }\n                else{\n                    bord[y][x+j]=co;\n                    bord[y+1][x+j]=co;\n                }\n            }\n        }\n        if(serch(playx[0],playy[0],bord[playy[0]][playx[0]]))cout<<\"OK\\n\";\n        else cout<<\"NG\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint board[110][110];\nbool used[110][110];\n\nint dx[4] = {0, -1, 1, 0};\nint dy[4] = {-1, 0, 0, 1};\n\nbool valid(int x, int y) {\n    return 0 < x && x <= w && 0 < y && y <= h;\n}\n\nbool dfs(int x, int y) {\n    if (x == xg && y == yg) return true;\n    used[y][x] = true;\n    for (int i=0; i<4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (valid(nx, ny) && ! used[ny][nx] && board[ny][nx] == board[y][x] && dfs(nx, ny)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> w >> h, (w || h)) {\n        cin >> xs >> ys >> xg >> yg >> n;\n        int c, d, x, y;\n        for (int i=0; i<n; ++i) {\n            cin >> c >> d >> x >> y;\n            for (int j=0; j<2; ++j) {\n                for (int k=0; k<4; ++k) {\n                    if (d == 0) {\n                        board[y + j][x + k] = c;\n                    } else {\n                        board[y + k][x + j] = c;\n                    }\n                }\n            }\n        }\n        memset(used, false, sizeof used);\n        cout << (dfs(xs, ys) ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=-1;\n\t\tgoal=-1;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\t\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w-1>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h-1>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w-1>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h-1>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\n\t\tmakelist(n);\n\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2-1&&y1+h1-1>=y2)||(x2==x1+w1&&y1<=y2+h2-1&&y1+h1-1>=y2)||(y1==y2+h2&&x1<=x2+w2-1&&x1+w1-1>=x2)||(y2==y1+h1&&x1<=x2+w2-1&&x1+w1-1>=x2))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\n\tif(start==-1||goal==-1)return false;\n\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\t\tque.push(*it);\n\t\t}\n\t\tadjacive[survey].clear();\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 101\n \nint H, W, sx, sy, gx, gy;\nint color, dir, field[MAX][MAX];\n \nstruct P {\n    int x, y;\n    P(int x, int y) : x(x), y(y) {}\n};\n \nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n \nbool check(int y, int x)\n{\n    if (0 <= y && y < H && 0 <= x && x < W) {\n\treturn true;\n    }\n    return false;\n}\n \nvoid paint(int y, int x)\n{\n    if (!dir) {\n\tfor (int i = 0; i < 2; i++) {\n\t    for (int j = 0; j < 4; j++) {\n\t\tfield[y+i][x+j] = color;\n\t    }\n\t}\n    } else {\n\tfor (int i = 0; i < 4; i++) {\n\t    for (int j = 0; j < 2; j++) {\n\t\tfield[y+i][x+j] = color;\n\t    }\n\t}\n    }\n}\n \nbool bfs()\n{\n    bool used[MAX][MAX];\n    memset(used, false, sizeof(used));\n    used[sy][sx] = true;\n \n    queue<P> Q;\n    Q.push(P(sx, sy));\n \n    while (!Q.empty()) {\n\tP p = Q.front(); Q.pop();\n \n\tif (field[p.y][p.x] == -1) continue;\n \n\tfor (int i = 0; i < 4; i++) {\n\t    int nx = p.x + dx[i];\n\t    int ny = p.y + dy[i];\n \n\t    if (!check(ny, nx) || used[ny][nx] || \n\t       field[p.y][p.x] != field[ny][nx]) continue;\n \n\t    used[ny][nx] = true;\n\t    Q.push(P(nx, ny));     \n\t}\n    }\n    return used[gy][gx];\n}\n \nint main()\n{\n    int n, x, y;\n    while (cin >> W >> H, (W | H)) {\n\tmemset(field, -1, sizeof(field));\n \n\tcin >> sx >> sy >> gx >> gy >> n;\n\tsy--, sx--, gy--, gx--;\n \n\tfor (int i = 0; i < n; i++) {\n\t    cin >> color >> dir >> x >> y;\n\t    y--, x--;\n\t    paint(y, x);\n\t}\n\tcout << (bfs() ? \"OK\" : \"NG\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n\nusing namespace std ;\n\nbool came[ 110 ][ 110 ] ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y )\n{\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tcame[ y ][ x ] = false ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\treturn ok_or_ng( xx ,yy ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\n\t\tmemset( came ,false ,sizeof came ) ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tif( map[ gy ][ gx ] == map[ sy ][ sx ] )\n\t\t\tok_or_ng( sx ,sy ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t\telse\n\t\t\tprintf( \"NG\\n\" ) ;\n\n\t\t/*if( came[ gy ][ gx ] ){\n\t\tfor( int i = 0 ; i <= h + 1 ; i++ )\n\t\t{\n\t\t\tfor( int j = 0 ; j <= w + 1 ; j++ )\n\t\t\t\tcout << map[ i ][ j ] ;\n\t\t\tcout << endl ;\n\t\t}}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n/* Karen {{{\n  ___  ____\n |_  ||_  _|\n   | |_/ /    ,--.   _ .--.  .---.  _ .--.\n   |  __'.   `'_\\ : [ `/'`\\]/ /__\\\\[ `.-. |\n  _| |  \\ \\_ // | |, | |    | \\__., | | | |\n |____||____|\\'-;__/[___]    '.__.'[___||__]\n}}} */\n/* cpp template {{{*/\nusing namespace std;\n\n#define endl '\\n'\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define REPS(i, a, n) for (int i = (a); i < (n); i++)\n#define RREP(i, n) for (int i = 1; i <= (n); i++)\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define ALL(v) v.begin(), v.end()\n\ntypedef double D;\ntypedef long long ll;\ntypedef long double lb;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\ntypedef pair<int, int> pii;\ntypedef pair<int, string> pis;\ntypedef pair<string, int> psi;\n\ninline bool inside(int y,int x,int H,int W){return(y>=0&&x>=0&&y<H&&x<W);}\ninline int in() {int x; std::cin >> x; return x;}\n\ntemplate <typename T>\nvoid print(std::vector<T>& v, char c = ' ') {\n  REP(i, v.size()) {\n    if (i != 0) std::cout << c;\n    std::cout << v[i];\n  }\n  std::cout << endl;\n}\ntemplate <typename T>\nvoid print(T x) {\n  std::cout << x << '\\n';\n}\n/* }}} */\n/* ?????° {{{*/\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e9 + 9;\nconst D EPS  = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n/* }}} */\n\nint d[100][100];\n\nint w, h;\nint co;\n\nvoid dfs(int x, int y, int c)\n{\n  if (!inside(y, x, h, w)) return;\n  if (d[x][y] != c) return;\n\n  d[x][y] = 0;\n  REP(i, 4) {\n    dfs(x + dx[i], y + dy[i], c);\n  }\n}\n\nvoid update(int x, int y, int c)\n{\n  d[x][y] = d[x][y + 1] = d[x + 1][y] = d[x + 1][y + 1] = c;\n}\n\nint color(int x, int y) { return d[x][y];}\n\nsigned main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while (cin >> w >> h, w){\n    memset(d, -1, sizeof(d));\n\n    int sx = in() - 1, sy = in() - 1;\n    int gx = in() - 1, gy = in() - 1;\n    int n = in();\n\n    REP(_, n){\n      int c = in(), D = in(), x = in() - 1, y = in() - 1;\n      update(x, y, c);\n      if (D) {\n        update(x, y + 2, c);\n      } else {\n        update(x + 2, y, c);\n      }\n    }\n\n    dfs(sx, sy, color(sx, sy));\n\n    cout << (d[gx][gy] ? \"NG\" : \"OK\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nconst int size = 110;\nint board[size][size];\nint visited[size][size];\nint xblocks[2][8] = { {0, 1, 2, 3, 0, 1, 2, 3},\n\t\t      {0, 0, 0, 0, 1, 1, 1, 1} };\nint yblocks[2][8] = { {0, 0, 0, 0, 1, 1, 1, 1},\n\t\t      {0, 1, 2, 3, 0, 1, 2, 3} };\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nint main() {\n  int w,h,xs,ys,xg,yg,n,c,d,x,y;\n  while(cin>>w>>h, w|h) {\n    for(int i=0; i<size; ++i)\n      for(int j=0; j<size; ++j) {\n\tboard[i][j] = 0;\n\tvisited[i][j] = 0;\n      }\n\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0; i<n; ++i) {\n      cin>>c>>d>>x>>y;\n      for(int j=0; j<8; ++j)\n\tboard[x+xblocks[d][j]][y+yblocks[d][j]] = c;\n    }\n\n    /*\n    for(int i=1; i<h; ++i) {\n      for(int j=1; j<w; ++j) {\n\tcout<<board[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n\n    queue<pair<int,int> > Q;\n    Q.push(pair<int,int>(ys,xs));\n    while(!Q.empty()) {\n      pair<int,int> pos = Q.front(); Q.pop();\n      int nx = pos.first,ny = pos.second;\n      if(visited[ny][nx]) continue;\n      visited[ny][nx] = 1;\n      if(nx == yg && ny == xg) {\n\tcout<<\"OK\"<<endl;\n\tgoto NEXT;\n      }\n\n      for(int i=0; i<4; ++i) {\n\tif(nx+dx[i] > 0 && nx+dx[i] <= w &&\n\t   ny+dy[i] > 0 && ny+dy[i] <= h &&\n\t   board[ny][nx] == board[ny+dy[i]][nx+dx[i]])\n\t  Q.push(pair<int,int>(nx+dx[i],ny+dy[i]));\n      }\n    }\n    cout<<\"NG\"<<endl;\n  NEXT:\n    ;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing pii = pair<int,int>;\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define pb push_back\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nconst ll MOD = 1000000007;\nvoid cioacc(){//accelerate cin/cout\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\nint main(){\n  int di[] = {1,-1,0,0};\n  int dj[] = {0,0,1,-1};\n  int w,h;\n  while(cin >> w >> h,w){\n    vector<vector<int>> field(w+2,vector<int> (h+2,0));\n    int sx,sy,gx,gy;\n    cin >> sx >> sy >> gx >> gy;\n    int n; cin >> n;\n    REP(i,n){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d==1){\n        REP(j,2) REP(k,4) field[x+j][y+k] = c;\n      }else{\n        REP(j,4) REP(k,2) field[x+j][y+k] = c;\n      }\n    }\n    bool flag = false;\n    int color = field[sx][sy];\n    queue<pair<int,int>> task;\n    task.push(make_pair(sx,sy));\n    while(color>0&&!task.empty()){\n      pii u = task.front(); task.pop();\n      if(u.first==gx && u.second==gy){\n        flag = true;\n        break;\n      }\n      REP(i,4){\n        int ni = u.first + di[i];\n        int nj = u.second + dj[i];\n        if(field[ni][nj] == color){\n          task.push(make_pair(ni,nj));\n          field[ni][nj] = -1;\n        }\n      }\n    }\n    cout << (flag? \"OK\":\"NG\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color){\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint fld[100][100];//[横][縦]\nint Dx[4]={0,-1,0,1};\nint Dy[4]={1,0,-1,0};\n\nbool ans[1000];\nint counter=0;\n\nbool flag=true;\n\nvoid dfs(int x,int y,int w,int h,int c){//スタート地点と色を与える\n\tfld[x][y]=-1;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+Dx[i],ny=y+Dy[i];//範囲内にある必要あり\n\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\tif(fld[nx][ny]==c)//同色についてのみ継続\n\t\t\tdfs(nx,ny,w,h,c);\n\t\t}\n\t}\n}//色の塗り替え\n\t\n\nvoid solve(){\n\tint w,h,xs,ys,xg,yg,n;\n\tcin >> w>>h;\n\t\n\tif(w==0) {flag=false;counter--; return;}\n\t\n\tcin >>xs>>ys>>xg>>yg>>n;//start,goal座標は-1する\n\txs--;ys--;xg--;yg--;\n\t\n\tfor(int i=0;i<w;i++){//fieldの初期化0~w-1\n\t\tfor(int j=0;j<h;j++){//0~h-1\n\t\t\tfld[i][j]=0;//0は何も無い\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint color,drc,x,y;\n\t\tcin >>color>>drc>>x>>y;\n\t\tx--;y--;\n\t\tif(drc==0){\n\t\t\tfor(int dx=0;dx<4;dx++){\n\t\t\t\tfor(int dy=0;dy<2;dy++){\n\t\t\t\t\tfld[x+dx][y+dy]=color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(drc==1){\n\t\t\tfor(int dy=0;dy<4;dy++){\n\t\t\t\tfor(int dx=0;dx<2;dx++){\n\t\t\t\t\tfld[x+dx][y+dy]=color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}//fieldの色塗り\n\t\n\tif(fld[xs][ys]!=fld[xg][yg]) {\n\t\tans[counter]=false;\n\t\treturn;\n\t}\n\tif(fld[xs][ys]==0){\n\t\tans[counter]=false;\n\t\treturn;\n\t}\n\t\n\tdfs(xs,ys,w,h,fld[xs][ys]);//塗り替え\n\t\n\tif(fld[xg][yg]==-1) ans[counter]=true;\n\telse ans[counter]=false;\n\t\n\treturn;\n}\n\nint main(){\n\twhile(flag){\n\t\tsolve();\n\t\tcounter++;\n\t}\n\tfor(int i=0;i<counter;i++){\n\t\tif(ans[i]) cout << \"OK\"<<endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y, color;\n\tvector< vector< int > > field;\n\tqueue< complex< int > > que;\n\tbool exist;\n\t\n\twhile(cin >> w >> h, w){\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\tfield.clear();\n\t\tfield.resize(w);\n\t\tfor(int i = 0; i < w; ++i) field[i].resize(h);\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 2; ++j){\n\t\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\texist = false;\n\t\tif(field[xs - 1][ys - 1] != 0 && field[xg - 1][yg - 1] != 0 && field[xs - 1][ys - 1] == field[xg - 1][yg - 1]){\n\t\t\tque.push(complex< int >(xs - 1, ys - 1));\n\t\t\tcolor = field[xs - 1][ys - 1];\n\t\t\t\n\t\t\twhile(!que.empty()){\n\t\t\t\tcomplex< int > pos = que.front();\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tif(pos.real() == xg - 1 && pos.imag() == yg - 1){\n\t\t\t\t\texist = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.real() > 0 && field[pos.real() - 1][pos.imag()] == color) que.push(pos + complex< int >(-1, 0));\n\t\t\t\tif(pos.real() < w - 1 && field[pos.real() + 1][pos.imag()] == color) que.push(pos + complex< int >(1, 0));\n\t\t\t\tif(pos.imag() > 0 && field[pos.real()][pos.imag() - 1] == color) que.push(pos + complex< int >(0, -1));\n\t\t\t\tif(pos.imag() < h - 1 && field[pos.real()][pos.imag() + 1] == color) que.push(pos + complex< int >(0, 1));\n\t\t\t\t\n\t\t\t\tfield[pos.real()][pos.imag()] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (exist ? \"OK\" : \"NG\") << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nvoid print(int w,int h){\n    for(int i=1;i<=w;i++){\n        for(int j=1;j<=h;j++){\n            cout<<C[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    //print(w,h);\n    //cout << endl;\n    meiro(xs,ys,C[xs][ys]);\n    //print(w,h);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std ;\n\nint w ,h ;\nint gx ,gy ;\nint sx ,sy ;\nint way ;\nint map[ 101 ][ 101 ] ;\n\nint ans( int x ,int y )\n{\n\tint mx[ 4 ] = { 1 ,0 ,0 ,-1 } ;\n\tint my[ 4 ] = { 0 ,1 ,-1 ,0 } ;\n\tmap[ y ][ x ] = -1 ;\n\tif( x == gx && y == gy )\n\t{\n\t\treturn 1 ;\n\t}\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tif( map[ y + my[ i ] ][ x + mx[ i ] ] == way && x + mx[ i ] > 0 && y + my[ i ] > 0 )\n\t\t{\n\t\t\tif( ans( x + mx[ i ] ,y + my[ i ] ) == 1 )\n\t\t\t{\n\t\t\t\treturn 1 ;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0 ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h ,h )\n\t{\n\t\tint n ;\n\t\tint color ,muki ,x ,y ;\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\twhile( n )\n\t\t{\n\t\t\tn-- ;\n\t\t\tcin >> color >> muki >> x >> y ;\n\t\t\tif( muki )\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 2 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tway = map[ sy ][ sx ] ;\n\t\tif( map[ gy ][ gx ] == way )\n\t\t{\n\t\t\tif( ans( sx ,sy ) )\n\t\t\t{\n\t\t\t\tcout << \"OK\" << endl ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"NA\" << endl ;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl ;\n\t\t}\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 0;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y+1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\tif (map[xg][yg]==0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\nstring res = \"NG\";\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i)).at(y+j) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  int temp = board[nx][ny];\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && temp==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && temp==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && temp==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && temp==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      --object[i].x; --object[i].y;\n      object[i].write(board);\t    \n    }\n    func(board,xs,ys);\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\nvoid DFSr(int x, int y){\n\tif(field[y][x] != col)\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tDFSr(x+1, y);\n\tif(flag)\n\t\treturn;\n\tDFSr(x, y+1);\n\tif(flag)\n\t\treturn;\n\tDFSr(x, y-1);\n\tif(flag)\n\t\treturn;\n\tDFSr(x-1, y);\n}\n\nvoid DFSl(int x, int y){\n\tif(field[y][x] != col)\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tDFSl(x-1, y);\n\tif(flag)\n\t\treturn;\n\tDFSl(x, y+1);\n\tif(flag)\n\t\treturn;\n\tDFSl(x, y-1);\n\tif(flag)\n\t\treturn;\n\tDFSl(x+1, y);\n}\n\nvoid DFS(int x, int y){\n\tif(sx < gy)\n\t\tDFSr(x,y);\n\telse\n\t\tDFSl(x,y);\n}\n\nint main(){\n\tint n,c,d,bx,by;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\n\t\tstd::cin >> c >> d;\n\t\tif(!c && !d)\n\t\t\treturn 0;\n\n\t\tstd::cin >> sx >> sy;\n\t\tstd::cin >> gx >> gy;\n\n\t\tstd::cin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tstd::cin >> c >> d >> bx >> by;\n\t\t\tif(d==0)\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+4; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t\telse\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+2; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t}\n\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\td[ny][nx]=0;\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint B[101][101];\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg);\n\nint main(int argc, char** argv)\n{\n\tint w, h;\n\tint xs, ys;\n\tint xg, yg;\n\tint n;\n\tint c, d, x, y;\n\n\twhile( 1 )\n\t{\n\t\tcin >> w;\n\t\tcin >> h;\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tcin >> xs;\n\t\tcin >> ys;\n\t\tcin >> xg;\n\t\tcin >> yg;\n\t\tcin >> n;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c; cin >> d; cin >> x; cin >> y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<4; dx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dy=0; dy<2; dy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tB[x+dx][y+dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<2; dx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dy=0; dy<4; dy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tB[x+dx][y+dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (bfs(w, h, xs, ys, xg, yg) ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg)\n{\n\tint x, y, c, xx, yy;\n\tint offset[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\tqueue<P> q;\n\tP p;\n\n\tc = B[xs][ys];\n\tB[xs][ys] = 0;\n\tp.first = xs, p.second = ys;\n\t\n\tq.push(p);\n\twhile(!q.empty())\n\t{\n\t\tp = q.front();\n\t\tq.pop();\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tif(x==xg && y==yg) return true;\n\t\tB[x][y] = 0;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\txx = x + offset[i][0];\n\t\t\tyy = y + offset[i][1];\n\t\t\tif(x>=0 && y>=0 && x<w && y<h)\n\t\t\t{\n\t\t\t\tif(B[xx][yy] == c)\n\t\t\t\t{\n\t\t\t\t\tp.first = xx;\n\t\t\t\t\tp.second = yy;\n\t\t\t\t\tq.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h; i++) {\n                for (int j = 0; j <= w; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(W+1, vector<int>(H+1));\n        vector<vector<int> > used(W+1, vector<int>(H+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            if (!dir) {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 < nx && nx <= W && 0 < ny && ny <= H && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (d[gx][gy] > 0 && used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[w][h] = 0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,C[xs][ys]);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "void Eratosthenes(){\n\tfor(int i = 0; i < N; i++){\n\t\tarr[i] = 1;\n\t}\n\tfor(int i = 2; i < sqrt(N); i++){\n\t\tif(arr[i]){\n\t\t\tfor(int j = 0; i * (j + 2) < N; j++){\n\t\t\t\tarr[i *(j + 2)] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 2; i < N; i++){\n\t\tif(arr[i]){\n\t\t\t//cout << i << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    for(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=-1;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  if(F[xs][ys] == 0){\n    cout << \"NG\" << endl;\n  } else {\n    DFS(xs,ys,F[xs][ys]);\n  \n    if(F[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" <<endl;\n    }\n  }\n\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h; i++) {\n                for (int j = 0; j <= w; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[1][1];\n    \n    bfs();\n    \n    if(goal==1){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NO\" << endl;\n    }\n    \n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\td[ny][nx]=0;\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid draw(int c,int d,int x,int y){\n    if(d){\n        for(int i=x;i<x+2;i++){\n            for(int j=y;j<y+4;y++){\n                f[i][j]=c;\n            }\n        }\n    }\n}\n\n\n\nbool DFS(int xs,int ys,int xg,int yg){\n    if(xs!=xg||ys!=yg){\n        if(DFS(xs+1,ys,xg,yg))\n          xs++;\n        else if(DFS(xs-1,ys,xg,yg))\n          xs--;\n        else if(DFS(xs,ys+1,xg,yg))\n          ys++;\n        else if(DFS(xs,ys-1,xg,yg))\n          ys--;\n        else{\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    int c;\n    int d,x,y;\n    while(1){\n        cin>>w>>h;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            draw(c,d,x,y);\n        }\n        if(DFS(xs,ys,xg,yg)){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 105\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x <= w && 0 <= y && y <= h && map[x][y] == color){\n\t\t\tmap[x][y] = 9;\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> ys >> xs;\n\t\tcin >> yg >> xg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0; i < w; i++){\n\t\t\tfor(int j=0; j < h; j++){\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n  cin >> w >> h;\n  if(w == 0 && h == 0)\n    break;\n\n  cin >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,color;\nstring res = \"NG\";\nvoid write(Matrix &board,int c, int d, int x, int y){\n  int width,length;\n  if(d == 0){ width = 4; length =2; }\n  if(d == 1){ width = 2; length =4; }\n  for(int i=0; i<width; ++i){\n    for(int j=0; j<length; ++j)\n      board[x+i][y+j]=c;\n  }\n}\nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && color==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && color==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && color==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && color==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  int c,d,x,y;\n  while(cin >> w >> h,w||h){\n\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> c >> d >> x >> y;\n      --x; --y;\n      write(board,c,d,x,y);\n    }\n    color = board[xs][ys];\n    func(board,xs,ys);\n    cout << res << endl;\n    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define loop(i,a,b) for(int i = a ; i < b ; i++)\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n\nint maze[104][104];\nint h,w;\nint sx,sy ,  gx,gy , n;\nint co;\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\n\nbool inmaze(int x,int y){\n  return (0<=x && x<w) && (0<=y && y<h);\n}\n\nbool dfs(int x,int y){\n  //cout<<\"che\"<<x<<\" \"<<y<<endl;\n  if(x == gy && y == gx){\n    return true;\n    cout<<\"ok\"<<endl;\n  }\n  if(!inmaze(x,y))return false;\n  maze[x][y] = 10;\n  bool res = false;\n  rep(i,4)\n    if(maze[x + dx[i]][y + dy[i]] == co){\n      res = dfs(x+dx[i],y+dy[i]);\n      if(res)return true;\n    }\n  return res;\n}\n\nint main(void){\n  while(cin>>w>>h,w+h){\n    cin>>sx>>sy>>gx>>gy>>n;\n    sx--,sy--,gx--,gy--;\n    //cout<<sx<<\" \"<<sy<<\" \"<<gx<<\" \"<<gy<<endl;\n    rep(i,h)rep(j,w)maze[i][j] = -1;\n    rep(i,n){\n      int c,b,x,y;\n      cin>>c>>b>>x>>y;\n      x--,y--;\n      //cout<<x<<\" \"<<y<<endl;\n      rep(i,(b?2:4))\n\trep(j,(b?4:2))\n\tmaze[i+x][j+y] = c;\n    }\n    co = maze[sx][sy];\n    bool res = dfs(sx,sy); \n    cout<<(res?\"OK\":\"NO\")<<endl;\n   \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<stack>\nstruct p{\n\tint x;\n\tint y;\n};\nusing namespace std;\nint main(){\n\tint w,h,sx,sy,gx,gy,n,c,d,x,y,i,j,k,o;\n\tint map[100][100];\n\tint used[100][100];\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tp v,u;\n\tstack<p> s;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(used,0,sizeof(used));\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx--;\n\t\tsy--;\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tgx--;\n\t\tgy--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(!d){\n\t\t\t\tfor(j=y;j<y+2;j++){\n\t\t\t\t\tfor(k=x;k<x+4;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=y;j<y+4;j++){\n\t\t\t\t\tfor(k=x;k<x+2;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx]){\n\t\t\tprintf(\"NG\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tv.x=sx;\n\t\tv.y=sy;\n\t\ts.push(v);\n\t\to=0;\n\t\twhile(!s.empty()){\n\t\t\tv=s.top();\n\t\t\ts.pop();\n\t\t\tif(used[v.y][v.x]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tused[v.y][v.x]=1;\n\t\t\t}\n\t\t\tif(v.x==gx&&v.y==gy){\n\t\t\t\to=1;\n\t\t\t\twhile(!s.empty()){\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(u.x>=0&&u.x<w&&u.y>=0&&u.y<h&&map[u.y][u.x]==map[sy][sx]){\n\t\t\t\t\ts.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n\n\n\n//マップの大きさの最大値\n#define MAP_MAX\t\t100\n//最初の歩数\n#define START\t\t1000000\n//マップの配列\nint wh_map[MAP_MAX + 1][MAP_MAX + 1];\n//縦・横に進むための配列\nint h_tate[4] = {1 , -1 , 0 , 0};\nint h_yoko[4] = {0 , 0 , 1 , -1};\n\n\n\n//----- blockの情報を持つ構造体 -----//\ntypedef struct block\n{\n\tint iro;\n\tint muki;\n\tint x;\n\tint y;\n}S_block;\n\n\n\n//----- 答えを返す関数 -----//\nbool f_ans(int , int  , int , int , int , int);\n\n\n//----- ブロックの入力は長くなるので関数で -----//\nint f_block_syokika(S_block[] , int , int , int);\n\n\n\n//----- マップを-1で初期化する変数 -----//\nvoid f_mapsyokika(void);\n\n\n\n//----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(メモリ節約のために構造体は参照で受ける) -----//\nvoid f_okmap(S_block[] , int , int , int , int);\n\n\n\n\n//*****----- main -----*****//\n\nint main(void)\n{\n\t//ボードの大きさ\n\tint tate = 0 , yoko = 0;\n\t//スタートの座標\n\tint startx = 0 , starty = 0;\n\t//ゴール座標\n\tint goalx = 0 , goaly = 0;\n\t//ブロックの個数\n\tint n = 0;\n\t//スタートと同じ色\n\tint startcolor = 0;\n\n\twhile (1)\n\t{\n\t\t//それぞれ入力\n\t\tscanf(\"%d%d\" , &tate , &yoko);\n\t\tif (tate == 0 && yoko == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t//スタート・ゴール座標\n\t\tscanf(\"%d%d\" , &startx , &starty);\n\t\tscanf(\"%d%d\" , &goalx , &goaly);\n\t\t//ブロックの個数\n\t\tscanf(\"%d\" , &n);\n\n\t\t//ブロックの分だけ領域を確保する\n\t\tS_block *s_block = new S_block[n];\n\n\t\t//関数で初期化\n\t\tstartcolor = f_block_syokika(s_block , n , starty , startx);\n\t\t//次にマップを初期化\n\t\tf_mapsyokika();\n\n\t\t//mapにSTARTを振り分ける\n\t\tf_okmap(s_block , starty , startx , startcolor , n);\n\n\t\tif (f_ans(starty , startx , goaly , goalx , tate , yoko) == true)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\n\t\t//一度メモリを解放\n\t\tdelete []s_block;\n\t}\n}\n\n\n\n\n//*****----- ブロックの情報を入力する関数 -----*****//\n\nint f_block_syokika(S_block s_data[] , int n , int starty , int startx)\n{\n\t//スタートの色を取り出す変数\n\tint startcolor = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\" , &s_data[i].iro , &s_data[i].muki , &s_data[i].x , &s_data[i].y);\n\n\t\t//色を取り出す(横向きなら)\n\t\tif (s_data[i].muki == 1)\n\t\t{\n\t\t\t//横向きに設置したと仮定し、その中にスタート座標が含まれているかどうか調べる\n\t\t\tif ((starty <= s_data[i].y && starty >= s_data[i].y - 1) && (startx >= s_data[i].x && startx <= s_data[i].x + 3))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t\t//縦向きだった\n\t\telse\n\t\t{\n\t\t\t//縦向きに設置したと仮定し、その中にスタート座標が含まれているか調べる\n\t\t\tif ((starty <= s_data[i].y && starty >= s_data[i].y - 3) && (startx >= s_data[i].x && s_data[i].x + 1))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t}\n\n\t//初期座標の値を返す\n\treturn startcolor;\n}\n\n\n\n//*****----- 答えを求める関数 -----*****//\n\nbool f_ans(int starty , int startx , int goaly , int goalx , int tateindex , int yokoindex)\n{\n\t//幅優先探索で使うｙとｘ\n\tstd::queue<int> x;\n\tstd::queue<int> y;\n\n\t//最初の座標をキューに追加\n\ty.push(starty);\n\tx.push(startx);\n\t\n\n\t//キューがなくなるまで\n\twhile (!x.empty())\n\t{\n\t\t//ｙ座標とｘ座標を取り出す\n\t\tint yy = y.front();\n\t\tint xx = x.front();\n\t\t//デキュー\n\t\ty.pop();\n\t\tx.pop();\n\n\t\t//ゴールにたどり着いた\n\t\tif (yy == goaly && xx == goalx)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t//今いる座標の値を吹っ飛ばす\n\t\twh_map[yy][xx] = -1;\n\n\t\t//四方に散れるか調べる\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t//次に進む座標を取得\n\t\t\tint nexty = yy + h_tate[i];\n\t\t\tint nextx = xx + h_yoko[i];\n\n\t\t\t//まずは範囲内かどうか調べる\n\t\t\tif (nexty >= 1 && nexty <= tateindex && nextx >= 1 && nextx <= yokoindex)\n\t\t\t{\n\t\t\t\t//そこが通れる場所且つブロックの色が同じとき\n\t\t\t\tif (wh_map[nexty][nextx] == START)\n\t\t\t\t{\n\t\t\t\t\t//ｙとｘをそれぞれ追加\n\t\t\t\t\ty.push(nexty);\n\t\t\t\t\tx.push(nextx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\n//*****----- マップを初期化する関数 -----*****//\n\nvoid f_mapsyokika(void)\n{\n\tfor (int i = 1; i < MAP_MAX + 1; i++)\n\t{\n\t\tfor (int j = 1; j < MAP_MAX + 1; j++)\n\t\t{\n\t\t\twh_map[i][j] = -1;\n\t\t}\n\t}\n}\n\n\n\n//*****----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(構造体は配列) -----*****//\n\nvoid f_okmap(S_block s_data[] , int starty , int startx , int startcolor , int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s_data[i].iro == startcolor)\n\t\t{\n\t\t\t//縦か横かによって挙動が変わる\n\t\t\tif (s_data[i].muki == 0)\n\t\t\t{\n\t\t\t\t//2 * 4マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0;k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + j][s_data[i].x + k] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//横だった\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 4 * 2マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + k][s_data[i].x + j] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint board[101][101],w,h;\nbool visited[101][101];\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nbool search(int x,int y,int tarx,int tary,int c)\n{\n\tvisited[y][x]=true;\n\tif(board[y][x]!=c)\t\treturn false;\n\tif(x==tarx && y==tary)\treturn true;\n\t\n\tfor(int k=0;k<4;k++){\n\t\tint xx=x+dx[k],yy=y+dy[k];\n\t\tif(xx<=0 || w<xx || yy<=0 || h<yy)\tcontinue;\n\t\tif(!visited[yy][xx] && search(xx,yy,tarx,tary,c))\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(;cin>>w>>h,w;){\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)board[i][j]=-1,visited[i][j]=false;\n\t\tint xs,ys,xg,yg,n;\tcin>>xs>>ys>>xg>>yg>>n;\n\t\twhile(n--){\n\t\t\tint c,d,x,y;\tcin>>c>>d>>x>>y;\n\t\t\tfor(int i=0;i<(d?4:2);i++)for(int j=0;j<(d?2:4);j++)board[y+i][x+j]=c;\n\t\t}\n\n\t\tif(board[ys][xs]!=board[yg][xg])\tcout<<\"NG\"<<endl;\n\t\telse\tcout<<(search(xs,ys,xg,yg,board[ys][xs])?\"OK\":\"NG\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg,w,h;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c || Y >w || X>h){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=10;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\nbool check(short **maze)\n{\n\t\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\t\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tshort **maze = new short*[h];\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tmaze[i] = new short [w];\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[1024][1024];\nint xg,yg;\nint w,h;\nbool dfs(int x,int y,int col){\n\tif(x == xg && y == yg && stage[x][y] == col){\n\t\treturn true;\n\t}\n\trep(i,4){\n\t\tif(stage[x+dx[i]][y+dy[i]] == 0)continue;\n\t\tif(x+dx[i] <= 0 || y+dy[i] <= 0 || x+dx[i] > w || y+dy[i] > h)continue; \n\t\tif(col == stage[x+dx[i]][y+dy[i]]){\n\t\t\treturn dfs(x + dx[i], y + dy[i], col);\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w|h){\n\t\tmemset(stage,0,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\n\t\trep(q,n){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\treps(i,x,x+4){\n\t\t\t\t\treps(j,y,y+2){\n\t\t\t\t\t\tstage[j][i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\treps(i,x,x+2){\n\t\t\t\t\treps(j,y,y+4){\n\t\t\t\t\t\tstage[j][i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(dfs(xs,ys,stage[xs][ys])) ? puts(\"OK\") : puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h;\nint field[101][101];\nint gx,gy;\nint sc;\nvoid init()\n{\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfield[i][j] = 0;\n\t\t}\n\t}\n}\nbool search(int x,int y)\n{\n\tbool flag = false;\n\tif(x == gx && y == gy)\n\t\tflag = true;\n\telse{\n\t\tint vectorx[4] = {-1,0,1,0},vectory[4] = {0,-1,0,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x+vectorx[i] >= 0 && y+vectory[i] >= 0 && x+vectorx[i] < w && y+vectory[i] < h){\n\t\t\t\tif(field[x+vectorx[i]][y+vectory[i]] == sc){\n\t\t\t\t\tfield[x][y] = 0;\n\t\t\t\t\tflag |= search(x+vectorx[i],y+vectory[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tint n,c,x,y;\n\t\tbool d;\n\t\tinit();\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint vectorx,vectory;\n\t\t\tif(d == 0){\n\t\t\t\tvectorx = 4;vectory = 2;\n\t\t\t}else{\n\t\t\t\tvectorx = 2;vectory = 4;\n\t\t\t}\n\t\t\tfor(int j=0;j<vectorx;j++){\n\t\t\t\tfor(int k=0;k<vectory;k++){\n\t\t\t\t\tfield[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc = field[sx][sy];\n\t\tif(search(sx,sy))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint c[110][110];\nbool vis[110][110];\nint h,w,n,x1,y1,x2,y2;\nvoid DFS(int y,int x){\n\tvis[y][x]=true;\n\tint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\tlol(i,4){\n\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\tif(xx<0||yy<0||xx==w||yy==h)continue;\n\t\tif(c[y][x]==c[yy][xx]&&!vis[yy][xx])DFS(yy,xx);\n\t}\n}\nint main(){\n\twhile(cin>>w>>h&&w+h){\n\t\tcin>>x1>>y1>>x2>>y2>>n;\n\t\tx1--,x2--,y1--,y2--;\n\t\tlol(i,h)lol(j,w)c[i][j]=0,vis[i][j]=false;\n\t\tlol(i,n){\n\t\t\tint x,y,a,b;\n\t\t\tcin>>a>>b>>x>>y;x--,y--;\n\t\t\tint xx=2,yy=4;if(b==0)xx=4,yy=2;\n\t\t\tlol(j,yy)lol(k,xx){\n\t\t\t\tc[j+y][k+x]=a;\n\t\t\t}\n\t\t}\n\t\tDFS(y1,x1);\n\t\tif(vis[y2][x2]==true)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint w,h;\nint sx,sy,gx,gy;\nint n;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nbool used[120][120];\nint f[120][120];\nvoid set(int c,int d,int x,int y)\n{\n\tif(d==0)\n\t{\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nbool judge()\n{\n\tif(f[sx][sy]!=f[gx][gy])return false;\n\tmemset(used,false,sizeof(used));\n\tqueue<P> q;\n\tq.push(mp(sx,sy));\n\tused[sx][sy]=true;\n\twhile(!q.empty())\n\t{\n\t\tP a=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nx=a.fi+dx[i],ny=a.sec+dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\tif(used[nx][ny]||f[nx][ny]!=f[a.fi][a.sec])continue;\n\t\t\tif(nx==gx&&ny==gy)return true;\n\t\t\tused[nx][ny]=true;\n\t\t\tq.push(mp(nx,ny));\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(w==0&&h==0)break;\n\t\tscanf(\"%d %d\",&sy,&sx);\n\t\tscanf(\"%d %d\",&gy,&gx);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&y,&x);\n\t\t\tset(c,d,x,y);\n\t\t}\n\t\tif(judge())puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\nif(F[xs][ys]==0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "int  map[100][100];\nbool visited[100][100];\nint  w,h;\nint  xs,ys;\nint  xg,yg;\nint  n;\n\nint dfs(int x,int y) {\n\tstatic int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\tif(x==xg&&y==yg) return 1;\n\tvisited[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&map[x][y]==map[nx][ny]&&!visited[nx][ny]) {\n\t\t\tif(dfs(nx,ny)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint c,d,x,y;\n\n\twhile(1) {\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d %d\",&xs,&ys);xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg);xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);x--;y--;\n\t\t\tint X,Y;\n\t\t\tif(d==1) {\n\t\t\t\tX=2;Y=4;\n\t\t\t}else {\n\t\t\t\tX=4;Y=2;\n\t\t\t}\n\t\t\tfor(int j=0;j<X;j++) {\n\t\t\t\tfor(int k=0;k<Y;k++) {\n\t\t\t\t\tmap[x+j][y+k]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint w,h;\n\tint xs,ys;\n\tint xg,yg;\n\tint n;\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tint field[101][101];\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfill(field[i],field[i]+101,0);\n\n\t\tcin>>xs>>ys;\n\t\tcin>>xg>>yg;\n\t\txs--;ys--;xg--;yg--;\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;y--;\n\t\t\tif(d==0){\n\t\t\t\tfor(int j = y; j < 2+y; j++){\n\t\t\t\t\tfor(int k = x; k < x + 4; k++){\n\t\t\t\t\t\tfield[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < 4+y; j++){\n\t\t\t\t\tfor(int k = x; k < x + 2; k++){\n\t\t\t\t\t\tfield[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// bfs\n\t\tint c=field[ys][xs];\n\t\tif(c==0){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\t\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\n\t\tconst int dy[]={-1,0,0,1};\n\t\tconst int dx[]={0,-1,1,0};\n\n\t\tbool passed[101][101];\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfill(passed[i],passed[i]+101,false);\n\n\t\tprv->push(make_pair(xs,ys));\n\n\t\tbool fin=false;\n\t\twhile(prv->size()){\n\t\t\twhile(prv->size()){\n\t\t\t\tpair<int,int> p = prv->front();\n\t\t\t\tprv->pop();\n\t\t\t\tif(p.first==yg&&p.second==xg){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(passed[p.first][p.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tpassed[p.first][p.second]=true;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]==c&&!passed[ny][nx]){\n\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tswap(prv,nxt);\n\t\t}\n\t\tif(fin){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"NG\"<<endl;\n\t\tdelete prv,nxt;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\t\nbool check(short maze[MAX][MAX])\n{\n\tque.push(S);\n\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t\trep(i,MAX)\n\t\t\trep(j,MAX)\n\t\t\tmaze[i][j] = -10;\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] != -10 && maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef unsigned long long ull; typedef long long ll;\n\nconst int INF=100000000; int dx[4]={1,0,-1,0}; int dy[4]={0,1,0-1};\n\ntypedef pair<int ,int > P;\n\nchar maze[105][105];\n\nint sx,sy; int gx,gy; int w,h;\n\nchar sc; //スタート地点のカラー\n\n//stdin //stdout\n\nvoid dfs(int x,int y) { maze[x][y]='9';\n\nfor(int i=0;i<4;i++) { int nx=x+dx[i]; int ny=y+dy[i];\n\nif(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[nx][ny]==sc) { dfs(nx,ny); }\n\n} return ; }\n\nvoid solve() {\n\nrep(i,101) rep(j,101) maze[i][j]='0';\n\nint n; char c; int d; int x,y;\n\ncin>>sy>>sx; cin>>gy>>gx;\n\ncin>>n;\n\nrep(i,n) { cin>>c>>d>>y>>x;\n\nif(d==1) { rep(i,4) { rep(j,2) { maze[x+i][y+j]=c;\n\n} } } else if (d==0) { rep(i,2) { rep(j,4) { maze[x+i][y+j]=c;\n\n} } }\n\n} //6 6 //1 1 //3 6 //2 //1 0 1 1 //1 1 3 3 // rep(i,w+1) // { // rep(j,h+1) // { // cout<<maze[i][j]; //// } // cout<<endl; // } //// cout<<maze[gx][gy]<<endl;\n\nif(maze[sx][sy]=='0') { cout<<\"NG\"<<endl; return; } else { sc=maze[sx][sy]; dfs(sx,sy); }\n\n//rep(i,w+1) //{ // rep(j,h+1) // { // cout<<maze[i][j];\n\n// } // cout<<endl; //}\n\nif(maze[gx][gy]=='9') { cout<<\"OK\"<<endl; return; } else { cout<<\"NG\"<<endl; return; }\n\n}\n\nint main() {\n\nwhile(cin>>w>>h) { if(w==0 && h==0) { return 0; } else { solve(); } }\n\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg;\n\nvoid dfs(int target, int x, int y){\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 0;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n}\n\nint main(){\n    int w, h, xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,105) rep(j,105) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w, h, n;\nint sx, sy, gx, gy;\nint t[102][102];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool check(int x, int y, int c){\n  if(x == gx && y == gy) return true;\n\n  t[y][x] = -1;\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] != c) continue;\n    if(check(nx, ny, c)) return true;\n  }\n}\n\nvoid putBlock(int c, int d, int x, int y){\n  int addX = (d == 0 ? 4 : 2);\n  int addY = (d == 0 ? 2 : 4);\n\n  for(int i = y; i < y + addY; i++){\n    for(int j = x; j < x + addX; j++){\n      t[i][j] = c;\n    }\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    cin >> sx >> sy; sx--; sy--;\n    cin >> gx >> gy; gx--; gy--;\n    cin >> n;\n\n    memset(t, -1, sizeof(t));\n\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n\n      x--;\n      y--;\n      putBlock(c, d, x, y);\n    }\n\n    if(t[sy][sx] != -1 && check(sx, sy, t[sy][sx])){\n      cout << \"OK\\n\";\n    }\n    else{\n      cout << \"NG\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<w;i++){\n\t\t\tfor(j=1;j<h;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tif(brock[xs][ys]!=brock[xg][yg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[xs][ys];\n\t\t\tds[xs][ys]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==xg&&ba.b==yg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[xg][yg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=w&&ba.b+q[i]>0&&ba.b+q[i]<=h&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n \nusing namespace std;\n \n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\n \nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0-1};\n \ntypedef pair<int ,int > P;\n \nchar maze[105][105];\n \nint sx,sy;\nint gx,gy;\nint w,h;\n \nchar sc;        //スタート地点のカラー\n \n//stdin\n//stdout\n \nvoid dfs(int x,int y)\n{\n    maze[y][x]='9';\n \n    rep(i,4)\n    {\n/*        for(int j=-1;j<=1;j++)\n        {*/\n            int nx=x+dx[i];\n            int ny=y+dy[i];\n \n            if(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[ny][nx]==sc)\n            {\n                dfs(nx,ny);\n            }\n \n/*        }*/\n    }\n    return ;\n}\n \nvoid solve()\n{\n \n    rep(i,101)\n        rep(j,101)\n        maze[i][j]='0';\n \n    int n;\n    char c;\n    int d;\n    int x,y;\n \n    cin>>sx>>sy;\n    cin>>gx>>gy;\n \n    cin>>n;\n \n    rep(i,n)\n    {\n        cin>>c>>d>>x>>y;\n \n        if(d==1)\n        {\n            rep(j,2)\n            {\n                rep(k,4)\n                {\n                    maze[y+k][x+j]=c;\n \n                }\n            }\n        }\n        else if (d==0)\n        {\n            rep(j,4)\n            {\n                rep(k,2)\n                {\n                    maze[y+k][x+j]=c;\n \n                }\n            }\n        }\n \n    }\n//6 6\n//1 1\n//3 6\n//2\n//1 0 1 1\n//1 1 3 3\n//  rep(i,w+1)\n//  {\n//      rep(j,h+1)\n//      {\n//          cout<<maze[i][j];\n//\n//      }\n//      cout<<endl;\n//  }\n//\n//  cout<<maze[gx][gy]<<endl;\n \n    if(maze[sy][sx]=='0')\n    {\n        cout<<\"NG\"<<endl;\n        return;\n    }\n    else\n    {\n        sc=maze[sy][sx];\n        dfs(sx,sy);\n    }\n     \n    //rep(i,w+1)\n    //{\n    //  rep(j,h+1)\n    //  {\n    //      cout<<maze[i][j];\n \n    //  }\n    //  cout<<endl;\n    //}\n \n    if(maze[gy][gx]=='9')\n    {\n        cout<<\"OK\"<<endl;\n        return;\n    }\n    else\n    {\n        cout<<\"NG\"<<endl;\n        return;\n    }\n \n \n \n}\n \nint main()\n{\n \n    while(cin>>w>>h)\n    {\n        if(w==0 && h==0)\n        {\n            return 0;\n        }\n        else\n        {\n            solve();\n        }\n    }\n \n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, b[101][101];\nint dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n\nbool dfs(int x, int y){\n  int nx, ny;\n  b[x][y] = 0;\n  if(x == xg && y == yg) return true;\n  bool r = 0;\n  rep(i, 4){\n    nx = x + dx[i]; ny = y + dy[i];\n    if(nx > 0 && nx <= h && ny > 0 && ny <= w && b[nx][ny]==c)r=r||dfs(nx, ny);\n  }\n  return r;\n}\n\nint main(){\n  while(scanf(\"%d %d\", &w, &h) && w && h){\n    memset(b, 0, sizeof(b));\n    scanf(\"%d%d%d%d\", &ys, &xs, &yg, &xg);\n    scanf(\"%d\", &n);\n    rep(i, n){\n      scanf(\"%d%d%d%d\", &c, &d, &y, &x);\n      rep(j, (d?4:2)) rep(k, (d?2:4)) b[x + j][y + k] = c;\n    }\n\n    c = b[xs][ys];\n    if(dfs(xs, ys)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nclass node{\npublic:\n\tint x,y;\n\tvoid set(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tbool check(int w,int h){\n\t\tif(x>=0&&y>=0){\n\t\t\tif(x<=w&&y<=h) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nint main(){\n\tint w,h;\n\tw=h=1;\n\twhile(w!=0||h!=0){\n\t\tint xs,ys,xg,yg,n,c,dir,x,y;\n\t\tint i,j;\n\t\tint color[101][101];\n\t\tint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\t\tbool visited[101][101];\n\t\tqueue<node> q;\n\t\tnode a;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\n\t\twhile(n--){\n\t\t\tscanf(\"%d%d%d%d\",&c,&dir,&x,&y);\n\t\t\tif(dir==0){\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+j][y+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+i][y+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta.set(xs,ys);\n\t\tq.push(a);\n\t\tvisited[a.x][a.y]=true;\n\t\twhile(!q.empty()){\n\t\t\ta = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\ta.x += dx[i];\n\t\t\t\ta.y += dy[i];\n\t\t\t\tif(!a.check(w,h)&&(color[xs][ys]==color[a.x][a.y])&&!visited[a.x][a.y]){\n\t\t\t\t\tq.push(a);\n\t\t\t\t\tif(a.x==xg&&a.y==yg) break;\n\t\t\t\t\tvisited[a.x][a.y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(visited[xg][yg]) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint  map[100][100];\nbool visited[100][100];\nint  w,h;\nint  xs,ys;\nint  xg,yg;\nint  n;\n\nint dfs(int x,int y) {\n\tstatic int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\tif(x==xg&&y==yg) return 1;\n\tvisited[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&map[x][y]==map[nx][ny]&&!visited[nx][ny]) {\n\t\t\tif(dfs(nx,ny)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint c,d,x,y;\n\n\twhile(1) {\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d %d\",&xs,&ys);xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg);xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);x--;y--;\n\t\t\tint X,Y;\n\t\t\tif(d==1) {\n\t\t\t\tX=2;Y=4;\n\t\t\t}else {\n\t\t\t\tX=4;Y=2;\n\t\t\t}\n\t\t\tfor(int j=0;j<X;j++) {\n\t\t\t\tfor(int k=0;k<Y;k++) {\n\t\t\t\t\tmap[x+j][y+k]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"YES\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n if(C[W][H]!=c){\n   return;\n }\n\n C[W][H] = -1;\n\n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n\nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n   if(w==0 && h==0){\n     break;\n   }\n\n   for(int i=0;i<20;i++){\n     for(int j=0;j<20;j++){\n       C[i][j] = 0;\n     }\n   }\n\n   int xs,ys,xg,yg;\n   cin >> xs >> ys >> xg >> yg;\n\n   int n;\n   cin >> n;\n\n   int c,d,x,y;\n   for(int i=0;i<n;i++){\n     cin >> c >> d >> x >> y;\n\n     if(d==0){\n       for(int j=x;j<x+4;j++){\n         for(int k=y;k<y+2;k++){\n           C[j][k]=c;\n         }\n       }\n     }else{\n       for(int j=x;j<x+2;j++){\n         for(int k=y;k<y+4;k++){\n           C[j][k]=c;\n         }\n       }\n     }\n   }\nif(C[xs][ys] == 0){\ncout << \"NG\"<<endl;\ncontinue;\n}\n   meiro(xs,ys,C[xs][ys]);\n   //print(w,h);\n\n   if(C[xg][yg] == -1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint map[size_max][size_max];\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue< PR > QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tint SC = map[ys][xs];\n\n\t\tQU.push(make_pair(ys, xs));\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] == SC)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == SC)\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.push(make_pair(now.Y + my[i], now.X + mx[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double ldouble;\n#define REP(i, x, n) for(int i = x ; i < n ; i++)\n#define rep(i, n) REP(i, 0, n)\n#define repr(i, n) for(int i = n - 1 ; i >= 0 ; i--)\n#define SORT(c) sort((c).begin(), (c).end())\n\nconst int IINF = 1e9 + 10;\nconst lint LLINF = 1e18;\nconst lint MOD = 1e9 + 7;\nconst lint inv = MOD - 2;\n\nvector< vector<int> > b;\nint xs, ys, xg, yg;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nbool dfs(int y, int x, int color){\n    if(y == yg && x == xg){\n        return true;\n    }\n    b[y][x] = -2;\n    bool res = false;\n    rep(i, 4){\n        int ny = y + dy[i], nx = x + dx[i];\n        if(b[ny][nx] == color){\n            res = res || dfs(ny, nx, color);\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(true){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0 && h == 0){\n            break;\n        }\n        b.resize(h+2);\n        rep(i, h+2){\n            b[i].resize(w+2);\n        }\n        rep(i, h+2){\n            rep(j, w+2){\n                b[i][j] = -2;\n            }\n        }\n        cin >> xs >> ys >> xg >> yg;\n        int n;\n        cin >> n;\n        rep(k, n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                REP(i, y, y+2){\n                    REP(j, x, x+4){\n                        b[i][j] = c;\n                    }\n                }\n            }else{\n                REP(i, y, y+4){\n                    REP(j, x, x+2){\n                        b[i][j] = c;\n                    }\n                }\n            }\n        }\n        b[ys][xs] = max(b[ys][xs], -1);\n        if(dfs(ys, xs, b[ys][xs])){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct cordinate{\n        int y;\n        int x;\n};\ncordinate SIZE,Start,Goal;\nstruct Blocks{\n        int color;\n        int direction;\n        int y;\n        int x;\n};\nBlocks block[200];\nint N,board[200][200];\nint Color,dp[200][200];\nint recursion(int y,int x){\n        int res=0;\n        if(board[y][x]==0)\n                return false;\n        if(y==Goal.y && x==Goal.x){\n                return true;\n        }\n        else{\n                board[y][x]=0;\n                if(recursion(y+1,x))return true;\n                if(recursion(y-1,x))return true;\n                if(recursion(y,x+1))return true;\n                if(recursion(y,x-1))return true;\n        }\n        return false;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<100 ; i++ )\n                        for(int j=0 ; j<100 ; j++ ){\n                                dp[i][j]=-1;\n                                board[i][j]=0;\n                        }\n                cin >> SIZE.x >> SIZE.y;\n                if(SIZE.x+SIZE.y==0)\n                        break;\n                cin >> Start.x >> Start.y;\n                cin >> Goal.x >> Goal.y;\n                cin >> N;\n                for(int i=0 ; i<N ; i++ ){\n                        cin >> block[i].color >> block[i].direction;\n                        cin >> block[i].x >> block[i].y;\n                        if(block[i].direction){\n                                for(int l=block[i].y ; l<block[i].y+4 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+2 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                        else{\n                                for(int l=block[i].y ; l<block[i].y+2 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+4 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                }\n                Color=board[Start.y][Start.x];\n                if(recursion(Start.y,Start.x)>0)\n                        cout <<\"OK\"<<endl;\n                else\n                        cout <<\"NG\"<<endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing V = vector<int>;\nusing VV = vector<V>;\nstruct P {int x, y;};\n\nint main() {\n\tint dx[] = {4, 2}, dy[] = {2, 4};\n\tfor (int w, h; w = in(), h = in();) {\n\t\tP s = {in(), in()}, g = {in(), in()};\n\t\tint n = in();\n\t\tVV m(h + 1, V(w + 1));\n\t\twhile (n--) {\n\t\t\tint c = in(), d = in(), x = in(), y = in();\n\t\t\tfor (int i = 0; i < dy[d]; i++)\n\t\t\t\tfor (int j = 0; j < dx[d]; j++)\n\t\t\t\t\tm[i + y][j + x] = c;\n\t\t}\n\t\tint c = m[s.y][s.x];\n\t\tm[s.y][s.x] = 0;\n\t\tfunction<bool(int, int)> f = [&](int x, int y) {\n\t\t\tif (x == g.x && y == g.y)\n\t\t\t\treturn true;\n\t\t\tP d = {1, 0};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = x + d.x, ty = y + d.y;\n\t\t\t\tif (m[ty][tx] == c) {\n\t\t\t\t\tm[ty][tx] = 0;\n\t\t\t\t\tif (f(tx, ty))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswap(d.x, d.y *= -1);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\toutl(c ? f(s.x, s.y) ? \"OK\" : \"NG\" : \"NG\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102]={0};\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=-1;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n  int goal_x,goal_y;\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {1, 0, -1, 0};\n\nvoid dfs(int y, int x, vector<vector<int>>& v) {\n    int c = v[y][x];\n    v[y][x] = -1;\n    for(int i=0; i<4; ++i) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if(ny < 0 || v.size() <= ny || nx < 0 || v[0].size() <= nx || v[ny][nx] != c) {\n            continue;\n        }\n        dfs(ny, nx, v);\n    }\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        int xs, ys, xg, yg;\n        cin >> xs >> ys >> xg >> yg;\n        xs--; ys--; xg--; yg--;\n\n        vector<vector<int>> v(h, vector<int>(w));\n        int n;\n        cin >> n;\n        for(int i=0; i<n; ++i) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            int size[2] = {2, 4};\n            for(int j=y; j<y+size[d]; ++j) {\n                for(int k=x; k<x+size[(d+1)%2]; ++k) {\n                    v[j][k] = c;\n                }\n            }\n        }\n        dfs(ys, xs, v);\n        if(v[yg][xg] == -1) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint data[102][102];\nvoid DFS(int x,int y,int gx,int gy,bool &Flag,int color){\n  if((data[y][x]!=color)||(Flag==true))\n    return;\n  if((x==gx)&&(y==gy)){\n    Flag=true;\n    return;\n  }\n  data[y][x]=0;\n  DFS(x,y+1,gx,gy,Flag,color);\n  DFS(x,y-1,gx,gy,Flag,color);\n  DFS(x+1,y,gx,gy,Flag,color);\n  DFS(x-1,y,gx,gy,Flag,color);\n}\nint main(){\n  int w,h;\n  int sx,sy;\n  int gx,gy;\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)\n      break;\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        data[i][j]=0;\n      }\n    }\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n    int n;\n    cin>>n;\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      if(d){\n        for(int j=0;j<4;j++){\n          for(int z=0;z<2;z++){\n            data[j+y][z+x]=c;\n          }\n        }\n      }else if(!d){\n        for(int j=0;j<2;j++){\n          for(int z=0;z<4;z++){\n            data[j+y][z+x]=c;\n          }\n        }\n      }\n    }\n    bool Flag=false;\n    int color=data[sy][sx];\n    if(color!=0)\n      DFS(sx,sy,gx,gy,Flag,color);\n    if (Flag){\n      cout<<\"OK\"<<endl;\n    }else if(!Flag){\n      cout<<\"NG\"<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;\nint xs, ys, xg, yg;\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\n// void Showboard(int w, int h){\n//     for(int i=0;i<=h;i++){\n//         for(int j=0;j<=w;j++)\n//             cout << Board[j][i] << \" \";\n//         cout << endl;\n//     }\n//     cout << endl;\n// }\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;\n        for(int i=0;i<102;i++){\n            for(int j=0;j<102;j++)\n                Board[j][i] = 9;\n        }\n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);  \n            int hb = 2+(d*2);\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        // Showboard(w, h);\n\n        DFS(Board[xs][ys], xs, ys);\n\n        // Showboard(w, h);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint moveTo[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\nint stage[100][100];\n\nvoid paint(int c,int d,int x,int y){\n\t//c:1~5 d: 0:horizonal 1:vertical\n\tif(d==0){\n\t\tfor(int i=x;i<x+4;i++){\n\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg){\n\tint cs = stage[ys][xs];\n\tint cg = stage[yg][xg];\n\tif(cs != cg) return false;\n\n\tqueue<P> que;\n\tque.push(P(ys,xs));\n\n\twhile(!que.empty()){\n\t\tint sx = que.front().first;\n\t\tint sy = que.front().second;\n\t\t\n\t\tif(sx == xg && sy == yg) return true;\n\t\tque.pop();\n\n\t\tstage[sy][sx] = -1;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = sx + moveTo[i][0];\n\t\t\tint dy = sy + moveTo[i][1];\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(stage[dy][dx] != cs || stage[dy][dx] == -1) continue;\n\t\t\tque.push(P(dx,dy));\n\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\n\t\tint xg,yg;\n\t\tscanf(\"%d %d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\t//c:1~5 d: 0:horizonal 1:vertical\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tpaint(c,d,x,y);\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(w,h,xs,ys,xg,yg) ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\tusing namespace std;\n\tint xs,ys,w,h,n,ban[111][111],xg,yg;bool visited[101][101];\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(x==xs&&ys==y&&ban[x][y]==-1||ban[x][y]!=c)return false;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y,c))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\nbool MazeJudge;\nint xg,yg;\n\nchar ItoC(int i){\n\tif(i==1){\n\t\treturn '1';\n\t}else if(i==2){\n\t\treturn '2';\n\t}else if(i==3){\n\t\treturn '3';\n\t}else if(i==4){\n\t\treturn '4';\n\t}else if(i==5){\n\t\treturn '5';\n\t}\n}\n\nvoid DFS(int X,int Y,char C)\n{\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\tF[X][Y] = '.';\n\n\tif(X==xg&&Y==yg){\n\t\tMazeJudge = true;\n\t\treturn;\n\t}\n\t\n\tDFS(X-1,Y  ,C);\n\tDFS(X  ,Y+1,C);\n\tDFS(X+1,Y  ,C);\n\tDFS(X  ,Y-1,C);\n}\n\t\n\nint main()\n{\n\twhile(true){\n\t\tfor(int j=0;j<102;j++){\n\t\t\tfor(int i=0;i<102;i++){\n\t\t\t\tF[i][j] = '0';\n\t\t\t}\n\t\t}\n\n\t\tMazeJudge = false;\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tint xs,ys;\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n    \t\t\tchar color = ItoC(c);\n\t\t\tif(d==0){\n\t\t\t\tF[x  ][y  ] = color;\n\t\t\t\tF[x+1][y  ] = color;\n\t\t\t\tF[x+2][y  ] = color;\n\t\t\t\tF[x+3][y  ] = color;\n\t\t\t\tF[x  ][y+1] = color;\n\t\t\t\tF[x+1][y+1] = color;\n\t\t\t\tF[x+2][y+1] = color;\n\t\t\t\tF[x+3][y+1] = color;\n\t\t\t}else if(d==1){\n\t\t\t\tF[x  ][y  ] = color;\n\t\t\t\tF[x+1][y  ] = color;\n\t\t\t\tF[x  ][y+1] = color;\n\t\t\t\tF[x+1][y+1] = color;\n\t\t\t\tF[x  ][y+2] = color;\n\t\t\t\tF[x+1][y+2] = color;\n\t\t\t\tF[x  ][y+3] = color;\n\t\t\t\tF[x+1][y+3] = color;\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//デバッグ用迷路表示\n\t\t/*for(int j=0;j<102;j++){\n\t\t\tfor(int i=0;i<102;i++){\n\t\t\t\tcout << F[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tchar rc = F[xs][ys];\n\t\tDFS(xs,ys,rc);\n\t\tif(MazeJudge==true){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else if(MazeJudge==false){\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[y+1][x+1]=c;\n             F[y+1][x+2]=c;\n             F[y+1][x+3]=c;\n             F[y+1][x+4]=c;  \n             F[y+2][x+1]=c;\n             F[y+2][x+2]=c;\n             F[y+2][x+3]=c;\n             F[y+2][x+4]=c;   \n         }\n         else{\n             F[y+1][x+1]=c;\n             F[y+2][x+1]=c;\n             F[y+3][x+1]=c;\n             F[y+4][x+1]=c;  \n             F[y+1][x+2]=c;\n             F[y+2][x+2]=c;\n             F[y+3][x+2]=c;\n             F[y+4][x+2]=c;   \n         }\n      }\n      if(F[ys+1][xs+1]==1&&F[ys+1][xs+1]==2&&F[ys+1][xs+1]==3&&F[ys+1][xs+1]==4&&F[ys+1][xs+1]==5)\n         DFS(ys+1,xs+1,F[ys+1][xs+1]);\n      if(F[yg+1][xg+1]==F[ys+1][xs+1])\n         cout << \"OK\" << endl;\n      else\n         cout << \"NG\" << endl;\n      for(int i=1;i<=w;i++)\n         for(int j=1;j<=h;j++)\n            F[i][j]=0;\n      \n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\n\nvoid DFS(int x,int y,char c){\n  if(F[x][y]!=c)\n    return;\n  F[x][y]='@';\n  DFS(x-1,y,c);\n  DFS(x,y+1,c);\n  DFS(x+1,y,c);\n  DFS(x,y-1,c);\n}\nvoid Block(int c,int d,int x,int y){\n  char b;\n  if(c=0)\n    b='+';\n  if(c=1)\n    b='-';\n  if(c=2)\n    b='*';\n  if(c=3)\n    b='/';\n  F[x][y]=b;\n  F[x][y+1]=b;\n  F[x+1][y]=b;\n  F[x+1][y+1]=b;\n  if(d==1){\n    F[x][y+2]=b;\n    F[x][y+3]=b;\n    F[x+1][y+2]=b;\n    F[x+1][y+3]=b;\n  }else{\n    F[x+2][y]=b;\n    F[x+2][y+1]=b;\n    F[x+3][y]=b;\n    F[x+3][y+1]=b;\n  }\n}\n\nint main(){\n  int w=1,h;\n  int xs,ys;\n  int xg,yg;\n  int n;\n  int c,d,x,y;\n  while(w>0){\n    cin>>w>>h;\n    if(w==0&&h==0)\n      break;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        F[i][j]='.';\n      }\n    }\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      Block(c,d,x,y);\n    }\n    DFS(xs,yscout<<endl;,F[xs][ys]);\n    if(F[xg][yg]=='@')\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<103; i++){\n      for(int j=0; j<103; j++){\n        F[i][j] = 10;\n      }\n    }\n       F[0][104] = 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[200][200]={},sx,sy,gx,gy;\nint f(int i,int j){\n\tif(i==gy && j==gx)\n\t\treturn 1;\n\tif(a[i+1][j]==a[sy][sx])\n\t\tif(f(i+1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j+1]==a[sy][sx])\n\t\tif(f(i,j+1)==1)\n\t\t\treturn 1;\n\tif(a[i-1][j]==a[sx][sy])\n\t\tif(f(i-1,j)==1)\n\t\t\treturn 1;\n\tif(a[i][j-1]==a[sx][sy])\n\t\tif(f(i,j-1)==1)\n\t\t\treturn 1;\n\treturn 0;\n}\nint main(){\n\twhile(1){\n\t\tint w,h,n,c,d,x,y;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)\n\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\ta[i][j]=0;\n\t\tcin>>sx>>sy;\n\t\tcin>>gx>>gy;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=0;i<2;i++)\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t}\n\t\t}\n\t\tif(a[sx][sy]!=a[gx][gy])\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sy,sx)==0)\n\t\tcout<<\"NG\"<<endl;\n\t\telse if(f(sx,sy)==1)\n\t\tcout<<\"OK\"<<endl;\n\t}\n\treturn 0;\n}\n+-"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nvvi tmp;\nint dx[]={0,0,1,-1};\nint dy[]={-1,1,0,0};\nvoid solve(int x,int y){\n\ttmp[x][y]=-1;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(tmp[nx][ny]==2)solve(nx,ny);\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n+2,vi(m+2));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tcin>>n;\n\t\twhile(n--){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tif(!b)rep(i,4)rep(j,2)in[c+i][d+j]=a;\n\t\t\telse rep(i,2)rep(j,4)in[c+i][d+j]=a;\n\t\t}\n\t\ttmp=in;\n\t\tif(in[sx][sy]==2)solve(sx,sy);\n\t\t//rep(i,22){rep(j,22)cout<<in[i][j]<<\" \";cout<<endl;}\n\t\tcout<<((in[sx][sy]==2&&in[gx][gy]==2&&tmp[gx][gy]==-1)?\"OK\":\"NG\")<<endl;\n\t\t//rep(i,22){rep(j,22)cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\nvector < vector <int> > block_map;\n\nint xs, ys;\nint xg, yg;\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, -1, 0, 1 };\n\nbool dfs( int x, int y )\n{\n\tif ( block_map[y][x] == 0 || block_map[y][x] != block_map[yg][xg] )\n\t\treturn false;\n\tif ( x == xg && y == yg )\n\t\treturn true;\n\n\tblock_map[y][x] = -1;\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif ( nx < 0 || nx >= w || ny < 0 || ny >= h )\n\t\t\tcontinue;\n\n\t\tif ( block_map[ny][nx] != -1 && block_map[ny][nx] == block_map[yg][xg] )\n\t\t{\n\t\t\tif ( dfs( nx, ny ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\tcin >> w >> h;\n\t\tif ( w == 0 && h == 0 )\n\t\t\tbreak;\n\n\t\tblock_map = vector < vector <int> >( h, vector <int>(w,0) );\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\txs--;\n\t\tys--;\n\t\txg--;\n\t\tyg--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( d == 0 )\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 2; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 4; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 4; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 2; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( dfs( xs, ys ) )\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint w,h,n,sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tif(field[y][x] != col)\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tDFS(x+1, y);\n\tif(flag)\n\t\treturn;\n\tDFS(x, y+1);\n\tif(flag)\n\t\treturn;\n\tDFS(x-1, y);\n\tif(flag)\n\t\treturn;\n\tDFS(x, y-1);\n}\n\nint main(){\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tcin >> w >> h;\n\t\tif(!w && !h)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0)\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+4; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t\telse\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+2; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  if(F[xs][ys] == 10){\ncout << \"NG\" << endl;\ncontinue;\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n\nusing namespace std;\ntypedef pair<int, int> P;\nint maze[20][20];\nbool used[20][20];\nint main()\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n//\tcut here before submit \n//\tfreopen (\"testcase.block\", \"r\", stdin );\n\tint w, h;\n\n\twhile (cin >> w >> h && w && h ){\n\t\tmemset (maze, 0, sizeof(maze ) );\n\t\tmemset (used, false, sizeof (used ) );\n\n\t\tP start, goal;\n\t\tcin >> start.first >> start.second;\n\t\tstart.first--; start.second--;\n\t\tcin >> goal.first >> goal.second;\n\t\tgoal.first--; goal.second--;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i ){\n\t\t\tint color, dir;\n\t\t\tP block;\n\t\t\tcin >> color >> dir >> block.first >> block.second;\n\t\t\tblock.first--; block.second--;\n\t\t\tif (dir == 0 ){\n\t\t\t\tfor (int col = 0; col < 4; ++col ){\n\t\t\t\t\tmaze[block.second][block.first+col] = color;\n\t\t\t\t\tmaze[block.second+1][block.first+col] = color;\n\t\t\t\t} // end for\n\t\t\t}else{\n\t\t\t\tfor (int row = 0; row < 4; ++row ){\n\t\t\t\t\tmaze[block.second+row][block.first] = color;\n\t\t\t\t\tmaze[block.second+row][block.first+1] = color;\n\t\t\t\t} // end for\n\t\t\t} // end if\n\t\t} // end for\n\t\tqueue<P> que;\n\t\tque.push (P(start.first, start.second ) );\n\t\tint search_color = maze[start.second][start.first];\n\t\tbool found = false;\n\n\t\twhile (!que.empty() ){\n\t\t\tP curr = que.front(); que.pop();\n\t\t\tint x = curr.first;\n\t\t\tint y = curr.second;\n\t\t\tif (x == goal.first && y == goal.second ){\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t\tused[y][x] = true;\n\t\t\tfor (int k = 0; k < 4; ++k ){\n\t\t\t\tint nx = x + dir[k][0];\n\t\t\t\tint ny = y + dir[k][1];\n\t\t\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h )\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((maze[ny][nx] == search_color) && !used[ny][nx] ){\n\t\t\t\t\tP next; next.first = nx; next.second = ny;\n\t\t\t\t\tque.push (next );\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end while\n\n\t\tif (found )\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 0 || F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\nvoid DFS(int y, int x, int c){\n  if(F[y][x]!=c){\n    return;\n  }\n\n  F[y][x]=6;\n\n  DFS(y, x+1, c);\n  DFS(y, x-1, c);\n  DFS(y+1, x, c);\n  DFS(y-1, x, c);\n}\n\nint main(){\n  while(1){\n    for(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=0;\n      }\n    }\n    int w,h,xs,ys,xg,yg,n;\n    cin >> w >> h;\n    if(w==0&&h==0){\n      return 0;\n    }\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0; i<n; i++){\n      int a,b,x,y;\n      cin >> a >> b >> x >> y;\n      if(b==0){\n        F[y][x]=a;\n        F[y][x+1]=a;\n        F[y][x+2]=a;\n        F[y][x+3]=a;\n        F[y+1][x]=a;\n        F[y+1][x+1]=a;\n        F[y+1][x+2]=a;\n        F[y+1][x+3]=a;//横長\n      }else{\n        F[y][x]=a;\n        F[y+1][x]=a;\n        F[y+2][x]=a;\n        F[y+3][x]=a;\n        F[y][x+1]=a;\n        F[y+1][x+1]=a;\n        F[y+2][x+1]=a;\n        F[y+3][x+1]=a;//縦長\n      }\n    }\n    int z = F[ys][xs];\n    if(z==0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    DFS(ys, xs , z);\n    if(F[yg][xg]==6){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nconst int MAX_W = 100, MAX_H = 100;\n\ntypedef std::pair<int,int> P;\nint map[MAX_H + 1][MAX_W + 1];\n\nint bfs(P sp, P gp, int w, int h){\n\t//½±Æª é©ði[\n\tint f[MAX_H + 1][MAX_W + 1] = {{0}};\n\tstd::queue<P> q;\n\tq.push(P(sp.first, sp.second));\n\t\n\twhile(q.size()){\n\t\tP p = q.front(); q.pop();\n\t\t//S[Å«½ç¬÷\n\t\tif(p.first == gp.first && p.second == gp.second)return 1;\n\t\t\n\t\tint vy[4] = {-1,1,0,0}, vx[4] = {0,0,-1,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = p.first + vx[i],\n\t\t\t\tny = p.second + vy[i];\n\t\t\tif(nx >= 0 && nx <= w && ny >= 0 && ny <= h && \n\t\t\t\t map[ny][nx] > 0 && !f[ny][nx]){\n\t\t\t\tq.push(P(nx,ny));\n\t\t\t\tf[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t//ÅãÜÅS[Å«È¢Èç¸s\n\treturn 0;\n}\n\nint main(){\n\tint w, h, xs, ys, xg, yg;\n\twhile(std::cin >> w >> h, w){\n\t\tmemset(map,0,sizeof(map));\n\t\tstd::cin >> xs >> ys;\n\t\tstd::cin >> xg >> yg;\n\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\t//ubNÌÝu\n\t\twhile(n--){\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint mx, my;\n\t\t\tif(d)//w < h\n\t\t\t\t{my = 4, mx = 2;}\n\t\t\telse//w > h\n\t\t\t\t{mx = 4, my = 2;}\n\t\t\tfor(int i=y;i<y+my;i++){\n\t\t\t\tfor(int j=x;j<x+mx;j++){\n\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//bfsÅS[Å«é©mF\n\t\tP sp = P(xs,ys), gp = P(xg,yg);\n\t\tif(bfs(sp, gp, w, h))std::cout << \"OK\" << std::endl;\n\t\telse{std::cout << \"NG\" << std::endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[120][120] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y; di++){\n                for(int dj = x;dj < dw + x;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[120][120] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xg][yg] != C || C == 0)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        }\n/*\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<field[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl<<endl;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<vis[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        //cout<<C<<\"---\"<<field[xg][yg]<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys])\n  if(1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[101][101];//y,x\nbool flag;\nint n,a,sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<101; i++)\n\t\tfor(int j=0; j<101; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tint xx = x;\n\tint yy = y;\n\n\tif(xx == gx && yy == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\txx++;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\txx--;\n\tyy++;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\t\t\n\txx--;\n\tyy--;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\t\t\t\n\txx++;\n\tyy--;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n}\n\nint main(){\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tcin >> n >> a;\n\t\tif(!n && !a)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0){\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+4; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+2; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint cell[101][101];\nint max_i, max_j;\nint goal_i, goal_j;\nbool ret;\n\nvoid search(int i, int j, int c){\n\tif(i<1 || j<1 || i>max_i || j>max_j) return;\n\tif(cell[i][j]!=c) return;\n\telse cell[i][j] = 0;\n\tif(i==goal_i && j==goal_j){\n\t\tret = true;\n\t\treturn;\n\t}\n\n\tsearch(i+1, j, c);\n\tif(ret) return;\n\tsearch(i-1, j, c);\n\tif(ret) return;\n\tsearch(i, j+1, c);\n\tif(ret) return;\n\tsearch(i, j-1, c);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> max_i >> max_j;\n\n\t\tif(!max_i && !max_j) break;\n\n\t\tint start_i, start_j;\n\t\tcin >> start_i >> start_j;\n\t\tcin >> goal_i >> goal_j;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tfor(int i=0;i<max_i;i++){\n\t\t\tfor(int j=0;j<max_j;j++){\n\t\t\t\tcell[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tint c, vec, i, j;\n\t\t\tcin >> c >> vec >> i >> j;\n\t\t\tcell[i][j] = cell[i+1][j] = cell[i][j+1] = cell[i+1][j+1] = c;\n\t\t\tif(vec){\n\t\t\t\tcell[i][j+2] = cell[i][j+3] = cell[i+1][j+2] = cell[i+1][j+3] = c;\n\t\t\t}else{\n\t\t\t\tcell[i+2][j] = cell[i+3][j] = cell[i+2][j+1] = cell[i+3][j+1] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tret = false;\n\t\tif(cell[start_i][start_j]){\n\t\t\tsearch(start_i, start_j, cell[start_i][start_j]);\n\t\t}\n\n\t\tif(ret) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = j;i<k;i++)\nint w,h,xs,ys,xg,yg,n;\nint m[102][102];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool DFS(int x,int y,int c){\n  if(m[x][y]!=c)return false;\n  if(x==xg && y == yg)return true;\n  m[x][y]=-1;\n  bool ans =false;\n  rep(i,0,4){\n    ans = max(ans,DFS(x+dx[i],y+dy[i],c));\n  }\n  return ans;\n}\nint main(){\n  cin >>w>>h;\n  while(w!=0){\n    cin>>xs>>ys>>xg>>yg>>n;\n    xs++;\n    ys++;\n    xg++;\n    yg++;\n    rep(i,0,102)rep(j,0,102)m[i][j]=-1;\n    rep(i,0,n){\n      int c,d,x,y;\n      cin >>c>>d>>x>>y;\n      x++;\n      y++;\n      if(d==0){\n        rep(j,x,x+4)rep(k,y,y+2)m[j][k]=c;\n      }else{\n        rep(j,x,x+2)rep(k,y,y+4)m[j][k]=c;\n      }\n    }\n    string ans[2]={\"NG\",\"OK\"};\n    cout << ans[DFS(xs,ys,m[xs][ys])]<<endl;\n    cin >> w>>h;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg, yg;\n\nbool DFS(int Y, int X, int C)\n{\n  if(Y == yg && X == xg)\n    return true;\n  if(F[Y][X]!=C)\n    return false;\n\n  F[Y][X] = 0;\n\n  bool tmp = 0;\n  tmp += DFS(Y-1, X, C);\n  tmp += DFS(Y+1, X, C);\n  tmp += DFS(Y, X-1, C);\n  tmp += DFS(Y, X+1, C);\n  return tmp;\n}\n\nint main()\n{\n  while(1){\n    F[102][102] = {};\n\n    int w, h;\n    cin >> w >> h;\n\n    if(w == 0 && h == 0)\n      return 0;\n\n    int xs, ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c, d, x, y;\n    for(int i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d == 0)\n        for(int j=0; j<2; j++)\n          for(int k=0; k<4; k++)\n            F[y+j][x+k] = c;\n      else\n        for(int j=0; j<4; j++)\n          for(int k=0; k<2; k++)\n            F[y+j][x+k] = c;\n    }\n\n    bool res = DFS(ys, xs, F[ys][xs]);\n\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -2;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=2;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -2){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint table[100][100];\nint memo[100][100];\n\nint w, h;\nint xs, ys, xg, yg;\nint n;\n\nvoid solve(int xs, int ys, int c)\n{\n\tif( memo[xs][ys] ) {\n\t\treturn;\n\t}\n\n\tif( !( -1 < xs && xs < w && -1 < ys && ys < h && table[xs][ys] == c ) ) {\n\t\tmemo[xs][ys] = 1;\n\t\treturn;\n\t}\n\t\n\tif( xs == xg && ys == yg ) {\n\t\tmemo[xs][ys] = 1;\n\t\tcout << \"OK\" << endl;\n\t\tthrow \"OK\";\n\t}\n\n\tmemo[xs][ys] = 1;\t\n\n\tsolve(xs+1, ys, c);\n\tsolve(xs, ys+1, c);\t\n\tsolve(xs-1, ys, c);\n\tsolve(xs, ys-1, c);\n\n\treturn;\n}\n\nint main(int argc, char* argv[])\n{\n\twhile(1) {\n\n\t\tcin >> w >> h;\n\n\t\tif( w == 0 && h == 0 )\n\t\t\tbreak;\n\t\t\t\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor( int i = 0; i < n; i++ ) {\n\n\t\t\tint c; cin >> c;\n\t\t\tint d; cin >> d;\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\tif( d == 0 ) {\n\n\t\t\t\ttable[x][y] = c;\n\t\t\t\ttable[x][y+1] = c;\n\n\t\t\t\ttable[x+1][y] = c;\n\t\t\t\ttable[x+1][y+1] = c;\n\n\t\t\t\ttable[x+2][y] = c;\n\t\t\t\ttable[x+2][y+1] = c;\n\n\t\t\t\ttable[x+3][y] = c;\n\t\t\t\ttable[x+3][y+1] = c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\n\n\t\t\t} else {\n\n\t\t\t\ttable[x][y] = c;\n\t\t\t\ttable[x+1][y] = c;\n\n\t\t\t\ttable[x][y+1] = c;\n\t\t\t\ttable[x+1][y+1] = c;\n\n\t\t\t\ttable[x][y+2] = c;\n\t\t\t\ttable[x+1][y+2] = c;\n\t\t\t\t\n\t\t\t\ttable[x][y+3] = c;\n\t\t\t\ttable[x+1][y+3] = c;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tfor( int i = 0; i < 100; i++ ) {\n\t\t\tfor( int j = 0; j < 100; j++ ) {\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t}\t\t\n\n\t\ttry {\n\t\t\tsolve(xs, ys, table[xs][ys]);\n\t\t\tcout << \"NG\" << endl;\t\t\t\t  \n\t\t} catch(...) {\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int YOKO = 0;\nconst int TATE = 1;\nconst int BLOCK_WIDTH = 4;\nconst int BLOCK_HEIGHT = 2;\n\nint map[101][101];\nint pmap[101][101];\nint w, h;\nint xs, ys, xg, yg;\nbool answer = false;\n\nvoid init() {\n  answer = false;\n  for (int i = 0; i < 101; i++) {\n    for (int j = 0; j < 101; j++) {\n      map[i][j] = 0;\n      pmap[i][j] = 0;\n    }\n  }\n}\n\nvoid set_block(int c, int d, int x, int y) {\n  int height, width;\n  if (d == YOKO) {\n    height = BLOCK_HEIGHT;\n    width = BLOCK_WIDTH;\n  } else {\n    height = BLOCK_WIDTH;\n    width = BLOCK_HEIGHT;\n  }\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      map[y + i][x + j] = c;\n    }\n  }\n}\n\nvoid find(int c, int x, int y) {\n  if (c == map[y][x]) {\n    pmap[y][x] = 1;\n  }\n  if (pmap[yg][xg]) {\n    answer = true;\n    return;\n  }\n  if (x - 1 > 0 && c == map[y][x - 1] && !pmap[y][x - 1]) {\n    find(c, x - 1, y);\n  }\n  if (x + 1 < 101 && c == map[y][x + 1] && !pmap[y][x + 1]) {\n    find(c, x + 1, y);\n  }\n  if (y - 1 > 0 && c == map[y - 1][x] && !pmap[y - 1][x]) {\n    find(c, x, y - 1);\n  }\n  if (y + 1 < 101 && c == map[y + 1][x] && !pmap[y + 1][x]) {\n    find(c, x, y + 1);\n  }\n}\n\nint main() {\n  int n, c, d, x, y;\n  while(cin >> w >> h, w) {\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    init();\n    for (int i = 0; i < n; i++) {\n      cin >> c >> d >> x >> y;\n      set_block(c, d, x, y);\n    }\n    find(map[ys][xs], xs, ys);\n    cout << ((answer) ? \"OK\" : \"NG\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y, int before_x, int before_y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( !color[x][y] )\n\t\treturn false;\n\tif ( color[x][y] == color[x + 1][y] && x + 1 != before_x )\n\t\tif ( solve(x + 1, y, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] && y + 1 != before_y )\n\t\tif ( solve(x, y + 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] && y - 1 != before_y )\n\t\tif ( solve(x, y - 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] && x - 1 != before_x )\n\t\tif ( solve(x - 1, y, x, y) )\n\t\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i < 1000; i++ ){\n\t\t\tfor ( int j = 0; j < 1000; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\t//ブロック情報\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( !block_quarter ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( solve(start_x, start_y, start_x, start_y) )\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define all(v) (v).begin(),(v).end()\n#define pf push_front\n#define pb push_back\n#define int long long\nusing namespace std;\nconst int INF=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint mp[100001][100001];\nbool ans;\nint w,h,tmp;\nint xs,ys,xg,yg;\n\nvoid dfs(int y,int x,int c){\n  if(y>0&&y<=h&&x>0&&x<=w&&mp[y][x]==c){\n    mp[y][x]=0;\n    rep(i,4){\n      dfs(y+dy[i],x+dx[i],c);\n    }\n  }else return;\n  if(y==yg&&x==xg){\n    ans=true;\n    return;\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h,w){\n    rep(i,w)rep(j,h)mp[i][j]==0;\n    ans=false;\n    cin>>xs>>ys>>xg>>yg;\n    //xs--;ys--;xg--;yg--;\n    int n;\n    cin>>n;\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      //x--;y--;\n      if(d==0)rep(i,2)rep(j,4)mp[y+i][x+j]=c;\n      else rep(i,2)rep(j,4)mp[y+j][x+i]=c;\n    }\n    tmp=mp[ys][xs];\n    if(mp[ys][xs]==tmp&&mp[yg][xg]==tmp)dfs(ys,xs,tmp);\n    cout<<(ans?\"OK\":\"NG\")<<endl;\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nbool ans;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\t\tint cx = p.second, cy = p.first;\n\n\t\tif (y == gy&&x == gx)break;\n\n\t\tREP(i, 4){\n\t\t\tint nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h){\n\t\t\t\tif (table[ny][nx] == table[cy][cx]\n\t\t\t\t\t&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[cy][cx] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tans = 0;\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tdis[sy][sx] = 1;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\tif (dis[gy][gx] != INF)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, w, h, xs, ys, xg, yg, f[105][105] = { 0 }, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, used[105][105] = { 0 }, color = 0;\nbool flag;\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (xg == nx&&yg == ny) {\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif (used[ny][nx]) continue;\n\t\tif (1 <= nx&&nx <= w && 1 <= ny&&ny <= h&&f[ny][nx] == color) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused[ys][xs] = 1;\n\t\tcolor = f[ys][xs];\n\t\tdfs(ys, xs);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL p=7+1e+9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint W, H;\nint xs, ys, xg, yg;\nint N, C;\nint maze[128][128];\nbool check[128][128];\n\nint dfs(int x, int y){\n\tif(x == xg && y == yg)\n\t\treturn 1;\n\t\n\tint res = 0;\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx > 0 && nx <= W && ny > 0 && ny <= H && !check[ny][nx] && maze[ny][nx] == C){\n\t\t\tcheck[ny][nx] = true;\n\t\t\tres |= dfs(nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> W >> H && (W || H)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tmemset(check, 0, sizeof(check));\n\t\tcin >> xs >> ys >> xg >> yg >> N;\n\t\tint c, d, x, y;\n\t\tREP(i,N){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,2)\n\t\t\t\t\tREP(k,4)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(j,4)\n\t\t\t\t\tREP(k,2)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t\tC = maze[yg][xg];\n\t\tcheck[ys][xs] = true;\n\t\tint ans = dfs(xs, ys);\n\t\tif(ans){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) 0<a&&a<=b\nusing namespace std;\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nint w,h,xs,ys,xg,yg,n,c,d,x,y,f[101][101];\nbool dfs(int y,int x){\n\tf[y][x]=0;\n\tif(y==yg&&x==xg)return 1;\n\tbool r=0;\n\trep(d,4){\n\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\tif(ck(ny,h)&&ck(nx,w)&&f[ny][nx]==c)r=r||dfs(ny,nx);\n\t}\n\treturn r;\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w)f[i+1][j+1]=0;\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\trep(i,n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\trep(j,(d?2:4))rep(k,(d?4:2))f[y+k][x+j]=c;\n\t\t}\n\t\tc=f[ys][xs];\n\t\tcout<<(c>0&&dfs(ys,xs)?\"OK\":\"NG\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] )\n{\n\t/*came[ y ][ x ] = false ;*/\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t{\n\t\t\tcame[ yy ][ xx ] = false ;\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t\t}\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tcame[ gy ][ gx ] = false ;\t//\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dir[][2] = {\n\t1, 0,\n\t0, 1,\n\t-1, 0,\n\t0, -1\n};\n\nstring solve( VVI board, int sy, int sx, int gx, int gy )\n{\n\tconst int H = board.size(), W = board[0].size();\n\n\tint color = board[ sy ][ sx ];\n\t\n\tqueue< PII > que;\n\tque.push( MP( sy, sx ) );\n\n\tset< PII > visited;\n\tvisited.insert( MP( sy, sx ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tauto cur = que.front();\n\t\tque.pop();\n\n\t\tif ( cur == MP( gy, gx ) )\n\t\t{\n\t\t\treturn \"OK\";\n\t\t}\n\n\t\tREP( d, 0, 4 )\n\t\t{\n\t\t\tauto next = cur;\n\n\t\t\tnext.fst += dir[d][0];\n\t\t\tnext.snd += dir[d][1];\n\n\t\t\tif ( !( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W ) || \n\t\t\t\t EXIST( visited, next ) ||\n\t\t\t\t board[ next.fst ][ next.snd ] != color )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tque.push( next );\n\t\t\tvisited.insert( next );\n\t\t}\n\t}\n\n\treturn \"NG\";\n}\t\t\t\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\n\t\tVVI board( h, VI( w, 0 ) );\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( !d )\n\t\t\t{\n\t\t\t\tREP( j, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tREP( k, 0, 4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ y + j ][ x + k ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP( j, 0, 4 )\n\t\t\t\t{\n\t\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ y + j ][ x + k ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve( board, sy, sx, gy, gx ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<queue>\nusing namespace std;\nint field[128][128];\nbool memo[128][128];\nint dx[] = {-1,0,0,1},dy[] = {0,-1,1,0};\nint w,h;\nvoid func(int x,int y,int c){\n\tif(memo[y][x])return ;\n\tif(field[y][x] != c)return ;\n\tmemo[y][x] = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tfunc(x+dx[i],y+dy[i],c);\n\t}\n\treturn ;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w,h){\n\t\tint xs,ys,xg,yg,n;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = x; j < x + 4; j++){\n\t\t\t\t\tfield[y][j] = c;\n\t\t\t\t\tfield[y+1][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < y + 4; j++){\n\t\t\t\t\tfield[j][x] = c;\n\t\t\t\t\tfield[j][x+1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunc(xs,ys,field[ys][xs]);\n\t\tcout << (memo[yg][xg]==1?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nclass cordinate\n{\n\npublic:\n\tint x;\n\tint y;\n\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\n\n\t\tint w;\n\t\tint h;\n\t\tcin >> w >> h; \n\t\tif(w == 0 && h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint xs;\n\t\tint ys;\n\t\tcin >> xs >> ys;\n\t\tint xg;\n\t\tint yg;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<vector<int >> vobj;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tvector<int> lineobj;\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tlineobj.push_back(0);\n\n\t\t\t}\n\t\t\tvobj.push_back(lineobj);\n\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 2][y] = c;\n\t\t\t\tvobj[x + 3][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 2][y + 1] = c;\n\t\t\t\tvobj[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x][y + 2] = c;\n\t\t\t\tvobj[x][y + 3] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 2] = c;\n\t\t\t\tvobj[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\n\t\tint startColor;\n\t\tstartColor = vobj[xs - 1][ys - 1];\n\t\tqueue<cordinate> que;\n\n\t\tcordinate obj;\n\t\tobj.x = xs - 1;\n\t\tobj.y = ys - 1;\n\t\tque.push(obj);\n\t\tbool flag = false;\n\t\twhile(1)\n\t\t{\n\t\t\tif(startColor == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcordinate buf;\n\t\t\tbuf = que.front();\n\t\t\tque.pop();\n\n\t\t\tint bx;\n\t\t\tint by;\n\t\t\tbx = buf.x;\n\t\t\tby = buf.y;\n\t\t\tif(bx == xg - 1 && by == yg - 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif(bx + dx[i] >= 0 && bx + dx[i] <= w - 1)\n\t\t\t\t{\n\t\t\t\t\tif(by + dy[i] >= 0 && by + dy[i] <= h - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vobj[bx + dx[i]][by + dy[i]] == startColor)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcordinate newObject;\n\t\t\t\t\t\t\tnewObject.x = bx + dx[i];\n\t\t\t\t\t\t\tnewObject.y = by + dy[i];\n\t\t\t\t\t\t\tque.push(newObject);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvobj[bx][by] = -1;\n\n\t\t\tif(que.size() == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(flag == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t/*for(int i = 0; i < w - 1; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < h - 1; j++)\n\t\t\t{\n\t\t\t\tcout << vobj[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}  */\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(block[xi][yi] == 0) return ;\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1, yi);\n        solve(xi, yi-1);\n        solve(xi+1, yi);\n        solve(xi, yi+1);\n    }\n    block[xi][yi] = 0;\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(int)*w*h);\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            //cout << x << \",\"<< y << endl;\n            if(d==1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=9;\n\tDFScolor(X-1,Y,color);\n\tDFScolor(X,Y+1,color);\n\tDFScolor(X+1,Y,color);\n\tDFScolor(X,Y-1,color);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==9)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n}"
  },
  {
    "language": "C++",
    "code": "include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=-1;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n  int goal_x,goal_y;\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        b.mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color){\n\t\t\tmap[x][y] = 9;\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> ys >> xs;\n\t\tcin >> yg >> xg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nvoid fun(int y,int x){\n    if(map[y][x]==map[ys][xs]){\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y+1][x+1]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+2);\n    fun(y,x-2);\n    fun(y+2,x);\n    fun(y-2,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cout << endl;\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==1){//???\n\t\t\t\tfor(m=0;m<2;m++){\n\t\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//?¨?\n\t\t\t\tfor(m=0;m<4;m++){\n\t\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(brock[xs][ys]!=brock[xg][yg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[xs][ys];\n\t\t\tds[xs][ys]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==xg&&ba.b==yg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[xg][yg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=w&&ba.b+q[i]>0&&ba.b+q[i]<=h&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(R==map[gb][ga]){\n\t\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint sx,sy,gx,gy,col;\nbool func(vector<vector<int> >out,vector<vector<bool> >&out2,int x,int y){\n  out2[x][y]=true;\n  rep(i,3)rep(j,3){\n    if(out2[x+i][y+j]!=true&&out[x+i][y+j]==col)func(out,out2,x+i,y+j);\n  }\n}\nint main(){\n  int n,m;\n  while(cin>>m>>n,n|m){\n    cin>>sx>>sy>>gx>>gy;\n    int nn;cin>>nn;\n    vector<vector<int> >out(n+2);\n    vector<vector<bool> >out2(n+2);\n    rep(i,n+2)rep(j,m+2)out[i].pb(0);\n    rep(i,n+2)rep(j,m+2)out2[i].pb(false);\n    rep(q,nn){\n      int a,b,c,d;\n      cin>>a>>b>>d>>c;\n      if(b)rep(i,4)rep(j,2)out[i+c][j+d]=a;\n      else rep(i,2)rep(j,4)out[i+c][j+d]=a;\n    }\n    /*cout<<endl;\n    rep(i,n){\n      rep(j,m)cout<<\" \"<<out[i+1][j+1];\n      cout<<endl;\n      }*/\n    \n    if(out[gx][gy]==0||out[gx][gy]!=out[sx][sy]){\n      cout<<\"NG\"<<endl;\n      continue;\n    }\n    col=out[sx][sy];\n    func(out,out2,sx,sy);\n    if(out2[gx][gy])cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    /*rep(i,n){\n      rep(j,m)cout<<\" \"<<out[i+1][j+1];\n      cout<<endl;\n      }*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[110][110];\n\nvoid dfs(int x , int y , int w , int h , int xg , int yg , int c){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif( board[tx][ty]!=c || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( tx,ty,w,h,xg,yg,c);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs( xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<1; i++){\n      for(int j=0; j<1; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\nif(F[xs][ys]==0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint dx[] = {0, 1, 0, 1}, dy[] = {0, 0, 1, 1};\nstruct P{ int x, y; };\nint main()\n{\n\tint w, h;\n\twhile(cin >> w >> h && (w || h))\n\t{\n\t\tvector<vint> field(w, vint(h, 0));\n\t\tP s, g;\n\t\tcin >> s.x >> s.y >> g.x >> g.y;\n\t\ts.x--, s.y--, g.x--, g.y--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i, n)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i]][y + dy[i]] = c;\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i] + 2 * !d][y + dy[i] + 2 * d] = c;\n\t\t}\n\n\t\tint c = field[s.x][s.y];\n\t\tif(!c || !field[g.x][g.y])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<P> que;\n\t\tfor(que.push(s); !que.empty(); que.pop())\n\t\t{\n\t\t\tP p = que.front();\n\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tint nx = p.x + dx[i], ny = p.y + dy[i];\n\t\t\t\t\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[nx][ny] == c)\n\t\t\t\t{\n\t\t\t\t\tfield[nx][ny] = 0;\n\t\t\t\t\tP next; next.x = nx, next.y = ny;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (field[g.x][g.y] ? \"NG\" : \"OK\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <ctime>\n#define INF 100000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n \n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint maze[105][105];\nint w,h,xs,ys,xg,yg;\n\nvoid init(){\n  rep(i,105){\n    rep(j,105){\n      maze[i][j]=-1;\n    }\n  }\n}\n\nvoid DEBUG(){\n  rep(i,h){\n    rep(j,w)cout<<maze[i][j]<<\" \";\n    cout<<endl;\n  }\n}\n\nbool bfs(int c){\n  //DEBUG();\n  queue<int>que;\n  que.push(xs);\n  que.push(ys);\n  while(que.size()){\n    //cout<<c<<endl;\n    int x=que.front();que.pop();\n    int y=que.front();que.pop();\n    if(x==xg&&y==yg)return true;\n    for(int i=0;i<4;i++){\n      if(0<x+dx[i]&&x+dx[i]<=w&&0<y+dy[i]&&y+dy[i]<=h&&maze[y+dy[i]][x+dx[i]]==c&&maze[y+dy[i]][x+dx[i]]!=-1){\n\tque.push(x+dx[i]);\n\tque.push(y+dy[i]);\n\tmaze[y+dy[i]][x+dx[i]]=-1;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n,c,d,x,y;\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    init();\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    rep(i,n){\n      cin>>c>>d>>x>>y;\n      if(d==0){\n\trep(j,2){\n\t  rep(k,4){\n\t    maze[y+j][x+k]=c;\n\t  }\n\t}\n      }else if(d==1){\n\trep(j,4){\n\t  rep(k,2){\n\t    maze[y+j][x+k]=c;\n\t  }\n\t}\n      }\n    }\n    if(bfs(maze[ys][xs]))cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dir[][2] = {\n\t1, 0,\n\t0, 1,\n\t-1, 0,\n\t0, -1\n};\n\nstring solve( VVI board, int sy, int sx, int gy, int gx )\n{\n\tconst int H = board.size(), W = board[0].size();\n\n\tint color = board[ sy ][ sx ];\n\t\n\tqueue< PII > que;\n\tque.push( MP( sy, sx ) );\n\n\tset< PII > visited;\n\tvisited.insert( MP( sy, sx ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tauto cur = que.front();\n\t\tque.pop();\n\n\t\tif ( cur == MP( gy, gx ) )\n\t\t{\n\t\t\treturn \"OK\";\n\t\t}\n\n\t\tREP( d, 0, 4 )\n\t\t{\n\t\t\tauto next = cur;\n\n\t\t\tnext.fst += dir[d][0];\n\t\t\tnext.snd += dir[d][1];\n\n\t\t\tif ( !( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W ) || \n\t\t\t\t EXIST( visited, next ) ||\n\t\t\t\t board[ next.fst ][ next.snd ] != color )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tque.push( next );\n\t\t\tvisited.insert( next );\n\t\t}\n\t}\n\n\treturn \"NG\";\n}\t\t\t\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\n\t\tVVI board( h, VI( w, 0 ) );\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( !d )\n\t\t\t{\n\t\t\t\tREP( j, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tREP( k, 0, 4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ y + j ][ x + k ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP( j, 0, 4 )\n\t\t\t\t{\n\t\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ y + j ][ x + k ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve( board, sy, sx, gy, gx ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, w, h, xs, ys, xg, yg, f[105][105] = { 0 }, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, used[105][105] = { 0 }, color = 0;\nbool flag;\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (xg == nx&&yg == ny) {\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif (used[ny][nx]) continue;\n\t\tif (1 <= nx&&nx <= w && 1 <= ny&&ny <= h&&f[ny][nx] == color) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < 105; i++) {\n\t\t\tfor (int j = 0; j < 105; j++) {\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused[ys][xs] = 1;\n\t\tcolor = f[ys][xs];\n\t\tdfs(ys, xs);\n\t\tif (color == 0) {//?????????????????????????????????\n\t\t\tcout << \"NG\" << endl; continue;\n\t\t}\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX_W 100\n#define MAX_H 100\n\nint board[MAX_H + 1][MAX_W + 1];\nbool ans = false;\n\nvoid swapAB(int a[], int b[]);\nvoid resetBoard();\nvoid setBoard(int c, int d, int x, int y);\nvoid loop(int xn, int yn, int xg, int yg, int c);\nvoid disp(int w, int h);\n\nint main(){\n    int w, h;\n    while(cin >>w >>h){\n        if(w == 0 && h == 0) break;\n        int xs, ys, xg, yg, n;\n        resetBoard();\n        ans = false;\n        cin >>xs >>ys >>xg >>yg >>n;\n        for(int i = 0; i < n; i++){\n            int c, d, x, y;\n            cin >>c >>d >>x >>y;\n            setBoard(c, d, x, y);\n        }\n//        disp(w, h);\n        if(board[ys][xs] == 0){\n            cout <<\"NG\" <<endl;\n        } else{\n            loop(xs, ys, xg, yg, board[ys + 1][xs + 1]);\n            if(ans) cout <<\"OK\" <<endl;\n            else cout <<\"NG\" <<endl;\n        }\n    }\n    return 0;\n}   \n\nvoid swapAB(int a[], int b[]){\n    for(int i = 0; i < 8; i++){\n        int tmp = a[i];\n        a[i] = b[i];\n        b[i] = tmp;\n    }\n}\n\nvoid resetBoard(){\n    for(int i = 0; i <= MAX_H; i++){\n        for(int j = 0; j <= MAX_W; j++){\n            board[i][j] = 0;\n        }\n    }\n}\n\nvoid setBoard(int c, int d, int x, int y){\n    int xm[] = {0, 1, 2, 3, 0, 1, 2, 3}, ym[] = {0, 0, 0, 0, 1, 1, 1, 1};\n    if(d == 1) swapAB(xm, ym);\n    for(int i = 0; i < sizeof(xm) / sizeof(xm[0]); i++){\n        int tmpx = x + xm[i], tmpy = y + ym[i];\n        if(tmpx > 0 || tmpy > 0 || tmpx <= MAX_W || tmpy <= MAX_H){\n            board[tmpy][tmpx] = c;\n        }\n    }\n}\nvoid loop(int xn, int yn, int xg, int yg, int c){\n    if(xn == xg && yn == yg){\n        ans = true;\n    } else{\n        board[yn][xn] = 0;\n        int xm[] = {0, 1, 0, -1}, ym[] = {-1, 0, 1, 0};\n        for(int i = 0; i < sizeof(xm) / sizeof(xm[0]); i++){\n            int tmpx = xn + xm[i], tmpy = yn + ym[i];\n            //            cout <<\"tmpx = \" <<tmpx <<\", tmpy = \" <<tmpy <<endl;\n            if(tmpx > 0 && tmpy > 0 && tmpx <= MAX_W && tmpy <= MAX_H && board[tmpy][tmpx] == c){\n                loop(tmpx, tmpy, xg, yg, c);\n            }\n        }\n    }\n}\n\nvoid disp(int w, int h){\n    for(int i = 0; i <= h; i++){\n        for(int j = 0; j <= w; j++){\n            cout <<board[i][j];\n        }\n        cout <<endl;\n    }\n}\n\n//0, 00:50:41"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101];\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y, int lastp){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc || i == lastp) return;\n\t\tfunc(x + nx[i], y + ny[i], (i + 2) % 4);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\twhile (1){\n\t\tfor (int i = 0; i < 101; i++){\n\t\t\tfor (int j = 0; j < 101; j++){\n\t\t\t\tstage[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tbw = 4;\n\t\t\t\tbh = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbw = 2;\n\t\t\t\tbh = 4;\n\t\t\t}\n\t\t\tfor (int j = 0; j < bh; j++){\n\t\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = stage[ys][xs];\n\t\tif (bc == 0) cout << \"NG\\n\";\n\t\tfunc(1, 1, -1);\n\t\tif (ans == true) cout << \"OK\\n\";\n\t\telse cout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\nusing namespace std;\n\nclass Point\n{\npublic:\n\tint x;\n\tint y;\n\n\tPoint(int x = 0, int y = 0) : x(x), y(y){}\n\tbool operator == (const Point& target)\n\t{\n\t\treturn (this->x == target.x && this->y == target.y);\n\t}\n};\n\nint w, h;\nint map[105][105];\nPoint start;\nPoint goal;\nint n; //????????????????????°\nint c; //???\nint d; //??????\nPoint blockPoint;\n\nvoid setSideways(const Point& blockPoint)\n{\n\t//?¨??????????????????????map???????????????????????????\n\t//\n\t//\t????????????\t(?????????blockPoint?????????)\n\t//\t????????????\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tfor (int j = 0; j < 2; ++j)\n\t\t{\n\t\t\tmap[blockPoint.x + i][blockPoint.y + j] = c;\n\t\t}\n\t}\n}\n\nvoid setPortrait(const Point& blockPoint)\n{\n\t//????????????????????????map???????????????????????????\n\t//\n\t//\t??????\t(?????????blockPoint?????????)\n\t//\t??????\n\t//\t??????\n\t//\t??????\n\tfor (int i = 0; i < 2; ++i)\n\t{\n\t\tfor (int j = 0; j < 4; ++j)\n\t\t{\n\t\t\tmap[blockPoint.x + i][blockPoint.y + j] = c;\n\t\t}\n\t}\n}\n\nbool dfs(Point point, int color) //color????????£????????????????????¨??????\n{\n\t//??¢?´¢??????????????????????????¨??????????????°??????0??????????????????\n\tmap[point.x][point.y] = 0;\n\n\tif (point == goal)\n\t{\n\t\treturn true;\n\t}\n\t//???????????????????????????????????´????????´???????????????????????????????????????\n\tbool upCase = false;\n\tbool downCase = false;\n\tbool leftCase = false;\n\tbool rightCase = false;\n\t//?????¨?????°?????????????????????????????????????????°???\n\tPoint upPoint = Point(point.x, point.y - 1);\n\tPoint downPoint = Point(point.x, point.y + 1);\n\tPoint leftPoint = Point(point.x - 1, point.y);\n\tPoint rightPoint = Point(point.x + 1, point.y);\n\n\t//??????????????????????????????????????°???????????????????????????????????????????????????\n\tif (upPoint.y >= 1 && map[upPoint.x][upPoint.y] == color)\n\t{\n\t\tupCase = dfs(upPoint, color);\n\t}\n\tif (downPoint.y <= h && map[downPoint.x][downPoint.y] == color)\n\t{\n\t\tdownCase = dfs(downPoint, color);\n\t}\n\tif (leftPoint.x >= 1 && map[leftPoint.x][leftPoint.y] == color)\n\t{\n\t\tleftCase = dfs(leftPoint, color);\n\t}\n\tif (rightPoint.x <= w && map[rightPoint.x][rightPoint.y] == color)\n\t{\n\t\trightCase = dfs(rightPoint, color);\n\t}\n\n\treturn (upCase || downCase || leftCase || rightCase);\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\t//?????????????????????\n\t\tfor (int i = 0; i < 105; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 105; ++j)\n\t\t\t{\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//??????????????§????????\\???\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\n\t\t//??????????????°????????´????????°?????\\???\n\t\tcin >> start.x >> start.y;\n\t\tcin >> goal.x >> goal.y;\n\n\t\t//????????????????????° n ?????\\???\n\t\tcin >> n;\n\n\t\t//???????????????????????±??\\???\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tcin >> c >> d >> blockPoint.x >> blockPoint.y;\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tsetSideways(blockPoint);\n\t\t\t}\n\t\t\tif (d == 1)\n\t\t\t{\n\t\t\t\tsetPortrait(blockPoint);\n\t\t\t}\n\t\t}\n\n\t\tint startColor = map[start.x][start.y];\n\t\tif (startColor != 0 && dfs(start, startColor))\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid draw(int c,int d,int x,int y){\n    if(d){\n        for(int i=x;i<x+2;i++){\n            for(int j=y;j<y+4;y++){\n                f[i][j]=c;\n            }\n        }\n    }\n}\n\n\n\nbool DFS(int xs,int ys,int xg,int yg){\n    while(xs!=xg||ys!=yg){\n        if(DFS(xs+1,ys,xg,yg))\n          xs++;\n        else if(DFS(xs-1,ys,xg,yg))\n          xs--;\n        else if(DFS(xs,ys+1,xg,yg))\n          ys++;\n        else if(DFS(xs,ys-1,xg,yg))\n          ys--;\n        else{\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    int c;\n    int d,x,y;\n    while(1){\n        cin>>w>>h;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            draw(c,d,x,y);\n        }\n        if(DFS(xs,ys,xg,yg)){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define rep(i, a, b) for(int i = a; i < b; i ++)\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint map[100][100] = {0};\nint map2[100][100] = {0};\nvoid exp(int x, int y, int c) {\n  if(x <= 0 || w <= x || y <= 0 || h <= y) return;\n  if(map[x][y] != c || map2[x][y] == 1) return;\n\n  map2[x][y] = 1;\n  exp(x-1, y, c);\n  exp(x+1, y, c);\n  exp(x, y-1, c);\n  exp(x, y+1, c);\n\n  return;\n}\n\nint main() {\n  while(cin >> w >> h >> xs >> ys >> xg >> yg >> n, w) {\n    rep(i, 0, h) {\n      rep(j, 0, w) {\n\tmap[j][i] = 0;\n\tmap2[j][i] = 0;\n      }\n    }\n\n    int block[4];\n    int start[4];\n    rep(i, 0, n) {\n      rep(lp, 0, 4) {\n\tcin >> block[lp];\n      }\n\n      switch(block[1]) {\n      case(0):\n\trep(lp1, 0, 2) {\n\t  rep(lp2, 0, 4) {\n\t    map[block[3]+lp1][block[2]+lp2] = block[0];\n\t  }\n\t}\n      case(1):\n\trep(lp1, 0, 4) {\n\t  rep(lp2, 0, 2) {\n\t    map[block[3]+lp1][block[2]+lp2] = block[0];\n\t  }\n\t}\n      }\n    }\n    exp(xs, ys, map[xs][ys]);\n    cout << ((map2[xg][yg] == 1)?(\"OK\"):(\"NG\")) << endl;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint a[100][100];\nbool l=false;\nvoid solve(int n, int m, int xg, int yg, int c,int h,int w) {\n\tif (m + 1 < w&&a[n][m + 1] == c) {\n\t\ta[n][m + 1] = 1000;\n\t\tif (n == xg&&m+1 == yg) {\n\t\t\tl = true; return;\n\t\t}\n\t\tsolve(n, m+1, xg, yg, c, h, w);\n\t}\n\tif (m - 1 >= 0 && a[n][m - 1] == c) {\n\t\ta[n][m - 1] = 1000;\n\t\tif (n == xg&&m - 1 == yg) {\n\t\t\tl = true; return;\n\t\t}\n\t\tsolve(n, m-1, xg, yg, c, h, w);\n\t}\n\tif (n + 1 < h && a[n+1][m] == c) {\n\t\ta[n+1][m] = 1000;\n\t\tif (n+1 == xg&&m == yg) {\n\t\t\tl = true; return;\n\t\t}\n\t\tsolve(n+1, m, xg, yg, c, h, w);\n\t}\n\tif (n - 1 >= 0 && a[n-1][m] == c) {\n\t\ta[n-1][m] = 1000;\n\t\tif (n-1 == xg&&m  == yg) {\n\t\t\tl = true; return;\n\t\t}\n\t\tsolve(n-1, m, xg, yg, c, h, w);\n\t}\n}\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h&&w != 0 && h != 0) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\ta[i][j] = 0;\n\t\t}\n\t\tint xs, ys, xg, yg,n;\n\t\tcin >> ys >> xs;\n\t\tcin >> yg >> xg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int z = 0; z < 4; z++) \n\t\t\t\t\t\ta[x + j][y + z] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int z = 0; z < 2; z++)\n\t\t\t\t\t\ta[x + j][y + z] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint k = a[xs][ys];\n\t\ta[xs][ys] = 1000;\n\t\tl = false;\n\t\tsolve(xs, ys, xg, yg, k,h,w);\n\t\tif (l) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = '.';\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n \n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,cbase);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second \nusing namespace std;\ntypedef pair<int,int> P;\nint w,h,sx,sy,gx,gy,fc;\nint imap[110][110];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\nbool found;\nvoid Init(){\n  for(int i=0;i<110;i++){\n    for(int j=0;j<110;j++){\n      imap[i][j] = -1;\n    }\n  }\n}\n\nvoid display(){\n for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tprintf(\"%3d \",imap[i][j]);\n      }\n      cout << endl;\n    }\n}\n\nvoid draw(int c,int d,int x,int y){\n  int limy,limx;\n  limy = d==1?4:2;\n  limx = d==1?2:4;\n  for(int i=0;i<limy && i<h;i++){\n    for(int j=0;j<limx && j<w;j++){\n      imap[y+i][x+j] = c;\n    }\n  }\n}\n\nvoid rec(int px,int py){\n  if(px == gx && py == gy){\n    found = true;\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int nx = px+dx[i], ny = py+dy[i];\n    if(!found && 0<=nx && nx <w && 0<=ny && ny<h && imap[ny][nx] == fc){\n      imap[ny][nx] = -1;\n      rec(nx,ny);\n    }\n  }\n}\n\n\nbool isMaze(){\n  rec(sx,sy);\n  if(found)return true;\n  return false;\n}\n\nint main(){\n  int n,c,d,x,y;\n  while(cin >> w >> h  && w && h){\n    found = false;\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n    Init();\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      draw(c,d,x,y);\n    }\n\n    \n    fc = imap[sy][sx];\n    if(fc == -1)cout << \"NG\" << endl;\n    else{\n      if(isMaze())cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    \n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nbool dfs(vector<vector<int> > &g);\n\nint sx, sy, gx, gy;\nint n, m; \nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint main()\n{\n\nwhile(cin >> n >> m,(n|m)){\n m++; n++;\n vector<vector<int> > graph(m,vector<int>(n,0));\n \n cin>>sx>>sy>>gx>>gy;\n int bl;  cin>>bl;\n loop(i, bl){\n  int a,b,c,t; cin>>a>>b>>c>>t;\n  if(!b){\n   for(int j=t;j<t+2;j++){\n    for(int k=c;k<c+4;k++){\n     graph[k][j] = a;\n    }\n   } \n  } else {\n   for(int j=c;j<c+2;j++){\n    for(int k=t;k<t+4;k++){\n     graph[k][j] = a;\n    }\n   }\n  }\n }\ncout << ((dfs(graph)) ? \"OK\" : \"NG\") << endl;\n}\nreturn 0;\n}\n\nbool dfs(vector<vector<int> > &g) {\nint cl = g[sx][sy];\nvector<vector<bool> > vsed(m,vector<bool>(n,false));\nqueue<i_i > q;\nq.push(mp(sx,sy));\nwhile(!q.empty()){\nint x = q.front().first, y = q.front().second;\nq.pop();\nif(x == gx && y == gy){\nreturn true;\n}\nif(vsed[x][y]){\ncontinue;\n} else {\nvsed[x][y]=true;\n}\n\nloop(i, 4) {\nint nx = x +dx[i], ny = y +dy[i];\nif(0<nx && nx < n && 0<ny && ny < m){\nif(g[nx][ny] == cl){\nq.push(mp(nx,ny));\n}\n} \n}\n\n}\nreturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, j) FOR(i, 0, j)\n#define rep2(i, k) for(int i = 1; i <= k; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define INF (1 << 30)\n\nusing namespace std;\n \nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint field[105][105], use[105][105];\nint h, w, sx, sy, gx, gy, n;\nint scol;\n\nvoid make_map(int x,int y,int chk,int color){\n  if(chk == 0){\n    for(int i=y;i<y+2;i++){\n      for(int j=x;j<x+4;j++) field[i][j] = color;\n    }\n  }\n  else {\n    for(int i=y;i<y+4;i++){\n      for(int j=x;j<x+2;j++) field[i][j] = color;\n    }\n  }\n}\n\nbool dfs(int x,int y){\n  use[y][x] = true;\n  if(x == gx && y == gy) return true;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h && field[ny][nx] == field[sy][sx] && !use[ny][nx]) dfs(nx,ny);\n  }\n  return use[gy][gx];\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(use, false, sizeof(use));\n\t\tint scol = 0;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\t--sx; --sy; --gx; --gy;\n\t\tcin >> n;\n\t\twhile(n--){\n     \t\tint c,d,x,y; cin >> c >> d >> x >> y; --x; --y;\n      \t\tmake_map(x,y,d,c);\n    \t}\n\t\trep(i, h + 1){\n\t\t\trep(j, w + 1) cout << field[i][j] << \" \";\n\t\t\tputs(\"\");\n  \t\t}\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <string>\n\n#define Pa pair<int,int>\n\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstring bfs(int a[101][101], int sx, int sy, int gx, int gy, int w, int h)\n{\n\tint s, t, m = a[sy][sx];\n\tbool vis[101][101];\n\tstring str = \"NG\";\n\tqueue<Pa> que;\n\tPa pa;\n\tfill(&vis[0][0], &vis[h+1][w+1], true);\n\t\n\tque.push(Pa(sy, sx));\n\tvis[sy][sx] = false;\n\t\n\twhile(!que.empty()){\n\t\tpa = que.front();\n\t\tque.pop();\n\t\tif(pa.first == gy && pa.second == gx){\n\t\t\tstr = \"OK\";\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ts = pa.first + dy[i];\n\t\t\tt = pa.second + dx[i];\n\t\t\tif(1 <= s && s <= h && 1 <= t && t <= w){\n\t\t\t\tif(vis[s][t] && m == a[s][t]){\n\t\t\t\t\tque.push(Pa(s, t));\n\t\t\t\t\tvis[s][t] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str;\n}\n\nint main()\n{\n\tint a[101][101], w, h, sx, sy, gx, gy, s, t, u, v, n;\n\t\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[0][0], &a[h][w], 0);\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u >> v;\n\t\t\tif(t == 0){\n\t\t\t\tfor(int i = v; i <= v+1; i++){\n\t\t\t\t\tfor(int j = u; j <= u+3; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i = v; i <= v+3; i++){\n\t\t\t\t\tfor(int j = u; j <= u+1; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, sx, sy, gx, gy, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h;\nint field[103][103];\nint gx,gy;\nint sc;\n\nvoid init()\n{\n\tfor(int i=0;i<103;i++){\n\t\tfor(int j=0;j<103;j++){\n\t\t\tfield[i][j] = 0;\n\t\t}\n\t}\n}\nbool search(int x,int y)\n{\n\tcout << x << \" \" << y << endl;\n\tbool flag = false;\n\tif(x == gx && y == gy)\n\t\tflag = true;\n\telse{\n\t\tint vectorx[4] = {-1,0,1,0},vectory[4] = {0,-1,0,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x+vectorx[i] >= 0 && y+vectory[i] >= 0 && x+vectorx[i] < w && y+vectory[i] < h){\n\t\t\t\tif(field[x+vectorx[i]][y+vectory[i]] == sc){\n\t\t\t\t\tfield[x][y] = -1;\n\t\t\t\t\tflag |= search(x+vectorx[i],y+vectory[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\t\tinit();\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tint n,c,x,y;\n\t\tbool d;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint vectorx,vectory;\n\t\t\tif(d == 0){\n\t\t\t\tvectorx = 4;vectory = 2;\n\t\t\t}else{\n\t\t\t\tvectorx = 2;vectory = 4;\n\t\t\t}\n\t\t\tfor(int j=0;j<vectorx;j++){\n\t\t\t\tfor(int k=0;k<vectory;k++){\n\t\t\t\t\tfield[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tcout << field[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\tsc = field[sx][sy];\n\t\tif(field[sx][sy] == 0 || field[gx][gy] == 0)\n\t\t\tcout << \"NG\" << endl;\n\t\telse{\n\t\t\tif(search(sx,sy))\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint field[1000][1000];\nint W, H;\nint tmp;\n\nvoid dfs(int x, int y){\n  field[y][x] = -1;\n  for(int i = 0 ; i < 4 ; i++){\n    if(x+dx[i]<0 || W <= x+dx[i] || y+dy[i] < 0 || H <= y+dy[i]) continue;\n    if(field[y+dy[i]][x+dx[i]] != tmp) continue;\n    dfs(x+dx[i], y+dy[i]);\n  }\n}\n    \nint main(){\n  int sx, sy, gx, gy, n;\n  int c, d, x, y;\n\n  while(cin >> W >> H){\n    if(W == 0 && H == 0) break;\n    memset(field, 0, sizeof(field));\n    cin >> sx >> sy >> gx >> gy >> n;\n    sx--, sy--, gx--, gy--;\n    for(int i = 0 ; i < n ; i++){\n      cin >> c >> d >> x >> y;\n      x--, y--;\n      \n      if(d == 1){\n\tfor(int i = y ; i < y+4 ; i++){\n\t  for(int j = x ; j < x+2 ; j++){\n\t    field[i][j] = c;\n\t  }\n\t}\n      }\n      else{\n\tfor(int i = y ; i < y+2 ; i++){\n\t  for(int j = x ; j < x+4 ; j++){\n\t    field[i][j] = c;\n\t  }\n\t}\n      }\n    }\n    if(field[sy][sx] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    \n    tmp = field[sy][sx];\n    dfs(sx, sy);\n    \n    if(field[gy][gx] == -1) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[110][110];\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight - 1;\n    board_hight  = Board_Hight  - 1;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n    \n    while(cin >> w >> h){\n        if(w == 0 && h == 0) break;\n        cin >> sx >> sy >> gx >> gy;\n        Solve s(w, h, sx, sy, gx, gy);\n        \n        cin >> n;\n        \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n            s.set_Block(c, d, x, y);\n        }\n        \n        if(s.check()){\n            cout << \"OK\\n\";\n        }else{\n            cout << \"NG\\n\";\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint mass[102][102];\nint gx,gy;\nbool goal_flag;\nvoid DFS(int x,int y,int c){\n    if(mass[y][x]!=c || mass[y][x]==0)return;\n    if(x==gx&&y==gy){goal_flag=true;return;}\n    mass[y][x]=0;\n    DFS(x+1,y,c);\n    DFS(x-1,y,c);\n    DFS(x,y+1,c);\n    DFS(x,y-1,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>gx>>gy;\n    cin>>n;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){mass[y+j][x+k]=c;}\n            else if(d==1){mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define MAX 101\n#define Nll -1\nint w,h;\nint xs,ys,xg,yg;\nint blockNm;\nint map[MAX][MAX];\ntypedef queue < pair<int,int> > Queue;\nvoid setBlock(int color,int dir,int x,int y){\n\tint dx[]={2,0};\n\tint dy[]={0,2};\n\tint xb=x,yb=y;//x_base,y_base\n\tfor(int i=0;i<2;i++,xb+=dx[dir],yb+=dy[dir]){\n\t\tmap[yb][xb]\n\t\t        =map[yb][xb+1]\n\t\t        =map[yb+1][xb]\n\t\t        =map[yb+1][xb+1]=color;\n\t}\n}\nvoid init(){\n\tfor(int i=0;i<MAX;i++)for(int j=0;j<MAX;j++)map[i][j]=-1;\n}\nvoid print(){\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)printf(\"%2d\",map[i][j]);cout<<endl;}\n}\nbool isGoal(int xs,int ys,int xg,int yg){\n\tint color=map[xs][ys];\n\tif(color==Nll)return false;\n\tint dx[]={ 0, 1, 0,-1};\n\tint dy[]={-1, 0, 1, 0};\n\tQueue q;\n\tq.push(pair<int,int>(xs,ys));\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front();q.pop();\n\t\tif(cur.first==xg&&cur.second==yg)return true;\n\t\tmap[cur.first][cur.second]=Nll;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cur.first+dx[i]<1||cur.first+dx[i]>w\n\t\t\t\t\t||cur.second+dy[i]<1||cur.second+dy[i]>h\n\t\t\t\t\t||map[cur.first+dx[i]][cur.second+dy[i]]!=color)continue;\n\t\t\tq.push(pair<int,int>(cur.first+dx[i],cur.second+dy[i]));\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin>>w>>h&&(w||h)){\n\t\tinit();\n\t\tcin>>xs>>ys>>xg>>yg>>blockNm;\n\t\tfor(int i=0;i<blockNm;i++){\n\t\t\tint color,dir,x,y;\n\t\t\tcin>>color>>dir>>x>>y;\n\t\t\tsetBlock(color,dir,x,y);\n\t\t}\n//\t\tprint();\n\t\tstring ans=isGoal(xs,ys,xg,yg)?\"OK\":\"NG\";\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a[102][102],color;\n\nvoid dfs(int x,int y){\n  \n  if(x < 102 && y < 102){\n  \n    a[y][x] = 9;\n    \n    if(a[y+1][x] == color){\n      dfs(x,y+1);\n    }\n    if(a[y][x+1] == color){\n      dfs(x+1,y);\n    }\n    if(a[y-1][x] == color){\n      dfs(x,y-1);\n    } \n    if(a[y][x-1] == color){\n      dfs(x-1,y);\n    }\n  \n  }\n\n} \n\nint main(){\n\n  int xs,ys,xg,yg,n,c,d,x,y,w,h;\n\n  while(1){\n  \n    cin >>w>>h;\n    \n    if(w == 0 && h == 0)break;\n\n    for(int i = 0 ; i < 102 ; i++){\n      for(int j = 0 ; j < 102 ; j++){\n\ta[i][j]=0;\n      }\n    }\n\n    cin >>xs>>ys;\n    cin >>xg>>yg;\n\n    cin >>n;\n\n    for(int i = 0 ; i < n ; i++){\n      \n      cin >> c >> d >> x >> y;\n      \n      if( d == 0 ){\n\tfor(int i = 0 ; i < 2 ; i++){\n\t  for(int j = 0 ; j < 4 ; j++){\n\t    a[i+y][j+x] = c;\n\t  }\n\t}\n      }else{\n\tfor(int i = 0 ; i < 4 ; i++){\n\t  for(int j = 0 ; j < 2 ; j++){\n\t    a[i+y][j+x] = c;\n\t  }\n\t}\n      }\n    \n    }\n    \n    /*\n      for(int i = 0 ; i < h+2 ; i ++){\n      for(int j = 0 ; j < w+2 ; j++){\n      cout << a[i][j];\n      }\n      cout <<endl;\n      }\n      cout <<endl;\n    */\n    \n    color = a[ys][xs];\n    dfs(xs,ys);\n    \n    /*\n      for(int i = 0 ; i < h+2 ; i ++){\n      for(int j = 0 ; j < w+2 ; j++){\n      cout << a[i][j];\n      }\n      cout <<endl;\n      }\n    */\n    \n    if(a[yg][xg] == 9){\n      cout <<\"OK\"<<endl;\n    }else{\n      cout <<\"NG\"<<endl;\n    }\n    \n  }      \n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint w,h;\n\tint xs,ys;\n\tint xg,yg;\n\tint n;\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tint field[101][101];\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfill(field[i],field[i]+101,0);\n\n\t\tcin>>xs>>ys;\n\t\tcin>>xg>>yg;\n\t\txs--;ys--;xg--;yg--;\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;y--;\n\t\t\tif(d==0){\n\t\t\t\tfor(int j = y; j < 2+y; j++){\n\t\t\t\t\tfor(int k = x; k < x + 4; k++){\n\t\t\t\t\t\tfield[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < 4+y; j++){\n\t\t\t\t\tfor(int k = x; k < x + 2; k++){\n\t\t\t\t\t\tfield[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// bfs\n\t\tint c=field[ys][xs];\n\n\t\tif(c==0){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\t\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\n\t\tconst int dy[]={-1,0,0,1};\n\t\tconst int dx[]={0,-1,1,0};\n\n\t\tbool passed[101][101];\n\t\tfor(int i = 0; i < 101; i++)\n\t\t\tfill(passed[i],passed[i]+101,false);\n\n\t\tprv->push(make_pair(ys,xs));\n\n\t\tbool fin=false;\n\t\twhile(prv->size()){\n\t\t\twhile(prv->size()){\n\t\t\t\tpair<int,int> p = prv->front();\n\t\t\t\tprv->pop();\n\t\t\t\tif(p.first==yg&&p.second==xg){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(passed[p.first][p.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tpassed[p.first][p.second]=true;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&field[ny][nx]==c&&!passed[ny][nx]){\n\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tswap(prv,nxt);\n\t\t}\n\t\tif(fin){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse\n\t\t\tcout<<\"NG\"<<endl;\n\t\tdelete prv,nxt;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nclass cordinate\n{\n\npublic:\n\tint x;\n\tint y;\n\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\n\n\t\tint w;\n\t\tint h;\n\t\tcin >> w >> h; \n\t\tif(w == 0 && h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint xs;\n\t\tint ys;\n\t\tcin >> xs >> ys;\n\t\tint xg;\n\t\tint yg;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<vector<int >> vobj;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tvector<int> lineobj;\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tlineobj.push_back(0);\n\n\t\t\t}\n\t\t\tvobj.push_back(lineobj);\n\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 2][y] = c;\n\t\t\t\tvobj[x + 3][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 2][y + 1] = c;\n\t\t\t\tvobj[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x][y + 2] = c;\n\t\t\t\tvobj[x][y + 3] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 2] = c;\n\t\t\t\tvobj[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0; i < w - 1; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < h - 1; j++)\n\t\t\t{\n\t\t\t\tcout << vobj[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint startColor;\n\t\tstartColor = vobj[xs - 1][ys - 1];\n\t\tqueue<cordinate> que;\n\n\t\tcordinate obj;\n\t\tobj.x = xg - 1;\n\t\tobj.y = yg - 1;\n\t\tque.push(obj);\n\t\tbool flag = false;\n\t\twhile(1)\n\t\t{\n\t\t\tif(startColor == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcordinate buf;\n\t\t\tbuf = que.front();\n\t\t\tque.pop();\n\n\t\t\tint bx;\n\t\t\tint by;\n\t\t\tbx = buf.x;\n\t\t\tby = buf.y;\n\t\t\tif(bx == xg - 1 && by == yg - 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif(bx + dx[i] >= 0 && bx + dx[i] <= w - 1)\n\t\t\t\t{\n\t\t\t\t\tif(by + dy[i] >= 0 && by + dy[i] <= h - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vobj[bx + dx[i]][by + dy[i]] == startColor)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcordinate newObject;\n\t\t\t\t\t\t\tnewObject.x = bx + dx[i];\n\t\t\t\t\t\t\tnewObject.y = by + dy[i];\n\t\t\t\t\t\t\tque.push(newObject);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvobj[bx][by] = 0;\n\n\t\t\tif(que.size() == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(flag == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <algorithm>\n//using namespace std;\n// \n//int N;  // ??????????????° (1 <= N <= 100)\n//int W;  // ??????????????????????????? (1 <= W <= 10000)\n// \n//struct Item {\n//    int v;  // ??????????????? (1 <= v <= 1000)\n//    int w;  // ??????????????? (1 <= w <= 1000)\n//};\n//Item items[101];    // ??????????????±\n// \n//int C[101][10001];  // ??????????????????????¨???????????????????????¬??????????\n///*\n//    C[i][w] :\n//    ???????????????????????\\?????????or??\\???????????????i????????????????????§????????????\n//    ??????????????????????¨????w????????£???????????????????????§??????????´??????????\n//*/\n//\n//int maxv = 0;  // ?????????????¨?????????§???\n// \n//// ??????????????????????????°????????¢??°\n//void debug_print(int i, int w)\n//{\n//    char key_wait;\n// \n//    cout << \"  C[i][w] = max(C[i-1][w], C[i-1][w - items[i].w] + items[i].v);\" << endl;\n//    cout << \"->C[\" << i << \"][\" << w << \"] = max(C[\" << i - 1 << \"][\" << w << \"], C[\" << i - 1 << \"][\" << w << \" - \" << items[i].w << \"] + \" << items[i].v << \")\" << endl;\n// \n//    for (int iii = 0; iii <= N; ++iii) {\n//        for (int www = 0; www <= W; ++www) {\n//            if (C[iii][www] == -1) {\n//                cout << \" x\";\n//            }\n//            else {\n//                cout << \" \" << C[iii][www];\n//            }\n//        }\n//        cout << endl;\n//    }\n// \n//    cin >> key_wait;\n//}\n// \n// \n//int main()\n//{\n//    int i, w;\n// \n//    cin >> N >> W;\n// \n//    // ?????? = 0, ?????? = 0 ???????????????????????\\???????????????\n//    // ?????????????????¨??§?????????????????????????°??????????????????????????????????\n//    items[0].v = 0;\n//    items[0].w = 0;\n//    for (i = 1; i <= N; ++i) {\n//        cin >> items[i].v >> items[i].w;\n//    }\n// \n//    /*\n//    ???????????°????????¨????????????-1??§?????????\n//    ??????????§£??????????????£??????\n//    ????????????????????????????????????????????????\n//    */\n//    for (i = 0; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            C[i][w] = -1;\n//        }\n//    }\n// \n//    // ??¢????????????????????\\??£???????????´????????????0\n//    for (w = 0; w <= W; ++w) {\n//        C[0][w] = 0;\n//    }\n// \n//    for (i = 1; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            // ?????????????????????i??????????????????????????\\???????????´???\n//            if (w - items[i].w < 0) {\n//                C[i][w] = C[i - 1][w];\n//            }\n//            // ?????????????????????i????????????????????\\??????????£????????????´??????\n//            // i????????????????????\\???????????£??????????????????\n//            // i????????????????????\\???????????????w????????£??????????????????????????????\n//            // ????????§????????????????´??????????\n//            else {\n//                C[i][w] = max(C[i - 1][w], C[i - 1][w - items[i].w] + items[i].v);\n//            }\n//            maxv = max(maxv, C[i][w]);\n// \n//            // ???????????°????????¨??¢??°\n//            // ???????????????????????¢??????????????°AOJ??§Accepted??????????????????\n//            debug_print(i, w);\n//        }\n//    }\n// \n//    cout << maxv << endl;\n// \n//    return 0;\n//}\n/*\n#include <iostream>\n#include <string>\nusing namespace std;\n\n#define REP( i, a )     for( int i = 0; i < a; i++ )\n#define RREP( i, a )    for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin, (A).end()\n\ntemplate <typename T>\nvoid debug( const T& outData ) {\n\tcout << outData << endl;\n}\n\ntemplate <typename T>\nvoid debugAr( const T& outData[], const int& loopNum ) {\n\n\tfor( int i = 0; i < loopNum; i++ ) cout << outData[i] << endl;\n\n}\n\nint main()\n{\n\n\tint a;\n\tstring str;\n\n\tcin >> a >> str;\n\n\tdebug( a );\n\tdebug( str );\n\n\treturn 0;\n\n}\n*/\n\n/*#ifndef DEBUG_H\n#define DEBUG_H\n\n#include <iostream>\n\n#define REP( i, a )  for( int i = 0; i < a; i++ )\n#define RREP( i, a ) for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin(), (A).end()\n\ntemplate <typename T>\nvoid prt( T outData )\n{\n\nstd::cout << outData << endl;\n\n}\n\n\n\n#endif\n\n\n??£????????????\n*/\n\n/*\n#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int N=100;\n\nint main(){\nint i,n,j,p[N+1],m[N+1][N+1],k;\ncin>>n;\nfor(i=1;i<=n;i++){\ncin>>p[i-1]>>p[i];\n}\nfor(i=1;i<=n;i++) m[i][i]=0;\nfor(i=2;i<=n;i++){\nfor(i=1;i<=n;i++){\nint j=i+i-1;\nm[i][j]=(i<<21);\nfor(k=10;k<=j-1;j++){\n}\n}\n}\nm[i][j]=min(m[i][j]=\n\n*/\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0,w,h;\nint block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcout<<endl;\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nint block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nbool bfs(pair<int,int>[],int **);\n\nint main(void){\n\tint w,h,xs,ys,xg,yg,n,**board,dr[2][2]={4,2,2,4};\n\tpair<int,int> sg[2];\n\n\tdo{\n\t\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\n\t\tsg[0] = make_pair(xs,ys);\n\t\tsg[1] = make_pair(xg,yg);\n\n\t\tboard = new int*[w+2];\n\t\tfor(int i=0;i<w+2;i++)\n\t\t\tboard[i] = new int[h+2];\n\n\t\tfor(int i=0;i<h+2;i++)\n\t\t\tfor(int j=0;j<w+2;j++)\n\t\t\t\tboard[j][i]=0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor(int j=0;j<dr[d][0];j++)\n\t\t\t\tfor(int k=0;k<dr[d][1];k++)\n\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t}\n\n\t\tcout << (bfs(sg,board)?\"OK\":\"NG\");\n\t\tcout << endl;\n\n\t\tfor(int i=0;i<w+2;i++)\n\t\t\tdelete [] board[i];\n\t\tdelete [] board;\t\n\t}while(w!=0||h!=0);\n\n\treturn 0;\n}\n\nbool bfs(pair<int,int> sg[],int **board){\n\tqueue< pair<int,int> > Q;\n\tpair<int,int> cur;\n\tint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1},c;\n\n\tQ.push(sg[0]);\n\tcur=Q.front();\n\tc=board[cur.first][cur.second];\n\n\twhile(!Q.empty()&&c!=0){\n\t\tcur=Q.front();\n\t\tQ.pop();\n\t\tboard[cur.first][cur.second]=0;\n\n\t\tif(cur==sg[1])\n\t\t\treturn true;\n\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(board[cur.first+dx[i]][cur.second+dy[j]]==c)\n\t\t\t\t\tQ.push(make_pair(cur.first+dx[i],cur.second+dy[j]));\n\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w;\nint maps[101][101];\nint check[101][101];\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\nint color;\nint sy,sx,gy,gx;\nint by0[]={0,0,1,1,0,0,1,1};\nint bx0[]={0,1,1,0,2,3,2,3};\nint by1[]={0,0,1,1,2,3,2,3};\nint bx1[]={0,1,1,0,0,0,1,1};\n\nbool solve(int y,int x);\n  \nint main(){\n  int n,c,d,x,y;\n  while(cin>>w>>h,w|h){\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n    cin>>n;\n    memset(check,0,sizeof(check));\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      if(d==0){\n\tfor(int i=0;i<8;i++){\n\t  maps[y+by0[i]][x+bx0[i]]=c;\n\t}\n      }\n      if(d==1){\n\tfor(int i=0;i<8;i++){\n\t  maps[y+by1[i]][x+bx1[i]]=c;\n\t}\n      }\n    }\n    sy--;sx--;gy--;gx--;\n    color=maps[sy][sx];\n    if(solve(sy,sx))cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n}\n\nbool solve(int y,int x){\n  check[y][x]=1;\n  if(y==gy && x==gx)return true;\n  bool b=false;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if(ny>=0 && ny<h && nx>=0 && nx<w && maps[ny][nx]==color && check[ny][nx]==0){\n      b=b | solve(ny,nx);\n    }\n  }\n  return b;\n}\n       \n\t\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[101][101]={0},v[101][101]={0};\nint root(int x,int y,int vmap[][101]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int i1=0;i1<101;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y, int before_x, int before_y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( !color[x][y] ){\n\t\tdp[x][y] = false;\n\t\treturn false;\n\t}\n\tif ( color[x][y] == color[x + 1][y] && x + 1 != before_x && dp[x + 1][y] )\n\t\tif ( solve(x + 1, y, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] && y + 1 != before_y && dp[x][y + 1] )\n\t\tif ( solve(x, y + 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] && y - 1 != before_y && dp[x][y - 1] )\n\t\tif ( solve(x, y - 1, x, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] && x - 1 != before_x && dp[x - 1][y] )\n\t\tif ( solve(x - 1, y, x, y) )\n\t\t\treturn true;\n\tdp[x][y] = false;\n\treturn false;\n}\n\nint n, c[30000], d[30000];\n\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i < 1000; i++ ){\n\t\t\tfor ( int j = 0; j < 1000; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t\tdp[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\t//ブロック情報\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( block_quarter == 0 ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( solve(start_x, start_y, start_x, start_y) )\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\nvoid DFC(int y,int x);\nvoid block_set(int c,int d,int x,int y);\nint cs;\nint xg,yg;\nbool result = false;\n\nint main(){\n  int H,W;\n  while(1){\n    result = false;\n    cin >> H >> W;\n    if(H==0&&W==0)\n      break;\n    int xs,ys;\n    cin >> xs >> ys >> xg >> yg;\n    int n;\n    cin >> n;\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(i==0)\n        cs = c;\n        block_set(c,d,x,y);\n    }\n\n    DFC(xs,ys);\n\n    if(result)\n      cout << \"YES\" << endl;\n      else\n      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}\n\nvoid DFC(int x,int y){\n  if(F[x][y]!=cs)\n    return;\n\n  if(x==xg,y==yg)\n    result = true;\n\n  F[x][y]=0;\n\n  DFC(x-1,y);\n  DFC(x+1,y);\n  DFC(x,y-1);\n  DFC(x,y+1);\n}\n\nvoid block_set(int c,int d,int x,int y){\n  for(int i=0;i<2;i++){\n    for(int j=0;j<4;j++){\n      if(d){\n        F[x+i][y+j] = c;\n      }\n      else{\n        F[x+j][y+i] = c;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#include<queue>\n#include<iostream>\n\nusing namespace std;\n\nenum\n{\n\twide, high,\n\tnone = 0\n};\n\n#define BLOCK_WIDE 2\n#define BLOCK_HIGH 4\n\nvoid HighBlock(char map[100 +2][100 +2] ,int color, int x, int y)\n{\n\tint i = y, j;\n\ty += BLOCK_HIGH;\n\twhile (i < y)\n\t{\n\t\tj = x;\n\t\twhile (j < x + BLOCK_WIDE)\n\t\t{\n\t\t\tmap[i][j++] = color;\n\t\t}\n\n\t\t++i;\n\t}\n}\n\nvoid WideBlock(char map[100 +2][100 +2] ,int color, int x, int y)\n{\n\tint i = y, j;\n\ty += BLOCK_WIDE;\n\twhile (i < y)\n\t{\n\t\tj = x;\n\t\twhile (j < x + BLOCK_HIGH)\n\t\t{\n\t\t\tmap[i][j++] = color;\n\t\t}\n\n\t\t++i;\n\t}\n}\n\nint sx, sy;\nint gx, gy;\nint n;\n\n#define X first\n#define Y second\n\nvoid func(char map[100 + 2][100 + 2])\n{\n\tint mx[] = { 0 ,1 ,-1 ,0 };\n\tint my[] = { 1 ,0 ,0 ,-1 };\n\tint way = map[sy][sx];\n\tqueue< pair< int, int > > que;\n\tque.push(make_pair(sx, sy));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<int, int> top = que.front(); que.pop();\n\n\t\tint x = top.X, y = top.Y;\n\t\tif (map[y][x] == way)\n\t\t{\n\t\t\tif (x == gx && y == gy)\n\t\t\t{\n\t\t\t\tputs(\"OK\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmap[y][x] = none;\n\n\t\t\tint i = 4;\n\t\t\twhile (i--)\n\t\t\t{\n\t\t\t\tint xx = x + mx[i];\n\t\t\t\tint yy = y + my[i];\n\n\t\t\t\tif (map[yy][xx] == way)\n\t\t\t\t{\n\t\t\t\t\tque.push(make_pair(xx, yy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(\"NG\");\n}\n\nint main(void)\n{\n\tchar map[100 + 2][100 + 2];\n\tint W, H;\n\twhile (1)\n\t{\n\t\tscanf(\"%d %d\", &W, &H);\n\n\t\tif ((W | H) == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tscanf(\"%d %d\", &sx, &sy);\n\t\tscanf(\"%d %d\", &gx, &gy);\n\t\tscanf(\"%d\", &n);\n\n\t\tint i;\n\t\tfor (i = 0; i < n; ++i)\n\t\t{\n\t\t\tint color, d, x, y;\n\t\t\tscanf(\"%d %d %d %d\", &color, &d, &x, &y);\n\n\t\t\tif (d == wide)\n\t\t\t{\n\t\t\t\tWideBlock(map, color, x, y);\n\t\t\t}\n\n\t\t\tif (d == high)\n\t\t\t{\n\t\t\t\tHighBlock(map, color, x, y);\n\t\t\t}\n\t\t}\n\n\t\tfunc(map);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint field[101][101],b[101][101],X,Y,n,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},I,sX,sY,gX,gY,ans,sgc;\nint func(int x,int y){\n\tfor(I=0;I<4;I++){\n\t\tint xx=x+dx[I];\n\t\tint yy=y+dy[I];\n\t\tif(xx>0&&yy>0&&xx<=X&&yy<=Y&&field[xx][yy]==sgc&&b[xx][yy]==0){\n\t\t\tif(xx==gX&&yy==gY){\n\t\t\t\tif(ans==-1)ans=b[x][y];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse{\n\t\t\tb[xx][yy]=b[x][y]+1;\n\t\t\tfunc(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,i2,c,d,x,y;\n\tcin>>X>>Y;\n\twhile(X!=0){\n\t\tcin>>sX>>sY>>gX>>gY>>n;\n\t\tans=-1;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tc=0;\n\t\t\td=0;\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t\tfor(i2=1;i2<=100;i2++){\n\t\t\t\tfield[i][i2]=0;\n\t\t\t\tb[i][i2]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+2][y]=c;\n\t\t\t\tfield[x+3][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+2][y+1]=c;\n\t\t\t\tfield[x+3][y+1]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x][y+2]=c;\n\t\t\t\tfield[x][y+3]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+1][y+2]=c;\n\t\t\t\tfield[x+1][y+3]=c;\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++)cout<<field[i2][i]<<' ';\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tsgc=field[sX][sY];\n\t\tfunc(sX,sY);\n\t\t/*for(i=1;i<=Y;i++){\n\t\t\tfor(i2=1;i2<=X;i2++){\n\t\t\t\tif(b[i2][i]<10)cout<<' '<<b[i2][i]<<' ';\n\t\t\t\telse cout<<b[i2][i]<<' ';\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tif(ans==-1)cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\tcin>>X>>Y;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy,n;\nint f[128][128];\n\nint dx[] = { 0, 1, 0,-1};\nint dy[] = { 1, 0,-1, 0};\n\nbool dfs(int x, int y)\n{\n\tif(f[y][x]==0)\n\t{\n\t\treturn false;\n\t}\n\tif(x==gx && y==gy)\n\t{\n\t\treturn true;\n\t}\n\n\tint c = f[y][x];\n\tf[y][x] = 0;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\n\t\tif(f[ny][nx]==c)\n\t\t{\n\t\t\tif(dfs(nx,ny))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> w >> h, w||h)\n\t{\n\t\tfor(int y=0; y<128; y++)\n\t\tfor(int x=0; x<128; x++)\n\t\t{\n\t\t\tf[y][x] = 0;\n\t\t}\n\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tint c,d,xx,yy,px,py;\n\t\t\tcin >> c >> d >> xx >> yy;\n\n\t\t\tpx = (1-d)*2;\n\t\t\tpy = (  d)*2;\n\n\t\t\tfor(int y=0; y<2; y++)\n\t\t\tfor(int x=0; x<2; x++)\n\t\t\t{\n\t\t\t\tf[yy   +y][xx   +x] = c;\n\t\t\t\tf[yy+py+y][xx+px+x] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (dfs(sx,sy)?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\nusing namespace std;\n\n#define X_MAX 100+10\n#define Y_MAX 100+10\n\n#define Vertical 1\n#define Horizontal 0\n\nint my[4] = { 1,-1,0,0 };\nint mx[4] = { 0,0,1,-1 };\n\nstruct ST\n{\n\tint now_y;\n\tint now_x;\n};\n\n\nvoid paint_V(int*map , int col)\n{\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\nvoid paint_H(int*map, int col)\n{\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\n\nvoid chek(int map[Y_MAX][X_MAX],int lx,int ly)\n{\n\tint i, j;\n\tfor (i = 0; i <= ly+1;i++)\n\t{\n\t\tfor (j = 0; j <= lx+1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nint main(void)\n{\n\tST an, tmp;\n\tqueue<ST> ma;\n\n\tint lx, ly, n;\n\tint sx, sy, gx, gy;\n\tint col, VorH,set_x,set_y;\n\tint i, j;\n\n\twhile ((cin >> lx >> ly), lx!=0&&ly!=0)\n\t{\n\t\tbool goal = false;\n\t\tint map[Y_MAX][X_MAX] = { 0 };\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> col >> VorH >> set_x >> set_y;\n\t\t\tif (VorH == Vertical)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_V(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_H(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s_col = map[sy][sx];\n\t\tif (s_col == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tan.now_y = sy;\n\t\tan.now_x = sx;\n\t\tma.push(an);\n\n\t\t//chek(map, lx, ly);\n\n\t\twhile (!ma.empty())\n\t\t{\n\t\t\tan = ma.front();\n\t\t\tma.pop();\n\t\t\t//an.came[an.now_y][an.now_x] = -1;\n\t\t\tif (map[an.now_y][an.now_x] == s_col)\n\t\t\t{\n\t\t\t\tmap[an.now_y][an.now_x] = -1;\n\n\t\t\t\t//printf(\"y=%d,x=%d\\n\", an.now_y, an.now_x);\n\t\t\t\t//chek(an.came, lx, ly);\n\n\t\t\t\tif (an.now_y == gy && an.now_x == gx)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttmp = an;\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[an.now_y + my[i]][an.now_x + mx[i]] == s_col/* && an.came[an.now_y + my[i]][an.now_x + mx[i]] == 0*/)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp.now_y = an.now_y + my[i];\n\t\t\t\t\t\ttmp.now_x = an.now_x + mx[i];\n\t\t\t\t\t\tma.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (goal)\n\t\t{\n\t\t\twhile (!ma.empty())\n\t\t\t{\n\t\t\t\tma.pop();\n\t\t\t}\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n    /*\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++)cout << grid[i][j];\n      cout << endl;\n    }\n    */\n    int color = grid[ys][xs];    \n    queue<P> q;\n    if(color){\n      q.push(P(ys,xs));\n      visit[ys][xs] = true;\n      while(q.size()){\n\tP p = q.front();q.pop();\n\ty = p.first;\n\tx = p.second;\n\t//cout << y << \" \" << x << endl;\n\tif(yg == y && xg == x){\n\t  cout << \"OK\\n\";\n\t  q.push(P(y,x));\n\t  break;\n\t}\n\t\n\tint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\tfor(int i=0;i<4;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<0 || sy<0 || w<=sx || h<=sy)continue;\n\t  //if(visit[sy][sx])cout << \"[\" << sy << \" \" << sx << \"]\" << endl;\n\t  if(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\t  //cout << sy << \" \" << sx << endl;\n\t  q.push(P(sy,sx));\n\t  visit[sy][sx] = true;\n\t}\n      }\n    }\n    if(q.empty())cout << \"NG\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdafx.h\"\n#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif(F[ys][xs]!=0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][yg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h, vi(w));\n\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(!d) {\n\t\t\t\t\t\tfield[y-1+k][x-1+j] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y-1+j][x-1+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool goal = false;\n\t\tint color = field[ys-1][xs-1];\n\t\tstack<pii> S;\n\t\tS.push(make_pair(xs-1, ys-1));\n\t\tvvi visit(h, vi(w));\n\t\n\t\tif(color == 0) {\n\t\t\tgoto show;\n\t\t}\n\n\t\twhile(!S.empty()) {\n\t\t\tpii p = S.top();\n\t\t\tS.pop();\n\n\t\t\tvisit[p.second][p.first] = 1;\n\t\t\tif(p.first == xg-1 && p.second == yg-1) {\n\t\t\t\tgoal = true;\n\t\t\t\tgoto show;\n\t\t\t}\n\t\t\t\n\t\t\tREP(d, 4) {\n\t\t\t\tint nx = p.first + dx[d];\n\t\t\t\tint ny = p.second + dy[d];\n\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny<h && field[ny][nx] == color && !visit[ny][nx]) {\n\t\t\t\t\tS.push(make_pair(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nshow:\n\t\tcout << (goal ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=9;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==9)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy;\nint mas[101][101],used[101][101];\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nvoid make_map(int x,int y,int chk,int color){\n  if(chk == 0){\n    for(int i=y;i<y+2;i++){\n      for(int j=x;j<x+4;j++) mas[i][j] = color;\n    }\n  }\n  else {\n    for(int i=y;i<y+4;i++){\n      for(int j=x;j<x+2;j++) mas[i][j] = color;\n    }\n  }\n}\n\nbool dfs(int x,int y){\n  used[y][x] = true;\n  if(x == gx && y == gy) return true;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h && mas[ny][nx] == mas[sy][sx] && !used[ny][nx]) dfs(nx,ny);\n  }\n  return used[gy][gx];\n}\n\nint main(){\n  int n;\n  while(cin >> w >> h,w||h){\n    fill_n(mas[0],101*101,0);\n    memset(used,false,sizeof(used));\n    cin >> sx >> sy >> gx >> gy >> n;\n    --sx; --sy; --gx; --gy;\n    while(n--){\n      int c,d,x,y; cin >> c >> d >> x >> y; --x; --y;\n      make_map(x,y,d,c);\n    }\n    cout << (dfs(sx,sy)? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[101][102];\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\t/*for (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c,d,x,y;       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    goal=0;\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==0 && h==0)break;\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    memset(mass,0,sizeof(mass));\n\n    for(i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      \n    if(d==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y][x+j]=c;\n\tmass[y+1][x+j]=c;\n      }\n    }\n    else if(d==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y+j][x]=c;\n\tmass[y+j][x+1]=c;\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  if(gx==sx && gy==sy)cout<<\"OK\"<<endl;\n\n  else if(scolor==mass[gy][gx]){\n  \n    solve();\n    \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n    }\n  }\n  else {\n    cout<<\"NG\"<<endl;\n  }\n\n  }\n  \n  return 0;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<=w && ny>=0 && ny<=h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\nint W,H;\n\nint field[110][110];\nint done[110][110];\nint dfs(int x,int y,int gx,int gy,int col){\n\tif(x < 0 || y < 0 || field[y][x] == 0 || field[y][x] != col) return 0;\n\tif( x == gx && y == gy ){\n\t\treturn 1;\n\t}\n\tif(done[y][x]) return false;\n\telse done[y][x] = true;\n\tif( dfs(x+1,y,gx,gy,col) ) return true;\n\tif( dfs(x-1,y,gx,gy,col) ) return true;\n\tif( dfs(x,y+1,gx,gy,col) ) return true;\n\tif( dfs(x,y-1,gx,gy,col) ) return true;\n\t\n\t\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(cin >> W >> H && W){\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\tfor(int j = 0 ; j < 110 ; j++) \n\t\t\t\tfield[i][j] = done[i][j] = 0;\n\t\tint sx,sy,gx,gy,n;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t//sx--,sy--;\n\t\t//gx--,gy--;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t//x--,y--;\n\t\t\tif( d == 0 ){\n\t\t\t\tfor(int i = 0 ; i < 3 ; i++)\n\t\t\t\t\tfor(int j = 0 ; j < 4 ; j++)\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t}else{\n\t\t\t\tfor(int i = 0 ; i < 4 ; i++)\n\t\t\t\t\tfor(int j = 0 ; j < 3 ; j++)\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++) cout << field[i][j];\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << (dfs(sx,sy,gx,gy,field[sy][sx])?\"OK\":\"NG\") << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL p=7+1e+9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint W, H;\nint xs, ys, xg, yg;\nint N, C;\nint maze[128][128];\nbool check[128][128];\n\nint dfs(int x, int y){\n\tif(x == xg && y == yg)\n\t\treturn 1;\n\t\n\tint res = 0;\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx > 0 && nx <= W && ny > 0 && ny <= H && !check[ny][nx] && maze[ny][nx] == C){\n\t\t\tcheck[ny][nx] = true;\n\t\t\tres |= dfs(nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> W >> H && (W || H)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tmemset(check, 0, sizeof(check));\n\t\tcin >> xs >> ys >> xg >> yg >> N;\n\t\tint c, d, x, y;\n\t\tREP(i,N){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,2)\n\t\t\t\t\tREP(k,4)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(j,4)\n\t\t\t\t\tREP(k,2)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t\tC = maze[yg][xg];\n\t\tif(C == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcheck[ys][xs] = true;\n\t\tint ans = dfs(xs, ys);\n\t\tif(ans){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\n\nint field[100][100];\nint pathToGoal[100][100];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint dfs(int x, int y, int goalX, int goalY, int color) {\n    pathToGoal[y][x] = 1;\n    if (x == goalX && y == goalY) {\n        return 1;\n    }\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < w && 0 <= ny && ny < h && pathToGoal[ny][nx] == -1 && field[ny][nx] == color) {\n            res += dfs(nx, ny, goalX, goalY, color);\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            return 0;\n        }\n\n        for (int i = 0; i < 100; ++i) {\n            for (int j = 0; j < 100; ++j) {\n                field[i][j] = -1;\n                pathToGoal[i][j] = -1;\n            }\n        }\n\n        int xs, ys;\n        int xg, yg;\n        int n;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        xs--;\n        ys--;\n        xg--;\n        yg--;\n        for (int i = 0; i < n; ++i) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--;\n            y--;\n            if (d == 0) {\n                for (int p = 0; p < 2; ++p) {\n                    for (int q = 0; q < 4; ++q) {\n                        field[y + p][x + q] = c;\n                    }\n                }\n            }\n            else {\n                for (int p = 0; p < 4; ++p) {\n                    for (int q = 0; q < 2; ++q) {\n                        field[y + p][x + q] = c;\n                    }\n                }\n            }\n        }\n\n        if (dfs(xs, ys, xg, yg, field[xs][ys]) > 0) {\n            cout << \"OK\" << endl;\n        }\n        else {\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,a,n,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,false,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]&&R!=0){\n\t\t\tif(block(Y,X)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<cstdio>\nusing namespace std;\n\n#define X_MAX 100+10\n#define Y_MAX 100+10\n\n#define Vertical 1\n#define Horizontal 0\n\nint my[4] = { 1,-1,0,0 };\nint mx[4] = { 0,0,1,-1 };\n\nstruct ST\n{\n\tint came[Y_MAX][X_MAX] = { 0 };\n\tint now_y;\n\tint now_x;\n};\n\n\nvoid paint_V(int*map , int col)\n{\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\nvoid paint_H(int*map, int col)\n{\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\n\nvoid chek(int map[Y_MAX][X_MAX],int lx,int ly)\n{\n\tint i, j;\n\tfor (i = 0; i <= ly+1;i++)\n\t{\n\t\tfor (j = 0; j <= lx+1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nint main(void)\n{\n\tST an,tmp;\n\tstack<ST> ma;\n\n\tint lx, ly, n;\n\tint sx, sy, gx, gy;\n\tint col, VorH,set_x,set_y;\n\tint i, j;\n\n\twhile ((cin >> lx >> ly), lx!=0&&ly!=0)\n\t{\n\t\tint goal = 0;\n\t\tint map[Y_MAX][X_MAX] = { 0 };\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> col >> VorH >> set_x >> set_y;\n\t\t\tif (VorH == Vertical)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_V(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_H(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s_col = map[sy][sx];\n\t\tif (s_col == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tan.now_y = sy;\n\t\tan.now_x = sx;\n\t\tma.push(an);\n\n\t\t//chek(map, lx, ly);\n\n\t\twhile (!ma.empty())\n\t\t{\n\t\t\tan = ma.top();\n\t\t\tma.pop();\n\t\t\tan.came[an.now_y][an.now_x] = 1;\n\n\t\t\t//printf(\"y=%d,x=%d\\n\", an.now_y, an.now_x);\n\t\t\t//chek(an.came, lx, ly);\n\n\t\t\tif (an.now_y == gy && an.now_x == gx)\n\t\t\t{\n\t\t\t\tgoal = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp = an;\n\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (map[an.now_y + my[i]][an.now_x + mx[i]] == s_col && an.came[an.now_y + my[i]][an.now_x + mx[i]] == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp.now_y = an.now_y + my[i];\n\t\t\t\t\ttmp.now_x = an.now_x + mx[i];\n\t\t\t\t\tma.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (goal == 1)\n\t\t{\n\t\t\twhile (!ma.empty())\n\t\t\t{\n\t\t\t\tma.pop();\n\t\t\t}\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n\n    int color = grid[ys][xs];    \n    queue<P> q;\n    if(color){\n      q.push(P(ys,xs));\n      visit[ys][xs] = true;\n      while(q.size()){\n\tP p = q.front();q.pop();\n\ty = p.first;\n\tx = p.second;\n\t\n\tint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\tfor(int i=0;i<4;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || w<sx || h<sy)continue;\n\t  if(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\t  q.push(P(sy,sx));\n\t  visit[sy][sx] = true;\n\t}\n      }\n      if(visit[yg][xg])cout << \"OK\\n\";\n      else cout << \"NG\\n\";\n    }else{\n      cout << \"NG\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tboard[i][j]=0;\n\tcheak[i][j]=0;\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    if(dfs(xs-1,ys-1)==true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(x>=0 && x<w && y>=0 && y<h && board[yn][xn]==board[ys][xs] && cheak[yn][xn]==0){\n      if(dfs(xn,yn)==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nchar start;\nvoid fun(int y,int x){\n    if(map[y][x]==start){\n    \tcout << 1 << endl;\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y][x]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+1);\n    fun(y,x-1);\n    fun(y+1,x);\n    fun(y-1,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        start=map[ys][xs];\n        /*if(map[ys][xs]==0||map[yg][xg]==0);\n        else*/\n        \tfun(ys,xs);\n        for(int i=1;i<w;i++){\n        \tfor(int j=1;j<h;j++){\n        \t\tcout << map[i][j];\n        \t}\n        \tcout << endl;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint board[100][100],w,h,xg,yg;\nbool f(int y,int x){\n\tboard[y][x] = -1;\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\tif(y == yg - 1 && x == xg -1) return true;\n\tfor(i = 0;i < 4;i++){\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\t\t\tif(board[y+dy[i]][x+dx[i]] == 2){\n\t\t\t\tif(f(y+dy[i],x+dx[i])) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint xs,ys,n,i,c,d,x,y,j,k;\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx -= 1;\n\t\t\ty -= 1;\n\t\t\tif(d == 0){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(board[ys - 1][xs - 1] == 2){\n\t\t\tif(f(ys - 1,xs -1)) cout << \"OK\" << endl;\n\t\t\telse cout << \"NG\" << endl;\n\t\t}\n\t\telse cout << \"NG\" << endl;\n\t\tfor(j = 0;j < 100;j++){\n\t\t\tfor(i = 0;i < 100;i++){\n\t\t\t\tboard[j][i] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint board[100][100],w,h,xg,yg;\n\nbool f(int y,int x,int color){\n\n\tboard[y][x] = -1;\n\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\n\tif(y == yg - 1 && x == xg -1) return true;\n\n\tfor(i = 0;i < 4;i++){\n\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\n\t\t\tif(board[y+dy[i]][x+dx[i]] == color){\n\n\t\t\t\tif(f(y+dy[i],x+dx[i],color)) return true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nint main(){\n\n\tint xs,ys,n,i,j,k,c,d,x,y;\n\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\n\t\tfor(j = 0;j < 100;j++){\n\n\t\t\tfor(i = 0;i < 100;i++){\n\n\t\t\t\tboard[j][i] = -1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcin >> xs >> ys;\n\n\t\tcin >> xg >> yg;\n\n\t\tcin >> n;\n\n\t\tfor(i = 0;i < n;i++){\n\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tx -= 1;\n\n\t\t\ty -= 1;\n\n\t\t\tif(d == 0){\n\n\t\t\t\tfor(j = 0;j < 2;j++){\n\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\telse if(d == 1){\n\n\t\t\t\tfor(j = 0;j < 2;j++){\n\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif(board[ys - 1][xs - 1] != -1){\n\n\t\t\tif(f(ys - 1,xs -1,board[ys - 1][xs - 1])) cout << \"OK\" << endl;\n\n\t\t\telse cout << \"NG\" << endl;\n\n\t\t}\n\n\t\telse cout << \"NG\" << endl;\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 10;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h;\t\t\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tcin>>xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\n\t\t\n\t\tif (map[xg][yg]==10)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,sy,sx,gx,gy,n;\nint color;\nint c,d,x,y;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint maps[105][105];\nint mem[105][105];\nint dfs(int nowx,int nowy);\nmain(){\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>sx>>sy>>gx>>gy;\n    cin>>n;\n    memset(maps,0,sizeof(maps));\n    memset(mem,0,sizeof(maps));\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      for(int i=0;i<4;i++){\n\tif(d==0){\n\t  maps[y][x+i]=c;\n\t  maps[y+1][x+i]=c;\n\t}\n\telse{\n\t  maps[y+i][x]=c;\n\t  maps[y+i][x+1]=c;\n\t}\n      }\n    }\n    /*\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcout<<maps[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n    color=maps[sy][sx];\n    if(dfs(sx,sy)==1){\n      cout<<\"OK\"<<endl;\n    }\n    else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\nint dfs(int nowx,int nowy){\n  int check=0;\n  if(nowx==gx&&nowy==gy){\n    return 1;\n  }\n  else{\n    for(int i=0;i<4;i++){\n      if(nowx+dx[i]>=1&&nowx+dx[i]<=w&&nowy+dy[i]>=1&&nowy+dy[i]<=h&&maps[nowy+dy[i]][nowx+dx[i]]==color&&mem[nowy+dy[i]][nowx+dx[i]]==0){\n\tmem[nowy+dy[i]][nowx+dx[i]]=1;\n\tcheck=max(dfs(nowx+dx[i],nowy+dy[i]),check);\n      }\n    }\n    return check;\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pr;\nint main() {\n\t// your code goes here\n\tint w,h;\n\twhile(cin >> w >> h && w!=0){\n\tint xs,ys,xg,yg,n,m,s,sum,c,d,x,y;\n\tint dx[]={0,1,-1,0},dy[]={1,0,0,-1};\n\tcin >> xs>>ys>>xg>>yg >> n;\n\tbool map[102][102]={};\t\n\tint color[102][102]={};\n\tqueue<pr> q;\n\t\tcolor[xs][ys]=10;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >>x >> y;\n\t\t\tfor(int j=0;j<2+d*2;j++)\n\t\t\t\tfor(int k=0;k<4-d*2;k++)\n\t\t\t\t\tcolor[x+k][y+j]=c;\n\t\t}\n\t\tmap[xs][ys]=true;\n\t\tq.push(pr(xs,ys));\n\t\twhile(!q.empty()){\n\t\t\tint f=q.front().first,s=q.front().second;\n\t\t\tq.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(color[f][s]==color[f+dx[i]][s+dy[i]] && !map[f+dx[i]][s+dy[i]]){\n\t\t\t\t\t\tq.push(pr(f+dx[i],s+dy[i]));\n\t\t\t\t\t\tmap[f+dx[i]][s+dy[i]]=true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xg][yg])\n\t\tcout << \"OK\" << endl;\n\t\telse\n\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n    int w,h,xs,ys,n;\n    while(1){\n        Flag=0;\n        memset(MAP,0,sizeof(MAP));\n        memset(MF,0,sizeof(MF));\n        scanf(\"%d %d\",&w,&h);\n        if(w == 0 && h == 0) break;\n        scanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n        scanf(\"%d\",&n);\n        for(int i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            haichi();\n        }\n        /*for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                printf(\"%d\",MAP[i][j]);\n            }\n            printf(\"\\n\");\n        }*/\n        M = MAP[ys][xs];//\n        if(MAP[ys][xs] == MAP[yg][xg])\n            Block(xs,ys);\n        if(Flag==1)\n            printf(\"OK\\n\");\n        else\n            printf(\"NG\\n\");\n    }\n    return 0;\n}\n \nvoid haichi(void)\n{\n    if(d==0){\n        MAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n        MAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n    }\n    else if(d==1){\n        MAP[y][x]=c;MAP[y][x+1]=c;\n        MAP[y+1][x]=c;MAP[y+1][x+1]=c;\n        MAP[y+2][x]=c;MAP[y+2][x+1]=c;\n        MAP[y+3][x]=c;MAP[y+3][x+1]=c;\n    }\n}\n \nvoid Block(int X,int Y)\n{\n    MF[Y][X] = 1;\n    //printf(\"%d\",M);\n    if(X == xg && Y == yg)\n        Flag = 1;\n    if(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n    if(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n    if(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n    if(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n\n    int color = grid[ys][xs];    \n    queue<P> q;\n    if(color){\n      q.push(P(ys,xs));\n      visit[ys][xs] = true;\n      while(q.size()){\n\tP p = q.front();q.pop();\n\ty = p.first;\n\tx = p.second;\n\t\n\tint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\tfor(int i=0;i<4;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<0 || sy<0 || w<=sx || h<=sy)continue;\n\t  if(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\t  q.push(P(sy,sx));\n\t  visit[sy][sx] = true;\n\t}\n      }\n      if(visit[yg][xg])cout << \"OK\\n\";\n      else cout << \"NG\\n\";\n    }else{\n      cout << \"NG\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint map[110][110];\nbool maze[110][110];\nint xs,ys,xg,yg,w,h;\n\nbool bfs(int col){\n\tqueue<P> que;\n\tque.push(P(ys,xs));\n\tmaze[ys][xs]=true;\n\n\twhile(que.size()){\n\t\tP p=que.front();que.pop();\n\t\tif(p.first==yg && p.second==xg) return true;\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dy[i],nx=p.second+dx[i];\n\t\t\tif(ny>0 && ny<=h && nx>0 && nx<=w && !maze[ny][nx] && map[ny][nx]==col){\n\t\t\t\tmaze[ny][nx]=true;\n\t\t\t\tque.push(P(ny,nx));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tfor(int i=0;i<110;i++){\n\t\t\tfor(int j=0;j<110;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t\tmaze[i][j]=false;\n\t\t\t}\n\t\t}\n\n\t\tint n;\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\t\n\t\t\tif(d==0){\n\t\t\t\tfor(int j=y;j<y+2;++j){\n\t\t\t\t\tfor(int k=x;k<x+4;++k){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=y;j<y+4;++j){\n\t\t\t\t\tfor(int k=x;k<x+2;++k){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(bfs(map[ys][xs])) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}\n\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[xg-1][yg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\nint flag;\n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n     flag = 1;\n     return;\n  }\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n \n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  flag = 0;\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i-1)).at(y+j-1) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if( nx==xg && ny==yg) flag = 1;\n  else if( w<=nx+1 || h<=ny+1) return;\n  if(board[nx-1][ny-1]==board[nx][ny-1])\n    func(board,nx+1,ny);\n  if(board[nx-1][ny-1]==board[nx-1][ny])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  string res;\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      object[i].write(board);\n    }\n    func(board,xs,ys);\n    if(flag==1) res = \"OK\";\n    else res = \"NG\";\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <functional> //sort(A,A.end(),greater<int>());???????????????\n#include <queue>\n#include <stack>\n#include <vector>\n\n#define INF 10 << 10\n#define MP make_pair\n\nint map[124][124];\nbool map_flg[124][124];\nint x_move[] = { 0,0,1,-1 };\nint y_move[] = { -1,1,0,0 };\n\nint main() {\n\tint w, h;\n\n\twhile (cin >> w >> h && w != 0 && h != 0) {\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(map_flg, true, sizeof(map_flg));\n\t\tint xs, ys;\n\t\tint xg, yg;\n\t\tint n;\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint x_, y_;\n\t\t\tif (d == 0) {\n\t\t\t\tx_ = 4;\n\t\t\t\ty_ = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_ = 2;\n\t\t\t\ty_ = 4;\n\t\t\t}\n\t\t\tfor (int j = y; j < y + y_; ++j) {\n\t\t\t\tfor (int j2 = x; j2 < x + x_; ++j2) {\n\t\t\t\t\tmap[j][j2] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (map[ys][xs] != map[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstack<pair<int, int> > st;\n\t\tst.push(MP(xs, ys));\n\t\tint m_c = map[ys][xs];\n\t\tbool flg = false;\n\t\twhile (!st.empty()) {\n\t\t\tint x = st.top().first, y = st.top().second;\n\t\t\tst.pop();\n\t\t\tmap_flg[y][x] = false;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint x_ = x + x_move[i], y_ = y + y_move[i];\n\t\t\t\tif (map[y_][x_] == m_c && map_flg[y_][x_]) {\n\t\t\t\t\tif (y_ == yg && x_ == xg) {\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tst.push(MP(x_, y_));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flg) { break; }\n\t\t}\n\n\t\tfor (int i = 1; i < h; ++i) {\n\t\t\tfor (int i2 = 1; i2 < w; ++i2) {\n\t\t\t\tcout << map[i][i2];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tif (flg) { cout << \"OK\" << endl; }\n\t\telse { cout << \"NG\" << endl; }\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[101][101];\nint w,h; \nint color;\nint xg,yg;\n\nbool dfs(int y,int x) {\n \n  if ( map[y][x] != color ) return 0;\n  map[y][x] = 10;\n  //if ( y-1 >= 1 ) dfs( y-1 , x );\n  if ( y+1 <= h ) dfs( y+1 , x );\n  //if ( x-1 >= 1 ) dfs( y , x-1 );\n  if ( x+1 <= w ) dfs( y , x+1 );\n  \n  if ( map[yg][xg] == 10 ) return 1; \n  return 0;\n\n}\n\nint main() {\n  while ( cin >> w >> h ,w+h ) {\n    int xs,ys; cin >> xs >> ys;\n    cin >> xg >> yg;\n    int n; cin >> n;\n    while ( n > 0 ) {\n      n--;\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if ( d == 1 ) {\n\n\tfor ( int i = y; i < y+4; i++ ) {\n\t  for ( int j = x; j < x+2; j++ ) map[i][j] = c;\n\t}\n      \n      } else if ( d == 0 ) {\n\tfor ( int i = y; i < y+2; i++ ) {\n\t  for ( int j = x; j < x+4; j++ ) map[i][j] = c;\n\t}\n      }\n      \n    }\n    color = map[ys][xs];\n    \n    if ( dfs(ys,xs) ) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w,h;\nint field[102][102];\nint sx,sy;\nint gx,gy;\nint n;\nint color;\nbool ans;\n\nvoid DFS(int x,int y)\n{\n\tif(x == gx && y == gy){\n\t\tans = true;\n\t\treturn;\n\t}\n\tif(field[y][x] == -1)\n\t\treturn;\n\tfield[y][x] = -1;\n\tif(color == field[y][x-1])\n\t\tDFS(x-1,y);\n\tif(color == field[y][x+1])\n\t\tDFS(x+1,y);\n\tif(color == field[y-1][x])\n\t\tDFS(x,y-1);\n\tif(color == field[y+1][x])\n\t\tDFS(x,y+1);\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(!w&&!h)\n\t\t\tbreak;\n\t\tans = false;\n\t\tmemset(field,-1,sizeof(field));\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 0){\n\t\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcolor = field[sy][sx];\n\t\tDFS(sx,sy);\n\t\tif(ans)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <functional> //sort(A,A.end(),greater<int>());???????????????\n#include <queue>\n#include <stack>\n#include <vector>\n\n#define INF 10 << 10\n#define MP make_pair\n\nint map[124][124];\nbool map_flg[124][124];\nint x_move[] = { 0,0,1,-1 };\nint y_move[] = { -1,1,0,0 };\n\nint main() {\n\tint w, h;\n\n\twhile (cin >> w >> h && w != 0 && h != 0) {\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(map_flg, true, sizeof(map_flg));\n\t\tint xs, ys;\n\t\tint xg, yg;\n\t\tint n;\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint x_, y_;\n\t\t\tif (d == 0) {\n\t\t\t\tx_ = 4;\n\t\t\t\ty_ = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_ = 2;\n\t\t\t\ty_ = 4;\n\t\t\t}\n\t\t\tfor (int j = y; j < y + y_; ++j) {\n\t\t\t\tfor (int j2 = x; j2 < x + x_; ++j2) {\n\t\t\t\t\tmap[j][j2] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (map[ys][xs] != map[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstack<pair<int, int> > st;\n\t\tst.push(MP(xs, ys));\n\t\tint m_c = map[ys][xs];\n\t\tbool flg = false;\n\t\twhile (!st.empty()) {\n\t\t\tint x = st.top().first, y = st.top().second;\n\t\t\tst.pop();\n\t\t\tmap_flg[y][x] = false;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint x_ = x + x_move[i], y_ = y + y_move[i];\n\t\t\t\tif (map[y_][x_] == m_c && map_flg[y_][x_]) {\n\t\t\t\t\tif (y_ == yg && x_ == xg) {\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tst.push(MP(x_, y_));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flg) { break; }\n\t\t}\n\n\t\tif (flg) { cout << \"OK\" << endl; }\n\t\telse { cout << \"NG\" << endl; }\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint meiro[110][110];\nint cc;\nint w,h;\nint xx[]={1,-1,0,0};\nint yy[]={0,0,1,-1};\n\nvoid dfs(int x,int y){\n\tmeiro[y][x]=-1;\n\tint i;\n\tfor(i=0;i<4;i++){\n\t\tif(x+xx[i]<0||w<=x+xx[i]||y+yy[i]<0||h<=y+yy[i])continue;\n\t\tif(meiro[y+yy[i]][x+xx[i]]!=cc)continue;\n\t\tdfs(x+xx[i],y+yy[i]);\n\t}\n}\n\nint main() {\n\tint xs,ys,xg,yg,n,c,d,x,y;\n\twhile(w=in(),h=in()){\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\txs--;ys--;xg--;yg--;\n\t\tint i;\n\t\tmemset(meiro,0,sizeof(meiro));\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;y--;\n//cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\tif(d==0){\n\t\t\t\tmeiro[y][x]=meiro[y][x+1]=meiro[y][x+2]=meiro[y][x+3]=meiro[y+1][x]=meiro[y+1][x+1]=meiro[y+1][x+2]=meiro[y+1][x+3]=c;\n\t\t\t}else{\n\t\t\t\tmeiro[y][x]=meiro[y][x+1]=meiro[y+1][x]=meiro[y+1][x+1]=meiro[y+2][x]=meiro[y+2][x+1]=meiro[y+3][x]=meiro[y+3][x+1]=c;\n\t\t\t}\n\t\t}\n\t\tif(meiro[ys][xs]==0){\n\t\t\tcout<<\"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tcc=meiro[ys][xs];\n//cout<<\"hoge\\n\";\n\t\tdfs(xs,ys);\n//cout<<\"piyo\\n\";\n\t\tif(meiro[yg][xg]==-1)cout<<\"OK\\n\";\n\t\telse cout<<\"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nint map[size_max][size_max];\n\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\n\nvoid chek(int w, int h)\n{\n\tint i, j;\n\tfor (i = 0; i <= h + 1; i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue<PR> QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t\t//chek(w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tnow = make_pair(ys, xs);\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] != -1)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = make_pair(now.Y + my[i], now.X + mx[i]);\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c,d,x,y;\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(x == xs &&y == ys){\n        cbase = c;\n      }\n\n      if(d == 0 && c == cbase){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n      if(d==1 && c==cbase){\n        for(int j = x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans == 1){\n      cout << \"OK\" << endl;\n    }\n    if(ans != 1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n \nusing namespace std;\n \n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n \ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n \nbool solve(vvi& field,int x,int y,int xg,int yg,int c)\n{\n    if(field[y][x]==0)\n        return false;\n    if(field[y][x]!=c)\n        return false;\n    if(x==xg && y==yg)\n        return true;\n    field[y][x]=-1;\n    bool res=0;\n    res|=solve(field,x-1,y,xg,yg,c);\n    res|=solve(field,x+1,y,xg,yg,c);\n    res|=solve(field,x,y-1,xg,yg,c);\n    res|=solve(field,x,y+1,xg,yg,c);\n    return res;\n}\n \nint main()\n{\n    for(int w,h;cin>>w>>h,w|h;){\n        int xs,ys,xg,yg,n; cin>>xs>>ys>>xg>>yg>>n;\n        vvi field(110,vi(110));\n        rep(k,n){\n            int c,d,x,y; cin>>c>>d>>x>>y;\n            if(d)\n                rep(i,4) rep(j,2)\n                    field[y+i][x+j]=c;\n            else\n                rep(i,2) rep(j,4)\n                    field[y+i][x+j]=c;\n        }\n        cout<<(solve(field,xs,ys,xg,yg,field[ys][xs])?\"OK\":\"NG\")<<endl;\n    }\n     \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<functional>\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint c,d,x,y;\nint map[101][101];\nint flg=0,temp;\nvoid func(int ,int);\nusing namespace std;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0){\n\t\t\tbreak;\n\t\t}\n\t\tint i,j,k;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(k=0;k<=1;k++){\n\t\t\t\t\tfor(j=0;j<=3;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\t\tfor(j=0;j<=1;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(j=1;j<=10;j++){\n\t\t\t\tfor(k=1;k<=10;k++){\n\t\t\t\t\tprintf(\"%d \",map[j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\t\tflg=0;\n\t\tif(map[ys][xs]==map[yg][xg] && map[ys][xs]!=0){\n\t\t\ttemp=map[ys][xs];\n\t\t\tmap[ys][xs]=0;\n\t\t\tfunc(ys,xs);\n\t\t}/*\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(flg==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\nvoid func(int yy,int xx){\n\tint dy[4]={0,1,0,-1},dx[4]={1,0,-1,0};\n\tint i;\n\tif(flg==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tyy=yy+dy[i];\n\t\t\txx=xx+dx[i];\n\t\t\tif(yy<=h && yy>=1 && xx<=w && xx>=1 && map[xx][yy]==temp){\n\t\t\t\tmap[yy][xx]=0;\n\t\t\t\tif(xg==xx && yg==yy){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfunc(yy,xx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint w,h,f[100][100];\nbool flag,used[100][100];\nint xs,ys,xg,yg;\nint color;\n\nvoid dfs(int y,int x)\n{\n\tif(y == yg && x == xg)\n\t{\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\trep(i,4)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && !used[ny][nx])\n\t\t{\n\t\t\tif(f[ny][nx] == color)\n\t\t\t{\n\t\t\t\tused[ny][nx] = true;\n\t\t\t\tdfs(ny,nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint n;\n\n\twhile(cin >> w >> h)\n\t{\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tcin >> n;\n\n\t\txs--;\n\t\tys--;\n\t\txg--;\n\t\tyg--;\n\n\t\tmemset(f,0,sizeof(f));\n\t\trep(i,100) rep(j,100) used[i][j] = false;\n\t\tflag = false;\n\t\trep(i,n)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\trep(j,4) f[y][x+j] = c;\n\t\t\t\trep(j,4) f[y+1][x+j] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\trep(j,4) f[y+j][x] = c;\n\t\t\t\trep(j,4) f[y+j][x+1] = c;\n\t\t\t}\n\t\t}\n\n\t\tcolor = f[ys][xs];\n\t\tdfs(ys,xs);\n\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0) break;\n        int sy,sx,gy,gx;\n        cin >> sx >> sy >> gx >> gy;\n        sx--,sy--,gx--,gy--;\n        int n;\n        cin >> n;\n        vector<vector<int> > color(h,vector<int>(w));\n        for(int block=0;block<n;block++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            x--;y--;\n            // yoko\n            if(d == 0){\n                for(int i=0;i<2;i++){\n                    for(int j=0;j<4;j++){\n                        color[y+i][x+j] = c;\n                    }\n                }\n            }else{\n                for(int i=0;i<4;i++){\n                    for(int j=0;j<2;j++){\n                        color[y+i][x+j] = c;\n                    }\n                }\n            }\n        }\n        // for(int i=0;i<h;i++){\n        //     for(int j=0;j<w;j++){\n        //         cerr << color[i][j];\n        //     }\n        //     cerr << endl;\n        // }\n        int c = color[sy][sx];\n        vector<vector<char> > visited(h,vector<char>(w));\n        queue<pair<int,int> > Q;\n        Q.push(make_pair(sy,sx));\n        while(not Q.empty()){\n            int y = Q.front().first;\n            int x = Q.front().second;\n            Q.pop();\n\n            if(y >= h or y < 0 or x >= w or x < 0) continue;\n            if(color[y][x] != c) continue;\n            if(visited[y][x]) continue;\n            visited[y][x] = true;\n            for(int i=0;i<4;i++){\n                Q.push(make_pair(y+dy[i],x+dx[i]));\n            }\n        }\n        if(visited[gy][gx]){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       F[0][-1] = 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint dx[] = {0, 1, 0, 1}, dy[] = {0, 0, 1, 1};\nstruct P{ int x, y; };\nint main()\n{\n\tint w, h;\n\twhile(cin >> w >> h && (w || h))\n\t{\n\t\tvector<vint> field(w, vint(h, 0));\n\t\tP s, g;\n\t\tcin >> s.x >> s.y >> g.x >> g.y;\n\t\ts.x--, s.y--, g.x--, g.y--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i, n)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i]][y + dy[i]] = c;\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i] + 2 * !d][y + dy[i] + 2 * d] = c;\n\t\t}\n\n\t\t\n\t\tint c = field[s.x][s.y];\n\t\tif(!c || !field[g.x][g.y] || field[s.x][s.y] != field[g.x][g.y])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<P> que;\n\t\tfor(que.push(s); !que.empty(); que.pop())\n\t\t{\n\t\t\tP p = que.front();\n\n\t\t\tint ddx[] = {1, 1, 0, 0}, ddy[] = {0, 0, 1, 1};\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tint nx = p.x + ddx[i], ny = p.y + ddy[i];\n\t\t\t\t\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[nx][ny] == c)\n\t\t\t\t{\n\t\t\t\t\tfield[nx][ny] = -1;\n\t\t\t\t\tP next; next.x = nx, next.y = ny;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (field[g.x][g.y] == -1? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xx[4] = {0, 1, 0, -1};\nint yy[4] = {1, 0, -1, 0};\nint block[101][101];\nint already[101][101];\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\nint dfs(int nowx, int nowy);\n\nint main(){\n  while(1){\n    memset(block, 0, sizeof(block));\n    memset(already, 0, sizeof(already));\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      int high, wide;\n      if(d){\n\thigh = 4; wide = 2;\n      }\n      else{\n\thigh = 2; wide = 4;\n      }\n      for(int j = 0; j < high; j++){\n\tfor(int k = 0; k < wide; k++){\n\t  block[y+j][x+k] = c;\n\t}\n      }\n    }\n    int ans = dfs(xs, ys);\n    if(ans) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}\n\nint dfs(int nowx, int nowy){\n  already[nowy][nowx] = 1;\n  if(nowx == xg && nowy == yg) return 1;\n  for(int i = 0; i < 4; i++){\n    int nextx = nowx + xx[i];\n    int nexty = nowy + yy[i];\n    if(0 < nextx && 0 < nexty && nextx <= w && nexty <= h && already[nexty][nextx] != 1 && block[nexty][nextx] == block[ys][xs]) return dfs(nextx, nexty);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return 0;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n\n}\n\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[110][110];\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight - 1;\n    board_hight  = Board_Hight  - 1;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main(){\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n    \n    while(cin >> w >> h){\n        if(w == 0 && h == 0) break;\n        cin >> sx >> sy >> gx >> gy;\n        Solve s(w, h, sx, sy, gx, gy);\n        \n        cin >> n;\n        \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n            s.set_Block(c, d, x, y);\n        }\n        \n        if(s.check() == true){\n            cout << \"OK\\n\";\n        }else{\n            cout << \"NG\\n\";\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint map[110][110];\nint com[110][110];\nint lx,ly,sx,sy,gx,gy;\nint py[4]={1,0,-1,0};\nint px[4]={0,1,0,-1};\nint fl;\nint mei(int zx,int zy ,int cei[][110])\n{\n\tint i;\n\tif(fl) return 0;\n\tif(zx==gx && zy==gy)\n\t{\n\t\tfl=1;\n\t\treturn 0;\n\t}\n\tcei[zy][zx]=1;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(cei[zy+py[i]][zx+px[i]]==0 && map[sy][sx]==map[zy+py[i]][zx+px[i]])\n\t\t{\n\t\t\tmei(zx+px[i],zy+py[i],cei);\n\t\t\t\n\t\t}\n\t}\n\tcei[zy][zx]=0;\n\treturn 0;\n}\nint main()\n{\n\tint n,col,muk,vx,vy;\n\tint i,j,t;\n\twhile(cin >> lx >> ly, lx!=0 && ly!=0)\n\t{\n\t\tfl=0;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(com,0,sizeof(com));\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> col >> muk >> vx >> vy;\n\t\t\tif(muk==0)\n\t\t\t{\n\t\t\t\tfor(j=vy;j<2+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<4+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=vy;j<4+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<2+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmei(sx,sy,com);\n\t\tif(fl) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tboard[i][j]=0;\n\tcheak[i][j]=0;\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs-1,ys-1)==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==board[ys-1][xs-1] && cheak[yn][xn]==0){\n      if(dfs(xn,yn)==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint a,b,c,d;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y])return 0;\n\tM[x][y]=9;\n\twalk(x+1,y,color);\n\twalk(x-1,y,color);\n\twalk(x,y+1,color);\n\twalk(x,y-1,color);\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>a>>b>>c>>d;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalk(a,b,M[a][b]);\n\t\tif(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n// #define int long long\n#define pb push_back\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vii;\n \ntemplate <class X> void print(X Target){ cout << Target << '\\n'; }\n\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint w, h;\nint xs, ys, xg, yg;\nint mp[128][128];\nbool check[128][128];\n\nvoid dfs(int y, int x, int color)\n{\n  if (x < 1 || x > w || y < 1 || y > h) return;\n  if (check[y][x]) return;\n  check[y][x] = true;\n  for (int i = 0; i < 4; i++){\n    if (mp[y + dy[i]][x + dx[i]] == color){\n      dfs(y + dy[i], x + dx[i], color);\n    }\n  }\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  int n;\n\n  while (cin >> w >> h, w || h){\n    memset(field, false, sizeof(check));\n    memset(mp, 0, sizeof(mp));\n    cin >> xs >> ys >> xg >> yg >> n;\n    for (int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      if (d){\n        for (int j = 0; j < 4; j++){\n          for (int k = 0; k < 2; k++){\n            mp[y + j][x + k] = c;\n          }\n        }\n      }\n      else {\n        for (int j = 0; j < 2; j++){\n          for (int k = 0; k < 4; k++){\n            mp[y + j][x + k] = c;\n          }\n        }\n      }\n    }\n    dfs(ys, xs, mp[ys][xs]);\n    (check[yg][xg]) ? print(\"OK\") : print(\"NG\");\n  }\n\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a=0;\nint F[102][102];\nvoid DFS(int Xs,int Ys,int c,int Xg,int Yg){\n  if(F[Xs][Ys]!=c){\n    return;\n  }else if(Xs==Xg&&Ys==Yg){\n    a=1;\n    return;\n  }\n F[Xs][Ys]=0;\n DFS(Xs-1,Ys,c,Xg,Yg);\n DFS(Xs,Ys-1,c,Xg,Yg);\n DFS(Xs+1,Ys,c,Xg,Yg);\n DFS(Xs,Ys+1,c,Xg,Yg);\n}\n\nint main(){\n  while(1){\n   int w,h,xs,ys,xg,yg,n,C;\n   cin>>w>>h;\n   if(w==0&&h==0){\n     break;\n   }\n   cin>>xs>>ys>>xg>>yg>>n;\n   int c[n];\n   int d[n];\n   int x[n];\n   int y[n];\n   for(int i=0;i<n;i++){\n     cin>>c[i]>>d[i]>>x[i]>>y[i];\n     if(xs==x[i]&&ys==y[i]){\n       C=c[i];\n     }\n      for(int j=0;j<4;j++){\n        for(int k=0;k<2;k++){\n          if(d[i]==0){\n           F[x[i+j]][y[i+k]]=c[i];\n         }else{\n           F[x[i+k]][y[i+j]]=c[i];\n         }\n       }\n     }\n    }\n    DFS(xs,ys,C,xg,yg);\n    if(a==1){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dy[i];\n      int ny=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint block[100][100];\nint visited[100][100];\nbool memo[100][100];\nint w, h, xs, ys, xg, yg, n;\nint d[2][4]={{0,0,-1,1},{-1,1,0,0}};\nbool dfs(int x, int y) {\n    if (visited[y][x]) return memo[y][x];\n    if (x==xg-1&&y==yg-1) return true;\n    visited[y][x]=1;\n    for (int i=0; i<4; i++) {\n        int nx=x+d[0][i], ny=y+d[1][i];\n        if (nx>=0&&nx<w&&ny>=0&&ny<h&&block[y][x]==block[ny][nx]) {\n            if (dfs(nx,ny)) {\n                memo[y][x]=true;\n                return true;\n            }\n        }\n    }\n    memo[y][x]=false;\n    return false;\n}\nint main() {\n    while (scanf(\"%d%d\",&w,&h)) {\n        if (!w&&!h) break;\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            visited[i][j]=0;\n            block[i][j]=0;\n        }\n        scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n        for (int i=0; i<n; i++) {\n            int c, d, x, y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            if (d) {\n                for (int j=y-1; j<y+3; j++) {\n                    for (int k=x-1; k<x+1; k++) {\n                        block[j][k]=c;\n                    }\n                }\n            } else {\n                for (int j=x-1; j<x+3; j++) {\n                    for (int k=y-1; k<y+1; k++) {\n                        block[k][j]=c;\n                    }\n                }\n            }\n        }\n        /*for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            printf(\"%d%c\",block[i][j],j==w-1?'\\n':' ');\n        }*/\n        if (dfs(xs,ys)) puts(\"OK\");\n        else puts(\"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h;\nint sx, sy;\nint gx, gy;\nint n;\nint field[120][120];\n\nvoid PrintField() {\n  REP(y, h + 2) {\n    REP(x, w + 2) {\n      printf(\"%d\", field[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(field, 0);\n    scanf(\"%d %d\", &sx, &sy);\n    scanf(\"%d %d\", &gx, &gy);\n    scanf(\"%d\", &n);\n    REP(i, n) {\n      int c, d, sx, sy;\n      scanf(\"%d %d %d %d\", &c, &d, &sx, &sy);\n      int ex = sx + 2;\n      int ey = sy + 2;\n      if (d == 0) { ex += 2; }\n      if (d == 1) { ey += 2; }\n      FOR(y, sy, ey) {\n        FOR(x, sx, ex) {\n          field[y][x] = c;\n        }\n      }\n    }\n    int sc = field[sy][sx];\n    queue<int> que;\n    que.push(sy * w + sx);\n    while (!que.empty()) {\n      int x = que.front() % w;\n      int y = que.front() / w;\n      que.pop();\n      if (x == gx && y == gy) {\n        puts(\"OK\");\n        goto next;\n      }\n      if (sc == 0) { break; }\n      REP(dir, 4) {\n        const int dx[4] = { 1, 0, -1, 0 };\n        const int dy[4] = { 0, 1, 0, -1 };\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n        if (field[ny][nx] != sc) { continue; }\n        field[ny][nx] = 9;\n        que.push(ny * w + nx);\n      }\n    }\n    puts(\"NG\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n\n\n\n      for (int b = 1; b <= h; b++)\n\t{\n\t  for (int a = 1; a <= w; a++)\n\t    {\n\t      F[b][a] = 0;\n\t    }\n\t}\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n\n      for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      //if(c == 0)\n        //c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n\n\n\n//マップの大きさの最大値\n#define MAP_MAX\t\t100\n//最初の歩数\n#define START\t\t1000000\n//マップの配列\nint wh_map[MAP_MAX + 1][MAP_MAX + 1];\n//縦・横に進むための配列\nint h_tate[4] = {1 , -1 , 0 , 0};\nint h_yoko[4] = {0 , 0 , 1 , -1};\n\n\n\n//----- blockの情報を持つ構造体 -----//\ntypedef struct block\n{\n\tint iro;\n\tint muki;\n\tint x;\n\tint y;\n}S_block;\n\n\n\n//----- 答えを返す関数 -----//\nbool f_ans(int , int  , int , int , int , int);\n\n\n//----- ブロックの入力は長くなるので関数で -----//\nint f_block_syokika(S_block* , int , int , int);\n\n\n\n//----- マップを-1で初期化する変数 -----//\nvoid f_mapsyokika(void);\n\n\n\n//----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(メモリ節約のために構造体は参照で受ける) -----//\nvoid f_okmap(S_block[] , int , int , int , int);\n\n\n\n\n//*****----- main -----*****//\n\nint main(void)\n{\n\t//ボードの大きさ\n\tint tate = 0 , yoko = 0;\n\t//スタートの座標\n\tint startx = 0 , starty = 0;\n\t//ゴール座標\n\tint goalx = 0 , goaly = 0;\n\t//ブロックの個数\n\tint n = 0;\n\t//スタートと同じ色\n\tint startcolor = 0;\n\n\twhile (1)\n\t{\n\t\t//それぞれ入力\n\t\tscanf(\"%d%d\" , &tate , &yoko);\n\t\tif (tate == 0 && yoko == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t//スタート・ゴール座標\n\t\tscanf(\"%d%d\" , &startx , &starty);\n\t\tscanf(\"%d%d\" , &goalx , &goaly);\n\t\t//ブロックの個数\n\t\tscanf(\"%d\" , &n);\n\n\t\t//ブロックの分だけ領域を確保する\n\t\tS_block *s_block = new S_block[n];\n\n\t\t//関数で初期化\n\t\tstartcolor = f_block_syokika(s_block , n , starty , startx);\n\t\t//次にマップを初期化\n\t\tf_mapsyokika();\n\n\t\t//mapにSTARTを振り分ける\n\t\tf_okmap(s_block , starty , startx , startcolor , n);\n\n\t\tif (f_ans(starty , startx , goaly , goalx , tate , yoko) == true)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\n\t\t//一度メモリを解放\n\t\tdelete []s_block;\n\t}\n}\n\n\n\n\n//*****----- ブロックの情報を入力する関数 -----*****//\n\nint f_block_syokika(S_block *s_data , int n , int starty , int startx)\n{\n\t//スタートの色を取り出す変数\n\tint startcolor = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\" , &s_data[i].iro , &s_data[i].muki , &s_data[i].x , &s_data[i].y);\n\n\t\t//色を取り出す(横向きなら)\n\t\tif (s_data[i].muki == 1)\n\t\t{\n\t\t\t//横向きに設置したと仮定し、その中にスタート座標が含まれているかどうか調べる\n\t\t\tif ((starty <= s_data[i].y && starty >= s_data[i].y - 1) && (startx >= s_data[i].x && startx <= s_data[i].x + 3))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t\t//縦向きだった\n\t\telse\n\t\t{\n\t\t\t//縦向きに設置したと仮定し、その中にスタート座標が含まれているか調べる\n\t\t\tif ((starty <= s_data[i].y && starty >= s_data[i].y - 3) && (startx >= s_data[i].x && s_data[i].x + 1))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t}\n\n\t//初期座標の値を返す\n\treturn startcolor;\n}\n\n\n\n//*****----- 答えを求める関数 -----*****//\n\nbool f_ans(int starty , int startx , int goaly , int goalx , int tateindex , int yokoindex)\n{\n\t//幅優先探索で使うｙとｘ\n\tstd::queue<int> x;\n\tstd::queue<int> y;\n\n\t//最初の座標をキューに追加\n\ty.push(starty);\n\tx.push(startx);\n\n\t/*\n\tfor (int i = 1; i <= tateindex; i++)\n\t{\n\t\tfor (int j = 1; j <= yokoindex; j++)\n\t\t{\n\t\t\tif (wh_map[i][j] == START)\n\t\t\t{\n\t\t\t\tprintf(\"■\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"□\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\n\t//キューがなくなるまで\n\twhile (!x.empty())\n\t{\n\t\t//ｙ座標とｘ座標を取り出す\n\t\tint yy = y.front();\n\t\tint xx = x.front();\n\t\t//デキュー\n\t\ty.pop();\n\t\tx.pop();\n\n\t\t//ゴールにたどり着いた\n\t\tif (yy == goaly && xx == goalx)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t//今いる座標の値を吹っ飛ばす\n\t\twh_map[yy][xx] = -1;\n\n\t\t//四方に散れるか調べる\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t//次に進む座標を取得\n\t\t\tint nexty = yy + h_tate[i];\n\t\t\tint nextx = xx + h_yoko[i];\n\n\t\t\t//まずは範囲内かどうか調べる\n\t\t\tif (nexty >= 1 && nexty <= tateindex && nextx >= 1 && nextx <= yokoindex)\n\t\t\t{\n\t\t\t\t//そこが通れる場所且つブロックの色が同じとき\n\t\t\t\tif (wh_map[nexty][nextx] == START)\n\t\t\t\t{\n\t\t\t\t\t//ｙとｘをそれぞれ追加\n\t\t\t\t\ty.push(nexty);\n\t\t\t\t\tx.push(nextx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\n//*****----- マップを初期化する関数 -----*****//\n\nvoid f_mapsyokika(void)\n{\n\tfor (int i = 1; i < MAP_MAX + 1; i++)\n\t{\n\t\tfor (int j = 1; j < MAP_MAX + 1; j++)\n\t\t{\n\t\t\twh_map[i][j] = -1;\n\t\t}\n\t}\n}\n\n\n\n//*****----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(構造体は配列) -----*****//\n\nvoid f_okmap(S_block s_data[] , int starty , int startx , int startcolor , int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s_data[i].iro == startcolor)\n\t\t{\n\t\t\t//縦か横かによって挙動が変わる\n\t\t\tif (s_data[i].muki == 0)\n\t\t\t{\n\t\t\t\t//2 * 4マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0;k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + j][s_data[i].x + k] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//横だった\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 4 * 2マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + k][s_data[i].x + j] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] ,int map[][ 110 ] )\n{\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\tcame[ y ][ x ] = false ;\n\tmap[ y ][ x ] = -1 ;\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] != false )\n\t\t\treturn ok_or_ng( xx ,yy ,came ,map ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tif( map[ gy ][ gx ] == map[ sy ][ sx ] )\n\t\t\tok_or_ng( sx ,sy ,came ,map ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t\telse\n\t\t\tprintf( \"NG\\n\" ) ;\n\t\t/*if( came[ gy ][ gx ] ){\n\t\tfor( int i = 0 ; i <= h + 1 ; i++ )\n\t\t{\n\t\t\tfor( int j = 0 ; j <= w + 1 ; j++ )\n\t\t\t\tcout << map[ i ][ j ] ;\n\t\t\tcout << endl ;\n\t\t}}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint W, H, sx, sy, gx, gy, N, c, d, x, y, r[111][111], vis[111][111];\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint main() {\n\twhile(cin >> W >> H, W | H) {\n\t\tcin >> sx >> sy >> gx >> gy; sx--, sy--, gx--, gy--;\n\t\tmemset(r, 0, sizeof(r));\n\t\tcin >> N;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\t\t\tint zx = (d ? 2 : 4), zy = (d ? 4 : 2);\n\t\t\tfor(int j = 0; j < zy; j++) {\n\t\t\t\tfor(int k = 0; k < zx; k++) {\n\t\t\t\t\tr[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(vis, 0, sizeof(vis)); vis[sy][sx] = 1;\n\t\tqueue<pair<int, int> > que; que.push(make_pair(sx, sy));\n\t\twhile(!que.empty()) {\n\t\t\tpair<int, int> v = que.front(); que.pop();\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint tx = v.first + dx[i], ty = v.second + dy[i];\n\t\t\t\tif(0 <= tx && tx < W && 0 <= ty && ty < H && r[ty][tx] == r[v.second][v.first]) {\n\t\t\t\t\tvis[ty][tx] = 1;\n\t\t\t\t\tque.push(make_pair(ty, tx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (vis[gy][gx] ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[101][102];\n\nvoid DFS(int Y, int X, int c) {\n        //cout << Y << \" \" << X << endl;\n        if (F[Y][X] != c || F[Y][X] == 0)\n                return;\n        F[Y][X] = 10;\n        DFS(Y - 1, X, c);//???\n                                                 //DFS(Y - 1, X+1, A_ito);//??????\n        DFS(Y, X + 1, c);//???\n                                                 //DFS(Y + 1, X+1, A_ito);//??????\n        DFS(Y + 1, X, c);//???\n                                                 //DFS(Y + 1, X-1, A_ito);//??????\n        DFS(Y, X - 1, c);//???\n                                                 //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n        int xs, ys, xg, yg, n;\n        int c, d, x, y;\n        int W = 0, H = 0;\n\n        while (!(W == H == 0)) {\n                cin >> W >> H;\n                cin >> xs >> ys >> xg >> yg >> n;\n                for (int i = 1;i <= n;i++) {\n                        cin >> c >> d >> x >> y;\n                        if (d == 0) {\n                                F[x][y] = c;\n                                F[x][y + 1] = c;\n                                F[x + 1][y] = c;\n                                F[x + 1][y + 1] = c;\n                                F[x + 2][y] = c;\n                                F[x + 2][y + 1] = c;\n                                F[x + 3][y] = c;\n                                F[x + 3][y + 1] = c;\n                        }\n                        if (d == 1) {\n                                F[x][y] = c;\n                                F[x + 1][y] = c;\n                                F[x][y + 1] = c;\n                                F[x + 1][y + 1] = c;\n                                F[x][y + 2] = c;\n                                F[x + 1][y + 2] = c;\n                                F[x][y + 3] = c;\n                                F[x + 1][y + 3] = c;\n                        }\n                }\n                DFS(ys, xs, F[ys][xs]);\n\n                if (F[yg][xg] == 10) {\n                        cout << \"OK\" << endl;\n                }\n                else { cout << \"NG\"<<endl; }\n                for (int i = 0;i < H;i++) {\n                        for (int j = 0;j < W;j++) {\n                                F[i][j] = 0;\n                        }\n                }\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\nbool check(short maze[MAX][MAX])\n{\n\t\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n/*\n\t\trep(i,y){\n\t\t\trep(j,x)\n\t\t\t\tprintf(\"%2d\", maze[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\n*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==1 &&y[i]==1){\n        cbase = c[i];\n      }\n    }\n\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,sx,sy,gx,gy,n,c,d,x,y,sc;\nint fld[101][101];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||fx<1||fy<1||fx>w||fy>h)return;\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>sx>>sy>>gx>>gy>>n;\n        fill(fld[0],fld[0]+101*101,-1);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[sy][sx];\n        dfs(sx,sy);\n        if(fld[gy][gx]==0)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[w][h] = 0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==1 &&y[i]==1){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0,w,h;\nint block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(R==map[gb][ga]){\n\t\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nint block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint color,gx,gy;\nbool maze;\n\nvoid DFS1(int Y,int X){\n    if(F[Y][X]!=color)return;\n    if(Y==gy&&X==gx)maze=true;\n    \n    F[Y][X]=0;\n    \n    DFS1(Y-1,X  );\n    DFS1(Y  ,X-1);\n    DFS1(Y  ,X+1);\n    DFS1(Y+1,X  );\n}\n\nint main(){\n    int N,M,sx,sy,n;\n    cin >> N >> M;\n    while(N!=0&&M!=0){\n        cin >> sx >> sy >> gx >> gy >> n;\n        int c,d,nx,ny;\n        for(int i=0;i<n;i++){\n            cin >> c >> d >> nx >> ny;\n            for(int y=ny;y<ny+2*(1+d);y++){\n                for(int x=nx;x<nx+2*(2-d);x++){\n                    F[y][x] = c;\n                }\n            }\n        }\n\n        color = F[sy][sx];\n        maze = false;\n        DFS1(sy,sx);\n        cout << (maze?\"OK\":\"NG\") << endl;\n        cin >> N >> M;\n    }\n    return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = 0;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy,d[100][100],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<=y+2+di*2;j++)for(int k=x;k<=x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tbfs();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101];\nint w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy))r=1;\n\tif(x>0&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>0&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\td?bw=2,bh=4:bh=2,bw=4;\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])dfs(sx,sy,m[sx][sy]),m[sx][sy] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n&#160;\nusing namespace std;\n&#160;\nint map[101][101];\nint xg, yg;\nint w, h;\nint col;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nbool flag;\n&#160;\nvoid dfs(int x, int y)\n{\n&#160;&#160;&#160;&#160;map[y][x] = 0;\n&#160;\n&#160;&#160;&#160;&#160;if (x == xg && y == yg) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag = true;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return ;\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;for (int i = 0; i < 4; i++) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int nx = x + dx[i];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int ny = y + dy[i];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (map[ny][nx] == col)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dfs(nx, ny);\n&#160;&#160;&#160;&#160;}\n}\n&#160;\nvoid setblock(int c, int d, int bx, int by)\n{\n&#160;&#160;&#160;&#160;int wlim = 4, hlim = 2;\n&#160;\n&#160;&#160;&#160;&#160;if (d == 1) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;wlim = 2;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;hlim = 4;\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;for (int y = 0; y < hlim; y++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int x = 0; x < wlim; x++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;map[by + y][bx + x] = c;\n}\n&#160;\n&#160;\nint main()\n{\n&#160;&#160;&#160;&#160;while (cin >> w >> h, w || h) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int xs, ys;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int n;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int y = 0; y < h; y++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int x = 0; x < w; x++)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;map[y][x] = 0;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin >> xs >> ys >> xg >> yg >> n;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xs--, ys--, xg--, yg--;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i < n; i++) {\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int c, d, x, y;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin >> c >> d >> x >> y;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x--, y--;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; \n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;setblock(c, d, x, y);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;col = map[ys][xs];\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag = false;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (col)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;dfs(xs, ys);\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (flag)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << \"OK\" << endl;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << \"NG\" << endl;\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint gx,gy,m[128][128];\nint F(int x,int y,int c)\n{\n\tif(x==gx&&y==gy)\n\t\treturn 1;\n\tif(m[y][x]!=c)\n\t\treturn 0;\n\tm[y][x]=-c;\n\tint d[]={0,1,0,-1,0},i,f;\n\tfor(i=f=0;i<4;++i)\n\t\tf=f||F(x+d[i],y+d[i+1],c);\n\treturn f;\n}\nint main()\n{\n\tint w,h,sx,sy,x,y,n,c,d,i,j;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tmemset(m,0,sizeof(m));\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<2;++i)for(j=0;j<4;++j)\n\t\t\t\tif(d) m[y+j][x+i]=c;\n\t\t\t\telse m[y+i][x+j]=c;\n\t\t}\n\t\tif(1<=sx&&sx<=w&&1<=sy&&sy<=h&&m[sy][sx]&&F(sx,sy,m[sy][sx]))puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\n\nint DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='w'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_Y(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='y'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_G(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='g'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\nint DFS_B(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='b'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n  int DFS_R(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='r'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n\nint main(){\n  int c[5];\n  int d[1];\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  int x[n];\n  int y[n];\n  cin>>w>>h;\n  while(w!=0){\n    int a=0;\n    int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n        int a=0;\n        int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      cnt=DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      cnt=DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      cnt=DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      cnt=DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      cnt=DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint board[100][100],w,h,xg,yg;\nbool f(int y,int x){\n\tboard[y][x] = -1;\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\tif(y == yg - 1 && x == xg -1) return true;\n\tfor(i = 0;i < 4;i++){\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\t\t\tif(board[y+dy[i]][x+dx[i]] == 2){\n\t\t\t\tif(f(y+dy[i],x+dx[i])) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint xs,ys,n,i,c,d,x,y,j,k;\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx -= 1;\n\t\t\ty -= 1;\n\t\t\tif(d == 0){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(board[ys - 1][xs - 1] == 2){\n\t\t\tif(f(ys - 1,xs -1)) cout << \"OK\" << endl;\n\t\t\telse cout << \"NG\" << endl;\n\t\t}\n\t\tfor(j = 0;j < 100;j++){\n\t\t\tfor(i = 0;i < 100;i++){\n\t\t\t\tboard[j][i] = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint gx,gy,m[128][128];\nint F(int x,int y,int c)\n{\n\tif(x==gx&&y==gy)\n\t\treturn 1;\n\tif(m[y][x]!=c)\n\t\treturn 0;\n\tm[y][x]=-c;\n\tint d[]={0,1,0,-1,0},i,f;\n\tfor(i=f=0;i<4;++i)\n\t\tf=f||F(x+d[i],y+d[i+1],c);\n\treturn f;\n}\nint main()\n{\n\tint w,h,sx,sy,x,y,n,c,d,i,j;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tmemset(m,0,sizeof(m));\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<2;++i)for(j=0;j<4;++j)\n\t\t\t\tif(d) m[y+j][x+i]=c;\n\t\t\t\telse m[y+i][x+j]=c;\n\t\t}\n\t\tif(m[sy][sx]&&F(sx,sy,m[sy][sx]))puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF INT_MAX/3\n#define ALL(a) (a).begin(),(a).end()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\n\nbool u[101][101];\nint board[101][101];\nint gc;\nint h,w,n;\nint xs,ys,xg,yg;\nint dx[] = {-1,0,0,1};\nint dy[] = {0,1,-1,0};\nbool saiki(int x,int y){\n    bool ret = false;\n    if(x==xg&&y==yg) return true;\n    REP(i,4){\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif(1<=nx&&nx<=w&&1<=ny&&ny<=h&&board[ny][nx] == gc&&!u[ny][nx]){\n\t    u[ny][nx] = true;\n\t    ret = ret || saiki(nx,ny);\n\t}\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n\tmemset(board,0,sizeof(board));\n\tmemset(u,false,sizeof(u));\n\tcin >> w >> h;\n\tif(w == 0 && h == 0) break;\n\tcin >> xs >> ys >> xg >> yg;\n\tcin >> n;\n\tREP(i,n){\n\t    int c,d,x,y;\n\t    cin >> c >> d >> x >> y;\n\t    if(d == 1){\n\t\tREP(i,2){\n\t\t    REP(j,4){\n\t\t\tboard[y+j][x+i] = c;\n\t\t    }\n\t\t}\n\t    }else{\n\t\tREP(i,4){\n\t\t    REP(j,2){\n\t\t\tboard[y+j][x+i] = c;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tgc = board[ys][xs];\n\tif(gc != board[yg][xg]) cout << \"NG\" << endl;\n\telse{\n\t    if(saiki(xs,ys)){\n\t\tcout << \"OK\" << endl;\n\t    }else cout << \"NG\" << endl;\n\t}\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a[200][200],color;\n\nvoid dfs(int x,int y){\n  \n  if(x < 102 && y < 102){\n  \n    a[y][x] = 9;\n    \n    if(a[y+1][x] == color){\n      dfs(x,y+1);\n    }\n    if(a[y][x+1] == color){\n      dfs(x+1,y);\n    }\n    if(a[y-1][x] == color){\n      dfs(x,y-1);\n    } \n    if(a[y][x-1] == color){\n      dfs(x-1,y);\n    }\n  \n  }\n\n} \n\nint main(){\n\n  int xs,ys,xg,yg,n,c,d,x,y,w,h;\n\n  while(1){\n  \n    cin >>w>>h;\n    \n    if(w == 0 && h == 0)break;\n\n    for(int i = 0 ; i < 102 ; i++){\n      for(int j = 0 ; j < 102 ; j++){\n\ta[i][j]=0;\n      }\n    }\n\n    cin >>xs>>ys;\n    cin >>xg>>yg;\n\n    cin >>n;\n\n    for(int i = 0 ; i < n ; i++){\n      \n      cin >> c >> d >> x >> y;\n      \n      if( d == 0 ){\n\tfor(int i = 0 ; i < 2 ; i++){\n\t  for(int j = 0 ; j < 4 ; j++){\n\t    a[i+y][j+x] = c;\n\t  }\n\t}\n      }else{\n\tfor(int i = 0 ; i < 4 ; i++){\n\t  for(int j = 0 ; j < 2 ; j++){\n\t    a[i+y][j+x] = c;\n\t  }\n\t}\n      }\n    \n    }\n    \n    /*\n      for(int i = 0 ; i < h+2 ; i ++){\n      for(int j = 0 ; j < w+2 ; j++){\n      cout << a[i][j];\n      }\n      cout <<endl;\n      }\n      cout <<endl;\n    */\n    \n    color = a[ys][xs];\n    dfs(xs,ys);\n    \n    /*\n      for(int i = 0 ; i < h+2 ; i ++){\n      for(int j = 0 ; j < w+2 ; j++){\n      cout << a[i][j];\n      }\n      cout <<endl;\n      }\n    */\n    \n    if(a[yg][xg] == 9){\n      cout <<\"OK\"<<endl;\n    }else{\n      cout <<\"NG\"<<endl;\n    }\n    \n  }      \n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a=0;\nint F[102][102];\nvoid DFS(int Xs,int Ys,int c,int Xg,int Yg){\n  if(F[Xs][Ys]!=c){\n    return;\n  }else if(Xs==Xg&&Ys==Yg){\n    a=1;\n    return;\n  }\n F[Xs][Ys]=0;\n DFS(Xs-1,Ys,c,Xg,Yg);\n DFS(Xs,Ys-1,c,Xg,Yg);\n DFS(Xs+1,Ys,c,Xg,Yg);\n DFS(Xs,Ys+1,c,Xg,Yg);\n}\n\nint main(){\n  while(1){\n    a=0;\n   int w,h,xs,ys,xg,yg,n,C;\n   cin>>w>>h;\n   if(w==0&&h==0){\n     break;\n   }\n   cin>>xs>>ys>>xg>>yg>>n;\n   int c[n],d[n],x[n],y[n];\n   for(int i=0;i<n;i++){\n     cin>>c[i]>>d[i]>>x[i]>>y[i];\n     if(xs==x[i]&&ys==y[i]){\n       C=c[i];\n     }\n      for(int j=0;j<4;j++){\n        for(int k=0;k<2;k++){\n          if(d[i]==0){\n           F[x[i]+j][y[i]+k]=c[i];\n         }else{\n           F[x[i]+k][y[i]+j]=c[i];\n         }\n       }\n     }\n    }\n    DFS(xs,ys,C,xg,yg);\n    if(a==1){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, w, h, xs, ys, xg, yg, f[105][105] = { 0 }, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, used[105][105] = { 0 };\nbool flag = 0;\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (xg == nx&&yg == ny) {\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif (used[ny][nx]) continue;\n\t\tif (1 <= nx&&nx <= w && 1 <= ny&&ny <= h&&f[ny][nx]>0) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused[ys][xs] = 1;\n\t\tdfs(ys, xs);\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 100;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\n\nvoid dfs(int x, int y){\n    maze[x][y] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) flag = 1;\n                dfs(nx, ny);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[x-1+dx][y-1+dy] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[x-1+dx][y-1+dy] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[xs][ys]) maze[i][j] = 0;\n\n    //search\n    dfs(xs-1, ys-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[y+1][x+1]=c;\n             F[y+1][x+2]=c;\n             F[y+1][x+3]=c;\n             F[y+1][x+4]=c;  \n             F[y+2][x+1]=c;\n             F[y+2][x+2]=c;\n             F[y+2][x+3]=c;\n             F[y+2][x+4]=c;   \n         }\n         else{\n             F[y+1][x+1]=c;\n             F[y+2][x+1]=c;\n             F[y+3][x+1]=c;\n             F[y+4][x+1]=c;  \n             F[y+1][x+2]=c;\n             F[y+2][x+2]=c;\n             F[y+3][x+2]=c;\n             F[y+4][x+2]=c;   \n         }\n      }\n      if(F[ys+1][xs+1]!=1&&F[ys+1][xs+1]!=2&&F[ys+1][xs+1]!=3&&F[ys+1][xs+1]!=4&&F[ys+1][xs+1]!=5)\n         cout << \"NG\" << endl;\n      else\n         DFS(ys+1,xs+1,F[ys+1][xs+1]);\n      if(F[yg+1][xg+1]==F[ys+1][xs+1])\n         cout << \"OK\" << endl;\n      else\n         cout << \"NG\" << endl;\n      for(int i=1;i<=w;i++)\n         for(int j=1;j<=h;j++)\n            F[i][j]=0;\n      \n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<windows.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k,l,m;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\tint maps=0;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\telse\n\t\t\t\t\t\tmaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\t\n/*\n\t\t\t\tfor(m=0;m<h;m++)\n\t\t\t\t{\n\t\t\t\t\tfor(l=0;l<w;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d \",map[l][m]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%dツ行\\n\",l);\n\t\t\t\t}\n\t\t\t\tgetchar();\n\t\t\t\tsystem(\"cls\");\n*/\n\t\t\t\t\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"migi\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"hidari\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i-1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tmaps--;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign && maps==0)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\n\t\t\t\t\tfor(m=0;m<h;m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(l=0;l<w;l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((map[m][l]==sign && map[m][l+1]==7) || (map[m][l]==sign && map[m-1][l]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ti=m;\n\t\t\t\t\t\t\t\tj=l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\");\n\t\t}\n\t}\n}\n/*\n20 20 \n1 1\n2 7\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nbool ans;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\t\tint cx = p.second, cy = p.first;\n\n\t\tif (y == gy&&x == gx)break;\n\n\t\tREP(i, 4){\n\t\t\tint nx = cx + dx[i], ny = cy + dy[i];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h){\n\t\t\t\tif (table[ny][nx] == table[cy][cx]\n\t\t\t\t\t&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[cy][cx] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tans = 0;\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tdis[sy][sx] = 1;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//REP(i, h){\n\t\t//\tREP(j, w){\n\t\t//\t\tcout << table[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << \"!\" << endl;\n\t\t//solve();\n\t\t//REP(i, h){\n\t\t//\tREP(j, w){\n\t\t//\t\tcout << dis[i][j] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tif (dis[gy][gx] != INF&&table[sy][sx] != 0 && table[gy][gx] != 0)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n\n    canGo[x][y] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_x][next_y]) {\n            bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> h >> w;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w + 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        if (start != goal) {\n            std::cout << \"NG\" << std::endl;\n            break;\n        }\n        for (int i = 0; i <= h; i++) {\n            for (int j = 0; j <= w; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(sx, sy, gx, gy, canGo);\n        if (result) { std::cout << \"OK\" << std::endl; }\n        else { std::cout << \"NG\" << std::endl; }\n        std::cin >> h >> w;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\tfor(int y = 0; y < 102; y++){\n\t\tfor(int x = 0; x < 102; x++){\n\t\t\tF[y][x] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xs][ys])){\n\t\tcout << \"OK\" << endl;\n\t}else{\n\t\tcout << \"NG\" << endl;\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool dfs(int xs,int ys,int xg,int yg,vector<vector<bool> >& canGo){\ncanGo[xs][ys]=false;\nif(xs==xg&&ys==yg)return true;\nif(canGo[xs+1][ys]){if(dfs(xs+1,ys,xg,yg,canGo))return true;}\nif(canGo[xs-1][ys]){if(dfs(xs-1,ys,xg,yg,canGo))return true;}\nif(canGo[xs][ys+1]){if(dfs(xs,ys+1,xg,yg,canGo))return true;}\nif(canGo[xs][ys-1]){if(dfs(xs,ys-1,xg,yg,canGo))return true;}\nreturn false;\n}\nint main(void){\nint w,h,xs,ys,xg,yg,n;\nbool ans,endflag;\nvector<vector<bool> > blockmap;\nwhile(true){\nendflag=false;\ncin>>w>>h>>xs>>ys>>xg>>yg>>n;\nif(w==0&&h==0)endflag=true;\nblockmap=vector<vector<bool> >(w+2,vector<bool>(h+2,true));\nfor(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin>>c>>d>>x>>y;\n    if(c!=2){\n        blockmap[x+1][y+1]=false;\n        blockmap[x+2][y+1]=false;\n        blockmap[x+1][y+2]=false;\n        blockmap[x+2][y+2]=false;\n        if(d==0){\n            blockmap[x+3][y+1]=false;\n            blockmap[x+3][y+2]=false;\n            blockmap[x+4][y+1]=false;\n            blockmap[x+4][y+2]=false;\n        }\n        else {\n            blockmap[x+1][y+2]=false;\n            blockmap[x+2][y+3]=false;\n            blockmap[x+1][y+4]=false;\n            blockmap[x+2][y+4]=false;\n        }\n    }\n}\nans=dfs(xs,ys,xg,yg,blockmap);\nif(ans)cout<<\"OK\"<<endl;\nelse cout<<\"NG\"<<endl;\nif(endflag)break;\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(xs-1,ys-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int xs,int ys){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[xs][ys] == 0){\n    return 0;\n  }\n  else if(maps[xs][ys] == maps[xg-1][yg-1]){\n    return 1;\n  }\n  maps[xs][ys] = 0;\n  return solve(xs+1,ys) + solve(xs,ys+1)+ solve(xs-1,ys) + solve(xs,ys-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint bord[101][101]={},playx[2],playy[2];\nint movex[]={1,0,-1,0},movey[]={0,1,0,-1};\nint serch(int x,int y,int color)\n{\n    if(color==0)return 0;\n    int now=0;\n    bord[y][x]=0;\n    if(x==playx[1]&&y==playy[1])return 1;\n    for(int i=0;i<4&&now==0;i++){\n        if(bord[movey[i]+y][movex[i]+x]==color)now=serch(movex[i]+x,movey[i]+y,color);\n    }\n    return now;\n}\nint main()\n{\n    int  h,w;\n    while(cin>>h>>w,h,w){\n        for(int i=0;i<=h+1;i++){\n                for(int j=0;j<=w+1;j++){\n                        bord[i][j]=0;\n                }\n        }\n        for(int i=0;i<2;i++)cin>>playx[i]>>playy[i];\n        int n;\n        cin>>n;\n        for(int i=0;i<n;i++){\n            int co,mu,x,y;\n            cin>>co>>mu>>x>>y;\n            for(int j=0;j<4;j++){\n                if(mu==1){\n                    bord[y+j][x]=co;\n                    bord[y+j][x+1]=co;\n                }\n                else{\n                    bord[y][x+j]=co;\n                    bord[y+1][x+j]=co;\n                }\n            }\n        }\n        if(serch(playx[0],playy[0],bord[playy[0]][playx[0]]))cout<<\"OK\\n\";\n        else cout<<\"NG\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,xgyg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(xi==xg && yi==yg && block[xi][yi]==c){ ans = 1; return;}\n    if(block[xi][yi] == 0) return;\n\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1, yi);\n        solve(xi, yi-1);\n        solve(xi+1, yi);\n        solve(xi, yi+1);\n    }\n    block[xi][yi] = 0;\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        memset(block,0,sizeof(int)*W*H);\n        if(w==0 && h==0) break;\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            if(d == 1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        /*rep(j,h)\n        {\n            rep(i,w) cout << block[i+1][j+1] << \" \" ;\n            cout << endl;\n        }*/\n\n        c = block[xs][ys];\n        //cout << c  << \" goal\" << block[xg][yg]<< endl;\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h;\nint sx, sy;\nint gx, gy;\nint n;\nint field[120][120];\n\nvoid PrintField() {\n  REP(y, h + 2) {\n    REP(x, w + 2) {\n      printf(\"%d\", field[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(field, 0);\n    scanf(\"%d %d\", &sx, &sy);\n    scanf(\"%d %d\", &gx, &gy);\n    scanf(\"%d\", &n);\n    REP(i, n) {\n      int c, d, sx, sy;\n      scanf(\"%d %d %d %d\", &c, &d, &sx, &sy);\n      int ex = sx + 2;\n      int ey = sy + 2;\n      if (d == 0) { ex += 2; }\n      if (d == 1) { ey += 2; }\n      FOR(y, sy, ey) {\n        FOR(x, sx, ex) {\n          field[y][x] = c;\n        }\n      }\n    }\n    w += 3;\n    int sc = field[sy][sx];\n    queue<int> que;\n    que.push(sy * w + sx);\n    while (!que.empty()) {\n      int x = que.front() % w;\n      int y = que.front() / w;\n      que.pop();\n      if (sc == 0) { break; }\n      if (x == gx && y == gy) {\n        puts(\"OK\");\n        goto next;\n      }\n      REP(dir, 4) {\n        const int dx[4] = { 1, 0, -1, 0 };\n        const int dy[4] = { 0, 1, 0, -1 };\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n        if (field[ny][nx] != sc) { continue; }\n        field[ny][nx] = 9;\n        que.push(ny * w + nx);\n      }\n    }\n    puts(\"NG\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n\n// 0\t\t\t\t\t\t\t\t1\n// (0, 0) (1, 0) (2, 0) (3, 0)\t\t(0, 0) (1, 0)\n// (0, 1) (1, 1) (2, 1) (3, 1)\t\t(0, 1) (1, 1)\n//\t\t\t\t\t\t\t\t\t(0, 2) (1, 2)\n//\t\t\t\t\t\t\t\t\t(0, 3) (1, 3)\nconst int dy[2][8] = {{0,0,0,0,1,1,1,1},{0,0,1,1,2,2,3,3}}, dx[2][8] = {{0,1,2,3,0,1,2,3},{0,1,0,1,0,1,0,1}};\nconst int ddy[4] = {-1,0,1,0}, ddx[4] = {0,1,0,-1};\nint table[100][100];\n\nvoid dfs(int x,int y,int w,int h){\n\tint now = table[y][x];\n\ttable[y][x] = 0;\n\tfor(int i = 0;i < 4;i++){\n\t\tif(x + ddx[i] >= 0 && x + ddx[i] < w && y + ddy[i] >= 0 && y + ddy[i] < h && table[y + ddy[i]][x + ddx[i]] != 0 && now == table[y + ddy[i]][x + ddx[i]]){\n\t\t\tdfs(x + ddx[i],y + ddy[i],w, h);\n\t\t}\n\t}\n}\n\n\nint main(void){\n\tint sx, sy, gx, gy, n, c, d, x, y, i, j, w, h;\n\tchar ans[3];\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tstrcpy(ans,\"NG\");\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\tsx--; sy--; gx--; gy--;\n\t\tmemset(table,0,sizeof(table));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(j = 0;j < 8;j++){\n\t\t\t\ttable[y + dy[d][j] - 1][x + dx[d][j] - 1] = c;\n\t\t\t}\n\t\t}\n/*\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tprintf(\"%d \",table[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(table[gy][gx] != 0){\n\t\t\tdfs(sx, sy, w, h);\n\t\t\tif(table[gy][gx] == 0){\n\t\t\t\tstrcpy(ans,\"OK\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <ctime>\n#define INF 100000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n \n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint maze[305][305];\nint w,h,xs,ys,xg,yg;\n\nvoid init(){\n  rep(i,305){\n    rep(j,305){\n      maze[i][j]=-1;\n    }\n  }\n}\n\nbool bfs(int c){\n  queue<int>que;\n  que.push(xs);\n  que.push(ys);\n  while(que.size()){\n    int x=que.front();que.pop();\n    int y=que.front();que.pop();\n    if(x==xg&&y==yg)return true;\n    for(int i=0;i<4;i++){\n      if(0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h&&maze[y+dy[i]][x+dx[i]]==c){\n\tque.push(x+dx[i]);\n\tque.push(y+dy[i]);\n\tmaze[y+dy[i]][x+dx[i]]=-1;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n,c,d,x,y;\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    init();\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    rep(i,n){\n      cin>>c>>d>>x>>y;\n      if(d==0){\n\trep(j,2){\n\t  rep(k,4){\n\t    maze[y+j][x+k]=c;\n\t  }\n\t}\n      }else if(d==1){\n\trep(j,4){\n\t  rep(k,2){\n\t    maze[y+j][x+k]=c;\n\t  }\n\t}\n      }\n    }\n    if(bfs(c))cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int ys,int xs);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0 || map[ys][xs] != gc){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[yg-1][xg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<windows.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k,l,m;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\t\n/*\t\t\t\tfor(l=0;l<h;l++)\n\t\t\t\t{\n\t\t\t\t\tfor(m=0;m<w;m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d \",map[l][m]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%dツ行\\n\",l);\n\t\t\t\t}\n\t\t\t\tgetchar();\n\t\t\t\tsystem(\"cls\");\n*/\n\t\t\t\t\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"migi\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"hidari\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i-1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101];\nint w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy))r=1;\n\tif(x>0&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>0&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t//spÍX^[gn_ÌÀWAgpÍS[n_ÌÀW\n\tpoint sp,bp;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\td?bw=2,bh=4:bh=2,bw=4;\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])dfs(sx,sy,m[sx][sy]),m[sx][sy] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint show=1;\nint w,h,sx,sy,gx,gy,d[101][101],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dy[i],nx=p.second+dx[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>w>>h){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<y+2+di*2;j++)for(int k=x;k<x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tif(!C)cout<<\"NG\"<<endl;\n\t\telse bfs();\n\t\tif(show){\n\t\t\tfor(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(field[i][j])cout<<field[i][j];else cout<<\" \";}cout<<endl;}\n\t\t\tfor(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(d[i][j]<INF)cout<<d[i][j]<<\" \";else cout<<\"  \";}cout<<endl;}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint count=0;\n\tint H,W,xg,yg,xs,ys,n;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2 || H<4 || W<4)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tfor(int o=ys;o<=yg;o++){\n\t\tfor(int j=xs;j<=xg;j++){\n\t\t\tcout<<F[j][o];\n\t\t}\n\t\tcout<<endl;\n\t}\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==0)\n\t\tcout<<\"OK\"<<endl;\n\tif(F[xg][yg]!=0)\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nstruct Data{\n\tint y, x;\n\tData(){}\n\tData(int _y, int _x){\n\t\ty = _y; x = _x;\n\t}\n};\n\nint fld[100][100];\n\nvoid PaintFld(int c, int x, int y, int w, int h){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfld[y + i][x + j] = c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint W, H;\n\twhile(cin >> W >> H, W || H){\n\t\tint Xs, Ys, Xg, Yg, N, C, D, X, Y;\n\t\tcin >> Xs >> Ys >> Xg >> Yg >> N;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tif(D == 0) PaintFld(C, X, Y, 4, 2);\n\t\t\telse PaintFld(C, X, Y, 2, 4);\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tbool memo[100][100] = {}, ans = false;\n\t\tq.push( Data(Xs, Ys) );\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\n\t\t\tif(q_front.y == Yg && q_front.x == Xg){\n\t\t\t\tans = true; break;\n\t\t\t}\n\n\t\t\tif(memo[q_front.y][q_front.x]) continue;\n\t\t\tmemo[q_front.y][q_front.x] = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\tint nx = q_front.x + dx[i];\n\n\t\t\t\tif(ny < 0 || H <= ny || nx < 0 || W <= nx || fld[ny][nx] != fld[Ys][Xs])\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push( Data(ny, nx) );\n\t\t\t}\n\t\t}\n\n\t\tif(ans) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y;\n\tstate(int x, int y) : x(x), y(y) {};\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h, vi(w));\n\t\tvvi visit(h, vi(w));\n\t\t\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(d) {\n\t\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<state> S;\n\t\tS.push(state(xs, ys));\n\t\tbool goal = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.front();\n\t\t\tS.pop();\n\n\t\t\tif(st.x == xg && st.y == yg) {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx, ny;\n\t\t\tREP(d, 4) {\n\t\t\t\tnx = st.x + dx[d];\n\t\t\t\tny = st.y + dy[d];\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny < h) {\n\t\t\t\t\tif(!visit[ny][nx] && field[ny][nx] == field[ys][xs]) {\n\t\t\t\t\t\tvisit[ny][nx] = 1;\n\t\t\t\t\t\tS.push(state(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(goal) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       F[0][-100] = 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define MAX 105\n#define Nll -1\nint w,h;\nint xs,ys,xg,yg;\nint blockNm;\nint map[MAX][MAX];\ntypedef queue < pair<int,int> > Queue;\nvoid setBlock(int color,int dir,int x,int y){\n\tint dx[]={2,0};\n\tint dy[]={0,2};\n\tint xb=x,yb=y;//x_base,y_base\n\tfor(int i=0;i<2;i++,xb+=dx[dir],yb+=dy[dir]){\n\t\tmap[yb][xb]\n\t\t        =map[yb][xb+1]\n\t\t        =map[yb+1][xb]\n\t\t        =map[yb+1][xb+1]=color;\n\t}\n}\nvoid init(){\n\tfor(int i=0;i<MAX;i++)for(int j=0;j<MAX;j++)map[i][j]=-1;\n}\nvoid print(){\n\tfor(int i=0;i<=h+1;i++){for(int j=0;j<=w+1;j++)printf(\"%2d\",map[i][j]);cout<<endl;}\n}\nbool isGoal(int xs,int ys,int xg,int yg){\n\tint color=map[xs][ys];\n\tif(color==Nll)return false;\n\tint dx[]={ 0, 1, 0,-1};\n\tint dy[]={-1, 0, 1, 0};\n\t//cout<<\"[\"<<w<<\" \"<<h<<\"]\"<<endl;\n\tQueue q;\n\tq.push(pair<int,int>(xs,ys));\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front();q.pop();\n\t//\tcout<<\"cur(\"<<cur.first<<\",\"<<cur.second<<\")\"<<endl;\n\t\tif(cur.first==xg&&cur.second==yg)return true;\n\t\tfor(int i=0;i<4;i++){\n//\t\t\tcout<<\"    next(\"<<cur.first+dx[i]<<\",\"<<cur.second+dy[i]<<\")\"<<map[cur.first+dy[i]][cur.second+dx[i]]<<endl;\n\t\t\tif(cur.first+dx[i]<1||cur.first+dx[i]>w\n\t\t\t\t\t||cur.second+dy[i]<1||cur.second+dy[i]>h\n\t\t\t\t\t||map[cur.second+dy[i]][cur.first+dx[i]]!=color)continue;\n\t\t\tq.push(pair<int,int>(cur.first+dx[i],cur.second+dy[i]));\n\t\t\tmap[cur.second+dy[i]][cur.first+dx[i]]=99;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin>>w>>h&&(w||h)){\n\t\tinit();\n\t\tcin>>xs>>ys>>xg>>yg>>blockNm;\n\t\tfor(int i=0;i<blockNm;i++){\n\t\t\tint color,dir,x,y;\n\t\t\tcin>>color>>dir>>x>>y;\n\t\t\tsetBlock(color,dir,x,y);\n\t\t}\n\t\t//print();\n\t\tstring ans=isGoal(xs,ys,xg,yg)?\"OK\":\"NG\";\n\t\t//cout<<\"after\"<<endl;\n\t\t//print();\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<queue>\nusing namespace std;\nint field[128][128];\nint dx[] = {-1,0,0,1},dy[] = {0,-1,1,0};\nint w,h;\nvoid func(int x,int y,int c){\n\tif(x < 0 || y < 0 || x >= w || y >= h)return ;\n\tif(field[y][x] == -1 || field[y][x] == 0)return ;\n\tif(field[y][x] != c)return ;\n\tfield[y][x] = -1;\n\tfor(int i = 0; i < 4; i++){\n\t\tfunc(x+dx[i],y+dy[i],c);\n\t}\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w,h){\n\t\tint xs,ys,xg,yg,n;\n\t\tmemset(field,0,sizeof(field));\n\t\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = x; j < x + 4; j++){\n\t\t\t\t\tfield[y][j] = c;\n\t\t\t\t\tfield[y+1][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < y + 4; j++){\n\t\t\t\t\tfield[j][x] = c;\n\t\t\t\t\tfield[j][x+1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunc(xs,ys,field[ys][xs]);\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tprintf(\"%2d\",field[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\tcout << (field[yg][xg]==-1?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=10;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\nif(F[xs][ys]==0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint w, h, xs, ys, xg, yg;\nint field[100][100];\n\nbool recur(int c, int x, int y){\n\tif(field[x][y] != c){ return false; }\n\tif(x == xg && y == yg){ return true; }\n\tfield[x][y] = -1;\n\tif(x > 0 && recur(c, x - 1, y)){ return true; }\n\tif(x < w - 1 && recur(c, x + 1, y)){ return true; }\n\tif(y > 0 && recur(c, x, y - 1)){ return true; }\n\tif(y < h - 1 && recur(c, x, y + 1)){ return true; }\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0 || h == 0){ break; }\n\t\tscanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\t\txs--; ys--; xg--; yg--;\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\tx--; y--;\n\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\t\tif(d == 0){\n\t\t\t\t\t\tfield[x + k][y + j] = c;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfield[x + j][y + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(recur(field[xs][ys], xs, ys) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c || c != 0)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][xs]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\t/*for (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy,d[101][101],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<=y+2+di*2;j++)for(int k=x;k<=x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tbfs();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint board[100][100];\nbool vst[100][100];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,xs,ys,xg,yg,n;\nbool dfs(int x,int y) {\n\tif(x==xg && y==yg)\n\t\treturn true;\n\tvst[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0>nx||nx>=w||0>ny||ny>=h)\n\t\t\tcontinue;\n\t\tif(board[nx][ny]!=board[xs][ys])\n\t\t\tcontinue;\n\t\tif(vst[nx][ny])\n\t\t\tcontinue;\n\t\tif(dfs(nx,ny)) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile(scanf(\"%d %d\",&w,&h),w|h) {\n\t\tscanf(\"%d %d\",&xs,&ys); xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg); xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tmemset(board,0,sizeof(board));\n\t\tmemset(vst,0,sizeof(vst));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y); x--;y--;\n\t\t\tif(d==0) {\n\t\t\t\tfor(int i=0;i<4;i++) for(int j=0;j<2;j++)\n\t\t\t\t\tboard[x+i][y+j]=c;\n\t\t\t}else {\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<4;j++)\n\t\t\t\t\tboard[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<int,int> P;\nP S,G;\nint w,h;\nint maze[MAX][MAX];\nint color;\n\nbool check()\n{\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tint nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G)\n\t\t\treturn true;\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tint n,c,d,x,y;\n\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(check())\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n/*\n\t\trep(i,y){\n\t\t\trep(j,x)\n\t\t\t\tprintf(\"%2d\", maze[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy,d[100][100],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=0;i<=h;i++)for(int j=0;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<=y+2+di*2;j++)for(int k=x;k<=x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tbfs();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x < w && y>=0 && y< h)?1:0;\n}\nint main(void){\n\tconst int dx[4]={0,-1,0,1};\n\tconst int dy[4]={-1,0,1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\t//printf(\"%d %d\\n\",w,h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x-1+k][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs-1][ys-1];\n/**\t\tif(c==0){\n\t\t\tputs(\"NG\");\n\t\t\tcontinue;\n\t\t}//**/\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs-1;\n\t\tqy[0]=ys-1;\n\t\tm[xs-1][ys-1]=-1;\n\t\tf=1;\n/**\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%3d\",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\t\tprintf(\"%d\\n\",c);\n\t\t\t\t/**/\n\t\twhile(f==1 && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dx[i];\n\t\t\t\ty = qy[p] + dy[i];\n\t\t\t\tif(is(x,y)==1 && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tqx[mx+cnt] = x;\n\t\t\t\t\tqy[mx+cnt] = y;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tif(x == xg-1 && y == yg-1)f=0;\n\t\t\t\t\t//printf(\"%d %d にいるよ,%d\\n\",x+1,y+1,i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}/**\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%3d\",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\t\tprintf(\"%d\\n\",c);\n\t\t\t\t/**/\n\n\t\tputs(f?\"NG\":\"OK\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[100][100] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y && di < h; di++){\n                for(int dj = x;dj < dw + x && dj < w;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[100][100] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xs][ys] != C)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n        }\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<MAX+2; i++ ) {\n      for ( int j=0; j<MAX+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n\n    next.push(ys*1000 + xs );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    /*\n      for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n      cout << map[i+1][j+1];\n      }\n      cout << endl;\n      }\n      cout << endl;\n    */\n    int xn,yn;\n    if ( map[yg][xg] == sc ) {\n      if ( sc == 0 || map[yg][xg] == 0 ) {\n      }\n      else {\n\twhile ( !next.empty() ) {\n\t  point = next.front();\n\t  next.pop();\n\t  xn = point%1000;\n\t  yn = point/1000;\n\n\t  if (map[yn][xn] == 0 )\n\t    continue;\n\n\t  if (point == yg*1000+xg) {\n\t    goal = true;\n\t    break;\n\t  }\n\n\t  for ( int i=0; i<4; i++ ) {\n\t    if ( check[yn+dy[i]][xn+dx[i]] ) {\n\t      check[yn+dy[i]][xn+dx[i]] = false;\n\t      if ( map[yn+dy[i]][xn+dx[i]] == sc ) {\n\t\tnext.push((yn+dy[i])*1000+ xn +dx[i]);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <string>\n#include <complex>\n#include <list>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <sstream>\n#include <numeric>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n\n#define INF (1<<29)\n\n// math\n#define Sq(x) ((x)*(x))\n\n// container utility\n#define ALL(x) (x).begin(), (x).end()\n#define MP make_pair\n#define PB push_back\n#define EACH(it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();it++)\n\n// rep\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// typedef\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\n\ntypedef long long ll;\n\n// useful\n#define FST first\n#define SND second\n\n#define CK(n,a,b) (a<=n && n<b)\n\n// conversion\ntemplate<class T> inline string toStr(T a) { ostringstream oss; oss << a; return oss.str(); }\ninline int toInt(string s) { return atoi(s.c_str()); }\n\n// prime\nbool isPrime(int a) { for(int i=2; i*i <=a; i++) if(a%i == 0) return false; return true; }\n\n\nint const dx[] = {-1,0,1,0,-1,1,1,-1};\nint const dy[] = {0,-1,0,1,-1,-1,1,1};\n\n//////////////////////////////////////////////////////////////\n\nint main() {\n  \n  int W, H;\n  while(cin >> W >> H && (W|H)) {\n    int sx, sy, gx, gy, N;\n    cin >> sx >> sy >> gx >> gy >> N;\n    sx --, sy --, gx --, gy --;\n    \n    int grid[100][100] = {{}};\n    \n    for(int i=0; i<N; i++) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x --, y --;\n      \n      grid[y][x] = grid[y+1][x] = grid[y][x+1] = grid[y+1][x+1] = c;\n      if(!d) { grid[y][x+2] = grid[y+1][x+2] = grid[y][x+3] = grid[y+1][x+3] = c; }\n      else   { grid[y+2][x] = grid[y+2][x+1] = grid[y+3][x] = grid[y+3][x+1] = c; }\n    }\n    \n    queue<PII> q;\n    q.push(MP(sx, sy));\n    \n    int cost[100][100];\n    fill(cost[0], cost[0] + 10000, -1);\n    cost[sy][sx] = 0;\n    \n    while(!q.empty()) {\n      PII pii = q.front(); q.pop();\n      int x = pii.FST, y = pii.SND;\n      \n      for(int i=0; i<4; i++) {\n\tint nx = x + dx[i], ny = y + dy[i];\n\tif(CK(nx, 0, W) && CK(ny, 0, H)\n\t   && cost[ny][nx] == -1 && grid[sy][sx] == grid[ny][nx]) {\n\t  q.push(PII(nx, ny));\n\t  \n\t  cost[ny][nx] = cost[y][x] + 1;\n\t}\n      }\n    }\n    \n    if(cost[gy][gx] == -1) {\n      cout << \"NG\" << endl;\n    }\n    else {\n      cout << \"OK\" << endl;\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, 1, -1};\nconst int vy[4] = {1, -1, 0, 0};\n \nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n    \n    if(g[y][x] != sc){\n        flag = false;\n        return;\n    }\n    \n    g[y][x] = -1;\n    \n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n         \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            dfs(nx, ny);\n        }\n    }\n    return;\n}\n \nint main(){\n    while(1){\n        int n, c, d, x, y;\n        flag = false;\n        g[101][101] = {};\n        \n        cin >> weight >> hight;\n \n        if(weight == 0 && hight == 0){\n            break;\n        }\n         \n        cin >> sx >> sy >> gx >> gy >> n;\n         \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n             \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n         \n        sc = g[sy][sx];\n        dfs(sx, sy);\n         \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\n\nvoid DFS(int h,int w,int c){\n\n    if(Array[h][w] != c || Array[h][w] == 0 || Array[h][w] == 6){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 6;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n      cin >> Goal[0] >> Goal[1];\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n\n      if(Array[Start[0]][Start[1]] != 0){\n        DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n      }\n      if(Array[Goal[0]][Goal[1]] == 6){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 101\n\nint H, W, sx, sy, gx, gy;\nint color, dir, field[MAX][MAX];\n\nstruct P{\n  int x, y;\n  P(int x, int y) : x(x), y(y) {}\n};\n\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\n\nbool check(int y, int x){\n  if(0 <= y && y < H && 0 <= x && x < W){\n    return true;\n  }\n  return false;\n}\n\nvoid paint(int y, int x){\n  if(!dir){\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < 4 ; j++){\n        field[y+i][x+j] = color;\n      }\n    }\n  }else{\n    for(int i = 0 ; i < 4 ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n        field[y+i][x+j] = color;\n      }\n    }\n\n  }\n}\n\nbool bfs(){\n  bool used[MAX][MAX];\n  memset(used, false, sizeof(used));\n  used[sy][sx] = true;\n\n  queue<P> Q;\n  Q.push(P(sx, sy));\n\n  while(!Q.empty()){\n    P p = Q.front(); Q.pop();\n\n    if(field[p.y][p.x] == -1) continue;\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n\n      if(!check(ny, nx) || used[ny][nx] || \n         field[p.y][p.x] != field[ny][nx]) continue;\n\n      used[ny][nx] = true;\n      Q.push(P(nx, ny));     \n    }\n  }\n  return used[gy][gx];\n}\n\nint main(){\n  int n, x, y;\n  while(cin >> W >> H, (W | H)){\n    memset(field, -1, sizeof(field));\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    sy--, sx--, gy--, gx--;\n\n    for(int i = 0 ; i < n ; i++){\n      cin >> color >> dir >> x >> y;\n      y--, x--;\n      paint(y, x);\n    }\n    cout << (bfs() ? \"OK\" : \"NG\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint B[100][100];\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg);\n\nint main(int argc, char** argv)\n{\n\tint w, h;\n\tint xs, ys;\n\tint xg, yg;\n\tint n;\n\tint c, d, x, y;\n\n\twhile( 1 )\n\t{\n\t\tcin >> w;\n\t\tcin >> h;\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tcin >> xs;\n\t\tcin >> ys;\n\t\tcin >> xg;\n\t\tcin >> yg;\n\t\tcin >> n;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c; cin >> d; cin >> x; cin >> y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<4; dx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dy=0; dy<2; dy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tB[x+dx][y+dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<2; dx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dy=0; dy<4; dy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tB[x+dx][y+dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for(int j=0; j<h; j++)\n\t\t//{\n\t\t//\tfor(int i=0; i<w; i++)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d \", B[i][j]);\n\t\t//\t}\n\t\t//\tprintf(\"\\n\");\n\t\t//}\n\n\t\tcout << (bfs(w, h, xs, ys, xg, yg) ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg)\n{\n\tint x, y, c, xx, yy;\n\tint offset[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\tqueue<P> q;\n\tP p;\n\n\tc = B[xs][ys];\n\tB[xs][ys] = 0;\n\tp.first = xs, p.second = ys;\n\t\n\tq.push(p);\n\twhile(!q.empty())\n\t{\n\t\tp = q.front();\n\t\tq.pop();\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tif(x==xg && y==yg) return true;\n\t\tB[x][y] = 0;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\txx = x + offset[i][0];\n\t\t\tyy = y + offset[i][1];\n\t\t\tif(x>=0 && y>=0 && x<w && y<h)\n\t\t\t{\n\t\t\t\tif(B[xx][yy] == c)\n\t\t\t\t{\n\t\t\t\t\tp.first = xx;\n\t\t\t\t\tp.second = yy;\n\t\t\t\t\tq.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg;\nint mat[102][102];\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, 1, -1, 0};\n\nvoid init(){\n    for(int i = 0; i < 102; i++){\n        for(int j = 0; j < 102; j++){\n            mat[i][j] = 0;\n        }\n    }\n}\n\nbool bfs(){\n    if(mat[xs][ys] == 0 || mat[xg][yg] == 0)    return false;\n\n    int c = mat[xs][ys];\n    stack<pair<int,int>> s;\n    s.push({xs,ys});\n    bool visit[102][102] = {};\n    \n    while(!s.empty()){\n        pair<int,int> now = s.top(); \n        s.pop();\n        if(now.first == xg && now.second == yg){\n            return true;\n        }\n        \n        visit[now.first][now.second] = true;\n        \n        for(int i = 0; i < 4; i++){\n            int nx = now.first + dx[i];\n            int ny = now.second + dy[i];\n            \n            if(mat[nx][ny] == c && !visit[nx][ny]){\n                s.push({nx,ny});\n            }\n        }\n    }\n    \n    return false;\n}\n\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0)  break;\n        cin >> ys >> xs >> yg >> xg;\n        \n        init();\n        \n        int n;\n        cin >> n;\n        \n        int c, d, x, y;\n        while(n-- > 0){\n            cin >> c >> d >> y >> x;\n            if(d == 0){\n                for(int i = 0; i < 2; i++){\n                    for(int j = 0; j < 4; j++){\n                        mat[x+i][y+j] = c;\n                    }\n                }\n            }else if(d == 1){\n                for(int i = 0; i < 4; i++){\n                    for(int j = 0; j < 2; j++){\n                        mat[x+i][y+j] = c;\n                    }\n                }\n            }\n        }\n\n        if(bfs())   cout << \"OK\" << endl;\n        else        cout << \"NG\" << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n\n    canGo[x][y] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_x][next_y]) {\n            bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(w + 2, std::vector<int>(h+ 2, 0));\n        std::vector<std::vector<bool>> canGo(w + 2, std::vector<bool>(h + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != goal) {\n            ans.push_back(\"NG\");\n            \n            continue;\n        }\n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tboard[i][j]=0;\n\tcheak[i][j]=0;\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs-1,ys-1)==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==board[ys][xs] && cheak[yn][xn]==0){\n      if(dfs(xn,yn)==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint dx[] = { 1,-1,0,0 };\nint dy[] = { 0,0,1,-1 };\nint w, h;\n\nint check(int xs, int ys, int xg, int yg ,int c, int board[110][110]) {\n\tint used[110][110] = { 0 };\n\tqueue<pl> q;\n\tq.push({ xs, ys });\n\n\twhile (!q.empty()) {\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ddx = dx[i] + x;\n\t\t\tint ddy = dy[i] + y;\n\t\t\tif (ddx >= 1 && ddx <= w && ddy >= 1 && ddy <= h && !used[ddy][ddx]) {\n\t\t\t\tused[ddy][ddx] = 1;\n\t\t\t\tif (board[ddy][ddx] == c && ddy == yg && ddx == xg)return 1;\n\t\t\t\telse if (board[ddy][ddx] == c) {\n\t\t\t\t\tq.push({ddx,ddy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w, h) \n\t{\n\t\tint xs, ys, xg, yg;\n\t\tint n;\n\t\tint board[110][110] = { 0 };\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{ \n\t\t\tint c,d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d){\n\t\t\t\tfor (int i = y; i < y+2; i++) {\n\t\t\t\t\tfor (int j = x; j < x+8; j++) \n\t\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = y; i < y+8; i++) {\n\t\t\t\t\tfor (int j = x; j < x+2; j++)\n\t\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (check(xs, ys, xg, yg, board[ys][xs], board))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing V = vector<int>;\nusing VV = vector<V>;\nusing P = pair<int, int>;\n\nint main() {\n\tint dx[] = {4, 2}, dy[] = {2, 4};\n\tfor (int w, h; w = in(), h = in();) {\n\t\tP s = {in() - 1, in() - 1}, g = {in() - 1, in() - 1};\n\t\tint n = in();\n\t\tVV m(h, V(w));\n\t\twhile (n--) {\n\t\t\tint c = in(), d = in(), x = in() - 1, y = in() - 1;\n\t\t\tfor (int i = 0; i < dy[d]; i++)\n\t\t\t\tfor (int j = 0; j < dx[d]; j++)\n\t\t\t\t\tm[i + y][j + x] = c;\n\t\t}\n\t\tauto f = [&]{\n\t\t\tqueue<P> q;\n\t\t\tq.push(s);\n\t\t\tint c = m[s.second][s.first];\n\t\t\tset<P> v;\n\t\t\tv.insert(s);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tP t = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tif (t == g)\n\t\t\t\t\treturn \"OK\";\n\t\t\t\tP d = {1, 0};\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tP u = {t.first + d.first, t.second + d.second};\n\t\t\t\t\tif (u.first >= 0 && u.second >= 0 &&\n\t\t\t\t\t\tu.first < w && u.second < h &&\n\t\t\t\t\t\tm[u.second][u.first] == c && !v.count(u)) {\n\t\t\t\t\t\tv.insert(u);\n\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t}\n\t\t\t\t\tswap(d.first, d.second *= -1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"NG\";\n\t\t};\n\t\toutl(f());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y, color;\n\tvector< vector< int > > field;\n\tqueue< complex< int > > que;\n\tbool exist;\n\t\n\twhile(cin >> w >> h, w){\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\tfield.resize(w);\n\t\tfor(int i = 0; i < w; ++i) field[i].resize(h);\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 2; ++j){\n\t\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(field[xs - 1][ys - 1] != 0){\n\t\t\tque.push(complex< int >(xs - 1, ys - 1));\n\t\t\tcolor = field[xs - 1][ys - 1];\n\t\t\texist = false;\n\t\t\t\n\t\t\twhile(!que.empty()){\n\t\t\t\tcomplex< int > pos = que.front();\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tif(pos.real() == xg - 1 && pos.imag() == yg - 1){\n\t\t\t\t\texist = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.real() > 0 && field[pos.real() - 1][pos.imag()] == color) que.push(pos + complex< int >(-1, 0));\n\t\t\t\tif(pos.real() < w - 1 && field[pos.real() + 1][pos.imag()] == color) que.push(pos + complex< int >(1, 0));\n\t\t\t\tif(pos.imag() > 0 && field[pos.real()][pos.imag() - 1] == color) que.push(pos + complex< int >(0, -1));\n\t\t\t\tif(pos.imag() < h - 1 && field[pos.real()][pos.imag() + 1] == color) que.push(pos + complex< int >(0, 1));\n\t\t\t\t\n\t\t\t\tfield[pos.real()][pos.imag()] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (exist ? \"OK\" : \"NG\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef unsigned long long ull; typedef long long ll;\n\nconst int INF=100000000; int dx[4]={1,0,-1,0}; int dy[4]={0,1,0-1};\n\ntypedef pair<int ,int > P;\n\nchar maze[105][105];\n\nint sx,sy; int gx,gy; int w,h;\n\nchar sc; //スタート地点のカラー\n\n//stdin //stdout\n\nvoid dfs(int x,int y) { maze[x][y]='9';\n\nfor(int i=-1;i<=1;i++) { for(int j=-1;j<=1;j++) { int nx=x+i; int ny=y+j;\n\nif(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[nx][ny] != '0'&&maze[nx][ny] != '9') { dfs(nx,ny); }\n\n} } return ; }\n\nvoid solve() {\n\nrep(i,101) rep(j,101) maze[i][j]='0';\n\nint n; char c; int d; int x,y;\n\ncin>>sy>>sx; cin>>gy>>gx;\n\ncin>>n;\n\nrep(i,n) { cin>>c>>d>>y>>x;\n\nif(d==1) { rep(i,4) { rep(j,2) { maze[x+i][y+j]=c;\n\n} } } else if (d==0) { rep(i,2) { rep(j,4) { maze[x+i][y+j]=c;\n\n} } }\n\n} //6 6 //1 1 //3 6 //2 //1 0 1 1 //1 1 3 3 // rep(i,w+1) // { // rep(j,h+1) // { // cout<<maze[i][j]; //// } // cout<<endl; // } //// cout<<maze[gx][gy]<<endl;\n\nif(maze[sx][sy]=='0') { cout<<\"NG\"<<endl; return; } else { sc=maze[sx][sy]; dfs(sx,sy); }\n\n//rep(i,w+1) //{ // rep(j,h+1) // { // cout<<maze[i][j];\n\n// } // cout<<endl; //}\n\nif(maze[gx][gy]=='9') { cout<<\"OK\"<<endl; return; } else { cout<<\"NG\"<<endl; return; }\n\n}\n\nint main() {\n\nwhile(cin>>w>>h) { if(w==0 && h==0) { return 0; } else { solve(); } }\n\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint field[101][101];\n\nint xs,ys,xg,yg;\n\nvoid SetBlock(int c,int d,int x,int y)\n{\n\tif(d==0){//横なが\n\t\tfor(int ay=0;ay<2;++ay){\n\t\t\tfor(int ax=0;ax<4;++ax){\n\t\t\t\tfield[y+ay][x+ax] = c;\n\t\t\t}\n\t\t}\n\t}\n\tif(d==1){//縦なが\n\t\tfor(int ay=0;ay<4;++ay){\n\t\t\tfor(int ax=0;ax<2;++ax){\n\t\t\t\tfield[y+ay][x+ax] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool dfs(int x,int y)\n{\n\tint c = field[y][x];\n\tfield[y][x] = 0;\n\tif(x == xg && y == yg) return true;\n\tfor(int i=0;i<4;++i){\n\t\tif(c==field[y+dy[i]][x+dx[i]])if(dfs(x+dx[i],y+dy[i]))return true;\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tint w,h;\n\t\tint n;\n\t\tmemset(field,0,sizeof(field));\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tSetBlock(c,d,x,y);\n\t\t}\n\t\tif(field[ys][xs] == 0)\n\t\t\tcout << \"NG\" << endl;\n\t\telse\n\t\t{\n\t\t\tif(dfs(xs,ys))\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define dr direction\n#define cl color\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nclass Block{\npublic:\n    int color;// 1~5\n    int direction;// 0:-, 1:|\n    int x, y;\n    void init(int c, int d, int xx, int yy);\n};\n\nvoid Block::init(int c, int d, int xx, int yy){\n    color=c;\n    direction=d;\n    x=xx;\n    y=yy;\n}\n\nint w, h, xs, ys, xg, yg, n;\nint fld[100][100], dis[100][100];\nconst pii dxdy[]={{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nconst int inf=1e8;\n\nstring solve(){// bfs\n    queue<pii> qu;\n    qu.push(make_pair(ys, xs));\n    int C=fld[ys][xs];\n    fill(dis[0], dis[100], inf);\n    dis[ys][xs]=0;\n\n    if(C==0) return \"NO\";\n    while(!qu.empty()){\n        pii now=qu.front(); qu.pop();\n        if(now.fi==yg&&now.se==xg){\n            return \"OK\";\n        }\n\n        for(int k=0; k<4; k++){\n            pii nx=make_pair(now.fi+dxdy[k].fi, now.se+dxdy[k].se);\n            if(!(0<=nx.fi&&nx.fi<h&&0<=nx.se&&nx.se<w)) continue;\n            if(fld[nx.fi][nx.se]!=C) continue;\n            if(dis[nx.fi][nx.se]!=inf) continue;\n\n            dis[nx.fi][nx.se]=dis[now.fi][now.se]+1;\n            qu.push(nx);\n        }\n    }\n\n    return \"NO\";\n}\n\nint main(){\n\n    while(1){\n        cin>> w>> h;\n        if(w==0&&h==0) break;\n        cin>> xs>> ys>> xg>> yg>> n;\n        xs--; ys--; xg--; yg--;\n        Block block[n];\n        for(int i=0; i<n; i++){\n            int c, d, xx, yy;\n            cin>> c>> d>> xx>> yy;\n            xx--; yy--;\n            block[i].init(c, d, xx, yy);\n        }\n\n        // make field\n        for(int k=0; k<n; k++){\n            int X=block[k].x, Y=block[k].y;\n            if(block[k].dr==0){\n                for(int i=0; i<2; i++){\n                    for(int j=0; j<4; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }else{\n                for(int i=0; i<4; i++){\n                    for(int j=0; j<2; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }\n        }\n/*\n        for(int i=0; i<w; i++){\n            for(int j=0; j<h; j++){\n                cout<< fld[i][j]<<\" \";\n            }\n            cout<< endl;\n        }\n//*/\n        cout<< solve()<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[105][105];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\t//memset(board,0,sizeof(board));\n\t\tfor(int i=0;i<101;++i){\n\t\t\tfor(int j=0;j<101;++j){\n\t\t\t\tboard[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[100][100] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y && di < h; di++){\n                for(int dj = x;dj < dw + x && dj < w;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[100][100] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xg][yg] != C)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n        }\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n/*\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<field[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl<<endl;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<vis[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xx[4] = {0, 1, 0, -1};\nint yy[4] = {1, 0, -1, 0};\nint block[100][100];\nbool put[100][100];\nint already[100][100];\nint w, h;\nint xs, ys;\nint xg, yg;\nbool dfs(int nex, int ney);\n\nint main(){\n  int n;\n  \n  while(1){\n    memset(block, 0, sizeof(block));\n    memset(already, 0, sizeof(already));\n    memset(put, 0, sizeof(put));\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    cin >> xs >> ys;\n    xs--; ys--;\n    cin >> xg >> yg;\n    xg--; yg--;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      int wide, high;\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      if(d){\n\twide = 2; high = 4;\n      }\n      else{\n\twide = 4; high = 2;\n      }\n      for(int j = 0; j < high; j++){\n\tfor(int k = 0; k < wide; k++){\n\t  block[y+j][x+k] = c;\n\t  put[y+j][x+k] = true;\n\t}\n      }\n    }\n    bool ans = false;\n    if(block[ys][xs] == block[yg][xg]){\n      ans = dfs(xs, ys);\n      if(ans) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int nex, int ney){\n  already[nex][ney] = 1;\n  if(nex == xg && ney == yg) return true;\n  for(int i = 0; i < 4; i++){\n    int nx = nex + xx[i];\n    int ny = ney + yy[i];\n    if(0 <= nx && 0 <= ny && ny < h && nx < w && put[ny][nx] && !already[ny][nx] && block[ys][xs] == block[ny][nx]) return dfs(nx, ny);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n#include <queue>\n#include <complex>\n#include <climits>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint maze[110][110];\nint f[110][110];\nint w, h, xs, ys, xg, yg, res = 0;\nint color;\n\nvoid dfs(int cx, int cy){\n\tif(f[cx][cy]) return ;\n\tf[cx][cy] = 1;\n\tif(cx == xg && cy == yg){\n\t\tres = 1;\n\t\treturn ;\n\t}\n\tfor(int dx=-1; dx<=1; ++dx){\n\t\tfor(int dy=-1; dy<=1; ++dy){\n\t\t\tif(abs(dx-dy) != 1) continue;\n\t\t\tint nx = cx + dx, ny = cy + dy;\n\t\t\tif(maze[nx][ny] == color){\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<110; ++i){\n\t\t\tfor(int j=0; j<110; ++j){\n\t\t\t\tmaze[i][j] = 6;\n\t\t\t\tf[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tmaze[i][j] = 0;\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j=y; j<=y+1; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+3; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d == 1){\n\t\t\t\tfor(int j=y; j<=y+3; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+1; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor = maze[xs][ys];\n\t\tif(color == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(xs, ys);\n\n\t\tif(res){\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STR(x) string x;cin>>x;\n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\n\n\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint w, h;\n\t\tpii start, goal;\n\t\tint n;\n\t\tint a[200][200] = {};\n\t\tbool flag[200][200] = {};\n\t\tbool ok = false;\n\t\tcin >> w >> h;if (!w)break;\n\t\tcin >> start.first >> start.second;\n\t\tcin >> goal.first >> goal.second;\n\t\tcin >> n;\n\n\t\tFOR(i, n)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor (int X = x; X <= x+1+(d?0:2); X++)\n\t\t\t{\n\t\t\t\tfor (int Y = y; Y <= y + 1 + (d ? 2 : 0); Y++)\n\t\t\t\t{\n\t\t\t\t\ta[X][Y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tflag[start.first][start.second] = true;\n\t\tqueue<pii> que; \n\t\tif(a[start.first][start.second]!=0)que.push(start);\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front(); que.pop();\n\t\t\tif (now == goal)\n\t\t\t{\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\tok = true;\n\t\t\t}\n\n\t\t\tFOR(i, 4)\n\t\t\t{\n\t\t\t\tpii next=now;\n\t\t\t\tnext.first += dx[i]; next.second += dy[i];\n\n\t\t\t\tif (a[next.first][next.second] == a[now.first][now.second] && !flag[next.first][next.second])\n\t\t\t\t{\n\t\t\t\t\tflag[next.first][next.second] = true;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!ok)cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[102][102],MF[102][102];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(Y>0 && X>0){\n\t\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0){\n\t\t\tBlock(X,Y-1); //???\n\t\t\t//MF[Y][X-1]=0;\n\t\t}\n\t\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0){\n\t\t\tBlock(X,Y+1); //???\n\t\t\t//MF[Y+1][X]=0;\n\t\t}\n\t\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0){\n\t\t\tBlock(X-1,Y); //???\n\t\t\t//MF[Y][X-1]=0;\n\t\t}\n\t\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0){\n\t\t\tBlock(X+1,Y); //???\n\t\t\t//MF[Y][X-1]=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101] = {};\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc) return;\n\t\tfunc(x + nx[i], y + ny[i]);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> c >> d >> x >> y;\n\t\tif (d == 0){\n\t\t\tbw = 4;\n\t\t\tbh = 2;\n\t\t}\n\t\telse{\n\t\t\tbw = 2;\n\t\t\tbh = 4;\n\t\t}\n\t\tfor (int j = 0; j < bh; j++){\n\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t}\n\tbc = stage[1][1];\n\tfunc(1, 1);\n\tif (ans == true) cout << \"OK\\n\";\n\telse cout << \"NG\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int ys,int xs);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0 || maps[ys][xs] != gc){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[yg-1][xg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint B[102][102], C, xg, yg;\n\nbool rec(int x, int y) {\n  if (B[x][y] != C)\n    return false;\n  if (x == xg && y == yg)\n    return true;\n  B[x][y] = 0;\n  if (rec(x+1, y) || rec(x-1, y) || rec(x, y+1) || rec(x, y-1))\n    return true;\n  return false;\n}\n\nint main() {\n  for (;;) {\n    int w, h;\n    cin >> w >> h;\n    if (!w && !h) return 0;\n    for (int x = 0; x < w+2; x++)\n      for (int y = 0; y < h+2; y++)\n        B[x][y] = 0;\n    int xs, ys, n;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for (int i = 0; i < n; i++) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      for (int j = 0; j < 2; j++)\n        for (int k = 0; k < 4; k++)\n          (d ? B[x+j][y+k] : B[x+k][y+j]) = c;\n    }\n    if (!B[xs][ys]) {\n      cout << \"NG\" << endl;\n      continue;\n    }\n    C = B[xs][ys];\n    cout << (rec(xs, ys) ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\n\nvoid Block(int c,int d,int x,int y){\n\tif(d==0){\n    \tfor(int i=0;i<4;i++){\n    \t\tF[y  ][x+i]=c;\n\t\t\tF[y+1][x+i]=c;\n    \t}\n  \t}else{\n    \tfor(int i=0;i<4;i++){\n    \t\tF[y+i][x  ]=c;\n    \t\tF[y+i][x+1]=c;\n    \t}\n\t}\n}\nvoid DFS(int y,int x,int c){\n\tif(F[y][x]!=c)\n\t\treturn;\n\n\tF[y][x] = 6;\n\n    DFS(y-1,x  ,c);\n    DFS(y  ,x+1,c);\n    DFS(y+1,x  ,c);\n    DFS(y  ,x-1,c);\n}\nint main(){\n\twhile(true){\n\t\tint w,h,xs,ys,xg,yg,n;\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0){break;}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\tF[i][k]=-1;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tBlock(c,d,x,y);\n  \t\t}\n \t\tDFS(ys,xs,F[ys][xs]);\n\t\tif(F[yg][xg]==6){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint board[100][100];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc|| board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\tint xs , ys;\n\tint n;\n\twhile(cin >> w >> h , w|h){\n\t\tb=false;\n\t\t//memset(board,0,sizeof(board));\n\t\tfor(int i=0;i<100;++i){\n\t\t\tfor(int j=0;j<100;++j){\n\t\t\t\tboard[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/09 Tazoe\n\n#include<iostream>\nusing namespace std;\n\nbool DFS(int brd[102][102], int x, int y, int xg, int yg, int c)\n{\n\tif(brd[y][x]!=c)\n\t\treturn false;\n\n\tif(x==xg&&y==yg)\n\t\treturn true;\n\n\tbrd[y][x] = 9;\t\t// ツつキツづづ可訪ツづェツつス\n\n\tif(DFS(brd, x+1, y, xg, yg, c))\n\t\treturn true;\n\tif(DFS(brd, x, y+1, xg, yg, c))\n\t\treturn true;\n\tif(DFS(brd, x-1, y, xg, yg, c))\n\t\treturn true;\n\tif(DFS(brd, x, y-1, xg, yg, c))\n\t\treturn true;\n\n\treturn false;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tint brd[102][102];\n\t\tfor(int y=0; y<=h+1; y++)\n\t\t\tfor(int x=0; x<=w+1; x++)\n\t\t\t\tbrd[y][x] = 0;\n\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tbrd[y  ][x  ] = c;\n\t\t\tbrd[y  ][x+1] = c;\n\t\t\tbrd[y+1][x  ] = c;\n\t\t\tbrd[y+1][x+1] = c;\n\t\t\tif(d==0){\n\t\t\t\tbrd[y  ][x+2] = c;\n\t\t\t\tbrd[y  ][x+3] = c;\n\t\t\t\tbrd[y+1][x+2] = c;\n\t\t\t\tbrd[y+1][x+3] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbrd[y+2][x  ] = c;\n\t\t\t\tbrd[y+2][x+1] = c;\n\t\t\t\tbrd[y+3][x  ] = c;\n\t\t\t\tbrd[y+3][x+1] = c;\n\t\t\t}\n\t\t}\n\n\t\tif(brd[ys][xs]==0||brd[yg][xg]==0||brd[ys][xs]!=brd[yg][xg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(DFS(brd, xs, ys, xg, yg, brd[ys][xs]))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 10000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint moveTo[][2] = {{-1,0},{1,0},{0,-1},{0,1}};\n\nint stage[100][100];\n\nvoid paint(int c,int d,int x,int y){\n\t//c:1~5 d: 0:horizonal 1:vertical\n\tif(d==0){\n\t\tfor(int i=x;i<x+4;i++){\n\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\tstage[j][i] = c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg){\n\tint cs = stage[ys][xs];\n\tint cg = stage[yg][xg];\n\tif(cs != cg) return false;\n\n\tqueue<P> que;\n\tque.push(P(xs,ys));\n\n\twhile(!que.empty()){\n\t\tint sx = que.front().first;\n\t\tint sy = que.front().second;\n\t\t\n\t\tif(sx == xg && sy == yg) return true;\n\t\tque.pop();\n\n\t\tstage[sy][sx] = -1;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = sx + moveTo[i][0];\n\t\t\tint dy = sy + moveTo[i][1];\n\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\t\t\tif(stage[dy][dx] != cs || stage[dy][dx] == -1) continue;\n\t\t\tque.push(P(dx,dy));\n\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==h && h==0) break;\n\t\tmemset(stage,-1,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\n\t\tint xg,yg;\n\t\tscanf(\"%d %d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\t//c:1~5 d: 0:horizonal 1:vertical\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tpaint(c,d,x-1,y-1);\n\t\t}\n\n\t\tprintf(\"%s\\n\",bfs(w,h,xs-1,ys-1,xg-1,yg-1) ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint m[100][100],used[100][100];\nint d[]={0,1,0,-1,0};\nmain()\n{\n\tint w,h;\n\twhile(cin>>w>>h,h)\n\t{\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)used[i][j]=m[i][j]=0;\n\t\tint sx,sy,gx,gy;cin>>sy>>sx>>gy>>gx;\n\t\tsx--,sy--,gx--,gy--;\n\t\tint n;cin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;cin>>c>>d>>y>>x;\n\t\t\tx--,y--;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<2;j++)for(int k=0;k<4;k++)m[x+j][y+k]=c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j=0;j<4;j++)for(int k=0;k<2;k++)m[x+j][y+k]=c;\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy]==0)\n\t\t{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<pair<int,int> >P;\n\t\tP.push(make_pair(sx,sy));\n\t\tused[sx][sy]=1;\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first,y=P.front().second;\n\t\t\tP.pop();\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint tx=x+d[r],ty=y+d[r+1];\n\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||used[tx][ty]||m[tx][ty]!=m[sx][sy])continue;\n\t\t\t\tused[tx][ty]=1;\n\t\t\t\tP.push(make_pair(tx,ty));\n\t\t\t}\n\t\t}\n\t\tcout<<(used[gx][gy]?\"OK\":\"NG\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(R==map[gb][ga]){\n\t\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color && count == 0){\n\t\tif(x == xg && y == yg){\n\t\t\tcount = 1;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[101][101] = {{0},{0},};\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n    \n    while(true){\n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy >> n;\n            Solve s(w, h, sx, sy, gx, gy);\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\" << endl;\n            }else{\n                cout << \"NG\" << endl;\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint table[100][100];\nint memo[100][100];\n\nint w, h;\nint xs, ys, xg, yg;\nint n;\n\nvoid solve(int xs, int ys, int c)\n{\n\tif( memo[xs][ys] ) {\n\t\treturn;\n\t}\n\n\tif( !( 0 < xs && xs < w+1 && 0 < ys && ys < h+1 && table[xs][ys] == c ) ) {\n\t\tmemo[xs][ys] = 1;\n\t\treturn;\n\t}\n\t\n\tif( xs == xg && ys == yg ) {\n\t\tmemo[xs][ys] = 1;\n\t\tcout << \"OK\" << endl;\n\t\tthrow \"OK\";\n\t}\n\n\tmemo[xs][ys] = 1;\t\n\n\tsolve(xs+1, ys, c);\n\tsolve(xs, ys+1, c);\t\n\tsolve(xs-1, ys, c);\n\tsolve(xs, ys-1, c);\n\n\treturn;\n}\n\nint main(int argc, char* argv[])\n{\n\twhile(1) {\n\n\t\tfor( int i = 0; i < 100; i++ ) {\n\t\t\tfor( int j = 0; j < 100; j++ ) {\n\t\t\t\ttable[i][j] = 0;\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t}\t\t\n\n\t\tcin >> w >> h;\n\n\t\tif( w == 0 && h == 0 )\n\t\t\tbreak;\n\t\t\t\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor( int i = 0; i < n; i++ ) {\n\n\t\t\tint c; cin >> c;\n\t\t\tint d; cin >> d;\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\tif( d == 0 ) {\n\n\t\t\t\ttable[x][y] = c;\n\t\t\t\ttable[x][y+1] = c;\n\n\t\t\t\ttable[x+1][y] = c;\n\t\t\t\ttable[x+1][y+1] = c;\n\n\t\t\t\ttable[x+2][y] = c;\n\t\t\t\ttable[x+2][y+1] = c;\n\n\t\t\t\ttable[x+3][y] = c;\n\t\t\t\ttable[x+3][y+1] = c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\n\n\t\t\t} else {\n\n\t\t\t\ttable[x][y] = c;\n\t\t\t\ttable[x+1][y] = c;\n\n\t\t\t\ttable[x][y+1] = c;\n\t\t\t\ttable[x+1][y+1] = c;\n\n\t\t\t\ttable[x][y+2] = c;\n\t\t\t\ttable[x+1][y+2] = c;\n\t\t\t\t\n\t\t\t\ttable[x][y+3] = c;\n\t\t\t\ttable[x+1][y+3] = c;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif( table[xs][ys] )\n\t\t\t\tsolve(xs, ys, table[xs][ys]);\n\t\t\tcout << \"NG\" << endl;\n\t\t} catch(...) {\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<utility>\nusing namespace std;\nchar m[128][128];\nvoid PutSquare(int x, int y, int c)\n{\n\tm[y][x] = m[y+1][x] = m[y+1][x+1] = m[y][x+1] = static_cast<char>(c);\n}\nbool CanReach(int sx,int sy,int gx,int gy)\n{\n\tbool f[128][128]={};\n\n\ttypedef pair<int,int>P;\n\tqueue<P>q;\n\tq.push(P(sx,sy));\n\n\tconst char c = m[sy][sx];\n\tif(!c)\n\t\treturn false;\n\tconst int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\twhile(!q.empty())\n\t{\n\t\tP p = q.front();\n\t\tq.pop();\n\t\tif(p.first==gx && p.second==gy)\n\t\t\treturn true;\n\t\tif(f[p.second][p.first] || c!=m[p.second][p.first])\n\t\t\tcontinue;\n\t\tf[p.second][p.first] = true;\n\t\tfor(int i=0; i<4; ++i)\n\t\t\tq.push(P(p.first+dx[i],p.second+dy[i]));\n\t}\n\treturn false;\n}\nint main()\n{\n\tint h, w;\n\tint sx, sy;\n\tint gx, gy;\n\tint n;\n\tint c, d, x, y;\n\twhile(scanf(\"%d%d\",&w,&h),h)\n\t{\n\t\tmemset(m,0,sizeof(m));\n\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tPutSquare(x,y,c);\n\t\t\tif(d==0)\n\t\t\t\tPutSquare(x+2,y,c);\n\t\t\telse\n\t\t\t\tPutSquare(x,y+2,c);\n\t\t}\n\t\tputs(CanReach(sx,sy,gx,gy) ? \"OK\" :\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[101][101];//y,x\nbool flag;\nint n,a,sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<101; i++)\n\t\tfor(int j=0; j<101; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tint xx = x;\n\tint yy = y;\n\n\tif(xx == gx && yy == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\txx++;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy);\n\tif(flag)\n\t\treturn;\n\n\tif(xx > 1){\n\t\txx--;\n\t\tyy++;\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n\t}\n\tif(flag)\n\t\treturn;\n\t\n\tif(yy > 1 && xx > 1){\t\n\t\txx--;\n\t\tyy--;\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n\t}\n\tif(flag)\n\t\treturn;\n\t\n\tif(yy > 1){\t\t\n\t\txx++;\n\t\tyy--;\n\t\tif(field[yy][xx] == col)\n\t\t\tDFS(xx, yy);\n\t}\n}\n\nint main(){\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\t\tcin >> n >> a;\n\t\tif(!n && !a)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0){\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+4; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+2; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w, h;\nint sx, sy;\nint gx, gy;\nint t[102][102];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool dfs(int x, int y){\n  if(x == gx && y == gy){\n    return true;\n  }\n\n  char c = t[y][x];\n  t[y][x] = 0;\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n    if(t[ny][nx] != c) continue;\n    if(dfs(nx, ny)) return true;\n  }\n\n  return false;\n}\n\nvoid solve(){\n  if(t[sy][sx] == 0){\n    cout << \"NG\" << endl;\n    return;\n  }\n  cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    cin >> sx >> sy; sx--; sy--;\n    cin >> gx >> gy; gx--; gy--;\n\n    int n;\n    cin >> n;\n\n    memset(t, 0, sizeof(t));\n\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--;\n      y--;\n\n      if(d == 0){ //脱即捉\n        for(int i = y; i < y + 2; i++){\n          for(int j = x; j < x + 4; j++){\n            t[i][j] = c;\n          }\n        }\n      }\n      else{ //巽存側\n        for(int i = y; i < y + 4; i++){\n          for(int j = x; j < x + 2; j++){\n            t[i][j] = c;\n          }\n        }\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint i,j;\nint a[105][105];\nint used[105][105];\nint h,w;\n\nvoid search(int y,int x,int c){\n  if(x<0 || y<0 || y>=h || x>=w || a[y][x]!=c)return;\n  if(used[y][x])return;\n  used[y][x]++;\n  int i;\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  rep(i,4)\n    search(y+dy[i],x+dx[i],c);\n  return;\n}\n\nint main(void) {\n  while(1){\n    cin>>w>>h;\n    if(h==0 && w==0)break;\n    rep(i,h)rep(j,w)used[i][j]=0;\n    int xs,ys,xg,yg,n;\n    cin>>xs>>ys;\n    xs--;ys--;\n    cin>>xg>>yg;\n    xg--;yg--;\n    cin>>n;\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      int p[8]={0,0,0,0,1,1,1,1};\n      int q[8]={0,1,2,3,0,1,2,3};\n      if(d)\n\trep(j,8)\n\t  a[y+q[j]][x+p[j]]=c;\n      else\n\trep(j,8)\n\t  a[y+p[j]][x+q[j]]=c;\n    }  \n    if(a[ys][xs]==0){\n      cout<<\"NG\"<<endl;\n      continue;\n    } \n    search(ys,xs,a[ys][xs]);//dfs\n    if(used[yg][xg])\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[b][a];\n\t\tif(R==map[gb][ga]){\n\t\t\tif(block(b,a)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=1;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==0) return block(b,a+1);}\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==0) return block(b+1,a);}\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==0) return block(b,a-1);}\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==0) return block(b-1,a);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2000;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n    int c[n],d[n],x[n],y[n],ca;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      if(c[i] == 0){\n        ca = 10;\n        break;\n      }else if(i == n-1){\n        ca = 0;\n      }\n    }\n    for(int i=0; i<102; i++){\n          for(int j=0; j<102; j++){\n            F[i][j]=ca;\n          }\n    }\n    for(int i=0;i<n;i++){\n      if(d[i] == 0){\n        for(int j=0;j<4;j++){\n          F[x[i]+j][y[i]] = c[i];\n          F[x[i]+j][y[i]+1] = c[i];\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x[i]][y[i]+j] = c[i];\n          F[x[i]+1][y[i]+j] = c[i];\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -2000){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std ;\n\nint map[ 100 ][ 100 ] ;\nint w ,h ;\nint gx ,gy ;\nint way ;\n\nstruct ST\n{\n\tint x ;\n\tint y ;\n} ;\n\nST s ;\n\nvoid ans()\n{\n\tqueue< ST > que ;\n\tint mx[ 4 ] = { 1 ,0 ,0 ,-1 } ;\n\tint my[ 4 ] = { 0 ,1 ,-1 ,0 } ;\n\tbool came[ 100 ][ 100 ] = { false } ;\n\tque.push( s ) ;\n\tcame[ s.y ][ s.x ] = true ;\n\twhile( ! que.empty() )\n\t{\n\t\ts = que.front() ;\n\t\tif( s.x == gx && s.y == gy )\n\t\t{\n\t\t\tcout << \"OK\" << endl ;\n\t\t\treturn ;\n\t\t}\n\t\tque.pop() ;\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\ts.x += mx[ i ] ;\n\t\t\ts.y += my[ i ] ;\n\t\t\tif( came[ s.y ][ s.x ] == false && map[ s.y ][ s.x ] == way )\n\t\t\t{\n\t\t\t\tcame[ s.y ][ s.x ] = true ;\n\t\t\t\tque.push( s ) ;\n\t\t\t\ts.x -= mx[ i ] ;\n\t\t\t\ts.y -= my[ i ] ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NG\" << endl ;\n}\n\n\nint main()\n{\n\twhile( cin >> w >> h ,h )\n\t{\n\t\tint n ;\n\t\tint color ,muki ,x ,y ;\n\t\tcin >> s.x >> s.y ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\twhile( n )\n\t\t{\n\t\t\tn-- ;\n\t\t\tcin >> color >> muki >> x >> y ;\n\t\t\tx-- ;\n\t\t\ty-- ;\n\t\t\tif( muki )\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 2 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgx-- ;\n\t\ts.x-- ;\n\t\tgy-- ;\n\t\ts.y-- ;\n\t\tway = map[ s.y ][ s.x ] ;\n\t\tif( map[ gy ][ gx ] == way )\n\t\t{\n\t\t\tans() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl ;\n\t\t}\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint f[102][102];\n\nvoid DFS(int x,int y,int c){\n    if(f[x][y]!=c)  return;\n\n    f[x][y]=10;\n    DFS(x+1,y,c);\n    DFS(x-1,y,c);\n    DFS(x,y+1,c);\n    DFS(x,y-1,c);\n}\n\nint main(){\n    int w,h;\n    int xs,ys;\n    int xg,yg;\n    int n;\n    while(true){\n        cin>>w>>h;\n        if(w+h==0)  break;\n        for(int i=1;i<=w;i++){\n            for(int j=1;j<=h;j++){\n                f[i][j]=-1;\n            }\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        for(int i=0;i<n;i++){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            if(d==1){\n                for(int j = 0; j<4; j++){\n                    for(int k = 0; k<2; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }else{\n                for(int j = 0; j<2; j++){\n                    for(int k = 0; k<4; k++){\n                        f[x+j][y+k] = c;\n                    }\n                }\n            }\n        }\n        DFS(xs,ys,f[xs][ys]);\n        if(f[xg][yg]==10){\n            cout<<\"OK\"<<endl;\n        }else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n\n#define MAX 110\n\nint map[MAX][MAX];\n\nvoid makemap(int c, int d, int x, int y);\n\nint bfs(int xs,int ys,int xg,int yg);\n\nint main()\n{\n\tint w,h,xs,ys,xg,yg,n,c,d,x,y;\n\twhile(1)\n\t{\n\tscanf(\"%d%d\",&w,&h);\n\tif(w==0 && h==0)\n\t\treturn 0;\n\tscanf(\"%d%d\",&xs,&ys);\n\tscanf(\"%d%d\",&xg,&yg);\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0;i<MAX;i++)\n\t\tfor(int j=0;j<MAX;j++)\n\t\t\tmap[i][j]=0;\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\tmakemap(c,d,x,y);\n\t}\n\tif(map[xs+1][ys+1]==0)\n\t\tprintf(\"NG\\n\");\n\tif(bfs(xs+1,ys+1,xg+1,yg+1)==0)\n\t\tprintf(\"OK\\n\");\n\telse\n\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid makemap(int c, int d, int x, int y)\n{\n\tif(d==0)\n\t\tfor(int i=x+1;i<x+5;i++)\n\t\t\tfor(int j=y+1;j<y+3;j++)\n\t\t\t\tmap[i][j]=c;\n\telse\n\t\tfor(int i=x+1;i<x+3;i++)\n\t\t\tfor(int j=y+1;j<y+5;j++)\n\t\t\t\tmap[i][j]=c;\n}\n\nint bfs(int xs,int ys,int xg,int yg)\n{\n\tint startcolor=map[xs][ys];\n\tint nowx=xs,nowy=ys;\n\tusing namespace std;\n\tqueue<int> x;\n\tqueue<int> y;\n\twhile(1)\n\t{\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint map[101][101];\nbool ch;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid dfs(int x,int y,int c){\n\tif(x==xg && y==yg)ch=true;\n\telse if(ch==false){\n\t\tmap[x][y]=-1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=x+dx[i],cy=y+dy[i];\n\t\t\tif(cx>=1 && cx<=w && cy>=1 && cy<=h  && map[cx][cy]==c)dfs(cx,cy,c);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tch=false;\n\t\tmemset(map,0,sizeof(map));\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0)break;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=y;i<y+2;i++){\n\t\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\t\tmap[j][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=y;i<y+4;i++){\n\t\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\t\tmap[j][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys]>=1)dfs(xs,ys,map[xs][ys]);\n\t\tif(ch)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a=0;\nint F[102][102];\nvoid DFS(int Xs,int Ys,int c,int Xg,int Yg){\n  if(F[Xs][Ys]!=c){\n    return;\n  }else if(Xs==Xg&&Ys==Yg){\n    a=1;\n    return;\n  }\n F[Xs][Ys]=0;\n DFS(Xs-1,Ys,c,Xg,Yg);\n DFS(Xs,Ys-1,c,Xg,Yg);\n DFS(Xs+1,Ys,c,Xg,Yg);\n DFS(Xs,Ys+1,c,Xg,Yg);\n}\n\nint main(){\n  while(1){\n    a=0;\n   int w,h,xs,ys,xg,yg,n,C;\n   cin>>w>>h;\n   if(w==0&&h==0){\n     break;\n   }\n   cin>>xs>>ys>>xg>>yg>>n;\n   int c[n],d[n],x[n],y[n];\n   for(int i=0;i<n;i++){\n     cin>>c[i]>>d[i]>>x[i]>>y[i];\n     if(xs==x[i]&&ys==y[i]){\n       C=c[i];\n     }\n      for(int j=0;j<4;j++){\n        for(int k=0;k<2;k++){\n          if(d[i]==0){\n           F[x[i]+j][y[i]+k]=c[i];\n         }else{\n           F[x[i]+k][y[i]+j]=c[i];\n         }\n       }\n     }\n    }\n    DFS(xs,ys,C,xg,yg);\n    if(a==1){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nbool block[6][110][110];\nbool visit[110][110];\n\nint main(){\n\tint w, h;\n\tint xs, ys, xg, yg;\n\tint n, c, d, x, y;\n\twhile(scanf(\"%d%d%d%d%d%d%d\", &w, &h, &xs, &ys, &xg, &yg, &n) == 7){\n\t\tmemset(block, 0, sizeof block);\n\t\tmemset(visit, 0, sizeof visit);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tint dx, dy;\n\t\t\tif(d){ dx = 2; dy = 4; }\n\t\t\telse{  dy = 2; dx = 4; }\n\n\t\t\tfor(int j = 0; j < dy; ++j)\n\t\t\tfor(int k = 0; k < dx; ++k){\n\t\t\t\tblock[c][y + j][x + k] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor(c = 5; c > 1 && !block[c][ys][xs]; --c);\n\n\t\tif(c){\n\t\t\tqueue<int> q;\n\t\t\tq.push(ys << 16 | xs);\n\t\t\tvisit[ys][xs] = true;\n\t\t\twhile(!q.empty()){\n\t\t\t\ty = q.front() >> 16;\n\t\t\t\tx = q.front() & 0xffff;\n\t\t\t\tq.pop();\n\n\t\t\t\tfor(int dy = -1; dy <= 1; ++dy)\n\t\t\t\tfor(int dx = -1; dx <= 1; ++dx){\n\t\t\t\t\tif(block[c][y+dy][x+dx] && !visit[y+dy][x+dx]){\n\t\t\t\t\t\tvisit[y+dy][x+dx] = true;\n\t\t\t\t\t\tq.push(y+dy << 16 | x+dx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tputs(visit[yg][xg] ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <utility>\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nint sx,sy,gx,gy;\nint w,h,n;\nint g[1000][1000];\nbool valid(int y, int x){ return 0<=x && x<w && 0<=y && y<h; }\n\nint main(){\n    while(cin>>w>>h && w){\n        cin>>sx>>sy>>gx>>gy;\n        sx--,sy--,gx--,gy--;\n        rep(i,h)rep(j,w)g[i][j]=0;\n        cin>>n;\n        rep(i,n){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n            if(d==0)x+=2;else y+=2;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n        }\n        int C=g[sy][sx];\n        // cout<<C<<endl;\n        // rep(i,h){\n        //     rep(j,w){\n        //         cout<<g[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n        rep(i,h)rep(j,w)g[i][j]= (g[i][j]==C) ? C : 0;\n\n        bool vis[1000][1000]={};\n        vis[sy][sx]=true;\n        if(C){\n            stack<pii> s;\n            vis[sy][sx]=true;\n            s.emplace(sy,sx);\n            while(s.size()){\n                int y,x;\n                tie(y,x) = s.top();s.pop();\n                rep(d,4){\n                    int nx=x+dx[d],ny=y+dy[d];\n                    if(!valid(ny,nx))continue;\n                    if(vis[ny][nx])continue;\n                    vis[ny][nx]=true;\n                    s.emplace(ny,nx);\n                }\n            }\n        }\n        puts(C && vis[gy][gx] ? \"OK\" : \"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 100;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\n\nvoid dfs(int x, int y){\n    maze[x][y] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) flag = 1;\n                dfs(nx, ny);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[x-1+dx][y-1+dy] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[x-1+dx][y-1+dy] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[xs][ys]) maze[i][j] = 0;\n\n    //search\n    dfs(xs-1, ys-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x < w && y>=0 && y< h);\n}\nint main(void){\n\tconst int dx[4]={0,1,0,-1};\n\tconst int dy[4]={1,0,-1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\t//printf(\"%d %d\\n\",w,h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x-1+k][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs-1][ys-1];\n\t\tif(c==0){\n\t\t\tputs(\"NG\");\n\t\t\tcontinue;\n\t\t}\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs-1;\n\t\tqy[0]=ys-1;\n\t\tf=1;\n/*\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\t\tprintf(\"%d\\n\",c);*/\n\t\twhile(f && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dx[i];\n\t\t\t\ty = qy[p] + dy[i];\n\t\t\t\tif(is(x,y) && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx[p+cnt] = x;\n\t\t\t\t\tqy[p+cnt] = y;\n\t\t\t\t\tif(x == xg-1 && y == yg-1)f=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}\n\t\tputs(f?\"NG\":\"OK\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int size = 101;\nint B[size][size];\nint V[size][size];\n\ntypedef pair <int, int> PII;\ntypedef queue <PII> QUEUE;\n\nint main() {\n    int w, h;\n    while ( cin >> w >> h && w && h ) {\n        for ( int i = 0; i < h; ++ i ) {\n            for ( int j = 0; j < w; ++ j ) {\n                B[i][j] = 0;\n                V[i][j] = 0;\n            }\n        }\n        int xs, ys, xg, yg;\n        cin >> xs >> ys >> xg >> yg;\n        xs --;\n        ys --;\n        xg --;\n        yg --;\n        int n;\n        cin >> n;\n        for ( int i = 0; i < n; ++ i ) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x --;\n            y --;\n            for ( int j = 0; j < ( d ? 4 : 2 ); ++ j ) {\n                for ( int k = 0; k < ( d ? 2 : 4 ); ++ k ) {\n                    int nx = x + k;\n                    int ny = y + j;\n                    B[ny][nx] = c;\n                }\n            }\n        }\n\n//         for ( int i = 0; i < h; ++ i ) {\n//             for ( int j = 0; j < w; ++ j ) {\n//                 cout << B[i][j];\n//             }\n//             cout << endl;\n//         }\n//         cout << endl;\n\n        if ( ! B[ys][xs] || ! B[yg][xg] ) {\n            cout << \"NG\" << endl;\n            continue;\n        }\n        \n        PII start( xs, ys );\n        V[ys][xs] = 1;\n        QUEUE Q;\n        Q.push( start );\n        bool flag = true;\n        while ( ! Q.empty() ) {\n            PII node = Q.front();\n            Q.pop();\n\n            int x = node.first;\n            int y = node.second;\n\n            if ( x == xg && y == yg ) {\n                cout << \"OK\" << endl;\n                flag = false;\n                break;\n            }\n            \n            const int dx[4] = { 1, -1, 0, 0 };\n            const int dy[4] = { 0, 0, 1, -1 };\n            for ( int i = 0; i < 4; ++ i ) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if ( nx < 0 || nx >= w ) continue;\n                if ( ny < 0 || ny >= h ) continue;\n                if ( B[y][x] != B[ny][nx] ) continue;\n                if ( V[ny][nx] ) continue;\n                V[ny][nx] = 1;\n                PII next( nx, ny );\n                Q.push( next );\n            }\n        }\n\n        if ( flag ) cout << \"NG\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvoid dfs(int a[][101] ,int x , int y , int w , int h , int xg , int yg , int sc){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(a[tx][ty]!=sc || a[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( a,tx,ty,w,h,xg,yg,sc);\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tint board[101][101]={0};\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(board ,xs,ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define pint pair<int,int>\nusing namespace std;\nint main(){\n\tint dx[4] = {-1,0,1,0};\n\tint dy[4] = {0,1,0,-1};\n\tint w,h,xs,ys,xg,yg,n;\n\twhile(cin >> w >> h && (w || h)) {\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tint b[110][110] = {};\n\t\tint\tc,d,x,y;\n\t\trep(i,n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\trep(j,2) {\n\t\t\t\trep(k,4) {\n\t\t\t\t\tif(d==0) b[y+j][x+k] = c;\n\t\t\t\t\telse b[y+k][x+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(b[ys][xs] != b[yg][xg] || b[ys][xs] == 0) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tqueue<pint> q;\n\t\tpint p;\n\t\tp.first = ys, p.second = xs;\n\t\tq.push(p);\n\t\tconst int b_color = b[ys][xs];\n\t\tbool f = 0;\n\t\twhile(!q.empty()) {\n\t\t\tpint a = q.front(); q.pop();\n\t\t\tb[a.first][a.second] = 0;\n\t\t\tif(a.first == yg && a.second == xg) {\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i,4) {\n\t\t\t\tif(b[a.first+dy[i]][a.second+dx[i]] == b_color) {\n\t\t\t\t\tpint e;\n\t\t\t\t\te.first = a.first+dy[i], e.second = a.second+dx[i];\n\t\t\t\t\tq.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint xs,ys,c,a[105][105],memo[105][105],ans,p,w,h;\n\nint solve(int yg,int xg){\n\n  if(a[yg][xg] != p) return 0;\n\n  a[yg][xg] = -1;\n\n  if(xs == xg && ys == yg) return ans = 1;\n\n  else if(yg - 1 > 0 && a[yg-1][xg] == p) solve(yg-1,xg);\n  else if(xg - 1 > 0 && a[yg][xg-1] == p) solve(yg,xg-1);\n  else if(yg + 1 <= w && a[yg+1][xg] == p) solve(yg+1,xg);\n  else if(xg + 1 <= h && a[yg][xg+1] == p) solve(yg,xg+1);\n}\n\nint main(){\n  int xg,yg,n,d,x,y;\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    memset(a,0,sizeof(a));\n    memset(memo,0,sizeof(memo));\n    ans = 0;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n\tfor(int i=y;i<y+2;i++){\n\t  for(int j=x;j<x+4;j++) a[i][j] = c;\n\t}\n      }\n\n      else if(d == 1){\n\tfor(int i=y;i<y+4;i++){\n\t  for(int j=x;j<x+2;j++) a[i][j] = c;\n\t}\n      }\n    }\n\n    p = a[yg][xg];\n    solve(yg,xg);\n\n    if(ans == 1)   cout << \"OK\" << endl;\n    else if(ans == 0)cout << \"NG\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105, 0));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool a = false;\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\tif ((nx + 1) >= 0 && ny >= 0 && (nx + 1) < h && ny < w)if (grid[nx + 1][ny] == grid[nx][ny])a |= dfs(nx + 1, ny);\n\tif (nx >= 0 && (ny + 1) >= 0 && nx < h && (ny + 1) < w)if (grid[nx][ny + 1] == grid[nx][ny])a |= dfs(nx, ny + 1);\n\tif ((nx - 1) >= 0 && ny >= 0 && (nx - 1) < h && ny < w)if (grid[nx - 1][ny] == grid[nx][ny])a |= dfs(nx - 1, ny);\n\tif (nx >= 0 && (ny - 1) >= 0 && nx < h && (ny - 1) < w)if (grid[nx][ny - 1] == grid[nx][ny])a |= dfs(nx, ny - 1);\n\t//return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn a;\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\tloop(j, w)\n\t\t\t{\n\t\t\tcout << grid[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tgrid = vector<vector<int> >(105, vector<int>(105, 0));\n\t\t\tgrid_visited = vector <vector<bool > > (105, vector<bool>(105, false));\n\t\t\ta = false;\n\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nint xg, yg, xs, ys;\nint data[102][102];\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\nbool dfs(int, int, int);\n\nmain(){\n  int c, d, x, y;\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    int n;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      int tw, th;\n      if(d==0){\n\ttw=4;\n\tth=2;\n      }else{\n\ttw=2;\n\tth=4;\n      }\n      for(int i=0;i<=th-1;i++){\n\tfor(int j=0;j<=tw-1;j++){\n\t  data[y+i][x+j]=c;\n\t}\n      }\n    }\n    if(dfs(ys, xs, data[ys][xs])) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}\n\nbool dfs(int y, int x, int c){\n  if(c==0 || data[y][x]!=c) return false;\n  if(y==yg && x==xg) return true;\n  data[y][x]=0;\n  for(int i=0;i<4;i++){\n    if(dfs(y+dy[i], x+dx[i], c)) return true;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[101][101];\n\nint DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='w'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_Y(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='y'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_G(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='g'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\nint DFS_B(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='b'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n  int DFS_R(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='r'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n\nint main(){\n  int c[5];\n  int d[1];\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  int x[n];\n  int y[n];\n  cin>>w>>h;\n  while(w!=0){\n    int a=0;\n    int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n        int a=0;\n        int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      cnt=DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      cnt=DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      cnt=DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      cnt=DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      cnt=DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\tfor(int y = 0; y < 102; y++){\n\t\tfor(int x = 0; x < 102; x++){\n\t\t\tF[y][x] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\" << endl;\n\t}else{\n\t\tcout << \"NG\" << endl;\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint b[100][100];\nint vis[100][100];\n\nint w, h;\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w + h) {\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\txs--, ys--, xg--, yg--;\n\n\t\tmemset(b, 0, sizeof b);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--, y--;\n\t\t\tint H = 2, W = 4;\n\t\t\tif(d == 1) swap(H, W);\n\t\t\tfor(int dx = 0; dx < W; dx++) {\n\t\t\t\tfor(int dy = 0; dy < H; dy++) {\n\t\t\t\t\tb[y + dy][x + dx] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(b[ys][xs] != b[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push({ xs, ys });\n\t\tmemset(vis, 0, sizeof vis);\n\t\tvis[ys][xs] = 1;\n\t\twhile(q.size()) {\n\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\tq.pop();\n\t\t\tint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(in(nx, ny) && b[ny][nx] == b[ys][xs] && vis[ny][nx] == 0) {\n\t\t\t\t\tvis[ny][nx] = 1;\n\t\t\t\t\tq.push({ nx, ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vis[yg][xg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg,ok;\n\nvoid Maze(int X,int Y,int C){\n\t//cout << X<<Y<<F[X][Y]<<endl;\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\t\n\n\tif(X==xg&&Y==yg){\n\t\tcout << \"OK\"<<endl;\n\t\tok++;\n\t}\n\n\tF[X][Y]='.';\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tok=0;\n\t\tfor(int i=1; i<=100; i++)\n\t\t\tfor(int j=1; j<=100; j++)\n\t\t\t\tF[j][i]=0;\n\n\n\t\tfor(int i=0; i<102;i++){\n\t\t\tF[0][i]=6;\n\t\t\tF[i][0]=6;\n\t\t}\n\n\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\n\t\tfor(int i=0; i<=w;i++)\n\t\t\t\tF[w+1][i]=6;\n\n\t\tfor(int i=0; i<=h;i++)\n\t\t\t\tF[i][h+1]=6;\n\n\n\t\tint N=0;\n\t\twhile(N<n){\n//cout <<N;\n\t\t\tcin >>c>>d>>x>>y;\n//cout<<c<<d<<x<<y<<endl;\n\t\t\tif(d){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tF[i][j]=c;\n//cout <<F[i][j];\n\t\t\t\t}\n//cout <<endl;\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tF[i][j]=c;\n//cout <<F[i][j];\n\t\t\t\t\t}\n//cout <<endl;\n\t\t\t}\n\t\t\tN++;\n\t\t}\n\n//for(int i=0; i<=101; i++){\n\t//for(int j=0; j<=101; j++){\n\t\t//cout <<F[j][i];\n\t\t//}\n\t//cout << endl;\n//}\n\t\t\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t\tif(ok==0)\n\t\t\tcout <<\"NG\"<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int x, int y, int c){\n      if(F[x][y]!=c)\n            return;\n\n      F[x][y] = -1;\n\n      DFS(x+1, y  , c);\n      DFS(x  , y+1, c);\n      DFS(x-1, y  , c);\n      DFS(x  , y-1, c);\n}\n\nint main(){\n      int w,h, xs,ys, xg,yg, n;\n      while(1){\n            cin >> w >> h;\n            if(w==0)    break;\n            cin >> xs >> ys;\n            cin >> xg >> yg;\n            cin >> n;\n\n            int c, d, x, y;\n            for(int i=1; i<=n; i++){\n                  cin >> c >> d >> x >> y;\n                  if(d==0){\n                        for(int fx=x; fx<=x+3; fx++){\n                        F[fx][y]   = c;\n                        F[fx][y+1] = c;\n                        }\n                  }\n                  else if(d==1){\n                        for(int fy=y; fy<=y+3; fy++){\n                        F[x][fy]   = c;\n                        F[x+1][fy] = c;\n                        }\n                  }\n            }\n\n            DFS(xs, ys, F[x][y]);\n            if(F[xg][yg]==-1)\n                  cout << \"OK\" << endl;\n            else\n                  cout << \"NG\" << endl;\n      }\n\n      return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  if(x == 8){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y, color;\n\tvector< vector< int > > field;\n\tqueue< complex< int > > que;\n\tbool exist;\n\t\n\twhile(cin >> w >> h, w){\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfield.clear();\n\t\t\n\t\tfield.resize(w);\n\t\tfor(int i = 0; i < w; ++i) field[i].resize(h);\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 2; ++j){\n\t\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\texist = false;\n\t\tif(field[xs - 1][ys - 1] != 0){\n\t\t\tque.push(complex< int >(xs - 1, ys - 1));\n\t\t\tcolor = field[xs - 1][ys - 1];\n\t\t\t\n\t\t\twhile(!que.empty()){\n\t\t\t\tcomplex< int > pos = que.front();\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tif(pos.real() == xg - 1 && pos.imag() == yg - 1){\n\t\t\t\t\texist = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pos.real() > 0 && field[pos.real() - 1][pos.imag()] == color) que.push(pos + complex< int >(-1, 0));\n\t\t\t\tif(pos.real() < w - 1 && field[pos.real() + 1][pos.imag()] == color) que.push(pos + complex< int >(1, 0));\n\t\t\t\tif(pos.imag() > 0 && field[pos.real()][pos.imag() - 1] == color) que.push(pos + complex< int >(0, -1));\n\t\t\t\tif(pos.imag() < h - 1 && field[pos.real()][pos.imag() + 1] == color) que.push(pos + complex< int >(0, 1));\n\t\t\t\t\n\t\t\t\tfield[pos.real()][pos.imag()] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << (exist ? \"OK\" : \"NG\") << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int h, int w, int color) {\n\tif (map[h][w] != color)\n\t\treturn;\n\tmap[h][w] = 0;\n\troute(h, w + 1, color);\n\troute(h + 1, w, color);\n\troute(h, w - 1, color);\n\troute(h - 1, w, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\n\twhile (1) {\n\t\tcin >> h >> w >> xs >> ys >> xg >> yg >> n;\n\t\tif (h == 0 && w == 0)\n\t\t\tbreak;\n\n\t\tint c, d, x, y;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 1; j <= 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y+1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j <= 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y+j] = c;\n\t\t\t}\n\t\t}\n\t\tint color = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\tif (xg == 0 && yg == 0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint b[100][100];\nint vis[100][100];\n\nint w, h;\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w + h) {\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\txs--, ys--, xg--, yg--;\n\n\t\tmemset(b, 0, sizeof b);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--, y--;\n\t\t\tint H = 2, W = 4;\n\t\t\tif(d == 1) swap(H, W);\n\t\t\tfor(int dx = 0; dx < W; dx++) {\n\t\t\t\tfor(int dy = 0; dy < H; dy++) {\n\t\t\t\t\tb[y + dy][x + dx] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(b[ys][xs] == 0 || b[ys][xs] != b[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push({ xs, ys });\n\t\tmemset(vis, 0, sizeof vis);\n\t\tvis[ys][xs] = 1;\n\t\twhile(q.size()) {\n\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\tq.pop();\n\t\t\tint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(in(nx, ny) && b[y][x] == b[ny][nx] && vis[ny][nx] == 0) {\n\t\t\t\t\tvis[ny][nx] = 1;\n\t\t\t\t\tq.push({ nx, ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vis[yg][xg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\n\nshort color;\n\tqueue<P> que;\n\t\nbool check(short maze[MAX][MAX])\n{\n\tque.push(S);\n\n\tcolor = maze[S.second][S.first];\n\tif(color < 0)\n\t\treturn false;\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\tshort maze[MAX][MAX];\n\twhile(cin >> w >> h, w){\n\t/*\trep(i,MAX){\n\t\t\trep(j,MAX)\n\t\t\t\tmaze[i][j] = -10;\n\t\t}*/\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(/*maze[S.second][S.first] > 0 && */maze[S.second][S.first] == maze[G.second][G.first] && check(maze))\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<MAX+2; i++ ) {\n      for ( int j=0; j<MAX+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n\n    next.push(y*1000 + x );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    /*\n    for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n\tcout << map[i+1][j+1];\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n    int xn,yn;\n    if ( map[yg][xg] == sc ) {\n\t\n      while ( !next.empty() ) {\n\tpoint = next.front();\n\tnext.pop();\n\txn = point%1000;\n\tyn = point/1000;\n\n\tif (map[yn][xn] == 0 )\n\t  continue;\n\n\tif (point == yg*1000+xg) {\n\t  goal = true;\n\t  break;\n\t}\n\n\tfor ( int i=0; i<4; i++ ) {\n\t  if ( check[yn+dy[i]][xn+dx[i]] ) {\n\t    check[yn+dy[i]][xn+dx[i]] = false;\n\t    if ( map[yn+dy[i]][xn+dx[i]] == sc ) {\n\t      next.push((yn+dy[i])*1000+ xn +dx[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[120][120] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y; di++){\n                for(int dj = x;dj < dw + x;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[120][120] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        if(field[xg][yg] != C || C == 0)cout<<\"NG\"<<endl;\n        else {\n            while(!Q.empty()){\n                point P = Q.front();\n                Q.pop();\n                for(int i = 0;i < 4;i++){\n                    point p = point(P.x + dx[i],P.y + dy[i]);\n                    if(0 <= p.x && p.x <= w && 0 <= p.y && p.y <= h){\n                        if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n\n                            vis[p.x][p.y] = true;\n                            Q.push(p);\n                        }\n                    }\n                }\n            }\n\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        }\n/*\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<field[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl<<endl;\n        for(int i = 0;i < h;i++){\n            for(int j = 0;j < w;j++){\n                cout<<vis[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        //cout<<C<<\"---\"<<field[xg][yg]<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint dx[] = { 1,-1,0,0 };\nint dy[] = { 0,0,1,-1 };\nint w, h;\n\nint check(int xs, int ys, int xg, int yg ,int c, int board[110][110]) {\n\tint used[110][110] = { 0 };\n\tqueue<pl> q;\n\tq.push({ xs, ys });\n\n\twhile (!q.empty()) {\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ddx = dx[i] + x;\n\t\t\tint ddy = dy[i] + y;\n\t\t\tif (ddx >= 1 && ddx <= w && ddy >= 1 && ddy <= h && !used[ddy][ddx]) {\n\t\t\t\tused[ddy][ddx] = 1;\n\t\t\t\tif (ddy == yg && ddx == xg)return 1;\n\t\t\t\telse if (board[ddy][ddx] == c) {\n\t\t\t\t\tq.push({ddx,ddy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w, h) \n\t{\n\t\tint xs, ys, xg, yg;\n\t\tint n;\n\t\tint board[110][110] = { 0 };\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{ \n\t\t\tint c,d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d){\n\t\t\t\tfor (int i = y; i < y+2; i++) {\n\t\t\t\t\tfor (int j = x; j < x+8; j++) \n\t\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = y; i < y+8; i++) {\n\t\t\t\t\tfor (int j = x; j < x+2; j++)\n\t\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (check(xs, ys, xg, yg, board[ys][xs], board))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==1){//???\n\t\t\t\tfor(m=0;m<2;m++){\n\t\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//?¨?\n\t\t\t\tfor(m=0;m<4;m++){\n\t\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(brock[xs][ys]!=brock[xg][yg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[xs][ys];\n\t\t\tds[xs][ys]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==xg&&ba.b==yg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[xg][yg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=w&&ba.b+q[i]>0&&ba.b+q[i]<=h&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=ba.c;\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int xs,int ys){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[xg-1][yg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(xs+1,ys) + solve(xs,ys+1)+ solve(xs-1,ys) + solve(xs,ys-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<int,int> P;\nP S,G;\nint w,h;\nint maze[MAX][MAX];\nint color;\n\nbool check()\n{\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tint nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tint n,c,d,x,y;\n\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(check())\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n/*\n\t\trep(i,y){\n\t\t\trep(j,x)\n\t\t\t\tprintf(\"%2d\", maze[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\n*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(x==xs&&ys==y&&ban[x][y]==-1)return false;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string.h>\nusing namespace std;\n\nint map[200][200];\nbool reach[200][200];\nint w, h;\n\ntypedef struct {\n\tint x;\n\tint y;\n} SIZE;\n\nSIZE size[2] = {\n\t{4, 2}, {2, 4}\n};\n\nint angle[][2] = {\n\t{-1, 0}, {0, -1}, {1, 0}, {0, 1}\n};\n\nvoid search(int x, int y)\n{\n\tif (x <= 0 || x > w || y <= 0 || y > h){\n\t\treturn;\n\t}\n\t\n\treach[x][y] = true;\n\t\n\tfor (int i = 0; i < 4; i++){\n\t\tif (\n\t\treach[x + angle[i][0]][y + angle[i][1]] == false &&\n\t\tmap[x + angle[i][0]][y + angle[i][1]] == map[x][y]\n\t\t){\n//\t\t\treach[x + angle[i][0]][y + angle[i][1]] = true;\n\t\t\tsearch(x + angle[i][0], y + angle[i][1]);\n\t\t}\n\t}\n}\n\t\t\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(map, 0, sizeof(reach));\n\t\t\n\t\tint xs, ys;\n\t\tscanf(\"%d %d\", &xs, &ys);\n\t\t\n\t\tint xg, yg;\n\t\tscanf(\"%d %d\", &xg, &yg);\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tfor (int j = 0; j < size[d].y; j++){\n\t\t\t\tfor (int k = 0; k < size[d].x; k++){\n\t\t\t\t\tmap[x + k][y + j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%d \", map[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n*/\t\t\n\t\tsearch(xs, ys);\n/*\t\t\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tprintf(\"%d \", reach[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n*/\t\t\n\t\tif (reach[xg][yg]){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[101][101] = {0};\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n    \n    while(true){\n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy >> n;\n            Solve s(w, h, sx, sy, gx, gy);\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\" << endl;\n            }else{\n                cout << \"NG\" << endl;\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> #include<string> #include<string.h> #include<cstring> #include<cmath> #include<algorithm> #include<stdlib.h> #include<queue> #include<map> #include<vector> #include<list> #include<stack> #include<functional>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end() #define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef unsigned long long ull; typedef long long ll;\n\nconst int INF=100000000; int dx[4]={1,0,-1,0}; int dy[4]={0,1,0-1};\n\ntypedef pair<int ,int > P;\n\nchar maze[105][105];\n\nint sx,sy; int gx,gy; int w,h;\n\nchar sc; //スタート地点のカラー\n\n//stdin //stdout\n\nvoid dfs(int x,int y) { maze[x][y]='9';\n\nfor(int i=-1;i<=1;i++) { for(int j=-1;j<=1;j++) { int nx=x+i; int ny=y+j;\n\nif(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[nx][ny] != '0'&&maze[nx][ny] != '9') { dfs(nx,ny); }\n\n} } return ; }\n\nvoid solve() {\n\nrep(i,101) rep(j,101) maze[i][j]='0';\n\nint n; char c; int d; int x,y;\n\ncin>>sy>>sx; cin>>gy>>gx;\n\ncin>>n;\n\nrep(i,n) { cin>>c>>d>>y>>x;\n\nif(d==1) { rep(i,4) { rep(j,2) { maze[x+i][y+j]=c;\n\n} } } else if (d==0) { rep(i,2) { rep(j,4) { maze[x+i][y+j]=c;\n\n} } }\n\n} //6 6 //1 1 //3 6 //2 //1 0 1 1 //1 1 3 3 // rep(i,w+1) // { // rep(j,h+1) // { // cout<<maze[i][j]; //// } // cout<<endl; // } //// cout<<maze[gx][gy]<<endl;\n\nif(maze[sx][sy]=='0') { cout<<\"NG\"<<endl; return; } else { sc=maze[sx][sy]; dfs(sx,sy); }\n\n//rep(i,w+1) //{ // rep(j,h+1) // { // cout<<maze[i][j];\n\n// } // cout<<endl; //}\n\nif(maze[gx][gy]=='9') { cout<<\"OK\"<<endl; return; } else { cout<<\"NG\"<<endl; return; }\n\n}\n\nint main() {\n\nwhile(cin>>w>>h) { if(w==0 && h==0) { return 0; } else { solve(); } }\n\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n\n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n        \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            g[y][x] = -1;\n            dfs(nx, ny);\n        }\n    }\n    \n    return;\n}\n\nint main(){ \n    while(1){\n        cin >> weight >> hight;\n\n        if(weight == 0 && hight == 0){\n            break;\n        }\n        \n        int dn, c, d, x, y;\n        flag = false;\n        g[101][101] = {};\n        \n        cin >> sx >> sy >> gx >> gy >> dn;\n        \n        for(int i = 0;i < dn;i++){\n            cin >> c >> d >> x >> y;\n            \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n        \n        sc = g[sy][sx];\n        dfs(sx, sy);\n        \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 0207 */\n#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint sx,sy,ex,ey;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y]||color==0)return 0;\n\tM[x][y]=0;\n\tif(x==ex&&y==ey)return 1;\n\tif(walk(x+1,y,color)|| walk(x-1,y,color)|| walk(x,y+1,color)|| walk(x,y-1,color))return 1;\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i=1;i<=h;i++){\n\t\t// \tfor(int j=1;j<=w;j++){\n\t\t// \t\tcout<<M[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tif((sy==ey&&sx==ex)||walk(sx,sy,M[sx][sy]))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t// if(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\t// else cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nconst int MAX_W = 100, MAX_H = 100;\n\ntypedef std::pair<int,int> P;\nint map[MAX_H + 1][MAX_W + 1], w, h;\n\nint bfs(P sp, P gp, int c){\n\t//½±Æª é©ði[\n\tint f[MAX_H + 1][MAX_W + 1] = {{0}};\n\tstd::queue<P> q;\n\tq.push(P(sp.first, sp.second));\n\t\n\twhile(q.size()){\n\t\tP p = q.front(); q.pop();\n\t\t//S[Å«½ç¬÷\n\t\tif(p.first == gp.first && p.second == gp.second && map[p.second][p.first] == c)return 1;\n\t\t\n\t\tint vy[4] = {-1,1,0,0}, vx[4] = {0,0,-1,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = p.first + vx[i],\n\t\t\t\tny = p.second + vy[i];\n\t\t\tif(nx >= 0 && nx <= w && ny >= 0 && ny <= h && \n\t\t\t\t map[ny][nx] == c && !f[ny][nx]){\n\t\t\t\tq.push(P(nx,ny));\n\t\t\t\tf[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t//ÅãÜÅS[Å«È¢Èç¸s\n\treturn 0;\n}\n\nint main(){\n\tP sp, gp;\n\twhile(std::cin >> w >> h, w && h){\n\t\tmemset(map,0,sizeof(map));\n\t\tstd::cin >> sp.first >> sp.second;\n\t\tstd::cin >> gp.first >> gp.second;\n\n\t\tint n;\n\t\tstd::cin >> n;\n\t\t//ubNÌÝu\n\t\twhile(n--){\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint mx, my;\n\t\t\tif(d)//w < h\n\t\t\t\tmy = 4, mx = 2;\n\t\t\telse//w > h\n\t\t\t\tmx = 4, my = 2;\n\t\t\tfor(int i=y;i<y+my;i++)\n\t\t\t\tfor(int j=x;j<x+mx;j++)\n\t\t\t\t\tmap[i][j] = c;\n\t\t}\n\n\t\tint sc = map[sp.second][sp.first];\n\n\t\t//bfsÅS[Å«é©mF\n\t\tif(bfs(sp, gp, sc))std::cout << \"OK\" << std::endl;\n\t\telse{std::cout << \"NG\" << std::endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }\n    if(C[xg][yg] != -1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[110][110];\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    while(true){\n        int w, h, sx, sy, gx, gy, n, c, d, x, y;\n        \n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy;\n            \n            Solve s(w, h, sx, sy, gx, gy);\n            \n            cin >> n;\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\\n\";\n            }else{\n                cout << \"NG\\n\";\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint flag=0;\nint mp[102][102];\nint sn[102][102];\nint bc;\n\nint px[4]={0,1,0,-1};\nint py[4]={1,0,-1,0};\n\nint slv(int xs,int ys);\n\nint w,h,xg,yg;\nint n,c,d,x,y;  \n\nint main(){\n  int xs,ys;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0)return(0);\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    flag=0;\n    cin>>n;\n    memset(mp,0,sizeof(mp));\n    memset(sn,0,sizeof(sn));\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      if(d==1){\n\tfor(int j=0;j<4;j++){\n\t  for(int k=0;k<2;k++)mp[x+k][y+j]=c;\n\t}\n      }\n      else{\n\tfor(int j=0;j<2;j++){\n\t  for(int k=0;k<4;k++)mp[x+k][y+j]=c;\n\t}\n      }\n    }\n    \n    bc=mp[xs][ys];\n    \n    slv(xs,ys);\n    \n    if(flag)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    \n  }\n}\n\nint slv(int xs,int ys){\n  if(xs==xg && ys==yg){\n    flag=1;\n    return(0);\n  }\n  \n  for(int i=0;i<4;i++){\n    xs+=px[i];\n    ys+=py[i];\n    if(bc==mp[xs][ys] && sn[xs][ys]==0){\n      sn[xs][ys]=1;\n      slv(xs,ys);\n    }\n    xs-=px[i];\n    ys-=py[i];\n  }\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=9;\n\tDFScolor(X-1,Y,color);\n\tDFScolor(X,Y+1,color);\n\tDFScolor(X+1,Y,color);\n\tDFScolor(X,Y-1,color);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==9)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <string>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstring bfs(int a[101][101], int sx, int sy, int gx, int gy, int w, int h)\n{\n\tint s, t, m = a[sy][sx];\n\tbool vis[101][101];\n\tstring str = \"NG\";\n\tqueue<Pa> que;\n\tPa pa;\n\tfill(&vis[0][0], &vis[h+1][w+1], true);\n\t\n\tque.push(Pa(sy, sx));\n\tvis[sy][sx] = false;\n\t\n\twhile(!que.empty()){\n\t\tpa = que.front();\n\t\tque.pop();\n\t\tif(pa.first == gy && pa.second == gx){\n\t\t\tstr = \"OK\";\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ts = pa.first + dy[i];\n\t\t\tt = pa.second + dx[i];\n\t\t\tif(1 <= s && s <= h && 1 <= t && t <= w){\n\t\t\t\tif(vis[s][t] && m == a[s][t]){\n\t\t\t\t\tque.push(Pa(s, t));\n\t\t\t\t\tvis[s][t] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str;\n}\n\nint main()\n{\n\tint a[101][101], w, h, sx, sy, gx, gy, s, t, u, v, n;\n\t\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[0][0], &a[h+1][w+1], -1);\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u >> v;\n\t\t\tif(t == 0){\n\t\t\t\tfor(int i = v; i <= v+1; i++){\n\t\t\t\t\tfor(int j = u; j <= u+3; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i = v; i <= v+3; i++){\n\t\t\t\t\tfor(int j = u; j <= u+1; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, sx, sy, gx, gy, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg, w,h;\n\nvoid dfs(int target, int x, int y){\n    if(x < 0 || y < 0 || x >= w || y >= h) return;\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 9;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n    return;\n}\n\nint main(){\n    int xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,h) rep(j,w) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        xs--; ys--; xg--; yg--;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            rep(j, (d?4:2)) rep(k, (d?2:4)) blocks[x + j][y + k] = c;\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 102\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid input_data(void);  //データ入力用関数\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    memset(mass,0,sizeof(mass));\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    input_data();\n    \n    make_mass();\n\n    solve();\n    if(scolor!=0 && mass[sy][sx]==mass[gy][gx]){\n      if(goal==1){\n\tcout<<\"OK\"<<endl;\n      } else {\n\tcout<<\"NG\"<<endl;\n      }\n    }\n    else {\n      cout<<\"NG\"<<endl;\n    }\n  }\n  \n  return 0;\n}\nvoid input_data(void){\n  \n  cin>>sx>>sy;\n  cin>>gx>>gy;\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>c[i]>>d[i]>>x[i]>>y[i];\n\n  }\n  \n  return;\n}\nvoid make_mass(void){\n  \n  int i,j;\n  \n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    switch(d[i]){\n    case 0:              //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n      break;\n    case 1:              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n      break;\n    }\n  }\n  \n  scolor=mass[sy][sx];\n  \n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      if(scolor!=mass[i][j]){\n\tmass[i][j]=0;\n      }\n    }\n  }\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint map[150][150]={};\nint gone[150][150]={};\n\nint gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nbool dfs(int nx,int ny){\n\tif(gone[nx][ny])return false;\n\tgone[nx][ny]=1;\n\tif(nx == gx && ny == gy)return true;\n\tbool res = false;\n\trep(i,4){\n\t\tint tx = nx+dx[i],ty=ny+dy[i];\n\t\tif(map[tx][ty]!=map[nx][ny])continue;\n\t\tres |= dfs(tx,ty);\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint w,h;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tint sx,sy,n;\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(gone,0,sizeof(gone));\n\t\trep(i,n){\n\t\t\tint c,d,nx,ny;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&nx,&ny);\n\t\t\tint fx=2,fy=4;\n\t\t\tif(d==0)swap(fx,fy);\n\t\t\trep(x,fx)rep(y,fy){\n\t\t\t\tmap[x+nx][y+ny]=c;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(y,20)rep(x,20){\n\t\t\tprintf(\"%d%c\",map[x][y],x==19?'\\n':' ');\n\t\t}*/\n\t\tif(map[sx][sy]!=0 && dfs(sx,sy))printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint a[103][103],gx,gy;\nbool f(int sx,int sy,int c)\n{\n\tif(sx==gx&&sy==gy)return true;\n\tif(a[sy][sx]!=c)return false;\n\ta[sy][sx]=0;\n\tif(f(sx+1,sy,c)||f(sx-1,sy,c)||f(sx,sy+1,c)||f(sx,sy-1,c))return true;\n\treturn false;\n}\nint main()\n{\n\tint h,w,sx,sy,n,i,j,c,d,x,y,\n\t\tdx[2][8]={{0,1,2,3,0,1,2,3},{0,0,0,0,1,1,1,1}},\n\t\tdy[2][8]={{0,0,0,0,1,1,1,1},{0,1,2,3,0,1,2,3}};\n\twhile(scanf(\"%d%d\",&w,&h),h)\n\t{\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\tfor(i=0;i<103;++i)for(j=0;j<103;++j)a[i][j]=0;\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<8;++i) a[y+dy[d][i]][x+dx[d][i]]=c;\n\t\t}\n\t\tif(a[sy][sx]&&f(sx,sy,a[sy][sx]))puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = 0;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c,d,x,y;\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n      if(d==1){\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[105][105];\nint w , h , xg , yg , sc;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {\n\t\tb=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=sc || board[tx][ty]==0 || b ) continue;\n\t\tdfs( tx,ty );\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse  dfs( xs , ys );\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<h+2; i++ ) {\n      for ( int j=0; j<w+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n    next.push(y*1000 + x );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    /*\n    for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n\tcout << map[i+1][j+1];\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n    if ( map[yg][xg] == sc ) {\n\t\n      while ( !next.empty() ) {\n\tpoint = next.front();\n\tnext.pop();\n\n\tcheck[point/1000][point%1000] = false;\n\tif (map[point/1000][point%1000] == 0 )\n\t  continue;\n\n\tif (point == yg*1000+xg) {\n\t  if ( sc == map[yg][xg] )\n\t    goal = true;\n\t  break;\n\t}\n\tfor ( int i=0; i<4; i++ ) {\n\t  if ( check[point/1000+dy[i]][point%1000+dx[i]] ) {\n\t    check[point/1000+dy[i]][point%1000+dx[i]] = false;\n\t    if ( map[point/1000+dy[i]][point%1000+dx[i]] == sc ) {\n\t      next.push((point/1000+dy[i])*1000+point%1000+dx[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n\n\n  }\n\n\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nint w,h;\nint masu[100][100];\nint uramasu[100][100];\nint stx,sty;\nint gox,goy;\nint flg;\n\nvoid saiki(int x,int y,int col){\n\t\n\tif(x==gox && y==goy){\n\t\tflg=1;\n\t}\n\t\n\tif(x+1<w && masu[x+1][y]==col && uramasu[x+1][y]==0){\n\t\turamasu[x+1][y]=1;\n\t\tsaiki(x+1,y,col);\n\t}\n\t\n\tif(y+1<h && masu[x][y+1]==col && uramasu[x][y+1]==0){\n\t\turamasu[x][y+1]=1;\n\t\tsaiki(x,y+1,col);\n\t}\n\t\n\tif(x-1>=0 && masu[x-1][y]==col && uramasu[x-1][y]==0){\n\t\turamasu[x-1][y]=1;\n\t\tsaiki(x-1,y,col);\n\t}\n\t\n\tif(y-1>=0 && masu[x][y-1]==col && uramasu[x][y-1]==0){\n\t\turamasu[x][y-1]=1;\n\t\tsaiki(x,y-1,col);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tflg=0;\n\t\tif(w==0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d%d\",&stx,&sty);\n\t\tscanf(\"%d%d\",&gox,&goy);\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\t\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tmasu[i][j]=0;\n\t\t\t\turamasu[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tswitch(d){\n\t\t\t\tcase 0:\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tmasu[i+x][j+y]=c;\n\t\t\t\t\t}\n\t\t\t\t}break;\n\t\t\t\t\n\t\t\t\tcase 1:\n\t\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tmasu[i+x][j+y]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsaiki(stx,sty,masu[stx][sty]);\n\t\t\n\t\tif(flg==0){\n\t\t\tputs(\"NG\");\n\t\t}else{\n\t\t\tputs(\"OK\");\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tif(masu[j][i]==0){\n\t\t\t\t\tprintf(\" \");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d \",masu[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint block[101][101];\nint oblock[101][101];\nint xg,yg,w,h;\n\nint go (int xs, int ys) {\n\t//cout << xs << \" \" << ys << endl;\n\toblock[xs][ys] = 1;\n\tif ( xs > w && ys > h ) {\n\t\treturn 0;\n\t}\n//\telse if ( xs == w && ys == h ) {cout >> \"NG\" >> endl; return 0;}\n\tif ( xs > 1 && block[xs-1][ys] == block[xs][ys] && !oblock[xs-1][ys] ){ go( xs-1,ys ); }\n\tif ( ys > 1 && block[xs][ys-1] == block[xs][ys] && !oblock[xs][ys-1] ){ go( xs,ys-1 ); }\n\tif ( xs < w && block[xs+1][ys] == block[xs][ys] && !oblock[xs+1][ys] ){ go( xs+1,ys ); }\n\tif ( ys < h && block[xs][ys+1] == block[xs][ys] && !oblock[xs][ys+1] ){ go( xs,ys+1 ); }\n}\n\nint main() {\n\twhile ( cin >> w && cin >> h ) {\n\t\tif ( !(w + h) )\tbreak;\n\t\t//各ブロックの初期化\n\t\tfor ( int i = 0; i < w; i++ ) {\n\t\t\tfor ( int j = 0; j < h; j++ ) {\n\t\t\t\tblock[i][j] = 0;\n\t\t\t\toblock[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint n,xs,ys;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\t//各ブロックの情報の入力\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint tate,yoko;\n\t\t\tif ( d ) {yoko=2;tate=4;}\n\t\t\telse {yoko=4;tate=2;}\n\t\t\t//カラーの入力\n\t\t\tfor ( int j = x; j < x + yoko; j++ ) {\n\t\t\t\tfor ( int k = y; k < y + tate; k++ ) {\n\t\t\t\t\tblock[j][k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for ( int i = 0; i < w; i++ ) {\n\t\t\tfor ( int j = 0; j < h; j++ ) {\n\t\t\t\tcout << block[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;*/\n\t\t//経路探索\n\t\tgo ( xs, ys );\n\t\tif ( oblock[xg][yg] )\tcout << \"OK\" << endl;\n\t\telse\tcout << \"NG\" << endl;\n\t\t/*for ( int i = 0; i < w; i++ ) {\n\t\t\tfor ( int j = 0; j < h; j++ ) {\n\t\t\t\tcout << oblock[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[100][100];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc|| board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\tint xs , ys;\n\tint n;\n\twhile(cin >> w >> h , w|h){\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nstruct Data{\n\tint y, x;\n\tData(){}\n\tData(int _y, int _x){\n\t\ty = _y; x = _x;\n\t}\n};\n\nint fld[100][100];\n\nvoid PaintFld(int c, int x, int y, int w, int h){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfld[y + i][x + j] = c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint W, H;\n\twhile(cin >> W >> H, W || H){\n\t\tint Xs, Ys, Xg, Yg, N, C, D, X, Y;\n\t\tcin >> Xs >> Ys >> Xg >> Yg >> N;\n\t\tXs--; Ys--; Xg--; Yg--;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tX--; Y--;\n\t\t\tif(D == 0) PaintFld(C, X, Y, 4, 2);\n\t\t\telse PaintFld(C, X, Y, 2, 4);\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tbool memo[100][100] = {}, ans = false;\n\t\tq.push( Data(Xs, Ys) );\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\n\t\t\tif(q_front.y == Yg && q_front.x == Xg){\n\t\t\t\tans = true; break;\n\t\t\t}\n\n\t\t\tif(memo[q_front.y][q_front.x]) continue;\n\t\t\tmemo[q_front.y][q_front.x] = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\tint nx = q_front.x + dx[i];\n\n\t\t\t\tif(ny < 0 || H <= ny || nx < 0 || W <= nx || fld[ny][nx] != fld[Ys][Xs])\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push( Data(ny, nx) );\n\t\t\t}\n\t\t}\n\n\t\tif(ans) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1, yi);\n        solve(xi, yi-1);\n        solve(xi+1, yi);\n        solve(xi, yi+1);\n    }\n    block[xi][yi] = 0;\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(int)*w*h);\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            //cout << x << \",\"<< y << endl;\n            if(d==1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        //if(c==0) {cout <<\"NG\" << endl; continue;}\n        \n        //cout << xs << \" \" << ys << \" \" << c << endl;\n        //cout <<\"input \" << endl;\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint xg,yg,c,sc,ans,block[101][101],w,h;\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nint idou(int x,int y)\n{\n    if(x == xg&&y == yg)\n    {\n        ans = 1;\n        return 0;\n    }\n    if(sc == 0)return 0;\n    block[x][y] = 0;\n    for(int i = 0; i < 4; i++)\n    {\n        if(block[x + dx[i]][y + dy[i]] == sc)idou(x + dx[i],y + dy[i]);\n    }\n    return 0;\n}\nint main()\n{\n    while(1)\n    {\n        int xs,ys,n,d,x,y;\n        ans = 0;\n        for(int i = 0; i < w; i++)\n        {\n            for(int j = 0; j < h; j++)\n            {\n                block[i][j] = 0;\n            }\n        }\n        scanf(\"%d%d\",&w,&h);\n        if(w == 0&&h == 0)break;\n        scanf(\"%d%d\",&xs,&ys);\n        scanf(\"%d%d\",&xg,&yg);\n        scanf(\"%d\",&n);\n        for(int i = 0; i < n; i++)\n        {\n            scanf(\"%d%d%d%d\",&c,&d,&y,&x);\n            if(d == 1)\n            {\n                for(int i = 0; i < 2; i++)\n                {\n                    for(int j = 0; j < 4; j++)\n                    {\n                        block[x + j][y + i] = c;\n                    }\n                }\n            }\n            if(d == 0)\n            {\n                for(int i = 0; i < 2; i++)\n                {\n                    for(int j = 0; j < 4; j++)\n                    {\n                        block[x + i][y + j] = c;\n                    }\n                }\n            }\n        }\n        sc = block[xs][ys];\n        idou(xs,ys);\n        if(ans == 1)printf(\"OK\\n\");\n        else printf(\"NG\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint weight, hight;\nint g[101][101];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, 1, -1};\nconst int vy[4] = {1, -1, 0, 0};\n \nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n    \n    g[y][x] = -1;\n    \n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n         \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            dfs(nx, ny);\n        }\n    }\n    return;\n}\n \nint main(){ \n    while(1){\n        int n, c, d, x, y;\n        flag = false;\n        g[101][101] = {};\n        \n        cin >> weight >> hight;\n \n        if(weight == 0 && hight == 0){\n            break;\n        }\n         \n        cin >> sx >> sy >> gx >> gy >> n;\n         \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n             \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n         \n        sc = g[sy][sx];\n        dfs(sx, sy);\n         \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n\n  DFS(xs,ys,F[xs][ys]);\n  if(xs == 8){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint m[102][102];\nint w, h, xs, ys, xg, yg, f, t;\n\nvoid solve(int x, int y){\n  if(x < 0 || y < 0 || x >= w || y >= h || f || m[x][y] == -1) return;\n  if(x == xg && y == yg){\n    f = 1;\n    return;\n  }\n  m[x][y] = -1;\n  if(m[x + 1][y] == t) solve(x + 1, y);\n  if(m[x - 1][y] == t) solve(x - 1, y);\n  if(m[x][y + 1] == t) solve(x, y + 1);\n  if(m[x][y - 1] == t) solve(x, y - 1);\n}\n\nint main(void){\n  int n, c, d, x, y;\n  for( ; ; ){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i = 0;i <= 101; i++)\n      for(int j = 0;j <= 101; j++) m[i][j] = 0;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n\n    for(int i = 0;i < n; i++){\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      if(!d){\n        for(int i = 0;i < 4; i++) m[x + i][y] = m[x + i][y + 1] = c;\n      } else {\n        for(int i = 0;i < 4; i++) m[x][y + i] = m[x + 1][y + i] = c;\n      }\n    }\n\n    f = 0;\n    t = m[xs][ys];\n    solve(xs, ys);\n\n    cout << (f? \"OK\" : \"NG\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <functional> //sort(A,A.end(),greater<int>());???????????????\n#include <queue>\n#include <stack>\n#include <vector>\n\n#define INF 10 << 10\n#define MP make_pair\n\nint map[124][124];\nbool map_flg[124][124];\nint x_move[] = { 0,0,1,-1 };\nint y_move[] = { -1,1,0,0 };\n\nint main() {\n\tint w, h;\n\n\twhile (cin >> w >> h && w != 0 && h != 0) {\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(map_flg, true, sizeof(map_flg));\n\t\tint xs, ys;\n\t\tint xg, yg;\n\t\tint n;\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint x_, y_;\n\t\t\tif (d == 0) {\n\t\t\t\tx_ = 4;\n\t\t\t\ty_ = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx_ = 2;\n\t\t\t\ty_ = 4;\n\t\t\t}\n\t\t\tfor (int j = y; j < y + y_; ++j) {\n\t\t\t\tfor (int j2 = x; j2 < x + x_; ++j2) {\n\t\t\t\t\tmap[j][j2] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (map[ys][xs] != map[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstack<pair<int, int> > st;\n\t\tst.push(MP(xs, ys));\n\t\tint m_c = map[ys][xs];\n\t\tbool flg = false;\n\t\twhile (!st.empty()) {\n\t\t\tint x = st.top().first, y = st.top().second;\n\t\t\tst.pop();\n\t\t\tmap_flg[y][x] = false;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint x_ = x + x_move[i], y_ = y + y_move[i];\n\t\t\t\tif (map[y_][x_] == m_c && map_flg[y_][x_]) {\n\t\t\t\t\tif (y_ == yg && x_ == xg) {\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tst.push(MP(x_, y_));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flg) { break; }\n\t\t}\n\n\t\tif (flg) { cout << \"OK\" << endl; }\n\t\telse { cout << \"NG\" << endl; }\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL p=7+1e+9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint W, H;\nint xs, ys, xg, yg;\nint N, C;\nint maze[128][128];\n\nint dfs(int x, int y){\n\tif(x == xg && y == yg)\n\t\treturn 1;\n\tmaze[y][x] = 0;\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(maze[ny][nx] == C){\n\t\t\tif(dfs(nx, ny))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin >> W >> H && (W || H)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tcin >> xs >> ys >> xg >> yg >> N;\n\t\tint c, d, x, y;\n\t\tREP(i,N){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,2)\n\t\t\t\t\tREP(k,4)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(j,4)\n\t\t\t\t\tREP(k,2)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t\tC = maze[yg][xg];\n\t\tif(C == 0 || maze[ys][xs] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = dfs(xs, ys);\n\t\tif(ans){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nint xg, yg;\nint data[101][101];\nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\nbool visited[101][101];\nbool dfs(int, int, int);\n\nmain(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n\n    int xs, ys, n;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<=h;i++){\n      for(int j=0;j<=w;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      if(d==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    data[i+y][j+x]=c;\n\t  }\n\t}\n      }else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<4;j++){\n\t    data[i+y][j+x]=c;\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<=h;i++){\n      for(int j=0;j<=w;j++){\n\tvisited[i][j]=false;\n      }\n    }\n\n    if(dfs(ys, xs, data[ys][xs])){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}\n\nbool dfs(int y, int x, int c){\n  if(y==yg && x==xg){\n    return true;\n  }\n  visited[y][x]=true;\n  bool ans=false;\n  for(int i=0;i<4;i++){\n    int ty=y+dy[i];\n    int tx=x+dx[i];\n    if(ty>0 && ty<=h){\n      if(tx>0 && tx<=w){\n\tif(data[ty][tx]==c && !visited[ty][tx]){\n\t  ans=dfs(ty, tx, c);\n\t  if(ans) break;\n\t}\n      }\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint width,height,table[100][100];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= width-1 && col >= 0 && col <= height-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int row,int col){\n\tint tmp = table[row][col];\n\ttable[row][col] = 7;\n\n\tif(rangeCheck(row-1,col) == true && table[row-1][col] == tmp)recursive(row-1,col);\n\tif(rangeCheck(row+1,col) == true && table[row+1][col] == tmp)recursive(row+1,col);\n\tif(rangeCheck(row,col-1) == true && table[row][col-1] == tmp)recursive(row,col-1);\n\tif(rangeCheck(row,col+1) == true && table[row][col+1] == tmp)recursive(row,col+1);\n}\n\nint main(){\n\n\tint x_s,y_s,x_g,y_g,n,color,dist,x,y;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&width,&height);\n\t\tif(width == 0 && height == 0)break;\n\n\t\tfor(int i = 0; i < height; i++)\n\t\t{\n\t\t\tfor(int k = 0; k < width; k++)table[i][k] = 0;\n\t\t}\n\n\t\tscanf(\"%d %d\",&x_s,&y_s);\n\t\tscanf(\"%d %d\",&x_g,&y_g);\n\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d %d %d\",&color,&dist,&x,&y);\n\n\t\t\tif(dist == 0){\n\t\t\t\tfor(int row = 0; row < 2; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\ttable[y-1+row][x-1+col] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 2; col++){\n\t\t\t\t\t\ttable[y-1+row][x-1+col] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecursive(y_s-1,x_s-1);\n\n\t\tif(table[y_g-1][x_g-1] == 7)printf(\"OK\\n\");\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nint w,h;\nbool** flags;\nchar** map;\n\nclass Point{\npublic:\n\tint X,Y;\n};\n\ntemplate <class T> T** NewArray(int w,int h){\n\tT** r = new T*[w];\n\tfor(int i=0;i<w;i++){\n\t\tr[i] = new T[h];\n\t\tfor(int j=0;j<h;j++){\n\t\t\tr[i][j] = 0;\n\t\t}\n\t}\n\treturn r;\n}\n\ntemplate <class T> void RemoveArray(T** array,int w,int h){\n\tfor(int i=0;i<h;i++){\n\t\tdelete[] array[i];\n\t}\n\tdelete[] array;\n}\n\nbool Check(int x,int y,int c){\n\tif(x<0){return false;}\n\tif(y<0){return false;}\n\tif(x>=w){return false;}\n\tif(y>=h){return false;}\n\tif(flags[x][y]){return false;}\n\tif(map[x][y] != c){return false;}\n}\n\nbool Solve(int sx,int sy,int gx,int gy){\n\tchar c = map[sx][sy];\n\tqueue<Point> pts;\n\tflags = NewArray<bool>(w + 1,h + 1);\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tflags[i][j] = false;\n\t\t}\n\t}\n\tPoint p,pp;\n\tp.X = sx;\n\tp.Y = sy;\n\tpts.push(p);\n\tflags[sx][sy] = true;\n\t\n\tbool res = false;\n\t\n\twhile(pts.size() > 0){\n\t\tp = pts.front();\n\t\tpts.pop();\n\t\tif(flags[gx][gy] == true){\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\t\tpp = p;\n\t\tpp.X -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.X += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t}\n\t\n\tRemoveArray<bool>(flags,w + 1,h + 1);\n\treturn res;\n}\n\nint main(){\n\tint xs,ys,xg,yg;\n\t\n\twhile(scanf(\"%d %d\",&w,&h) && w && h){\n\t\tmap = NewArray<char>(w + 1,h + 1);\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\txs -= 1;\n\t\tys -= 1;\n\t\txg -= 1;\n\t\tyg -= 1;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tint c,d,x,y;\n\t\tint xx,yy;\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t//printf(\"%d \",map[i][j]);\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\txx = 4;\n\t\t\t\tyy = 2;\n\t\t\t}else{\n\t\t\t\txx = 2;\n\t\t\t\tyy = 4;\n\t\t\t}\n\t\t\tx-=1;\n\t\t\ty-=1;\n\t\t\tfor(int j=0;j<xx;j++){\n\t\t\t\tfor(int k=0;k<yy;k++){\n\t\t\t\t\t//printf(\"(%2d+%2d,%2d+%2d) = %d\\n\",k,j,y,k,c);\n\t\t\t\t\tmap[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(Solve(xs,ys,xg,yg)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tRemoveArray<char>(map,w + 1,h + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nstruct point{\n\tint x;\n\tint y;\n};\nint m[101][101] = {0};\nint w,h,r;\npoint gp;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gp.x)&&!(y-gp.y))r=1;\n\tif(x>0&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>0&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d;\n\t//spÍX^[gn_ÌÀWAgpÍS[n_ÌÀW\n\tpoint sp,bp;\n\t\n\twhile(1){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>w>>h;\n\t\tif(!w&&!h)return 0;\n\t\tstd::cin>>sp.x>>sp.y;\n\t\tstd::cin>>gp.x>>gp.y;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bp.x>>bp.y;\n\t\t\tint bw,bh;\n\t\t\td?bw=2,bh=4:bh=2,bw=4;\n\t\t\tfor(int y=bp.y;y<=bp.y+bh;y++){\n\t\t\t\tfor(int x=bp.x;x<=bp.x+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sp.x][sp.y])dfs(sp.x,sp.y,m[sp.x][sp.y]),m[sp.x][sp.y] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( color[x][y] == color[x + 1][y] && dp[x + 1][y] )\n\t\tif ( solve(x + 1, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] && dp[x][y + 1] )\n\t\tif ( solve(x, y + 1) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] && dp[x][y - 1] )\n\t\tif ( solve(x, y - 1) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] && dp[x - 1][y] )\n\t\tif ( solve(x - 1, y) )\n\t\t\treturn true;\n\tdp[x][y] = false;\n\treturn false;\n}\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i <= board_range_w + 1; i++ ){\n\t\t\tfor ( int j = 0; j <= board_range_h + 1; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t\tdp[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( !block_quarter ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( start_x > goal_x && start_y > goal_y ){\n\t\t\tswap(start_x, goal_x);\n\t\t\tswap(start_y, goal_y);\n\t\t}\n\t\tif ( solve(start_x, start_y) ) \n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n;\nint w,h;\nint xs,ys;\nint xg,yg;\nint color;\nint c,d,xb,yb;\n\nint b[100][100];\n\nbool flag;\n\nvoid saiki(int y,int x,int c){\n\tif(b[y][x] != c || flag || b[y][x]==0)return;\n\tb[y][x]=-1;\n\tif(y==yg&&x==xg)flag = 1;\n\tif(x-1>=0)saiki(y,x-1,c);\n\tif(y-1>=0)saiki(y-1,x,c);\n\tif(x+1<w)saiki(y,x+1,c);\n\tif(y+1<h)saiki(y+1,x,c);\n}\n\nint main(){\n\twhile(cin >> w >> h && w ){\n\t\t/*ú»*/\n\t\tfor(int i=0;i<100;i++)for(int j=0;j<100;j++)b[i][j]=0;\n\t\t/*üÍ*/\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\txs-=1;ys-=1;xg-=1;yg-=1;\n\t\t\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> xb >> yb;\n\t\t\txb-=1;yb-=1;\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tb[yb  ][xb+i]=c;\n\t\t\t\t\tb[yb+1][xb+i]=c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tb[yb+i][xb  ]=c;\n\t\t\t\t\tb[yb+i][xb+1]=c;\n\t\t\t\t}\t\t\t\t\n\n\t\t\t}\n\t\t}\n\t\tflag = 0;\n\t\tsaiki(ys,xs,b[ys][xs]);\n/*\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++)cout << b[i][j];\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif(flag)cout << \"OK\";\n\t\telse cout << \"NG\";\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint board[100][100],w,h,xg,yg;\nbool f(int y,int x){\n\tboard[y][x] = 0;\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\tif(y == yg - 1 && x == xg -1) return true;\n\tfor(i = 0;i < 4;i++){\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\t\t\tif(board[y+dy[i]][x+dx[i]] == 2){\n\t\t\t\tif(f(y+dy[i],x+dx[i])) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint xs,ys,n,i,c,d,x,y,j,k;\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx -= 1;\n\t\t\ty -= 1;\n\t\t\tif(d == 0){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f(ys - 1,xs -1)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t\tfor(j = 0;j < 100;j++){\n\t\t\tfor(i = 0;i < 100;i++){\n\t\t\t\tboard[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint xs,ys,c,a[105][105],memo[105][105],ans,p,w,h;\n\nint solve(int yg,int xg){\n\n  if(a[yg][xg] != p) return 0;\n\n  a[yg][xg] = 0;\n\n  if(xs == xg && ys == yg) return ans = 1;\n\n  else if(yg - 1 > 0 && a[yg-1][xg] == p) solve(yg-1,xg);\n  else if(xg - 1 > 0 && a[yg][xg-1] == p) solve(yg,xg-1);\n  else if(yg + 1 <= w && a[yg+1][xg] == p) solve(yg+1,xg);\n  else if(xg + 1 <= h && a[yg][xg+1] == p) solve(yg,xg+1);\n}\n\nint main(){\n  int xg,yg,n,d,x,y;\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    memset(a,0,sizeof(a));\n    memset(memo,0,sizeof(memo));\n    ans = 0;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n\tfor(int i=y;i<y+2;i++){\n\t  for(int j=x;j<x+4;j++) a[i][j] = c;\n\t}\n      }\n\n      else if(d == 1){\n\tfor(int i=y;i<y+4;i++){\n\t  for(int j=x;j<x+2;j++) a[i][j] = c;\n\t}\n      }\n    }\n\n    p = a[yg][xg];\n    solve(yg,xg);\n\n    if(ans == 1)   cout << \"OK\" << endl;\n    else if(ans == 0)cout << \"NG\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return 0;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl;\n\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\nint w,h,sx,sy,gx,gy,n;\nint board[21][21];\n\nint main()\n{\n    while(cin >> w >> h && w) {\n        memset(board, 0, sizeof(board));\n        cin >> sx >> sy >> gx >> gy >> n;\n        \n        int c, d, x, y;\n        rep(k, n) {\n            cin >> c >> d >> x >> y;\n            if(d == 0)\n                rep(i, 2) rep(j, 4) \n                    board[i + y][j + x] = c;\n             else \n                rep(i, 4) rep(j, 2) \n                    board[i + y][j + x] = c;\n        }\n\n        int e = board[sy][sx];\n        queue<P> que;\n        que.push(P(sx, sy));\n        bool ok = false;\n        while(!que.empty()) {\n            P p = que.front(); que.pop();\n            x = p.first; y = p.second;\n            if(x == gx && y == gy) {\n                ok = true;\n                break;\n            }\n            if(board[y][x] == -1) \n                continue;\n\n            board[y][x] = -1;\n            for(int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                if(nx >= 1 && nx <= w && ny >= 0 && ny <= h && board[ny][nx] == e) \n                    que.push(P(nx, ny));\n            }\n        }\n\n        cout << ((ok) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(W+1, vector<int>(H+1));\n        vector<vector<int> > used(W+1, vector<int>(H+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            if (!dir) {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx <= H && 0 <= ny && ny <= W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint i,j;\nint a[105][105];\nint used[105][105];\nint h,w;\n\nvoid search(int y,int x,int c){\n  if(x<0 || y<0 || y>=h || x>=w || a[y][x]!=c)return;\n  if(used[y][x])return;\n  used[y][x]++;\n  int i;\n  int dx[4]={-1,0,1,0};\n  int dy[4]={0,-1,0,1};\n  rep(i,4)\n    search(y+dy[i],x+dx[i],c);\n  return;\n}\n\nint main(void) {\n  while(1){\n    cin>>h>>w;\n    if(h==0 && w==0)break;\n    rep(i,h)rep(j,w)used[i][j]=0;\n    int xs,ys,xg,yg,n;\n    cin>>xs>>ys;\n    xs--;ys--;\n    cin>>xg>>yg;\n    xg--;yg--;\n    cin>>n;\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      int p[8]={0,0,0,0,1,1,1,1};\n      int q[8]={0,1,2,3,0,1,2,3};\n      if(d)\n\trep(j,8)\n\t  a[y+q[j]][x+p[j]]=c;\n      else\n\trep(j,8)\n\t  a[y+p[j]][x+q[j]]=c;\n    }  \n    if(a[ys][xs]==0){\n      cout<<\"NG\"<<endl;\n      continue;\n    } \n    search(ys,xs,a[ys][xs]);//dfs\n    if(used[yg][xg])\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint cnt=0;\n\nvoid DFS(int XS, int YS, int XG, int YG, int e){\n\tif(F[XS][YS]!=e){\n\t\treturn;\n\t}\n\tif(XS==XG&&YS==YG){\n\t\tcnt++;\n\t}\n\tF[XS][YS]=0;\n\n\tDFS(XS-1,YS  ,XG,YG,e);\n\tDFS(XS  ,YS+1,XG,YG,e);\n\tDFS(XS+1,YS  ,XG,YG,e);\n\tDFS(XS  ,YS-1,XG,YG,e);\n}\n\nint main(){\n\twhile(true){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\t\tfor(int i=0; i<=102; i++){\n\t\t\tfor(int j=0; j<=102; j++){\n\t\t\t\tF[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tcnt=0;\n\t\tint xs,ys;\n\t\tcin>>xs>>ys;\n\t\tint xg,yg;\n\t\tcin>>xg>>yg;\n\t\tint n;\n\t\tcin>>n;\n\t\tint c[n];\n\t\tint d[n], x[n], y[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin>>c[i]>>d[i]>>x[i]>>y[i];\n\t\t}\n\t\tfor(int i=0; i<n;  i++){\n\t\t\tif(d[i]==0){\n\t\t\t\tF[x[i]  ][y[i]]=c[i];\tF[x[i]  ][y[i]+1]=c[i];\n\t\t\t\tF[x[i]+1][y[i]]=c[i];\tF[x[i]+1][y[i]+1]=c[i];\n\t\t\t\tF[x[i]+2][y[i]]=c[i];\tF[x[i]+2][y[i]+1]=c[i];\n\t\t\t\tF[x[i]+3][y[i]]=c[i];\tF[x[i]+3][y[i]+1]=c[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tF[x[i]][y[i]  ]=c[i];\tF[x[i]+1][y[i]  ]=c[i];\n\t\t\t\tF[x[i]][y[i]+1]=c[i];\tF[x[i]+1][y[i]+1]=c[i];\n\t\t\t\tF[x[i]][y[i]+2]=c[i];\tF[x[i]+1][y[i]+2]=c[i];\n\t\t\t\tF[x[i]][y[i]+3]=c[i];\tF[x[i]+1][y[i]+3]=c[i];\n\t\t\t}\n\t\t}\n\t\tif(F[xs][ys]!=0){\n\t\t\tif(F[xg][yg]!=0){\n\t\t\t\tDFS(xs,ys,xg,yg,F[xs][ys]);\n\t\t\t}\n\t\t}\n\t\tif(cnt==1){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[105][105];\nint w , h , xg , yg , sc;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {\n\t\tb=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=sc || board[tx][ty]==0 || b ) continue;\n\t\tdfs( tx,ty );\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse  dfs( xs , ys );\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color && map[x][y] != 9){\n\t\t\tmap[x][y] = 9;\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x < w && y>=0 && y< h);\n}\nint main(void){\n\tconst int dx[4]={0,1,0,-1};\n\tconst int dy[4]={1,0,-1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\t//printf(\"%d %d\\n\",w,h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x-1+k][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs-1][ys-1];\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs-1;\n\t\tqy[0]=ys-1;\n\t\tf=c!=0;\n/*\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\t\tprintf(\"%d\\n\",c);*/\n\t\twhile(!f && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dx[i];\n\t\t\t\ty = qy[p] + dy[i];\n\t\t\t\tif(is(x,y) && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx[p+cnt] = x;\n\t\t\t\t\tqy[p+cnt] = y;\n\t\t\t\t\tif(x == xg-1 && y == yg-1)f=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}\n\t\tputs(f?\"OK\":\"NG\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg, w,h;\n\nvoid dfs(int target, int x, int y){\n    if(x < 0 || y < 0 || x >= w || y >= h) return;\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 0;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n}\n\nint main(){\n    int xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,105) rep(j,105) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        xs--; ys--; xg--; yg--;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<stack>\n\nusing namespace std ;\n\nint w ,h ,n ;\nint sx ,sy ,gx ,gy ;\n\nstruct P\n{\n\tint x ;\n\tint y ;\n} ;\n\nbool came[ 110 ][ 110 ] ;\n\nint map[ 110 ][ 110 ] ;\n\nvoid high( int x ,int y ,int c )\n{\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid wide( int x ,int y ,int c )\n{\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && !w )\n\t\t\treturn 0 ;\n\t\tcin >> sx >> sy >> gx >> gy >> n ;\n\tmemset( came ,false ,sizeof came ) ;\n\tmemset( map ,0 ,sizeof map ) ;\n\n\tstack< P > st ;\n\n\tint c ,d ,x ,y ;\n\tint d1 ,d2 ;\n\tfor( int k = 0 ; k < n ; k++ )\n\t{\n\t\tcin >> c >> d >> x >> y ;\n\t\td ? high( x ,y ,c ) : wide( x ,y ,c ) ;\n\t\t/*if( d )\n\t\t{\n\t\t\td1 = 2 ;\n\t\t\td2 = 4 ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td1 = 4 ;\n\t\t\td2 = 2 ;\n\t\t}\n\t\tfor( int i = 0 ; i < d1 ; i++ )\n\t\t{\n\t\t\tfor( int j = 0 ; j < d2 ; j++ )\n\t\t\t\tmap[ y + i ][ x + j ] = c ;\n\t\t}*/\n\t}\n/*\nfor( int i = 0 ; i <= h + 1 ; i++ )\n{\n\tfor( int j = 0 ; j <= w + 1 ; j++ )\n\t\tcout << map[ i ][ j ] ;\n\tcout << endl ;\n}\n*/\n\tif( map[ sy ][ sx ] != map[ gy ][ gx ] )\n\t{\n\t\tprintf( \"NG\\n\" ) ;\n\t\tcontinue ;\n\t}\n\n\tc = map[ gy ][ gx ] ;\n\n\tfor( int i = 1 ; i <= h ; i++ )\n\t{\n\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t{\n\t\t\tif( c == map[ i ][ j ] )\n\t\t\t\tcame[ i ][ j ] = true ;\n\t\t}\n\t}\n\n\td = 1 ;\n\tP l ;\n\tl.x = sx ;\n\tl.y = sy ;\n\tst.push( l ) ;\n\n\tcame[ sy ][ sx ] = false ;\n\n\twhile( !st.empty() )\n\t{\n\n\t\tP p = st.top() ;\n\t\tst.pop() ;\n\n\t\tif( p.x == gx && p.y == gy )\n\t\t{\n\t\t\td = 0 ;\n\t\t\tbreak ;\n\t\t}\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\tint mx[] = { 1 ,0 ,0 ,-1 } ;\n\t\t\tint my[] = { 0 ,1 ,-1 ,0 } ;\n\t\t\tint xx = p.x + mx[ i ] ;\n\t\t\tint yy = p.y + my[ i ] ;\n\t\t\tif( xx > 0 && x <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\t{\n\t\t\t\tcame[ yy ][ xx ] = false ;\n\t\t\t\tl.x = xx ;\n\t\t\t\tl.y = yy ;\n\t\t\t\tst.push( l ) ;\n\t\t\t}\n\t\t}\n\t}\n\td ? printf( \"NG\\n\" ) : printf( \"OK\\n\" ) ;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint width,height,table[100][100];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= width-1 && col >= 0 && col <= height-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(int row,int col){\n\tint tmp = table[row][col];\n\ttable[row][col] = 7;\n\n\tif(rangeCheck(row-1,col) == true && table[row-1][col] == tmp)recursive(row-1,col);\n\tif(rangeCheck(row+1,col) == true && table[row+1][col] == tmp)recursive(row+1,col);\n\tif(rangeCheck(row,col-1) == true && table[row][col-1] == tmp)recursive(row,col-1);\n\tif(rangeCheck(row,col+1) == true && table[row][col+1] == tmp)recursive(row,col+1);\n}\n\nint main(){\n\n\tint x_s,y_s,x_g,y_g,n,color,dist,x,y;\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&width,&height);\n\t\tif(width == 0 && height == 0)break;\n\n\t\tfor(int i = 0; i < height; i++)\n\t\t{\n\t\t\tfor(int k = 0; k < width; k++)table[i][k] = 0;\n\t\t}\n\n\t\tscanf(\"%d %d\",&x_s,&y_s);\n\t\tscanf(\"%d %d\",&x_g,&y_g);\n\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d %d %d\",&color,&dist,&x,&y);\n\n\t\t\tif(dist == 0){\n\t\t\t\tfor(int row = 0; row < 2; row++){\n\t\t\t\t\tfor(int col = 0; col < 4; col++){\n\t\t\t\t\t\ttable[y-1+row][x-1+col] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int row = 0; row < 4; row++){\n\t\t\t\t\tfor(int col = 0; col < 2; col++){\n\t\t\t\t\t\ttable[y-1+row][x-1+col] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trecursive(y_s-1,x_s-1);\n\n\t\tif(table[x_g-1][y_g-1] == 7)printf(\"OK\\n\");\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool dfs(int xs,int ys,int xg,int yg,vector<vector<bool> >& canGo){\ncanGo[xs][ys]=false;\nif(xs==xg&&ys==yg)return true;\nif(canGo[xs+1][ys]){if(dfs(xs+1,ys,xg,yg,canGo))return true;}\nif(canGo[xs-1][ys]){if(dfs(xs-1,ys,xg,yg,canGo))return true;}\nif(canGo[xs][ys+1]){if(dfs(xs,ys+1,xg,yg,canGo))return true;}\nif(canGo[xs][ys-1]){if(dfs(xs,ys-1,xg,yg,canGo))return true;}\nreturn false;\n}\nint main(void){\nint w,h,xs,ys,xg,yg,n;\nbool ans,endflag;\nvector<vector<bool> > blockmap;\nwhile(true){\ncin>>w>>h;\nif(w==0&&h==0)break;\ncin>>xs>>ys>>xg>>yg>>n;\nblockmap=vector<vector<bool> >(w+2,vector<bool>(h+2,false));\nfor(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin>>c>>d>>x>>y;\n    if(c==2){\n        blockmap[x+1][y+1]=true;\n        blockmap[x+2][y+1]=true;\n        blockmap[x+1][y+2]=true;\n        blockmap[x+2][y+2]=true;\n        if(d==0){\n            blockmap[x+3][y+1]=true;\n            blockmap[x+3][y+2]=true;\n            blockmap[x+4][y+1]=true;\n            blockmap[x+4][y+2]=true;\n        }\n        else {\n            blockmap[x+1][y+2]=true;\n            blockmap[x+2][y+3]=true;\n            blockmap[x+1][y+4]=true;\n            blockmap[x+2][y+4]=true;\n        }\n    }\n}\nans=dfs(xs+1,ys+1,xg+1,yg+1,blockmap);\nif(ans)cout<<\"OK\"<<endl;\nelse cout<<\"NG\"<<endl;\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool b;\n\nvoid dfs(int board[][102] ,int x , int y , int w , int h , int xg , int yg , int sc){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( board , tx,ty,w,h,xg,yg,sc);\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tint board[102][102]={0};\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(board ,xs,ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    for(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j]=0;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  if(F[xs][ys] == 0){\n    cout << \"NG\" << endl;\n  } else {\n    DFS(xs,ys,F[xs][ys]);\n  \n    if(F[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" <<endl;\n    }\n  }\n\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,color;\nstring res = \"NG\";\nvoid write(Matrix &board,int c, int d, int x, int y){\n  int width,length;\n  if(d == 0){ width = 4; length =2; }\n  if(d == 1){ width = 2; length =4; }\n  for(int i=0; i<width; ++i){\n    for(int j=0; j<length; ++j)\n      board[x+i][y+j]=c;\n  }\n}\nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && color==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && color==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && color==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && color==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  int c,d,x,y;\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> c >> d >> x >> y;\n      --x; --y;\n      write(board,c,d,x,y);\n    }\n    color = board[xs][ys];\n    func(board,xs,ys);\n    cout << res << endl;\n    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<h;i++){\n\t\t\tfor(j=1;j<w;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tif(brock[ys][xs]!=brock[yg][xg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=ys;\n\t\t\tma.b=xs;\n\t\t\tma.c=brock[ys][xs];\n\t\t\tds[ys][xs]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==yg&&ba.b==xg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[yg][xg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=h&&ba.b+q[i]>0&&ba.b+q[i]<=w&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int,int> Pa;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nstring bfs(int a[101][101], int sx, int sy, int gx, int gy, int w, int h)\n{\n\tint s, t, m = a[sy][sx];\n\tbool vis[101][101];\n\tstring str = \"NG\";\n\tqueue<Pa> que;\n\tPa pa;\n\tfill(&vis[0][0], &vis[h+1][w+1], true);\n\t\n\tque.push(Pa(sy, sx));\n\tvis[sy][sx] = false;\n\t\n\twhile(!que.empty()){\n\t\tpa = que.front();\n\t\tque.pop();\n\t\tif(pa.first == gy && pa.second == gx){\n\t\t\tstr = \"OK\";\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\ts = pa.first + dy[i];\n\t\t\tt = pa.second + dx[i];\n\t\t\tif(1 <= s && s <= h && 1 <= t && t <= w){\n\t\t\t\tif(vis[s][t] && m == a[s][t]){\n\t\t\t\t\tque.push(Pa(s, t));\n\t\t\t\t\tvis[s][t] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn str;\n}\n\nint main()\n{\n\tint a[101][101], w, h, sx, sy, gx, gy, s, t, u, v, n;\n\t\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[0][0], &a[h+1][w+1], -1);\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> s >> t >> u >> v;\n\t\t\tif(t == 0){\n\t\t\t\tfor(int i = v; i <= v+1; i++){\n\t\t\t\t\tfor(int j = u; j <= u+3; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int i = v; i <= v+3; i++){\n\t\t\t\t\tfor(int j = u; j <= u+1; j++){\n\t\t\t\t\t\ta[i][j] = s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, sx, sy, gx, gy, w, h) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map> \n#include <sstream>\n#include <cstdio>\n#include <complex>\n#include <cstring>\nusing namespace std;\n \nconst int MAX= 10000100;\n\n#define loop(i,a,b) for(int i = a ; i < b ; i ++)\n#define rep(i,a) loop(i,0,a)\n#define all(a) (a).begin(),(a).end()\n#define ll long long int\n#define gcd(a,b) __gcd(a,b)\n#define pb(a) push_back(a)\nint GCD(int a, int b) {if(!b) return a; return gcd(b, a%b);}\nint lcm(int a, int b) {return a*b / gcd(a, b);}\n\nint m[100][100];\nint sx,sy,gx,gy;\nint w,h;\nbool dfs(int x,int y,int c){\n  if(x==gx&&y==gy)return true;\n  if(m[y][x] == 0)return false;\n  m[y][x] = 0;\n  //cout<<x<<\" \"<<y<<\" \"<<c<<endl;\n  int dx[] = {0,0,-1,1}, dy[] = {1,-1,0,0};\n  bool judge=false;\n  rep(i,4){\n    if(m[y+dy[i]][x+dx[i]] == c)\n      judge |= dfs(x+dx[i],y+dy[i],c);\n  }\n  return judge;\n}\n\n\nint main(void){\n  while(cin>>h>>w,h+w){\n    rep(i,h)rep(j,w)m[i][j]=0;\n  \n    cin>>sx>>sy>>gx>>gy;\n \n    int n,c,d,x,y;\n    cin>>n;\n    rep(i,n){\n      cin>>c>>d>>x>>y;\n      //cout<<c<<\" \"<<d<<\" \"<<x<<\" \"<<y<<endl;\n      if(d){\n\trep(i,4)rep(j,2)m[i+y][j+x] = c;\n      }else{\n\t//cout<<x<<\" \"<<y<<endl;\n\trep(i,2)rep(j,4)m[i+y][j+x] = c;      \n      }\n    }\n    //m[sy][sx] = 8; m[gy][gx] = 9;\n    //cout<<\"  \";rep(i,w)cout<<i%10<<\" \";cout<<endl;\n    //rep(i,h){cout<<i%10<<\" \";rep(j,w)cout<<m[i][j]<<\" \";cout<<endl;}\n    cout<<(dfs(sx,sy,m[sy][sx])?\"OK\":\"NG\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<list>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { \nassert(b!=0);\nreturn a * inv(b);\n }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,-1,0,1 };\nstruct Node {\n\tNode(int a, int b, int c) {\n\t\tatime = a;\n\t\tx = b;\n\t\ty = c;\n\t}\n\tint atime;\n\tint x;\n\tint y;\n};\nclass Compare {\npublic:\n\tbool operator()(const Node& l, const Node& r) {\n\t\treturn l.atime < r.atime;\n\t}\n};\n\n\nint main() {\n\twhile(1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w)return 0;\n\t\tvector<vector<int>> maze(h+2, vector<int>(w+2,0));\n\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d) {\n\t\t\t\tfor (int ax = 0; ax < 4; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\tmaze[y+ay][x+ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 4; ++ay) {\n\t\t\t\t\t\tmaze[y + ay][x + ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < maze.size(); ++i) {\n\t\t\tfor (int j = 0; j < maze[0].size(); ++j) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint color = maze[ys][xs];\n\t\tif (!color||color!=maze[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<bool>>times(h, vector<bool>(w, false));\n\n\t\tpriority_queue<Node,vector<Node>,Compare> qu;\n\t\t qu.emplace(0,xs,ys);\n\t\t bool flag=false;\n\t\twhile (!qu.empty()) {\n\t\t\tNode an(qu.top());\n\t\t\tqu.pop();\n\t\t\tif (an.x == xg&&an.y == yg) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tif (maze[an.y + dy[i]][an.x + dx[i]] == color) {\n\t\t\t\t\t\tif (times[an.y + dy[i]][an.x + dx[i]]) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tqu.push(Node{ an.atime + 1,an.x + dx[i], an.y + dy[i] });\n\t\t\t\t\t\t\ttimes[an.y + dy[i]][an.x + dx[i]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"OK\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define TATE 1\n#define YOKO 0\nint main(void){\n    int map[101][101];\n    int board[101][101];\n    int T[]={0,-1,1,0};\n    int Y[]={1,0,0,-1};\n    int w,h,xs,xg,ys,yg,n,color,muki,x,y;\n    struct ST {\n        int x;\n        int y;\n    };\n    ST RE;\n    ST GO;\n    queue <ST> Q;\n    while(1){\n        memset(map,0,sizeof(map));\n        memset(board,0,sizeof(board));\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys>>xg>>yg>>n;\n        for(int i=0;i<n;i++){\n            cin>>color>>muki>>x>>y;\n            if(muki==YOKO){\n                for(int j=0;j<4;j++){\n                    board[y][x+j]=board[y+1][x+j]=color;\n                }\n            }\n            else{\n                for(int j=0;j<4;j++){\n                    board[y+j][x]=board[y+j][x+1]=color;\n                }\n            }\n        }\n       /* for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        RE.x=xs;\n        RE.y=ys;\n        map[ys][xs]=1;\n        Q.push(RE);\n        int flag=0;\n        while(!Q.empty()){\n            RE=Q.front();\n            Q.pop();\n            if(RE.x==xg&&RE.y==yg&&board[RE.y][RE.x]==board[yg][xg]){\n                flag=1;\n                //cout<<RE.x<<\" \"<<RE.y<<endl;\n                break;\n            }\n            else{\n                for(int i=0;i<4;i++){\n                    GO=RE;\n                    if(GO.x+Y[i]>0&&GO.y+T[i]>0&&GO.x+Y[i]<101&&GO.y+T[i]<101&&board[GO.y+T[i]][GO.x+Y[i]]==board[yg][xg]&&map[GO.y+T[i]][GO.x+Y[i]]!=1){\n                        GO.x+=Y[i];\n                        GO.y+=T[i];\n                        map[GO.y][GO.x]=1;\n                        Q.push(GO);\n                    }\n                }\n            }\n        }\n       /* for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(flag==1){\n            cout<<\"OK\"<<endl;\n        }\n        else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dir[][2] = {\n\t1, 0,\n\t0, 1,\n\t-1, 0,\n\t0, -1\n};\n\nstring solve( VVI board, int sy, int sx, int gx, int gy )\n{\n\tconst int H = board.size(), W = board[0].size();\n\n\tint color = board[ sy ][ sx ];\n\t\n\tqueue< PII > que;\n\tque.push( MP( sy, sx ) );\n\n\tset< PII > visited;\n\tvisited.insert( MP( sy, sx ) );\n\n\twhile ( !que.empty() )\n\t{\n\t\tauto cur = que.front();\n\t\tque.pop();\n\n\t\tif ( cur == MP( gy, gx ) )\n\t\t{\n\t\t\treturn \"OK\";\n\t\t}\n\n\t\tREP( d, 0, 4 )\n\t\t{\n\t\t\tauto next = cur;\n\n\t\t\tnext.fst += dir[d][0];\n\t\t\tnext.snd += dir[d][1];\n\n\t\t\tif ( !( 0 <= next.fst && next.fst < H && 0 <= next.snd && next.snd < W ) || \n\t\t\t\t EXIST( visited, next ) ||\n\t\t\t\t board[ next.fst ][ next.snd ] != color )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tque.push( next );\n\t\t\tvisited.insert( next );\n\t\t}\n\t}\n\n\treturn \"NG\";\n}\t\t\t\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\n\t\tVVI board( h, VI( w, 0 ) );\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( !d )\n\t\t\t{\n\t\t\t\tREP( j, 0, 2 )\n\t\t\t\t{\n\t\t\t\t\tREP( k, 0, 4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ y + j ][ x + k ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP( j, 0, 4 )\n\t\t\t\t{\n\t\t\t\t\tREP( k, 0, 2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ y + j ][ x + k ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve( board, sy, sx, gy, gx ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool solve(int x,int y,int c);\nint ux[2][8]={{0,1,2,3,0,1,2,3},\n\t      {0,1,0,1,0,1,0,1}};\nint uy[2][8]={{0,0,0,0,1,1,1,1},\n\t      {0,0,1,1,2,2,3,3}};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint w,h,n;\nint b[105][105];\nint xs,ys,xg,yg;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(!w && !h) break;\n    memset(b,0,sizeof(b));\n    scanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n    scanf(\"%d\",&n);\n    int c,d,tx,ty;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&c,&d,&tx,&ty);\n      for(int j=0;j<8;j++){\n\tb[tx+ux[d][j]][ty+uy[d][j]]=c;\n      }\n    }\n    if(b[xs][ys]!=0 && b[xg][yg]!=0 && solve(xs,ys,b[xs][ys])) puts(\"OK\");\n    else puts(\"NG\");\n  }\n}\n\nbool solve(int x,int y,int c){\n  printf(\"%d\\n\",c);\n  if(x==xg && y==yg) return true;\n  b[x][y]=0;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(0<=nx && nx<w && 0<=ny && ny<h){\n      if(b[nx][ny]==c){\n\tif(solve(nx,ny,c)) return true;\n      }\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X]!=c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n  cin >> w >> h;\n  if(w == 0 && h == 0)\n    break;\n  cin >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n, w, h, sx, sy, gx, gy;\nint t[102][102];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool solve(int x, int y, int kind){\n  if(x == gx && y == gy){\n    return true;\n  }\n  t[y][x] = -1;\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(0 <= nx && nx < w && 0 <= ny && ny < h && t[ny][nx] == kind){\n      if(solve(nx, ny, kind)) return true;\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    memset(t, 0, sizeof(t));\n\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    sx--;\n    sy--;\n    gx--;\n    gy--;\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      int ww, hh;\n      cin >> c >> d >> x >> y;\n      x--;\n      y--;\n\n      if(d == 0){\n        ww = 4;\n        hh = 2;\n      }\n      else{\n        ww = 2;\n        hh = 4;\n      }\n\n      for(int j = y; j < y + hh; j++){\n        for(int k = x; k < x + ww; k++){\n          t[j][k] = c;\n        }\n      }\n    }\n\n    /*\n    for(int i = 0; i < h; i++){\n      for(int j =0; j < w;j ++){\n        cout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    */\n\n    bool ans = t[sy][sx] == 0 ? false : solve(sx, sy, t[sy][sx]);\n\n    cout << (ans ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define dr direction\n#define cl color\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nclass Block{\npublic:\n    int color;// 1~5\n    int direction;// 0:-, 1:|\n    int x, y;\n    void init(int c, int d, int xx, int yy);\n};\n\nvoid Block::init(int c, int d, int xx, int yy){\n    color=c;\n    direction=d;\n    x=xx;\n    y=yy;\n}\n\nint w, h, xs, ys, xg, yg, n;\nint fld[100][100], dis[100][100];\nconst pii dxdy[]={{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nconst int inf=1e8;\n\nstring solve(){// bfs\n    queue<pii> qu;\n    qu.push(make_pair(ys, xs));\n    int C=fld[ys][xs];\n    fill(dis[0], dis[100], inf);\n    dis[ys][xs]=0;\n\n    if(C==0) return \"NG\";\n    while(!qu.empty()){\n        pii now=qu.front(); qu.pop();\n        if(now.fi==yg&&now.se==xg){\n            return \"OK\";\n        }\n\n        for(int k=0; k<4; k++){\n            pii nx=make_pair(now.fi+dxdy[k].fi, now.se+dxdy[k].se);\n            if(!(0<=nx.fi&&nx.fi<h&&0<=nx.se&&nx.se<w)) continue;\n            if(fld[nx.fi][nx.se]!=C) continue;\n            if(dis[nx.fi][nx.se]!=inf) continue;\n\n            dis[nx.fi][nx.se]=dis[now.fi][now.se]+1;\n            qu.push(nx);\n        }\n    }\n\n    return \"NG\";\n}\n\nint main(){\n\n    while(1){\n        cin>> w>> h;\n        if(w==0&&h==0) break;\n        cin>> xs>> ys>> xg>> yg>> n;\n        xs--; ys--; xg--; yg--;\n        Block block[n];\n        for(int i=0; i<n; i++){\n            int c, d, xx, yy;\n            cin>> c>> d>> xx>> yy;\n            xx--; yy--;\n            block[i].init(c, d, xx, yy);\n        }\n\n        // make field\n        fill(fld[0], fld[100], 0);\n        for(int k=0; k<n; k++){\n            int X=block[k].x, Y=block[k].y;\n            if(block[k].dr==0){\n                for(int i=0; i<2; i++){\n                    for(int j=0; j<4; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }else{\n                for(int i=0; i<4; i++){\n                    for(int j=0; j<2; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }\n        }\n/*\n        for(int i=0; i<w; i++){\n            for(int j=0; j<h; j++){\n                cout<< fld[i][j]<<\" \";\n            }\n            cout<< endl;\n        }\n//*/\n        cout<< solve()<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\nbool is_goal = false;\n#define START 20\n#define GOAL 30\n\nvoid DFS(int h,int w,int c){\n\n  if(!is_goal){\n\n    if(Array[h][w] == GOAL){\n      is_goal = true;\n      return;\n    }\n\n    if(Array[h][w] != c || Array[h][w] == 0){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 0;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n  }\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n      is_goal = false;\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n      cin >> Goal[0] >> Goal[1];\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n      Array[Goal[0]][Goal[1]] = GOAL;\n      /*for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          cout << Array[i][j];\n        }\n        cout << endl;\n      }*/\n      if(Array[Start[0]][Start[1]] != 0){\n        DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n      }\n      if(is_goal){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing V = vector<int>;\nusing VV = vector<V>;\nstruct P {int x, y;};\n\nint main() {\n\tint dx[] = {4, 2}, dy[] = {2, 4};\n\tfor (int w, h; w = in(), h = in();) {\n\t\tP s = {in() - 1, in() - 1}, g = {in() - 1, in() - 1};\n\t\tint n = in();\n\t\tVV m(h, V(w));\n\t\twhile (n--) {\n\t\t\tint c = in(), d = in(), x = in() - 1, y = in() - 1;\n\t\t\tfor (int i = 0; i < dy[d]; i++)\n\t\t\t\tfor (int j = 0; j < dx[d]; j++)\n\t\t\t\t\tm[i + y][j + x] = c;\n\t\t}\n\t\tint c = m[s.y][s.x];\n\t\tm[s.y][s.x] = 0;\n\t\tfunction<bool(int, int)> f = [&](int x, int y) {\n\t\t\tif (x == g.x && y == g.y)\n\t\t\t\treturn true;\n\t\t\tP d = {1, 0};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = x + d.x, ty = y + d.y;\n\t\t\t\tif (tx >= 0 && ty >= 0 && tx < w && ty < h && m[ty][tx] == c) {\n\t\t\t\t\tm[ty][tx] = 0;\n\t\t\t\t\tif (f(tx, ty))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswap(d.x, d.y *= -1);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\toutl(c ? f(s.x, s.y) ? \"OK\" : \"NG\" : \"NG\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\npair<int,int> pii;\n\nint main() {\n\tint w,h,n;\n\tint xs,ys;\n\tint xg,yg;\n\tint c,d,x,y;\n\tint v[101][101];\n\tint u[101][101];\n\tint flag=0;\n\tint xx[4]={-1,0,1,0};\n\tint yy[4]={0,1,0,-1};\n\tint xxx,yyy;\nwhile(cin>>w>>h,w||h){\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\n\tcin>>n;\n\tfill(v[0],v[101],0);\n\tfill(u[0],u[101],0);\n\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tv[x][y]=c;\tv[x+1][y]=c;\tv[x+2][y]=c;\tv[x+3][y]=c;\n\t\t\t\tv[x][y+1]=c;\tv[x+1][y+1]=c;\tv[x+2][y+1]=c;\tv[x+3][y+1]=c;\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tv[x][y]=c;\tv[x][y+1]=c;\tv[x][y+2]=c;\tv[x][y+3]=c;\n\t\t\t\tv[x+1][y]=c;\tv[x+1][y+1]=c;\tv[x+1][y+2]=c;\tv[x+1][y+3]=c;\n\t\t\t}\n\t}\n\tqueue<pair<int,int> > q;\n\tu[xs][ys]=1;\n\tint color=v[xs][ys];\n\tq.push(make_pair(xs,ys));\n\twhile(!q.empty()){\n\t\tpii=q.front();q.pop();\n\t\tif(pii.first==xg&&pii.second==yg){flag=1;break;}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\txxx=xx[i]+pii.first;\n\t\t\tyyy=yy[i]+pii.second;\n\t\t\tif(xxx>=1&&xxx<=w&&yyy>=1&&yyy<=h&&u[xxx][yyy]!=1&&color==v[xxx][yyy]){\n\t\t\t\tu[xxx][yyy]=1;\n\t\t\t\tq.push(make_pair(xxx,yyy));\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){cout<<\"OK\"<<endl;}\n\telse{cout<<\"NG\"<<endl;}\n\tflag=0;\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\tusing namespace std;\n\tint xs,ys,w,h,n,ban[111][111],xg,yg;bool visited[101][101];\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\t\t\tif(c-1||ban[x][y]!=c)return false;\n\t\tif(xg==x&&yg==y)return true;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==c&&visited[x+1][y]==false){\n\t\t\tvisited[x+1][y]=true;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c&&visited[x][y+1]==false){\n\t\t\tvisited[x][y+1]=true;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==c&&visited[x-1][y]==false){\n\t\t\tvisited[x-1][y]=true;\n\t\t\tif(dfs(x-1,y,c))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]=c&&visited[x][y-1]==false){\n\t\t\tvisited[x][y-1]=true;\n\t\t\tif(dfs(x,y-1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,color;\nstring res = \"NG\";\nMatrix board(101, vector<int>(101,0));\n\nvoid write(Matrix &board,int c, int d, int x, int y){\n  int width,length;\n  if(d == 0){ width = 4; length =2; }\n  if(d == 1){ width = 2; length =4; }\n  for(int i=0; i<width; ++i){\n    for(int j=0; j<length; ++j)\n      board[x+i][y+j]=c;\n  }\n}\nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && color==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && color==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && color==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && color==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  int c,d,x,y;\n  while(cin >> w >> h,w||h){\n    if( w==0 && h==0) return 0;\n    res = \"NG\";\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    //    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> c >> d >> x >> y;\n      --x; --y;\n      write(board,c,d,x,y);\n    }\n    color = board[xs][ys];\n    func(board,xs,ys);\n    cout << res << endl;\n    //    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<h;i++){\n\t\t\tfor(j=1;j<w;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tif(brock[ys][xs]!=brock[yg][xg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=ys;\n\t\t\tma.b=xs;\n\t\t\tma.c=brock[ys][xs];\n\t\t\tds[ys][xs]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==yg&&ba.b==xg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=h&&ba.b+q[i]>0&&ba.b+q[i]<=w&&ds[ba.a+p[i]][ba.b+q[i]]==0&&brock[ba.a+p[i]][ba.b+q[i]]==brock[yg][xg]){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(!w && !h)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(xs-1,ys-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int xs,int ys){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[xs][ys] == 0){\n    return 0;\n  }\n  else if(maps[xs][ys] == maps[xg-1][yg-1]){\n    return 1;\n  }\n  if(maps[xs-1][ys] == maps[xs][ys]){\n    return solve(xs-1,ys);\n  }\n  if(maps[xs][ys-1] == maps[xs][ys]){\n    return solve(xs,ys-1);\n  }\n  if(maps[xs+1][ys] == maps[xs][ys]){\n    return solve(xs+1,ys);\n  }\n  if(maps[xs][ys+1] == maps[xs][ys]){\n    return solve(xs,ys+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint x[4]={-1,1,0,0};\nint y[4]={0,0,-1,1};\nint color;\nvoid func(vector<vector<int> >&in,vector<vector<int> >&map,int a,int b){\n  //cout<<a<<\" \"<<b<<endl;\n  map[a][b]=2;\n  rep(i,4)if(in[a+x[i]][b+y[i]]==color&&map[a+x[i]][b+y[i]]==1)func(in,map,a+x[i],b+y[i]);\n}\nint main(){\n  int n,m;\n  while(cin>>m>>n,n||m){\n    vector<vector<int> >in(n+2,vector<int>(m+2));\n    int xs,ys,xg,yg;\n    cin>>ys>>xs>>yg>>xg;\n    int q;\n    cin>>q;\n    rep(i,q){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      if(b)rep(i,2)rep(j,4)in[i+c][j+d]=a;\n      else rep(i,4)rep(j,2)in[i+c][j+d]=a;\n    }\n    //cout<<n<<\" \"<<m<<endl;\n    //loop(i,1,n+1){loop(j,1,m+1)cout<<\" \"<<in[i][j];cout<<endl;}\n\n    if(in[xs][ys]==0||in[xg][yg]==0){cout<<\"NG\"<<endl;continue;}\n    color=in[xs][ys];\n    vector<vector<int> >map(n+2,vector<int>(m+2));\n    loop(i,1,n+1)loop(j,1,m+1)map[i][j]=1;\n    //loop(i,1,n+1){loop(j,1,m+1)cout<<\" \"<<map[i][j];cout<<endl;}\n\n    func(in,map,xs,ys);\n    if(map[xg][yg]==2)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    //cout<<n<<\" \"<<m<<endl;\n    //loop(i,1,n+1){loop(j,1,m+1)cout<<\" \"<<map[i][j];cout<<endl;}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\nbool ok = false;\nint w, h;\nvector< vector<int> > Field;\nP goal;\n\nvoid DFS(int x, int y, int c)\n{\n\tif(x == goal.first && y == goal.second)\n\t{\n\t\tok = true;\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tField[y][x] = -1;\n\t}\n\tfor(int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && Field[ny][nx] == c)\n\t\t{\n\t\t\tDFS(nx, ny, c);\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\twhile(cin >> w >> h, w || h)\n\t{\n\t\tok = false;\n\t\tField.resize(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tField[i].resize(w);\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tField[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tP start;\n\t\tcin >> start.first >> start.second;\n\t\t--start.first; --start.second;\n\t\tcin >> goal.first >> goal.second;\n\t\t--goal.first; --goal.second;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t--x; --y;\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < 2; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < 4; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tField[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1) \n\t\t\t{\n\t\t\t\tfor(int i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < 2; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tField[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDFS(start.first, start.second, Field[start.second][start.first]);\n\t\tif(ok)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <ctime>\n#define INF 100000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n \n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint maze[305][305];\nint w,h,xs,ys,xg,yg;\n\nvoid init(){\n  rep(i,305){\n    rep(j,305){\n      maze[i][j]=-1;\n    }\n  }\n}\n\nbool bfs(int c){\n  queue<int>que;\n  que.push(xs);\n  que.push(ys);\n  while(que.size()){\n    int x=que.front();que.pop();\n    int y=que.front();que.pop();\n    if(x==xg&&y==yg)return true;\n    for(int i=0;i<4;i++){\n      if(0<=x+dx[i]&&x+dx[i]<=w&&0<=y+dy[i]&&y+dy[i]<=h&&maze[y+dy[i]][x+dx[i]]==c){\n\tque.push(x+dx[i]);\n\tque.push(y+dy[i]);\n\tmaze[y+dy[i]][x+dx[i]]=-1;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n,c,d,x,y;\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    init();\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    rep(i,n){\n      cin>>c>>d>>x>>y;\n      if(d==0){\n\trep(j,2){\n\t  rep(k,4){\n\t    maze[y+j][x+k]=c;\n\t  }\n\t}\n      }else if(d==1){\n\trep(j,4){\n\t  rep(k,2){\n\t    maze[y+j][x+k]=c;\n\t  }\n\t}\n      }\n    }\n    if(bfs(c))cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int Y, int X, int C, int yg, int xg)\n{\n  if(Y == yg && X == xg)\n    return true;\n  if(F[Y][X]!=C)\n    return false;\n\n  F[Y][X] = 0;\n\n  bool tmp = 0;\n  tmp += DFS(Y-1, X, C, yg, xg);\n  tmp += DFS(Y+1, X, C, yg, xg);\n  tmp += DFS(Y, X-1, C, yg, xg);\n  tmp += DFS(Y, X+1, C, yg, xg);\n  return tmp;\n}\n\nint main()\n{\n  while(1){\n    int w, h;\n    cin >> w >> h;\n\n    if(w == 0 && h == 0)\n      return 0;\n\n    int xs, ys;\n    cin >> xs >> ys;\n\n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c, d, x, y;\n    for(int i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d == 0)\n        for(int j=0; j<2; j++)\n          for(int k=0; k<4; k++)\n            F[y+j][x+k] = c;\n      else\n        for(int j=0; j<4; j++)\n          for(int k=0; k<2; k++)\n            F[y+j][x+k] = c;\n    }\n\n    bool res = DFS(ys, xs, F[ys][xs], yg, xg);\n\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\nstruct point{\n    int x,y;\n    point(){}\n    point(int a, int b){x = a;y = b;}\n};\nint main(void){\n\n    int w,h;\n    while(cin>>w>>h,w){\n        int xs,ys,xg,yg,n;\n        cin>>xs>>ys>>xg>>yg>>n;\n        int field[100][100] = {{0}};\n        for(int i = 0;i < n;i++){\n            int c,d,x,y;\n            int dw = 4,dh = 2;\n            cin>>c>>d>>x>>y;\n            if(d)swap(dw,dh);\n            for(int di = y;di < dh + y && di < h; di++){\n                for(int dj = x;dj < dw + x && dj < w;dj++){\n                    field[di][dj] = c;\n                }\n            }\n        }\n        int C = field[xs][ys];\n        bool vis[100][100] = {{false}};\n        queue<point> Q;\n        Q.push(point(xs,ys));\n        while(!Q.empty()){\n            point P = Q.front();\n            vis[P.x][P.y] = true;\n            Q.pop();\n            for(int i = 0;i < 4;i++){\n                point p = point(P.x + dx[i],P.y + dy[i]);\n                if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h){\n                    if(!vis[p.x][p.y]&&field[p.x][p.y] == C){\n                        Q.push(p);\n                    }\n                }\n\n            }\n        }\n        if(vis[xg][yg])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\nint b[102][102];\n\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\n\nbool input() {\n  cin >> w >> h;\n  if (!w && !h) {\n    return false;\n  }\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      b[i][j] = -1;\n    }\n  }\n  cin >> xs >> ys;\n  cin >> xg >> yg;\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    int c, d, x, y;\n    cin >> c >> d >> x >> y;\n    if (!d) {\n      for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < 4; ++j) {\n          b[y + i][x + j] = c;\n        }\n      }\n    } else {\n      for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          b[y + i][x + j] = c;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nvoid dfs(int c, int y, int x) {\n  if (b[y][x] != c) {\n    return;\n  }\n  b[y][x] = -1;\n  for (int i = 0; i < 4; ++i) {\n    dfs(c, y + dy[i], x + dx[i]);\n  }\n}\n\nvoid solve() {\n  if (b[ys][xs] != b[yg][xg]) {\n    cout << \"NG\" << endl;\n    return;\n  }\n\n  dfs(b[ys][xs], ys, xs);\n  if (b[yg][xg] == -1) {\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n}\n\nint main() {\n  while (input()) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, b[101][101];\nint dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n\nbool dfs(int x, int y){\n\n  int nx, ny;\n  b[x][y] = 0;\n  if(x == xg && y == yg) return true;\n  bool r = 0;\n  rep(i, 4){\n    nx = x + dx[i]; ny = y + dy[i];\n    if(nx > 0 && nx <= h && ny > 0 && ny <= w && b[nx][ny]==c)r=r||dfs(nx, ny);\n  }\n  return r;\n}\n\nint main(){\n  while(scanf(\"%d %d\", &w, &h) && w && h){\n    memset(b, 0, sizeof(b));\n    scanf(\"%d%d%d%d\", &ys, &xs, &yg, &xg);\n    scanf(\"%d\", &n);\n    rep(i, n){\n      scanf(\"%d%d%d%d\", &c, &d, &y, &x);\n      rep(j, (d?4:2)) rep(k, (d?2:4)) b[x + j][y + k] = c;\n    }\n    /*    rep(i, h){\n      rep(j, w) printf(\"%d \", b[i][j]);\n      puts(\"\");\n      }*/\n    c = b[xs][ys];\n    //    printf(\"%d\\n\", c);\n    //    fprintf(stderr, \"error\\n\");\n    if(c > 0 && dfs(xs, ys)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\tfor(int y = 0; y < 102; y++){\n\t\tfor(int x = 0; x < 102; x++){\n\t\t\tF[y][x] = -1;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\" << endl;\n\t}else{\n\t\tcout << \"NG\" << endl;\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nconst int inf=100000;\nusing namespace std;\nint sx,sy,gx,gy,col;\nvoid func(vector<vector<int> >out,vector<vector<bool> >&out2,int x,int y){\n  out2[x][y]=true;\n  loop(i,-1,2)loop(j,-1,2){\n    if(out[x+i][y+j]==inf)continue;\n    if(out2[x+i][y+j]!=true&&out[x+i][y+j]==col)func(out,out2,x+i,y+j);\n  }\n}\nint main(){\n  int n,m;\n  while(cin>>m>>n,n|m){\n    cin>>sx>>sy>>gx>>gy;\n    int nn;cin>>nn;\n    vector<vector<int> >out(n+2);\n    vector<vector<bool> >out2(n+2);\n    rep(i,n+2)rep(j,m+2){\n      if(i==0||i==n+1||j==0||j==m+1)out[i].pb(inf);\n      else out[i].pb(0);\n    }\n    rep(i,n+2)rep(j,m+2)out2[i].pb(false);\n    rep(q,nn){\n      int a,b,c,d;\n      cin>>a>>b>>d>>c;\n      if(b)rep(i,4)rep(j,2)out[i+c][j+d]=a;\n      else rep(i,2)rep(j,4)out[i+c][j+d]=a;\n    }/*\n    cout<<endl;\n    rep(i,n+2){\n      rep(j,m+2)cout<<\" \"<<out[i][j];\n      cout<<endl;\n      }*/\n    \n    if(out[gx][gy]==0||out[gx][gy]!=out[sx][sy]||out[sx][sy]==0){\n      cout<<\"NG\"<<endl;\n      continue;\n    }\n    col=out[sx][sy];\n    func(out,out2,sx,sy);\n    if(out2[gx][gy])cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    /*rep(i,n){\n      rep(j,m)cout<<\" \"<<out[i+1][j+1];\n      cout<<endl;\n      }*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nint xg, yg;\nint data[102][102];\nint dx[]={0, 1, 0, -1};\nint dy[]={-1, 0, 1, 0};\nbool dfs(int, int, int);\n\nmain(){\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    int xs, ys, n;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<=h+1;i++){\n      for(int j=0;j<=w+1;j++){\n\tdata[i][j]=0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      if(d==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    data[i+y][j+x]=c;\n\t  }\n\t}\n      }else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<4;j++){\n\t    data[i+y][j+x]=c;\n\t  }\n\t}\n      }\n    }\n    if(dfs(ys, xs, data[ys][xs])){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n  return 0;\n}\n\nbool dfs(int y, int x, int c){\n  if(c==0 || data[y][x]!=c) return false;\n  if(y==yg && x==xg) return true;\n  data[y][x]=0;\n  for(int i=0;i<4;i++){\n    if(dfs(y+dy[i], x+dx[i], c)) return true;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int Y, int X, int C, int yg, int xg)\n{\n  if(Y == yg && X == xg)\n    return true;\n  if(F[Y][X]!=C)\n    return false;\n\n  F[Y][X] = 0;\n\n  bool tmp = 0;\n  tmp += DFS(Y-1, X, C, yg, xg);\n  tmp += DFS(Y+1, X, C, yg, xg);\n  tmp += DFS(Y, X-1, C, yg, xg);\n  tmp += DFS(Y, X+1, C, yg, xg);\n  return tmp;\n}\n\nint main()\n{\n  while(1){\n    F[102][102] = {};\n\n    int w, h;\n    cin >> w >> h;\n\n    if(w == 0 && h == 0)\n      return 0;\n\n    int xs, ys;\n    cin >> xs >> ys;\n\n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c, d, x, y;\n    for(int i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d == 0)\n        for(int j=0; j<2; j++)\n          for(int k=0; k<4; k++)\n            F[y+j][x+k] = c;\n      else\n        for(int j=0; j<4; j++)\n          for(int k=0; k<2; k++)\n            F[y+j][x+k] = c;\n    }\n\n    bool res = DFS(ys, xs, F[ys][xs], yg, xg);\n\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int x, int y, int c){\n      if(F[x][y]!=c)\n            return;\n\n      F[x][y] = -1;\n\n      DFS(x+1, y  , c);\n      DFS(x  , y+1, c);\n      DFS(x-1, y  , c);\n      DFS(x  , y-1, c);\n}\n\nint main(){\n      int w,h, xs,ys, xg,yg, n;\n      while(1){\n            cin >> w >> h;\n            if(w==0)    break;\n            cin >> xs >> ys;\n            cin >> xg >> yg;\n            cin >> n;\n\n            int c, d, x, y;\n            for(int i=1; i<=n; i++){\n                  cin >> c >> d >> x >> y;\n                  if(d==0){\n                        for(int fx=x; fx<=x+3; fx++){\n                        F[fx][y]   = c;\n                        F[fx][y+1] = c;\n                        }\n                  }\n                  else if(d==1){\n                        for(int fy=y; fy<=y+3; fy++){\n                        F[x][fy]   = c;\n                        F[x+1][fy] = c;\n                        }\n                  }\n            }\n\n            DFS(xs, ys, F[x][y]);\n            if(F[xg][yg]==-1)\n                  cout << \"OK\" << endl;\n            else\n                  cout << \"NG\" << endl;\n      }\n\n      return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nint xs,ys,xg,yg,n;\nll w,h;\nvector<vector<ll>> field;\nvector<vector<ll>> f;\nbool res = false;\n\nvoid dfs(int x,int y,int c){\n  if(f[x][y] != inf) return ;\n  if(x == xg && y == yg){\n    res = true;\n    return ;\n  }\n  f[x][y] = 1;\n  rep(i,4){\n    int nx = x + dx[i],ny = y + dy[i];\n    if(value(nx,ny,w,h) && field[nx][ny] == c){\n      dfs(nx,ny,c);\n    }\n  }\n  return ;\n}\n\nvoid solve(){\n  f = vector<vector<ll>>(w+1,vector<ll>(h+1,inf));\n  res = false;\n  if(field[xs][ys] != inf){\n    dfs(xs,ys,field[xs][ys]);\n  }\n  if(res){\n    cout << \"OK\" << endl;\n    return ;\n  }\n  cout << \"NG\" << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> w >> h && w+h){\n    field = vector<vector<ll>>(w+1,vector<ll>(h+1,inf));\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--,ys--,xg--,yg--;\n    int c,d,x,y;\n    rep(i,n){\n      cin >> c >> d >> x >> y;\n      --x,--y,--c;\n      rep(j,2){\n        rep(k,4){\n          ll nx = k,ny = j;\n          if(d){\n            swap(nx,ny);\n          }\n          field[x+nx][y+ny] = c;\n        }\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nint w,h;\nint sx,sy,gx,gy;\nint n;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nbool used[120][120];\nint f[120][120];\nvoid set(int c,int d,int x,int y)\n{\n\tif(d==0)\n\t{\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tf[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nbool judge()\n{\n\tif(f[sx][sy]!=f[gx][gy])return false;\n\tmemset(used,false,sizeof(used));\n\tqueue<P> q;\n\tq.push(mp(sx,sy));\n\tused[sx][sy]=true;\n\twhile(!q.empty())\n\t{\n\t\tP a=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nx=a.fi+dx[i],ny=a.sec+dy[i];\n\t\t\tif(nx<=0||nx>w||ny<=0||ny>h)continue;\n\t\t\tif(used[nx][ny]||f[nx][ny]!=f[a.fi][a.sec])continue;\n\t\t\tif(nx==gx&&ny==gy)return true;\n\t\t\tused[nx][ny]=true;\n\t\t\tq.push(mp(nx,ny));\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tscanf(\"%d %d\",&h,&w);\n\t\tif(w==0&&h==0)break;\n\t\tscanf(\"%d %d\",&sy,&sx);\n\t\tscanf(\"%d %d\",&gy,&gx);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&y,&x);\n\t\t\tset(c,d,x,y);\n\t\t}\n\t\tif(judge())puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n\tusing namespace std;\n\t\n\tint xs,ys,w,h,n,ban[111][111],xg,yg;bool visited[101][101];\n\t\tint vecx[4]={1,0,-1,0},vecy[4]={0,1,0,-1};\n\tstruct P{\n\t\tint xx,yy;\n\t};\t\n\t\n\tqueue<P> jo;\n\tbool bfs(void){\t\n\t\twhile(!jo.size()==0){\n\t\tP now=jo.front();jo.pop();\n\t\tif(now.xx==-1||now.yy==-1)return false;\n\t\tif(now.xx==xg&&now.yy==yg)return true;\n\t\tint x=now.xx,y=now.yy;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(ban[x+vecx[i]][y+vecy[i]]==ban[xs][ys]){\n\t\t\t\tif(!visited[x+vecx[i]][y+vecy[i]]){\n\t\t\t\tP next={x+vecx[i],y+vecy[i]};\n\t\t\t\tvisited[x+vecx[i]][y+vecy[i]]=true;\n\t\t\t\tjo.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\treturn 0;\n\t}\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\t\tP start={xs,ys};\n\tjo.push(start);\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(bfs())cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nint w,h,xg,yg,xs,ys,n,fld[101][101];\nbool dfs(int x,int y,int c){\n\tif(c==0||fld[x][y]!=c)return false;\n\tif(x==xg&&y==yg)return true;\n\tfld[x][y]=0;\n\tfor(int i=0;i<4;i++)if(dfs(x+dx[i],y+dy[i],c))return true;\n\treturn false;\n}\nint main(){\n\twhile(cin>>w>>h,w,h){\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y,cc,d,r,l;\n\t\t\tcin>>cc>>d>>x>>y;\n\t\t\tif(d){r=4;l=2;}else{r=2;l=4;}\n\t\t\tfor(int j=x;j<x+l;j++)for(int k=y;k<y+r;k++)fld[j][k]=cc;\n\t\t}\n\t\tif(dfs(xs,ys,fld[xs][ys]))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tboard[i][j]=0;\n\tcheak[i][j]=0;\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << board[i][j];\n      }\n      cout << endl;\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs-1,ys-1)==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==board[ys-1][xs-1] && cheak[yn][xn]==0){\n      if(dfs(xn,yn)==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    int xs,ys,xg,yg,n;\n    cin>>xs>>ys>>xg>>yg>>n;\n    --xs,--ys,--xg,--yg;\n    int maze[w][h];\n    memset(maze,0,sizeof(maze));\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      --x,--y;\n      rep(i,4-d*2)rep(j,2+d*2)maze[x+i][y+j]=c;\n    }\n    queue<PI> Q;\n    if(maze[xs][ys]== 0 || maze[xs][ys]!=maze[xg][yg] || maze[xg][yg]==0){\n      puts(\"NG\");\n      continue;\n    }\n    bool goal=false;\n    Q.push(mp(xs,ys));\n    int dp[w][h];\n    memset(dp,0,sizeof(dp));\n    dp[xs][ys]=1;\n    while(!Q.empty()){\n      int cx=Q.front().f,cy=Q.front().s;Q.pop();\n      if(cx==xg && cy==yg){\n        goal=true;\n        break;\n      }\n      rep(i,4){\n        int nx=cx+dx[i],ny=cy+dy[i];\n        if(nx<0 || nx>=w || ny<0 || ny>=h || dp[nx][ny])continue;\n        if(maze[nx][ny]!=maze[xs][ys])continue;\n        dp[nx][ny]=1;\n        Q.push(mp(nx,ny));\n      }\n    }\n    cout<<(goal?\"OK\":\"NG\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdafx.h\"\n#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c || c != 0)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\t/*for (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nbool dfs(const vector<vector<int> >& v ,int x , int y , int w , int h , int xg , int yg , int sc){\n\tbool b;\n\tif(x==xg&&y==yg) {b=true;return b;}\n\tfor(int i=0;i<4;++i){\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(v[tx][ty]!=sc || v[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( v , tx,ty,w,h,xg,yg,sc);\n\t}\n\treturn b;\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tbool b=false;\n\t\tvector<vector<int> > board(101);\n\t\tfor(int i=0;i<101;++i) board[i].resize(101);\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse b=dfs(board ,xs,ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#pragma region defins\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\n#pragma endregion\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n    if (d == 0)//yokonaga\n    {\n        loop(i, 2)\n        {\n            loop(j, 4)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n    else//tatenaga\n    {\n        loop(i, 4)\n        {\n            loop(j, 2)\n            {\n                grid[y + i][x + j] = c;\n            }\n        }\n    }\n}\nbool dfs(int nx, int ny)\n{\n    if (nx == gx&&ny == gy)return true;\n    if (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n    grid_visited[nx][ny] = true;\n    bool a=false;\n    if(grid[nx + 1][ny]== grid[nx][ny])a|=dfs(nx + 1, ny);\n    if(grid[nx][ny+1]== grid[nx][ny])a|=dfs(nx, ny+1);\n    if(grid[nx - 1][ny]== grid[nx][ny])a|=dfs(nx - 1, ny);\n    if(grid[nx][ny-1]== grid[nx][ny])a|=dfs(nx, ny-1);\n    //return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n    return a;\n    return false;\n}\nint main()\n{\n    while (1)\n    {\n        cin >> w >> h;\n        if (!w && !h) break;\n        else\n        {\n            cin >> sx >> sy >> gx >> gy >> n;\n            sx--; sy--; gx--; gy--;\n            loop(i, n)\n            {\n                int c, d, x, y;\n                cin >> c >> d >> x >> y;\n                x--; y--;\n                input(c, d, x, y);\n            }\n            /*loop(i, h)\n            {\n                loop(j, w)\n                {\n                    cout << grid[i][j] << \" \";\n                }\n                cout << endl;\n            }*/\n            cout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint w,h;\nint sx,sy,gx,gy;\nint field[104][104];\n\nclass Info{\npublic:\n\tint x,y;\n};\n\nbool bfd(void){\n\tint search = field[sy-1][sx-1];\n\tint dx[4] = {1,-1,0,0};\n\tint dy[4] = {0,0,1,-1};\n\n\tqueue<Info> q;\n\tInfo tmp = {sx-1,sy-1};\n\n\tif(search == 0){return false;}\n\n\tq.push(tmp);\n\twhile(!q.empty()){\n\t\ttmp = q.front(); q.pop();\n\n\t\tif(tmp.x + 1 == gx && tmp.y + 1 == gy){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[tmp.y][tmp.x] = 0;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint nx = tmp.x + dx[k];\n\t\t\tint ny = tmp.y + dy[k];\n\n\t\t\tif(nx>=0 && ny>=0 && nx<w && ny<h && field[ny][nx]==search){\n\t\t\t\tInfo tmp2 = {nx,ny};\n\t\t\t\tq.push(tmp2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid put_block(int c,int d,int x,int y){\n\tint i,j;\n\tint to_i=2,to_j=4;\n\n\tif(d == 1){to_i=4,to_j=2;}\n\n\tfor(i=0;i<to_i;i++){\n\t\tfor(j=0;j<to_j;j++){\n\t\t\tfield[y+i-1][x+j-1] = c;\n\t\t}\n\t}\n}\n\nint main(void){\n\tint n,c,d,x,y;\n\n\twhile(cin>>w>>h && w){\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\n\t\tmemset(field,0,sizeof(field));\n\t\twhile(n--){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tput_block(c,d,x,y);\n\t\t}\n\n\t\tif(bfd()){\n\t\t\tcout<<\"OK\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w, h, n;\nint sx, sy, gx, gy;\nint t[102][102];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nbool check(int x, int y, int c){\n  if(x == gx && y == gy) return true;\n\n  t[y][x] = -1;\n\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] != c) continue;\n    if(check(nx, ny, c)) return true;\n  }\n\n  return false;\n}\n\nvoid putBlock(int c, int d, int x, int y){\n  int addX = (d == 0 ? 4 : 2);\n  int addY = (d == 0 ? 2 : 4);\n\n  for(int i = y; i < y + addY; i++){\n    for(int j = x; j < x + addX; j++){\n      t[i][j] = c;\n    }\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w || h){\n    cin >> sx >> sy; sx--; sy--;\n    cin >> gx >> gy; gx--; gy--;\n    cin >> n;\n\n    memset(t, -1, sizeof(t));\n\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n\n      x--;\n      y--;\n      putBlock(c, d, x, y);\n    }\n\n    /*\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        printf(\"%2d\", t[i][j]);\n      }\n      cout<<endl;\n    }\n    */\n\n    if(t[sy][sx] != -1 && check(sx, sy, t[sy][sx])){\n      cout << \"OK\\n\";\n    }\n    else{\n      cout << \"NG\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    for(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=-1;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  if(F[xs][ys] == 0){\n    cout << \"NG\" << endl;\n  } else {\n    DFS(xs,ys,F[xs][ys]);\n  \n    if(F[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" <<endl;\n    }\n  }\n\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,a,n,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,false,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]&&R!=0){\n\t\t\tif(block(Y,X)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=true;\n\tif(ga==a&&gb==b) return true;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==false) return block(b,a+1);} //???\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==false) return block(b+1,a);} //???\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==false) return block(b,a-1);} //???\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==false) return block(b-1,a);} //???\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint weight, hight;\nint g[101][101] = {0};\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, 1, -1};\nconst int vy[4] = {1, -1, 0, 0};\n \nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n    \n    if(g[y][x] == 0){\n        flag = false;\n        return;\n    }\n    \n    g[y][x] = -1;\n    \n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n         \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            dfs(nx, ny);\n        }\n    }\n    return;\n}\n \nint main(){\n    while(1){\n        int n, c, d, x, y;\n        flag = false;\n        g[101][101] = {0};\n        \n        cin >> weight >> hight;\n        \n        if(weight == 0 && hight == 0){\n            break;\n        }\n         \n        cin >> sx >> sy >> gx >> gy >> n;\n         \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n             \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n         \n        sc = g[sy][sx];\n        dfs(sx, sy);\n         \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n    /*\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++)cout << grid[i][j];\n      cout << endl;\n    }\n    */\n    int color = grid[ys][xs];    \n    queue<P> q;\n    if(color){\n      q.push(P(ys,xs));\n      \n      while(q.size()){\n\tP p = q.front();q.pop();\n\ty = p.first;\n\tx = p.second;\n\tif(yg == y && xg == x){\n\t  cout << \"OK\\n\";\n\t  q.push(P(y,x));\n\t  break;\n\t}\n\tvisit[y][x] = true;\n\t\n\tint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\tfor(int i=0;i<4;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t\n\t  if(sx<0 || sy<0 || w<=sx || h<=sy)continue;\n\t  \n\t  if(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\t  q.push(P(sy,sx));\n\t}\n      }\n    }\n    if(q.empty())cout << \"NG\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint color[200][200];\nbool flg[200][200];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint w,h,n,c,d,x,y;\n\nvoid dfs(int ny,int nx,int gy,int gx){\n\tflg[ny][nx]=true;\n\trep(i,4){\n\t\tint nex=nx+dx[i];\n\t\tint ney=ny+dy[i];\n\t\tif(nex>=w || nex<0 || ney>=h || ney<0)continue;\n\t\tif(color[ney][nex]==color[ny][nx] && flg[ney][nex]==false)dfs(ney,nex,gy,gx);\n\t}\n\treturn;\n}\n\nint main(){\n\tpair<int,int> s,g;\n\twhile(1){\n\t\trep(i,200)rep(j,200)color[i][j]=flg[i][j]=0;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)break;\n\t\tcin>>s.first>>s.second;\n\t\tcin>>g.first>>g.second;\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\trep(j,2){\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\tcolor[y-1+j][x-1+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(j,4){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tcolor[y-1+j][x-1+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(s.second-1,s.first-1,g.second-1,g.first-1);\n\t\tif(flg[g.second-1][g.first-1])cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 101;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\nint sc;\nvoid dfs(int x, int y){\n    maze[x][y] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) flag = 1;\n                dfs(nx, ny);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[x-1+dx][y-1+dy] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[x-1+dx][y-1+dy] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[xs][ys]) maze[i][j] = 0;\n\n    //search\n    dfs(xs-1, ys-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\ntypedef struct{\n\tint x;\n\tint y;\n}point;\n\nint main(){\n\twhile(1){\n\t\tint f[101][101];\n\t\tint w, h, n;\n\t\tpoint s, g;\n\t\t\n\t\tmemset(f, 0, sizeof(f));\n\t\t\n\t\t//入力\n\t\tscanf(\" %d %d\", &w, &h);\n\t\tif(w==0) break;\n\t\t\n\t\tscanf(\" %d %d %d %d\", &s.x, &s.y, &g.x, &g.y);\n\t\tscanf(\" %d\", &n);\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, bx, by;\n\t\t\tscanf(\" %d %d %d %d\", &c, &d, &bx, &by);\n\t\t\t\n\t\t\tif(d==0){\n\t\t\t\tfor(int j=0; j<2; ++j){\n\t\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\t\tf[by+j][bx+k]=c;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int j=0; j<4; ++j){\n\t\t\t\t\tfor(int k=0; k<2; ++k){\n\t\t\t\t\t\tf[by+j][bx+k]=c;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//bfs\n\t\tint dx[4]={1,0,-1,0}, dy[4]={0,1,0,-1};\n\t\tint color=f[s.y][s.x]; //スタート地点のブロックの色\n\t\tqueue<point> que;\n\t\tf[s.y][s.x]=6; //訪問済み\n\t\tque.push(s);\n\t\t\n\t\twhile( !que.empty() ){\n\t\t\tpoint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\tint nx=v.x+dx[i], ny=v.y+dy[i];\n\t\t\t\t\n\t\t\t\tif(nx>0 && nx<=w && ny>0 && ny<=h && f[ny][nx]==color){\n\t\t\t\t\tf[ny][nx]=6;\n\t\t\t\t\tpoint tmp;\n\t\t\t\t\ttmp.x=nx; tmp.y=ny;\n\t\t\t\t\tque.push(tmp);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n\t\t//ゴールにたどり着いているか判定\n\t\tif(f[g.y][g.x]==6) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\t\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys])\n  if(x == 8){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint map[105][105];\nint xg,yg;\nint w,h;\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nbool check(int x,int y)\n{\n  if(x==xg && y==yg)\n    return true;\n  if(map[x][y]==-1)\n    return false;\n  if(x>h||y>w||x<=0||y<=0)\n    return false;\n  \n  char buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]<=h && x+dx[i]>=0 &&\n\t y+dy[i]<=w && y+dy[i]>=0 &&\n\t map[x+dx[i]][y+dy[i]]==buf && \n\t check(x+dx[i],y+dy[i])\n\t )\n\treturn true;\n    }\n  return false;\n}\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>xs>>ys;\n      cin>>xg>>yg;\n      int n;\n      cin>>n;\n      for(int i=0;i<n;i++)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;      \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n if(C[W][H]!=c){\n   return;\n }\n\n C[W][H] = -1;\n\n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n\nvoid print(int w,int h){\n   for(int i=1;i<=w;i++){\n       for(int j=1;j<=h;j++){\n           cout<<C[i][j]<<' ';\n       }\n       cout<<endl;\n   }\n}\n\nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n   if(w==0 && h==0){\n     break;\n   }\n\n   for(int i=0;i<20;i++){\n     for(int j=0;j<20;j++){\n       C[i][j] = 0;\n     }\n   }\n\n   int xs,ys,xg,yg;\n   cin >> xs >> ys >> xg >> yg;\n\n   int n;\n   cin >> n;\n\n   int c,d,x,y;\n   for(int i=0;i<n;i++){\n     cin >> c >> d >> x >> y;\n\n     if(d==0){\n       for(int j=x;j<x+4;j++){\n         for(int k=y;k<y+2;k++){\n           C[j][k]=c;\n         }\n       }\n     }else{\n       for(int j=x;j<x+2;j++){\n         for(int k=y;k<y+4;k++){\n           C[j][k]=c;\n         }\n       }\n     }\n   }\n   //print(w,h);\n   //cout << endl;\n   meiro(xs,ys,C[xs][ys]);\n   //print(w,h);\n\n   if(C[xg][yg] == -1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105, 0));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool a = false;\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\tif ((nx + 1) >= 0 && ny >= 0 && (nx + 1) < h && ny < w)if (grid[nx + 1][ny] == grid[nx][ny])a |= dfs(nx + 1, ny);\n\tif (nx >= 0 && (ny + 1) >= 0 && nx < h && (ny + 1) < w)if (grid[nx][ny + 1] == grid[nx][ny])a |= dfs(nx, ny + 1);\n\tif ((nx - 1) >= 0 && ny >= 0 && (nx - 1) < h && ny < w)if (grid[nx - 1][ny] == grid[nx][ny])a |= dfs(nx - 1, ny);\n\tif (nx >= 0 && (ny - 1) >= 0 && nx < h && (ny - 1) < w)if (grid[nx][ny - 1] == grid[nx][ny])a |= dfs(nx, ny - 1);\n\t//return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn a;\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\tloop(j, w)\n\t\t\t{\n\t\t\tcout << grid[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tgrid = vector<vector<int> >(105, vector<int>(105, 0));\n\t\t\tgrid_visited = vector <vector<bool > > (105, vector<bool>(105, false));\n\t\t\ta = false;\n\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105, 0));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool a = false;\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\tif ((nx + 1) >= 0 && ny >= 0 && (nx + 1) < h && ny < w)if (grid[nx + 1][ny] == grid[nx][ny])a |= dfs(nx + 1, ny);\n\tif (nx >= 0 && (ny + 1) >= 0 && nx < h && (ny + 1) < w)if (grid[nx][ny + 1] == grid[nx][ny])a |= dfs(nx, ny + 1);\n\tif ((nx - 1) >= 0 && ny >= 0 && (nx - 1) < h && ny < w)if (grid[nx - 1][ny] == grid[nx][ny])a |= dfs(nx - 1, ny);\n\tif (nx >= 0 && (ny - 1) >= 0 && nx < h && (ny - 1) < w)if (grid[nx][ny - 1] == grid[nx][ny])a |= dfs(nx, ny - 1);\n\t//return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn a;\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\tloop(j, w)\n\t\t\t{\n\t\t\tcout << grid[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tgrid = vector<vector<int> >(105, vector<int>(105, 0));\n\t\t\tgrid_visited = vector <vector<bool > > (105, vector<bool>(105, false));\n\t\t\ta = false;\n\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[yg-1][xg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = 0;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c[102],d[102],x[102],y[102];\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c || Y > w || X > h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 0;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*****include*****/\n#include <iostream>\n#include <fstream>\n#include <queue>\n\n/*****名前空間*****/\nusing namespace std;\n\n/*****グローバル変数置き場*****/\n/*****その他関数置き場*****/\n/*****main関数*****/\nint main(){\n\t/*****変数置き場*****/\n\tint width;\n\tint height;\n\tint pField[101][101];\n\tint pVisited[101][101];\n\tint xs,ys;\n\tint xg,yg;\n\tint xn,yn;\n\tint x2,y2;\n\tint c,d,x,y;\n\tint n;\n\tqueue<int> Qx;\n\tqueue<int> Qy;\n\tint cs;\n\tint dx[] = {0,1,0,-1};\n\tint dy[] = {-1,0,1,0};\n\t/*****ファイルオープン*****/\t\n\t/*ofstream fout(\"output.txt\");\n\tifstream fin(\"input.txt\");\n\tif(!fout || !fin){\n\t\tcout << \"Can't open the file.\\n\";\n\t\treturn;\n\t}*/\n\t\n\t/*****処理部*****/\n\twhile(1){\n\t\txn = 0;\n\t\tyn = 0;\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int j=0;j<101;j++){\n\t\t\t\tpVisited[i][j] = 0;\n\t\t\t\tpField[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> width >> height;\n\t\tif(width == 0 && height == 0)\tbreak;\n\t\t//int *pField = new int [height][width];\n\t\t//int *pVisited = new int [height][width];\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tpField[j+y][k+x] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\t\tpField[j+y][k+x] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<21;i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tcout << pField[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcs = pField[ys][xs];\n\t\t//cout << cs << endl;\n\t\tQx.push(xs);\n\t\tQy.push(ys);\n\t\tpVisited[ys][xs] = 1;\n\t\twhile(!(Qx.empty() && Qy.empty())){\n\t\t\txn = Qx.front();\n\t\t\tQx.pop();\n\t\t\tyn = Qy.front();\n\t\t\tQy.pop();\n\t\t\t//cout << yn << \" \" << xn << endl;\n\t\t\t/*if(xn == xg && yn == yg){\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx2 = xn + dx[i];\n\t\t\t\ty2 = yn + dy[i];\n\t\t\t\tif(pField[y2][x2]==cs){\n\t\t\t\t\tif(!pVisited[y2][x2]){\n\t\t\t\t\t\tQx.push(x2);\n\t\t\t\t\t\tQy.push(y2);\n\t\t\t\t\t\tpVisited[y2][x2] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<21;i++){\n\t\t\tfor(int j=0;j<21;j++){\n\t\t\t\tcout << pVisited[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif(pVisited[yg][xg]){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\t/*****処理終了後*****/\n\t/*fout.close();\n\tfin.close();*/\n\t//delete[] pField;\n\t//delete[] pVisited;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n\n      if(d[i]==0 && c[i]==cbase){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1 && c[i]==cbase){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans == 1){\n      cout << \"OK\" << endl;\n    }\n    if(ans != 1 || C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==c){\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c){\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nvoid put(int,int,int,int);\nvoid tansaku(int,int);\n\nconst int nashi=-1;\nconst int tootta=10;\n\nint field[102][102];\nint main(int argc,char* argv[]){\n\twhile(1){\n\t\tint x_size,y_size;\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tint n;\n\t\tscanf(\"%d %d\",&x_size,&y_size);\n\t\tif(x_size==0)\n\t\t\treturn 0;\n\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\n\t\tfor(int i=0;i<y_size+2;i++)\n\t\t\tfor(int j=0;j<x_size+2;j++)\n\t\t\t\tfield[i][j]=nashi;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tput(c,d,x,y);\n\t\t}\n\n\t\ttansaku(sx,sy);\n\t\tif(field[gy][gx]==tootta)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n}\n\nvoid put(int c,int d,int x,int y){\n\tconst int size[2][2]={{4,2},{2,4}};\n\tfor(int i=0;i<size[d][1];i++){\n\t\tfor(int j=0;j<size[d][0];j++){\n\t\t\tfield[y+i+1][x+j+1]=c;\n\t\t}\n\t}\n}\n\nvoid tansaku(int sx,int sy){\n\tint c=field[sy][sx];\n\tfield[sy][sx]=tootta;\n\tif(field[sy][sx-1]==c)\n\t\ttansaku(sx-1,sy);\n\tif(field[sy][sx+1]==c)\n\t\ttansaku(sx+1,sy);\n\tif(field[sy-1][sx]==c)\n\t\ttansaku(sx,sy-1);\n\tif(field[sy+1][sx]==c)\n\t\ttansaku(sx,sy+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg,w,h;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c || Y >w || X>h){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint a[1000][1000],memo[1000][1000];\nint xg,yg,w,h,ans;\n\nint solve(int xs,int ys){\n\n  if(xs == xg && ys == yg) return ans = 1;\n  if(memo[ys][xs] == 1) return memo[ys][xs];\n  memo[ys][xs] = 1;\n  a[ys][xs] = -1;\n\n  if(xs + 1 <= w && a[ys][xs+1] == a[yg][xg]) solve(xs+1,ys);\n  if(ys + 1 <= h && a[ys+1][xs] == a[yg][xg]) solve(xs,ys+1);\n  if(xs - 1 > 0 && a[ys][xs-1] == a[yg][xg]) solve(xs-1,ys);\n  if(ys - 1 > 0 && a[ys-1][xs] == a[yg][xg]) solve(xs,ys-1);\n\n}\n\nint main(){\n\n  int xs,ys;\n  int n;\n\n  while(1){\n    cin >> w >> h;\n    if(!w && !h) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n\n    memset(a,0,sizeof(a));\n    memset(memo,0,sizeof(memo));\n    ans = 0;\n\n    int c,d,x,y;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n\tfor(int j=0;j<4;j++){\n\t  a[y][x+j] = c;\n\t  a[y+1][x+j] = c;\n\t}\n      }\n\n      else if(d == 1){\n\tfor(int j=0;j<4;j++){\n\t  a[y+j][x] = c;\n\t  a[y+j][x+1] =c ;\n\t}\n      }\n    }\n\n    solve(xs,ys);\n\n    if(ans == 1) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tint h, w;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tint ys, xs, yg, xg;\n\t\tscanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\t\t--ys; --xs; --yg; --xg;\n\t\t\n\t\tvvi field(h, vi(w, 0));\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\t--x; --y;\n\t\t\trep(j, d?4:2){\n\t\t\t\trep(k, d?2:4){\n\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint road = field[ys][xs];\n\t\tif(!road)\n\t\t\tputs(\"NG\");\n\t\telse{\n\t\t\tvector<vector<bool> > visited(h, vector<bool>(w, false));\n\t\t\tqueue<pii> Q;\n\t\t\tQ.push(pii(ys, xs));\n\t\t\tbool ok = false;\n\t\t\twhile(!Q.empty()){\n\t\t\t\tpii pos = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tif(visited[pos.first][pos.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[pos.first][pos.second] = true;\n\t\t\t\tif(pii(yg, xg) == pos){\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst int dy[] = {-1, 0, 0, 1};\n\t\t\t\tconst int dx[] = {0, -1, 1, 0};\n\t\t\t\trep(i, 4){\n\t\t\t\t\tint py = pos.first + dy[i];\n\t\t\t\t\tint px = pos.second + dx[i];\n\t\t\t\t\tif(py<0 || h<=py || px<0 || w<=px || field[py][px]!=road)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tQ.push(pii(py, px));\n\t\t\t\t}\n\t\t\t}\n\t\t\tputs(ok ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  if(xs == 8){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n    while (true) {\n        int w, h;\n        cin >> w >> h;\n    \n        if (w==0 && h==0) {\n            break;\n        }\n    \n        int xs, ys;\n        cin >> xs >> ys;\n        xs -= 1;\n        ys -= 1;\n        \n        int xg, yg;\n        cin >> xg >> yg;\n        xg -= 1;\n        yg -= 1;\n    \n        int S[h][w];\n    \n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                S[i][j] = -1;\n            }\n        }\n    \n        int n;\n        cin >> n;\n        \n        for (int i=0; i<n; i++) {\n            int ci, di, xi, yi;\n            cin >> ci >> di >> xi >> yi;\n            xi -= 1;\n            yi -= 1;\n            \n            if (di==0) {\n                for (int i=yi; i<yi+2; i++) {\n                    for (int j=xi; j<xi+4; j++) {\n                        S[i][j] = ci;\n                    }\n                }\n            }\n            else {\n                for (int i=yi; i<yi+4; i++) {\n                    for (int j=xi; j<xi+2; j++) {\n                        S[i][j] = ci;\n                    }\n                }\n            }\n        }\n        \n        if (S[ys][xs]==-1) {\n            cout << \"NG\" << endl;\n            continue;\n        }\n        \n        int visited[h][w];\n        \n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                visited[i][j] = 0;\n            }\n        }\n        \n        queue<P> q;\n        q.push(P(ys, xs));\n        visited[ys][xs] = 1;\n        \n        while (q.size()) {\n            P p = q.front();\n            q.pop();\n            int cy = p.first;\n            int cx = p.second;\n            \n            for (int i=0; i<4; i++) {\n                int ny = cy+dy[i];\n                int nx = cx+dx[i];\n                \n                if (!(0<=ny && ny<h && 0<=nx && nx<w)) {\n                    continue;\n                }\n                \n                if (visited[ny][nx]==0 && S[ny][nx]==S[cy][cx]) {\n                    q.push(P(ny, nx));\n                    visited[ny][nx] = 1;\n                }\n            }\n        }\n        \n        if (visited[yg][xg]==1) {\n            cout << \"OK\" << endl;\n        }\n        else {\n            cout << \"NG\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1, yi);\n        solve(xi, yi-1);\n        solve(xi+1, yi);\n        solve(xi, yi+1);\n    }\n    block[xi][yi] = 0;\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(int)*w*h);\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            //cout << x << \",\"<< y << endl;\n            if(d==1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define loop(i,a,b) for(int i = a ; i < b ; i++)\n#define rep(i,a) for(int i = 0 ; i < a ; i ++)\n\nint maze[104][104];\nint h,w;\nint sx,sy ,  gx,gy , n;\nint co;\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\n\nbool inmaze(int x,int y){\n  return (0<=x && x<w) && (0<=y && y<h);\n}\n\nbool dfs(int x,int y){\n  //cout<<\"che\"<<x<<\" \"<<y<<endl;\n  if(x == gx && y == gy){\n    return true;\n    cout<<\"ok\"<<endl;\n  }\n  if(!inmaze(x,y))return false;\n  maze[x][y] = 10;\n  bool res = false;\n  rep(i,4)\n    if(maze[x + dx[i]][y + dy[i]] == co){\n      res = dfs(x+dx[i],y+dy[i]);\n      if(res)return true;\n    }\n  return res;\n}\n\nint main(void){\n  while(cin>>w>>h,w+h){\n    cin>>sx>>sy>>gx>>gy>>n;\n    sx--,sy--,gx--,gy--;\n    //cout<<sx<<\" \"<<sy<<\" \"<<gx<<\" \"<<gy<<endl;\n    rep(i,h)rep(j,w)maze[i][j] = -1;\n    rep(i,n){\n      int c,b,x,y;\n      cin>>c>>b>>x>>y;\n      x--,y--;\n      //cout<<x<<\" \"<<y<<endl;\n      rep(i,(b?2:4))\n\trep(j,(b?4:2))\n\tmaze[i+x][j+y] = c;\n    }\n    co = maze[sx][sy];\n    bool res = dfs(sx,sy); \n    cout<<(res?\"OK\":\"NO\")<<endl;\n   \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg,ok;\n\nvoid Maze(int X,int Y,int C){\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\t\n\n\tif(X==xg&&Y==yg){\n\t\tcout << \"OK\"<<endl;\n\t\tok++;\n\t}\n\n\tF[X][Y]='.';\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tok=0;\n\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\t\tfor(int i=1; i<=w; i++)\n\t\t\tfor(int j=1; j<=h; j++)\n\t\t\t\tF[j][i]=0;\n\n\t\tfor(int i=1; i<=w;i++){\n\t\t\t\tF[w+1][i]=6;\n\t\t\t\tF[0][i]=6;\n\t\t}\n\t\tfor(int i=1; i<=h;i++){\n\t\t\t\tF[i][h+1]=6;\n\t\t\t\tF[i][0]=6;\n\t\t}\n\n\t\tint N=0;\n\t\twhile(N<n){\n\t\t\tcin >>c>>d>>x>>y;\n\n\t\t\tif(d){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tN++;\n\t\t}\n\t\t\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t\tif(ok==0)\n\t\t\tcout <<\"NG\"<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<tuple>\n#include<utility>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<iomanip>\n#include<map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9 + 7;\nint dx[8] = { 1,0,-1,0,1,1,-1,-1 };\nint dy[8] = { 0,1,0,-1,1,-1,1,-1 };\n\nint h, w;\nint sy, sx, gy, gx;\nint n;\nint s[105][105] = { 0 };\nint color;\n\nvoid dfs(int y, int x) {\n\n\ts[y][x] = 10;\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w && s[ny][nx] == color) {\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\n\treturn;\n}\n\n\n\nint main() {\n\n\twhile (cin >> w >> h) {\n\t\tif (w == 0)break;\n\n\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tsx--, sy--, gx--, gy--;\n\n\t\tcin >> n;\n\n\t\tint c[200], d[200], x[200], y[200];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c[i] >> d[i] >> x[i] >> y[i];\n\t\t\tx[i]--, y[i]--;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\ts[y[i] + k][x[i] + j] = c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\ts[y[i] + k][x[i] + j] = c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tcolor = s[sy][sx];\n\n\t\tdfs(sy, sx);\n\n\n\t\t\n\n\t\tif (s[gy][gx] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\n\t\tfor (int i = 0; i < 105; i++) {\n\t\t\tfor (int j = 0; j < 105; j++) {\n\t\t\t\ts[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans,f=0;\nint map[100][100],v[100][100]={0};\nint root(int x,int y,int vmap[][100]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\nint field[102][102];\nbool visited[102][102];\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\nint d_x[] = {1, 0, -1, 0};\nint d_y[] = {0, -1, 0, 1};\n\nbool search(int y, int x) {\n  if (visited[y][x] || field[y][x] == 0) {return false;}  \n  if (y == yg && x == xg) {\n    return true;\n  }\n  visited[y][x] = true;\n  for (int i = 0; i < 4; i++) {\n    if (search(y + d_y[i], x + d_x[i])) {return true;}\n  }\n  return false;\n}\n\nint main()\n{\n  while (true) {\n    scanf(\"%d %d \", &w, &h);\n    if (w == 0 && h == 0) {\n      break;\n    }\n    scanf(\"%d %d \", &xs, &ys);\n    scanf(\"%d %d \", &xg, &yg);\n    scanf(\"%d \", &n);\n    for (int i = 0; i < 102; i++) {\n      fill(field[i], &field[i][102], 0);\n      fill(visited[i], &visited[i][102], false);\n    }\n    for (int i = 0; i < n; i++) {\n      int c, d, x, y;\n      scanf(\"%d %d %d %d \", &c, &d, &x, &y);\n      for (int i = 0; i < 2; i++) {\n\tfor (int j = 0; j < 4; j++) {\n\t  if (d == 0) {\n\t    field[y + i][x + j] = c;\n\t  } else {\n\t    field[y + j][x + i] = c;\n\t  }\n\t}\n      }\n    }\n    /*for (int i = 1; i <= h; i++) {\n      for (int j = 1; j <= w; j++) {\n\tprintf(\"%d \", field[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    if (search(ys, xs)) {cout << \"OK\" << endl;}\n    else {cout << \"NG\" << endl;}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define TATE 1\n#define YOKO 0\nint main(void){\n    int map[101][101];\n    int board[101][101];\n    int T[]={0,-1,1,0};\n    int Y[]={1,0,0,-1};\n    int w,h,xs,xg,ys,yg,n,color,muki,x,y;\n    struct ST {\n        int x;\n        int y;\n    };\n    ST RE;\n    ST GO;\n    queue<ST> Q;\n    while(1){\n        memset(map,0,sizeof(map));\n        memset(board,0,sizeof(board));\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys>>xg>>yg>>n;\n        for(int i=0;i<n;i++){\n            cin>>color>>muki>>x>>y;\n            if(muki==YOKO){\n                for(int j=0;j<4;j++){\n                    board[y][x+j]=board[y+1][x+j]=color;\n                }\n            }\n            else{\n                for(int j=0;j<4;j++){\n                    board[y+j][x]=board[y+j][x+1]=color;\n                }\n            }\n        }\n       /* for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        RE.x=xs;\n        RE.y=ys;\n        map[ys][xs]=1;\n        Q.push(RE);\n        int flag=0;\n        while(!Q.empty()){\n            RE=Q.front();\n            Q.pop();\n            if(RE.x==xg&&RE.y==yg&&board[RE.y][RE.x]==board[yg][xg]){\n                flag=1;\n                //cout<<RE.x<<\" \"<<RE.y<<endl;\n                break;\n            }\n            else{\n                for(int i=0;i<4;i++){\n                    GO=RE;\n                    if(GO.x+Y[i]>0&&GO.y+T[i]>0&&GO.x+Y[i]<101&&GO.y+T[i]<101&&board[GO.y+T[i]][GO.x+Y[i]]==board[yg][xg]&&map[GO.y+T[i]][GO.x+Y[i]]!=1){\n                        GO.x+=Y[i];\n                        GO.y+=T[i];\n                        map[GO.y][GO.x]=1;\n                        Q.push(GO);\n                    }\n                }\n            }\n        }\n       /* for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(flag==1){\n            cout<<\"OK\"<<endl;\n        }\n        else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\nusing namespace std;\nint w, h, xs, ys, xg, yg;\nint mp[110][110];\n\nbool dfs(int x, int y, int f) {\n  if (x >= w || y >= h || x < 0 || y < 0 || mp[y][x] != f)\n    return false;\n  if (y == yg && x == xg && mp[y][x] == f)\n    return true;\n  mp[y][x] = 9;\n  return dfs(x + 1, y, f) || dfs(x - 1, y, f) || dfs(x, y + 1, f) ||\n         dfs(x, y - 1, f);\n}\n\nint main() {\n  while (cin >> w >> h) {\n    if (w == 0 && h == 0)\n      break;\n    int n;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--;\n    ys--;\n    xg--;\n    yg--;\n    int c, d, x, y;\n    rep(i, n) {\n      cin >> c >> d >> x >> y;\n      if (d == 0) {\n        for (int i = y - 1; i < y + 1; i++)\n          for (int j = x - 1; j < x + 3; j++) {\n            mp[i][j] = c;\n          }\n      } else {\n        for (int i = y - 1; i < y + 3; i++)\n          for (int j = x - 1; j < x + 1; j++) {\n            mp[i][j] = c;\n          }\n      }\n    }\n    cout << (dfs(xs, ys, mp[ys][xs]) ? \"OK\" : \"NG\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar HW[102][102];\n\nvoid DFS(int Y,int X,char c)\n{\n\tif(HW[Y][X]=='0'||HW[Y][X]!=c)\n\t\treturn;\n\n\tHW[Y][X]='0';\n\t\n\tDFS(Y-1,X,c);\n\tDFS(Y,X+1,c);\n\tDFS(Y+1,X,c);\n\tDFS(Y,X-1,c);\n}\t\n\t\nint main()\n{\n\tint H,W;\n\tcin>>H>>W;\n\n\tfor(int y=1;y<=H+1;y++){\n\t\tfor(int x=1;x<=W;x++){\n\t\t\tcin>>HW[y][x];\n\t\t\tif(HW[y][1]=='0'&&HW[y][2]=='0'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(HW[y][1]=='0'&&HW[y][2]=='0'){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint count=0;\n\tfor(int y=1;y<=H;y++){\n\t\tfor(int x=1;x<=W;x++){\n\t\t\tif((HW[y][x]=='@')||(HW[y][x]=='#')||(HW[y][x]=='*')){\n\t\t\t\tcount++;\n\t\t\t\tDFS(y,x,HW[y][x]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<count<<endl;\n\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 0 || F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n\n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[102][102];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t        memset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nclass cordinate\n{\n\npublic:\n\tint x;\n\tint y;\n\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\n\n\t\tint w;\n\t\tint h;\n\t\tcin >> w >> h; \n\t\tif(w == 0 && h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint xs;\n\t\tint ys;\n\t\tcin >> xs >> ys;\n\t\tint xg;\n\t\tint yg;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<vector<int >> vobj;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tvector<int> lineobj;\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tlineobj.push_back(0);\n\n\t\t\t}\n\t\t\tvobj.push_back(lineobj);\n\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 2][y] = c;\n\t\t\t\tvobj[x + 3][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 2][y + 1] = c;\n\t\t\t\tvobj[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x][y + 2] = c;\n\t\t\t\tvobj[x][y + 3] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 2] = c;\n\t\t\t\tvobj[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\n\t\tint startColor;\n\t\tstartColor = vobj[xs - 1][ys - 1];\n\t\tqueue<cordinate> que;\n\n\t\tcordinate obj;\n\t\tobj.x = xs - 1;\n\t\tobj.y = ys - 1;\n\t\tque.push(obj);\n\t\tbool flag = false;\n\t\twhile(1)\n\t\t{\n\t\t\tif(startColor == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcordinate buf;\n\t\t\tbuf = que.front();\n\t\t\tque.pop();\n\n\t\t\tint bx;\n\t\t\tint by;\n\t\t\tbx = buf.x;\n\t\t\tby = buf.y;\n\t\t\tif(bx == xg - 1 && by == yg - 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif(bx + dx[i] >= 0 && bx + dx[i] <= w - 1)\n\t\t\t\t{\n\t\t\t\t\tif(by + dy[i] >= 0 && by + dy[i] <= h - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vobj[bx + dx[i]][by + dy[i]] == startColor)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcordinate newObject;\n\t\t\t\t\t\t\tnewObject.x = bx + dx[i];\n\t\t\t\t\t\t\tnewObject.y = by + dy[i];\n\t\t\t\t\t\t\tque.push(newObject);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvobj[bx][by] = -1;\n\n\t\t\tif(que.size() == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(flag == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t/*for(int i = 0; i < w - 1; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < h - 1; j++)\n\t\t\t{\n\t\t\t\tcout << vobj[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}  */\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w,h;\nint field[101][101];\nint sx,sy;\nint gx,gy;\nint n;\nint color;\nbool ans;\nvoid DFS(int x,int y)\n{\n\tfield[y][x] = -1;\n\tif(x == gx && y == gy)\n\t\tans = true;\n\tif(0<=x-1){\n\t\tif(color == field[y][x-1]){\n\t\t\tDFS(x-1,y);\n\t\t}\n\t}\n\tif(w>x+1){\n\t\tif(color == field[y][x+1]){\n\t\t\tDFS(x+1,y);\n\t\t}\n\t}\n\tif(0<=y-1){\n\t\tif(color == field[y-1][x]){\n\t\t\tDFS(x,y-1);\n\t\t}\n\t}\n\tif(h>y+1){\n\t\tif(color == field[y+1][x]){\n\t\t\tDFS(x,y+1);\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(!w&&!h)\n\t\t\tbreak;\n\t\tans = false;\n\t\tmemset(field,-1,sizeof(field));\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 0){\n\t\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcolor = field[sy][sx];\n\t\tif(color!= -1)\n\t\t\tDFS(sx,sy);\n\t\tif(ans)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][xs]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==1){//???\n\t\t\t\tfor(m=0;m<2;m++){\n\t\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//?¨?\n\t\t\t\tfor(m=0;m<4;m++){\n\t\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(brock[xs][ys]!=brock[xg][yg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[xs][ys];\n\t\t\tds[xs][ys]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==xg&&ba.b==yg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(ba.c==brock[xg][yg]){\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=w&&ba.b+q[i]>0&&ba.b+q[i]<=h&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=ba.c;\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define TATE 1\n#define YOKO 0\n\nstruct ST {\n        int x;\n        int y;\n    };\n\nint main(void){\n    int map[101][101];\n    int board[101][101];\n    int T[]={0,-1,1,0};\n    int Y[]={1,0,0,-1};\n    int w,h,xs,xg,ys,yg,n,color,muki,x,y;\n    \n    ST RE;\n    ST GO;\n    queue <ST> Q;\n    while(1){\n        memset(map,0,sizeof(map));\n        memset(board,0,sizeof(board));\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys>>xg>>yg>>n;\n        for(int i=0;i<n;i++){\n            cin>>color>>muki>>x>>y;\n            if(muki==YOKO){\n                for(int j=0;j<4;j++){\n                    board[y][x+j]=board[y+1][x+j]=color;\n                }\n            }\n            else{\n                for(int j=0;j<4;j++){\n                    board[y+j][x]=board[y+j][x+1]=color;\n                }\n            }\n        }\n       /* for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        RE.x=xs;\n        RE.y=ys;\n        map[ys][xs]=1;\n        Q.push(RE);\n        int flag=0;\n        while(!Q.empty()){\n            RE=Q.front();\n            Q.pop();\n            if(RE.x==xg&&RE.y==yg&&board[RE.y][RE.x]==board[yg][xg]){\n                flag=1;\n                //cout<<RE.x<<\" \"<<RE.y<<endl;\n                break;\n            }\n            else{\n                for(int i=0;i<4;i++){\n                    GO=RE;\n                    if(GO.x+Y[i]>0&&GO.y+T[i]>0&&GO.x+Y[i]<101&&GO.y+T[i]<101&&board[GO.y+T[i]][GO.x+Y[i]]==board[GO.y][GO.x]&&map[GO.y+T[i]][GO.x+Y[i]]!=1){\n                        GO.x+=Y[i];\n                        GO.y+=T[i];\n                        map[GO.y][GO.x]=1;\n                        Q.push(GO);\n                    }\n                }\n            }\n        }\n       /* for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(flag==1){\n            cout<<\"OK\"<<endl;\n        }\n        else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint s,t,u,v,n,c,d,x,y,i,j,f[102][102],a[4]={1,0,-1,0};int r(int x,int y){if(f[x][y]==c)for(int i=4;i-->0;f[x][y]=9)r(x+a[i],y+a[(i+3)%4]);}main(){for(;std::cin>>x>>y>>s>>t>>u>>v>>n,x;puts(f[u][v]-9?\"NG\":\"OK\")){for(j=0;j++<101;)for(i=0;i++<101;)f[i][j]=0;for(;n-->0;c=f[s][t]){std::cin>>c>>d>>x>>y;for(i=2;d&i-->0;)for(j=4;j-->0;)f[x+i][y+j]=c;for(i=4;!d&i-->0;)for(j=2;j-->0;)f[x+i][y+j]=c;}c&&r(s,t);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\nusing namespace std;\nstruct q{\n    int x,y,color,cnt;\n};\nqueue <q> pipe;\nq Main,sub;\nint sy,sx;\nint gy,gx;\nint w,h,n;\nint board[101][101];\nint visited[101][101];\nint state[4];\n\nvoid put(int mode,int color,int x,int y);\n\nint main(void){\n    cin>>w>>h;\n    while(w!=0&&h!=0){\n        cin>>sx>>sy;\n        cin>>gx>>gy;\n        cin>>n;\n        memset(board,0,sizeof(board));\n        memset(visited,0,sizeof(visited));\n        for(int i=0;i<n;i++){\n            cin>>state[0]>>state[1]>>state[2]>>state[3];\n            put(state[1],state[0],state[2],state[3]);\n        }\n        \n        Main.x=sx;\n        Main.y=sy;\n        Main.cnt=0;\n        Main.color=board[sx][sy];\n        visited[sx][sy]=1;\n        pipe.push(Main);\n        \n        int mx,fx[]={0,1,0,-1};\n        int my,fy[]={1,0,-1,0};\n        \n        while(!pipe.empty()){\n            Main=pipe.front();\n            pipe.pop();\n            for(int i=0;i<4;i++){\n                mx=Main.x+fx[i];\n                my=Main.y+fy[i];\n                if(mx>=1&&mx<=100&&my>=1&&my<=100&&Main.color==board[mx][my]&&visited[mx][my]==0){\n                    sub=Main; visited[mx][my]=1;\n                    sub.x=mx; sub.y=my; sub.cnt++;\n                    pipe.push(sub);\n                }\n            }\n        }\n        if(visited[gx][gy]==1){cout<<\"OK\"<<endl;}\n        else{cout<<\"NG\"<<endl;}\n        cin>>w>>h;\n    }\n}\n\nvoid put(int mode,int color,int x,int y){\n    int X[2],Y[2];\n    X[0]=4; Y[0]=2;\n    X[1]=2; Y[1]=4;\n    for(int i=x;i<x+X[mode];i++){\n        for(int j=y;j<y+Y[mode];j++){\n            board[i][j]=color;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101];\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y, int lastp){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc || i == lastp) return;\n\t\tfunc(x + nx[i], y + ny[i], (i + 2) % 4);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\twhile (1){\n\t\tfor (int i = 0; i < 101; i++){\n\t\t\tfor (int j = 0; j < 101; j++){\n\t\t\t\tstage[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tbw = 4;\n\t\t\t\tbh = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbw = 2;\n\t\t\t\tbh = 4;\n\t\t\t}\n\t\t\tfor (int j = 0; j < bh; j++){\n\t\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = stage[ys][xs];\n\t\tif (bc == 0){\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfunc(ys, xs, -1);\n\t\tif (ans == true) cout << \"OK\\n\";\n\t\telse cout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(ban[x][y+1]==CHECKED&&ban[x+1][y]==CHECKED)return false;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==c){\n\t\t\tban[x+1][y]=CHECKED;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c){\n\t\t\tban[x][y+1]=CHECKED;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nint w, h;\nint xs, ys, xg, yg, n, c, d, x, y;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid put_b(int a[][105]) {\n  int X, Y;\n  if(d == 0) X = 4, Y = 2;\n  else X = 2, Y = 4 ;\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j < X; j++)\n      a[y + i][x + j] = c;\n}\n\nbool bfs(int a[][105]) {\n  int cs = a[ys][xs];\n  if(cs != a[yg][xg]) return false;\n\n  //cout << ys << xs << endl;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while(que.size()) {\n    P p = que.front();\n    que.pop();\n    if(p.first == xg && p.second == yg) return true;\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(0 < nx && nx <= w && 0 < ny && ny <= h && a[ny][nx] == cs) {\n\tque.push(P(nx, ny));\n\ta[ny][nx] = 0;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  while(cin >> w >> h, w != 0 || h != 0) {\n    int a[105][105] = {};\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n  \n    while(n--) {\n      cin >> c >> d >> x >> y;\n      put_b(a);\n    }\n    /*\n     for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++)\n      cout << a[i][j];\n      cout << endl;\n      }\n    */\n    if(bfs(a) == true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nint main(void){\n\tint w,h;\n\t\n\twhile(cin >> w >> h){\n\t\tif((w|h) == 0) break;\n\t\tint f[w+2][h+2], sx, sy, ex, ey;\n\t\tbool reachable[w+2][h+2];\n\t\tmemset(f,-1,sizeof(f));\n\t\tmemset(reachable, false, sizeof(reachable));\n\t\t\n\t\tcin >> sx >> sy;\n\t\tcin >> ex >> ey;\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\t\tint color,d,px,py, hh, ww;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> color >> d >> px >> py;\n\t\t\tif(d == 0){\n\t\t\t\thh=2;\n\t\t\t\tww=4;\n\t\t\t}else{\n\t\t\t\thh=4;\n\t\t\t\tww=2;\n\t\t\t}\n\t\t\tfor(int p=0;p<hh;p++){\n\t\t\t\tfor(int q=0;q<ww;q++){\n\t\t\t\t\tf[px+q][py+p] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdeque<pair<int,int> > q;\n\t\treachable[sx][sy] = true;\n\t\tq.push_back(make_pair(sx,sy));\n\t\t\n\t\twhile(!q.empty()){\n\t\t\tpair<int,int> pii = q.front();\n\t\t\tq.pop_front();\n\t\t\treachable[pii.first][pii.second] = true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(f[pii.first][pii.second] == f[pii.first+dx[i]][pii.second+dy[i]] &&\n\t\t\t\treachable[pii.first+dx[i]][pii.second+dy[i]] == false){\n\t\t\t\t\treachable[pii.first+dx[i]][pii.second+dy[i]] = true;\n\t\t\t\t\tq.push_back(make_pair(pii.first+dx[i], pii.second+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(reachable[ex][ey]){\n\t\t\tcout << \"OK\" << endl;\n\t\t}else{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint xs, ys;\nint xg, yg;\nint maze[102][102];\n\nusing P = pair<int, int>;\nvoid solve() {\n    int c = maze[ys][xs];\n    queue<P> que;\n    que.push(P(ys, xs));\n    set<P> visited;\n    visited.insert(P(ys, xs));\n    bool ok = false;\n    while (que.size()) {\n        auto p = que.front();\n        que.pop();\n        int y = p.first;\n        int x = p.second;\n        if (yg == y && xg == x) ok = true;\n        rep(k, 4) {\n            int ny = y + dy[k];\n            int nx = x + dx[k];\n            if (ny < 0 || nx < 0) continue;\n            if (h <= ny || w <= nx) continue;\n            if (maze[ny][nx] != c) continue;\n            if (visited.count(P(ny, nx))) continue;\n            visited.insert(P(ny, nx));\n            que.push(P(ny, nx));\n        }\n    }\n    cout << (ok ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        rep(i, 102) rep(j, 102) maze[i][j] = -1;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        int n;\n        cin >> n;\n        rep(i, n) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                rep(i, 2) rep(j, 4) maze[y + i][x + j] = c;\n            } else {\n                rep(i, 4) rep(j, 2) maze[y + i][x + j] = c;\n            }\n        }\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n\nint F[500][500];\n\n//?????????????????????\nvoid r(int yy,int xx,int z){\n if(F[yy][xx]!=z){\n\treturn ;\n }\n\nF[yy][xx]=10;\n\nr(yy-1,xx,z);\nr(yy,xx+1,z);\nr(yy+1,xx,z);\nr(yy,xx-1,z);\n\n}\n\nvoid yoko(int c,int x,int y){\n F[x  ][y]=c;\n F[x+1][y]=c;\n F[x+2][y]=c;\n F[x=3][y]=c;\n F[x  ][y+1]=c;\n F[x+2][y+1]=c;\n F[x+3][y+1]=c;\n F[x+4][y+1]=c;\nreturn ;\n}\nvoid tate(int c,int x,int y){\n F[x][y  ]=c;\n F[x][y+1]=c;\n F[x][y+2]=c;\n F[x][y+3]=c;\n F[x+1][y  ]=c;\n F[x+1][y+1]=c;\n F[x+1][y+2]=c;\n F[x+1][y+3]=c;\nreturn ;\n}\n\nint main(){\n int w,h,xs,ys,xg,yg,n;\n int c,d,x,y;\n\nwhile(1){\n cin>>w>>h;\n\n//?????????????????????0???????????????\n if(w==0&&h==0)break;\n//???????????????????????????????????\\?????°????±??????£???????????????\n cin>>xs>>ys>>xg>>yg>>n;\n \n//n?????°???????????????????????????\nfor(int i=0;i<n;i++){\n\tcin>>c,d,x,y;//?????????????????¨????????±????????????\n\tif(d==0)yoko(c,x,y);\n\tif(d==1)tate(c,x,y);\n}\n\n//??\\????????????????????????\n\n//??????????????????\nr(xs,ys,F[xs][ys]);\n//??´???????????????\nif(F[xg][yg]==10){\n\tcout<<\"OK\"<<endl;\n}else{\n\tcout<<\"NG\"<<endl;\n}\n//?????????????????????\n}\nreturn 0;\n}\n\n\n\n\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nvoid putblock(int x,int y,int c,int d);\nbool bfs(std::pair<int,int> start,std::pair<int,int> goal);\n\nstd::queue< std::pair<int,int> > que;\nint board[102][102];\nbool visited[102][102];\n\nint main()\n{\n\tint n,w,h,x,y,c,d,xs,ys,xg,yg;\n\t\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tmemset(board,0,sizeof(board));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tputblock(x,y,c,d);\n\t\t}\n\n\t\tif(bfs(std::pair<int,int>(xs,ys),std::pair<int,int>(xg,yg)))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid putblock(int x,int y,int c,int d)\n{\n\tint h,w;\n\tif(d==0)\n\t{\n\t\th=2;\n\t\tw=4;\n\t}\n\telse\n\t{\n\t\th=4;\n\t\tw=2;\n\t}\n\tfor(int i=y;i<y+h;i++)\n\t{\n\t\tfor(int j=x;j<x+w;j++)\n\t\t{\n\t\t\tboard[i][j]=c;\n\t\t}\n\t}\n}\n\nbool bfs(std::pair<int,int> start,std::pair<int,int> goal)\n{\n\tint x,y;\n\tif(board[start.second][start.first]==0||board[goal.second][goal.first]==0)return false;\n\t\n\tque.push(start);\n\twhile(!que.empty())\n\t{\n\t\tx=que.front().first;\n\t\ty=que.front().second;\n\t\tque.pop();\n\t\tvisited[y][x]=true;\n\n\t\tif(x==goal.first&&y==goal.second)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif(board[y][x]==0){std::cin.get();}\n\n\t\tif(board[y-1][x]==board[y][x]&&!visited[y-1][x])que.push(std::pair<int,int>(x,y-1));\n\t\tif(board[y+1][x]==board[y][x]&&!visited[y+1][x])que.push(std::pair<int,int>(x,y+1));\n\t\tif(board[y][x-1]==board[y][x]&&!visited[y][x-1])que.push(std::pair<int,int>(x-1,y));\n\t\tif(board[y][x+1]==board[y][x]&&!visited[y][x+1])que.push(std::pair<int,int>(x+1,y));\n\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include <numeric>\n#include<map>\n#include<cstdio>\n \n \n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 1e9\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n \ntypedef long long int ll;\n#define MOD 1000000007\n#define MAX_H 110\n#define MAX_W 110\n\nint h,w;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,1,-1};\n/*左、右、上、下*/\nint xs,ys,xg,yg,color;\nint mp[MAX_H][MAX_W];\nbool ans = false;\n\n\nvoid dfs(int y,int x){\n\n    if(y == yg && x == xg){\n        /*ゴールについた*/\n        ans = true;\n        return;\n    }\n    //今いるところを置き換える\n    mp[y][x] = -1;\n    //移動方向をループ\n    for(int i = 0;i < 4;i++){\n        //x方向にdx,ｙ方向にdy移動した場所を(ny,nx)とする\n        int nx = x + dx[i], ny = y + dy[i];\n        if(1 <= nx && nx <= w && 1 <= ny && ny <= h && mp[ny][nx] == color){/*同じ色なら進める*/\n            dfs(ny,nx);\n        }\n    }\n    return;/*全て調べ終わり、1つ深さを戻す*/\n}\n\n\n\n\nvoid solve(){\n\n    for(int i = 1;i <= h;i++){\n        for(int j = 1;j <= w;j++){\n            if(mp[i][j] == color){\n                dfs(i,j);\n                if(ans){\n                    /*dfsによってゴールに着いた*/\n                    return;\n                }\n            }\n        }\n    }\n}\n\n\n\nint main(){\n\n    while(cin >> w >> h,w){\n        cin >> xs >> ys >> xg >> yg;\n\n        int c,d,x,y,n;\n        cin >> n;\n\n        REP(i,n){\n\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                /*横長*/\n                for(int j = y;j < y+2;j++){\n                    for(int k = x;k < x+4;k++){\n                        mp[j][k] = c;\n                    }\n                }\n            }else{\n                /*縦長*/\n                for(int j = y;j < y+4;j++){\n                    for(int k = x;k < x+2;k++){\n                        mp[j][k] = c;\n                    }\n                }\n            }\n        }\n\n        color = mp[ys][xs];\n    \n        if(mp[ys][xs] == 0 || mp[yg][xg] == 0){\n            ans = false;\n        }else{\n            /*横方向がx、縦方向がy*/\n            dfs(ys,xs);\n        }\n\n        if(ans){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n       \n        /*初期化*/\n        ans = false;\n        for(int i = 1;i <= MAX_H;i++){\n            for(int j = 1;j <= MAX_W;j++){\n                mp[i][j] = 0;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint fie[101][101],ans,gol[101][101],st[101][101],col,muki,bx,by;\nint bex[]={0,1,0,-1},bey[]={1,0,-1,0},cou;\nint func(int y,int x){\n    if(y<1||x<1)return 0;\n    if(fie[y][x]==0)return 0;\n    if(fie[y][x]==6){\n        cou=1;\n        return 0;\n    }\n    if(cou==1)return 0;\n    if(fie[y][x]!=ans){\n        fie[y][x]=0;\n        return 0;\n    }\n    if(fie[y][x]==ans){\n        for(int i=0;i<4;i++){\n            func(y+bey[i],x+bex[i]);\n        }\n    }\n    return 0;\n}\nint main(){\n    int a,b,sx,sy,gx,gy,n;\n    for(;;){\n        cin>>a>>b;\n        if(a==0&&b==0)break;\n        fill(fie[0],fie[0]+101*101,0);\n        cin>>sx>>sy>>gx>>gy;\n        cin>>n;\n        for(int i=0;i<n;i++){\n            cin>>col>>muki>>bx>>by;\n            if(muki==0){\n                for(int i=0;i<=1;i++){\n                    for(int j=0;j<=3;j++){\n                        fie[by+i][bx+j]=col;\n                    }\n                }\n            }\n            if(muki==1){\n                for(int i=0;i<=3;i++){\n                    for(int j=0;j<=1;j++){\n                        fie[by+i][bx+j]=col;\n                    }\n                }\n            }\n        }\n        fie[gy][gx]=6;\n        ans=fie[sy][sx];\n        func(sy,sx);\n        if(cou==1)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        cou=0;\n    }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint map[101][101];\nint xg, yg;\nint w, h;\nint col;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nbool flag;\n\nvoid dfs(int x, int y)\n{\n    map[y][x] = 0;\n\n    if (x == xg && y == yg) {\n        flag = true;\n        return ;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx < 0 || ny < 0 || nx >= w || ny >= h)\n            continue;\n        else if (map[ny][nx] == col)\n            dfs(nx, ny);\n    }\n}\n\nvoid setblock(int c, int d, int bx, int by)\n{\n    int wlim = 4, hlim = 2;\n\n    if (d == 1) {\n        wlim = 2;\n        hlim = 4;\n    }\n\n    for (int y = 0; y < hlim; y++)\n        for (int x = 0; x < wlim; x++)\n            map[by + y][bx + x] = c;\n}\n\n\nint main()\n{\n    while (cin >> w >> h, w || h) {\n        int xs, ys;\n        int n;\n\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++)\n                map[y][x] = 0;\n\n        cin >> xs >> ys >> xg >> yg >> n;\n\n        xs--, ys--, xg--, yg--;\n        for (int i = 0; i < n; i++) {\n            int c, d, x, y;\n            \n            cin >> c >> d >> x >> y;\n            x--, y--;            \n            setblock(c, d, x, y);\n        }\n        col = map[ys][xs];\n        flag = false;\n        if (col)\n            dfs(xs, ys);\n\n        if (flag)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint vx[4]={1,0,-1,0};int vy[4]={0,1,0,-1};int flag=0;int board[102][102]={0};vector<pair<int,int> > com;\nqueue<pair<pair<int,int>,int > > qp;int num=0;\npair<pair<int,int>,int > now;\nint check(int i){\n  if(now.second!=board[now.first.second+vy[i]][now.first.first+vx[i]])\n    return 0;\n  for(int j=0;j<com.size();j++)\n    if(now.first.second+vy[i]==com[j].second&&now.first.first+vx[i]==com[j].first)\n      return 0;\n  return 1;\n}\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h!=0){\n    flag=0;num=0;\n    com.clear();\n    while(!qp.empty())\n      qp.pop();\n    int xs,ys,xg,yg;\n    for(int i=0;i<h+2;i++)\n      for(int j=0;j<w+2;j++)\n\tboard[i][j]=0;\n    cin>>xs>>ys;cin>>xg>>yg;\n    int n,c,d,x,y;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      for(int j=0;j<2;j++){\n\tfor(int k=0;k<4;k++){\n\t  if(d==0)\n\t    board[y+j][x+k]=c;\n\t  else\n\t    board[y+k][x+j]=c;\n\t}\n      }\n    }\n    qp.push(make_pair(make_pair(xs,ys),board[ys][xs]));\n    while(!qp.empty()){\n      now=qp.front();\n      qp.pop();\n      for(int i=0;i<4;i++){\n\tnum++;\n\tif(check(i)==1){\n\t  qp.push(make_pair(make_pair(now.first.first+vx[i],now.first.second+vy[i]),now.second));\n\t  com.push_back(make_pair(now.first.first+vx[i],now.first.second+vy[i]));\n\t  if(now.first.first+vx[i]==xg&&now.first.second+vy[i]==yg){\n\t    flag=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(flag==1){cout<<\"OK\"<<endl;break;}\n      if(num==10000){cout<<\"NG\"<<endl;break;}\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg, w,h;\n\nvoid dfs(int target, int x, int y){\n    if(x < 0 || y < 0 || x >= w || y >= h) return;\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 9;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n    return;\n}\n\nint main(){\n    int xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,h) rep(j,w) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        xs--; ys--; xg--; yg--;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            rep(j, (d?4:2)) rep(k, (d?2:4)) b[x + j][y + k] = c;\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n#include <queue>\n#include <complex>\n#include <climits>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint maze[110][110];\nint f[110][110];\nint w, h, xs, ys, xg, yg, res = 0;\nint color;\n\nvoid dfs(int cy, int cx){\n\tif(f[cy][cx]) return ;\n\tf[cy][cx] = 1;\n\tif(cy == yg && cx == xg){\n\t\tres = 1;\n\t\treturn ;\n\t}\n\tfor(int dx=-1; dx<=1; ++dx){\n\t\tfor(int dy=-1; dy<=1; ++dy){\n\t\t\tif(abs(dx-dy) != 1) continue;\n\t\t\tint nx = cx + dx, ny = cy + dy;\n\t\t\tif(maze[ny][nx] == color){\n\t\t\t\tdfs(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> w >> h){\n\t\tres = 0;\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<110; ++i){\n\t\t\tfor(int j=0; j<110; ++j){\n\t\t\t\tmaze[i][j] = 6;\n\t\t\t\tf[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tmaze[i][j] = 0;\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j=y; j<=y+1; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+3; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d == 1){\n\t\t\t\tfor(int j=y; j<=y+3; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+1; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor = maze[ys][xs];\n\t\tif(color == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(ys, xs);\n\n\t\tif(res){\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint b[100][100];\nint vis[100][100];\n\nint w, h;\nbool in(int x, int y) {\n\treturn 0 <= x && x < w && 0 <= y && y < h;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w + h) {\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\txs--, ys--, xg--, yg--;\n\n\t\tmemset(b, 0, sizeof b);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--, y--;\n\t\t\tint H = 2, W = 4;\n\t\t\tif(d == 1) swap(H, W);\n\t\t\tfor(int dx = 0; dx < W; dx++) {\n\t\t\t\tfor(int dy = 0; dy < H; dy++) {\n\t\t\t\t\tb[y + dy][x + dx] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(b[ys][xs] != b[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttypedef pair<int, int> P;\n\t\tqueue<P> q;\n\t\tq.push({ xs, ys });\n\t\tmemset(vis, 0, sizeof vis);\n\t\tvis[ys][xs] = 1;\n\t\twhile(q.size()) {\n\t\t\tint x = q.front().first, y = q.front().second;\n\t\t\tq.pop();\n\t\t\tint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\t\tif(in(nx, ny) && vis[ny][nx] == 0) {\n\t\t\t\t\tvis[ny][nx] = 1;\n\t\t\t\t\tq.push({ nx, ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(vis[yg][xg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = '.';\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int ys,int xs);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys-1,xs-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[yg-1][xg-1]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <ctime>\n#define INF 100000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n \n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint maze[105][105];\nint w,h,xs,ys,xg,yg;\n\nbool bfs(){\n  queue<int>que;\n  que.push(xs);\n  que.push(ys);\n  while(que.size()){\n    int x=que.front();que.pop();\n    int y=que.front();que.pop();\n    if(x==xg&&y==yg)return true;\n    for(int i=0;i<4;i++){\n      if(0<=x+dx[i]&&x+dx[i]<=w&&0<=y+dy[i]&&y+dy[i]<=h&&maze[y+dy[i]][x+dx[i]]==maze[ys][xs]){\n\tque.push(x+dx[i]);\n\tque.push(y+dy[i]);\n\tmaze[y+dy[i]][x+dx[i]]=-1;\n      }\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    rep(i,h/2){\n      rep(j,w/4){\n\tcin>>maze[i][j];\n      }\n    }\n    if(bfs())cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=-1;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  while(1){\n    int h,w;\n    int start_x,start_y;\n    int goal_x,goal_y;\n    int n;\n\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n          b.mass[i][j]=0;\n        }\n      }\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\nint w, h;\n\nint map[200][200];\n\nvoid search(int x, int y, int col){\n\tif(x < 0 || y < 0 || x > w || y > h){\n\t\treturn;\n\t}\n\tif(map[x][y] != col || map[x][y] == 0){\n\t\treturn;\n\t}\n\tmap[x][y] = 0;\n\tsearch(x - 1, y, col);\n\tsearch(x + 1, y, col);\n\tsearch(x, y - 1, col);\n\tsearch(x, y + 1, col);\n}\n\nint main(){\n\t\n\t\n\twhile(true){\n\t\t\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint xs, ys, xg, yg;\n\t\t\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\t\n\t\tint n;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tfor(int i = 0; i <= w; i++){\n\t\t\tfor(int j = 0; j <= h; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int loop = 0; loop < n; loop++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int dx = 0; dx < 4; dx++){\n\t\t\t\t\tfor(int dy = 0; dy < 2; dy++){\n\t\t\t\t\t\tmap[x + dx][y + dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int dx = 0; dx < 2; dx++){\n\t\t\t\t\tfor(int dy = 0; dy < 4; dy++){\n\t\t\t\t\t\tmap[x + dx][y + dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t}else{\n\t\t\tsearch(xs, ys, map[xs][ys]);\n\t\t\tif(map[xg][yg] == 0){\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tcout << map[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h; i++) {\n                for (int j = 0; j <= w; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        sx--, sy--, gx--, gy--;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(H, vector<int>(W));\n        vector<vector<int> > used(H, vector<int>(W));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            x--, y--;\n            if (dir) {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx < H && 0 <= ny && ny < W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nint gx, gy;\nint vx[] = {0, 1, 0, -1};\nint vy[] = {1, 0, -1, 0};\nint block[100][100];\nbool check[100][100];\nbool flag;\n\nvoid dfs(int y, int x) {\n\n  if(y == gy && x == gx) {\n\n    flag = true;\n    return;\n\n  } else {\n\n    for(int i = 0; i < 4; ++i) {\n\n      int ny = y + vy[i];\n      int nx = x + vx[i];\n\n      if(ny >= 0 && ny < h && nx >= 0 && nx < w && !check[ny][nx] && block[ny][nx] && block[ny][nx] == block[y][x]) {\n\n        check[ny][nx] = true;\n        dfs(ny, nx);\n\n      }\n\n    }\n\n  }\n\n}\n\nint main() {\n\n  int sx, sy;\n  int n;\n  int c, d, x, y;\n\n  while(cin >> w >> h) {\n\n    if(w == 0 && h == 0) break;\n\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n\n    --sx;\n    --sy;\n    --gx;\n    --gy;\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        block[i][j] = 0;\n        check[i][j] = false;\n      }\n    }\n\n    for(int i = 0; i < n; ++i) {\n\n        cin >> c >> d >> x >> y;\n\n        --x;\n        --y;\n\n        int bw, bh;\n\n        if(d) {\n          bw = 2;\n          bh = 4;\n        } else {\n          bw = 4;\n          bh = 2;\n        }\n\n        for(int j = 0; j < bh; ++j) {\n          for(int k = 0; k < bw; ++k) {\n            block[y + j][x + k] = c;\n          }\n        }\n\n    }\n\n    flag = false;\n    check[sy][sx] = true;\n    dfs(sy, sx);\n\n    cout << (flag ? \"OK\" : \"NG\") << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define dr direction\n#define cl color\n#define fi first\n#define se second\n\nusing namespace std;\ntypedef pair<int, int> pii;\n\nclass Block{\npublic:\n    int color;// 1~5\n    int direction;// 0:-, 1:|\n    int x, y;\n    void init(int c, int d, int xx, int yy);\n};\n\nvoid Block::init(int c, int d, int xx, int yy){\n    color=c;\n    direction=d;\n    x=xx;\n    y=yy;\n}\n\nint w, h, xs, ys, xg, yg, n;\nint fld[100][100], dis[100][100];\nconst pii dxdy[]={{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nconst int inf=1e8;\n\nstring solve(){// bfs\n    queue<pii> qu;\n    qu.push(make_pair(ys, xs));\n    int C=fld[ys][xs];\n    fill(dis[0], dis[100], inf);\n    dis[ys][xs]=0;\n\n    while(!qu.empty()){\n        pii now=qu.front(); qu.pop();\n        if(now.fi==yg&&now.se==xg){\n            return \"OK\";\n        }\n\n        for(int k=0; k<4; k++){\n            pii nx=make_pair(now.fi+dxdy[k].fi, now.se+dxdy[k].se);\n            if(!(0<=nx.fi&&nx.fi<h&&0<=nx.se&&nx.se<w)) continue;\n            if(fld[nx.fi][nx.se]!=C) continue;\n            if(dis[nx.fi][nx.se]!=inf) continue;\n\n            dis[nx.fi][nx.se]=dis[now.fi][now.se]+1;\n            qu.push(nx);\n        }\n    }\n\n    return \"NO\";\n}\n\nint main(){\n\n    while(1){\n        cin>> w>> h;\n        if(w==0&&h==0) break;\n        cin>> xs>> ys>> xg>> yg>> n;\n        xs--; ys--; xg--; yg--;\n        Block block[n];\n        for(int i=0; i<n; i++){\n            int c, d, xx, yy;\n            cin>> c>> d>> xx>> yy;\n            xx--; yy--;\n            block[i].init(c, d, xx, yy);\n        }\n\n        // make field\n        for(int k=0; k<n; k++){\n            int X=block[k].x, Y=block[k].y;\n            if(block[k].dr==0){\n                for(int i=0; i<2; i++){\n                    for(int j=0; j<4; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }else{\n                for(int i=0; i<4; i++){\n                    for(int j=0; j<2; j++){\n                        fld[Y+i][X+j]=block[k].cl;\n                    }\n                }\n            }\n        }\n/*\n        for(int i=0; i<w; i++){\n            for(int j=0; j<h; j++){\n                cout<< fld[i][j]<<\" \";\n            }\n            cout<< endl;\n        }\n//*/\n        cout<< solve()<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int ys,int xs);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--;ys--;xg--;yg--;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n      x[i]--;y[i]--;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j][k] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(ys,xs))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[ys][xs] == 0 || maps[ys][xs] != gc){\n    return 0;\n  }\n  else if(maps[ys][xs] == maps[yg][xg]){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint fie[101][101],ans,gol[101][101],st[101][101],col,muki,bx,by;\nint bex[4]={0,1,0,-1},bey[4]={1,0,-1,0},cou,a,b;\n    int sx,sy,gx,gy,n;\nint func(int y,int x){\n    if(fie[sy][sx]==-1)return 0;\n    if(y<1||x<1||y>b||x>a)return 0;\n    if(fie[y][x]==ans){\n        fie[y][x]=0;\n        for(int i=0;i<4;i++){\n            func(y+bey[i],x+bex[i]);\n        }\n    }\n    return 0;\n}\nint main(){\n    for(;;){\n        cin>>a>>b;\n        if(a==0&&b==0)break;\n        fill(fie[0],fie[0]+101*101,-1);\n        cin>>sx>>sy>>gx>>gy;\n        cin>>n;\n        for(int i=0;i<n;i++){\n            cin>>col>>muki>>bx>>by;\n            if(muki==0){\n                for(int i=0;i<=1;i++){\n                    for(int j=0;j<=3;j++){\n                        fie[by+i][bx+j]=col;\n                    }\n                }\n            }\n            if(muki==1){\n                for(int i=0;i<=3;i++){\n                    for(int j=0;j<=1;j++){\n                        fie[by+i][bx+j]=col;\n                    }\n                }\n            }\n        }\n        ans=fie[sy][sx];\n        if(fie[sy][sx]!=0){\n            func(sy,sx);\n        }\n        /*for(int i=1;i<=a;i++){\n            for(int j=1;j<=b;j++){\n                cout<<fie[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(!fie[gy][gx])cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        cou=0;\n        /*for(int i=1;i<=a;i++){\n            for(int j=1;j<=b;j++){\n                cout<<fie[i][j];\n            }\n            cout<<endl;\n        }*/\n    }\nreturn 0;\n}\n/*6 5\n1 1\n5 5\n3\n2 0 1 1\n2 0 2 3\n2 0 2 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 100\n \nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n \nint w, h, xs, ys, xg, yg, G[MAX+2][MAX+2];\n \nbool dfs(int x, int y, int color){\n    if(color == 0 || G[x][y] != color) return false;\n    if(x==xg&&y==yg) return true;\n    G[x][y] = 0;\n    for(int r=0; r<4; r++){\n        if(dfs(x+dx[r], y+dy[r], color)) return true;\n    }\n    return false;\n}\n \nint main(void)\n{\n    int n, c, d, bx, by;\n    while(cin>>w>>h, w&&h){\n        for(int x=0; x<w+2; x++){\n            for(int y=0; y<h+2; y++){\n                G[x][y] = 0;\n            }\n        }\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=0; i<n; i++){\n            cin >> c >> d >> bx >> by;\n            for(int i=0; i<4; i++){\n                for(int j=0; j<2; j++){\n                    if(d==0) G[bx+i][by+j] = c; \n                    else G[bx+j][by+i] = c;\n                }\n            }\n        }\n        if(dfs(xs, ys, G[xs][ys])) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (n); i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nint main() {\n    while (true)\n    {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n\n        int grid[100][100];\n        rep(i, w) rep(j, h) grid[i][j] = 0;\n\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        sx--; sy--; gx--; gy--;\n\n        int n;\n        cin >> n;\n\n        rep(i, n) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                rep(j, 4) rep(k, 2) grid[j+x-1][k+y-1] = c;\n            } else {\n                rep(j, 2) rep(k, 4) grid[j+x-1][k+y-1] = c;\n            }\n        }\n\n        bool ok[100][100];\n        rep(i, w) rep(j, h) ok[i][j] = true;\n\n        bool flag = false;\n        int sc = grid[sx][sy];\n        queue<P> que;\n        que.push(P(sx, sy));\n        while (que.size()) {\n            P p = que.front();\n            que.pop();\n            if (p.first == gx && p.second == gy) {\n                flag = true;\n                break;\n            }\n\n            rep(i, 4) {\n                int nx = p.first+dx[i], ny = p.second+dy[i];\n                if (0 <= nx && nx < w && 0 <= ny && ny < h && grid[nx][ny] == sc && ok[nx][ny] == true) {\n                    que.push(P(nx, ny));\n                    ok[nx][ny] = false;\n                }\n            }\n        }\n\n        if (flag && sc > 0) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint M[100][100];\nbool vst[100][100];\nint w,h,xs,ys,xg,yg,n;\nbool dfs(int x,int y) {\n\tif(x==xg&&y==yg) return true;\n\tvst[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0>nx||nx>=w||0>ny||ny>=h)continue;\n\t\tif(M[x][y]!=M[nx][ny])continue;\n\t\tif(vst[nx][ny])continue;\n\t\tif(dfs(nx,ny))return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile(scanf(\"%d %d\",&w,&h),w) {\n\t\tmemset(vst,0,sizeof(vst));\n\t\tmemset(M,0,sizeof(M));\n\t\tscanf(\"%d %d\",&xs,&ys);xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg);xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);x--;y--;\n\t\t\tif(d==1) {\n\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\tfor(int k=0;k<2;k++)\n\t\t\t\t\t\tM[x+k][y+j]=c;\n\t\t\t}else {\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t\tfor(int k=0;k<4;k++) \n\t\t\t\t\t\tM[x+k][y+j]=c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid setblock(int c, int d, int x, int y){\n  if(d==0){\n    for(int i=0;i<4;i++){\n      F[y][x+i]=c;\n      F[y+1][x+i]=c;\n    }\n  }else{\n    for(int i=0;i<4;i++){\n      F[y+i][x]=c;\n      F[y+i][x+1]=c;\n    }\n  }\n\n}\n\nvoid DFS(int Y, int X, int c){\n  if(F[Y][X]!=c)\n    return;\n\n  F[Y][X] = 6;\n\n  DFS(Y-1, X  ,c);\n  DFS(Y  , X+1,c);\n  DFS(Y+1, X  ,c);\n  DFS(Y  , X-1,c);\n}\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(true){\n  cin >> w >> h;\n  for(int i=0;i<h;i++){\n   for(int k=0;k<w;k++){\n     F[i][k]=-1;\n   }\n  }\n  if(w==0&&h==0){\n    break;\n  }\n  cin >> xs >> ys;\n  cin >> xg >> yg;\n  cin >> n;\n  for(int i=0; i<n; i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    setblock(c,d,x,y);\n  }\n\n  DFS(ys,xs,F[ys][xs]);\n  if(F[yg][xg]==6){\n    cout << \"OK\" << endl;\n  }else{\n    cout << \"NG\" << endl;\n  }\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define repeat(n, i) for(int i=0; i<(n); i++)\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\n\nint st_color;\n\nvector< vector<int> > board;\n\n#define VISITED 6\n\nbool get_input() {\n    cin >> w >> h;\n    if (w == 0 && h == 0) return false;\n    board.resize(h);\n    repeat(h, i) board[i].resize(w);\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    repeat(n, i) {\n        int c, d, x, y;\n        cin >> c >> d >> x >> y;\n        if (d == 0) {\n            for (int j = y-1; j < y-1+4; j++) {\n                for (int k = x-1; k < x-1+2; k++) {\n                    board[j][k] = c;\n                }\n            }\n        } else {\n            for (int j = y-1; j < y-1+2; j++) {\n                for (int k = x-1; k < x-1+4; k++) {\n                    board[j][k] = c;\n                }\n            }\n        }\n    }\n    st_color = board[ys-1][xs-1];\n    return true;\n}\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool possible;\nvoid dfs(int x, int y) {\n    board[y-1][x-1] = VISITED;\n    if (x == xg && y == yg) {\n        possible = true;\n        return;\n    }\n    repeat(4, i) {\n        int nx = x+dx[i], ny = y+dy[i];\n        if (1 <= nx && nx <= w && 1 <= ny && ny <= h) {\n            if (board[ny-1][nx-1] != VISITED) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    possible = false; dfs(xs, ys);\n    if (possible) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n}\n\nint main() {\n    while (get_input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint a[100][100];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint w, h;\n\nvoid dfs(int x, int y) {\n\tint c = a[x][y];\n\ta[x][y] = -1;\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < w && 0 <= ny&&ny < h&&a[nx][ny] == c)dfs(nx, ny);\n\t}\n}\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\txs--; ys--; xg--; yg--;\n\t\trep(i, n) {\n\t\t\tint c, d, x, y; scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\tx--; y--;\n\t\t\trep(j, 2)rep(k, 4) {\n\t\t\t\tif (d)a[x + j][y + k] = c;\n\t\t\t\telse a[x + k][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tdfs(xs, ys);\n\t\tputs(a[xg][yg] == -1 ? \"OK\" : \"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n// #define main int main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector<vi> vvi;\ntypedef vector<vb> vvb;\ntypedef vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nint di[] = {1, 0, -1, 0}, dj[] = {0, 1, 0, -1};\n\nvoid solve() {\n  int w, h;\n  while (cin >> w >> h, w) {\n    int sx, sy, gx, gy, n;\n    cin >> sx >> sy >> gx >> gy >> n;\n    sx--, sy--, gx--, gy--;\n    vvi v(h, vi(w));\n    rep(i, n) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--;\n      y--;\n      rep(i, 2 + d * 2) rep(j, 4 - d * 2) v[y + i][x + j] = c;\n    }\n    int roadColor = v[sy][sx];\n    function<bool(int, int)> dfs = [&](int i, int j) {\n      if (i < 0 || j < 0 || i >= h || j >= w || v[i][j] != roadColor) return false;\n      if (i == gy && j == gx) return true;\n      v[i][j] = -1;\n      bool b  = false;\n      rep(k, 4) b |= dfs(i + di[k], j + dj[k]);\n      return b;\n    };\n    cout << (dfs(sy, sx) ? \"OK\" : \"NG\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint a=0;\nint F[102][102];\nvoid DFS(int Xs,int Ys,int c,int Xg,int Yg){\n  if(F[Xs][Ys]!=c){\n    return;\n  }else if(Xs==Xg&&Ys==Yg){\n    a=1;\n    return;\n  }\n F[Xs][Ys]=0;\n DFS(Xs-1,Ys,c,Xg,Yg);\n DFS(Xs,Ys-1,c,Xg,Yg);\n DFS(Xs+1,Ys,c,Xg,Yg);\n DFS(Xs,Ys+1,c,Xg,Yg);\n}\n\nint main(){\n  while(1){\n   int w,h,xs,ys,xg,yg,n,C;\n   cin>>w>>h;\n   if(w==0&&h==0){\n     break;\n   }\n   cin>>xs>>ys>>xg>>yg>>n;\n   int c[n],d[n],x[n],y[n];\n   for(int i=0;i<n;i++){\n     cin>>c[i]>>d[i]>>x[i]>>y[i];\n     if(xs==x[i]&&ys==y[i]){\n       C=c[i];\n     }\n      for(int j=0;j<4;j++){\n        for(int k=0;k<2;k++){\n          if(d[i]==0){\n           F[x[i+j]][y[i+k]]=c[i];\n         }else{\n           F[x[i+k]][y[i+j]]=c[i];\n         }\n       }\n     }\n    }\n    DFS(xs,ys,C,xg,yg);\n    if(a==1){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#define INF (2000000000)\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<int>::iterator VII;\ntypedef vector<double> VD;\ntypedef vector<double>::iterator VDI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint map[200][200];\nbool done[200][200];\n\nint xg, yg;\n\nvoid Search(int y, int x)\n{\n\tdone[y][x] = true;\n\tfor (int i = 0; i < 4; i++){\n\t\tif (!done[y + dy[i]][x + dx[i]] && map[y][x] == map[y + dy[i]][x + dx[i]]){\n\t\t\tSearch(y + dy[i], x + dx[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(map, 0, sizeof(map));\n\t\tmemset(done, 0, sizeof(done));\n\t\t\n\t\tint xs, ys;\n\t\tscanf(\"%d %d %d %d\", &xs, &ys, &xg, &yg);\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tint a = 2, b = 4;\n\t\t\tif (d == 1){\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = y; j < y + a; j++){\n\t\t\t\tfor (int k = x; k < x + b; k++){\n\t\t\t\t\tmap[j][k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (map[ys][xs]) Search(ys, xs);\n\t\t\n\t\tprintf(done[yg][xg] ? \"OK\\n\" : \"NG\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl;\n\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\nint w,h,sx,sy,gx,gy,n;\nint board[102][102];\n\nint main()\n{\n    while(cin >> w >> h && w) {\n        memset(board, 0, sizeof(board));\n        cin >> sx >> sy >> gx >> gy >> n;\n        \n        int c, d, x, y;\n        rep(k, n) {\n            cin >> c >> d >> x >> y;\n            if(d == 0)\n                rep(i, 2) rep(j, 4) \n                    board[i + y][j + x] = c;\n             else \n                rep(i, 4) rep(j, 2) \n                    board[i + y][j + x] = c;\n        }\n\n        int e = board[sy][sx];\n        queue<P> que;\n        que.push(P(sx, sy));\n        bool ok = false;\n        while(!que.empty()) {\n            P p = que.front(); que.pop();\n            x = p.first; y = p.second;\n            if(x == gx && y == gy) {\n                ok = true;\n                break;\n            }\n            if(board[y][x] != e) \n                continue;\n\n            board[y][x] = -1;\n            for(int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                if(nx >= 1 && nx <= w && ny >= 0 && ny <= h && board[ny][nx] == e) \n                    que.push(P(nx, ny));\n            }\n        }\n\n        cout << ((ok) ? \"OK\" : \"NG\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint field[1024][1024];\nbool vis[1024][1024];\n\nint dx[2][8] = { {0,1,2,3,0,1,2,3}, {0,1,0,1,0,1,0,1}};\nint dy[2][8] = { {0,0,0,0,1,1,1,1}, {0,0,1,1,2,2,3,3}};\n\nvoid rec(int x, int y, int c){\n\t\n\tif( vis[y][x] || x <= 0 || w < x || y <= 0 || h < y || field[y][x] != c )\n\t\treturn;\n\t\n\tvis[y][x] = true;\n\t\n\trec(x+1, y, c);\n\trec(x-1, y, c);\n\trec(x, y+1, c);\n\trec(x, y-1, c);\n\t\n\treturn;\n}\n\nint main()\n{\n\twhile(cin >> w >> h, (w||h)){\n\t\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(vis,0,sizeof(vis));\n\t\t\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\t\n\t\t\tint c, d, x, y;\n\t\t\t\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tfor(int i = 0; i < 8; ++i){\n\t\t\t\t\n\t\t\t\tfield[y+dy[d][i]][x+dx[d][i]] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\trec(xs,ys,field[ys][xs]);\n\t\t\n\t\tcout << (vis[yg][xg]?\"OK\":\"NG\") << endl;\n\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int Y, int X, int C, int yg, int xg)\n{\n  if(Y == yg && X == xg)\n    return true;\n  if(F[Y][X]!=C)\n    return false;\n\n  F[Y][X] = 0;\n\n  bool tmp = 0;\n  tmp += DFS(Y-1, X, C, yg, xg);\n  tmp += DFS(Y+1, X, C, yg, xg);\n  tmp += DFS(Y, X-1, C, yg, xg);\n  tmp += DFS(Y, X+1, C, yg, xg);\n  return tmp;\n}\n\nint main()\n{\n  while(1){\n    F[102][102] = {}\n\n    int w, h;\n    cin >> w >> h;\n\n    if(w == 0 && h == 0)\n      return 0;\n\n    int xs, ys;\n    cin >> xs >> ys;\n\n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c, d, x, y;\n    for(int i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d == 0)\n        for(int j=0; j<2; j++)\n          for(int k=0; k<4; k++)\n            F[y+j][x+k] = c;\n      else\n        for(int j=0; j<4; j++)\n          for(int k=0; k<2; k++)\n            F[y+j][x+k] = c;\n    }\n\n    bool res = DFS(ys, xs, F[ys][xs], yg, xg);\n\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint vx[4]={1,0,-1,0};int vy[4]={0,1,0,-1};int flag=0;int board[102][102]={0};vector<pair<int,int> > com;\nqueue<pair<pair<int,int>,int > > qp;int num=0;\npair<pair<int,int>,int > now;\nint check(int i){\n  if(now.second!=board[now.first.second+vy[i]][now.first.first+vx[i]])\n    return 0;\n  for(int j=0;j<com.size();j++)\n    if(now.first.second+vy[i]==com[j].second&&now.first.first+vx[i]==com[j].first)\n      return 0;\n  return 1;\n}\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h!=0){\n    flag=0;num=0;\n    com.clear();\n    while(!qp.empty())\n      qp.pop();\n    int xs,ys,xg,yg;\n    for(int i=0;i<h+2;i++)\n      for(int j=0;j<w+2;j++)\n\tboard[i][j]=0;\n    cin>>xs>>ys;cin>>xg>>yg;\n    int n,c,d,x,y;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      for(int j=0;j<2;j++){\n\tfor(int k=0;k<4;k++){\n\t  if(d==0)\n\t    board[y+j][x+k]=c;\n\t  else\n\t    board[y+k][x+j]=c;\n\t}\n      }\n    }\n    qp.push(make_pair(make_pair(xs,ys),board[ys][xs]));\n    while(!qp.empty()){\n      now=qp.front();\n      qp.pop();\n      for(int i=0;i<4;i++){\n\tnum++;\n\tif(check(i)==1){\n\t  qp.push(make_pair(make_pair(now.first.first+vx[i],now.first.second+vy[i]),now.second));\n\t  com.push_back(make_pair(now.first.first+vx[i],now.first.second+vy[i]));\n\t  if(now.first.first+vx[i]==xg&&now.first.second+vy[i]==yg){\n\t    flag=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(flag==1){cout<<\"OK\"<<endl;break;}\n      if(num==5000||flag==0){cout<<\"NG\"<<endl;break;}\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/01/14 Tazoe\n\n#include<iostream>\nusing namespace std;\n\nbool DFS(int brd[102][102], int x, int y, int col, int xg, int yg)\n{\n\tif(brd[y][x]!=col)\n\t\treturn false;\n\tif(x==xg&&y==yg)\n\t\treturn true;\n\n\tbrd[y][x] = 9;\n\n\treturn(DFS(brd, x+1, y, col, xg, yg)\n\t     ||DFS(brd, x, y+1, col, xg, yg)\n\t     ||DFS(brd, x-1, y, col, xg, yg)\n\t     ||DFS(brd, x, y-1, col, xg, yg));\n}\n\nint main()\n{\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\tint brd[102][102];\n\t\tfor(int yy=0; yy<h+2; yy++)\n\t\t\tfor(int xx=0; xx<w+2; xx++)\n\t\t\t\tbrd[yy][xx] = 0;\n\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tbrd[y  ][x  ] = c;\n\t\t\tbrd[y  ][x+1] = c;\n\t\t\tbrd[y+1][x  ] = c;\n\t\t\tbrd[y+1][x+1] = c;\n\t\t\tif(d==0){\n\t\t\t\tbrd[y  ][x+2] = c;\n\t\t\t\tbrd[y  ][x+3] = c;\n\t\t\t\tbrd[y+1][x+2] = c;\n\t\t\t\tbrd[y+1][x+3] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbrd[y+2][x  ] = c;\n\t\t\t\tbrd[y+2][x+1] = c;\n\t\t\t\tbrd[y+3][x  ] = c;\n\t\t\t\tbrd[y+3][x+1] = c;\n\t\t\t}\n\t\t}\n\n\t\tif(brd[ys][xs]==0||brd[yg][xg]==0||brd[ys][xs]!=brd[yg][xg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(DFS(brd, xs, ys, brd[ys][xs], xg, yg))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,a[100][100];\nint d1[]={0,0,1,-1},d2[]={1,-1,0,0};\nvoid dfs(int y,int x,int c){\n  a[y][x]=0;\n  for(int i=0;i<4;i++){\n    int yy=d2[i]+y,xx=d1[i]+x;\n    if(yy>=0&&xx>=0&&xx<w&&yy<h)\n      if(a[yy][xx]==c)\n        dfs(yy,xx,c);\n  }\n}\nint main(){\n  while(cin>>w>>h,h){\n    memset(a,0,sizeof(a));\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    sx--;sy--;gx--;gy--;\n    int m;\n    cin>>m;\n    while(m--){\n      int q,w,e,r;\n      cin>>q>>w>>e>>r;\n      w;e--;r--;\n      int dy[2][8] = {{0,0,0,0,1,1,1,1},{0,0,1,1,2,2,3,3}}, dx[2][8] = {{0,1,2,3,0,1,2,3},{0,1,0,1,0,1,0,1}};\n      for(int i=0;i<8;i++)\n        a[r+dy[w][i]][e+dx[w][i]]=q;\n    }\n    if(a[sy][sx]!=0&&a[gy][gx]==a[sy][sx]){\n      dfs(sy,sx,a[sy][sx]);\n      if(a[gy][gx]==0)cout<<\"OK\"<<endl;\n      else goto L;\n    }\n    else{L:;\n      cout<<\"NG\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[101][101]={0},v[101][101]={0};\nint root(int x,int y,int vmap[][101]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[ys][xs]&&fy>0&&fy<=h&&fx>0&&fx<=w&&vmap[fy][fx]==0){\n\t\t\tvmap[y][x]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\t\tfor(int e=y;e<y+2;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int e=y;e<y+4;e++){\n\t\t\t\t\t\tmap[e][i]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int i1=0;i1<101;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101],w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy))r=1;\n\tif(x>1&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<=w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>1&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<=h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\tif(d)bw=2,bh=4;\n\t\t\telse{bh=2,bw=4;}\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])dfs(sx,sy,m[sx][sy]),m[sx][sy] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg,ok;\n\nvoid Maze(int X,int Y,int C){\n\t//cout << X<<Y<<F[X][Y]<<endl;\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\t\n\n\tif(X==xg&&Y==yg){\n\t\tcout << \"OK\"<<endl;\n\t\tok++;\n\t}\n\n\tF[X][Y]='.';\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tok=0;\n\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\t\tfor(int i=1; i<=w; i++)\n\t\t\tfor(int j=1; j<=h; j++)\n\t\t\t\tF[j][i]=0;\n\n\n\t\t//for(int i=0; i<=101;i++){\n\t\t\t//F[0][i]=6;\n\t\t\t//F[i][0]=6;\n\t\t//}\n\n\t\tfor(int i=1; i<=w;i++){\n\t\t\t\tF[w+1][i]=6;\n\t\t\t\tF[0][i]=6;\n\t\t}\n\t\tfor(int i=1; i<=h;i++){\n\t\t\t\tF[i][h+1]=6;\n\t\t\t\tF[i][0]=6;\n\t\t}\n\n\t\tint N=0;\n\t\twhile(N<n){\n//cout <<N;\n\t\t\tcin >>c>>d>>x>>y;\n//cout<<c<<d<<x<<y<<endl;\n\t\t\tif(d){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tF[i][j]=c;\n//cout <<F[i][j];\n\t\t\t\t}\n//cout <<endl;\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tF[i][j]=c;\n//cout <<F[i][j];\n\t\t\t\t\t}\n//cout <<endl;\n\t\t\t}\n\t\t\tN++;\n\t\t}\n\n//for(int i=0; i<=101; i++){\n\t//for(int j=0; j<=101; j++){\n\t\t//cout <<F[j][i];\n\t\t//}\n\t//cout << endl;\n//}\n\t\t\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t\tif(ok==0)\n\t\t\tcout <<\"NG\"<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define repeat(n, i) for(int i=0; i<(n); i++)\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\n\nint st_color;\n\nint board[100][100];\n\n#define VISITED 6\n\nbool get_input() {\n    cin >> w >> h;\n    if (w == 0 && h == 0) return false;\n//    board.resize(h);\n//    repeat(h, i) board[i].resize(w);\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    repeat(n, i) {\n        int c, d, x, y;\n        cin >> c >> d >> x >> y;\n        if (d == 0) {\n            for (int j = y-1; j < y-1+4; j++) {\n                for (int k = x-1; k < x-1+2; k++) {\n                    board[j][k] = c;\n                }\n            }\n        } else {\n            for (int j = y-1; j < y-1+2; j++) {\n                for (int k = x-1; k < x-1+4; k++) {\n                    board[j][k] = c;\n                }\n            }\n        }\n    }\n    st_color = board[ys-1][xs-1];\n    return true;\n}\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool possible;\nvoid dfs(int x, int y) {\n    board[y-1][x-1] = VISITED;\n    if (x == xg && y == yg) {\n        possible = true;\n        return;\n    }\n    repeat(4, i) {\n        int nx = x+dx[i], ny = y+dy[i];\n        if (1 <= nx && nx <= w && 1 <= ny && ny <= h) {\n            if (board[ny-1][nx-1] != VISITED) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    possible = false; dfs(xs, ys);\n    if (possible) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n}\n\nint main() {\n    while (get_input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(m=y;m<y+2;m++){\n\t\t\t\t\tfor(j=x;j<x+4;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(m=y;m<y+4;m++){\n\t\t\t\t\tfor(j=x;j<x+2;j++){\n\t\t\t\t\t\tbrock[m][j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<h;i++){\n\t\t\tfor(j=1;j<w;j++){\n\t\t\t\tcout<<brock[i][j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tif(brock[ys][xs]!=brock[yg][xg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=ys;\n\t\t\tma.b=xs;\n\t\t\tma.c=brock[ys][xs];\n\t\t\tds[ys][xs]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==yg&&ba.b==xg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=h&&ba.b+q[i]>0&&ba.b+q[i]<=w&&ds[ba.a+p[i]][ba.b+q[i]]==0&&brock[ba.a+p[i]][ba.b+q[i]]==brock[yg][xg]){\n\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\tma.c=brock[ba.a+p[i]][ba.b+q[i]];\n\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif(check==1){\n\t\t\tcout<<\"OK\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing V = vector<int>;\nusing VV = vector<V>;\nstruct P {int x, y;};\n\nint main() {\n\tint dx[] = {4, 2}, dy[] = {2, 4};\n\tfor (int w, h; w = in(), h = in();) {\n\t\tP s = {in() - 1, in() - 1}, g = {in() - 1, in() - 1};\n\t\tint n = in();\n\t\tVV m(h, V(w));\n\t\twhile (n--) {\n\t\t\tint c = in(), d = in(), x = in() - 1, y = in() - 1;\n\t\t\tfor (int i = 0; i < dy[d]; i++)\n\t\t\t\tfor (int j = 0; j < dx[d]; j++)\n\t\t\t\t\tm[i + y][j + x] = c;\n\t\t}\n\t\tfunction<bool(int, int, int)> f = [&](int x, int y, int c) {\n\t\t\tif (x == g.x && y == g.y)\n\t\t\t\treturn true;\n\t\t\tP d = {1, 0};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = x + d.x, ty = y + d.y;\n\t\t\t\tif (tx >= 0 && ty >= 0 && tx < w && ty < h && m[ty][tx] == c) {\n\t\t\t\t\tm[ty][tx] = 0;\n\t\t\t\t\tif (f(tx, ty, c))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswap(d.x, d.y *= -1);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tint c = m[s.y][s.x];\n\t\tm[s.y][s.x] = 0;\n\t\toutl(c ? f(s.x, s.y, c) ? \"OK\" : \"NG\" : \"NG\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\n#define rep(i, j) FOR(i, 0, j)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, b[101][101];\nint dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n\nbool dfs(int x, int y){\n  int nx, ny;\n  b[x][y] = 0;\n  if(x == xg && y == yg) return true;\n  bool r = 0;\n  rep(i, 4){\n    nx = x + dx[i]; ny = y + dy[i];\n    if(nx >= 0 && nx < h && ny >= 0 && ny < w && b[nx][ny]==c)r=r||dfs(nx, ny);\n  }\n  return r;\n}\n\nint main(){\n  while(scanf(\"%d %d\", &w, &h) && w && h){\n    memset(b, 0, sizeof(b));\n    scanf(\"%d%d%d%d\", &ys, &xs, &yg, &xg);\n    scanf(\"%d\", &n);\n    rep(i, n){\n      scanf(\"%d%d%d%d\", &c, &d, &y, &x);\n      rep(j, (d>0?4:2)) rep(k, (d>0?2:4)) b[x + j][y + k] = c;\n    }\n\n    c = b[xs][ys];\n    if(dfs(xs, ys)) puts(\"OK\");\n    else puts(\"NG\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y;\n\tstate(int x, int y) : x(x), y(y) {};\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h+1, vi(w+1));\n\t\tvvi visit(h+1, vi(w+1));\n\t\t\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(d) {\n\t\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tS.push(state(xs, ys));\n\t\tint color = field[ys][xs];\n\t\tbool goal = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(st.x == xg && st.y == yg) {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx, ny;\n\t\t\tREP(d, 4) {\n\t\t\t\tnx = st.x + dx[d];\n\t\t\t\tny = st.y + dy[d];\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny<h) {\n\t\t\t\t\tif(!visit[ny][nx] && field[ny][nx] == color) {\n\t\t\t\t\t\tvisit[ny][nx] = 1;\n\t\t\t\t\t\tS.push(state(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(color == 0) {\n\t\t\tgoal = false;\n\t\t}\n\n\t\tif(goal) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\n\nvoid dfs(int blocks[105][105], int target, int y, int x, int gx, int gy){\n    if(x == gx && y == gy){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] == target){\n        blocks[y][x] = 0;\n    }else{\n        return;\n    }\n    dfs(blocks, target, y + 1, x, gx, gy);\n    dfs(blocks, target, y - 1, x, gx, gy);\n    dfs(blocks, target, y, x + 1, gx, gy);\n    dfs(blocks, target, y, x - 1, gx, gy);\n}\n\nint main(){\n    int w, h, xs, ys, xg, yg, n;\n    while(cin >> w >> h, w||h){\n        int blocks[105][105] = {0};\n        cin >> xs >> ys >> xg >> yg >> n;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        if(blocks[ys][xs] != 0) dfs(blocks, blocks[ys][xs], xs, ys, xg, yg);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] )\n{\n\tcame[ y ][ x ] = false ;\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t{\n\t\t\tcame[ yy ][ xx ] = false ;\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t\t}\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tcame[ sy ][ sx ] = false ;\t//\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag;\nint MAP[102][102],MF[102][102];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(Y>0 && X>0){\n\t\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0){\n\t\t\tBlock(X,Y-1); //???\n\t\t\tMF[Y][X-1]=0;\n\t\t}\n\t\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0){\n\t\t\tBlock(X,Y+1); //???\n\t\t\tMF[Y+1][X]=0;\n\t\t}\n\t\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0){\n\t\t\tBlock(X-1,Y); //???\n\t\t\tMF[Y][X-1]=0;\n\t\t}\n\t\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0){\n\t\t\tBlock(X+1,Y); //???\n\t\t\tMF[Y][X-1]=0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nint Block(int,int);\nint c,d,x,y,xg,yg,w,h,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(Block(xs,ys))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nint Block(int X,int Y)\n{\n\t\n\t//printf(\"%d\",M);\n\t//printf(\"%d %d\\n\",X,Y);\n\tif(X == xg && Y == yg)\n\t\treturn 1;\n\tif(MAP[Y][X] != M || MF[Y][X] == 1 || X < 1 || Y < 1 || X > w || Y > h) return 0;\n\tMF[Y][X] = 1;\n\treturn Block(X,Y-1) || Block(X,Y+1) || Block(X-1,Y) || Block(X+1,Y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=1;i<=100;i++){    //Boardの初期化\n            for(int j=1;j<=100;j++)\n                Board[j][i] = -1;\n        } \n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n        \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* 0207 */\n#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint sx,sy,ex,ey;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y]||color==0)return 0;\n\tM[x][y]=9;\n\tif(x==ex&&y==ey)return 1;\n\tif(walk(x+1,y,color)|| walk(x-1,y,color)|| walk(x,y+1,color)|| walk(x,y-1,color))return 1;\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i=1;i<=h;i++){\n\t\t// \tfor(int j=1;j<=w;j++){\n\t\t// \t\tcout<<M[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tif((sy==ey&&sx==ex)||walk(sx,sy,M[sx][sy]))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t// if(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\t// else cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[101][101];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\t//memset(board,0,sizeof(board));\n\t\tfor(int i=0;i<101;++i){\n\t\t\tfor(int j=0;j<101;++j){\n\t\t\t\tboard[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  //DFS(Y-1,X  ,c);\n  //DFS(Y  ,X+1,c);\n  //DFS(Y+1,X  ,c);\n  //DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <iostream>\n\n\n\n#define MAX 150\n\nint map[MAX][MAX];\n\nvoid makemap(int c, int d, int x, int y);\n\nint bfs(int xs,int ys,int xg,int yg);\n\nint main()\n{\n\tint w,h,xs,ys,xg,yg,n,c,d,x,y;\n\t//int flag=1;\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)\n\t\t\treturn 0;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\n\t\t/*w=20;\n\t\th=20;\n\t\tif (flag==0)\n\t\t{\n\t\t\txs=1;\n\t\t\tys=1;\n\t\t\txg=9;\n\t\t\tyg=9;\n\t\t\tn=7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txs=9;\n\t\t\tys=9;\n\t\t\txg=1;\n\t\t\tyg=1;\n\t\t\tn=6;\n\t\t}サンプルデータ入力*/\n\t\tfor(int i=0;i<MAX;i++)\n\t\t\tfor(int j=0;j<MAX;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t/*if (flag==0)\n\t\t{\n\t\t\tmakemap(2,0,1,1);\n\t\t\tmakemap(5,1,1,3);\n\t\t\tmakemap(2,1,3,3);\n\t\t\tmakemap(1,1,5,2);\n\t\t\tmakemap(5,1,7,3);\n\t\t\tmakemap(2,0,2,7);\n\t\t\tmakemap(2,0,6,8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmakemap(2,0,1,1);\n\t\t\tmakemap(1,0,5,1);\n\t\t\tmakemap(2,1,1,3);\n\t\t\tmakemap(5,0,1,7);\n\t\t\tmakemap(3,1,5,5);\n\t\t\tmakemap(4,1,8,5);\n\t\t}サンプルデータ入力２*/\n\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tprintf(\"b%d\\n\",i+1);\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tmakemap(c,d,x,y);\n\t\t}\n\t\t\n\n\t\t/*for(int i=0;i<MAX;i++)\n\t\t{\n\t\t\tfor(int j=0;j<MAX;j++)\n\t\t\t\tprintf(\"%d\",map[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}マップの表示*/\n\n\t\tif(bfs(xs,ys,xg,yg)==0)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n}\n\treturn 0;\n}\n\nvoid makemap(int c, int d, int x, int y)\n{\n\tif(d==0)\n\t\tfor(int i=x+1;i<x+5;i++)\n\t\t\tfor(int j=y+1;j<y+3;j++)\n\t\t\t\tmap[i][j]=c;\n\telse\n\t\tfor(int i=x+1;i<x+3;i++)\n\t\t\tfor(int j=y+1;j<y+5;j++)\n\t\t\t\tmap[i][j]=c;\n}\n\nint bfs(int xs,int ys,int xg,int yg)\n{\n\tint startcolor=map[xs][ys];\n\tint nowx=xs,nowy=ys;\n\tusing namespace std;\n\tqueue<int> x;\n\tqueue<int> y;\n\twhile(1)\n\t{\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}\n\t/*bool visit[MAX][MAX];\n\tfor(int i=0;i<MAX;i++)\n\t\tfor(int j=0;j<MAX;j++)\n\t\t\tvisit[i][j]=0;\n\twhile(1)\n\t{\n\t\t//visit[nowx][nowy]=1;\n\t\tif(nowx==xg && nowy == yg && map[nowx][nowy]==startcolor )\n\t\t\treturn 0;\n\t\tmap[nowx][nowy]=0;\n\t\tif(map[nowx-1][nowy]==startcolor && visit[nowx-1][nowy]==0)\n\t\t{\n\t\t\tx.push(nowx-1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(map[nowx][nowy-1]==startcolor && visit[nowx][nowy-1]==0)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy-1);\n\t\t}\n\t\tif(map[nowx][nowy+1]==startcolor && visit[nowx][nowy+1]==0)\n\t\t{\n\t\t\tx.push(nowx);\n\t\t\ty.push(nowy+1);\n\t\t}\n\t\tif(map[nowx+1][nowy]==startcolor && visit[nowx+1][nowy]==0)\n\t\t{\n\t\t\tx.push(nowx+1);\n\t\t\ty.push(nowy);\n\t\t}\n\t\tif(x.empty()==1 && y.empty()==1)\n\t\t\treturn 1;\n\t\tnowx=x.front();\n\t\tnowy=y.front();\n\t\tx.pop();\n\t\ty.pop();\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n if(C[W][H]!=c){\n   return;\n }\n\n C[W][H] = -1;\n\n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n\nvoid print(int w,int h){\n   for(int i=1;i<=w;i++){\n       for(int j=1;j<=h;j++){\n           cout<<C[i][j]<<' ';\n       }\n       cout<<endl;\n   }\n}\n\nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n   if(w==0 && h==0){\n     break;\n   }\n\n   for(int i=0;i<20;i++){\n     for(int j=0;j<20;j++){\n       C[i][j] = 0;\n     }\n   }\n\n   int xs,ys,xg,yg;\n   cin >> xs >> ys >> xg >> yg;\n\n   int n;\n   cin >> n;\n\n   int c,d,x,y;\n   for(int i=0;i<n;i++){\n     cin >> c >> d >> x >> y;\n\n     if(d==0){\n       for(int j=x;j<x+4;j++){\n         for(int k=y;k<y+2;k++){\n           C[j][k]=c;\n         }\n       }\n     }else{\n       for(int j=x;j<x+2;j++){\n         for(int k=y;k<y+4;k++){\n           C[j][k]=c;\n         }\n       }\n     }\n   }\n   //print(w,h);\n   //cout << endl;\nif(c == 0){\ncout << \"NG\"<<endl;\ncontinue;\n}\n   meiro(xs,ys,C[xs][ys]);\n   //print(w,h);\n\n   if(C[xg][yg] == -1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n        c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nbool used[101][101];\nint mas[101][101],sx,sy,gx,gy,w,h;\nint d[]={0,1,0,-1};\nint dfs(int,int,int);\nint main(){\n  int n,c,d,x,y,tate,yoko;\n  while(cin >> w >> h && w||h){\n    memset(used,false,sizeof(used));\n    memset(mas,-1,sizeof(mas));\n    cin >> sy >> sx >> gy >> gx >> n;\n    sy--,sx--,gx--,gy--;\n    while(n--){\n      cin >> c >> d >> y >> x;\n      x--,y--;\n      d==0 ? (tate=2,yoko=4) : (tate=4,yoko=2);\n      for(int i=x;i<x+tate;i++){\n\tfor(int j=y;j<y+yoko;j++){\n\t  mas[i][j] = c;\n\t}\n      }\n    }\n    dfs(sx,sy,mas[sx][sy]);\n    cout << (used[gx][gy]?\"OK\":\"NG\") << endl;\n  }\n}\nint dfs(int x,int y,int color){\n  used[x][y] = true;\n  for(int i=0;i<4;i++){\n    int nx=x+d[i],ny=y+d[3-i];\n    if(x>=0&&x<h&&y>=0&&y<w&&mas[nx][ny]==color&&used[nx][ny]==false){\n\tdfs(nx,ny,color);\n      }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define MAX 101\n\nusing namespace std;\n\nint field[MAX][MAX];\nbool went[MAX][MAX];\nint w, h;\nint sx, sy, gx, gy;\nint scol;\nconst int dx[] = {0,0,1,-1};\nconst int dy[] = {1,-1,0,0};\n\nbool dfs(int x, int y) {\n\tif(field[y][x] == 0) return false;\n\tif(x == gx && y == gy) return true;\n\tint ncol = field[y][x];\n\tfield[y][x] = 0;\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 < nx && nx <= w && 0 < ny && ny <= h && ncol == field[ny][nx]) {\n\t\t\t/*rep(j, h) {\n\t\t\t\trep(k, w) cout << field[j][k] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tif(dfs(nx, ny)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(went, false, sizeof(went));\n\t\tint n;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(i, n) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\trep(i, (d ? 4 : 2)) rep(j, (d ? 2 : 4)) field[y + i][x + j] = c;\n\t\t}\n\t\t/*rep(j, h) {\n\t\t\trep(k, w) cout << field[j][k] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nint w, h;\nint xs, ys, xg, yg, n, c, d, x, y;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid put_b(int a[][101]) {\n  int X, Y;\n  if(d == 0) X = 4, Y = 2;\n  else X = 2, Y = 4 ;\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j < X; j++)\n      a[y + i][x + j] = c;\n}\n\nbool bfs(int a[][101]) {\n  int cs = a[ys][xs];\n  if(cs != a[yg][xg]) return false;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while(que.size()) {\n    P p = que.front();\n    que.pop();\n    if(p.first == xg && p.second == yg) return true;\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second +dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && a[ny][nx] == cs) \n\tque.push(P(nx, ny));\n    }\n  }\n  return false;\n}\nint main() {\n  while(cin >> w >> h, w != 0 || h != 0) {\n    int a[101][101] = {};\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n  \n    while(n--) {\n      cin >> c >> d >> x >> y;\n      put_b(a);\n    }\n    /*\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++)\n\tcout << a[i][j];\n      cout << endl;\n      }*/\n    if(bfs(a) == true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nint xs,ys,xg,yg,n;\nll w,h;\nvector<vector<ll>> field;\nvector<vector<ll>> f;\nbool res = false;\n\nvoid dfs(int x,int y,int c){\n  if(f[x][y] != inf) return ;\n  if(x == xg && y == yg){\n    res = true;\n    return ;\n  }\n  f[x][y] = 1;\n  rep(i,4){\n    int nx = x + dx[i],ny = y + dy[i];\n    if(value(nx,ny,w,h) && field[nx][ny] == c){\n      dfs(nx,ny,c);\n    }\n  }\n  return ;\n}\n\nvoid solve(){\n  f = vector<vector<ll>>(w+1,vector<ll>(h+1,inf));\n  res = false;\n  if(field[xs][ys]){\n    dfs(xs,ys,field[xs][ys]);\n  }\n  if(res){\n    cout << \"OK\" << endl;\n    return ;\n  }\n  cout << \"NG\" << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> w >> h && w+h){\n    field = vector<vector<ll>>(w+1,vector<ll>(h+1,0));\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--,ys--,xg--,yg--;\n    int c,d,x,y;\n    rep(i,n){\n      cin >> c >> d >> x >> y;\n      --x,--y,--c;\n      rep(j,2){\n        rep(k,4){\n          ll nx = k,ny = j;\n          if(d){\n            swap(nx,ny);\n          }\n          field[x+nx][y+ny] = c;\n        }\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n#include <queue>\n#include <complex>\n#include <climits>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint maze[110][110];\nint f[110][110];\nint w, h, xs, ys, xg, yg, res = 0;\nint color;\n\nvoid dfs(int cx, int cy){\n\tif(f[cx][cy]) return ;\n\tf[cx][cy] = 1;\n\tif(cx == xg && cy == yg){\n\t\tres = 1;\n\t\treturn ;\n\t}\n\tfor(int dx=-1; dx<=1; ++dx){\n\t\tfor(int dy=-1; dy<=1; ++dy){\n\t\t\tif(abs(dx-dy) != 1) continue;\n\t\t\tint nx = cx + dx, ny = cy + dy;\n\t\t\tif(maze[nx][ny] == color){\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<110; ++i){\n\t\t\tfor(int j=0; j<110; ++j){\n\t\t\t\tmaze[i][j] = 0;\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j=y; j<=y+1; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+3; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d == 1){\n\t\t\t\tfor(int j=y; j<=y+3; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+1; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor = maze[xs][ys];\n\t\tif(color == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(xs, ys);\n\n\t\tif(res){\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][102],int b[][102],int x,int y,int gx,int gy,int c){  \n  if(a[x][y]!=c)\n    return 0;\n  if(x==gx&&y==gy)\n    return 1;\n  if(b[x][y])\n    return 0;\n  b[x][y]=1;\n  if(f(a,b,x-1,y,gx,gy,c))\n    return 1;\n  if(f(a,b,x,y-1,gx,gy,c))\n    return 1;\n  if(f(a,b,x+1,y,gx,gy,c))\n    return 1;\n  if(f(a,b,x,y+1,gx,gy,c))\n    return 1;\n  return 0;\n}\nint main(){\n  int i,j,k;\n  int a[102][102],b[102][102],w,h,sx,sy,gx,gy,n;\n  while(cin>>w>>h&&w+h){\n    cin>>sx>>sy>>gx>>gy>>n;\n    memset(a,0,sizeof(a));\n    for(i=0;i<n;i++){\n      int p,q,r,s;\n      cin>>p>>q>>r>>s;\n      for(j=0;j<2+2*q;j++)\n\tfor(k=0;k<2+2*!q;k++)\n\t  a[r+k][s+j]=p;\n    }\n    if(a[sx][sy]!=a[gx][gy])\n      cout<<\"NG\"<<endl;\n    else if(a[sx][sy]==0)\n      cout<<\"NG\"<<endl;\n    else{\n      memset(b,0,sizeof(b));\n      if(f(a,b,sx,sy,gx,gy,a[sx][sy]))\n\tcout<<\"OK\"<<endl;\n      else\n\tcout<<\"NG\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[101][101];\n\nvoid DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='w')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_Y(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='y')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_G(int Y,int X,int Xg,int Yg,int &c){\n  if((Y==Xg&&X==Yg)||(c!=0)){\n    c=1;\n  }\n  if(F[Y][X]!='g'){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_B(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='b')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_R(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='r')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n}\n\nint main(){\n\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      F[j][i]='0';\n    }\n  }\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  cin>>w>>h;\n  while(w!=0){\n    //int a=0;\n    //int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    int c[n];\n    int d[n];\n    int x[n];\n    int y[n];\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      //int a=0;\n      //int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n        F[i][j]='0';\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\nbool dfs(int x,int y);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tboard[i][j]=0;\n\tcheak[i][j]=0;\n      }\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs-1,ys-1)==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==board[ys-1][xs-1] && cheak[yn][xn]==0){\n      if(dfs(xn,yn)==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nqueue <pair<int,int> > blocks;\nint w,h,xs,ys,n,xg,yg,c,d,x,y,area[105][105];\nbool flag=false;\nvoid solve(int x,int y,int c);\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0&&h==0)break;\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=0;i<n;i++){\n            cin >> c >> d >> x >> y;\n            if(d==0){\n            for(int j=y;j<y+2;j++){\n                for(int k=x;k<x+4;k++){\n                    area[k][j]=c;\n                }\n            }\n            }else{\n            for(int j=y;j<y+4;j++){\n                for(int k=x;k<x+2;k++){\n                    area[k][j]=c;\n                    }\n                }\n            }\n        }\n        if(area[xs][ys]!=area[xg][yg]);\n        else {\n        blocks.push(make_pair(xs,ys));\n        solve(1,1,area[xs][ys]);\n        }\n        if(flag==true)cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n        flag=false;\n        fill(area[0],area[104],0);\n    }\n\nreturn 0;\n}\n\nvoid solve(int x,int y,int c){\n    if(!blocks.empty()){\n    blocks.pop();\n    if(x==xg&&y==yg){\n        flag=true;\n        while(!blocks.empty())blocks.pop();\n    }else{\n        area[x][y]=0;\n        if(area[x-1][y]==c)blocks.push(make_pair(x-1,y));\n        if(area[x][y-1]==c)blocks.push(make_pair(x,y-1));\n        if(area[x+1][y]==c)blocks.push(make_pair(x+1,y));\n        if(area[x][y+1]==c)blocks.push(make_pair(x,y+1));\n        solve(blocks.front().first,blocks.front().second,c);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint board[100][100],w,h,xg,yg;\nbool f(int y,int x,int color){\n\tboard[y][x] = -1;\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\tif(y == yg - 1 && x == xg -1) return true;\n\tfor(i = 0;i < 4;i++){\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\t\t\tif(board[y+dy[i]][x+dx[i]] == color){\n\t\t\t\tif(f(y+dy[i],x+dx[i],color)) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint xs,ys,n,i,j,k,c,d,x,y;\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\t\tfor(j = 0;j < 100;j++){\n\t\t\tfor(i = 0;i < 100;i++){\n\t\t\t\tboard[j][i] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx -= 1;\n\t\t\ty -= 1;\n\t\t\tif(d == 0){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(board[ys - 1][xs - 1] != -1){\n\t\t\tif(f(ys - 1,xs -1,board[ys - 1][xs - 1])) cout << \"OK\" << endl;\n\t\t\telse cout << \"NG\" << endl;\n\t\t}\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\nshort maze[MAX][MAX];\nshort color;\n\nbool check()\n{\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(check())\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n/*\n\t\trep(i,y){\n\t\t\trep(j,x)\n\t\t\t\tprintf(\"%2d\", maze[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\n*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h,f=0;\nvoid block(int ,int);\nint main()\n{\n\tint i,n,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,false,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]&&R!=0){\n\t\t\tblock(Y,X);\n\t\t\tif(f==1) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tf=0;\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nvoid block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=true;\n\tif(ga==a&&gb==b) f=1;\n\t\tif(map[b][a+1]==R&&N[b][a+1]==false) block(b,a+1); //???\n\t\tif(map[b+1][a]==R&&N[b+1][a]==false) block(b+1,a); //???\n\t\tif(map[b][a-1]==R&&N[b][a-1]==false) block(b,a-1); //???\n\t\tif(map[b-1][a]==R&&N[b-1][a]==false) block(b-1,a); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n\n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101],w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy))r=1;\n\tif(x>1&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<=w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>1&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<=h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\tif(d)bw=2,bh=4;\n\t\t\telse{bh=2,bw=4;}\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])c = m[sx][sy],m[sx][sy]=0,dfs(sx,sy,c);\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define shosu(n) setprecision(n)\nusing namespace std;\nint w, h, xs, ys, xg, yg;\nint mp[110][110];\n\nbool dfs(int x, int y, int f) {\n  if (x >= w || y >= h || x < 0 || y < 0 || mp[y][x] != f)\n    return false;\n  if (y == yg && x == xg && mp[y][x] == f)\n    return true;\n  mp[y][x] = 9;\n  return dfs(x + 1, y, f) || dfs(x - 1, y, f) || dfs(x, y + 1, f) ||\n         dfs(x, y - 1, f);\n}\n\nint main() {\n  while (cin >> w >> h) {\n    if (w == 0 && h == 0)\n      break;\n    int n;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--;\n    ys--;\n    xg--;\n    yg--;\n    int c, d, x, y;\n    rep(i, n) {\n      cin >> c >> d >> x >> y;\n      if (d == 0) {\n        for (int i = y - 1; i < y + 1; i++)\n          for (int j = x - 1; j < x + 3; j++) {\n            mp[i][j] = c;\n          }\n      } else {\n        for (int i = y - 1; i < y + 3; i++)\n          for (int j = x - 1; j < x + 1; j++) {\n            mp[i][j] = c;\n          }\n      }\n    }\n    cout << (dfs(xs, ys, mp[ys][xs]) ? \"OK\" : \"NG\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w, h, xs, ys, xg, yg, stage[101][101];\nint ny[4] = { 0, 1, 0, -1 }, nx[4] = { 1, 0, -1, 0 };\nint bc;\nbool ans = false;\nvoid func(int x, int y, int lastp){\n\tif (x == xg && y == yg){\n\t\tans = true;\n\t}\n\tfor (int i = 0; i < 4; i++){\n\t\tif (stage[y + ny[i]][x + nx[i]] != bc || i == lastp) return;\n\t\tfunc(x + nx[i], y + ny[i], (i + 2) % 4);\n\t}\n}\nint main(){\n\tint n, c, d, x, y, bw, bh;\n\twhile (1){\n\t\tfor (int i = 0; i < 101; i++){\n\t\t\tfor (int j = 0; j < 101; j++){\n\t\t\t\tstage[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tbw = 4;\n\t\t\t\tbh = 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbw = 2;\n\t\t\t\tbh = 4;\n\t\t\t}\n\t\t\tfor (int j = 0; j < bh; j++){\n\t\t\t\tfor (int k = 0; k < bw; k++){\n\t\t\t\t\tstage[y + j][x + k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = stage[ys][xs];\n\t\tif (bc == 0){\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tfunc(1, 1, -1);\n\t\tif (ans == true) cout << \"OK\\n\";\n\t\telse cout << \"NG\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif ((W == 0) && (H == 0)) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n//bool b;\n//int xg , yg;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[105][105];\nint  sc;\n/*\nvoid dfs(int x , int y ,int w , int h){\n\tif(x==xg&&y==yg) {\n\t\tb=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=sc || board[tx][ty]==0 || b ) continue;\n\t\tdfs( tx , ty , w , h );\n\t}\n}\n*/\n\nvoid dfs(int x , int y , int w , int h){\n\tif(x<=0 || y<=0 || x>w || y >h) return;\n\tif(board[x][y]==sc){\n\t\tboard[x][y]=10;\n\t\tfor(int i=0;i<4;++i){\n\t\t\tdfs(x+dx[i] , y+dy[i] , w , h);\n\t\t}\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w|h){\n\t\tint xs , ys , n;\n\t\tint xg , yg;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tdfs( xs , ys , w , h );\n\t\tcout << ( board[xg][yg]==10 ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    memset(mass,0,sizeof(mass));\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n  \n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    switch(d[i]){\n    case 0:              //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n      break;\n    case 1:              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n      break;\n    }\n  }\n  \n  scolor=mass[sy][sx];\n  \n  for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      if(scolor!=mass[i][j]){\n\tmass[i][j]=0;\n      }\n    }\n  }\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,xs,ys,n,xg,yg,c,d,x,y,area[105][105],c_area[105][105];\nint x_p[4]={-1,0,1,0},y_p[4]={0,-1,0,1};\n\nbool flag=false;\nvoid solve(int x,int y,int c);\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0&&h==0)break;\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=0;i<n;i++){\n            cin >> c >> d >> x >> y;\n            if(d==0){\n            for(int j=y;j<y+2;j++){\n                for(int k=x;k<x+4;k++){\n                    area[k][j]=c;\n                }\n            }\n            }else{\n            for(int j=y;j<y+4;j++){\n                for(int k=x;k<x+2;k++){\n                    area[k][j]=c;\n                    }\n                }\n            }\n        }\n        if(area[xs][ys]!=area[xg][yg]);\n        else {\n        solve(xs,ys,area[xs][ys]);\n        }\n        if(flag==true)cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n        flag=false;\n        fill(area[0],area[104],0);\n    }\n\nreturn 0;\n}\n\nvoid solve(int x,int y,int c){\n\n    if(x==xg&&y==yg){\n        flag=true;\n    return;\n    }else{\n        for(int i=0;i<4;i++){\n        if(area[x+x_p[i]][y+y_p[i]]==c){\n                c_area[x][y]=area[x][y];\n                area[x][y]=0;\n                solve(x+x_p[i],y+y_p[i],c);\n                area[x][y]=c_area[x][y];\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint weight, hight;\nint g[110][110];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n\n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n        \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            g[y][x] = 8;\n            dfs(nx, ny);\n        }\n    }\n}\n\nvoid disp(){\n    for(int i = 0;i < hight;i++){\n        for(int j = 0;j < weight;j++){\n            cout << g[i][j];\n        }cout << endl;\n    }\n}\n\nint main(){\n    int dn, c, d, x, y;\n    \n    while(cin >> weight >> hight){\n        if(weight == 0 && hight == 0){\n            break;\n        }\n        \n        cin >> sx >> sy >> gx >> gy >> dn;\n        \n        for(int i = 0;i < dn;i++){\n            cin >> c >> d >> x >> y;\n            \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n        \n        sc = g[sy][sx];\n        flag = false;\n        dfs(sx, sy);\n        \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 10;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n\n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep_(v, f, l) for (int v = (f); v < (l); ++v)\n#define rep(v, n) rep_(v, 0, n)\n#define lep(v, n) rep_(v, 1, n + 1)\n\nusing namespace std;\n\ntypedef long long int lint;\n\nstatic inline int in(){ int x; scanf(\"%d\", &x); return x; }\nstatic inline lint inl(){ lint x; scanf(\"%lld\", &x); return x; }\n\nstruct UF {\n    vector<int> data;\n    UF(int n) : data(n, -1) {}\n    bool merge(int x, int y){\n        x = root(x);\n        y = root(y);\n        if (x != y){\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool isSame(int x, int y){\n        return root(x) == root(y);\n    }\n    int root(int x){\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\n\nint main()\n{\n    int w, h;\n    while (w = in(), h = in()){\n        UF uf(w * h);\n        int sx, sy;\n        sx = in() - 1;\n        sy = in() - 1;\n        int gx, gy;\n        gx = in() - 1;\n        gy = in() - 1;\n        int n = in();\n        int field[128][128] = {};\n        rep(i, n){\n            int c, d, x, y;\n            c = in();\n            d = in();\n            x = in() - 1;\n            y = in() - 1;\n            rep(j, 4) rep(k, 2){\n                if (!d) field[y + k][x + j] = c;\n                else field[y + j][x + k] = c;\n            }\n        }\n        rep(i, h){\n            rep(j, w){\n                if (i + 1 < h && field[i][j] == field[i + 1][j]){\n                    uf.merge(i * w + j, i * w + j + w);\n                }\n                if (j + 1 < w && field[i][j] == field[i][j + 1]){\n                    uf.merge(i * w + j, i * w + j + 1);\n                }\n            }\n        }\n\n        if (uf.isSame(sy * w + sx, gy * w + gx)){\n            puts(\"OK\");\n        }\n        else {\n            puts(\"NG\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\tusing namespace std;\n\tint xs,ys,w,h,n,ban[111][111],xg,yg;bool visited[101][101];\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(c-1||ban[x][y]!=c)return false;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y,c))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "//#include <iostream>\n//#include <algorithm>\n//using namespace std;\n// \n//int N;  // ??????????????° (1 <= N <= 100)\n//int W;  // ??????????????????????????? (1 <= W <= 10000)\n// \n//struct Item {\n//    int v;  // ??????????????? (1 <= v <= 1000)\n//    int w;  // ??????????????? (1 <= w <= 1000)\n//};\n//Item items[101];    // ??????????????±\n// \n//int C[101][10001];  // ??????????????????????¨???????????????????????¬??????????\n///*\n//    C[i][w] :\n//    ???????????????????????\\?????????or??\\???????????????i????????????????????§????????????\n//    ??????????????????????¨????w????????£???????????????????????§??????????´??????????\n//*/\n//\n//int maxv = 0;  // ?????????????¨?????????§???\n// \n//// ??????????????????????????°????????¢??°\n//void debug_print(int i, int w)\n//{\n//    char key_wait;\n// \n//    cout << \"  C[i][w] = max(C[i-1][w], C[i-1][w - items[i].w] + items[i].v);\" << endl;\n//    cout << \"->C[\" << i << \"][\" << w << \"] = max(C[\" << i - 1 << \"][\" << w << \"], C[\" << i - 1 << \"][\" << w << \" - \" << items[i].w << \"] + \" << items[i].v << \")\" << endl;\n// \n//    for (int iii = 0; iii <= N; ++iii) {\n//        for (int www = 0; www <= W; ++www) {\n//            if (C[iii][www] == -1) {\n//                cout << \" x\";\n//            }\n//            else {\n//                cout << \" \" << C[iii][www];\n//            }\n//        }\n//        cout << endl;\n//    }\n// \n//    cin >> key_wait;\n//}\n// \n// \n//int main()\n//{\n//    int i, w;\n// \n//    cin >> N >> W;\n// \n//    // ?????? = 0, ?????? = 0 ???????????????????????\\???????????????\n//    // ?????????????????¨??§?????????????????????????°??????????????????????????????????\n//    items[0].v = 0;\n//    items[0].w = 0;\n//    for (i = 1; i <= N; ++i) {\n//        cin >> items[i].v >> items[i].w;\n//    }\n// \n//    /*\n//    ???????????°????????¨????????????-1??§?????????\n//    ??????????§£??????????????£??????\n//    ????????????????????????????????????????????????\n//    */\n//    for (i = 0; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            C[i][w] = -1;\n//        }\n//    }\n// \n//    // ??¢????????????????????\\??£???????????´????????????0\n//    for (w = 0; w <= W; ++w) {\n//        C[0][w] = 0;\n//    }\n// \n//    for (i = 1; i <= N; ++i) {\n//        for (w = 0; w <= W; ++w) {\n//            // ?????????????????????i??????????????????????????\\???????????´???\n//            if (w - items[i].w < 0) {\n//                C[i][w] = C[i - 1][w];\n//            }\n//            // ?????????????????????i????????????????????\\??????????£????????????´??????\n//            // i????????????????????\\???????????£??????????????????\n//            // i????????????????????\\???????????????w????????£??????????????????????????????\n//            // ????????§????????????????´??????????\n//            else {\n//                C[i][w] = max(C[i - 1][w], C[i - 1][w - items[i].w] + items[i].v);\n//            }\n//            maxv = max(maxv, C[i][w]);\n// \n//            // ???????????°????????¨??¢??°\n//            // ???????????????????????¢??????????????°AOJ??§Accepted??????????????????\n//            debug_print(i, w);\n//        }\n//    }\n// \n//    cout << maxv << endl;\n// \n//    return 0;\n//}\n/*\n#include <iostream>\n#include <string>\nusing namespace std;\n\n#define REP( i, a )     for( int i = 0; i < a; i++ )\n#define RREP( i, a )    for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin, (A).end()\n\ntemplate <typename T>\nvoid debug( const T& outData ) {\n\tcout << outData << endl;\n}\n\ntemplate <typename T>\nvoid debugAr( const T& outData[], const int& loopNum ) {\n\n\tfor( int i = 0; i < loopNum; i++ ) cout << outData[i] << endl;\n\n}\n\nint main()\n{\n\n\tint a;\n\tstring str;\n\n\tcin >> a >> str;\n\n\tdebug( a );\n\tdebug( str );\n\n\treturn 0;\n\n}\n*/\n\n/*#ifndef DEBUG_H\n#define DEBUG_H\n\n#include <iostream>\n\n#define REP( i, a )  for( int i = 0; i < a; i++ )\n#define RREP( i, a ) for( int i = a; i >= 0; i-- )\n#define FOR( i, a, b )  for( int i = a; i < b; i++ )\n#define RFOR( i, a, b ) for( int i = b; i >= a; i-- )\n#define ALL( A ) (A).begin(), (A).end()\n\ntemplate <typename T>\nvoid prt( T outData )\n{\n\nstd::cout << outData << endl;\n\n}\n\n\n\n#endif\n\n\n??£????????????\n*/\n\n/*\n#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int N=100;\n\nint main(){\nint i,n,j,p[N+1],m[N+1][N+1],k;\ncin>>n;\nfor(i=1;i<=n;i++){\ncin>>p[i-1]>>p[i];\n}\nfor(i=1;i<=n;i++) m[i][i]=0;\nfor(i=2;i<=n;i++){\nfor(i=1;i<=n;i++){\nint j=i+i-1;\nm[i][j]=(i<<21);\nfor(k=10;k<=j-1;j++){\n}\n}\n}\nm[i][j]=min(m[i][j]=\n\n*/\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[101][101];\nint map[101][101],R,ga,gb,f=0;\nint block(int ,int);\nint main()\n{\n\tint i,j,a,n,L,b,c,d,X=0,Y=0,w,h,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,0,sizeof(N));\n\t\tcin>>a>>b;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[x][y]=c;\n\t\t\t\tmap[x][y+1]=c;\n\t\t\t\tmap[x][y+2]=c;\n\t\t\t\tmap[x][y+3]=c;\n\t\t\t\tmap[x+1][y]=c;\n\t\t\t\tmap[x+1][y+1]=c;\n\t\t\t\tmap[x+1][y+2]=c;\n\t\t\t\tmap[x+1][y+3]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[x][y]=c;\n\t\t\t\tmap[x+1][y]=c;\n\t\t\t\tmap[x+2][y]=c;\n\t\t\t\tmap[x+3][y]=c;\n\t\t\t\tmap[x+1][y+1]=c;\n\t\t\t\tmap[x+2][y+1]=c;\n\t\t\t\tmap[x+3][y+1]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[a][b];\n\t\tif(block(a,b)) cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\tf=0;\n\t}\n\treturn 0;\n}\nint block(int a,int b)\n{\n\t//if(f==1) return 1;\n\tN[a][b]=1;\n\tif(ga==a&&gb==b) f=1;return 1;\n\tif(map[a+1][b]==R&&N[a+1][b]==0) return block(a+1,b);\n\tif(map[a][b+1]==R&&N[a][b+1]==0) return block(a,b+1);\n\tif(map[a-1][b]==R&&N[a-1][b]==0) return block(a-1,b);\n\tif(map[a][b-1]==R&&N[a][b-1]==0) return block(a,b-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nint w,h;\nbool** flags;\nchar** map;\n\nclass Point{\npublic:\n\tint X,Y;\n};\n\ntemplate <class T> T** NewArray(int w,int h){\n\tT** r = new T*[w];\n\tfor(int i=0;i<w;i++){\n\t\tr[i] = new T[h];\n\t\tfor(int j=0;j<h;j++){\n\t\t\tr[i][j] = 0;\n\t\t}\n\t}\n\treturn r;\n}\n\ntemplate <class T> void RemoveArray(T** array,int w,int h){\n\tfor(int i=0;i<h;i++){\n\t\tdelete[] array[i];\n\t}\n\tdelete[] array;\n}\n\nbool Check(int x,int y,int c){\n\tif(x<0){return false;}\n\tif(y<0){return false;}\n\tif(x>=w){return false;}\n\tif(y>=h){return false;}\n\tif(flags[x][y]){return false;}\n\tif(map[x][y] != c){return false;}\n}\n\nbool Solve(int sx,int sy,int gx,int gy){\n\tchar c = map[sx][sy];\n\tqueue<Point> pts;\n\tflags = NewArray<bool>(w + 1,h + 1);\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tflags[i][j] = false;\n\t\t}\n\t}\n\tPoint p,pp;\n\tp.X = sx;\n\tp.Y = sy;\n\tpts.push(p);\n\tflags[sx][sy] = true;\n\t\n\tbool res = false;\n\t\n\twhile(pts.size() > 0){\n\t\tp = pts.front();\n\t\tpts.pop();\n\t\tif(flags[gx][gy] == true){\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\t\tpp = p;\n\t\tpp.X -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.X += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t}\n\t\n\tRemoveArray<bool>(flags,w + 1,h + 1);\n\treturn res;\n}\n\nint main(){\n\tint xs,ys,xg,yg;\n\t\n\twhile(scanf(\"%d %d\",&w,&h) && w && h){\n\t\tw+=1;\n\t\th+=1;\n\t\tmap = NewArray<char>(w + 1,h + 1);\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\txs -= 1;\n\t\tys -= 1;\n\t\txg -= 1;\n\t\tyg -= 1;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tint c,d,x,y;\n\t\tint xx,yy;\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t//printf(\"%d \",map[i][j]);\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\txx = 4;\n\t\t\t\tyy = 2;\n\t\t\t}else{\n\t\t\t\txx = 2;\n\t\t\t\tyy = 4;\n\t\t\t}\n\t\t\tx-=1;\n\t\t\ty-=1;\n\t\t\tfor(int j=0;j<xx;j++){\n\t\t\t\tfor(int k=0;k<yy;k++){\n\t\t\t\t\t//printf(\"(%2d+%2d,%2d+%2d) = %d\\n\",k,j,y,k,c);\n\t\t\t\t\tmap[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t//printf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n\");\n\t\t}\n\t\t\n\t\t\n\t\tif(Solve(xs,ys,xg,yg)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tRemoveArray<char>(map,w + 1,h + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\n#include<map>\n#include<string>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nstruct Data{\n\tint y, x;\n\tData(){}\n\tData(int _y, int _x){\n\t\ty = _y; x = _x;\n\t}\n};\n\nint fld[100][100];\n\nvoid PaintFld(int c, int x, int y, int w, int h){\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tfld[y + i][x + j] = c;\n\t\t}\n\t}\n}\n\nint main(){\n\tint W, H;\n\twhile(cin >> W >> H, W || H){\n\t\tfill_n( (int*)fld, 100*100, 0 );\n\t\tint Xs, Ys, Xg, Yg, N, C, D, X, Y;\n\t\tcin >> Xs >> Ys >> Xg >> Yg >> N;\n\t\tXs--; Ys--; Xg--; Yg--;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tX--; Y--;\n\t\t\tif(D == 0) PaintFld(C, X, Y, 4, 2);\n\t\t\telse PaintFld(C, X, Y, 2, 4);\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tbool memo[100][100] = {}, ans = false;\n\t\tq.push( Data(Xs, Ys) );\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\n\t\t\tif(q_front.y == Yg && q_front.x == Xg){\n\t\t\t\tans = true; break;\n\t\t\t}\n\n\t\t\tif(memo[q_front.y][q_front.x]) continue;\n\t\t\tmemo[q_front.y][q_front.x] = true;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i];\n\t\t\t\tint nx = q_front.x + dx[i];\n\n\t\t\t\tif(ny < 0 || H <= ny || nx < 0 || W <= nx || fld[ny][nx] != fld[Ys][Xs])\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push( Data(ny, nx) );\n\t\t\t}\n\t\t}\n\n\t\tif(ans) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nbool dfs(int x,int y,int color);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    memset(board,0,sizeof(board));\n    memset(cheak,0,sizeof(cheak));\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs-1,ys-1,board[ys-1][xs-1])==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y,int color){\n  cheak[y][x]=1;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==color && cheak[yn][xn]==0){\n      if(dfs(xn,yn,board[yn][xn])==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint ib[100][100];\nbool used[100][100];\nint i,j;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,1,-1,0};\n\nbool search(int a,int b,int c){\n\tbool ok=false;\n\tfor(int k=0;k<4;k++){\n\t\tif(a+dx[k]>=0&&a+dx[k]<w&&b+dy[k]>=0&&b+dy[k]<h){\n\t\t\tif(!used[a+dx[k]][b+dy[k]]&&ib[a+dx[k]][b+dy[k]]==c){\n\t\t\t\tused[a+dx[k]][b+dy[k]]=true;\n\t\t\t\tif(a+dx[k]==xg-1&&b+dy[k]==yg-1)return true;\n\t\t\t\tif(search(a+dx[k],b+dy[k],c))ok=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ok;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0)return 0;\n\t\tscanf(\"%d %d\",&xs,&ys);\n\t\tscanf(\"%d %d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<w;i++)for(j=0;j<h;j++){\n\t\t\tib[i][j]=0;\n\t\t\tused[i][j]=false;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0)for(j=0;j<4;j++)for(int k=0;k<2;k++)ib[x+j-1][y+k-1]=c;\n\t\t\tif(d==1)for(j=0;j<2;j++)for(int k=0;k<4;k++)ib[x+j-1][y+k-1]=c;\n\t\t}\n\t\tif(search(xs-1,ys-1,ib[xs-1][ys-1]))printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h){\n    int xs,ys,xg,yg;\n    bool Map[h+10][w+10]={};\n    bool flag=false;\n    cin>>xs>>ys>>xg>>yg;\n    xs--;ys--;xg--;yg--;\n    int n;cin>>n;\n    int Map2[h+10][w+10]={};\n    Map[ys][xs]=true;\n    queue<pair<int,int> >que;\n    que.push(mp(ys,xs));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      if(d==0){\n\tfor(int i=y;i<y+2;i++)\n\t  for(int j=x;j<x+4;j++)\n\t    Map2[i][j]=c;\n      }else if(d==1){\n\tfor(int i=y;i<y+4;i++)\n\t  for(int j=x;j<x+2;j++)\n\t    Map2[i][j]=c;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)\n\tcout<<Map2[i][j]<<\" \";\n      cout<<endl;\n    }\n    int vx[4]={0,-1,0,1};\n    int vy[4]={1,0,-1,0};\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      if(now.F==xg&&now.S==yg){\n\tflag=true;\n\tbreak;\n      }\n      for(int kk=0;kk<4;kk++){\n\tint as=now.F+vx[kk];int bs=now.S+vy[kk];\n\tif(as<h&&as>=0&&bs<w&&bs>=0&&Map2[now.F][now.S]==Map2[as][bs]&&!Map[as][bs]){\n\t  que.push(mp(as,bs));\n\t  Map[as][bs]=true;\n\t}\n      }\n    }\n    if(flag)\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\nint blocks[105][105], xg, yg, w,h;\n\nvoid dfs(int target, int x, int y){\n    if(x <= 0 || y <= 0 || x > w || y > h) return;\n    if(x == xg && y == yg){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] != target || blocks[y][x] == 0){\n        return;\n    }\n\n    blocks[y][x] = 0;\n    \n    dfs(target, x + 1, y);\n    dfs(target, x - 1, y);\n    dfs(target, x, y + 1);\n    dfs(target, x, y - 1);\n}\n\nint main(){\n    int xs, ys, n;\n    while(cin >> w >> h, w||h){\n        rep(i,105) rep(j,105) blocks[i][j] = 0;\n        cin >> xs >> ys >> xg >> yg >> n;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        dfs(blocks[ys][xs], xs, ys);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<functional>\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint c,d,x,y;\nint map[101][101];\nint flg=0,temp;\nvoid func(int ,int);\nusing namespace std;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0){\n\t\t\tbreak;\n\t\t}\n\t\tint i,j,k;\n\t\tfor(i=1;i<=100;i++){\n\t\t\tfor(j=1;j<=100;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(k=0;k<=1;k++){\n\t\t\t\t\tfor(j=0;j<=3;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\t\tfor(j=0;j<=1;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*for(j=1;j<=10;j++){\n\t\t\t\tfor(k=1;k<=10;k++){\n\t\t\t\t\tprintf(\"%d \",map[j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\t\tflg=0;\n\t\tif(map[ys][xs]==map[yg][xg] && map[ys][xs]!=0){\n\t\t\ttemp=map[ys][xs];\n\t\t\tmap[ys][xs]=0;\n\t\t\tfunc(ys,xs);\n\t\t}/*\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tif(flg==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\nvoid func(int y,int x){\n\tint dy[4]={0,1,0,-1},dx[4]={1,0,-1,0};\n\tint i,xx,yy;\n\tif(flg==0){\n\t\tfor(i=0;i<4;i++){\n\t\t\tyy=y+dy[i];\n\t\t\txx=x+dx[i];\n\t\t\tif(yy<=h && yy>=1 && xx<=w && xx>=1 && map[yy][xx]==temp){\n\t\t\t\tmap[yy][xx]=0;\n\t\t\t\tif(xg==xx && yg==yy){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfunc(yy,xx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 10)\n        c = 2345;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n \n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring ans;\nint w,h,gx,gy;\nint map[110][110];\nint dx_[4] = {0,1,0,-1};\nint dy_[4] = {1,0,-1,0};\nint dx[2][8] = {\n\t{0,1,2,3,0,1,2,3},\n\t{0,1,0,1,0,1,0,1}\n};\nint dy[2][8] = {\n\t{0,0,0,0,1,1,1,1},\n\t{0,0,1,1,2,2,3,3},\n};\nvoid solve(int x,int y,int color){\n\tif( ans == \"OK\" || color == 0 ) return;\n\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx_[i];\n\t\tint my = y + dy_[i];\n\t\tif( mx<0 || mx>w || my<0 || my>h ) continue;\n\t\t\n\t\tif( map[my][mx] == color ){\n\t\t\tif( mx == gx && my == gy ){\n\t\t\t\tans = \"OK\";\n\t\t\t}else{\n\t\t\t\tmap[my][mx] = 0;\n\t\t\t\tsolve( mx , my , color );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint sx,sy,n;\n\t\n\twhile( cin >> w >> h , w|h ){\n\t\tans = \"NG\";\n\t\tfor(int y=0 ; y<110 ; ++y )\n\t\t\tfor(int x=0 ; x<110 ; ++x )\n\t\t\t\tmap[y][x] = 0;\n\n\t\tcin >> sx >> sy >> gx >> gy >> n ;\n\t\tfor(int i=0 ; i<n ; ++i ){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor(int j=0 ; j<8 ; j++){\n\t\t\t\tint mx = x + dx[d][j];\n\t\t\t\tint my = y + dy[d][j];\n\t\t\t\tmap[my][mx] = c;\n\t\t\t}\n\t\t}\n\t\tsolve( sx , sy , map[sy][sx] );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <utility>\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nusing namespace std;\n\ntypedef pair<int,int> pii;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nint sx,sy,gx,gy;\nint w,h,n;\nint g[1000][1000];\nbool valid(int y, int x){ return 0<=x && x<w && 0<=y && y<h; }\n\nint main(){\n    while(cin>>w>>h && w){\n        cin>>sx>>sy>>gx>>gy;\n        sx--,sy--,gx--,gy--;\n        cin>>n;\n        rep(i,h)rep(j,w)g[i][j]=0;\n        rep(i,n){\n            int c,d,x,y;\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n            if(d==0)x+=2;else y+=2;\n            for(int j=0;j<4;j++)g[y+j%2][x+j/2]=c;\n            g[y][x]=c;\n        }\n        int C=g[sy][sx];\n        rep(i,h)rep(j,w)g[i][j]= (g[i][j]==C) ? C : 0;\n        bool vis[1000][1000]={};\n        vis[sy][sx]=true;\n        if(C){\n            stack<pii> s;\n            vis[sy][sx]=true;\n            s.emplace(sy,sx);\n            while(s.size()){\n                int y,x;\n                tie(y,x) = s.top();s.pop();\n                rep(d,4){\n                    int nx=x+dx[d],ny=y+dy[d];\n                    if(!valid(nx,ny))continue;\n                    if(vis[ny][nx])continue;\n                    vis[ny][nx]=true;\n                    s.emplace(ny,nx);\n                }\n            }\n        }\n        puts(vis[gy][gx] ? \"OK\" : \"NG\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//メモリ数確認したか?\n#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\ntypedef long long int ll;\nbool s[100][100];\nint w,h,xs,ys,xg,yg,n;\nint boad[100][100];\nint c,d,x,y;\nint X[4]={-1,0,0,1};\nint Y[4]={0,-1,1,0};\nvoid f(int x,int y){\n\ts[x][y]=true;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>=0&&x+X[i]<w&&y+Y[i]>=0&&y+Y[i]<h){\n\t\t\tif(!s[x+X[i]][y+Y[i]]){\n\t\t\t\tif(boad[x][y]==boad[x+X[i]][y+Y[i]]){\n\t\t\t\t\tf(x+X[i],y+Y[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(true){\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tboad[i][j]=0;\n\t\t\ts[i][j]=false;\n\t\t}\n\t}\n\tscanf(\"%d%d\",&w,&h);\n\tif(w==0&&h==0)return 0;\n\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\tif(d==1){\n\t\t\tfor(int j=x-1;j<x+2-1;j++){\n\t\t\t\tfor(int k=y-1;k<y+4-1;k++){\n\t\t\t\t\tboad[k][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse{\n\t\t\tfor(int j=x-1;j<x+4-1;j++){\n\t\t\t\tfor(int k=y-1;k<y+2-1;k++){\n\t\t\t\t\tboad[k][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(boad[xs-1][ys-1]==0||boad[xg-1][yg-1]==0){\n\t\tprintf(\"NG\\n\");\n\t\tgoto a;\n\t}\n\tf(xs-1,ys-1);\n\t\n\tif(s[xg-1][yg-1]){\n\t\tprintf(\"OK\\n\");\n\t}\n\telse printf(\"NG\\n\");\na:;\n\t}\n    return 0;\n}\n//メモリ数確認したか?"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nconst int dy[4] = {-1, 1, 0, 0};\nconst int dx[4] = {0, 0, -1, 1};\nconst int MAX_W = 101, MAX_H = 101;\nint maze[MAX_H][MAX_W];\nint w, h, xs, ys, xg, yg, color;\n\nvoid solve() {\n  memset(maze, 0, sizeof maze);\n  int n;\n  cin>>xs>>ys>>xg>>yg>>n;\n  rep(i,n) {\n    int c, d, x, y;\n    cin>>c>>d>>x>>y;\n    //cout<<c<<d<<x<<y<<endl;\n    if (d == 0) {\n      REP(j,x,x+4) REP(k,y,y+2) maze[k][j] = c;\n    } else {\n      REP(j,x,x+2) REP(k,y,y+4) maze[k][j] = c;\n    }\n  }\n  \n  if (maze[ys][xs] == 0) {\n    cout<<\"NG\"<<endl;\n    return;\n  } else {\n    color = maze[ys][xs];\n  }\n  \n  bool flag = false;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while (!que.empty() || !flag) {\n    P p = que.front(); que.pop();\n    int tx = p.first, ty = p.second;\n    if (tx == xg && ty == yg) {\n      flag = true; continue;\n    }\n    if (maze[ty][tx] == 0) continue;\n    maze[ty][tx] = 0;\n    \n    rep(z,4) {\n      int ttx = tx + dx[z], tty = ty + dy[z];\n      if (ttx < 1 || tty < 1 || ttx >= w || tty >= h) continue;\n      if (maze[tty][ttx] != color) continue;\n      que.push(P(ttx, tty));\n    }\n  }\n  \n  if (flag) {\n    cout<<\"OK\"<<endl;\n  } else {\n    cout<<\"NG\"<<endl;\n  }\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>w>>h, w||h) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint N;\nint W,H;\npair<int,int>s;\npair<int,int>g;\nint sc;\nint map[103][103]={0};\nbool flag[103][103]={0};\nint ans=0;\n\nbool se(int x,int y){\n\tif(x==g.first && y==g.second)ans=1;\n\tfor(int i=0;i<4;i++){\n\t\tint xx=x+dx[i];\n\t\tint yy=dy[i]+y;\n\t\tif(xx>=0 &&yy>=0 &&xx<W &&yy<H && sc==map[xx][yy]&& flag[xx][yy]==0){\n\t\t\tflag[xx][yy]=1;\n\t\t\tse(xx,yy);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\t\n\twhile(cin>>W>>H>>s.first>>s.second>>g.first>>g.second>>N && W && H){\n\t\tint d,c,x,y;\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tsc=map[s.first][s.second];\n\t\tflag[s.first][s.second]=1;\n\t\tse(s.first,s.second);\n\t\tif(ans)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t//if(se(s.first,s.second))cout<<\"OK\"<<endl;\n\t\t//else cout<<\"NG\"<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nbool bfs(pair<int,int>[],int **);\n\nint main(void){\n\tint w,h,xs,ys,xg,yg,n,**board,dr[2][2]={4,2,2,4};\n\tpair<int,int> sg[2];\n\n\tdo{\n\t\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\n\t\tsg[0] = make_pair(xs,ys);\n\t\tsg[1] = make_pair(xg,yg);\n\n\t\tboard = new int*[w+2];\n\t\tfor(int i=0;i<w+2;i++)\n\t\t\tboard[i] = new int[h+2];\n\n\t\tfor(int i=0;i<h+2;i++)\n\t\t\tfor(int j=0;j<w+2;j++)\n\t\t\t\tboard[j][i]=0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor(int j=0;j<dr[d][0];j++)\n\t\t\t\tfor(int k=0;k<dr[d][1];k++)\n\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t}\n\n\t\tcout << (bfs(sg,board)?\"OK\":\"NG\");\n\t\tcout << endl;\n\n\t\tfor(int i=0;i<w+2;i++)\n\t\t\tdelete [] board[i];\n\t\tdelete [] board;\t\n\t}while(w!=0||h!=0);\n\n\treturn 0;\n}\n\nbool bfs(pair<int,int> sg[],int **board){\n\tqueue<pair<int,int>> Q;\n\tpair<int,int> cur;\n\tint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1},c;\n\n\tQ.push(sg[0]);\n\tcur=Q.front();\n\tc=board[cur.first][cur.second];\n\n\twhile(!Q.empty()&&c!=0){\n\t\tcur=Q.front();\n\t\tQ.pop();\n\t\tboard[cur.first][cur.second]=0;\n\n\t\tif(cur==sg[1])\n\t\t\treturn true;\n\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tif(board[cur.first+dx[i]][cur.second+dy[j]]==c)\n\t\t\t\t\tQ.push(make_pair(cur.first+dx[i],cur.second+dy[j]));\n\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,color;\nstring res = \"NG\";\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i)).at(y+j) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && color==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && color==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && color==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && color==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Block *object[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      object[i] = new Block();\n      cin >> object[i]->color;\n      cin >> object[i]->direction;\n      cin >> object[i]->x;\n      cin >> object[i]->y;\n      --object[i]->x; --object[i]->y;\n      object[i]->write(board);\t    \n    }\n    color = board[xs][ys];\n    func(board,xs,ys);\n    cout << res << endl;\n    delete[] *object;\n    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  //DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[101][101];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<0||ty<0||tx>=w||ty>=h) continue;\n\t\tif(board[tx][ty]!=sc|| board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n\n    canGo[x][y] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_x][next_y]) {\n            bool flag = dfs(next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(w + 2, std::vector<int>(h+ 2, 0));\n        std::vector<std::vector<bool>> canGo(w + 2, std::vector<bool>(h + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftX + j][leftY + k] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        /*for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != goal) {\n            ans.push_back(\"NG\");\n            \n            break;\n        }\n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=0;i<102;i++){     //Boardの初期化\n            for(int j=0;j<102;j++)\n                Board[j][i] = 0;\n        }\n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\nbool is_goal = false;\n#define START 20\n#define GOAL 30\n\nvoid DFS(int h,int w,int c){\n\n  if(Array[h][w] = START){\n    DFS(h-1,w,Array[h-1][w]);\n    DFS(h,w+1,Array[h][w+1]);\n    DFS(h+1,w,Array[h+1][w]);\n    DFS(h,w-1,Array[h][w-1]);\n  }\n\n  if(!is_goal){\n\n    if(Array[h][w] == GOAL){\n      is_goal = true;\n      return;\n    }\n\n    if(Array[h][w] != c || Array[h][w] == '.'){\n      return;\n    }\n\n    char tmp=Array[h][w];\n\n    Array[h][w] = '.';\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n  }\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n      Array[Start[0]][Start[1]] = START;\n\n      cin >> Goal[0] >> Goal[1];\n      Array[Goal[0]][Goal[1]] = GOAL;\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n      DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n\n      if(is_goal){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,color;\nstring res = \"NG\";\nvoid write(Matrix &board,int c, int d, int x, int y){\n  int width,length;\n  if(d == 0){ width = 4; length =2; }\n  if(d == 1){ width = 2; length =4; }\n  for(int i=0; i<width; ++i){\n    for(int j=0; j<length; ++j)\n      board[x+i][y+j]=c;\n  }\n}\nvoid func(Matrix &board,int nx,int ny){\n  if(board[nx][ny] == 0){\n    res = \"NG\";\n    return;\n  }\n  if( nx==xg && ny==yg){\n    res = \"OK\";\n    return;\n  }\n  board[nx][ny] = 0;\n  if( 0<=nx-1 && color==board[nx-1][ny])\n    func(board,nx-1,ny);\n  if( 0<=ny-1 && color==board[nx][ny-1])\n    func(board,nx,ny-1);\n  if( nx+1<=w && color==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if( ny+1<=h && color==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  int c,d,x,y;\n  while(cin >> w >> h,w||h){\n    if( w==0 && h==0) return 0;\n    res = \"NG\";\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--; ys--; xg--; yg--;\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> c >> d >> x >> y;\n      --x; --y;\n      write(board,c,d,x,y);\n    }\n    color = board[xs][ys];\n    func(board,xs,ys);\n    cout << res << endl;\n    board.clear();\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\nusing namespace std;\nstruct Block\n{\n\tint color;\n\tint angle;\n\tint x,y;\n};\nint main(void)\n{\n\t\n\t\nRE:\n\tqueue<pair<int,int> > que;\n\tint **board;\n\tint board_mx,board_my;\n\tint start_x,start_y;\n\tint goal_x,goal_y;\n\tint block_num;\n\tBlock *block;\n\t//\n\tscanf(\"%d %d\",&board_mx,&board_my);\n\tif(board_mx==0&&board_my==0)\n\t{\n\t\tgoto END;\n\t}\n\tboard=new int*[board_my];\n\tfor(int f1=0;f1<board_my;f1++)\n\t{\n\t\tboard[f1]=new int[board_mx];\n\t\tfor(int f2=0;f2<board_mx;f2++)\n\t\t{\n\t\t\tboard[f1][f2]=0;\n\t\t}\n\t}\n\tscanf(\"%d %d\",&start_x,&start_y);\n\tscanf(\"%d %d\",&goal_x,&goal_y);\n\tscanf(\"%d\",&block_num);\n\tblock=new Block[block_num];\n\tfor(int f1=0;f1<block_num;f1++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&block[f1].color,&block[f1].angle,&block[f1].x,&block[f1].y);\n\t\tblock[f1].x--;\n\t\tblock[f1].y--;\n\t}\n\t//\n\tfor(int f1=0;f1<block_num;f1++)\n\t{\n\t\t//横\n\t\tif(!block[f1].angle)\n\t\t{\n\t\t\tfor(int f2=0;f2<2;f2++)\n\t\t\t{\n\t\t\t\tfor(int f3=0;f3<4;f3++)\n\t\t\t\t{\n\t\t\t\t\tboard[block[f1].y+f2][block[f1].x+f3]=block[f1].color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//縦\n\t\telse\n\t\t{\n\t\t\tfor(int f2=0;f2<4;f2++)\n\t\t\t{\n\t\t\t\tfor(int f3=0;f3<2;f3++)\n\t\t\t\t{\n\t\t\t\t\tboard[block[f1].y+f2][block[f1].x+f3]=block[f1].color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int f1=0;f1<board_my;f1++)\n\t{\n\t\tfor(int f2=0;f2<board_mx;f2++)\n\t\t{\n\t\t\tprintf(\"%d\",board[f1][f2]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tint st_col=board[start_y-1][start_x-1];\n\tint goal_col=board[goal_y-1][goal_x-1];\n\t//\n\tif(st_col!=goal_col||st_col==0||goal_col==0)\n\t{\n\t\tprintf(\"NG\\n\");\n\t\tgoto RE;\n\t}\n\t//queue<pair<int,int> > que;\n\tque.push(make_pair(start_y,start_x));\n\twhile(!que.empty())\n\t{\n\t\tpair<int,int> buf=que.front();que.pop();\n\t\tif(buf.first==goal_y-1&&buf.second==goal_x-1)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t\tgoto RE;\n\t\t}\n\t\t//printf(\"%d %d\\n\",buf.second,buf.first);\n\t\tboard[buf.first][buf.second]=9;\n\t\tif(buf.first+1<board_my)\n\t\t{\n\t\t\tif(board[buf.first+1][buf.second]==st_col)\n\t\t\t{\n\t\t\t\tque.push(make_pair(buf.first+1,buf.second));\n\t\t\t}\n\t\t}\n\t\tif(buf.first-1>=0)\n\t\t{\n\t\t\tif(board[buf.first-1][buf.second]==st_col)\n\t\t\t{\n\t\t\t\tque.push(make_pair(buf.first-1,buf.second));\n\t\t\t}\n\t\t}\n\t\tif(buf.second+1<board_mx)\n\t\t{\n\t\t\tif(board[buf.first][buf.second+1]==st_col)\n\t\t\t{\n\t\t\t\tque.push(make_pair(buf.first,buf.second+1));\n\t\t\t}\n\t\t}\n\t\tif(buf.second-1>=0){\n\t\t\tif(board[buf.first][buf.second-1]==st_col)\n\t\t\t{\n\t\t\t\tque.push(make_pair(buf.first,buf.second-1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int f1=0;f1<board_my;f1++)\n\t{\n\t\tfor(int f2=0;f2<board_mx;f2++)\n\t\t{\n\t\t\tprintf(\"%d\",board[f1][f2]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tprintf(\"NG\\n\");\nEND:\n\t/*\n\tprintf(\"end\\n\");\n\tfflush(stdin);\n\tgetchar();\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 27;\nconst double EPS = 1e-10;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n#define repD(i, n) for(int i = n; i >= 0; i--)\n\nint block[102][102];\nbool visit[102][102];\n\n\nint main(){\n\tint n, w, h, xs, ys, xg, yg;\n\tint c, d, x, y;\n\twhile(cin >> w >> h && (w || h)){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tfill(&block[0][0], &block[101][101] + 1, -1);\n\t\tmemset(visit, false, sizeof(visit));\n\t\tcin >>n;\n\t\trep(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d){\n\t\t\t\trep(j, 4) rep(k, 2) block[x+k][y+j] = c;\n\t\t\t}else{\n\t\t\t\trep(j, 4) rep(k, 2) block[x+j][y+k] = c;\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> que;\n\t\tque.push(P(xs, ys));\n\t\tvisit[xs][ys] = true;\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, -1, 0, 1};\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\tx = p.first;\n\t\t\ty = p.second;\n\t\t\trep(i, 4){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(!visit[x2][y2] && block[x2][y2] == block[x][y]){\n\t\t\t\t\tvisit[x2][y2] = true;\n\t\t\t\t\tque.push(P(x2, y2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(visit[xg][yg]) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint block[100][100];\nint xs, ys, xg, yg, n, w, h;\n\nbool dfs(int x, int y, int c)\n{\n  if(block[x][y] != c || block[x][y] == 0)\n    return false;\n  if(x == xg && y == yg)\n    return true;\n  bool b = false;\n  block[x][y] = 0;\n  if(x < w - 1)\n    b |= dfs(x + 1, y, c);\n  if(x > 0 && !b)\n    b |= dfs(x - 1, y, c);\n  if(y < h - 1 && !b)\n    b |= dfs(x, y + 1, c);\n  if(y > 0 && !b)\n    b |= dfs(x, y - 1, c);\n  return b;\n}\n\nint main()\n{\n  while(true)\n  {\n    cin >> w >> h;\n    if(!w && !h)\n      break;\n    cin >> xs >> ys\n      >> xg >> yg >> n;\n    xs--; ys--;\n    xg--; yg--;\n    \n    for(int i = 0; i < n; i++)\n    {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      block[x][y] = c;\n      block[x + 1][y] = c;\n      block[x][y + 1] = c;\n      block[x + 1][y + 1] = c;\n      if(d == 0)\n        x += 2;\n      else\n        y += 2;\n      block[x][y] = c;\n      block[x + 1][y] = c;\n      block[x][y + 1] = c;\n      block[x + 1][y + 1] = c;\n    }\n    if(dfs(xs, ys, block[xs][ys]))\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <cassert>\n\nenum class Color {\n\tgoal, white, yellow, green, blue, red, null\n};\nvoid recursive(std::vector<std::vector<Color>> &vector, const int &x, const int &y, const Color c) {\n\tif (0 <= x && x < vector.at(0).size() && 0 <= y && y < vector.size() && vector.at(y).at(x) == c) {\n\t\tvector.at(y).at(x) = Color::goal;\n\t\trecursive(vector, x, y - 1, c); recursive(vector, x + 1, y, c); recursive(vector, x, y + 1, c); recursive(vector, x - 1, y, c);\n\t}\n}\nvoid fill(std::vector<std::vector<Color>> &vector, const int &x, const int &y, const Color &c) {\n\tassert(0 <= x && 0 <= y && x < vector.at(0).size() && y < vector.size());\n\tfor (auto i = 0; i < 2; ++i) {\n\t\tfor (auto j = 0; j < 2; ++j) {\n\t\t\tvector.at(y + i).at(x + j) = c;\n\t\t}\n\t}\n}\nint main() {\n\tint w, h;\n\tstd::cin >> w >> h;\n\twhile (w != 0) {\n\t\tstd::vector<std::vector<Color>> vector(h, std::vector<Color>(w, Color::null));\n\t\tint start_x, start_y;\n\t\tstd::cin >> start_x >> start_y;\n\t\tint goal_x, goal_y;\n\t\tstd::cin >> goal_x >> goal_y;\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tassert(start_x <= w && start_y <= h && goal_x <= w && goal_y <= h);\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\tfill(vector, x - 1, y - 1, Color(c));\n\t\t\tfill(vector, x + 1 - 2 * d, y - 1 + 2 * d, Color(c));\n\t\t}\n\t\trecursive(vector, start_x - 1, start_y - 1, vector.at(start_y).at(start_x));\n\t\tif (vector.at(goal_y - 1).at(goal_x - 1) == Color::goal) {\n\t\t\tstd::cout << \"OK\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"NG\\n\";\n\t\t}\n\t\tstd::cin >> w >> h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  joi\n//\n//  Created by 8595198919 on 14/06/09.\n//  Copyright (c) 2014年 8595198919. All rights reserved.\n//\n\n#include <iostream>\n#include <list>\n#include <stack>\n#include <cstdio>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define Rep(i,n) for(int i = 1;i <= n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\n\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint goal[2];\nint dx[4]={1,0,0,-1};\nint dy[4]={0,1,-1,0};\nint map_[105][105];\nbool went[105][105];\nint c,d,x,y;\n\nbool search(int x,int y){\n    if(map_[x][y]==0)\n        return 0;\n    if(x==xg&&y==yg)\n        return 1;\n    rep(i,4){\n        int xnext = x +dx[i];\n        int ynext = y +dy[i];\n        if(went[xnext][ynext])\n            continue;\n        if(map_[xnext][ynext]==map_[x][y]){\n            went[x][y]=true;\n            if(search(xnext,ynext))\n                return 1;\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n    while(scanf(\"%d %d\",&w,&h),(w!=0&&h!=0)){\n        rep(i,w+5){\n            rep(j,h+5){\n                map_[i][j]=0;\n                went[i][j]=0;\n            }\n        }\n        scanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n        xs++,ys++,xg++,yg++;\n        rep(i,n){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x++,y++;\n            rep(i,(dx[d]+1)*2){\n                rep(j,(dy[d]+1)*2){\n                    map_[x+i][y+j] = c;\n                }\n            }\n        }\n        if(search(xs,ys))\n            cout << \"OK\" << endl;\n        else\n            cout <<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=-1;\n\t\tgoal=-1;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2-1&&y1+h1-1>=y2)||(x2==x1+w1&&y1<=y2+h2-1&&y1+h1-1>=y2)||(y1==y2+h2&&x1<=x2+w2-1&&x1+w1-1>=x2)||(y2==y1+h1&&x1<=x2+w2-1&&x1+w1-1>=x2))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\t\tque.push(*it);\n\t\t}\n\t\tadjacive[survey].clear();\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nclass cordinate\n{\n\npublic:\n\tint x;\n\tint y;\n\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\n\n\t\tint w;\n\t\tint h;\n\t\tcin >> w >> h; \n\t\tif(w == 0 && h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint xs;\n\t\tint ys;\n\t\tcin >> xs >> ys;\n\t\tint xg;\n\t\tint yg;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<vector<int >> vobj;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tvector<int> lineobj;\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tlineobj.push_back(0);\n\n\t\t\t}\n\t\t\tvobj.push_back(lineobj);\n\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 2][y] = c;\n\t\t\t\tvobj[x + 3][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 2][y + 1] = c;\n\t\t\t\tvobj[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x][y + 2] = c;\n\t\t\t\tvobj[x][y + 3] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 2] = c;\n\t\t\t\tvobj[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\n\t\tint startColor;\n\t\tstartColor = vobj[xs - 1][ys - 1];\n\t\tqueue<cordinate> que;\n\n\t\tcordinate obj;\n\t\tobj.x = xs - 1;\n\t\tobj.y = ys - 1;\n\t\tque.push(obj);\n\t\tbool flag = false;\n\t\twhile(1)\n\t\t{\n\t\t\tif(startColor == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcordinate buf;\n\t\t\tbuf = que.front();\n\t\t\tque.pop();\n\n\t\t\tint bx;\n\t\t\tint by;\n\t\t\tbx = buf.x;\n\t\t\tby = buf.y;\n\t\t\tif(bx == xg - 1 && by == yg - 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif(bx + dx[i] >= 0 && bx + dx[i] <= h - 1)\n\t\t\t\t{\n\t\t\t\t\tif(by + dy[i] >= 0 && by + dy[i] <= w - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vobj[bx + dx[i]][by + dy[i]] == startColor)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcordinate newObject;\n\t\t\t\t\t\t\tnewObject.x = bx + dx[i];\n\t\t\t\t\t\t\tnewObject.y = by + dy[i];\n\t\t\t\t\t\t\tque.push(newObject);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvobj[bx][by] = -1;\n\n\t\t\tif(que.size() == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(flag == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t\t/*for(int i = 0; i < w - 1; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < h - 1; j++)\n\t\t\t{\n\t\t\t\tcout << vobj[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}  */\n\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nclass node{\npublic:\n\tint x,y;\n\tvoid set(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tbool check(int w,int h){\n\t\tif(x>=0&&y>=0){\n\t\t\tif(x<=w&&y<=h) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nint main(){\n\tint i,j;\n\twhile(1){\n\t\tint w,h;\n\t\tint xs,ys,xg,yg,n,c,dir,x,y;\n\t\tint color[101][101];\n\t\tint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\t\tbool visited[101][101];\n\t\tqueue<node> q;\n\t\tnode a;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\n\t\twhile(n--){\n\t\t\tscanf(\"%d%d%d%d\",&c,&dir,&x,&y);\n\t\t\tif(dir==0){\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+j][y+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+i][y+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta.set(xs,ys);\n\t\tq.push(a);\n\t\tvisited[a.x][a.y]=true;\n\t\twhile(!q.empty()){\n\t\t\ta = q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\ta.x += dx[i];\n\t\t\t\ta.y += dy[i];\n\t\t\t\tif(!a.check(w,h)&&(color[xs][ys]==color[a.x][a.y])&&!visited[a.x][a.y]){\n\t\t\t\t\tq.push(a);\n\t\t\t\t\tvisited[a.x][a.y] = true;\n\t\t\t\t\tif(a.x==xg&&a.y==yg) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(visited[xg][yg]) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t\tfor(i=0;i<101;i++){\n\t\t\tfor(j=0;j<101;j++) visited[i][j] = false;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h,w;\nint maps[100][100];\nint color;\nint gy,gx,sy,sx;\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\nint muki[2][2]={\n  {2,4},\n  {4,2}\n};\n    \n  \n\nbool dfs(int y,int x);\n\nint main(){\n  int n;\n  int c,d,y,x;\n  while(cin >> w >> h,w | h){\n    memset(maps,-1,sizeof(maps));\n    cin >> sx >> sy >> gx >> gy;\n    sx--;sy--;gx--;gy--;\n    cin >> n;\n    for(int i = 0; i < n; ++i){\n      cin >> c >> d >> x >> y;\n      y--;x--;\n      for(int j = 0; j < muki[d][0]; j++){\n\tfor(int k = 0;k < muki[d][1]; k++){\n\t  maps[y + j][x + k] = c;\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j = 0; j< w ; j++){\n\tif(i==sy && j == sx)color = maps[sy][sx];\n      }\n    }\n    /*\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tprintf(\"%3d\",maps[i][j]);\n      }\n      cout<<endl;\n    }*/\n\n    if(dfs(sy,sx))cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    \n    /*\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tprintf(\"%3d\",maps[i][j]);\n      }\n      cout<<endl;\n      }*/\n\n  }\n}\n \nbool dfs(int y,int x){\n  maps[y][x] = -1;\n  if(gy==y && gx==x){\n    return true;\n  }\n  bool b = false;\n  for(int i=0;i<4;i++){\n    int vy=y+dy[i];\n    int vx=x+dx[i];\n    if(vy >= 0 && vy < h && vx >= 0 && vx < w && maps[vy][vx] != -1 && maps[vy][vx] == color){\n      b = b | dfs(vy,vx);\n    }\n  }\n  return b;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\n\nint DFS(int Y,int X,int c){\n  int cnt = 0;\n  if(F[Y][X] != c){\n    return 0;\n  }\n\n  F[Y][X] = -1;\n  cnt += DFS(Y-1,X  ,c);\n  cnt += DFS(Y  ,X+1,c);\n  cnt += DFS(Y+1,X  ,c);\n  cnt += DFS(Y  ,X-1,c);\n  return cnt;\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<102;i++){\n        for(int j=0;j<102;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  if(DFS(xs,ys,F[xs][ys])){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    for(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j]=0;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  if(F[xs][ys] == 0){\n    cout << \"NG\" << endl;\n  } else {\n    DFS(xs,ys,F[xs][ys]);\n  \n    if(F[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" <<endl;\n    }\n  }\n\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid setblock(int c, int d, int x, int y){\n  if(d==0){\n    for(int i=0;i<4;i++){\n      F[y][x+i]=c;\n      F[y+1][x+i]=c;\n    }\n  }else{\n    for(int i=0;i<4;i++){\n      F[y+i][x]=c;\n      F[y+i][x+1]=c;\n    }\n  }\n\n}\n\nvoid DFS(int Y, int X, int c){\n  if(F[Y][X]!=c)\n    return;\n\n  F[Y][X] = 6;\n\n  DFS(Y-1, X  ,c);\n  DFS(Y  , X+1,c);\n  DFS(Y+1, X  ,c);\n  DFS(Y  , X-1,c);\n}\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(true){\n  cin >> w >> h;\n  if(w==0&&h==0){\n    break;\n  }\n  cin >> xs >> ys;\n  cin >> xg >> yg;\n  cin >> n;\n  for(int i=0; i<n; i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    setblock(c,d,x,y);\n  }\n\n}\n\n  int S=F[ys][xs];\n  DFS(xs,ys,F[ys][xs]);\n  if(F[ys][xs]==6){\n    cout << \"OK\" << endl;\n  }else{\n    cout << \"NO\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<int,int> P;\nP S,G;\nint w,h;\nint maze[MAX][MAX];\nint color;\n\nbool check()\n{\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tint nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G)\n\t\t\treturn true;\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tint n,c,d,x,y;\n\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(check())\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n/*\n\t\trep(i,y){\n\t\t\trep(j,x)\n\t\t\t\tprintf(\"%2d\", maze[i][j]);\n\t\t\tcout << endl;\n\t\t}\n\n*/\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, j) FOR(i, 0, j)\n#define rep2(i, k) for(int i = 1; i <= k; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define INF (1 << 30)\n\nusing namespace std;\n \nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint field[105][105], use[105][105];\nint h, w, sx, sy, gx, gy, n;\nint scol;\n\nvoid make_map(int x,int y,int chk,int color){\n  if(chk == 0){\n    for(int i=y;i<y+2;i++){\n      for(int j=x;j<x+4;j++) field[i][j] = color;\n    }\n  }\n  else {\n    for(int i=y;i<y+4;i++){\n      for(int j=x;j<x+2;j++) field[i][j] = color;\n    }\n  }\n}\n\nbool dfs(int x,int y){\n  use[y][x] = true;\n  if(x == gx && y == gy) return true;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h && field[ny][nx] == field[sy][sx] && !use[ny][nx]) dfs(nx,ny);\n  }\n  return use[gy][gx];\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(use, false, sizeof(use));\n\t\tint scol = 0;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\t--sx; --sy; --gx; --gy;\n\t\tcin >> n;\n\t\twhile(n--){\n     \t\tint c,d,x,y; cin >> c >> d >> x >> y; --x; --y;\n      \t\tmake_map(x,y,d,c);\n    \t}\n\t\trep(i, h + 1){\n\t\t\trep(j, w + 1) cout << field[i][j] << \" \";\n\t\t\tputs(\"\");\n  \t\t}\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h;\nint gx,gy;\nint iro;\nint mas[101][101];\nint dy[4]={0,1,-1,0};\nint dx[4]={1,0,0,-1};\nint flag;\nvoid solve(int x,int y){\n  if(iro==0) return;\n  if(x==gx-1 && y==gy-1){\n    flag=1;\n    return;\n  }\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if(0<=ny && 0<=nx && ny<h && nx<w && mas[ny][nx]==iro){\n      mas[ny][nx]=0;\n      solve(nx,ny);\n    }\n  }\n  return;\n}\nint main(){\n  int n;\n  int sx,sy;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tmas[i][j]=0;\n      }\n    }\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      if(d==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[y-1+i][x-1+j]=c;\n\t  }\n\t}\n      }else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[y-1+i][x-1+j]=c;\n\t  }\n\t}\n      }\n    }\n    //for(int i=0;i<h;i++){\n    //for(int j=0;j<w;j++){\n    //\tcout<<mas[i][j];\n    //}\n    //cout<<endl;\n    //}\n\n    iro=mas[sy-1][sx-1];\n    //cout<<iro<<endl;\n    flag=0;\n    solve(sx-1,sy-1);\n    if(flag){\n      cout<<\"OK\"<<endl;\n    }else{\n      cout<<\"NG\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nbool N[102][102];\nint map[102][102],R,ga,gb,w,h;\nbool block(int ,int);\nint main()\n{\n\tint i,a,n,b,c,d,X=0,Y=0,x,y;\n\tcin>>w>>h;\n\twhile(w!=0||h!=0){\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(N,false,sizeof(N));\n\t\tcin>>X>>Y;\n\t\tcin>>ga>>gb;\n\t\tcin>>n;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d){\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y+2][x]=c;\n\t\t\t\tmap[y+3][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+2][x+1]=c;\n\t\t\t\tmap[y+3][x+1]=c;\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap[y][x]=c;\n\t\t\t\tmap[y+1][x+1]=c;\n\t\t\t\tmap[y+1][x+2]=c;\n\t\t\t\tmap[y+1][x+3]=c;\n\t\t\t\tmap[y+1][x]=c;\n\t\t\t\tmap[y][x+1]=c;\n\t\t\t\tmap[y][x+2]=c;\n\t\t\t\tmap[y][x+3]=c;\n\n\t\t\t}\n\t\t}\n\t\tR=map[Y][X];\n\t\tif(R==map[gb][ga]&&R!=0){\n\t\t\tif(block(Y,X)) cout<<\"OK\"<<endl;\n\t\t        else cout<<\"NG\"<<endl;\n\t\t}\n\t\telse cout<<\"NG\"<<endl;\n\t\t//for(i=0;i<h;i++){\n\t\t\t//for(j=0;j<w;j++){\n\t\t\t//\tcout<<map[i][j];\n\t\t\t//}\n\t\t\t\t\n\t//\t\tcout<<endl;\n\t\t//}\n\t\tcin>>w>>h;\n\t}\n\treturn 0;\n}\nbool block(int b,int a)\n{\n\t//if(f==1) return 1;\n\tN[b][a]=true;\n\tif(ga==a&&gb==b) return 1;\n\tif(a+1!=w){\n\t\tif(map[b][a+1]==R&&N[b][a+1]==false) return block(b,a+1);} //???\n\tif(b+1!=h){\n\t\tif(map[b+1][a]==R&&N[b+1][a]==false) return block(b+1,a);} //???\n\tif(a-1!=-1){\n\t\tif(map[b][a-1]==R&&N[b][a-1]==false) return block(b,a-1);} //???\n\tif(b-1!=-1){\n\t\tif(map[b-1][a]==R&&N[b-1][a]==false) return block(b-1,a);} //???\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n//#include<windows.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k,l,m;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\tint maps=0;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\telse\n\t\t\t\t\t\tmaps++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\t\n/*\n\t\t\t\tfor(m=0;m<h;m++)\n\t\t\t\t{\n\t\t\t\t\tfor(l=0;l<w;l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d \",map[l][m]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"%dツ行\\n\",l);\n\t\t\t\t}\n\t\t\t\tgetchar();\n\t\t\t\tsystem(\"cls\");\n*/\n\t\t\t\t\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t\tmaps--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"migi\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"hidari\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i+1][j]!=sign && */map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue1\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(/*map[i-1][j]!=sign && */map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"sita2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t\tmaps--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n//\t\t\t\t\tprintf(\"ue2\\n\");\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tmaps--;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]!=sign && map[i-1][j]!=sign && map[i][j-1]!=sign && maps==0)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\n\t\t\t\t\tfor(m=0;m<h;m++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(l=0;l<w;l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((map[m][l]==sign && map[m][l+1]==7) || (map[m][l]==sign && map[m-1][l]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ti=m;\n\t\t\t\t\t\t\t\tj=l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\");\n\t\t}\n\t}\n}\n/*\n20 20 \n1 1\n2 7\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] )\n{\n\tcame[ y ][ x ] = false ;\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h )\n\t{\n\t\tif( w == h && w == 0 )\n\t\treturn 0 ;\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint a[1000][1000];\nint xg,yg,w,h,ans;\n\nvoid solve(int xs,int ys){\n\n  if(xs == xg && ys == yg){\n    ans = 1;\n    return;\n  }\n\n  if(a[ys][xs] != a[yg][xg]) return;\n  a[ys][xs] = 100;\n\n  if(xs+1 <= w) solve(xs+1,ys);\n  if(ys+1 <= h) solve(xs,ys+1);\n  if(xs-1 > 0) solve(xs-1,ys);\n  if(ys-1 > 0) solve(xs,ys-1);\n\n}\n\nint main(){\n\n  int xs,ys;\n  int n;\n\n  while(1){\n    cin >> w >> h;\n    if(!w && !h) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n\n    memset(a,0,sizeof(a));\n    ans = 0;\n\n    int c,d,x,y;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n\tfor(int j=0;j<4;j++){\n\t  a[y][x+j] = c;\n\t  a[y+1][x+j] = c;\n\t}\n      }\n\n      else if(d == 1){\n\tfor(int j=0;j<4;j++){\n\t  a[y+j][x] = c;\n\t  a[y+j][x+1] =c ;\n\t}\n      }\n    }\n\n    solve(xs,ys);\n\n    if(ans == 1) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(block[xi][yi] == 0) return;\n\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1, yi);\n        solve(xi, yi-1);\n        solve(xi+1, yi);\n        solve(xi, yi+1);\n    }\n    block[xi][yi] = 0;\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(int)*w*h);\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            //cout << x << \",\"<< y << endl;\n            if(d==1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2015/03/25 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nvoid DFS(int F[102][102], int y, int x, int C)\n{\n\tif(F[y][x]!=C)\n\t\treturn;\n\n\tF[y][x] = 6;\n\n\tDFS(F, y-1, x, C);\n\tDFS(F, y, x+1, C);\n\tDFS(F, y+1, x, C);\n\tDFS(F, y, x-1, C);\n}\n\nint main()\n{\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\n\t\tint xs, ys;\n\t\tcin >> xs >> ys;\n\n\t\tint xg, yg;\n\t\tcin >> xg >> yg;\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tint F[102][102] = {};\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\n\t\t\tF[y][x] = F[y][x+1] = F[y+1][x] = F[y+1][x+1] = c;\n\n\t\t\tif(d==0){\n\t\t\t\tF[y][x+2] = F[y][x+3] = F[y+1][x+2] = F[y+1][x+3] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tF[y+2][x] = F[y+2][x+1] = F[y+3][x] = F[y+3][x+1] = c;\n\t\t\t}\n\t\t}\n\n//\t\tfor(int y=0; y<=h; y++){\n//\t\t\tfor(int x=0; x<=w; x++){\n//\t\t\t\tcout << F[y][x];\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\n\t\tif(F[ys][xs]==0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tDFS(F, ys, xs, F[ys][xs]);\n\n\t\tif(F[yg][xg]==6){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nbool isMaze;\n\nvoid dfs(int blocks[105][105], int target, int x, int y, int gx, int gy){\n    if(x == gx && y == gy){\n        isMaze = true;\n        return;\n    }\n    if(blocks[y][x] == target){\n        blocks[y][x] = 0;\n    }else{\n        return;\n    }\n    dfs(blocks, target, x + 1, y, gx, gy);\n    dfs(blocks, target, x - 1, y, gx, gy);\n    dfs(blocks, target, x, y + 1, gx, gy);\n    dfs(blocks, target, x, y - 1, gx, gy);\n}\n\nint main(){\n    int w, h, xs, ys, xg, yg, n;\n    while(cin >> w >> h, w||h){\n        int blocks[105][105] = {0};\n        cin >> xs >> ys >> xg >> yg >> n;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                rep(j,2) rep(k,4) blocks[y + j][x + k] = c;\n            }else{\n                rep(j,4) rep(k,2) blocks[y + j][x + k] = c;\n            }\n        }\n        isMaze = false;\n        if(blocks[ys][xs] != 0) dfs(blocks, blocks[ys][xs], xs, ys, xg, yg);\n\n        if(isMaze) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h;\nint maps[101][101];\nint solve(int xs,int ys);\nint main(){\n  int tate[2] = {2,4};\n  int yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(w==0 && h==0)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  maps[j-1][k-1] = c[i];\n\t}\n      }\n    }\n    /* for(int i=0;i<h;i++){\n       for(int j=0;j<w;j++){\n       cout << maps[i][j];\n       }\n       cout << endl;\n       }*///マップ確認用\n    if(solve(xs-1,ys-1))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int xs,int ys){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || maps[xs][ys] == 0){\n    return 0;\n  }\n  else if(maps[xs][ys] == maps[xg-1][yg-1]){\n    return 1;\n  }\n  if(maps[xs-1][ys] == maps[xs][ys]){\n    return solve(xs-1,ys);\n  }\n  if(maps[xs][ys-1] == maps[xs][ys]){\n    return solve(xs,ys-1);\n  }\n  if(maps[xs+1][ys] == maps[xs][ys]){\n    return solve(xs+1,ys);\n  }\n  if(maps[xs][ys+1] == maps[xs][ys]){\n    return solve(xs,ys+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int w,h;\n  int xs,ys,xg,yg;\n  int n;\n  int c,d,x,y;\n  int grid[101][101];\n  bool visit[101][101];\n\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h)break;\n\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++){\n\tgrid[i][j] = 0;\n\tvisit[i][j] = false;\n      }\n    cin >> xs >> ys >> xg >> yg;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d){\n\tfor(int j=0;j<4;j++)\n\t  for(int k=0;k<2;k++)grid[y+j][x+k] = c;\n      }else{\n\tfor(int j=0;j<2;j++)\n\t  for(int k=0;k<4;k++)grid[y+j][x+k] = c;\n      }\n    }\n\n    int color = grid[ys][xs];    \n    queue<P> q;\n    if(color){\n      q.push(P(ys,xs));\n      visit[ys][xs] = true;\n      while(q.size()){\n\tP p = q.front();q.pop();\n\ty = p.first;\n\tx = p.second;\n\t\n\tint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\tfor(int i=0;i<4;i++){\n\t  int sx = x+dx[i],sy = y+dy[i];\n\t  if(sx<=0 || sy<=0 || w<=sx || h<=sy)continue;\n\t  if(visit[sy][sx] || grid[sy][sx]!=color)continue;\n\t  q.push(P(sy,sx));\n\t  visit[sy][sx] = true;\n\t}\n      }\n      if(visit[yg][xg])cout << \"OK\\n\";\n      else cout << \"NG\\n\";\n    }else{\n      cout << \"NG\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=0;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n  int goal_x,goal_y;\n  int n;\n  int c,d,x,y;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        b.mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint a;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint board[105][105];\n\nvoid dfs(int x , int y , int w , int h , int xg , int yg , int c){\n\tif(x==xg&&y==yg) {\n\t\ta=1;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=c || board[tx][ty]==0 || a ) continue;\n\t\tdfs( tx,ty,w,h,xg,yg,c);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\ta=0;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs( xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( a ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,c,d,x,y,nok,sc;\nint fld[101][101];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||nok==1||fx<0||fx>w||fy<0||fy>h)return;\n    if(fx==xg-1&&fy==yg-1){\n        if(sc==fld[fy][fx])nok=1;\n    }\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        nok=0;\n        fill(fld[0],fld[0]+101,0);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[ys][xs];\n        dfs(0,0);\n        if(nok==1)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c || c != 0)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][xs]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nvoid dfs(int a[][101] ,int x , int y , int w , int h , int xg , int yg , int sc){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(a[tx][ty]!=sc || a[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( a,tx,ty,w,h,xg,yg,sc);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tint board[101][101]={0};\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs(board , xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint x[MAX_N][MAX_N], y[MAX_N][MAX_N];\nint H, W, N, X, Y, C, D, SX, SY, GX, GY;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) { break; }\n\t\tcin >> SX >> SY >> GX >> GY >> N;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tx[i][j] = 0; y[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> C >> D >> X >> Y;\n\t\t\tif (D == 0) {\n\t\t\t\tfor (int j = Y; j < Y + 2; j++) {\n\t\t\t\t\tfor (int k = X; k < X + 4; k++) {\n\t\t\t\t\t\tx[j][k] = C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (D == 1) {\n\t\t\t\tfor (int j = Y; j < Y + 4; j++) {\n\t\t\t\t\tfor (int k = X; k < X + 2; k++) {\n\t\t\t\t\t\tx[j][k] = C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>Q; Q.push(make_pair(SY, SX)); y[SY][SX] = 1;\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint a1 = pa.first; int a2 = pa.second;\n\t\t\tif (y[a1 - 1][a2] == 0 && a1 - 1 >= 1 && x[a1][a2] == x[a1 - 1][a2]) { y[a1 - 1][a2] = 1; Q.push(make_pair(a1 - 1, a2)); }\n\t\t\tif (y[a1 + 1][a2] == 0 && a1 + 1 <= H && x[a1][a2] == x[a1 + 1][a2]) { y[a1 + 1][a2] = 1; Q.push(make_pair(a1 + 1, a2)); }\n\t\t\tif (y[a1][a2 - 1] == 0 && a2 - 1 >= 1 && x[a1][a2] == x[a1][a2 - 1]) { y[a1][a2 - 1] = 1; Q.push(make_pair(a1, a2 - 1)); }\n\t\t\tif (y[a1][a2 + 1] == 0 && a2 + 1 <= W && x[a1][a2] == x[a1][a2 + 1]) { y[a1][a2 + 1] = 1; Q.push(make_pair(a1, a2 + 1)); }\n\t\t}\n\t\tif (y[GY][GX] == 1) { cout << \"OK\" << endl; }\n\t\tif (y[GY][GX] == 0) { cout << \"NG\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint needleX[4] = {-1, 0, 1, 0};\nint needleY[4] = {0, 1, 0, -1};\n\nbool dfs(int x, int y, int goalx, int goaly,vector<vector<int> >& canGo){\n\n    //??´??????????????????????????????true\n    if(x == goalx && y == goaly){ return true; }\n\n    //???????????°????????¢?´¢???????????????\n    canGo[x][y] = false;\n\n    //???????????????????????¢?´¢\n    for(int i = 0; i < 4; i++){\n        int nextx = x + needleX[i];\n        int nexty = y + needleY[i];\n\n        //?????????????????????\n        if(canGo[nextx][nexty]){\n            bool flag = dfs(nextx, nexty, goalx, goaly, canGo);\n            if(flag){\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\n\nint block(int w, int h){\n\n    //0 0??§??????\n    if(w == 0 && h == 0){return 0;}\n\n    //??????????????±??\\???\n    int xs, ys, xg, yg;\n    int n;\n    int c, d, inputX, inputY;\n    vector<vector<int> > canGo(h + 2, vector<int>(w + 2, 0));\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n\n    //??????????????????\n    for(int i = 1; i <= n; i++){\n        cin >> c >> d >> inputX >> inputY;\n        if(d == 0){\n            for(int j = 0; j < 4; j++){\n                for(int k = 0; k < 2; k++){\n                    canGo[inputY + k][inputX + j] = c;\n                }\n            }\n        }else{\n            for(int j = 0; j < 2; j++){\n                for(int k = 0; k < 4; k++){\n                    canGo[inputY + k][inputX + j] = c;\n                }\n            }\n        }   \n    }\n    /*??????????????¨???\n    cout << canGo[ys][xs] << endl;\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            cout << canGo[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n    */\n\n    //????????????bool????????¨?????????\n    int load = canGo[ys][xs];\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            if(canGo[i][j] == load){\n                canGo[i][j] = 1;\n            }else{\n                canGo[i][j] = 0;\n            }\n        }\n    }\n    \n    // ??±???????????¢?´¢????????????????????????\n    bool result = dfs(xs,ys,xg,yg,canGo);\n    if(result){\n        return 1;\n    }else{\n        return 2;\n    }\n\n    \n}\n\nint main(void){\n    int i = 0;\n    int array[30];\n    int w, h;\n    while(1){\n        cin >> w >> h;\n        array[i] = block(w, h);\n        if(array[i] == 0){break;}\n        i++;\n    }\n    for(int j = 0; j < i; j++){\n        if(array[j] == 1){cout << \"OK\" << endl;}\n        else {cout << \"NG\" << endl;}\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include----------------------------------------------------------------------------------------------------------------------\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<cctype>\n#include<string>\n#include<vector>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<algorithm>\n#include<memory>\n\n\n//using namespace--------------------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//define,const-----------------------------------------------------------------------------------------------------------------\n#define rep(i, n) for(int i = 0; i < n; i++)\nconst int INF = 1 << 25;\n#define MAX 1000\n\n//global-----------------------------------------------------------------------------------------------------------------------\nint board_range_w, board_range_h, start_x, start_y, goal_x, goal_y;\nint color[MAX][MAX];\nbool dp[MAX][MAX];\n\n//function---------------------------------------------------------------------------------------------------------------------\nbool solve(int x, int y){\n\tif ( x == goal_x && y == goal_y )\n\t\treturn true;\n\tif ( !color[x][y] )\n\t\treturn false;\n\tif ( color[x][y] == color[x + 1][y] )\n\t\tif ( solve(x + 1, y) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y + 1] )\n\t\tif ( solve(x, y + 1) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x][y - 1] )\n\t\tif ( solve(x, y - 1) )\n\t\t\treturn true;\n\tif ( color[x][y] == color[x - 1][y] )\n\t\tif ( solve(x - 1, y) )\n\t\t\treturn true;\n\treturn false;\n}\n\nint main(){\n\twhile ( scanf(\"%d %d\", &board_range_w, &board_range_h) ) {\n\t\tif ( board_range_w == 0 && board_range_h == 0 )\n\t\t\treturn 0;\n\t\tfor ( int i = 0; i < 1000; i++ ){\n\t\t\tfor ( int j = 0; j < 1000; j++ ){\n\t\t\t\tcolor[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d\", &start_x, &start_y);\n\t\tscanf(\"%d %d\", &goal_x, &goal_y);\n\t\tint block;\n\t\tscanf(\"%d\", &block);\n\t\tfor ( int i = 0; i < block; i++ ){\n\t\t\tint block_color, block_quarter, block_start_x, block_start_y;\n\t\t\tscanf(\"%d %d %d %d\", &block_color, &block_quarter, &block_start_x, &block_start_y);\n\t\t\tcolor[block_start_x + 1][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x][block_start_y + 1] = block_color;\n\t\t\tcolor[block_start_x + 1][block_start_y] = block_color;\n\t\t\tcolor[block_start_x][block_start_y] = block_color;\n\t\t\tif ( !block_quarter ){\n\t\t\t\tcolor[block_start_x + 2][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 2][block_start_y] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y + 1] = block_color;\n\t\t\t\tcolor[block_start_x + 3][block_start_y] = block_color;\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\n\t\t\telse{\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 3] = block_color;\n\t\t\t\tcolor[block_start_x + 1][block_start_y + 2] = block_color;\n\t\t\t\tcolor[block_start_x][block_start_y + 2] = block_color;\n\t\t\t}\n\t\t}\n\t\tif ( solve(start_x, start_y) ) \n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<queue>\nusing namespace std;\nint field[128][128];\nbool memo[128][128];\nint w,h;\nvoid func(int x,int y,int c){\n\tif(x < 1 || y < 1 || x > w || y > h)return;\n\tif(memo[y][x])return ;\n\tif(field[y][x] != c)return ;\n\tmemo[y][x] = 1;\n\tfunc(x-1,y,c);\n\tfunc(x+1,y,c);\n\tfunc(x,y+1,c);\n\tfunc(x,y-1,c);\n\treturn ;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w,h){\n\t\tint xs,ys,xg,yg,n;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = x; j < x + 4; j++){\n\t\t\t\t\tfield[y][j] = c;\n\t\t\t\t\tfield[y+1][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < y + 4; j++){\n\t\t\t\t\tfield[j][x] = c;\n\t\t\t\t\tfield[j][x+1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunc(xs,ys,field[ys][xs]);\n\t\tcout << (memo[yg][xg]?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(void)\n{\n\tint w,h;\n\tint map[101][101];\n\tint st[2],go[2];\n\tint i,j,k;\n\tint num;\n\tint b_c,b_ang,b_x,b_y;\n\tint sign;\n\tint ans;\n\t\n\tfor(;;)\n\t{\n\t\tans=0;\n\t\t\n\t\tfor(i=0;i<100;i++)\n\t\t{\n\t\t\tfor(j=0;j<100;j++)\n\t\t\t\tmap[i][j]=0;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h);\n\t\t\n\t\tif(w==0 && h==0)\n\t\t\tbreak;\n\t\t\n\t\tscanf(\"%d%d%d%d\",&st[0],&st[1],&go[0],&go[1]);\n\t\t\n\t\t\n\t\tscanf(\"%d\",&num);\n\t\t\n\t\tfor(i=0;i<num;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&b_c,&b_ang,&b_x,&b_y);\n\t\t\t\n\t\t\tif(b_ang==0)\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+j][b_y+k]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=0;j<4;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<2;k++)\n\t\t\t\t\t\tmap[b_x+k][b_y+j]=b_c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(map[st[0]][st[1]]==0 || map[go[0]][go[1]]==0)\n\t\t\tprintf(\"NG\\n\");\n\t\telse\n\t\t{\n\t\t\tsign=map[st[0]][st[1]];\n\t\t\t\n\t\t\tfor(i=0;i<w;i++)\n\t\t\t{\n\t\t\t\tfor(j=0;j<h;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][j]!=sign)\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmap[st[0]][st[1]]=-1;\n\t\t\tmap[go[0]][go[1]]=-2;\n\t\t\t\n\t\t\tfor(i=st[0],j=st[1];;)\n\t\t\t{\n\t\t\t\tif(map[i+1][j]==-2 || map[i][j+1]==-2 || map[i-1][j]==-2 || map[i][j-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=0 && map[i][j-1]!=0 && map[i+1][j]!=0 && map[i][j+1]!=0)\n\t\t\t\t{\n\t\t\t\t\tif(map[i+1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j+1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i-1][j]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j-1]==sign)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j+1]==sign)//ツ可コ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]!=sign && map[i][j-1]==sign)//ツ湘」\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==sign/* && map[i][j-1]!=sign*/)//ツ右\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse if(map[i-1][j]==sign/* && map[i][j+1]!=sign*/)//ツ債カ\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=7;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse if(map[i+1][j]==7 && map[i][j+1]==7 && map[i-1][j]==7 && map[i][j-1]==7)\n\t\t\t\t{\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==1)\n\t\t\t\tprintf(\"OK\\n\");\n\t\t\telse if(ans==2)\n\t\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = -1;\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    if(C[xs][ys]==0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n\n    meiro(xs,ys,C[xs][ys]);\n\n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nint w, h;\nint xs, ys, xg, yg, n, c, d, x, y;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid put_b(int a[][101]) {\n  int X, Y;\n  if(d == 0) X = 4, Y = 2;\n  else X = 2, Y = 4 ;\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j < X; j++)\n      a[y + i][x + j] = c;\n}\n\nbool bfs(int a[][101]) {\n  int cs = a[ys][xs];\n  if(cs != a[yg][xg]) return false;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while(que.size()) {\n    P p = que.front();\n    que.pop();\n    if(p.first == xg && p.second == yg) return true;\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second +dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && a[ny][nx] == cs) \n\tque.push(P(nx, ny));\n    }\n  }\n  return false;\n}\nint main() {\n  while(cin >> w >> h, w != 0 || h != 0) {\n    int a[101][101] = {};\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n  \n    while(n--) {\n      cin >> c >> d >> x >> y;\n      put_b(a);\n    }\n    /*\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++)\n\tcout << a[i][j];\n      cout << endl;\n      }*/\n    if(bfs(a) == true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint dx[] = {0, 1, 0, 1}, dy[] = {0, 0, 1, 1};\nstruct P{ int x, y; };\nint main()\n{\n\tint w, h;\n\twhile(cin >> w >> h && (w || h))\n\t{\n\t\tvector<vint> field(w, vint(h, 0));\n\t\tP s, g;\n\t\tcin >> s.x >> s.y >> g.x >> g.y;\n\t\ts.x--, s.y--, g.x--, g.y--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i, n)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y; x--, y--;\n\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i]][y + dy[i]] = c;\n\t\t\trep(i, 4)\n\t\t\t\tfield[x + dx[i] + 2 * !d][y + dy[i] + 2 * d] = c;\n\t\t}\n\n\t\t\n\t\tint c = field[s.x][s.y];\n\t\tif(!c || !field[g.x][g.y] || field[s.x][s.y] != field[g.x][g.y])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue<P> que;\n\t\tfor(que.push(s); !que.empty(); que.pop())\n\t\t{\n\t\t\tP p = que.front();\n\n\t\t\tint ddx[] = {1, -1, 0, 0}, ddy[] = {0, 0, -1, 1};\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tint nx = p.x + ddx[i], ny = p.y + ddy[i];\n\t\t\t\t\n\t\t\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h && field[nx][ny] == c)\n\t\t\t\t{\n\t\t\t\t\tfield[nx][ny] = -1;\n\t\t\t\t\tP next; next.x = nx, next.y = ny;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (field[g.x][g.y] == -1? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nint Block(int,int);\nint c,d,x,y,xg,yg,w,h,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(Block(xs,ys))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nint Block(int X,int Y)\n{\n\t\n\t//printf(\"%d\",M);\n\tprintf(\"%d %d\\n\",X,Y);\n\tif(X == xg && Y == yg)\n\t\treturn 1;\n\tif(MAP[Y][X] != M || MF[Y][X] == 1 || X < 1 || Y < 1 || X > w || Y > h) return 0;\n\tMF[Y][X] = 1;\n\treturn Block(X,Y-1) || Block(X,Y+1) || Block(X-1,Y) || Block(X+1,Y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define rep2(i, n) for(int i = 1; i <= n; ++i)\n#define INF 0\n#define MAX 102\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n \nint field[101][101];\nint h, w, sx, sy, gx, gy, n;\nint col, dire, x, y;\nint scol;\n\nbool dfs(int nx, int ny) {\n\tif(nx == gx && ny == gy) return true;\n\tfield[nx][ny] = -1;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tint nex = nx + dx[i];\n\t\tint ney = ny + dy[i];\n\t\tif(0 < nex && nex <= w && 0 < ney && ney <= h && scol == field[nex][ney]) {\n\t\t\tif(dfs(nex, ney)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(1) {\n\t\tscol = INF;\n\t\tcin >> h >> w;\n\t\tfor(int i = 0; i <= h+1; ++i) {\n\t\t\tfor(int j = 0; j <= w+1; ++j) {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif(h == 0 && w == 0) break;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(k, n) {\n\t\t\tcin >> col >> dire >> x >> y;\n\t\t\tif(dire == 1) {\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\tfor(int j = 0; j < 2; ++j) field[x+j][y+i] = col;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\t\t\tfor(int j = 0; j < 4; ++j) field[x+j][y+i] = col;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscol = field[sx][sy];\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    /*for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}*/\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct block{\n  int x, y, c;\n  bool var;//0テ」ツ?ョテヲツ卍?*4, 1テ」ツ?ョテヲツ卍?*2\n  block(int c_, bool var_, int x_, int y_):\n    c(c_), var(var_), x(x_), y(y_){\n  };\n  int GetWidth(){\n    if(var)return 2;\n    else return 4;\n  }\n  int GetHight(){\n    if(var)return 4;\n    else return 2;\n  }\n};\n\nvoid paint(vector<string>& grid, block b){\n  for (int i = b.y; i < b.y + b.GetHight(); i++) {\n    for (int j = b.x; j < b.x + b.GetWidth(); j++) {\n      grid[i][j] = b.c + '0';\n    }\n  }\n}\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nint w, h;\n\nbool range(int x, int y){\n  return (0 <= x && x < w && 0 <= y && y < h);\n}\n\nbool dfs(vector<string>& grid, vector<vector<bool> > &visited,\n         int x, int y, int gx, int gy, char c){\n  if(x == gx && y == gy)return true;\n  bool res = false;\n  for (int i = 0; i < 4; i++) {\n    if(!range(x + dx[i], y + dy[i]))continue;\n    if(visited[y + dy[i]][x + dx[i]] == true)continue;\n    if(grid[y + dy[i]][x + dx[i]] != c)continue;\n    visited[y + dy[i]][x + dx[i]] = true;\n    res |= dfs(grid, visited, x + dx[i], y + dy[i], gx, gy, c);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  while(std::cin >> w >> h, w){\n    int sx, sy, gx, gy, n;\n    std::cin >> sx >> sy >> gx >> gy >> n;\n    sx--;sy--;gx--;gy--;\n    vector<string> grid(h, string(w, '.'));\n    vector<block> b;\n    for (int i = 0; i < n; i++) {\n      int c, d, x, y;\n      std::cin >> c >> d >> x >> y;\n      x--;y--;\n      b.push_back(block(c, d, x, y));\n      paint(grid, b[i]);\n    }\n    // for (int i = 0; i < grid.size(); i++) {\n    //   std::cout << grid[i] << std::endl;\n    // }\n    vector<vector<bool> > visited(h, vector<bool>(w, false));\n    visited[sy][sx] = true;;\n    if(dfs(grid, visited, sx, sy, gx, gy, grid[sy][sx])){\n      std::cout << \"OK\" << std::endl;\n    }else{\n      std::cout << \"NG\"<< std::endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n    \n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define reep(i,n,m) for(int i=(n);i<(m);i++)\n#define rep(i,n) reep(i,0,n)\n\nbool flg[150][150];\nint fld[150][150];\nint w,h;\nint xg,yg;\nbool ans;\n\nvoid check(int c,int x,int y){\n    if(x == xg && y == yg){\n        ans = true;\n        return;\n    }\n\n    if(fld[y][x]!=c){\n        return;\n    }\n\n    if(flg[y][x]){\n        return;\n    }\n    flg[y][x] = true;\n\n    int dx[] = {0,0,1,-1};\n    int dy[] = {1,-1,0,0};\n    rep(i,4){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(nx<0 || nx>=w || ny<0 || ny>=h){\n            continue;\n        }\n        check(c,nx,ny);\n    }\n}\n\nint main(){\n    while(cin >> w >> h,w+h){\n        rep(i,150){rep(k,150){flg[i][k]=false;}}\n        ans = false;\n        int xs,ys;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        xs--;ys--;\n        xg--;yg--;\n\n        int n;\n        cin >> n;\n        rep(i,n){\n            int c,d,x,y;\n            cin >> c >> d >> x >> y;\n            x--;\n            y--;\n            int width,height;\n            if(d == 0){\n                width = 4;\n                height = 2;\n            }else{\n                width = 2;\n                height = 4;\n            }\n\n            reep(ny,y,y+height){\n                reep(nx,x,x+width){\n                    fld[ny][nx] = c;\n                }\n            }\n        }\n\n        reep(i,1,6){\n            check(i,xs,ys);\n        }\n        if(ans){\n            puts(\"OK\");\n        }else{\n            puts(\"NG\");\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* 0207 */\n#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint a,b,c,d;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y]||color==0)return 0;\n\tM[x][y]=9;\n\tif(x==c&&y==d)return 1;\n\tif(walk(x+1,y,color)||\n\t\t\twalk(x-1,y,color)||\n\t\t\twalk(x,y+1,color)||\n\t\t\twalk(x,y-1,color))return 1;\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>a>>b>>c>>d;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i=1;i<=h;i++){\n\t\t// \tfor(int j=1;j<=w;j++){\n\t\t// \t\tcout<<M[i][j]<<\" \";\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tif(a==c&&b==d||walk(a,b,M[a][b]))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t// if(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\t// else cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\t/*if(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==ban[xs][ys]){\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]){\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}*/\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint sx,sy,gx,gy,col;\nbool func(vector<vector<int> >out,vector<vector<bool> >&out2,int x,int y){\n  out2[x][y]=true;\n  loop(i,-1,2)loop(j,-1,2){\n    if(out2[x+i][y+j]!=true&&out[x+i][y+j]==col)func(out,out2,x+i,y+j);\n  }\n}\nint main(){\n  int n,m;\n  while(cin>>m>>n,n|m){\n    cin>>sx>>sy>>gx>>gy;\n    int nn;cin>>nn;\n    vector<vector<int> >out(n+2);\n    vector<vector<bool> >out2(n+2);\n    rep(i,n+2)rep(j,m+2)out[i].pb(0);\n    rep(i,n+2)rep(j,m+2)out2[i].pb(false);\n    rep(q,nn){\n      int a,b,c,d;\n      cin>>a>>b>>d>>c;\n      if(b)rep(i,4)rep(j,2)out[i+c][j+d]=a;\n      else rep(i,2)rep(j,4)out[i+c][j+d]=a;\n    }\n    /*cout<<endl;\n    rep(i,n){\n      rep(j,m)cout<<\" \"<<out[i+1][j+1];\n      cout<<endl;\n      }*/\n    \n    if(out[gx][gy]==0||out[gx][gy]!=out[sx][sy]||out[sx][sy]==0){\n      cout<<\"NG\"<<endl;\n      continue;\n    }\n    col=out[sx][sy];\n    func(out,out2,sx,sy);\n    if(out2[gx][gy])cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    /*rep(i,n){\n      rep(j,m)cout<<\" \"<<out[i+1][j+1];\n      cout<<endl;\n      }*/\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint gx,gy,m[128][128];\nint F(int x,int y,int c)\n{\n\tif(x==gx&&y==gy)\n\t\treturn 1;\n\tif(m[y][x]!=c)\n\t\treturn 0;\n\tm[y][x]=-c;\n\tint d[]={0,1,0,-1,0},i,f;\n\tfor(i=f=0;i<4;++i)\n\t\tf=f||F(x+d[i],y+d[i+1],c);\n\treturn f;\n}\nint main()\n{\n\tint w,h,sx,sy,x,y,n,c,d,i,j;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tmemset(m,0,sizeof(m));\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<2;++i)for(j=0;j<4;++j)\n\t\t\t\tif(d) m[y+j][x+i]=c;\n\t\t\t\telse m[y+i][x+j]=c;\n\t\t}j<=w;++j)printf(\"%c\",\".@#$%*\"[m[i][j]]);\n\t\tif(1<=sx&&sx<=w&&1<=sy&&sy<=h&&m[sy][sx]&&F(sx,sy,m[sy][sx]))puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 0;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h >> xs >> ys >> xg >> yg >> n;\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y+1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\tif (map[xg][yg]==0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nclass UnionFind {\n    int n;\n    vector<int> uni;\n    int forest_size;\npublic:\n    explicit UnionFind(int n) : n(n), uni(static_cast<u32>(n), -1), forest_size(n) {};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        forest_size--;\n        return true;\n    }\n    int size(){ return forest_size; }\n    int size(int i){ return -uni[root(i)]; }\n    bool same(int a, int b) { return root(a) == root(b); }\n};\n\nvoid solve(int h, int w){\n    int sy, sx, gy, gx;\n    cin >> sx >> sy >> gx >> gy;\n    vector<vector<int>> grid(h+2, vector<int>(w+2, 0));\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        int c, d, x, y;\n        cin >> c >> d >> x >> y;\n        if(d){\n            for (int j = 0; j < 4; ++j) {\n                for (int k = 0; k < 2; ++k) {\n                    grid[y+j][x+k] = c;\n                }\n            }\n        }else {\n            for (int j = 0; j < 2; ++j) {\n                for (int k = 0; k < 4; ++k) {\n                    grid[y+j][x+k] = c;\n                }\n            }\n        }\n    }\n    UnionFind uf((h+2)*(w+2));\n    for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n            if(grid[i][j] == grid[i+1][j]){\n                uf.unite(i*(w+2)+j, (i+1)*(w+2)+j);\n            }\n            if(grid[i][j] == grid[i][j+1]){\n                uf.unite(i*(w+2)+j, i*(w+2)+j+1);\n            }\n        }\n    }\n    puts(uf.same(sy*(w+2)+sx, gy*(w+2)+gx) ? \"OK\" : \"NG\");\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w){\n        solve(h, w);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint board[100][100];\n\nvoid init_board() {\n    int i, j;\n    for (i=0; i<100; i++) {\n        for (j=0; j<100; j++) {\n            board[i][j] = 0;\n        }\n    }\n}\nvoid put_block(int c, int d, int x, int y) {\n    int i, j;\n    int i_stop = d? 2+x: 4+x;\n    int j_stop = d? 4+y: 2+y;\n    for (i=x; i<i_stop; i++) {\n        for (j=y; j<j_stop; j++) {\n            board[i][j] = c;\n        }\n    }\n}\n\nstring trace(int xs, int ys, int xg, int yg) {\n    int x, y, nx, ny, i, c;\n    queue<pair<int, int> > q;\n    q.push(make_pair(xs, ys));\n    c = board[xs][ys];\n    if (c == 0) {\n        return \"NG\";\n    }\n    board[xs][ys] = 0;\n    while (q.size() > 0) {\n        x = q.front().first;\n        y = q.front().second;\n        q.pop();\n        if (x==xg && y==yg) {\n            return \"OK\";\n        }\n        for (i=0; i<4; i++) {\n            nx = x+dx[i];\n            ny = y+dy[i];\n            if (nx<0 || ny<0 || nx>=100 || ny>=100) {\n                continue;\n            }\n            if (board[nx][ny] == c) {\n                q.push(make_pair(nx, ny));\n                board[nx][ny] = 0;\n            }\n        }\n    }\n    return \"NG\";\n}\n\nint main() {\n    int w, h, xs, ys, xg, yg, n, c, d, x, y, i;\n    while (true) {\n        cin >> w >> h;\n        if (w==0 && h==0) {\n            break;\n        }\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        init_board();\n        for (i=0; i<n; i++) {\n            cin >> c >> d >> x >> y;\n            put_block(c, d, x, y);\n        }\n        cout << trace(xs, ys, xg, yg) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 00;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y;\n\tstate(int x, int y) : x(x), y(y) {};\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h, vi(w));\n\t\tvvi visit(h, vi(w));\n\t\t\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(d) {\n\t\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tS.push(state(xs, ys));\n\t\tbool goal = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(st.x == xg && st.y == yg) {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx, ny;\n\t\t\tREP(d, 4) {\n\t\t\t\tnx = st.x + dx[d];\n\t\t\t\tny = st.y + dy[d];\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny < h) {\n\t\t\t\t\tif(!visit[ny][nx] && field[ny][nx] == field[ys][xs]) {\n\t\t\t\t\t\tvisit[ny][nx] = 1;\n\t\t\t\t\t\tS.push(state(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(goal) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nint w,h,xs,ys,xg,yg,n,cc;\nint field[100][100];\nbool flag;\n\nvoid dfs(int x,int y,int c){\n\tif(flag) return;\n\tif(x == xg && y == yg) {\n\t\tflag = true;\n\t\treturn;\n\t}\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < w && ny >= 0 && ny < h && field[nx][ny] == c){\n\t\t\tfield[nx][ny] = 0;\n\t\t\tdfs(nx,ny,c);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif(!w) break;\n\t\tfor(int i = 0;i < w;i++){\n\t\t\tfor(int j = 0;j < h;j++) field[i][j] = 0;\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n; xs--;ys--;xg--;yg--;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int k = 0;k < 2;k++){\n\t\t\t\t\tfor(int j = 0;j < 4;j++) field[x + k - 1][y + j - 1] = c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tfor(int j = 0;j < 2;j++) field[x + k - 1][y + j - 1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(field[xs][ys] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcc = field[xs][ys];\n\t\tfield[xs][ys] = 0;\n\t\tdfs(xs,ys,cc);\n\t\tif(flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<stack>\nstruct p{\n\tint x;\n\tint y;\n};\nusing namespace std;\nint main(){\n\tint w,h,sx,sy,gx,gy,n,c,d,x,y,i,j,k,o;\n\tint map[100][100];\n\tint used[100][100];\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tp v,u;\n\tstack<p> s;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(used,0,sizeof(used));\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx--;\n\t\tsy--;\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tgx--;\n\t\tgy--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(!d){\n\t\t\t\tfor(j=y;j<y+2;j++){\n\t\t\t\t\tfor(k=x;k<x+4;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=y;j<y+4;j++){\n\t\t\t\t\tfor(k=x;k<x+2;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx]){\n\t\t\tprintf(\"NA\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tv.x=sx;\n\t\tv.y=sy;\n\t\ts.push(v);\n\t\to=0;\n\t\twhile(!s.empty()){\n\t\t\tv=s.top();\n\t\t\ts.pop();\n\t\t\tif(used[v.y][v.x]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tused[v.y][v.x]=1;\n\t\t\t}\n\t\t\tif(v.x==gx&&v.y==gy){\n\t\t\t\to=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(u.x>=0&&u.x<w&&u.y>=0&&u.y<h&&map[u.y][u.x]==map[sy][sx]){\n\t\t\t\t\ts.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NA\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define TATE 1\n#define YOKO 0\nint main(void){\n    int map[101][101];\n    int board[101][101];\n    int T[]={0,-1,1,0};\n    int Y[]={1,0,0,-1};\n    int w,h,xs,xg,ys,yg,n,color,muki,x,y;\n    struct ST {\n        int x;\n        int y;\n    };\n    ST RE;\n    ST GO;\n    queue <ST> Q;\n    while(1){\n        memset(map,0,sizeof(map));\n        memset(board,0,sizeof(board));\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys>>xg>>yg>>n;\n        for(int i=0;i<n;i++){\n            cin>>color>>muki>>x>>y;\n            if(muki==YOKO){\n                for(int j=0;j<4;j++){\n                    board[y][x+j]=board[y+1][x+j]=color;\n                }\n            }\n            else{\n                for(int j=0;j<4;j++){\n                    board[y+j][x]=board[y+j][x+1]=color;\n                }\n            }\n        }\n       /* for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        RE.x=xs;\n        RE.y=ys;\n        map[ys][xs]=1;\n        Q.push(RE);\n        int flag=0;\n        while(!Q.empty()){\n            RE=Q.front();\n            Q.pop();\n            if(RE.x==xg&&RE.y==yg&&board[RE.y][RE.x]==board[yg][xg]){\n                flag=1;\n                //cout<<RE.x<<\" \"<<RE.y<<endl;\n                break;\n            }\n            else{\n                for(int i=0;i<4;i++){\n                    GO=RE;\n                    if(GO.x+Y[i]>0&&GO.y+T[i]>0&&GO.x+Y[i]<101&&GO.y+T[i]<101&&board[GO.y+T[i]][GO.x+Y[i]]==board[yg][xg]&&map[GO.y+T[i]][GO.x+Y[i]]!=1){\n                        GO.x+=Y[i];\n                        GO.y+=T[i];\n                        map[GO.y][GO.x]=1;\n                        Q.push(GO);\n                    }\n                }\n            }\n        }\n       /* for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<board[i][j];\n            }\n            cout<<endl;\n        }*/\n        if(flag==1){\n            cout<<\"OK\"<<endl;\n        }\n        else{\n            cout<<\"NG\"<<endl;\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,x,n) for(int i=x;i<n;i++)\n#define all(v) (v).begin(),(v).end()\n#define pf push_front\n#define pb push_back\n#define int long long\nusing namespace std;\nconst int INF=1000000007;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint mp[101][101];\nbool ans;\nint w,h,tmp;\nint xs,ys,xg,yg;\n\nvoid dfs(int y,int x,int c){\n  if(y>0&&y<=h&&x>0&&x<=w&&mp[y][x]==c){\n    mp[y][x]=0;\n    rep(i,4){\n      dfs(y+dy[i],x+dx[i],c);\n    }\n  }else return;\n  if(y==yg&&x==xg){\n    ans=true;\n    return;\n  }\n}\n\nsigned main(){\n  while(cin>>w>>h,w){\n    rep(i,w)rep(j,h)mp[i][j]==0;\n    ans=false;\n    cin>>xs>>ys>>xg>>yg;\n    int n;\n    cin>>n;\n    rep(i,n){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      if(d==0)rep(i,2)rep(j,4)mp[y+i][x+j]=c;\n      else rep(i,2)rep(j,4)mp[y+j][x+i]=c;\n    }\n    tmp=mp[ys][xs];\n    if(mp[ys][xs]==tmp&&mp[yg][xg]==tmp)dfs(ys,xs,tmp);\n    cout<<(ans?\"OK\":\"NG\")<<endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\nbool is_goal = false;\n#define START 20\n#define GOAL 30\n\nvoid DFS(int h,int w,int c){\n\n  if(!is_goal){\n\n    if(Array[h][w] == GOAL){\n      is_goal = true;\n      return;\n    }\n\n    if(Array[h][w] != c || Array[h][w] == 0){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 0;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n  }\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n      is_goal = false;\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n      cin >> Goal[0] >> Goal[1];\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n      Array[Goal[0]][Goal[1]] = GOAL;\n      /*for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          cout << Array[i][j];\n        }\n        cout << endl;\n      }*/\n\n      DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n\n      if(is_goal){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W || H) {\n\t\tint sx, sy; cin >> sx >> sy; --sx, --sy;\n\t\tint gx, gy; cin >> gx >> gy; --gx, --gy;\n\t\tint n; cin >> n;\n\n\t\tint board[100][100] = {0};\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y; --x, --y;\n\t\t\tint lx = x, ly = y;\n\t\t\tint rx, ry;\n\n\t\t\tif (d == 0) rx = x + 4, ry = y + 2;\n\t\t\telse rx = x + 2, ry = y + 4;\n\n\t\t\tfor (y = ly; y < ry; ++y)\n\t\t\t\tfor (x = lx; x < rx; ++x)\n\t\t\t\t\tboard[y][x] = c;\n\t\t}\n\n\t\tbool f = false;\n\t\tP goal = P(gx, gy);\n\t\tint color = board[sy][sx];\n\n\t\tif (color == 0) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstack<P> S; S.push( P(sx, sy) );\n\t\twhile ( !S.empty() ) {\n\t\t\tP p = S.top(); S.pop();\n\n\t\t\tif (p.real() < 0 || p.real() >= W || p.imag() < 0 || p.imag() >= H) continue;\n\t\t\tif (board[p.imag()][p.real()] != color) continue;\n\t\t\tboard[p.imag()][p.real()] = 0;\n\n\t\t\tif ( p == goal ) {\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS.push( p + P(1, 0) );\n\t\t\tS.push( p + P(-1, 0) );\n\t\t\tS.push( p + P(0, 1) );\n\t\t\tS.push( p + P(0, -1) );\n\t\t}\n\t\tif (f) continue;\n\n\t\tcout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint board[105][105];\nint xg , yg , sc;\n\nvoid dfs(int x , int y ,int w , int h){\n\tif(x==xg&&y==yg) {\n\t\tb=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0 || ty<=0 || tx>w || ty>h || board[tx][ty]!=sc || board[tx][ty]==0 || b ) continue;\n\t\tdfs( tx , ty , w , h );\n\t}\n}\n\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w|h){\n\t\tint xs , ys , n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse  dfs( xs , ys , w , h );\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nbool ans;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\tif (p.first == gy&&p.second == gx){\n\t\t\tans = 1;\n\t\t\treturn;\n\t\t}\n\t\tREP(i, 4){\n\t\t\tint nx = p.second + dx[i], ny = p.first + dy[i];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h){\n\t\t\t\tif (table[ny][nx] == c&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tans = 0;\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t\tdis[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tdis[sy][sx] = 1;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\tif (ans)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102]={0};\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=-1;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  while(1){\n    int h,w;\n    int start_x,start_y;\n    int goal_x,goal_y;\n    int n;\n\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg, yg;\n\nbool DFS(int Y, int X, int C)\n{\n  if(F[Y][X]!=C)\n    return false;\n  else if(Y == yg && X == xg)\n    return true;\n\n  F[Y][X] = 0;\n\n  bool tmp = 0;\n  tmp += DFS(Y-1, X, C);\n  tmp += DFS(Y+1, X, C);\n  tmp += DFS(Y, X-1, C);\n  tmp += DFS(Y, X+1, C);\n  return tmp;\n}\n\nint main()\n{\n  while(1){\n    F[102][102] = {};\n\n    int w=0, h=0;\n    cin >> w >> h;\n\n    if(w == 0 && h == 0)\n      return 0;\n\n    int xs, ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c, d, x, y;\n    for(int i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d == 0)\n        for(int j=0; j<2; j++)\n          for(int k=0; k<4; k++)\n            F[y+j][x+k] = c;\n      else\n        for(int j=0; j<4; j++)\n          for(int k=0; k<2; k++)\n            F[y+j][x+k] = c;\n    }\n\n    bool res = DFS(ys, xs, F[ys][xs]);\n\n    if(res)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -2;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n    for(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=-1;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  if(F[xs][ys] == 0){\n    cout << \"NG\" << endl;\n  } else {\n    DFS(xs,ys,F[xs][ys]);\n  \n    if(F[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    } else {\n      cout << \"NG\" <<endl;\n    }\n  }\n\n}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\nbool isfirst = true;\nwhile(true){\n\tif(isfirst){\n\t\tisfirst = false;\n\t}else{\n\t\tcout << endl;\n\t}\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\";\n\t}else{\n\t\tcout << \"NG\";\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem0207 : Block **/\nint main()\n{\n\tint W, H;\n\t\n\twhile (cin>>W>>H, W||H) {\n\t\tvector<vector<int> > board(W, vector<int>(H));\n\t\tint sx, sy, gx, gy;\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tsx--, sy--, gx--, gy--;\n\t\t\n\t\tint N; cin>>N;\n\t\twhile (N--) {\n\t\t\tint c, d, x, y; cin>>c>>d>>x>>y;\n\t\t\tx--, y--;\n\t\t\t\n\t\t\tif (d==0) {\n\t\t\t\tboard[x][y] = board[x+1][y] = board[x+2][y] = board[x+3][y] = c;\n\t\t\t\tboard[x][y+1] = board[x+1][y+1] = board[x+2][y+1] = board[x+3][y+1] = c;\n\t\t\t} else {\n\t\t\t\tboard[x][y] = board[x][y+1] = board[x][y+2] = board[x][y+3] = c;\n\t\t\t\tboard[x+1][y] = board[x+1][y+1] = board[x+1][y+2] = board[x+1][y+3] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tcerr << board[j][i] << \" \";\n\t\t\t}\n\t\t\tcerr << endl;\n\t\t} **/\n\t\t\n\t\tqueue<P> Q;\n\t\tbool vis[100][100]={0};\n\t\tQ.push(P(sx, sy));\n\t\tvis[sx][sy]=true;\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (p.first == gx && p.second == gy) {\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first+dx[i], ny = p.second+dy[i];\n\t\t\t\tif_range(nx, ny, W, H) {\n\t\t\t\t\tif (!vis[nx][ny] && board[nx][ny] == board[p.first][p.second]) {\n\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"NG\" << endl;\n\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<list>\nusing namespace std;\n\nconst int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { \nassert(b!=0);\nreturn a * inv(b);\n }\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,-1,0,1 };\nstruct Node {\n\tNode(int a, int b, int c) {\n\t\ttime = a;\n\t\tx = b;\n\t\ty = c;\n\t}\n\tint time;\n\tint x;\n\tint y;\n};\nclass Compare {\npublic:\n\tbool operator()(const Node& l, const Node& r) {\n\t\treturn l.time < r.time;\n\t}\n};\n\n\nint main() {\n\twhile(1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w)return 0;\n\t\tvector<vector<int>> maze(h+2, vector<int>(w+2,0));\n\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d) {\n\t\t\t\tfor (int ax = 0; ax < 4; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 2; ++ay) {\n\t\t\t\t\t\tmaze[y+ay][x+ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int ax = 0; ax < 2; ++ax) {\n\t\t\t\t\tfor (int ay = 0; ay < 4; ++ay) {\n\t\t\t\t\t\tmaze[y + ay][x + ax] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < maze.size(); ++i) {\n\t\t\tfor (int j = 0; j < maze[0].size(); ++j) {\n\t\t\t\tcout << maze[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint color = maze[ys][xs];\n\t\tif (!color||color!=maze[yg][xg]) {\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<bool>>times(h, vector<bool>(w, false));\n\n\t\tpriority_queue<Node,vector<Node>,Compare> qu;\n\t\t qu.emplace(0,xs,ys);\n\t\t bool flag=false;\n\t\twhile (!qu.empty()) {\n\t\t\tNode an(qu.top());\n\t\t\tqu.pop();\n\t\t\tif (an.x == xg&&an.y == yg) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tif (maze[an.y + dy[i]][an.x + dx[i]] == color) {\n\t\t\t\t\t\tif (times[an.y + dy[i]][an.x + dx[i]]) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tqu.push(Node{ an.time + 1,an.x + dx[i], an.y + dy[i] });\n\t\t\t\t\t\t\ttimes[an.y + dy[i]][an.x + dx[i]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"OK\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\nint nx, ny;\n\nvoid route(int h, int w, int color) {\n\tif (map[h][w] != color)\n\t\treturn;\n\tmap[h][w] = 0;\n\troute(h, w + 1, color);\n\troute(h + 1, w, color);\n\troute(h, w - 1, color);\n\troute(h - 1, w, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\n\twhile (1) {\n\t\tcin >> h >> w >> xs >> ys >> xg >> yg >> n;\n\t\tif (h == 0 && w == 0)\n\t\t\tbreak;\n\n\t\tint c, d, x, y;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 1; j <= 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y+1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 1; j <= 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y+j] = c;\n\t\t\t}\n\t\t}\n\t\tint color = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\tif (xg == 0 && yg == 0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\";\n\t\tcout << nx << ' ' << ny << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint board[100][100];\nbool vst[100][100];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,xs,ys,xg,yg,n;\nbool dfs(int x,int y) {\n\tif(x==xg && y==yg)\n\t\treturn true;\n\tvst[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0>nx||nx>=w|0>ny||ny>=h)\n\t\t\tcontinue;\n\t\tif(board[nx][ny]!=board[xs][ys])\n\t\t\tcontinue;\n\t\tif(vst[nx][ny])\n\t\t\tcontinue;\n\t\tif(dfs(nx,ny)) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile(scanf(\"%d %d\",&w,&h),w|h) {\n\t\tscanf(\"%d %d\",&xs,&ys); xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg); xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tmemset(board,0,sizeof(board));\n\t\tmemset(board,0,sizeof(vst));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y); x--;y--;\n\t\t\tif(d==0) {\n\t\t\t\tfor(int i=0;i<4;i++) for(int j=0;j<2;j++)\n\t\t\t\t\tboard[x+i][y+j]=c;\n\t\t\t}else {\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<4;j++)\n\t\t\t\t\tboard[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Solve{\nprivate:\n    int board[101][101] = {{0},{0}};\n    int board_weight;\n    int board_hight;\n    int start_x;\n    int start_y;\n    int goal_x;\n    int goal_y;\n    int start_color;\n    const int vector_x[4] = {0, 0, -1, 1};\n    const int vector_y[4] = {1, -1, 0, 0};\n    bool flag = false;\n    void dfs(int x, int y);\npublic:\n    Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y);\n    void set_Block(int Color, int Direction, int X, int Y);\n    bool check();\n};\n\nSolve::Solve(int Board_Weight, int Board_Hight, int Start_X, int Start_Y, int Goal_X, int Goal_Y){\n    board_weight = Board_Weight;\n    board_hight  = Board_Hight;\n    start_x      = Start_X - 1;\n    start_y      = Start_Y - 1;\n    goal_x       = Goal_X - 1;\n    goal_y       = Goal_Y - 1;\n}\nvoid Solve::set_Block(int Color, int Direction, int X, int Y){\n    X -= 1; Y -= 1;\n    if(X == start_x && Y == start_y){\n        start_color = Color;\n    }\n    if(Direction == 0){\n        for(int h = 0;h < 2;h++){\n            for(int w = 0;w < 4;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }else{\n        for(int h = 0;h < 4;h++){\n            for(int w = 0;w < 2;w++){\n                board[Y+h][X+w] = Color;\n            }\n        }\n    }\n}\nbool Solve::check(){\n    Solve::dfs(start_x, start_y);\n    return flag;\n}\n\nvoid Solve::dfs(int X, int Y){\n    if(X == goal_x && Y == goal_y){\n        flag = true;\n        return;\n    }\n    \n    for(int y = 0;y < 4;y++){\n        for(int x = 0;x < 4;x++){\n            int new_x = X + vector_x[x];\n            int new_y = Y + vector_y[y];\n            \n            if(new_x >= 0 && new_x < board_weight){\n                if(new_y >= 0 && new_y < board_hight){\n                    if(start_color == board[new_y][new_x]){\n                        board[Y][X] = 9;\n                        dfs(new_x, new_y);\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int w, h, sx, sy, gx, gy, n, c, d, x, y;\n    \n    while(true){\n        cin >> w >> h;\n        if(w != 0 && h != 0){\n            cin >> sx >> sy >> gx >> gy >> n;\n            Solve s(w, h, sx, sy, gx, gy);\n            \n            for(int i = 0;i < n;i++){\n                cin >> c >> d >> x >> y;\n                s.set_Block(c, d, x, y);\n            }\n            \n            if(s.check() == true){\n                cout << \"OK\" << endl;\n            }else{\n                cout << \"NG\" << endl;\n            }\n        }else{\n            break;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[100][100]={0},v[100][100]={0};\nint root(int x,int y,int vmap[][100]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int i1=0;i1<100;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[128][128];\nbool mem[128][128];\nint xg,yg;\nint w,h;\nvoid dfs(int x,int y,int col){\n\tif(x < 1 || y < 1 || x > w || y > h)return ;\n\tif(mem[x][y])return ;\n\tif(stage[x][y] != col)return ;\n\tmem[x][y] = true;\n\trep(i,4)if(col == stage[x+dx[i]][y+dy[i]])dfs(x + dx[i], y + dy[i], col);\n\treturn ;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w|h){\n\t\tmemset(stage,0,sizeof(stage));\n\t\trep(i,128)rep(j,128)mem[i][j] = false;\n\t\tint xs,ys;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\t\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\n\t\trep(q,n){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\treps(i,x,x+4)reps(j,y,y+2)stage[j][i] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treps(i,x,x+2)reps(j,y,y+4)stage[j][i] = c;\n\t\t\t}\n\t\t}\n\t\tdfs(xs,ys,stage[xs][ys]);\n\t\tbool f = mem[xg][yg];\n\t\t(f) ? puts(\"OK\") : puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h, vi(w));\n\t\tvvi visit(h, vi(w));\n\t\t\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(d) {\n\t\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<pii> S;\n\t\tS.push(make_pair(xs, ys));\n\t\tbool goal = false;\n\t\twhile(!S.empty()) {\n\t\t\tpii p = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(p.first == xg && p.second == yg) {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx, ny;\n\t\t\tREP(d, 4) {\n\t\t\t\tnx = p.first + dx[d];\n\t\t\t\tny = p.second + dy[d];\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny < h) {\n\t\t\t\t\tif(!visit[ny][nx] && field[ny][nx] == field[ys][xs]) {\n\t\t\t\t\t\tvisit[ny][nx] = 1;\n\t\t\t\t\t\tS.push(make_pair(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(goal) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\n \nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = -1;\n \n  meiro(W+1,H  ,c);\n  meiro(W-1  ,H,c);\n  meiro(W,H+1 ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n \n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 10;\n      }\n    }\n \n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n \n    int n;\n    cin >> n;\n \n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n \n    meiro(xs,ys,C[xs][ys]);\n \n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\n\nint maze[150][150];\nint W, H;\nbool flag;\n\nvoid dfs( int sx, int sy, int gx, int gy, int color ) {\n\tREP( i, 4 ) {\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\n\t\tif( nx >= 0 && nx <= W && ny >= 0 && ny <= H && maze[nx][ny] == color ) {\n\t\t\tif( nx == gx && ny == gy ) flag = true;\n\t\t\tmaze[nx][ny] = -1;\n\t\t\tdfs( nx, ny, gx, gy, color );\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile( cin >> W >> H, W ) {\n\t\tfill( maze[0], maze[150], -1 );\n\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tREP( i, n ) {\n\t\t\tint color, d, x, y;\n\t\t\tcin >> color >> d >> x >> y;\n\n\t\t\tif( d == 0 ) {\n\t\t\t\tREP( i, 4 ) {\n\t\t\t\t\tmaze[x + i][y] = color;\n\t\t\t\t\tmaze[x + i][y + 1] = color;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tREP( i, 4 ) {\n\t\t\t\t\tmaze[x][y + i] = color;\n\t\t\t\t\tmaze[x + 1][y + i] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( maze[sx][sy] == -1 ) {\n\t\t\tcout << \"NG\" << endl;\n\t\t} else {\n\t\t\tflag = false;\n\t\t\tdfs( sx, sy, gx, gy, maze[sx][sy] );\n\t\t\tcout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint a,b,c,d;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y]||color==0)return 0;\n\tM[x][y]=9;\n\twalk(x+1,y,color);\n\twalk(x-1,y,color);\n\twalk(x,y+1,color);\n\twalk(x,y-1,color);\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>a>>b>>c>>d;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twalk(a,b,M[a][b]);\n\t\tif(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n return;\n if(C[W][H]!=c){\n   return;\n }\n\n C[W][H] = -1;\n\n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n\nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n   if(w==0 && h==0){\n     break;\n   }\n\n   for(int i=0;i<20;i++){\n     for(int j=0;j<20;j++){\n       C[i][j] = 0;\n     }\n   }\n\n   int xs,ys,xg,yg;\n   cin >> xs >> ys >> xg >> yg;\n\n   int n;\n   cin >> n;\n\n   int c,d,x,y;\n   for(int i=0;i<n;i++){\n     cin >> c >> d >> x >> y;\n\n     if(d==0){\n       for(int j=x;j<x+4;j++){\n         for(int k=y;k<y+2;k++){\n           C[j][k]=c;\n         }\n       }\n     }else{\n       for(int j=x;j<x+2;j++){\n         for(int k=y;k<y+4;k++){\n           C[j][k]=c;\n         }\n       }\n     }\n   }\n\n   meiro(xs,ys,C[xs][ys]);\n   //print(w,h);\n\n   if(C[xg][yg] == -1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<functional>\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint c,d,x,y;\nint map[101][101];\nint flg=0,temp;\nvoid func(int ,int);\nusing namespace std;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0 && h==0){\n\t\t\tbreak;\n\t\t}\n\t\tint i,j,k;\n\t\tfor(i=1;i<=w;i++){\n\t\t\tfor(j=1;j<=h;j++){\n\t\t\t\tmap[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(k=0;k<=1;k++){\n\t\t\t\t\tfor(j=0;j<=3;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d==1){\n\t\t\t\tfor(k=0;k<=3;k++){\n\t\t\t\t\tfor(j=0;j<=1;j++){\n\t\t\t\t\t\tmap[y+k][x+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(i=1;i<=w;i++){\n\t\t\tfor(j=1;j<=h;j++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tflg=0;\n\t\tif(map[xs][ys]==map[xg][yg] && map[xs][ys]!=0){\n\t\t\ttemp=map[xs][ys];\n\t\t\tmap[xs][ys]=0;\n\t\t\tfunc(ys,xs);\n\t\t}\n\t\tif(flg==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\nvoid func(int yy,int xx){\n\tint dy[4]={0,1,0,-1},dx[4]={1,0,-1,0};\n\tint i;\n\tfor(i=0;i<4;i++){\n\t\tyy=yy+dy[i];\n\t\txx=xx+dx[i];\n\t\tif(yy<=h && yy>=1 && xx<=w && xx>=1 && map[xx][yy]==temp){\n\t\t\tmap[xx][yy]=0;\n\t\t\tif(xg==xx && yg==yy){\n\t\t\t\tflg=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfunc(yy,xx);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nclass node{\npublic:\n\tint x,y;\n\tvoid set(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tbool check(int w,int h){\n\t\tif(x>=0&&y>=0){\n\t\t\tif(x<=w&&y<=h) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nint main(){\n\t\n\tint w,h,xs,ys,xg,yg,n,c,dir,x,y;\n\tint i,j;\n\tint color[101][101];\n\tint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\tbool visited[101][101];\n\tqueue<node> q;\n\tnode a;\n\n\tscanf(\"%d%d\",&w,&h);\n\tscanf(\"%d%d\",&xs,&ys);\n\tscanf(\"%d%d\",&xg,&yg);\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tscanf(\"%d%d\",&c,&dir,&x,&y);\n\t\tif(dir==0){\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<4;j++) color[x+j][y+i] = c;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(i=0;i<2;i++){\n\t\t\t\tfor(j=0;j<4;j++) color[x+i][y+j] = c;\n\t\t\t}\n\t\t}\n\t}\n\ta.set(xs,ys);\n\t\n\tq.push(a);\n\tvisited[a.x][a.y]=true;\n\twhile(!q.empty()){\n\t\ta = q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\ta.x += dx[i];\n\t\t\ta.y += dy[i];\n\t\t\tif(!a.check(w,h)&&(color[xs][ys]==color[a.x][a.y])&&!visited[a.x][a.y]){\n\t\t\t\tq.push(a);\n\t\t\t\tif(a.x==xg&&a.y==yg) break;\n\t\t\t\tvisited[a.x][a.y] = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(visited[xg][yg]) printf(\"OK\\n\");\n\telse printf(\"NG\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nint xs,ys,xg,yg,n;\nll w,h;\nvector<vector<ll>> field;\nvector<vector<ll>> f;\n\nbool dfs(int x,int y,int c){\n  if(f[x][y] != inf) return false;\n  if(x == xg && y == yg) return true;\n  f[x][y] = 1;\n  bool res = false;\n  rep(i,4){\n    int nx = x + dx[i],ny = y + dy[i];\n    if(value(nx,ny,w,h) && field[nx][ny] == c){\n      res |= dfs(nx,ny,c);\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  rep(i,5){\n    f = vector<vector<ll>>(w+1,vector<ll>(h+1,inf));\n\n    if(dfs(xs,ys,i)){\n      cout << \"OK\" << endl;\n      return ;\n    }\n  }\n  cout << \"NG\" << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> w >> h && w+h){\n    field = vector<vector<ll>>(w+1,vector<ll>(h+1,0));\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--,ys--,xg--,yg--;\n    int c,d,x,y;\n    rep(i,n){\n      cin >> c >> d >> x >> y;\n      --x,--y,--c;\n      rep(j,2){\n        rep(k,4){\n          ll dx = k,dy = j;\n          if(d){\n            swap(dx,dy);\n          }\n          field[x+dx][y+dy] = c;\n        }\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint xg,yg,c,a[1000][1000],memo[1000][1000],ans,p,w,h;\n\nint solve(int ys,int xs){\n\n  if(memo[ys][xs] < 0) return memo[ys][xs];\n\n  if(ys + 1 <= w && a[ys+1][xs] == p) solve(ys+1,xs);\n  else if(xs + 1 <= h && a[ys][xs+1] == p) solve(ys,xs+1);\n  //else if(ys - 1 > 0 /*&& a[ys-1][xs] == p*/) solve(ys-1,xs);\n  //else if(xs - 1 > 0 && a[ys][xs-1] == p) solve(ys,xs-1);\n\n  if(xs == xg && ys == yg) return ans = 1;\n\n  return  memo[ys][xs] = -1;\n}\n\nint main(){\n  int xs,ys,n,d,x,y;\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    memset(a,0,sizeof(a));\n    memset(memo,0,sizeof(memo));\n    ans = 0;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n\tfor(int i=y;i<y+2;i++){\n\t  for(int j=x;j<x+4;j++) a[i][j] = c;\n\t}\n      }\n\n      else if(d == 1){\n\tfor(int i=y;i<y+4;i++){\n\t  for(int j=x;j<x+2;j++) a[i][j] = c;\n\t}\n      }\n    }\n\n    p = a[yg][xg];\n    solve(ys,xs);\n\n    for(int i=1;i<=h;i++){\n      cout << endl;\n      for(int j=1;j<=w;j++) cout << a[i][j];\n    }\n\n    if(ans == 1)   cout << \"OK\" << endl;\n    else if(ans == 0)cout << \"NG\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(W+1, vector<int>(H+1));\n        vector<vector<int> > used(W+1, vector<int>(H+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            if (!dir) {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx <= H && 0 <= ny && ny <= W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (d[gx][gy] > 0 && used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\n\nint field[100][100];\nint pathToGoal[100][100];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint dfs(int x, int y, int goalX, int goalY, int color) {\n    pathToGoal[y][x] = 1;\n    if (x == goalX && y == goalY) {\n        return 1;\n    }\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < w && 0 <= ny && ny < h && pathToGoal[ny][nx] == -1 && field[ny][nx] == color) {\n            res += dfs(nx, ny, goalX, goalY, color);\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (true) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            return 0;\n        }\n\n        for (int i = 0; i < 100; ++i) {\n            for (int j = 0; j < 100; ++j) {\n                field[i][j] = -1;\n                pathToGoal[i][j] = -1;\n            }\n        }\n\n        int xs, ys;\n        int xg, yg;\n        int n;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        xs--;\n        ys--;\n        xg--;\n        yg--;\n        for (int i = 0; i < n; ++i) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--;\n            y--;\n            if (d == 0) {\n                for (int p = 0; p < 2; ++p) {\n                    for (int q = 0; q < 4; ++q) {\n                        field[y + p][x + q] = c;\n                    }\n                }\n            }\n            else {\n                for (int p = 0; p < 4; ++p) {\n                    for (int q = 0; q < 2; ++q) {\n                        field[y + p][x + q] = c;\n                    }\n                }\n            }\n        }\n\n        if (dfs(xs, ys, xg, yg, field[xs][ys]) > 0) {\n            cout << \"OK\" << endl;\n        }\n        else {\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define pb(a) push_back(a)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n, c, d, x, y, b[101][101];\nint dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n\nbool dfs(int x, int y){\n    int nx, ny;\n    b[x][y] = 0;\n    if(x == xg && y == yg) return true;\n    bool r = 0;\n    rep(i, 4){\n        nx = x + dx[i]; ny = y + dy[i];\n        if(nx > 0 && nx <= h && ny > 0 && ny <= w && b[nx][ny]==c)r=r||dfs(nx, ny);\n    }\n    return r;\n}\n\nint main(){\n    while(cin >> w >> h, w||h){\n        memset(b, 0, sizeof(b));\n        cin >> ys >> xs >> yg >> xg >> n;\n        rep(i,n){\n            int c, d, x, y;\n            cin >> c >> d >> y >> x;\n            rep(j, (d?4:2)) rep(k, (d?2:4)) b[x + j][y + k] = c;\n        }\n        c = b[xs][ys];\n\n        if(c > 0 && dfs(xs, ys)) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nbool dfs(vector<vector<int> > &g);\n\nint sx, sy, gx, gy;\nint n, m; \nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint main()\n{\n\nwhile(cin >> n >> m,(n|m)){\n m++; n++;\n vector<vector<int> > graph(m,vector<int>(n,0));\n \n cin>>sx>>sy>>gx>>gy;\n int bl;  cin>>bl;\n loop(i, bl){\n  int a,b,c,t; cin>>a>>b>>c>>t;\n  if(!b){\n   for(int j=t;j<t+2;j++){\n    for(int k=c;k<c+4;k++){\n     graph[j][k] = a;\n    }\n   } \n  } else {\n   for(int j=c;j<c+2;j++){\n    for(int k=t;k<t+4;k++){\n     graph[j][k] = a;\n    }\n   }\n  }\n }\ncout << ((dfs(graph)) ? \"OK\" : \"NG\") << endl;\n}\nreturn 0;\n}\n\nbool dfs(vector<vector<int> > &g) {\nint cl = g[sy][sx];\nvector<vector<bool> > vsed(m,vector<bool>(n,false));\nqueue<i_i > q;\nq.push(mp(sx,sy));\nwhile(!q.empty()){\nint x = q.front().first, y = q.front().second;\nq.pop();\nif(x == gx && y == gy){\nreturn true;\n}\nif(vsed[y][x]){\ncontinue;\n} else {\nvsed[y][x]=true;\n}\n\nloop(i, 4) {\nint nx = x +dx[i], ny = y +dy[i];\nif(0<nx && nx < n && 0<ny && ny < m){\nif(g[ny][nx] == cl){\nq.push(mp(nx,ny));\n}\n} \n}\n\n}\nreturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#include <algorithm>\n\nint testcase_ends() {\n  int w, h;\n  scanf(\"%d %d\", &w, &h);\n  if (w == 0 && h == 0)\n    return 1;\n\n  int xs, ys;\n  scanf(\"%d %d\", &xs, &ys);\n\n  int xg, yg;\n  scanf(\"%d %d\", &xg, &yg);\n\n  std::vector<std::vector<int>> g(h+2, std::vector<int>(w+2));\n\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i=0; i<n; ++i) {\n    int c, d, x, y;\n    scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\n    int dh=2, dw=2;\n    (d? dh:dw) += 2;\n\n    for (int j=0; j<dh; ++j)\n      for (int k=0; k<dw; ++k)\n\tg[y+j][x+k] = c;\n  }\n\n  // for (int i=0; i<h; ++i)\n  //   for (int j=0; j<w; ++j)\n  //     fprintf(stderr, \"%d%c\", g[i][j], j+1<w? ' ':'\\n');\n\n  if (g[ys][xs] != g[yg][xg])\n    return !printf(\"NG\\n\");\n\n  const int dy[]={-1, 0, 1, 0};\n  const int dx[]={0, -1, 0, 1};\n  std::function<bool (int, int)> dfs=[&](int x, int y) {\n    if (x == xg && y == yg) return true;\n\n    int cs=g[y][x];\n    g[y][x] = -cs;  // mark visited\n    for (int k=0; k<4; ++k) {\n      int cd=g[y+dy[k]][x+dx[k]];\n      if (cs == cd && dfs(x+dx[k], y+dy[k]))\n\treturn true;\n    }\n    return false;\n  };\n\n  printf(\"%s\\n\", dfs(xs, ys)? \"OK\":\"NG\");\n  return 0;\n}      \n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint B[101][101];\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg);\n\nint main(int argc, char** argv)\n{\n\tint w, h;\n\tint xs, ys;\n\tint xg, yg;\n\tint n;\n\tint c, d, x, y;\n\n\twhile( 1 )\n\t{\n\t\tcin >> w;\n\t\tcin >> h;\n\t\tif(w==0 && h==0) break;\n\t\t\n\t\tcin >> xs;\n\t\tcin >> ys;\n\t\tcin >> xg;\n\t\tcin >> yg;\n\t\tcin >> n;\n\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> c; cin >> d; cin >> x; cin >> y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<4; dx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dy=0; dy<2; dy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tB[x+dx][y+dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int dx=0; dx<2; dx++)\n\t\t\t\t{\n\t\t\t\t\tfor(int dy=0; dy<4; dy++)\n\t\t\t\t\t{\n\t\t\t\t\t\tB[x+dx][y+dy] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (bfs(w, h, xs, ys, xg, yg) ? \"OK\" : \"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n\nbool bfs(int w, int h, int xs, int ys, int xg, int yg)\n{\n\tint x, y, c, xx, yy;\n\tint offset[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\tqueue<P> q;\n\tP p;\n\n\tc = B[xs][ys];\n\tB[xs][ys] = 0;\n\tp.first = xs, p.second = ys;\n\t\n\tq.push(p);\n\twhile(!q.empty())\n\t{\n\t\tp = q.front();\n\t\tq.pop();\n\t\tx = p.first;\n\t\ty = p.second;\n\t\tif(x==xg && y==yg) return true;\n\t\tB[x][y] = 0;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\txx = x + offset[i][0];\n\t\t\tyy = y + offset[i][1];\n\t\t\tif(x>=1 && y>=1 && x<=w && y<=h)\n\t\t\t{\n\t\t\t\tif(B[xx][yy] == c)\n\t\t\t\t{\n\t\t\t\t\tp.first = xx;\n\t\t\t\t\tp.second = yy;\n\t\t\t\t\tq.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][xs]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std ;\n\nint map[ 100 ][ 100 ] ;\nint w ,h ;\nint gx ,gy ;\nint way ;\n\nstruct ST\n{\n\tint x ;\n\tint y ;\n} ;\n\nST s ;\n\nvoid ans()\n{\n\tqueue< ST > que ;\n\tint mx[ 4 ] = { 1 ,0 ,0 ,-1 } ;\n\tint my[ 4 ] = { 0 ,1 ,-1 ,0 } ;\n\tbool came[ 100 ][ 100 ] = { false } ;\n\tque.push( s ) ;\n\tcame[ s.y ][ s.x ] = true ;\n\twhile( ! que.empty() )\n\t{\n\t\ts = que.front() ;\n\t\tif( s.x == gx && s.y == gy )\n\t\t{\n\t\t\tcout << \"OK\" << endl ;\n\t\t\treturn ;\n\t\t}\n\t\tque.pop() ;\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\ts.x += mx[ i ] ;\n\t\t\ts.y += my[ i ] ;\n\t\t\tif( came[ s.y ][ s.x ] == false && map[ s.y ][ s.x ] == way )\n\t\t\t{\n\t\t\t\tcame[ s.y ][ s.x ] = true ;\n\t\t\t\tque.push( s ) ;\n\t\t\t\ts.x -= mx[ i ] ;\n\t\t\t\ts.y -= my[ i ] ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NG\" << endl ;\n}\n\n\nint main()\n{\n\twhile( cin >> w >> h ,h )\n\t{\n\t\tint n ;\n\t\tint color ,muki ,X ,Y ;\n\t\tcin >> s.x >> s.y ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\twhile( n )\n\t\t{\n\t\t\tn-- ;\n\t\t\tcin >> color >> muki >> X >> Y ;\n\t\t\tX-- ;\n\t\t\tY-- ;\n\t\t\tif( muki )\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ Y + i ][ X + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 2 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ Y + i ][ X + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgx-- ;\n\t\ts.x-- ;\n\t\tgy-- ;\n\t\ts.y-- ;\n\t\tway = map[ s.y ][ s.x ] ;\n\t\tif( map[ gy ][ gx ] == way )\n\t\t{\n\t\t\tans() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl ;\n\t\t}\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int Y, int X, int C, int yg, int xg)\n{\n  if(Y == yg && X == xg)\n    return true;\n  if(F[Y][X]!=C)\n    return false;\n\n  F[Y][X] = 0;\n\n  bool tmp = 0;\n  tmp += DFS(Y-1, X, C, yg, xg);\n  tmp += DFS(Y+1, X, C, yg, xg);\n  tmp += DFS(Y, X-1, C, yg, xg);\n  tmp += DFS(Y, X+1, C, yg, xg);\n  return tmp;\n}\n\nint main()\n{\n  int w, h;\n  cin >> w >> h;\n\n  if(w == 0 && h == 0)\n    return 0;\n\n  int xs, ys;\n  cin >> xs >> ys;\n\n  int xg, yg;\n  cin >> xg >> yg;\n\n  int n;\n  cin >> n;\n\n  int c, d, x, y;\n  for(int i=0; i<n; i++){\n    cin >> c >> d >> x >> y;\n    if(d == 0)\n      for(int j=0; j<2; j++)\n        for(int k=0; k<4; k++)\n          F[y+j][x+k] = c;\n    else\n      for(int j=0; j<4; j++)\n        for(int k=0; k<2; k++)\n          F[y+j][x+k] = c;\n  }\n\n  bool res = DFS(ys, xs, F[ys][xs], yg, xg);\n  if(res)\n    cout << \"OK\" << endl;\n  else\n    cout << \"NG\" << endl;\n\n  main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint block[101][101];\nint oblock[101][101];\nint xg,yg,w,h;\n\nint go (int xs, int ys) {\n\t//cout << xs << \" \" << ys << endl;\n\toblock[xs][ys] = 1;\n\tif ( xs > w && ys > h ) {\n\t\treturn 0;\n\t}\n//\telse if ( xs == w && ys == h ) {cout >> \"NG\" >> endl; return 0;}\n\tif ( xs > 1 && block[xs-1][ys] == block[xs][ys] && !oblock[xs-1][ys] ){ go( xs-1,ys ); }\n\tif ( ys > 1 && block[xs][ys-1] == block[xs][ys] && !oblock[xs][ys-1] ){ go( xs,ys-1 ); }\n\tif ( xs < w && block[xs+1][ys] == block[xs][ys] && !oblock[xs+1][ys] ){ go( xs+1,ys ); }\n\tif ( ys < h && block[xs][ys+1] == block[xs][ys] && !oblock[xs][ys+1] ){ go( xs,ys+1 ); }\n}\n\nint main() {\n\twhile ( cin >> w && cin >> h ) {\n\t\tif ( !(w + h) )\tbreak;\n\t\t//各ブロックの初期化\n\t\tfor ( int i = 0; i < w; i++ ) {\n\t\t\tfor ( int j = 0; j < h; j++ ) {\n\t\t\t\tblock[i][j] = 0;\n\t\t\t\toblock[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint n,xs,ys;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\t//各ブロックの情報の入力\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint tate,yoko;\n\t\t\tif ( d ) {yoko=2;tate=4;}\n\t\t\telse {yoko=4;tate=2;}\n\t\t\t//カラーの入力\n\t\t\tfor ( int j = x; j < x + yoko; j++ ) {\n\t\t\t\tfor ( int k = y; k < y + tate; k++ ) {\n\t\t\t\t\tblock[j][k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for ( int i = 0; i < w; i++ ) {\n\t\t\tfor ( int j = 0; j < h; j++ ) {\n\t\t\t\tcout << block[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;*/\n\t\t//経路探索\n\t\tif ( block[xs][ys] )\tgo ( xs, ys );\n\t\tif ( oblock[xg][yg] )\tcout << \"OK\" << endl;\n\t\telse\tcout << \"NG\" << endl;\n\t\t/*for ( int i = 0; i < w; i++ ) {\n\t\t\tfor ( int j = 0; j < h; j++ ) {\n\t\t\t\tcout << oblock[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvoid PutBlock(vector< vector<int> >&, int, int, int, int);\nvoid CheckMaze1(vector< vector<int> >&, int&, int, int, int, int, int);\nvoid CheckMaze2(vector< vector<int> >&, int&, int, int, int, int, int);\n\nint main(){\n  int i, w, h, n, xs, ys, xg, yg, c, d, x, y, color, ans;\n  vector<int> _data;\n  vector< vector<int> > data;\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(i=0; i<w; ++i)\n      _data.push_back(0);\n\n    for(i=0; i<h; ++i)\n      data.push_back(_data);\n\n    cin >> ys >> xs;\n    cin >> yg >> xg;\n    --xs;\n    --xg;\n    --ys;\n    --yg;\n\n    cin >> n;\n\n    for(i=0; i<n; ++i){\n      cin >> c >> d >> y >> x;\n      PutBlock(data, c, d, x-1, y-1);\n    }\n\n    color = data[xs][ys];\n\n    ans = 0;\n    CheckMaze1(data, ans, color, xs, ys, xg, yg);\n\n    if(ans == 1)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n\n    _data.clear();\n    data.clear();\n  }\n\n  return 0;\n}\n\nvoid PutBlock(vector< vector<int> >& data, int c, int d, int x, int y){\n  int i, j;\n  if(d == 0){\n    for(i=x; i<x+2; ++i){\n      for(j=y; j<y+4; ++j)\n\tdata[i][j] = c;\n    }\n  }else{\n    for(i=x; i<x+4; ++i){\n      for(j=y; j<y+2; ++j)\n\tdata[i][j] = c;\n    }\n  }\n}\n\nvoid CheckMaze1(vector< vector<int> >& data, int& ans, int color, int x, int y, int xg, int yg){\n  data[x][y] = -1;\n  if(x == xg && y == yg) ans = 1;\n\n  CheckMaze2(data, ans, color, x-1, y, xg, yg);\n  CheckMaze2(data, ans, color, x, y-1, xg, yg);\n  CheckMaze2(data, ans, color, x+1, y, xg, yg);\n  CheckMaze2(data, ans, color, x, y+1, xg, yg);\n}\n\nvoid CheckMaze2(vector< vector<int> >& data, int& ans, int color, int x, int y, int xg, int yg){\n  if(x > -1 && x < data.size() && y > -1 && y < data[0].size() && data[x][y] == color)\n    CheckMaze1(data, ans, color, x, y, xg, yg);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n \nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[128][128];\nbool mem[128][128];\nint xg,yg;\nint w,h;\nvoid dfs(int x,int y,int col){\n    if(x < 1 || y < 1 || x > h || y > w)return ;\n    if(mem[x][y])return ;\n    if(stage[x][y] != col)return ;\n    mem[x][y] = true;\n    rep(i,4){\n        if(col == stage[x+dx[i]][y+dy[i]]){\n            dfs(x + dx[i], y + dy[i], col);\n        }\n    }\n    return ;\n}\nint main(){\n    while(scanf(\"%d%d\",&w,&h),w|h){\n        memset(stage,0,sizeof(stage));\n        rep(i,128)rep(j,128)mem[i][j] = false;\n        int xs,ys;\n        scanf(\"%d%d\",&xs,&ys);\n        scanf(\"%d%d\",&xg,&yg);\n         \n        int n;\n        scanf(\"%d\",&n);\n \n        rep(q,n){\n            int c,d,x,y;\n            scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n            if(d == 0){\n                reps(i,x,x+4){\n                    reps(j,y,y+2){\n                        stage[j][i] = c;\n                    }\n                }\n            }\n            else{\n                reps(i,x,x+2){\n                    reps(j,y,y+4){\n                        stage[j][i] = c;\n                    }\n                }\n            }\n        }\n        dfs(xs,ys,stage[xs][ys]);\n        bool f = mem[xg][yg];\n        (f) ? puts(\"OK\") : puts(\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    goal=0;\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==0 && h==0)break;\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    else if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  if(scolor==mass[gy][gx]){\n  \n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n  }\n  else {\n    cout<<\"NG\"<<endl;\n  }\n\n  }\n  \n  return 0;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ANSWER(x) cout<<x<<endl\n#define debug(x) cout<<#x<<\": \"<<x\nconst int BA = 1000;\nconst int INFTY = (1<<21);\nint xg,yg,w,h,gc;\nint maps[101][101];\nint solve(int ys,int xs);\nint main(){\n  int tate[2] = {2,4},yoko[2] = {4,2};\n  int xs,ys,n;\n  int c[101],d[101],x[101],y[101];\n  while(1){\n    fill(maps[0],maps[101],0);\n    cin >> w >> h;\n    if(!w && !h)break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    xs--;ys--;xg--;yg--;\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n      x[i]--;y[i]--;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=y[i];j<y[i]+tate[d[i]];j++){\n\tfor(int k=x[i];k<x[i]+yoko[d[i]];k++){\n\t  if(j == ys && k == xs)gc = c[i];\n\t  maps[j][k] = c[i];\n\t}\n      }\n    }\n    if(solve(ys,xs))cout << \"OK\\n\";\n    else cout << \"NG\\n\";\n  }\n}\nint solve(int ys,int xs){\n  if(xs < 0 || ys < 0 || xs > w-1 || ys > h-1 || !maps[ys][xs] || maps[ys][xs] != gc){\n    return 0;\n  }\n  else if(ys == yg && xs == xg){\n    return 1;\n  }\n  maps[ys][xs] = 0;\n  return solve(ys+1,xs) + solve(ys,xs+1)+ solve(ys-1,xs) + solve(ys,xs-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tint w, h;\n\twhile( cin >> w >> h && ( w || h ) ){\n\t\tint* map = new int[ ( w + 2 ) * ( h + 2 ) ]();\n\t\tint xs, ys, xg, yg;\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tfor( int j = 0; j < 2; ++j ){\n\t\t\t\tif( d == 0 ) x += ( 2 * j );\n\t\t\t\telse y += ( 2 * j );\n\t\t\t\tfor( int k = y; k < y + 2; ++k ){\n\t\t\t\t\tfor( int m = x; m < x + 2; ++m ){\n\t\t\t\t\t\tmap[ k * ( w + 2 ) + m ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = false;\n\t\tint cs, cg;\n\t\tcs = map[ ys * ( w + 2 ) + xs ];\n\t\tcg = map[ yg * ( w + 2 ) + xg ];\n\t\tif( !( cs == 0 || cg == 0 || cs != cg ) ){\n\t\t\tqueue< pair< int, int > > q;\n\t\t\tq.push( make_pair( xs, ys ) );\n\t\t\twhile( !q.empty() ){\n\t\t\t\tint x = q.front().first;\n\t\t\t\tint y = q.front().second;\n\t\t\t\tq.pop();\n\t\t\t\tif( x == xg && y == yg ){\n\t\t\t\t\tans = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmap[ y * ( w + 2 ) + x ] = 0;\n\t\t\t\tfor( int i = 0; i < 4; ++i ){\n\t\t\t\t\tint nx = x + dx[ i ];\n\t\t\t\t\tint ny = y + dy[ i ];\n\t\t\t\t\tif( map[ ny * ( w + 2 ) + nx ] == cs ){\n\t\t\t\t\t\tq.push( make_pair( nx, ny ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ( ans ? \"OK\" : \"NG\" ) << endl;\n\t\tdelete[] map;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nvvi tmp;\nint q;\nint dx[]={0,0,1,-1};\nint dy[]={-1,1,0,0};\nvoid solve(int x,int y){\n\ttmp[x][y]=-1;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(tmp[nx][ny]==q){solve(nx,ny);}\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tvvi in(n+2,vi(m+2));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tcin>>n;\n\t\twhile(n--){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tif(!b)rep(i,4)rep(j,2)in[c+i][d+j]=a;\n\t\t\telse rep(i,2)rep(j,4)in[c+i][d+j]=a;\n\t\t}\n\t\ttmp=in;\n\t\t//rep(i,in.size()){rep(j,in[0].size())cout<<in[i][j]<<\" \";cout<<endl;}\n\t\tif(in[sx][sy]){\n\t\t\tq=in[sx][sy];\n\t\t\tsolve(sx,sy);\n\t\t}\n\t\t//cout<<endl;\n\t\t//rep(i,tmp.size()){rep(j,tmp[0].size())cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t\tcout<<((tmp[gx][gy]==-1)?\"OK\":\"NG\")<<endl;\n\t\t//rep(i,22){rep(j,22)cout<<tmp[i][j]<<\" \";cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 100;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\n\nvoid dfs(int y, int x){\n    maze[y][x] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[ny][nx] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) { flag = 1; return; }\n                dfs(ny, nx);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[y-1+dy][x-1+dx] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[y-1+dy][x-1+dx] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[ys-1][xs-1]) maze[i][j] = 0;\n    //debugの為に出力\n    /*\n    for(int i=0; i < w; i++){\n        for(int j=0; j < h; j++) cout << maze[i][j];\n        cout << endl;\n    }\n    */\n    //search\n    dfs(ys-1, xs-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint minDist(const vector<vector<int> >& plane, char road, int y1, int x1, int y2, int x2)\n{\n    int dy[] = {0, 0, -1, 1};\n    int dx[] = {-1, 1, 0, 0};\n\n    int h = plane.size();\n    int w = plane[0].size();\n\n    queue<pair<int, int> > q;\n    vector<vector<bool> > check(h, vector<bool>(w, false));\n    q.push(make_pair(y1, x1));\n    check[y1][x1] = true;\n    int ret = 0;\n    while(!q.empty()){\n        queue<pair<int, int> > q1;\n        while(!q.empty()){\n            int y = q.front().first;\n            int x = q.front().second;\n            q.pop();\n            if(y == y2 && x == x2)\n                return ret;\n            for(int i=0; i<4; ++i){\n                int y0 = y + dy[i];\n                int x0 = x + dx[i];\n                if(0 <= y0 && y0 < h && 0 <= x0 && x0 < w && plane[y0][x0] == road && !check[y0][x0]){\n                    q1.push(make_pair(y0, x0));\n                    check[y0][x0] = true;\n                }\n            }\n        }\n        ++ ret;\n        q = q1;\n    }\n    return -1;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        int xs, ys, xg, yg;\n        cin >> xs >> ys >> xg >> yg;\n\n        int n;\n        cin >> n;\n        vector<vector<int> > grid(h+2, vector<int>(w+2, 0));\n        for(int i=0; i<n; ++i){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if(d == 0){\n                for(int j=0; j<2; ++j){\n                    for(int k=0; k<4; ++k){\n                        grid[y+j][x+k] = c;\n                    }\n                }\n            }else{\n                for(int j=0; j<4; ++j){\n                    for(int k=0; k<2; ++k){\n                        grid[y+j][x+k] = c;\n                    }\n                }\n            }\n        }\n\n        if(grid[ys][xs] != grid[yg][xg] || grid[ys][xs] == 0)\n            cout << \"NG\" << endl;\n        else if(minDist(grid, grid[ys][xs], ys, xs, yg, xg) == -1)\n            cout << \"NG\" << endl;\n        else\n            cout << \"OK\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<climits>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\n\nint map[150][150]={};\nint gone[150][150]={};\n\nint gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nbool dfs(int nx,int ny){\n\tif(gone[nx][ny])return false;\n\tgone[nx][ny]=1;\n\tif(nx == gx && ny == gy)return true;\n\tbool res = false;\n\trep(i,4){\n\t\tint tx = nx+dx[i],ty=ny+dy[i];\n\t\tif(map[tx][ty]!=map[nx][ny])continue;\n\t\tres |= dfs(tx,ty);\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tint w,h;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\tint sx,sy,n;\n\t\tscanf(\"%d%d%d%d%d\",&sx,&sy,&gx,&gy,&n);\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(gone,0,sizeof(gone));\n\t\trep(i,n){\n\t\t\tint c,d,nx,ny;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&nx,&ny);\n\t\t\tint fx=2,fy=4;\n\t\t\tif(d==0)swap(fx,fy);\n\t\t\trep(x,fx)rep(y,fy){\n\t\t\t\tmap[x+nx][y+ny]=c;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\trep(y,20)rep(x,20){\n\t\t\tprintf(\"%d%c\",map[x][y],x==19?'\\n':' ');\n\t\t}*/\n\t\tif(dfs(sx,sy))printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint ans=0;\n\nvoid set(int C2, int D2, int X2, int Y2){\n\tswitch(D2){\n\t\t\t\tcase 0:\n\t\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t\t\t\tF[Y2+i][X2+j] = C2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\t\tfor(int l=0; l<2; l++){\n\t\t\t\t\t\t\tF[Y2+k][X2+l] = C2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\treturn ;\n\t\t\t\n}\n\n\n\n\n\nvoid maze(int C, int D, int X, int Y){\n\tswitch(C){\n\t\tcase 1:\n\t\t\tset(C, D, X, Y);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tset(C, D, X, Y);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tset(C, D, X, Y);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tset(C, D, X, Y);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tset(C, D, X, Y);\n\t\t\tbreak;\n\t\n\t}\n\n\treturn ;\n\t\n}\n\nvoid judge(int X, int Y, int XG, int YG, int A){\n\t\n\tif(A==0)\n\t\treturn;\n\t\n\tcout << F[Y][X] << endl;\n\t\n\t\n\tif(F[YG][XG]==A)\n\t\tans = 1;\n\t\n\tif(F[Y][X]!=A)\t\t//　再帰関数が停止する条件\n\t\treturn;\n\t\t\n\tF[Y][X] = 7;\n\t\n\tjudge(Y-1, X  , XG, YG, A);\t\t//　上\n\t\n\tjudge(Y  , X+1, XG, YG, A);\t\t//　右\n\t\n\tjudge(Y+1, X  , XG, YG, A);\t\t//　下\n\t\n\tjudge(Y  , X-1, XG, YG, A);\t\t//　左\n\t\n\n}\n\n\nint main()\n{\n\n\tint w, h;\n\tint xs, ys;\n\tint xg, yg;\n\tint n;\n\tint c, d, x, y;\n\t\n\twhile(1){\n\t\n\tcin >> w >> h;\n\t\n\tif(w==0 && h==0)\n\t\treturn 0;\n\t\n\tcin >> xs >> ys;\n\tcin >> xg >> yg;\n\tcin >> n;\n\t\n\t\n\t\n\t\n\tfor(int i=0; i<102; i++){\n\t\tfor(int j=0;j<102; j++){\n\t\t\tF[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<n; i++){\n\t\tcin >> c >> d >> x >> y;\n\t\tmaze(c, d, x, y);\n\t\n\t}\n\t \n\tfor(int i=1; i<=h; i++){\n\t\tfor(int j=1;j<=w; j++){\n\t\t\tcout << F[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t\t\t \n\tans = 0;\n\t\t\t \n\t\t\t \n\tint a = F[xs][ys];\n\t\t\t \n\tjudge(xs, ys, xg, yg, a);\n\t\n\tif(ans==1)\n\t\tcout << \"OK\" << endl;\n\t\t\n\telse\n\t\tcout << \"NG\" << endl;\n\t\t\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint weight, hight;\nint g[101][101] = {0};\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, 1, -1};\nconst int vy[4] = {1, -1, 0, 0};\n \nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n    \n    if(g[y][x] == 0){\n        flag = false;\n        return;\n    }\n    \n    g[y][x] = -1;\n    \n    for(int i = 0;i < 4;i++){\n        int nx = x + vx[i];\n        int ny = y + vy[i];\n         \n        if(nx >= 0 && nx < weight && ny >= 0 && ny < hight && g[ny][nx] == sc){\n            dfs(nx, ny);\n        }\n    }\n    return;\n}\n \nint main(){\n    while(1){\n        int n, c, d, x, y;\n        flag = false;\n        g[101][101] = {0};\n        \n        cin >> weight >> hight;\n        \n        if(weight == 0 && hight == 0){\n            break;\n        }\n         \n        cin >> sx >> sy >> gx >> gy >> n;\n        sx--; sy--; gx--; gy--;\n         \n        for(int i = 0;i < n;i++){\n            cin >> c >> d >> x >> y;\n            x--; y--;\n             \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n         \n        sc = g[sy][sx];\n        dfs(sx, sy);\n         \n        if(flag){\n            cout << \"OK\" << endl;\n        }else{\n            cout << \"NG\" << endl;\n        }\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nconst int dy[4] = {-1, 1, 0, 0};\nconst int dx[4] = {0, 0, -1, 1};\nconst int MAX_W = 102, MAX_H = 102;\nint maze[MAX_H][MAX_W];\nint w, h, xs, ys, xg, yg, color;\n\nvoid solve() {\n  memset(maze, 0, sizeof maze);\n  int n;\n  cin>>xs>>ys>>xg>>yg>>n;\n  rep(i,n) {\n    int c, d, x, y;\n    cin>>c>>d>>x>>y;\n    //cout<<c<<d<<x<<y<<endl;\n    if (d == 0) {\n      REP(j,x,x+4) REP(k,y,y+2) maze[k][j] = c;\n    } else {\n      REP(j,x,x+2) REP(k,y,y+4) maze[k][j] = c;\n    }\n  }\n  \n  /*\n  rep(i,h+1) {\n    rep(j,w+1) cout<<maze[i][j];\n    cout<<endl;\n  }*/\n  \n  if (maze[ys][xs] == 0) {\n    cout<<\"NG\"<<endl;\n    return;\n  } else {\n    color = maze[ys][xs];\n  }\n  \n  bool flag = false;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while (!que.empty() && !flag) {\n    P p = que.front(); que.pop();\n    int tx = p.first, ty = p.second;\n    if (tx == xg && ty == yg) {\n      flag = true; continue;\n    }\n    if (maze[ty][tx] == 0) continue;\n    maze[ty][tx] = 0;\n    \n    rep(z,4) {\n      int ttx = tx + dx[z], tty = ty + dy[z];\n      if (ttx < 1 || tty < 1 || ttx > w || tty > h) continue;\n      if (maze[tty][ttx] != color) continue;\n      que.push(P(ttx, tty));\n    }\n  }\n  \n  if (flag) {\n    cout<<\"OK\"<<endl;\n  } else {\n    cout<<\"NG\"<<endl;\n  }\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>w>>h, w||h) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 100 ] )\n{\n\tcame[ y ][ x ] = false ;\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 100 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 100 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h ,w & h )\n\t{\n\t\tbool came[ 100 ][ 100 ] = { false } ;\n\t\tint map[ 100 ][ 100 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint board[100][100],w,h,xg,yg;\nbool f(int y,int x){\n\tboard[y][x] = 0;\n\tint dy[] = {-1,0,0,1},dx[] = {0,-1,1,0},i;\n\tif(y == yg - 1 && x == xg -1) return true;\n\tfor(i = 0;i < 4;i++){\n\t\tif(y + dy[i] > -1 && y + dy[i] < h && x + dx[i] > -1 && x + dx[i] < w){\n\t\t\tif(board[y+dy[i]][x+dx[i]] == 2){\n\t\t\t\tif(f(y+dy[i],x+dx[i])) return true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint xs,ys,n,i,c,d,x,y,j,k;\n\twhile(cin >> w >> h && (w != 0 && h != 0)){\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx -= 1;\n\t\t\ty -= 1;\n\t\t\tif(d == 0){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+j][x+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 1){\n\t\t\t\tfor(j = 0;j < 2;j++){\n\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\tboard[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(board[ys - 1][xs - 1] == 2){\n\t\t\tif(f(ys - 1,xs -1)) cout << \"OK\" << endl;\n\t\t\telse cout << \"NG\" << endl;\n\t\t}\n\t\telse cout << \"NG\" << endl;\n\t\tfor(j = 0;j < 100;j++){\n\t\t\tfor(i = 0;i < 100;i++){\n\t\t\t\tboard[j][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nstruct UnionFind{\n    vector<int> par; // 親\n    vector<int> rank; // 木の深さ\n    int size;\n    UnionFind(int n){\n        REP(i,n) par.push_back(i);\n        rank = vector<int>(n);\n        size=n;\n    }\n    int root(int x){\n        if(par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    bool same(int x,int y){\n        return root(x) == root(y);\n    }\n    void unite(int x,int y){\n        x = root(x);y = root(y);\n        if(x==y)return;\n        if(rank[x] < rank[y])par[x] = y;\n        else par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        size--;\n    }\n};\n\nint INF=1<<28;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\n\nint enc(int y,int x){\n\treturn y*w+x;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0)break;\n\t\tvector<vector<int>> map(h,vector<int>(w));\n\t\tint xs,ys;cin >> xs >> ys;xs--;ys--;\n\t\tint xg,yg;cin >> xg >> yg;xg--;yg--;\n\t\tint n;cin >> n;\n\t\tREP(i,n){\n\t\t\tint c,d,x,y;cin >> c >> d >> x >> y;x--;y--;//d=0 2×4 d=1 4×2 (H*W)\n\t\t\tif(d==0){\n\t\t\t\tREP(dy,2)REP(dx,4){\n\t\t\t\t\tmap[y+dy][x+dx]=c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tREP(dy,4)REP(dx,2){\n\t\t\t\t\tmap[y+dy][x+dx]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(h*w);\n\t\tREP(y,h)REP(x,w){\n\t\t\tREP(di,4){\n\t\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\t\tif(!IN(0,nx,w) || !IN(0,ny,h) )continue;\n\t\t\t\tif(map[y][x]==map[ny][nx]){\n\t\t\t\t\tuf.unite(enc(y,x),enc(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(uf.same(enc(ys,xs),enc(yg,xg))){\n\t\t\tcout <<\"OK\"<<endl;\n\t\t}else{\n\t\t\tcout <<\"NG\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[101][101]={{0},{0}};\nconst int START=4545191;\nconst int GOAL=454545;\nconst int CHECKED=432535;\n\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(ban[x][y+1]==CHECKED&&ban[x+1][y]==CHECKED)return false;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[x+1][y]==c){\n\t\t\tban[x+1][y]=CHECKED;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c){\n\t\t\tban[x][y+1]=CHECKED;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0;\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint w, h;\nint sx, sy;\nint gx, gy;\nint n;\nint field[120][120];\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(field, 0);\n    scanf(\"%d %d\", &sx, &sy);\n    scanf(\"%d %d\", &gx, &gy);\n    scanf(\"%d\", &n);\n    REP(i, n) {\n      int c, d, sx, sy;\n      scanf(\"%d %d %d %d\", &c, &d, &sx, &sy);\n      int ex = sx + 2;\n      int ey = sy + 2;\n      if (d == 0) { ex += 2; }\n      if (d == 1) { ey += 2; }\n      FOR(y, sy, ey) {\n        FOR(x, sx, ex) {\n          field[y][x] = c;\n        }\n      }\n    }\n    int sc = field[sy][sx];\n    queue<int> que;\n    que.push(sy * w + sx);\n    while (!que.empty()) {\n      if (sc == 0) { break; }\n      int x = que.front() % w;\n      int y = que.front() / w;\n      que.pop();\n      if (x == gx && y == gy) {\n        puts(\"OK\");\n        goto next;\n      }\n      REP(dir, 4) {\n        const int dx[4] = { 1, 0, -1, 0 };\n        const int dy[4] = { 0, 1, 0, -1 };\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n        if (field[ny][nx] != sc) { continue; }\n        field[ny][nx] = 9;\n        que.push(ny * w + nx);\n      }\n    }\n    puts(\"NG\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint Array[200][200];\n#define START 20\n\nvoid DFS(int h,int w,int c){\n\n    if(Array[h][w] != c || Array[h][w] == 0 || Array[h][w] == 6){\n      return;\n    }\n\n    int tmp=Array[h][w];\n\n    Array[h][w] = 6;\n\n    DFS(h-1,w,tmp);\n    DFS(h,w+1,tmp);\n    DFS(h+1,w,tmp);\n    DFS(h,w-1,tmp);\n\n\n}\n\nint main(){\n\n    while(1){\n      int H,W;\n      int Start[2],Goal[2];\n      int BlockNum;\n      int color,dir,xpos,ypos;\n\n\n      for(int i=0;i<200;i++){\n        for(int j=0;j<200;j++){\n          Array[i][j] = 0;\n        }\n      }\n\n      cin >> H >> W;\n\n      if(H == 0 && W == 0){\n        break;\n      }\n\n      cin >> Start[0] >> Start[1];\n\n      cin >> Goal[0] >> Goal[1];\n\n      cin >> BlockNum;\n\n      for(int i=0;i<BlockNum;i++){\n        cin >> color >> dir >> xpos >> ypos;\n        for(int i=0;i<4;i++){\n          for(int j=0;j<2;j++){\n            if(!dir){//?¨?\n              Array[xpos+i][ypos+j] = color;\n            }\n            else{\n              Array[xpos+j][ypos+i] = color;\n            }\n          }\n        }\n      }\n\n      /*for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          cout << Array[i][j];\n        }\n        cout << endl;\n      }*/\n      if(Array[Start[0]][Start[1]] != 0){\n        DFS(Start[0],Start[1],Array[Start[0]][Start[1]]);\n      }\n      if(Array[Goal[0]][Goal[1]] == 6){\n        cout << \"OK\" << endl;\n      }\n      else{\n        cout << \"NG\" << endl;\n      }\n\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\tif(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n\n      if(d[i]==0 && c[i]==cbase){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1 && c[i]==cbase){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans == 1){\n      cout << \"OK\" << endl;\n    }\n    if(ans != 1 || c[xs][ys] == 0){\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, j) FOR(i, 0, j)\n#define rep2(i, k) for(int i = 1; i <= k; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define INF (1 << 30)\n\nusing namespace std;\n \nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint field[105][105];\nint h, w, sx, sy, gx, gy, n;\nint col, dire, x, y;\nint scol;\n\nbool dfs(int nx, int ny) {\n\tfield[ny][nx] = 0;\n\tif(nx == gx && ny == gy) return true;\n\trep(i, 4) {\n\t\tint tx = nx + dx[i];\n\t\tint ty = ny + dy[i];\n\t\tif(tx <= w && tx > 0 && ty <= h && field[ty][tx] == scol) dfs(tx, ty);\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tint scol = 0;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(k, n) {\n\t\t\tcin >> col >> dire >> x >> y;\n\t\t\tif(dire) {\n\t\t\t\trep(i, 4) rep(j, 2) field[y + i][x + j] = col;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(i, 2) rep(j, 4) field[y + i][x + j] = col;\n\t\t\t}\n\t\t\t//rep(j, (dire?4:2)) rep(k, (dire?2:4)) field[x + j][y + k] = col;\n\t\t}\n\t\tscol = field[sx][sy];\n\t\t/*rep(i, h + 1){\n\t\t\trep(j, w + 1) cout << field[i][j] << \" \";\n\t\t\tputs(\"\");\n  \t\t}*/\n\t\tif(dfs(sx, sy) || field[y][x] != 0) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl; \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint map[110][110];\nint com[110][110];\nint lx,ly,sx,sy,gx,gy;\nint py[4]={1,0,-1,0};\nint px[4]={0,1,0,-1};\nint fl;\nint mei(int zx,int zy ,int cei[][110])\n{\n\tint i;\n\tif(fl) return 0;\n\tif(zx==gx && zy==gy)\n\t{\n\t\tfl=1;\n\t\treturn 0;\n\t}\n\tcei[zy][zx]=1;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(cei[zy+py[i]][zx+px[i]]==0 && map[sy][sx]==map[zy+py[i]][zx+px[i]])\n\t\t{\n\t\t\tmei(zx+px[i],zy+py[i],cei);\n\t\t\t\n\t\t}\n\t}\n\tcei[zy][zx]=0;\n\treturn 0;\n}\nint main()\n{\n\tint n,col,muk,vx,vy;\n\tint i,j,t;\n\twhile(cin >> lx >> ly, lx)\n\t{\n\t\tfl=0;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(com,0,sizeof(com));\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tcin >> col >> muk >> vx >> vy;\n\t\t\tif(muk==0)\n\t\t\t{\n\t\t\t\tfor(j=vy;j<2+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<4+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(j=vy;j<4+vy;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(t=vx;t<2+vx;t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[j][t]=col;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx])\n\t\t{\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmei(sx,sy,com);\n\t\tif(fl) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\tboard.at(x+i).at(y+j) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if( nx==xg && ny==yg) flag = 1;\n  else if( w<=nx+1 || h<=ny+1) return;\n  if(board[nx][ny]==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if(board[nx][ny]==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  string res;\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      object[i].write(board);\n    }\n    func(board,xs,ys);\n    if(flag==1) res = \"OK\";\n    else res = \"NG\";\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<list>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define debug(x) cout << x << endl;\nusing namespace std;\n\nint xstart, ystart;\nint xgoal, ygoal;\nint load;\nbool check;\n\nint answer(int maze[][1000], int x, int y){\n    if(load == maze[x][y]){\n        maze[x][y] = 0;\n    }else{\n        return 0;\n    }\n    if(x == xgoal && y == ygoal){\n        cout << \"OK\" << endl;\n        check = true;\n        return 1;\n    }\n    answer(maze, x+1,y);\n    answer(maze, x,y+1);\n    answer(maze, x,y-1);\n    answer(maze, x-1,y);\n}\n\nint main(){\n    int width, height;\n    int n;\n    int color, direction, x, y;\n\n    while(cin >> width >> height, height){\n        int maze[1000][1000];\n        check = false;\n        cin >> xstart >> ystart >> xgoal >> ygoal >> n;\n        rep(i,n){\n            cin >> color >> direction >> x >> y;\n            if(direction == 0){\n                maze[x][y] = color;\n                maze[x+1][y] = color;\n                maze[x+2][y] = color;\n                maze[x+3][y] = color;\n                maze[x][y+1] = color;\n                maze[x+1][y+1] = color;\n                maze[x+2][y+1] = color;\n                maze[x+3][y+1] = color;\n            }else{\n                maze[x][y] = color;\n                maze[x][y+1] = color;\n                maze[x][y+2] = color;\n                maze[x][y+3] = color;\n                maze[x+1][y+1] = color;\n                maze[x+1][y+2] = color;\n                maze[x+1][y+3] = color;\n                maze[x+1][y+4] = color;\n            }\n        }\n        load = maze[xstart][ystart];\n        answer(maze, xstart, ystart);\n        if(check == false){\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint dy[] = {-1, 0, 0, 1};\nint dx[] = {0, -1, 1, 0};\nint w, h;\npii s, g;\nint n;\nint f[110][110];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> w >> h, w) {\n    cin >> s.second >> s.first;\n    s.second--, s.first--;\n    cin >> g.second >> g.first;\n    g.second--, g.first--;    \n    cin >> n;\n    for (int i = 0; i < n; i++) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--, y--;\n      if (d == 0) {\n        for (int j = 0; j < 2; j++) {\n          for (int k = 0; k < 4; k++) {\n            f[y + j][x + k] = c;\n          }\n        }\n      } else {\n        for (int j = 0; j < 4; j++) {\n          for (int k = 0; k < 2; k++) {\n            f[y + j][x + k] = c;\n          }\n        }\n      }\n    }\n    if (f[s.first][s.second] == 0) {\n      cout << \"NG\" << endl;\n      continue;\n    }\n    bool used[110][110] = {};\n    used[s.first][s.second] = true;\n    queue<pii> que;\n    que.emplace(s);\n    while (!que.empty()) {\n      pii u = que.front(); que.pop();\n      int y = u.first, x = u.second;\n      for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w && f[ny][nx] == f[y][x] && !used[ny][nx]) {\n          used[ny][nx] = true;\n          que.emplace(ny, nx);\n        }\n      }\n    }\n    cout << (used[g.first][g.second] ? \"OK\" : \"NG\") << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tflag = true;return;\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint board[101][101];\nint h,w;\nint xs,ys,xg,yg;\nint n;\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nbool search(int c,int y,int x){\n\tif(y<1||h<y||x<1||w<x||c!=board[y][x])return false;\n\tif(y==yg&&x==xg)return true;\n\tboard[y][x]=0;\n\tfor(int i=0;i<4;i++)\n\t\tif(search(c,y+dy[i],x+dx[i]))return true;\n\treturn false;\n}\nint main(){\n\twhile(cin>>w>>h,w|h){\n\t\tint c,d,x,y;\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\tfill_n((int*)board,sizeof(board)/sizeof(int),0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tint dx=2,dy=2;\n\t\t\tif(d==0)dx=4;\n\t\t\telse dy=4;\n\t\t\tfor(int i=0;i<dy;i++)\n\t\t\t\tfor(int j=0;j<dx;j++)\n\t\t\t\t\tboard[y+i][x+j]=c;\n\t\t}\n\t\tif(board[ys][xs]!=0 && board[yg][xg]!=0 && search(board[ys][xs],ys,xs))cout<<\"OK\\n\";\n\t\telse cout<<\"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nbool flag;\nint n,sx,sy,gx,gy,col;\n\nvoid erase(int** field){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y, int** field){\n\tint xx = x+1;\n\tint yy = y;\n\n\tif(xx == gx && yy == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy, field);\n\tif(flag)\n\t\treturn;\n\n\txx = x;\n\tyy = y+1;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy, field);\n\tif(flag)\n\t\treturn;\n\n\txx = x-1;\n\tyy = y;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy, field);\n\tif(flag)\n\t\treturn;\n\t\t\t\n\txx = x;\n\tyy = y-1;\n\tif(field[yy][xx] == col)\n\t\tDFS(xx, yy, field);\n}\n\nint main(){\n\tint field[102][102];//y,x\n\tint c,d,bx,by;\n\tusing std::cin;\n\twhile(true){\n\t\tflag = false;\n\t\terase(field);\n\t\tcin >> c >> d;\n\t\tif(!c && !d)\n\t\t\treturn 0;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tif(d==0){\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+4; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int k=bx; k<bx+2; k++)\n\t\t\t\t\t\tfield[h][k] = c;\n\t\t\t}\n\t\t}\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy, field);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 105\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x <= w && 0 <= y && y <= h && map[x][y] == color){\n\t\t\tmap[x][y] = 9;\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> h >> w;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> ys >> xs;\n\t\tcin >> yg >> xg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0; i < w; i++){\n\t\t\tfor(int j=0; j < h; j++){\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=9;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n,count=0;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==9)\n\t\tcout<<\"OK\"<<endl;\n\telse\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\nusing namespace std;\nclass point {\npublic:\n\tint color;\n\tbool used;\n\tpoint():color(-1),used(false){}\n};\nint main() {\n\tint X, Y;\n\tint make[][2] = { {2,4},{4,2} };\n\twhile (cin >> X >> Y&&X != 0) {\n\t\tvector<vector<point> > map(X + 2, vector<point>(Y + 2));\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint color, d, x, y;\n\t\t\tcin >> color >> d >> x >> y;\n\t\t\tfor (int dx = 0; dx < make[d][1]; ++dx) {\n\t\t\t\tfor (int dy = 0; dy < make[d][0]; ++dy) {\n\t\t\t\t\tmap[x + dx][y + dy].color = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<pair<int, int> > st;\n\t\tif (map[sx][sy].color != -1) {\n\t\t\tst.push(pair<int, int>(sx, sy));\n\t\t}\n\t\tint mx[] = { 1,0,-1,0 }, my[] = { 0,1,0,-1 };\n\t\twhile (!st.empty()) {\n\t\t\tpair<int,int> dummy = st.top(); st.pop();\n\t\t\tif (map[dummy.first][dummy.second].used)continue;\n\t\t\tmap[dummy.first][dummy.second].used = true;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint x = dummy.first + mx[i];\n\t\t\t\tint y = dummy.second + my[i];\n\t\t\t\tif (map[dummy.first][dummy.second].color == map[x][y].color&&map[x][y].used == false) {\n\t\t\t\t\tst.push(pair<int, int>(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (map[gx][gy].used ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+9\n#define EPS 1e-9\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < (k); i++)\ntypedef long long ll;\nint stage[128][128];\nint xg,yg;\nint w,h;\nbool dfs(int x,int y,int col){\n\tif(x == xg && y == yg && stage[x][y] == col){\n\t\treturn true;\n\t}\n\trep(i,4){\n\t\tif(stage[x+dx[i]][y+dy[i]] == 0)continue;\n\t\tif(col == stage[x+dx[i]][y+dy[i]]){\n\t\t\treturn dfs(x + dx[i], y + dy[i], col);\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w|h){\n\t\tmemset(stage,0,sizeof(stage));\n\t\tint xs,ys;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\n\t\trep(q,n){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\treps(i,x,x+4){\n\t\t\t\t\treps(j,y,y+2){\n\t\t\t\t\t\tstage[j][i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\treps(i,x,x+2){\n\t\t\t\t\treps(j,y,y+4){\n\t\t\t\t\t\tstage[j][i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t(dfs(xs,ys,stage[xs][ys])) ? puts(\"OK\") : puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nbool b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nvoid dfs(int a[][200] ,int x , int y , int w , int h , int xg , int yg , int sc){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(a[tx][ty]!=sc || a[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( a,tx,ty,w,h,xg,yg,sc);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tint board[200][200]={0};\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs(board , xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\nvoid DFC(int y,int x);\nvoid block_set(int c,int d,int x,int y);\nint cs;\nint xg,yg;\nbool result = false;\n\nint main(){\n  int H,W;\n  while(1){\n    result = false;\n    cin >> H >> W;\n    if(H==0&&W==0)\n      break;\n    int xs,ys;\n    cin >> xs >> ys >> xg >> yg;\n    int n;\n    cin >> n;\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(i==0)\n        cs = c;\n        block_set(c,d,x,y);\n    }\n\n    DFC(xs,ys);\n\n    if(result)\n      cout << \"YES\" << endl;\n      else\n      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}\n\nvoid DFC(int x,int y){\n  if(F[x][y]!=cs)\n    return;\n\n  if(x==xg,y==yg)\n    result = true;\n\n  F[x][y]=0;\n\n  DFC(x-1,y);\n  DFC(x+1,y);\n  DFC(x,y-1);\n  DFC(x,y+1);\n}\n\nvoid block_set(int c,int d,int x,int y){\n  for(int i=0;i<2;i++){\n    for(int j=0;j<4;j++){\n      if(d){\n        F[x+i][y+j] = c;\n      }\n      else{\n        F[x+j][y+i] = c;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<stack>\nstruct p{\n\tint x;\n\tint y;\n};\nusing namespace std;\nint main(){\n\tint w,h,sx,sy,gx,gy,n,c,d,x,y,i,j,k,o;\n\tint map[100][100];\n\tint used[100][100];\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tp v,u;\n\tstack<p> s;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(used,0,sizeof(used));\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx--;\n\t\tsy--;\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tgx--;\n\t\tgy--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(!d){\n\t\t\t\tfor(j=y;j<y+2;j++){\n\t\t\t\t\tfor(k=x;k<x+4;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=y;j<y+4;j++){\n\t\t\t\t\tfor(k=x;k<x+2;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx]){\n\t\t\tprintf(\"NG\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tv.x=sx;\n\t\tv.y=sy;\n\t\ts.push(v);\n\t\to=0;\n\t\twhile(!s.empty()){\n\t\t\tv=s.top();\n\t\t\ts.pop();\n\t\t\tif(used[v.y][v.x]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tused[v.y][v.x]=1;\n\t\t\t}\n\t\t\tif(v.x==gx&&v.y==gy){\n\t\t\t\to=1;\n\t\t\t\twhile(!s.empty()){\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(u.x>=0&&u.x<w&&u.y>=0&&u.y<h&&map[u.y][u.x]==map[sy][sx]){\n\t\t\t\t\ts.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int limit = 100;\nint w, h, n;\nint xs, ys, xg, yg;\nint maze[limit][limit];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint flag = 0;\n\nvoid dfs(int x, int y){\n    maze[x][y] = 0;\n    //4近傍を探索\n    for(int i=0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx and nx < h and 0 <= ny and ny < w and maze[nx][ny] != 0){\n                if(nx == (xg-1) and ny == (yg-1)) {\n                    flag = 1;\n                    return;\n                }\n                dfs(nx, ny);\n            }\n        }\n    return;\n}\n\n\nint main(){\n    while(1){\n    flag = 0;\n    cin >> w >> h;\n    if(w == 0 and h == 0) break;\n    cin >> xs >> ys >> xg >> yg >> n;\n    //ボードを初期化\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) maze[i][j] = 0;\n    //ボードにブロックを敷き詰める\n    for(int i=0; i < n; i++){\n        int c = 0, d = 0, x = 0, y = 0;\n        cin >> c >> d >> x >> y;\n        if(d)for(int dx=0; dx < 2; dx++)for(int dy=0; dy < 4; dy++) maze[x-1+dx][y-1+dy] = c;\n        else for(int dy=0; dy < 2; dy++)for(int dx=0; dx < 4; dx++) maze[x-1+dx][y-1+dy] = c;\n    }\n    //迷路を単純化する\n    for(int i=0; i < w; i++)for(int j=0; j < h; j++) if(maze[i][j] != maze[xs-1][ys-1]) maze[i][j] = 0;\n\n    //search\n    dfs(xs-1, ys-1);\n    if(flag) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nconst int MAX_W = 100, MAX_H = 100;\n\ntypedef std::pair<int,int> P;\nint map[MAX_H + 1][MAX_W + 1];\n\nint bfs(P sp, P gp, int w, int h, int c){\n\t//½±Æª é©ði[\n\tint f[MAX_H + 1][MAX_W + 1] = {{0}};\n\tstd::queue<P> q;\n\tq.push(P(sp.first, sp.second));\n\t\n\twhile(q.size()){\n\t\tP p = q.front(); q.pop();\n\t\t//S[Å«½ç¬÷\n\t\tif(p.first == gp.first && p.second == gp.second && map[p.second][p.first] == c)return 1;\n\t\t\n\t\tint vy[4] = {-1,1,0,0}, vx[4] = {0,0,-1,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx = p.first + vx[i],\n\t\t\t\tny = p.second + vy[i];\n\t\t\tif(nx >= 0 && nx <= w && ny >= 0 && ny <= h && \n\t\t\t\t map[ny][nx] == c && !f[ny][nx]){\n\t\t\t\tq.push(P(nx,ny));\n\t\t\t\tf[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t//ÅãÜÅS[Å«È¢Èç¸s\n\treturn 0;\n}\n\nint main(){\n\tint w, h, xs, ys, xg, yg;\n\twhile(std::cin >> w >> h, w&&h){\n\t\tmemset(map,0,sizeof(map));\n\t\tstd::cin >> xs >> ys;\n\t\tstd::cin >> xg >> yg;\n\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\t//ubNÌÝu\n\t\twhile(n--){\n\t\t\tint c, d, x, y;\n\t\t\tstd::cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint mx, my;\n\t\t\tif(d)//w < h\n\t\t\t\t{my = 4, mx = 2;}\n\t\t\telse//w > h\n\t\t\t\t{mx = 4, my = 2;}\n\t\t\tfor(int i=y;i<y+my;i++){\n\t\t\t\tfor(int j=x;j<x+mx;j++){\n\t\t\t\t\tmap[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//bfsÅS[Å«é©mF\n\t\tP sp = P(xs,ys), gp = P(xg,yg);\n\t\tint c = map[ys][xs];\n\t\tif(bfs(sp, gp, w, h, c))std::cout << \"OK\" << std::endl;\n\t\telse{std::cout << \"NG\" << std::endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    memset(d,0,sizeof(d));\n    C = goal = n = x = y = xs = ys = xg = yg = 0;\n\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[ys][xs];\n    //cout << \"color:\" << C << endl;\n    \n    if(C!=0 && mas[ys][xs]==mas[yg][xg]){\n\n      bfs();\n\n    \n      if(goal==1){\n\tcout << \"OK\" << endl;\n\tgoal=0;\n      }\n      else{\n\tcout << \"NG\" << endl;\n      }\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(ny>=1 && ny<=y && nx>=1 && nx<=x && mas[ny][nx]==C && d[ny][nx]==-1){\n\td[ny][nx] = 1;\n\tque.push(P(ny,nx));\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint color[200][200];\nbool flg[200][200];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint w,h,n,c,d,x,y;\n\nvoid dfs(int ny,int nx,int gy,int gx){\n\tflg[ny][nx]=true;\n\trep(i,4){\n\t\tint nex=nx+dx[i];\n\t\tint ney=ny+dy[i];\n\t\tif(nex>=w || nex<0 || ney>=h || ney<0)continue;\n\t\tif(color[ney][nex]==color[ny][nx] && flg[ney][nex]==false)dfs(ney,nex,gy,gx);\n\t}\n\treturn;\n}\n\nint main(){\n\tpair<int,int> s,g;\n\twhile(1){\n\t\trep(i,200)rep(j,200)color[i][j]=flg[i][j]=0;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)break;\n\t\tcin>>s.first>>s.second;\n\t\tcin>>g.first>>g.second;\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\trep(j,2){\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\tcolor[y-1+j][x-1+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(j,4){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tcolor[y-1+j][x-1+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(s.first-1,s.second-1,g.first-1,g.second-1);\n\t\tif(flg[g.second-1][g.first-1])cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint field[101][101];\nint dx[] = { 0,1,0,-1};\nint dy[] = { 1,0,-1,0};\nint w,h;\nint xs=1,ys=2,xg,yg;\nint num;\n\nint dfs(int x, int y){\n\n  int judge = 0,nx,ny;\n  \n  if(x == xg && y == yg){\n    return 1;\n  }\n\n  for(int i = 0;i < 4;i++){\n    nx = x + dx[i];\n    ny = y + dy[i];\n    if(nx <= w && ny <= h && 0 < nx && 0 < ny && field[ny][nx] == num && field[ny][nx] != -1){\n      field[ny][nx] = -1;\n      judge += dfs(nx,ny);\n    }\n  }  \n  \n  return judge;\n\n}\nint main(){\n\n  int n;\n  int c,d,x,y;\n  int j_max,k_max;\n  \n  while(cin >> w >> h, w | h){\n    for(int i = 0;i < 101;i++){\n      for(int j = 0;j < 101;j++){\n\tfield[i][j] = 0;\n      }\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i = 0;i < n;i++){\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n\tj_max = 2;\n\tk_max = 4;\n      }else{\n\tj_max = 4;\n\tk_max = 2;\n      }\n      for(int j = y;j < y+j_max;j++){\n\tfor(int k = x;k < x+k_max;k++){\n\t  field[j][k] = c;\n\t}\n      }\n    }\n    num = field[ys][xs];\n    \n    if(dfs( xs, ys)){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint count=0;\n\tint H,W,xg,yg,xs,ys,n;\n\tcin>>H;\n\tif(H==0)\n\t\tcount++;\n\tcin>>W;\n\tif(W==0)\n\t\tcount++;\n\tif(count==2 || H<4 || W<4)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==0)\n\t\tcout<<\"OK\"<<endl;\n\tif(F[xg][yg]!=0)\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid;\nvector <vector<bool > > grid_visited;\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool a = false;\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\tif ((nx + 1) >= 0 && ny >= 0 && (nx + 1) < h && ny < w)if (grid[nx + 1][ny] == grid[nx][ny])a |= dfs(nx + 1, ny);\n\tif (nx >= 0 && (ny + 1) >= 0 && nx < h && (ny + 1) < w)if (grid[nx][ny + 1] == grid[nx][ny])a |= dfs(nx, ny + 1);\n\tif ((nx - 1) >= 0 && ny >= 0 && (nx - 1) < h && ny < w)if (grid[nx - 1][ny] == grid[nx][ny])a |= dfs(nx - 1, ny);\n\tif (nx >= 0 && (ny - 1) >= 0 && nx < h && (ny - 1) < w)if (grid[nx][ny - 1] == grid[nx][ny])a |= dfs(nx, ny - 1);\n\t//return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn a;\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\tloop(j, w)\n\t\t\t{\n\t\t\tcout << grid[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tgrid = vector<vector<int> >(105, vector<int>(105, 0));\n\t\t\tgrid_visited = vector <vector<bool > > (105, vector<bool>(105, false));\n\t\t\ta = false;\n\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w,h;\nint sx,sy,gx,gy;\nint n,c,d,x,y;\nint g[200][200];\nbool use[200][200];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nvoid rec(int Y,int X, char c){\n  if(use[Y][X])return;\n  use[Y][X] = true;\n\n  for(int i=0;i<4;i++){\n    int ny = Y+dy[i], nx = X+dx[i];\n    if(ny<1 || nx<1 || ny>h || nx>w)continue;\n    if(g[ny][nx] == c)rec(ny,nx,c);\n  }\n}\n\nint main(){\n  while(cin >> w >> h,w||h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tg[i][j] = 0;\n\tuse[i][j] = false;\n      }\n    }\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d==0){\n\tfor(int j=0;j<2;j++){\n\t  for(int k=0;k<4;k++){\n\t    g[y+j][x+k] = c;\n\t  }\n\t}\n      }else{\n\tfor(int j=0;j<4;j++){\n\t  for(int k=0;k<2;k++){\n\t    g[y+j][x+k] = c;\n\t  }\n\t}\n      }\n    }\n\n    if(!g[sy][sx] || !g[gy][gx] || g[sy][sx] != g[gy][gx]){\n      cout << \"NG\\n\";\n    }else{\n      rec(sy,sx,g[sy][sx]);\n      cout << (use[gy][gx]?\"OK\":\"NG\") << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c || Y > w || X > h){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nclass node{\npublic:\n\tint x,y;\n\tvoid set(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n\tbool check(int w,int h){\n\t\tif(x>=0&&y>=0){\n\t\t\tif(x<=w&&y<=h) return true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n};\n\nint main(){\n\tint i,j;\n\twhile(1){\n\t\tint w,h;\n\t\tint xs,ys,xg,yg,n,c,dir,x,y;\n\t\tint color[101][101];\n\t\tint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\t\tbool visited[101][101];\n\t\tqueue<node> q;\n\t\tnode a;\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tscanf(\"%d%d\",&xs,&ys);\n\t\tscanf(\"%d%d\",&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\n\t\twhile(n--){\n\t\t\tscanf(\"%d%d%d%d\",&c,&dir,&x,&y);\n\t\t\tif(dir==0){\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+j][y+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<2;i++){\n\t\t\t\t\tfor(j=0;j<4;j++) color[x+i][y+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta.set(xs,ys);\n\t\tq.push(a);\n\t\tvisited[a.x][a.y]=true;\n\t\twhile(!q.empty()){\n\t\t\ta = q.front();\n\t\t\tq.pop();\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\ta.x += dx[i];\n\t\t\t\ta.y += dy[i];\n\t\t\t\tif(!a.check(w,h)&&(color[xs][ys]==color[a.x][a.y])&&!visited[a.x][a.y]){\n\t\t\t\t\tq.push(a);\n\t\t\t\t\tvisited[a.x][a.y] = true;\n\t\t\t\t\tif(a.x==xg&&a.y==yg) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(visited[xg][yg]) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t\tfor(i=0;i<101;i++){\n\t\t\tfor(j=0;j<101;j++) visited[i][j] = false;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nint main(){\n    int h, w;\n    while(cin >> w >> h, h){\n        int xs, ys, xg, yg;\n        int n;\n        cin >> xs >> ys >> xg >> yg >> n;\n        xs--; ys--; xg--; yg--;\n        vector<vector<int> > color(h, vector<int>(w,0));\n        for(int i=0;i<n;i++){\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--; y--;\n            for(int dy=0;dy<(d?4:2);dy++){\n                for(int dx=0;dx<(d?2:4);dx++){\n                    color[y+dy][x+dx] = c;\n                }\n            }\n        }\n        UnionFindTree uf;\n        uf.init(h*w);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(color[i][j] == 0) continue;\n                if(i+1<h && color[i][j] == color[i+1][j]){\n                    uf.unite(i*w+j, (i+1)*w+j);\n                }\n                if(j+1<w && color[i][j] == color[i][j+1]){\n                    uf.unite(i*w+j, i*w+j+1);\n                }\n            }\n        }\n        cout << (uf.is_same(ys*w+xs,yg*w+xg) ? \"OK\" : \"NG\") << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\n\nint maze[150][150];\nint W, H;\nbool flag;\n\nvoid dfs( int sx, int sy, int gx, int gy, int color ) {\n\tREP( i, 4 ) {\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\n\t\tif( nx >= 0 && nx < W && ny >= 0 && ny < H && maze[nx][ny] == color ) {\n\t\t\tif( nx == gx && ny == gy ) flag = true;\n\t\t\tmaze[nx][ny] = -1;\n\t\t\tdfs( nx, ny, gx, gy, color );\n\t\t}\n\t}\n}\n\nsigned main() {\n\twhile( cin >> W >> H, W ) {\n\t\tfill( maze[0], maze[150], -1 );\n\n\t\tint sx, sy, gx, gy, n;\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tREP( i, n ) {\n\t\t\tint color, d, x, y;\n\t\t\tcin >> color >> d >> x >> y;\n\n\t\t\tif( d == 0 ) {\n\t\t\t\tREP( i, 4 ) {\n\t\t\t\t\tmaze[x + i][y] = color;\n\t\t\t\t\tmaze[x + i][y + 1] = color;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tREP( i, 4 ) {\n\t\t\t\t\tmaze[x][y + i] = color;\n\t\t\t\t\tmaze[x + 1][y + i] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( maze[sx][sy] == -1 ) cout << \"NG\" << endl;\n\t\telse {\n\t\t\tflag = false;\n\t\t\tdfs( sx, sy, gx, gy, maze[sx][sy] );\n\t\t\tcout << ( flag ? \"OK\" : \"NG\" ) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\tusing namespace std;\n\tint xs,ys,w,h,n,ban[111][111],xg,yg;bool visited[101][101];\n\tbool dfs(int x,int y,int c){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\t\t\tif(c-1||ban[x][y]!=c)return false;\n\t\tif(xg==x&&yg==y)return true;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==c&&visited[x+1][y]==false){\n\t\t\tvisited[x+1][y]=true;\n\t\t\tif(dfs(x+1,y,c))return true;\n\t\t}\n\t\tif(ban[x][y+1]==c&&visited[x][y+1]==false){\n\t\t\tvisited[x][y+1]=true;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==c&&visited[x-1][y]==false){\n\t\t\tvisited[x-1][y]=true;\n\t\t\tif(dfs(x-1,y,c))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==c&&visited[x][y-1]==false){\n\t\t\tvisited[x][y-1]=true;\n\t\t\tif(dfs(x,y-1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = (int)1e9;\n\nint board[128][128];\n\nint main()\n{\n    int w, h;\n\n    while (scanf(\"%d %d\", &w, &h), w){\n        int xs, ys;\n        int xg, yg;\n        scanf(\"%d %d\", &xs, &ys);\n        scanf(\"%d %d\", &xg, &yg);\n\n        int n;\n        scanf(\"%d\", &n);\n        memset(board, 0, 128 * 128);\n        while (n-- > 0){\n            int c, d, x, y;\n            scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\n            board[y][x] = board[y][x + 1] = c;\n            board[y + 1][x] = board[y + 1][x + 1] = c;\n            if (d == 0){\n                board[y][x + 2] = board[y][x + 3] = c;\n                board[y + 1][x + 2] = board[y + 1][x + 3] = c;\n            }\n            else {\n                board[y + 2][x] = board[y + 3][x] = c;\n                board[y + 2][x + 1] = board[y + 3][x + 1] = c;\n            }\n        }\n\n        queue<P> que;\n        bool flag = false;\n        int color = board[ys][xs];\n\n        if (!color){\n            puts(\"NG\");\n            continue;\n        }\n\n        for (que.push(P(xs, ys)); que.size(); que.pop()){\n            P p = que.front();\n            int x = p.first;\n            int y = p.second;\n\n            if (board[y][x] != color) continue;\n\n            if (x == xg && y == yg){\n                flag = true;\n                break;\n            }\n            board[y][x] = !color;\n            que.push(P(x + 1, y));\n            que.push(P(x - 1, y));\n            que.push(P(x, y + 1));\n            que.push(P(x, y - 1));\n        }\n\n        puts(flag ? \"OK\" : \"NG\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 00;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nint color[200][200];\nbool flg[200][200];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs(int ny,int nx,int gy,int gx){\n\tflg[ny][nx]=true;\n\trep(i,4){\n\t\tif(color[ny+dy[i]][nx+dx[i]]==color[ny][nx] && flg[ny+dy[i]][nx+dx[i]]==false)dfs(ny+dy[i],nx+dx[i],gy,gx);\n\t}\n\treturn;\n}\n\nint main(){\n\tint w,h,n,c,d,x,y;\n\tpair<int,int> s,g;\n\twhile(1){\n\t\trep(i,200)rep(j,200)color[i][j]=flg[i][j]=0;\n\t\tcin>>w>>h;\n\t\tif(w==0 && h==0)break;\n\t\tcin>>s.first>>s.second;\n\t\tcin>>g.first>>g.second;\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\trep(j,2){\n\t\t\t\t\trep(k,4){\n\t\t\t\t\t\tcolor[y-1+j][x-1+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trep(j,4){\n\t\t\t\t\trep(k,2){\n\t\t\t\t\t\tcolor[y-1+j][x-1+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(s.first-1,s.second-1,g.first-1,g.second-1);\n\t\tif(flg[g.second-1][g.first-1])cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint Board[102][102];    //Board[j, x, w][i, y, h]\nbool isOK;              //迷路がOKかNGか\nint xs, ys, xg, yg;     //StartとGoalの座標\n\nvoid DFS(int c, int x, int y){\n    if(Board[x][y] != c){\n        return;\n    }\n    else if(x==xg && y==yg){\n        isOK = true;    //Goalなら迷路はOK\n        return;\n    }\n\n    Board[x][y] = 0;\n\n    DFS(c, x+1, y  );\n    DFS(c, x  , y+1);\n    DFS(c, x-1, y  );\n    DFS(c, x  , y-1);\n}\n\nint main(){\n    int w,h;\n    while(true){\n        cin >> w >> h;\n        if(w==0 && h==0)\n            break;\n        \n        isOK = false;               //初期値をNGに\n        for(int i=0;i<102;i++){     //Boardの初期化\n            for(int j=0;j<102;j++)\n                Board[j][i] = -1;\n        }\n        cin >> xs >> ys >> xg >> yg;\n\n        int n, c, d, x, y;\n        cin >> n;\n        for(int t=0;t<n;t++){\n            cin >> c >> d >> x >> y;\n            int wb = 2+(!d*2);      //d=0なら横長\n            int hb = 2+(d*2);       //d=1なら縦長\n            for(int i=0;i<hb;i++){\n                for(int j=0;j<wb;j++)\n                    Board[x+j][y+i] = c;\n            }\n        }\n\n        DFS(Board[xs][ys], xs, ys);\n\n        if(isOK)\n            cout << \"OK\" << endl;\n        else\n            cout << \"NG\" << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL p=7+1e+9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint W, H;\nint xs, ys, xg, yg;\nint N, C;\nint maze[128][128];\nbool check[128][128];\n\nint dfs(int x, int y){\n\tif(x == xg && y == yg)\n\t\treturn 1;\n\t\n\tint res = 0;\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx > 0 && nx <= W && ny > 0 && ny <= H && !check[ny][nx] && maze[ny][nx] == C){\n\t\t\tcheck[ny][nx] = true;\n\t\t\tres |= dfs(nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> W >> H && (W || H)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tmemset(check, 0, sizeof(check));\n\t\tcin >> xs >> ys >> xg >> yg >> N;\n\t\tint c, d, x, y;\n\t\tREP(i,N){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,2)\n\t\t\t\t\tREP(k,4)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(j,4)\n\t\t\t\t\tREP(k,2)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t\tC = maze[yg][xg];\n\t\tif(C == 0 || maze[ys][xs] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcheck[ys][xs] = true;\n\t\tint ans = dfs(xs, ys);\n\t\tif(ans){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[x+1][y+1]=c;\n             F[x+2][y+1]=c;\n             F[x+3][y+1]=c;\n             F[x+4][y+1]=c;  \n             F[x+1][y+2]=c;\n             F[x+2][y+2]=c;\n             F[x+3][y+2]=c;\n             F[x+4][y+2]=c;   \n         }\n         if(d==1){\n             F[x+1][y+1]=c;\n             F[x+1][y+2]=c;\n             F[x+1][y+3]=c;\n             F[x+1][y+4]=c;  \n             F[x+2][y+1]=c;\n             F[x+2][y+2]=c;\n             F[x+2][y+3]=c;\n             F[x+2][y+4]=c;   \n         }\n      }\n      if(F[xs][ys]!=1&&F[xs][ys]!=2&&F[xs][ys]!=3&&F[xs][ys]!=4&&F[xs][ys]!=5)\n         cout << \"NG\" << endl;\n      else{\n         DFS(xs+1,ys+1,c);\n         if(F[xg+1][yg+1]==6)\n            cout << \"OK\" << endl;\n         else\n            cout << \"NG\" << endl;\n         for(int i=1;i<=w;i++)\n            for(int j=1;j<=h;j++)\n               F[i][j]=0;\n      }\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\n\nvoid meiro(int W,int H,int c){\n if(C[W][H]!=c){\n   return;\n }\n\n C[W][H] = -1;\n\n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n\nvoid print(int w,int h){\n   for(int i=1;i<=w;i++){\n       for(int j=1;j<=h;j++){\n           cout<<C[i][j]<<' ';\n       }\n       cout<<endl;\n   }\n}\n\nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n   if(w==0 && h==0){\n     break;\n   }\n\n   for(int i=0;i<w;i++){\n     for(int j=0;j<h;j++){\n       C[i][j] = 0;\n     }\n   }\n\n   int xs,ys,xg,yg;\n   cin >> xs >> ys >> xg >> yg;\n\n   int n;\n   cin >> n;\n\n   int c,d,x,y;\n   for(int i=0;i<n;i++){\n     cin >> c >> d >> x >> y;\n\n     if(d==0){\n       for(int j=x;j<x+4;j++){\n         for(int k=y;k<y+2;k++){\n           C[j][k]=c;\n         }\n       }\n     }else{\n       for(int j=x;j<x+2;j++){\n         for(int k=y;k<y+4;k++){\n           C[j][k]=c;\n         }\n       }\n     }\n   }\n   //print(w,h);\n   //cout << endl;\n   meiro(xs,ys,C[xs][ys]);\n   //print(w,h);\n\n   if(C[xg][yg] == -1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[102][102];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 0;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 10;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h;\t\t\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tcin>>xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcolor = map[xs][ys];\n\t\t\n\t\tif (map[xg][yg]==10 && map[xs][ys]==10)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans,f=0;\nint map[100][100],v[100][100]={0};\nint root(int x,int y,int vmap[][100]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nint w, h;\nint b[101][101];\nint xg, yg;\nbool is_reachable(int x, int y, int c)\n{\n\tif (x < 1 || y < 1 || x > w || y > h || b[y][x] != c)\n\t\treturn false;\n\tif (x == xg && y == yg)\n\t\treturn true;\n\tb[y][x] = -1;\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { -1, 0, 1, 0 };\n\tbool res = false;\n\tfor (int i = 0; i < 4 && !res; ++i)\n\t\tres = is_reachable(x+dx[i], y+dy[i], c);\n\treturn res;\n}\nint main()\n{\n\twhile (scanf(\"%d %d\", &w, &h), w | h)\n\t{\n\t\tint xs, ys;\n\t\tscanf(\"%d %d %d %d\", &xs, &ys, &xg, &yg);\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tmemset(b, -1, sizeof(b));\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\t\t\tint w[2][2] = { { 2, 4 }, { 4, 2 } };\n\t\t\tfor (int j = 0; j < w[d][0]; ++j)\n\t\t\t\tfor (int k = 0; k < w[d][1]; ++k)\n\t\t\t\t\tb[y+j][x+k] = c;\n\t\t}\n\t\tif (b[ys][xs] != -1 && is_reachable(xs, ys, b[ys][xs]))\n\t\t\tputs(\"OK\");\n\t\telse\n\t\t\tputs(\"NG\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX_H 100\n#define MAX_W 100\n#define INF 1000;\nint h,w;\nint field[MAX_H][MAX_W];\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nvoid dfs(int y,int x,const int sc){\n\tif(y<=0 || x<=0 || y>h || x>w)return;\n\tif(field[y][x]==sc){\n\t\tfield[y][x]=0;\n\t\tfor(int i=0;i<4;i++)dfs(y+dy[i],x+dx[i],sc);\n\t}\n\treturn;\n}\nint main(){\n\tint sx,sy,gx,gy,n;\n\twhile(cin>>w>>h){\n        if(!w && !h)break;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=0;i<MAX_H;i++){\n\t\t\tfor(int j=0;j<MAX_W;j++){\n\t\t\t\t\tfield[i][j]=INF;\n\t\t\t\t}\n\t\t}\n\t\twhile(n--){\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tif(d)field[y+j][x+i]=c;\n\t\t\t\t\telse field[y+i][x+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sy,sx,field[sy][sx]);\n\t\tif(field[gy][gx])cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101],w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy)){r=1;return ;}\n\tif(x>1&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<=w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>1&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<=h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\tif(d)bw=2,bh=4;\n\t\t\telse{bh=2,bw=4;}\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])c = m[sx][sy],m[sx][sy]=0,dfs(sx,sy,c);\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define MAX 101\n\nusing namespace std;\n\nint field[MAX][MAX];\nbool went[MAX][MAX];\nint w, h;\nint sx, sy, gx, gy;\nint scol;\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nbool dfs(int x, int y) {\n\tif(field[y][x] == 0) return false;\n\tif(x == gx && y == gy) return true;\n\tint ncol = field[y][x];\n\tfield[y][x] = 0;\n\trep(i, 4) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 < nx && nx <= w && 0 < ny && ny <= h && ncol == field[ny][nx]) {\n\t\t\t/*rep(j, h) {\n\t\t\t\trep(k, w) cout << field[j][k] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tif(dfs(nx, ny)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(went, false, sizeof(went));\n\t\tint n;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tcin >> n;\n\t\trep(i, n) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\trep(i, (d ? 4 : 2)) rep(j, (d ? 2 : 4)) field[y + i][x + j] = c;\n\t\t}\n\t\t/*rep(j, h) {\n\t\t\trep(k, w) cout << field[j][k] << \" \";\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif(dfs(sx, sy)) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0&& w!=0){\n        int color, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = 0, goal = 0;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                if (board[i][j] == start) {\n                    canGo[i][j] = true;\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n \n#define Y first\n#define X second\n\n#define max_size 100+10\n\nint my[4] = {0,0,1,-1};\nint mx[4] = {1,-1,0,0};\n\npair<int, int>now,tmp;\n\nvoid chek(int map[max_size][max_size], int w, int h)\n{\n\tint i, j;\n\tfor(i=0;i<=h+1;i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nint main(void)\n{\n\tint w, h;\n\tint xs, ys, xg, yg;\n\tint n;\n\tint col, d, set_x, set_y;\n\n\tint i, j,k;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tqueue< pair<int, int> > QU;\n\n\t\tint map[max_size][max_size] = { 0 };\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> col >> d >> set_x >> set_y;\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[set_y][set_x] = col;\n\t\t\t\t\t\tset_x++;\n\t\t\t\t\t}\n\t\t\t\t\tset_x -= 4;\n\t\t\t\t\tset_y++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (k = 0; k < 2; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[set_y][set_x] = col;\n\t\t\t\t\t\tset_x++;\n\t\t\t\t\t}\n\t\t\t\t\tset_x -= 2;\n\t\t\t\t\tset_y++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//chek(map, w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tint s_col = map[ys][xs];\n\n\t\tnow.Y = ys;\n\t\tnow.X = xs;\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] != -1)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]]== s_col)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp.Y = now.Y + my[i];\n\t\t\t\t\t\ttmp.X = now.X + mx[i];\n\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nint gx, gy;\nint vx[] = {0, 1, 0, -1};\nint vy[] = {1, 0, -1, 0};\nint block[100][100];\nbool check[100][100];\nbool flag;\n\nvoid dfs(int y, int x) {\n\n  /*\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      if(i == y && j == x) cout << 'P';\n      else if(i == gy && j == gx) cout << 'G';\n      else cout << block[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n\n  if(y == gy && x == gx) {\n    \n    flag = true;\n    return;\n\n  } else {\n    \n    for(int i = 0; i < 4; ++i) {\n      \n      int ny = y + vy[i];\n      int nx = x + vx[i];\n      \n      if(ny >= 0 && ny < h && nx >= 0 && nx < w && !check[ny][nx] && block[ny][nx] && block[ny][nx] == block[y][x]) {\n\t\n\tcheck[ny][nx] = true;\n\tdfs(ny, nx);\n\t//check[ny][nx] = false;\n\n      }\n\n    }\n\n  }\n\n}\n\nint main() {\n\n  int sx, sy;\n  int n;\n  int c, d, x, y;\n\n  while(cin >> w >> h) {\n\n    if(w == 0 && h == 0) break;\n\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n\n    --sx;\n    --sy;\n    --gx;\n    --gy;\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n\tblock[i][j] = 0;\n\tcheck[i][j] = false;\n      }\n    }\n\n    for(int i = 0; i < n; ++i) {\n\t\n\tcin >> c >> d >> x >> y;\n\n\t--x;\n\t--y;\n\t\n\tint bw, bh;\n\n\tif(d) {\n\t  bw = 2;\n\t  bh = 4;\n\t} else {\n\t  bw = 4;\n\t  bh = 2;\n\t}\n\n\tfor(int j = 0; j < bh; ++j) {\n\t  for(int k = 0; k < bw; ++k) {\n\t    block[y + j][x + k] = c;\n\t  }\n\t}\n\n    }\n\n    flag = false;\n    check[sy][sx] = true;\n    dfs(sy, sx);\n\n    cout << (flag ? \"OK\" : \"NG\") << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  joi\n//\n//  Created by 8595198919 on 14/06/09.\n//  Copyright (c) 2014年 8595198919. All rights reserved.\n//\n\n#include <iostream>\n#include <list>\n#include <stack>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define Rep(i,n) for(int i = 1;i <= n;i++)\n#define fs first\n#define sc second\n#define mp make_pair\nusing namespace std;\n\nint w,h;\nint xs,ys,xg,yg;\nint n;\nint goal[2];\nint dx[4]={1,0,0,-1};\nint dy[4]={0,1,-1,0};\nint map_[105][105];\nbool went[105][105];\nint c,d,x,y;\n\nbool search(int x,int y){\n    if(map_[x][y]==0)\n        return 0;\n    if(x==xg&&y==yg)\n        return 1;\n    rep(i,4){\n        int xnext = x +dx[i];\n        int ynext = y +dy[i];\n        if(went[xnext][ynext])\n            continue;\n        if(map_[xnext][ynext]==map_[x][y]){\n            went[x][y]=true;\n            if(search(xnext,ynext))\n                return 1;\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n    while(scanf(\"%d %d\",&w,&h),(w!=0&&h!=0)){\n        rep(i,w+5){\n            rep(j,h+5){\n                map_[i][j]=0;\n                went[i][j]=0;\n            }\n        }\n        scanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n        xs++,ys++,xg++,yg++;\n        rep(i,n){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x++,y++;\n            rep(i,(dx[d]+1)*2){\n                rep(j,(dy[d]+1)*2){\n                    map_[x+i][y+j] = c;\n                }\n            }\n        }\n        if(search(xs,ys))\n            cout << \"OK\" << endl;\n        else\n            cout <<\"NG\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 102\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid input_data(void);  //データ入力用関数\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\nvoid clear(void);       //データの初期化\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[102][102];\nint data[102][102];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0)break; //ループ終了条件\n\n    input_data();\n\n    make_mass();\n\n    solve();\n\n    /*printf(\"%d\\n\",goal);*/\n\n    if(goal==1){\n      cout<<\"OK\"<<endl;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n\n    /*    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",data[i][j]);\n      }\n      printf(\"     \");\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",mass[i][j]);\n      }\n      printf(\"\\n\");\n      }                          */\n    clear();\n\n  }\n\n  return 0;\n}\nvoid input_data(void){\n\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n\n    cin>>n;\n\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n\n    }\n\n    return;\n}\nvoid make_mass(void){\n\n  int i,j;\n  int scolor,fcolor;\n\n    /*マスの作成*/\n    for(i=0;i<n;i++){\n\tswitch(d[i]){\n\tcase 0:              //横向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]][x[i]+j]=c[i];\n\t    mass[y[i]+1][x[i]+j]=c[i];\n\t  }\n\t  break;\n\tcase 1:              //縦向きなら\n\t  for(j=0;j<4;j++){\n\t    mass[y[i]+j][x[i]]=c[i];\n\t    mass[y[i]+j][x[i]+1]=c[i];\n\t  }\n\t  break;\n\t}\n      }\n\n    scolor=mass[sy][sx];\n    fcolor=mass[gy][gx];\n\n      for(i=0;i<h;i++){\n\tfor(j=0;j<w;j++){\n\t  if(scolor!=mass[i][j]){\n\t    mass[i][j]=0;\n\t  }\n\t}\n      }\n\n    return;\n}\nvoid solve(void){\n\n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n\n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n\n    if(p.first==gx && p.second==gy){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]!=0 && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=data[p.second][p.first]+1;\n      }\n    }\n  }\n  return;\n}\n\n\nvoid clear(void){\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      mass[i][j]==0;\n    }\n  }\n  goal=0;\n\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[101][101];\n\nvoid DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='w')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_Y(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='y')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_G(int Y,int X,int Xg,int Yg,int &c){\n  if((Y==Xg&&X==Yg)||(c!=0)){\n    c=1;\n  }\n  if(F[Y][X]!='g'){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_B(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='b')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_R(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='r')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n}\n\nint main(){\n\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      F[j][i]='0';\n    }\n  }\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  cin>>w>>h;\n  while(w!=0){\n    //int a=0;\n    //int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    int c[n];\n    int d[n];\n    int x[n];\n    int y[n];\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      //int a=0;\n      //int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n        F[i][j]='0';\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 0, n)\n\n//4方向ベクトル→↑←↓\nint dx[] ={1,0,-1,0};\nint dy[] ={0,-1,0,1};\n//ブロック2×4 \nint w,h;//ボードの横,縦\nint xs,ys;//スタートの座標\nint xg,yg;//ゴールの座標\nint n;//ブロックの個数\nint c,d;//ブロックの色,ブロックの向き,ブロックの位置x,y\n\nint board[102][102];\n\nbool dfs(int x,int y,int color){\n  if(color ==0 ||board[x][y] !=color)\n    return false;\n  if(x ==xg&&y ==yg)\n    return true;\n  board[x][y] = 0;\n  for(int i = 0 ;i < 4;i++){\n    if(x +dx[i] <=0 || x+dx[i]>w || y+dy[i] <=0 ||y +dy[i] >h)\n      continue;\n    if(dfs(x+dx[i],y+dy[i],color))\n      return true;\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d %d\",&w,&h)){\n    if(w==0&&h==0)\n      break;\n    cin>>xs>>ys>>xg>>yg>>n;\n    for(int i = 0;i < n;i++){\n      int x,y;\n      cin >>c>>d>>x>>y;\n      int W,H;\n      if(d ==0){\n\tW =4;\n\tH =2;\n      }else{\n\tW = 2;\n\tH = 4;\n      }\n      for(int i = 0;i < H;i++){\n\tfor(int j = 0;j < W;j++){\n\t  board[j+x][i+y] =c;\n\t}\n      }\n  }\n    cout<<((dfs(xs,ys,board[xs][ys]))?\"OK\":\"NG\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector < vector<int> > hyou(102, vector<int>(102));\n\nvoid check(int x, int y, int c) {\n\tint mx[] = {1, 0, -1, 0};\n\tint my[] = {0, 1, 0, -1};\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (hyou[x+mx[i]][y+my[i]] == c) {\n\t\t\thyou[x+mx[i]][y+my[i]] = 0;\n\t\t\tcheck(x+mx[i], y+my[i], c);\n\t\t}\n\t}\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 102; i++) {\n\t\t\tfor (int j = 0; j < 102; j++) {\n\t\t\t\thyou[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint xs, ys, xg, yg, n;\n\t\tint c, d, x, y;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\thyou[x+k][y+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\thyou[x+k][y+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (hyou[xg][yg] != 0 && hyou[xg][yg] == hyou[xs][ys]) {\n\t\t\tcheck(xs, ys, hyou[xs][ys]);\n\t\t\tif (hyou[xg][yg] == 0) {\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\t} else {\n\t\t\t\tcout << \"NG\" << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n\n#define rep(i,n) for(short i = 0; i < n; i++)\n#define MAX 50\n\nint dx[] = {0,0,-1,1},\n\tdy[] = {1,-1,0,0};\n\ntypedef pair<short,short> P;\nP S,G;\nshort w,h;\nshort maze[MAX][MAX];\nshort color;\n\nbool check()\n{\n\tqueue<P> que;\n\tque.push(S);\n\tcolor = maze[S.second][S.first];\n\n\tshort nx,ny;\n\twhile(que.size()){\n\t\tP p = que.front();\tque.pop();\n\n\t\tif(p == G){\n\t\t\twhile(que.size())\n\t\t\t\tque.pop();\n\t\t\treturn true;\n\t\t}\n\n\t\trep(i,4){\n\t\t\tnx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\n\t\t\tif(nx > -1 && ny > -1 && nx < w && ny < h &&\n\t\t\t\tmaze[ny][nx] == color){\n\t\t\t\t\tmaze[ny][nx] = -1;\n\t\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t\n\treturn false;\n}\n\nint main(void)\n{\n\tshort n,c,d,x,y;\n\n\twhile(cin >> w >> h, w){\n\t\tcin >> S.first >> S.second;\n\t\tcin >> G.first >> G.second;\n\t\tS.first = S.first / 2;\n\t\tS.second= S.second/ 2;\n\n\t\tcin >> n;\n\n\t\trep(i,n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx /= 2;\n\t\t\ty /= 2;\n\t\t\tx++;\n\t\t\ty++;\n\n\t\t\tif(d == 0)\n\t\t\t\tmaze[y][x] = maze[y][x+1] = c;\n\t\t\telse\n\t\t\t\tmaze[y][x] = maze[y+1][x] = c;\n\t\t}\n\t\t\n\t\tif(maze[S.second][S.first] == maze[G.second][G.first] && check())\n\t\t\tcout << \"OK\\n\";\n\t\telse\n\t\t\tcout << \"NG\\n\";\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef unsigned long long ull; typedef long long ll;\n\nconst int INF=100000000; int dx[4]={1,0,-1,0}; int dy[4]={0,1,0-1};\n\ntypedef pair<int ,int > P;\n\nchar maze[105][105];\n\nint sx,sy; int gx,gy; int w,h;\n\nchar sc; //スタート地点のカラー\n\n//stdin //stdout\n\nvoid dfs(int x,int y) { maze[x][y]='9';\n\nfor(int i=0;i<4;i++) { int nx=x+dx[i]; int ny=y+dy[i];\n\nif(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[nx][ny]==sc) { dfs(nx,ny); }\n\n} return ; }\n\nvoid solve() {\n\nrep(i,101) rep(j,101) maze[i][j]='0';\n\nint n; char c; int d; int x,y;\n\ncin>>sy>>sx; cin>>gy>>gx;\n\ncin>>n;\n\nrep(i,n) { cin>>c>>d>>x>>y;\n\nif(d==1) { rep(i,4) { rep(j,2) { maze[x+i][y+j]=c;\n\n} } } else if (d==0) { rep(i,2) { rep(j,4) { maze[x+i][y+j]=c;\n\n} } }\n\n} //6 6 //1 1 //3 6 //2 //1 0 1 1 //1 1 3 3 // rep(i,w+1) // { // rep(j,h+1) // { // cout<<maze[i][j]; //// } // cout<<endl; // } //// cout<<maze[gx][gy]<<endl;\n\nif(maze[sx][sy]=='0') { cout<<\"NG\"<<endl; return; } else { sc=maze[sx][sy]; dfs(sx,sy); }\n\n//rep(i,w+1) //{ // rep(j,h+1) // { // cout<<maze[i][j];\n\n// } // cout<<endl; //}\n\nif(maze[gx][gy]=='9') { cout<<\"OK\"<<endl; return; } else { cout<<\"NG\"<<endl; return; }\n\n}\n\nint main() {\n\nwhile(cin>>w>>h) { if(w==0 && h==0) { return 0; } else { solve(); } }\n\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[101][102];\n\nvoid DFS(int Y, int X, int c) {\n        //cout << Y << \" \" << X << endl;\n        if (F[Y][X] != c || F[Y][X] == 0)\n                return;\n        F[Y][X] = 10;\n        DFS(Y - 1, X, c);//???\n                                                 //DFS(Y - 1, X+1, A_ito);//??????\n        DFS(Y, X + 1, c);//???\n                                                 //DFS(Y + 1, X+1, A_ito);//??????\n        DFS(Y + 1, X, c);//???\n                                                 //DFS(Y + 1, X-1, A_ito);//??????\n        DFS(Y, X - 1, c);//???\n                                                 //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n        int xs, ys, xg, yg, n;\n        int c, d, x, y;\n        int W = 0, H = 0;\n\n        while (!(W == H == 0)) {\n                cin >> W >> H;\n                cin >> xs >> ys >> xg >> yg >> n;\n                for (int i = 1;i <= n;i++) {\n                        cin >> c >> d >> x >> y;\n                        if (d == 0) {\n                                F[x][y] = c;\n                                F[x][y + 1] = c;\n                                F[x + 1][y] = c;\n                                F[x + 1][y + 1] = c;\n                                F[x + 2][y] = c;\n                                F[x + 2][y + 1] = c;\n                                F[x + 3][y] = c;\n                                F[x + 3][y + 1] = c;\n                        }\n                        if (d == 1) {\n                                F[x][y] = c;\n                                F[x + 1][y] = c;\n                                F[x][y + 1] = c;\n                                F[x + 1][y + 1] = c;\n                                F[x][y + 2] = c;\n                                F[x + 1][y + 2] = c;\n                                F[x][y + 3] = c;\n                                F[x + 1][y + 3] = c;\n                        }\n                }\n                DFS(ys, xs, F[ys][xs]);\n\n                if (F[yg][xg] == 10) {\n                        cout << \"OK\" << endl;\n                }\n                else { cout << \"NG\"<<endl; }\n                for (int i = 0;i < H;i++) {\n                        for (int j = 0;j < W;j++) {\n                                F[i][j] = 0;\n                        }\n                }\n        }\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\nusing namespace std;\n\n#define X_MAX 100+10\n#define Y_MAX 100+10\n\n#define Vertical 1\n#define Horizontal 0\n\nint my[4] = { 1,-1,0,0 };\nint mx[4] = { 0,0,1,-1 };\n\nstruct ST\n{\n\tint came[Y_MAX][X_MAX];\n\tint now_y;\n\tint now_x;\n};\n\n\nvoid paint_V(int*map , int col)\n{\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\nvoid paint_H(int*map, int col)\n{\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\n\nvoid chek(int map[Y_MAX][X_MAX],int lx,int ly)\n{\n\tint i, j;\n\tfor (i = 0; i <= ly+1;i++)\n\t{\n\t\tfor (j = 0; j <= lx+1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nint main(void)\n{\n\tST an = {0}, tmp;\n\tqueue<ST> ma;\n\n\tint lx, ly, n;\n\tint sx, sy, gx, gy;\n\tint col, VorH,set_x,set_y;\n\tint i, j;\n\n\twhile ((cin >> lx >> ly), lx!=0&&ly!=0)\n\t{\n\t\tint goal = 0;\n\t\tint map[Y_MAX][X_MAX] = { 0 };\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> col >> VorH >> set_x >> set_y;\n\t\t\tif (VorH == Vertical)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_V(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_H(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s_col = map[sy][sx];\n\t\tif (s_col == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tan.now_y = sy;\n\t\tan.now_x = sx;\n\t\tma.push(an);\n\n\t\t//chek(map, lx, ly);\n\n\t\twhile (!ma.empty())\n\t\t{\n\t\t\tan = ma.front();\n\t\t\tma.pop();\n\t\t\tan.came[an.now_y][an.now_x] = 1;\n\n\t\t\t//printf(\"y=%d,x=%d\\n\", an.now_y, an.now_x);\n\t\t\t//chek(an.came, lx, ly);\n\n\t\t\tif (an.now_y == gy && an.now_x == gx)\n\t\t\t{\n\t\t\t\tgoal = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp = an;\n\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (map[an.now_y + my[i]][an.now_x + mx[i]] == s_col && an.came[an.now_y + my[i]][an.now_x + mx[i]] == 0)\n\t\t\t\t{\n\t\t\t\t\ttmp.now_y = an.now_y + my[i];\n\t\t\t\t\ttmp.now_x = an.now_x + mx[i];\n\t\t\t\t\tma.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (goal == 1)\n\t\t{\n\t\t\twhile (!ma.empty())\n\t\t\t{\n\t\t\t\tma.pop();\n\t\t\t}\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nint w, h;\nint xs, ys, xg, yg, n, c, d, x, y;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid put_b(int a[][101]) {\n  int X, Y;\n  if(d == 0) X = 4, Y = 2;\n  else X = 2, Y = 4 ;\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j < X; j++)\n      a[y + i][x + j] = c;\n}\n\nbool bfs(int a[][101]) {\n  int cs = a[ys][xs];\n  if(cs != a[yg][xg]) return false;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while(que.size()) {\n    P p = que.front();\n    que.pop();\n    if(p.first == xg && p.second == yg) return true;\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second +dy[i];\n      if(0 <= nx && nx < w && 0 <= ny && ny < h && a[ny][nx] == cs) {\n\tque.push(P(nx, ny));\n\ta[ny][nx] = 0;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  while(cin >> w >> h, w != 0 || h != 0) {\n    int a[101][101] = {};\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n  \n    while(n--) {\n      cin >> c >> d >> x >> y;\n      put_b(a);\n    }\n    /*\n      for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++)\n      cout << a[i][j];\n      cout << endl;\n      }*/\n    if(bfs(a) == true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nint map[size_max][size_max];\n\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\n\nvoid check(int w, int h)\n{\n\tint i, j;\n\tfor (i = 0; i <= h + 1; i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue<PR> QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t\t//check(w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tc = map[ys][xs];\n\n\t\t//cout << \"C=\" << c << endl;\n\n\t\tnow = make_pair(ys, xs);\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] == c)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = make_pair(now.Y + my[i], now.X + mx[i]);\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg,ok;\n\nvoid Maze(int X,int Y,int C){\n\tif(F[X][Y]!=C)\n\t\treturn;\n\n\t\n\n\tif(X==xg&&Y==yg){\n\t\tcout << \"OK\"<<endl;\n\t\tok++;\n\t}\n\n\tF[X][Y]=-1;\n\n\tMaze(X-1,Y  ,C);\n\tMaze(X  ,Y+1,C);\n\tMaze(X+1,Y  ,C);\n\tMaze(X  ,Y-1,C);\n\t\n}\n\n\n\nint main(){\t\n\twhile(1){\n\t\tok=0;\n\n\t\tint w,h,xs,ys,n,c,d,x,y;\n\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)\n\t\t\treturn 0;\n\n\t\tcin >>xs>>ys;\n\t\tcin >>xg>>yg;\n\t\tcin >>n;\n\n\n\t\tfor(int i=1; i<=w; i++)\n\t\t\tfor(int j=1; j<=h; j++)\n\t\t\t\tF[j][i]=0;\n\n\t\tfor(int i=1; i<=w;i++){\n\t\t\t\tF[w+1][i]=6;\n\t\t\t\tF[0][i]=6;\n\t\t}\n\t\tfor(int i=1; i<=h;i++){\n\t\t\t\tF[i][h+1]=6;\n\t\t\t\tF[i][0]=6;\n\t\t}\n\n\t\tint N=0;\n\t\twhile(N<n){\n\t\t\tcin >>c>>d>>x>>y;\n\n\t\t\tif(d){\n\t\t\t\tfor(int i=x; i<x+2; i++)\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int i=x; i<x+4; i++)\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tF[i][j]=c;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tN++;\n\t\t}\n\n/*for(int i=0; i<=h+1; i++){\n\tfor(int j=0; j<=w+1; j++){\n\t\tcout <<F[j][i];\n\t\t}\n\tcout << endl;\n}*/\n\t\t\n\t\tMaze(xs,ys,F[xs][ys]);\n\n\t\tif(ok==0)\n\t\t\tcout <<\"NG\"<<endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool solve(int x,int y,int c);\nint ux[2][8]={{0,1,2,3,0,1,2,3},\n\t      {0,1,0,1,0,1,0,1}};\nint uy[2][8]={{0,0,0,0,1,1,1,1},\n\t      {0,0,1,1,2,2,3,3}};\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint w,h,n;\nint b[105][105];\nint xs,ys,xg,yg;\nint main(void){\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(!w && !h) break;\n    memset(b,0,sizeof(b));\n    scanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n    scanf(\"%d\",&n);\n    int c,d,tx,ty;\n    for(int i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&c,&d,&tx,&ty);\n      for(int j=0;j<8;j++){\n\tb[tx+ux[d][j]][ty+uy[d][j]]=c;\n      }\n    }\n    if(b[xs][ys]!=0 && b[xg][yg]!=0 && b[xs][ys]==b[xg][yg] && solve(xs,ys,b[xs][ys])) puts(\"OK\");\n    else puts(\"NG\");\n  }\n}\n\nbool solve(int x,int y,int c){\n  if(x==xg && y==yg) return true;\n  b[x][y]=0;\n  for(int i=0;i<4;i++){\n    int nx=x+dx[i];\n    int ny=y+dy[i];\n    if(0<nx && nx<=w && 0<ny && ny<=h){\n      if(b[nx][ny]==c){\n\tif(solve(nx,ny,c)) return true;\n      }\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\n\n      for(int i=0;i<105;i++){\n        for(int j=0;j<105;j++){\n                F[i][j]=0;\n        }\n      }\n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct cordinate{\n        int y;\n        int x;\n};\ncordinate SIZE,Start,Goal;\nstruct Blocks{\n        int color;\n        int direction;\n        int y;\n        int x;\n};\nBlocks block[200];\nint N,board[200][200];\nint Color,dp[200][200];\nint recursion(int y,int x){\n        int res=0;\n        if(y==Goal.y && x==Goal.x){\n                res=1;\n        }\n        else if(dp[y][x]!=-1)\n                return dp[y][x];\n        else{\n                dp[y][x]=0;\n                if(board[y+1][x]==Color && dp[y+1][x]==-1)\n                        res+=recursion(y+1,x);\n                if(board[y-1][x]==Color && dp[y-1][x]==-1)\n                        res+=recursion(y-1,x);\n                if(board[y][x+1]==Color && dp[y][x+1]==-1)\n                        res+=recursion(y,x+1);\n                if(board[y][x-1]==Color && dp[y][x-1]==-1)\n                        res+=recursion(y,x-1);\n        }\n        return dp[y][x]=res;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<100 ; i++ )\n                        for(int j=0 ; j<100 ; j++ )\n                                dp[i][j]=-1;\n                cin >> SIZE.x >> SIZE.y;\n                if(SIZE.x+SIZE.y==0)\n                        break;\n                cin >> Start.x >> Start.y;\n                cin >> Goal.x >> Goal.y;\n                cin >> N;\n                for(int i=0 ; i<N ; i++ ){\n                        cin >> block[i].color >> block[i].direction;\n                        cin >> block[i].x >> block[i].y;\n                        if(block[i].direction){\n                                for(int l=block[i].y ; l<block[i].y+4 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+2 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                        else{\n                                for(int l=block[i].y ; l<block[i].y+2 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+4 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                }\n                Color=board[Start.y][Start.x];\n                if(recursion(Start.y,Start.x)>0)\n                        cout <<\"OK\"<<endl;\n                else\n                        cout <<\"NG\"<<endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,xs,ys,n,xg,yg,c,d,x,y,area[105][105],c_area[105][105];\nint x_p[4]={-1,0,1,0},y_p[4]={0,-1,0,1};\n\nbool flag=false;\nvoid solve(int x,int y,int c);\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(w==0&&h==0)break;\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=0;i<n;i++){\n            cin >> c >> d >> x >> y;\n            if(d==0){\n            for(int j=y;j<y+2;j++){\n                for(int k=x;k<x+4;k++){\n                    area[k][j]=c;\n                }\n            }\n            }else{\n            for(int j=y;j<y+4;j++){\n                for(int k=x;k<x+2;k++){\n                    area[k][j]=c;\n                    }\n                }\n            }\n        }\n        if(area[xs][ys]!=area[xg][yg]);\n        else {\n        solve(xs,ys,area[xs][ys]);\n        }\n        if(flag==true)cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n        flag=false;\n        fill(area[0],area[104],0);\n    }\n\nreturn 0;\n}\n\nvoid solve(int x,int y,int c){\n\n    if(x==xg&&y==yg){\n        flag=true;\n    return;\n    }else{\n        for(int i=0;i<4;i++){\n        if(area[x+x_p[i]][y+y_p[i]]==c){\n                //c_area[x][y]=area[x][y];\n                area[x][y]=0;\n                solve(x+x_p[i],y+y_p[i],c);\n                //area[x][y]=c_area[x][y];\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n\n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nbool DFS(int X, int Y, int Xg, int Yg, int c){\n\tif(F[Y][X] != c){\n\t\treturn false;\n\t}else if(F[Y][X] == c && X == Xg && Y == Yg){\n\t\treturn true;\n\t}\n\tF[Y][X] = -1;\n\tif(DFS(X, Y - 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X + 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X, Y + 1, Xg, Yg, c)){\n\t\treturn true;\n\t}else if(DFS(X - 1, Y, Xg, Yg, c)){\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nint main(){\n\nwhile(true){\n\tint w, h;\n\tcin >> w >> h;\n\tif(w == 0 && h == 0){\n\t\tbreak;\n\t}\n\tint xs, ys, xg, yg;\n\tcin >> xs >> ys >> xg >> yg;\n\tint n;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tint c, d, x, y;\n\t\tcin >> c >> d >> x >> y;\n\t\tif(d == 0){\n\t\t\tfor(int X = x; X < x + 4; X++){\n\t\t\t\tfor(int Y = y; Y < y + 2; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(d == 1){\n\t\t\tfor(int X = x; X < x + 2; X++){\n\t\t\t\tfor(int Y = y; Y < y + 4; Y++){\n\t\t\t\t\tF[Y][X] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(DFS(xs, ys, xg, yg, F[xg][yg])){\n\t\tcout << \"OK\" << endl;\n\t}else{\n\t\tcout << \"NG\" << endl;\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX_W 100\n#define MAX_H 100\n\nint board[MAX_H + 1][MAX_W + 1];\nbool ans = false;\n\nvoid resetBoard();\nvoid setBoard(int c, int d, int x, int y);\nvoid loop(int xn, int yn, int xg, int yg, int c);\nvoid disp(int w, int h);\n\nint main(){\n    int w, h;\n    while(cin >>w >>h){\n        if(w == 0 && h == 0) break;\n        int xs, ys, xg, yg, n;\n        resetBoard();\n        ans = false;\n        cin >>xs >>ys >>xg >>yg >>n;\n        for(int i = 0; i < n; i++){\n            int c, d, x, y;\n            cin >>c >>d >>x >>y;\n            setBoard(c, d, x, y);\n        }\n        if(board[ys][xs] == 0){\n            cout <<\"NG\" <<endl;\n        } else{\n            loop(xs, ys, xg, yg, board[ys + 1][xs + 1]);\n            if(ans) cout <<\"OK\" <<endl;\n            else cout <<\"NG\" <<endl;\n        }\n    }\n    return 0;\n}   \n\nvoid resetBoard(){\n    for(int i = 0; i <= MAX_H; i++){\n        for(int j = 0; j <= MAX_W; j++){\n            board[i][j] = 0;\n        }\n    }\n}\n\nvoid setBoard(int c, int d, int x, int y){\n    int xm[] = {0, 1, 2, 3, 0, 1, 2, 3}, ym[] = {0, 0, 0, 0, 1, 1, 1, 1};\n    if(d == 1) swap(xm, ym);\n    for(int i = 0; i < sizeof(xm) / sizeof(xm[0]); i++){\n        int tmpx = x + xm[i], tmpy = y + ym[i];\n        if(tmpx > 0 || tmpy > 0 || tmpx <= MAX_W || tmpy <= MAX_H){\n            board[tmpy][tmpx] = c;\n        }\n    }\n}\nvoid loop(int xn, int yn, int xg, int yg, int c){\n    if(xn == xg && yn == yg){\n        ans = true;\n    } else{\n        board[yn][xn] = 0;\n        int xm[] = {0, 1, 0, -1}, ym[] = {-1, 0, 1, 0};\n        for(int i = 0; i < sizeof(xm) / sizeof(xm[0]); i++){\n            int tmpx = xn + xm[i], tmpy = yn + ym[i];\n            //            cout <<\"tmpx = \" <<tmpx <<\", tmpy = \" <<tmpy <<endl;\n            if(tmpx > 0 && tmpy > 0 && tmpx <= MAX_W && tmpy <= MAX_H && board[tmpy][tmpx] == c){\n                loop(tmpx, tmpy, xg, yg, c);\n            }\n        }\n    }\n}\n\nvoid disp(int w, int h){\n    for(int i = 0; i <= h; i++){\n        for(int j = 0; j <= w; j++){\n            cout <<board[i][j];\n        }\n        cout <<endl;\n    }\n}\n\n//0, 00:50:41"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nchar F[102][102];\n \nvoid DFS(int Y,int X,char c){\n  if(F[Y][X]!=c){\n    return;\n  }\n \n  F[Y][X] = '0';\n \n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n \nint main(){\n  while(1){\n  int N,M;\n  cin >> N >> M;\n  if(N==0&&M==0)\n    break;\n \n  for(int h=1;h<=N;h++){\n    for(int w=1;w<=M;w++){\n      cin>>F[h][w];\n    }\n  }\n \n  int cnt=0;\n  for(int h=1;h<=N;h++){\n    for(int w=1;w<=M;w++){\n      if(F[h][w]=='@'){\n        cnt++;\n        DFS(h,w,'@');\n      }else if(F[h][w]=='#'){\n        cnt++;\n        DFS(h,w,'#');\n      }else if(F[h][w]=='*'){\n          cnt++;\n          DFS(h,w,'*');\n      }\n    }\n  }\n  cout<<cnt<<endl;\n}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nint gx, gy;\nint vx[] = {0, 1, 0, -1};\nint vy[] = {1, 0, -1, 0};\nint block[100][100];\nbool check[100][100];\nbool flag;\n\nvoid dfs(int y, int x) {\n\n  /*\n  for(int i = 0; i < h; ++i) {\n    for(int j = 0; j < w; ++j) {\n      if(i == y && j == x) cout << 'P';\n      else if(i == gy && j == gx) cout << 'G';\n      else cout << block[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n  */\n\n  if(y == gy && x == gx) {\n    \n    flag = true;\n    return;\n\n  } else {\n    \n    for(int i = 0; i < 4; ++i) {\n      \n      int ny = y + vy[i];\n      int nx = x + vx[i];\n      \n      if(ny >= 0 && ny < h && nx >= 0 && nx < w && !check[ny][nx] && block[ny][nx] && block[ny][nx] == block[y][x]) {\n\t\n\tcheck[ny][nx] = true;\n\tdfs(ny, nx);\n\tcheck[ny][nx] = false;\n\n      }\n\n    }\n\n  }\n\n}\n\nint main() {\n\n  int sx, sy;\n  int n;\n  int c, d, x, y;\n\n  while(cin >> w >> h) {\n\n    if(w == 0 && h == 0) break;\n\n    cin >> sx >> sy;\n    cin >> gx >> gy;\n    cin >> n;\n\n    --sx;\n    --sy;\n    --gx;\n    --gy;\n\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n\tblock[i][j] = 0;\n\tcheck[i][j] = false;\n      }\n    }\n\n    for(int i = 0; i < n; ++i) {\n\t\n\tcin >> c >> d >> x >> y;\n\n\t--x;\n\t--y;\n\t\n\tint bw, bh;\n\n\tif(d) {\n\t  bw = 2;\n\t  bh = 4;\n\t} else {\n\t  bw = 4;\n\t  bh = 2;\n\t}\n\n\tfor(int j = 0; j < bh; ++j) {\n\t  for(int k = 0; k < bw; ++k) {\n\t    block[y + j][x + k] = c;\n\t  }\n\t}\n\n    }\n\n    flag = false;\n    check[sy][sx] = true;\n    dfs(sy, sx);\n\n    cout << (flag ? \"OK\" : \"NG\") << endl;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n;\n\tcin>>H;\n\tcin>>W;\n\tif(H==0&&W==0)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==0)\n\t\tcout<<\"OK\"<<endl;\n\tif(F[xg][yg]!=0)\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny == yg && nx == xg){\n\t\t\tflag = true;\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint board[101][101];\nbool visited[101][101];\n\nint w, h, xg, yg;\n\nclass Point{\npublic:\n\tint x, y;\n\n\tPoint(int xx, int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t}\n};\n\nbool judge(int, int);\nint main(void){\n\tconst int UNDEFINED = 0;\n\tconst int BLOCK_WIDTH = 2;\n\tconst int BLOCK_HEIGHT = 4;\n\n\tfor(int xs, ys, n; cin >> w >> h >> xs >> ys >> xg >> yg >> n, w, h;){\n\t\tfor(int i = 1; i <= w; i ++){\n\t\t\tfor(int j = 1; j <= h; j ++){\n\t\t\t\tboard[j][i] = UNDEFINED;\n\t\t\t\tvisited[j][i] = false;\n\t\t\t}\n\t\t}\n\n\t\twhile(n --){\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tint width = (!d) ? BLOCK_HEIGHT:BLOCK_WIDTH;\n\t\t\tint height = (!d) ? BLOCK_WIDTH:BLOCK_HEIGHT;\n\n\t\t\tfor(int curX = x; curX <= x + width; curX ++)\n\t\t\t\tfor(int curY = y; curY <= y + height; curY ++)\n\t\t\t\t\tboard[curX][curY] = c;\n\t\t}\n\t\tcout << ((judge(xs, ys)) ? \"OK\":\"NG\") << endl;\n\t}\n\n\treturn 0;\n}\n\nbool judge(int firstX, int firstY){\n\tqueue<Point> q; Point p(firstX, firstY);\n\tq.push(p);\n\tvisited[firstY][firstX] = true;\n\n\tint targetColor = board[firstY][firstX];\n\t\n\twhile(!q.empty()){\n\t\tif(visited[yg][xg]) return true;\n\t\tPoint currentNode = q.front(); q.pop();\n\n\t\tfor(int delta = -1; delta <= 1; delta += 2){\n\t\t\tfor(int a = 0; a < 2; a ++){\n\t\t\t\tPoint nextNode(currentNode.x + ((a)?delta:0), currentNode.y + ((a)?0:delta));\n\n\t\t\t\tif(!visited[nextNode.y][nextNode.x] && board[nextNode.y][nextNode.x] == targetColor){\n\t\t\t\t\tq.push(nextNode);\n\t\t\t\t\tvisited[nextNode.y][nextNode.x] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nbool b=false;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvoid dfs(int a[][110] ,int x , int y , int w , int h , int xg , int yg , int c){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif( a[tx][ty]!=c || a[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs( a,tx,ty,w,h,xg,yg,c);\n\t}\n}\nint main(){\n\tint w , h;\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys , xg , yg ;\n\t\tint n;\n\t\tb=false;\n\t\tint board[110][110]={0};\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(!d){\n\t\t\t\tfor(int k=y;k<y+2;++k){\n\t\t\t\t\tfor(int j=x;j<x+4;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k=y;k<y+4;++k){\n\t\t\t\t\tfor(int j=x;j<x+2;++j){\n\t\t\t\t\t\tboard[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {\n\t\t}\n\t\telse dfs(board , xs , ys , w , h , xg , yg , sc);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\nint xg,yg;\n\nint DFS(int Y,int X,char c){\n  if(F[Y][X]!=c){\n    return 0;\n  }\n  if(Y == xg && X == yg){\n    return 1;\n  }\n\n  F[Y][X] = '0';\n\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  cin >> w >> h >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  if(DFS(xs,ys,F[xs][ys]) == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" << endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint field[101][101];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint heights[] = {2, 4};\nint widths[] = {4, 2};\nint w, h;\nint gx, gy;\n\nbool isMaze(int y, int x) {\n    if (y == gy && x == gx) {\n        return true;\n    }\n    int c = field[y][x];\n    field[y][x] = 0;\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        if (1 <= ny && ny <= h && 1 <= nx && nx <= w && field[ny][nx] == c && isMaze(ny, nx)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (true) {\n        cin >> w >> h;\n        if ((w | h) == 0) {\n            break;\n        }\n        int sx, sy, n;\n        cin >> sx >> sy >> gx >> gy >> n;\n        memset(field, 0, sizeof(field));\n        while (n--) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            for (int i = 0; i < heights[d]; i++) {\n                for (int j = 0; j < widths[d]; j++) {\n                    field[y + i][x + j] = c;\n                }\n            }\n        }\n        if (field[sy][sx] > 0 && field[sy][sx] == field[gy][gx] && isMaze(sy, sx)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nint w,h;\nbool** flags;\nchar** map;\n\nclass Point{\npublic:\n\tint X,Y;\n};\n\ntemplate <class T> T** NewArray(int w,int h){\n\tT** r = new T*[w];\n\tfor(int i=0;i<w;i++){\n\t\tr[i] = new T[h];\n\t\tfor(int j=0;j<h;j++){\n\t\t\tr[i][j] = 0;\n\t\t}\n\t}\n\treturn r;\n}\n\ntemplate <class T> void RemoveArray(T** array,int w,int h){\n\tfor(int i=0;i<h;i++){\n\t\tdelete[] array[i];\n\t}\n\tdelete[] array;\n}\n\nbool Check(int x,int y,int c){\n\tif(x<0){return false;}\n\tif(y<0){return false;}\n\tif(x>=w){return false;}\n\tif(y>=h){return false;}\n\tif(flags[x][y]){return false;}\n\tif(map[x][y] != c){return false;}\n}\n\nbool Solve(int sx,int sy,int gx,int gy){\n\tchar c = map[sx][sy];\n\tqueue<Point> pts;\n\tflags = NewArray<bool>(w,h);\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=0;j<h;j++){\n\t\t\tflags[i][j] = false;\n\t\t}\n\t}\n\tPoint p,pp;\n\tp.X = sx;\n\tp.Y = sy;\n\tpts.push(p);\n\tflags[sx][sy] = true;\n\t\n\tbool res = false;\n\t\n\twhile(pts.size() > 0){\n\t\tp = pts.front();\n\t\tpts.pop();\n\t\tif(flags[gx][gy] == true){\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\t\tpp = p;\n\t\tpp.X -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.X += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y -= 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t\tpp = p;\n\t\tpp.Y += 1;\n\t\tif(Check(pp.X,pp.Y,c)){ pts.push(pp); flags[pp.X][pp.Y]=true; }\n\t}\n\t\n\tRemoveArray<bool>(flags,w,h);\n\treturn res;\n}\n\nint main(){\n\tint xs,ys,xg,yg;\n\t\n\twhile(scanf(\"%d %d\",&w,&h) && w && h){\n\t\tmap = NewArray<char>(w,h);\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\txs -= 1;\n\t\tys -= 1;\n\t\txg -= 1;\n\t\tyg -= 1;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tint c,d,x,y;\n\t\tint xx,yy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\txx = 4;\n\t\t\t\tyy = 2;\n\t\t\t}else{\n\t\t\t\txx = 2;\n\t\t\t\tyy = 4;\n\t\t\t}\n\t\t\tx-=1;\n\t\t\ty-=1;\n\t\t\tfor(int j=0;j<xx;j++){\n\t\t\t\tfor(int k=0;k<yy;k++){\n\t\t\t\t\t//printf(\"(%2d+%2d,%2d+%2d) = %d\\n\",k,j,y,k,c);\n\t\t\t\t\tmap[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<h;j++){\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tprintf(\"%d \",map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tif(Solve(xs,ys,xg,yg)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}else{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tRemoveArray<char>(map,w,h);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[w][h] = 0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar F[102][102];\nvoid DFC(int y,int x);\nvoid block_set(int c,int d,int x,int y);\nint cs;\nint xg,yg;\nbool result = false;\n\nint main(){\n  int H,W;\n  while(1){\n    result = false;\n    cin >> H >> W;\n    if(H==0&&W==0)\n      break;\n    int xs,ys;\n    cin >> xs >> ys >> xg >> yg;\n    int n;\n    cin >> n;\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(i==0)\n        cs = c;\n        block_set(c,d,x,y);\n    }\n\n    DFC(xs,ys);\n\n    if(result)\n      cout << \"OK\" << endl;\n      else\n      cout << \"NG\" << endl;\n  }\n\n  return 0;\n}\n\nvoid DFC(int x,int y){\n  if(F[x][y]!=cs)\n    return;\n\n  if(x==xg,y==yg)\n    result = true;\n\n  F[x][y]=0;\n\n  DFC(x-1,y);\n  DFC(x+1,y);\n  DFC(x,y-1);\n  DFC(x,y+1);\n}\n\nvoid block_set(int c,int d,int x,int y){\n  for(int i=0;i<2;i++){\n    for(int j=0;j<4;j++){\n      if(d){\n        F[x+i][y+j] = c;\n      }\n      else{\n        F[x+j][y+i] = c;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define RREP(i,b) FFOR(i,1,b)\n#define PB push_back\n#define F first\n#define S second\n#define BE(c) c.begin(),c.end()\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef long double ld;\ntypedef pair<ut,ut> pr;\ntypedef vector<pr> Vpr;\ntypedef vector<ut> VI;\ntypedef pair<ut,pr> ppr;\ntypedef priority_queue<pr,Vpr, greater<pr> > PQ;\nconst int SIZE=5+3*1e+4;\nconst ut INF=1<<30;\nconst ld eps=1e-6;\nconst LL p=7+1e+9;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint W, H;\nint xs, ys, xg, yg;\nint N, C;\nint maze[128][128];\n\nint dfs(int x, int y){\n\tif(x == xg && y == yg)\n\t\treturn 1;\n\tmaze[y][x] = 0;\n\tint res = 0;\n\tREP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx > 0 && nx <= W && ny > 0 && ny <= H && maze[ny][nx] == C){\n\t\t\tres |= dfs(nx, ny);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin >> W >> H && (W || H)){\n\t\tmemset(maze, 0, sizeof(maze));\n\t\tcin >> xs >> ys >> xg >> yg >> N;\n\t\tint c, d, x, y;\n\t\tREP(i,N){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tREP(j,2)\n\t\t\t\t\tREP(k,4)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(j,4)\n\t\t\t\t\tREP(k,2)\n\t\t\t\t\t\tmaze[y + j][x + k] = c;\n\t\t\t}\n\t\t}\n\t\tC = maze[yg][xg];\n\t\tif(C == 0 || maze[ys][xs] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = dfs(xs, ys);\n\t\tif(ans){\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define Rrep(i, m, n) for(int i=(m);i<(n);i++)\n#define All(v) v.begin(),v.end()\n#define Uniq(v) v.erase(unique(All(v)),v.end())\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> Pip;\ntypedef pair<string, int> Psi;\ntypedef vector<int> Vi;\nconst int INF = (1<<30);\nconst int dx[]={1,0,-1,0}, dy[]={0,-1,0,1};\n\nint space[100][100];\nbool flag[100][100];\nint w, h;\nint sx, sy;\nint gx, gy;\nint n;\n\nbool bfs() {\n  queue<Pii> q;\n  int start_color = space[sy][sx];\n  q.push( Pii(sy, sx) );\n\n  while( !q.empty() ) {\n    Pii p = q.front(); q.pop();\n    int x = p.sc, y = p.fr;\n    flag[y][x] = true;\n    if( x == gx && y == gy ) return true;\n    Rep(i, 4) {\n      int nx = x+dx[i], ny = y+dy[i];\n      if( nx >= 0 && ny >= 0 && nx < w && ny < h && !flag[ny][nx] && space[ny][nx] == start_color ) {\n\tq.push( Pii(ny, nx) );\n      }\n    }\n  }\n\n  return false; \n}\n\nint main()\n{\n  while( cin >> w >> h, w+h ) {\n    fill_n(*space, 100*100, 0);\n    fill_n(*flag, 100*100, false);\n    cin >> sx >> sy; sx--; sy--;\n    cin >> gx >> gy; gx--; gy--;\n    cin >> n;\n\n    Rep(i, n) {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      if( d == 0 ) {\n\tRep(j, 2) {\n\t  Rep(k, 4) {\n\t    space[y+j][x+k] = c;\n\t  }\n\t}\n      } else {\n\tRep(j, 4) {\n\t  Rep(k, 2) {\n\t    space[y+j][x+k] = c;\n\t  }\n\t}\n      }\n    }\n\n    if( bfs() ) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint w,h;\nint field[101][101];\nint sx,sy;\nint gx,gy;\nint n;\nint color;\nbool ans;\n\nvoid DFS(int x,int y)\n{\n\tif(x == gx && y == gy){\n\t\tans = true;\n\t\treturn;\n\t}\n\tif(field[y][x] == -1)\n\t\treturn;\n\tfield[y][x] = -1;\n\tif(0<=x-1){\n\t\tif(color == field[y][x-1]){\n\t\t\tDFS(x-1,y);\n\t\t}\n\t}\n\tif(w>x+1){\n\t\tif(color == field[y][x+1]){\n\t\t\tDFS(x+1,y);\n\t\t}\n\t}\n\tif(0<=y-1){\n\t\tif(color == field[y-1][x]){\n\t\t\tDFS(x,y-1);\n\t\t}\n\t}\n\tif(h>y+1){\n\t\tif(color == field[y+1][x]){\n\t\t\tDFS(x,y+1);\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(!w&&!h)\n\t\t\tbreak;\n\t\tans = false;\n\t\tmemset(field,-1,sizeof(field));\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint c,d,x,y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 1){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 0){\n\t\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\t\tfield[y+i][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcolor = field[sy][sx];\n\t\tDFS(sx,sy);\n\t\tif(ans)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<MAX+2; i++ ) {\n      for ( int j=0; j<MAX+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n\n    next.push(y*1000 + x );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    /*\n    for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n\tcout << map[i+1][j+1];\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n    int xn,yn;\n    if ( map[yg][xg] == sc ) {\n      if ( sc == 0 || map[yg][xg] == 0 ) {\n      } else {\n      while ( !next.empty() ) {\n\tpoint = next.front();\n\tnext.pop();\n\txn = point%1000;\n\tyn = point/1000;\n\n\tif (map[yn][xn] == 0 )\n\t  continue;\n\n\tif (point == yg*1000+xg) {\n\t  goal = true;\n\t  break;\n\t}\n\n\tfor ( int i=0; i<4; i++ ) {\n\t  if ( check[yn+dy[i]][xn+dx[i]] ) {\n\t    check[yn+dy[i]][xn+dx[i]] = false;\n\t    if ( map[yn+dy[i]][xn+dx[i]] == sc ) {\n\t      next.push((yn+dy[i])*1000+ xn +dx[i]);\n\t    }\n\t  }\n\t}\n      }\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint F[105][105];\nint xg,yg;\n \n \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n \n  F[Y][X] = -2;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n \n \nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=0;\n      }\n    }\n     \n    cin >> xs >> ys >> xg >> yg >> n;\n \n \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n \n  if(F[xg][yg] == -2){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i-1)).at(y+j-1) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if( nx==xg && ny==yg) flag = 1;\n  else if( w<=nx+1 || h<=ny+1) return;\n  if(board[nx-1][ny-1]==board[nx][ny-1])\n    func(board,nx+1,ny);\n  if(board[nx-1][ny-1]==board[nx-1][ny])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  string res;\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      object[i].write(board);\n    }\n    func(board,xs,ys);\n    if(flag==1) res = \"OK\";\n    else res = \"NG\";\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nint map[size_max][size_max];\n\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\n\nvoid chek(int w, int h)\n{\n\tint i, j;\n\tfor (i = 0; i <= h + 1; i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue<PR> QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t\tchek(w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tnow = make_pair(ys, xs);\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] != -1)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = make_pair(now.Y + my[i], now.X + mx[i]);\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint board[110][110];\nbool used[110][110];\n\nint dx1[8] = {0,1,2,3,0,1,2,3};\nint dy1[8] = {0,0,0,0,1,1,1,1};\n\nint dx2[8] = {0,0,0,0,1,1,1,1};\nint dy2[8] = {0,1,2,3,0,1,2,3};\n\nbool dfs(int x, int y, int xg, int yg, int color) {\n    if (board[y][x] != color || used[y][x] || x <= 0 || y <= 0 || w < x || h < y) {\n        return false;\n    }\n    if (x == xg && y == yg) {\n        return true;\n    }\n    used[y][x] = true;\n    bool ret = false;\n    ret |= dfs(x+1, y, xg, yg, color);\n    ret |= dfs(x-1, y, xg, yg, color);\n    ret |= dfs(x, y+1, xg, yg, color);\n    ret |= dfs(x, y-1, xg, yg, color);\n    return ret;\n}\n\nint main() {\n    while (cin >> w >> h, (w || h)) {\n        memset(board, 0, sizeof board);\n        cin >> xs >> ys >> xg >> yg >> n;\n        int c, d, x, y;\n        for (int i=0; i<n; ++i) {\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                for (int i=0; i<8; ++i) {\n                    board[y + dy1[i]][x + dx1[i]] = c;\n                }\n            } else {\n                for (int i=0; i<8; ++i) {\n                    board[y + dy2[i]][x + dx2[i]] = c;\n                }\n            }\n        }\n        memset(used, false, sizeof used);\n        if (board[ys][xs] && dfs(xs, ys, xg, yg, board[ys][xs])) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n#include <queue>\n#include <complex>\n#include <climits>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint maze[110][110];\nint f[110][110];\nint w, h, xs, ys, xg, yg, res = 0;\nint color;\n\nvoid dfs(int cx, int cy){\n\tif(f[cx][cy]) return ;\n\tf[cx][cy] = 1;\n\tif(cx == xg && cy == yg){\n\t\tres = 1;\n\t\treturn ;\n\t}\n\tfor(int dx=-1; dx<=1; ++dx){\n\t\tfor(int dy=-1; dy<=1; ++dy){\n\t\t\tif(abs(dx-dy) != 1) continue;\n\t\t\tint nx = cx + dx, ny = cy + dy;\n\t\t\tif(maze[nx][ny] == color){\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> w >> h){\n\t\tres = 0;\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<110; ++i){\n\t\t\tfor(int j=0; j<110; ++j){\n\t\t\t\tmaze[i][j] = 6;\n\t\t\t\tf[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=h; ++i){\n\t\t\tfor(int j=1; j<=w; ++j){\n\t\t\t\tmaze[i][j] = 0;\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j=y; j<=y+1; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+3; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d == 1){\n\t\t\t\tfor(int j=y; j<=y+3; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+1; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor = maze[xs][ys];\n\t\tif(color == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(xs, ys);\n\n\t\tif(res){\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\nusing namespace std;\n\n#define X_MAX 100+10\n#define Y_MAX 100+10\n\n#define Vertical 1\n#define Horizontal 0\n\nint my[4] = { 1,-1,0,0 };\nint mx[4] = { 0,0,1,-1 };\n\nstruct ST\n{\n\tint came[Y_MAX][X_MAX];\n\tint now_y;\n\tint now_x;\n};\n\n\nvoid paint_V(int*map , int col)\n{\n\tint i;\n\tfor (i = 0; i < 2; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\nvoid paint_H(int*map, int col)\n{\n\tint i;\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\t*(map + i) = col;\n\t}\n}\n\n\nvoid chek(int map[Y_MAX][X_MAX],int lx,int ly)\n{\n\tint i, j;\n\tfor (i = 0; i <= ly+1;i++)\n\t{\n\t\tfor (j = 0; j <= lx+1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nint main(void)\n{\n\tST an = {0}, tmp;\n\tqueue<ST> ma;\n\n\tint lx, ly, n;\n\tint sx, sy, gx, gy;\n\tint col, VorH,set_x,set_y;\n\tint i, j;\n\n\twhile ((cin >> lx >> ly), lx!=0&&ly!=0)\n\t{\n\t\tint goal = 0;\n\t\tint map[Y_MAX][X_MAX] = { 0 };\n\t\tcin >> sx >> sy >> gx >> gy >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> col >> VorH >> set_x >> set_y;\n\t\t\tif (VorH == Vertical)\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_V(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tpaint_H(map[set_y + j] + set_x, col);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint s_col = map[sy][sx];\n\t\tif (s_col == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tan.now_y = sy;\n\t\tan.now_x = sx;\n\t\tma.push(an);\n\n\t\t//chek(map, lx, ly);\n\n\t\twhile (!ma.empty())\n\t\t{\n\t\t\tan = ma.front();\n\t\t\tma.pop();\n\t\t\t//an.came[an.now_y][an.now_x] = -1;\n\t\t\tif (map[an.now_y][an.now_x] == s_col)\n\t\t\t{\n\t\t\t\tmap[an.now_y][an.now_x] = -1;\n\n\t\t\t\t//printf(\"y=%d,x=%d\\n\", an.now_y, an.now_x);\n\t\t\t\t//chek(an.came, lx, ly);\n\n\t\t\t\tif (an.now_y == gy && an.now_x == gx)\n\t\t\t\t{\n\t\t\t\t\tgoal = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttmp = an;\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[an.now_y + my[i]][an.now_x + mx[i]] == s_col/* && an.came[an.now_y + my[i]][an.now_x + mx[i]] == 0*/)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp.now_y = an.now_y + my[i];\n\t\t\t\t\t\ttmp.now_x = an.now_x + mx[i];\n\t\t\t\t\t\tma.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (goal == 1)\n\t\t{\n\t\t\twhile (!ma.empty())\n\t\t\t{\n\t\t\t\tma.pop();\n\t\t\t}\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cassert>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n#define mp(a,b) make_pair(a,b)\n#define DEBUG(x) cerr<<#x<<\":\"<<x<<endl;\n\nint W, H;\nint SX, SY, GX, GY;\n\nint field[100][100];\n\ninline bool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid setBlock(int c, int d, int x, int y) {\n\tif(d == 0) {\n\t\tfor(int dy = 0; dy < 2; dy++) {\n\t\t\tfor(int dx = 0; dx < 4; dx++) {\n\t\t\t\tfield[x + dx][y + dy] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse if(d == 1) {\n\t\tfor(int dy = 0; dy < 4; dy++) {\n\t\t\tfor(int dx = 0; dx < 2; dx++) {\n\t\t\t\tfield[x + dx][y + dy] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tassert(false);\n}\n\nvoid pv() {\n\tcerr << endl;\n\tcerr << \"-----\" << endl;\n\tfor(int y = 0; y < H; y++) {\n\t\tfor(int x = 0; x < H; x++)\n\t\t\tcerr << field[x][y];\n\t\tcerr << endl;\n\t}\n\tcerr << \"-----\" << endl;\n}\n\nbool visit[100][100];\n\nint main() {\n\tfor(; cin >> W >> H, W || H;) {\n\t\tcin >> SX >> SY >> GX >> GY;\n\t\tSX--, SY--, GX--, GY--;\n\n\t\tmemset(field, 0, sizeof field);\n\t\tmemset(visit, 0, sizeof visit);\n\t\t\n\t\tint N; cin >> N;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--, y--;\n\t\t\tsetBlock(c, d, x, y);\n\t\t}\n\n\t\tqueue<P> Q;\n\t\tQ.push(mp(SX, SY));\n\t\tvisit[SX][SY] = true;\n\n\t\tint C = field[SX][SY];\n\n\t\tbool f = false;\n\t\twhile(!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif(p.first == GX && p.second == GY) {\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint dx[4] = {1, 0, -1, 0};\n\t\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif(inRange(nx, ny) && field[nx][ny] == C && visit[nx][ny] == false) {\n\t\t\t\t\tvisit[nx][ny] = true;\n\t\t\t\t\tQ.push(mp(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (f ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint h,w,a[100][100];\nint d1[]={0,0,1,-1},d2[]={1,-1,0,0};\nvoid dfs(int y,int x,int c){\n  a[y][x]=0;\n  for(int i=0;i<4;i++){\n    int yy=d2[i]+y,xx=d1[i]+x;\n    if(yy>=0&&xx>=0&&xx<w&&yy<h)\n      if(a[yy][xx]==c)\n        dfs(yy,xx,c);\n  }\n}\nint main(){\n  while(cin>>w>>h,h){\n    memset(a,0,sizeof(a));\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    sx--;sy--;gx--;gy--;\n    int m;\n    cin>>m;\n    while(m--){\n      int q,w,e,r;\n      cin>>q>>w>>e>>r;\n      w;e--;r--;\n      int dy[2][8] = {{0,0,0,0,1,1,1,1},{0,0,1,1,2,2,3,3}}, dx[2][8] = {{0,1,2,3,0,1,2,3},{0,1,0,1,0,1,0,1}};\n      for(int i=0;i<8;i++)\n        a[r+dy[w][i]][e+dx[w][i]]=q;\n    }\n    if(a[sy][sx]!=0){\n      dfs(sy,sx,a[sy][sx]);\n      if(a[gy][gx]==0)cout<<\"OK\"<<endl;\n      else goto L;\n    }\n    else{L:;\n      cout<<\"NG\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nint w, h;\nint xs, ys, xg, yg, n, c, d, x, y;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid put_b(int a[][105]) {\n  int X, Y;\n  if(d == 0) X = 4, Y = 2;\n  else X = 2, Y = 4 ;\n  for(int i = 0; i < Y; i++)\n    for(int j = 0; j < X; j++)\n      a[y + i][x + j] = c;\n}\n\nbool bfs(int a[][105]) {\n  int cs = a[ys][xs];\n  if(cs != a[yg][xg]) return false;\n\n  //cout << ys << xs << endl;\n  queue<P> que;\n  que.push(P(xs, ys));\n  while(que.size()) {\n    P p = que.front();\n    que.pop();\n    if(p.first == xg && p.second == yg) return true;\n    for(int i = 0; i < 4; i++) {\n      int nx = p.first + dx[i], ny = p.second + dy[i];\n      if(0 < nx && nx <= w && 0 < ny && ny <= h && a[ny][nx] == cs) {\n\tque.push(P(nx, ny));\n\ta[ny][nx] = 0;\n      }\n    }\n  }\n  return false;\n}\nint main() {\n  while(cin >> w >> h, w != 0 || h != 0) {\n    int a[105][105] = {};\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n  \n    while(n--) {\n      cin >> c >> d >> x >> y;\n      put_b(a);\n    }\n    /*\n     for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++)\n      cout << a[i][j];\n      cout << endl;\n      }\n    */\n    if(bfs(a) == true) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<h+2; i++ ) {\n      for ( int j=0; j<w+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n    next.push(y*100 + x );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n    /*\n    for ( int i=0; i<h; i++ ) {\n      for ( int j=0; j<w; j++ ) {\n\tcout << map[i+1][j+1];\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n    if ( map[yg][xg] == sc ) {\n\t\n      while ( !next.empty() ) {\n\tpoint = next.front();\n\tnext.pop();\n\n\tcheck[point/100][point%100] = false;\n\tif (map[point/100][point%100] == 0 )\n\t  continue;\n\n\tif (point == yg*100+xg) {\n\t  if ( sc == map[yg][xg] )\n\t    goal = true;\n\t  break;\n\t}\n\tfor ( int i=0; i<4; i++ ) {\n\t  if ( check[point/100+dy[i]][point%100+dx[i]] ) {\n\t    check[point/100+dy[i]][point%100+dx[i]] = false;\n\t    if ( map[point/100+dy[i]][point%100+dx[i]] == sc ) {\n\t      next.push((point/100+dy[i])*100+point%100+dx[i]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n\n\n  }\n\n\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n;\nint board[110][110];\nbool used[110][110];\n\nint dx1[8] = {0,1,2,3,0,1,2,3};\nint dy1[8] = {0,0,0,0,1,1,1,1};\n\nint dx2[8] = {0,0,0,0,1,1,1,1};\nint dy2[8] = {0,1,2,3,0,1,2,3};\n\nbool dfs(int x, int y, int xg, int yg, int color) {\n    if (board[y][x] != color || used[y][x] || x <= 0 || y <= 0 || w < x || h < y) {\n        return false;\n    }\n    if (x == xg && y == yg) {\n        return true;\n    }\n    used[y][x] = true;\n    bool ret = false;\n    ret |= dfs(x+1, y, xg, yg, color);\n    ret |= dfs(x-1, y, xg, yg, color);\n    ret |= dfs(x, y+1, xg, yg, color);\n    ret |= dfs(x, y-1, xg, yg, color);\n    return ret;\n}\n\nint main() {\n    while (cin >> w >> h, (w || h)) {\n        memset(board, 0, sizeof board);\n        cin >> xs >> ys >> xg >> yg >> n;\n        int c, d, x, y;\n        for (int i=0; i<n; ++i) {\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                for (int i=0; i<8; ++i) {\n                    board[y + dy1[i]][x + dx1[i]] = c;\n                }\n            } else {\n                for (int i=0; i<8; ++i) {\n                    board[y + dy2[i]][x + dx2[i]] = c;\n                }\n            }\n        }\n        memset(used, false, sizeof used);\n        if (dfs(xs, ys, xg, yg, c)) {\n            cout << \"OK\" << endl;\n        } else {\n            cout << \"NG\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  if(scolor==mass[gy][gx]){\n  \n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n  }\n  else {\n    cout<<\"NG\"<<endl;\n  }\n  }\n  \n  return 0;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n\n      //横長。\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      //縦長。\n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[1][1];\n    \n    bfs();\n    \n    if(goal==1){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n    \n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\td[ny][nx]=d[p.first][p.second]+1;\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint B[102][102];\nbool maze = false;\n\nvoid DFS(int Y, int X, int YG, int XG, int C)\n{\n  if(B[Y][X]!=C || C==0)\n    return;\n\n  if(Y==YG && X==XG)\n    maze = true;\n\n  B[Y][X] = 0;\n\n  DFS(Y-1, X  , YG, XG, C);\n  DFS(Y  , X+1, YG, XG, C);\n  DFS(Y+1, X  , YG, XG, C);\n  DFS(Y  , X-1, YG, XG, C);\n}\n\nint main()\n{\n  while(true){\n    int w, h;\n    cin >> w >> h;\n\n    if(w==0 && h==0)\n      break;\n\n    int xs, ys, xg, yg, n;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n\n    for(int y=0; y<=h; y++){\n      for(int x=0; x<=w; x++){\n\tB[y][x] = 0;\n      }\n    }\n\n    for(int i=0; i<n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      if(d==0){\n\tB[y  ][x  ] = c;\n\tB[y  ][x+1] = c;\n\tB[y  ][x+2] = c;\n\tB[y  ][x+3] = c;\n\tB[y+1][x  ] = c;\n\tB[y+1][x+1] = c;\n\tB[y+1][x+2] = c;\n\tB[y+1][x+3] = c;\n      }\n      else{\n       \tB[y  ][x  ] = c;\n\tB[y+1][x  ] = c;\n\tB[y+2][x  ] = c;\n\tB[y+3][x  ] = c;\n\tB[y  ][x+1] = c;\n\tB[y+1][x+1] = c;\n\tB[y+2][x+1] = c;\n\tB[y+3][x+1] = c;\n      }\n    }\n\n    maze = false;\n\n    DFS(ys, xs, yg, xg, B[ys][xs]);\n\n    if(maze){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = 0;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n \n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[101][101];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tint gc=board[xg][yg];\n\t\tif(sc!=gc) {}\n\t\telse dfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint w,h;\nint map[101][101];\nint xg,yg;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid mapout()\n{\n  for(int xx=0;xx<h;xx++,cout<<endl)\n    for(int yy=0;yy<w;yy++)\n      if(map[xx][yy]!=-1)\n      cout<<map[xx][yy];\n      else\n\tcout<<\"X\";\n}\n\nbool check(int x,int y)\n{\n  //  cout<<\"check \"<<x<<\" \"<<y<<\";\"<<map[x][y]<<endl;\n  if(x==xg&&y==yg)\n    return true;\n  int buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]>=0&&x+dx[i]<h&&\n\t y+dy[i]>=0&&y+dy[i]<w&&\n\t buf==map[x+dx[i]][y+dy[i]] &&\n\t map[x+dx[i]][y+dy[i]]!=-1 &&\n\t check(x+dx[i],y+dy[i]))\n\treturn true;\n    }\n\n  \n  return false;\n}\n\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>xs>>ys;\n      cin>>xg>>yg;\n      xs--;ys--;\n      xg--;yg--;\n      \n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  x--;y--;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      ///   mapout();\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;\n    }\n  \n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define int long long\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,c,d,x,y,nok,sc;\nint fld[101][101];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int fx,int fy){\n    if(fld[fy][fx]!=sc||nok==1||fx<0||fx>w-1||fy<0||fy>h-1)return;\n    if(fx==xg-1&&fy==yg-1){\n        if(sc==fld[fy][fx])nok=1;\n    }\n    fld[fy][fx]=0;\n    for(int i=0;i<4;i++){\n        dfs(fx+dx[i],fy+dy[i]);\n    }\n}\nsigned main(){\n    for(;;){\n        cin>>w>>h;\n        if(w==0&&h==0)break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        nok=0;\n        fill(fld[0],fld[0]+101,0);\n        for(int i=0;i<n;i++){\n            cin>>c>>d>>x>>y;\n            x--,y--;\n            if(d==0){\n                for(int j=0;j<2;j++){\n                    for(int k=0;k<4;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n            if(d==1){\n                for(int j=0;j<4;j++){\n                    for(int k=0;k<2;k++){\n                        fld[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        sc=fld[ys][xs];\n        dfs(0,0);\n        if(nok==1)cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\t/*for (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[100][100]={0},v[100][100]={0};\nint root(int x,int y,int vmap[][100]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int i1=0;i1<100;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint ac,w,h,sx,sy,gx,gy,mp[100][100],vx[4]={1,0,-1,0},vy[4]={0,1,0,-1};\n\nint check(int x,int y) {\n\tint i;\n\tmp[y][x]=-1;\n\tif (x==gx && y==gy) return 1;\n\tfor (i=0;i<4;i++) {\n\t\tif (x+vx[i]>=0 && x+vx[i]<w && y+vy[i]>=0 && y+vy[i]<h) {\n\t\t\tif (mp[y+vy[i]][x+vx[i]]==ac) {if (check(x+vx[i],y+vy[i])==1) return 1;}\n\t\t}\n\t}\n\treturn 0;\n} \n\nint main() {\n\tint i,j,k,n,c,d,x,y;\n\twhile(cin >> w >>  h) {\n\t\tif (w==0) break;\n\tfor (i=0;i<h;i++) for (j=0;j<w;j++) mp[i][j]=0;\t\n\tcin >> sx >> sy; \n\tcin >> gx >> gy;\n\tsx--; sy--; gx--; gy--;\n\tcin >> n;\n\tfor (k=0;k<n;k++) {\n\t\tcin >> c >> d >> x >> y;\n\t\tfor (i=0;i<d*2+2;i++) for (j=0;j<4-d*2;j++) mp[y+i-1][x+j-1]=c;\n\t\t}\n\tac=mp[sy][sx];\n\tif (mp[gy][gx]!=ac || ac==0) cout << \"NG\";  else { if (check(sx,sy)==1) cout << \"OK\"; else cout << \"NG\";}\n\tcout << endl;\n\t}  \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint map[105][105];\nint xg,yg;\nint w,h;\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\n\nbool check(int x,int y)\n{\n  if(x==xg && y==yg)\n    return true;\n  if(map[x][y]==-1)\n    return false;\n  if(x>h||y>w||x<=0||y<=0)\n    return false;\n  \n  char buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]<=h && x+dx[i]>0 &&\n\t y+dy[i]<=w && y+dy[i]>0 &&\n\t map[x+dx[i]][y+dy[i]]==buf && \n\t check(x+dx[i],y+dy[i])\n\t )\n\treturn true;\n    }\n  return false;\n}\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>ys>>xs;\n      cin>>yg>>xg;\n      int n;\n      cin>>n;\n      for(int i=0;i<n;i++)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;      \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n\n\n\n//マップの大きさの最大値\n#define MAP_MAX\t\t100\n//最初の歩数\n#define START\t\t1000000\n//マップの配列\nint wh_map[MAP_MAX + 1][MAP_MAX + 1];\n//縦・横に進むための配列\nint h_tate[4] = {1 , -1 , 0 , 0};\nint h_yoko[4] = {0 , 0 , 1 , -1};\n\n\n\n//----- blockの情報を持つ構造体 -----//\ntypedef struct block\n{\n\tint iro;\n\tint muki;\n\tint x;\n\tint y;\n}S_block;\n\n\n\n//----- 答えを返す関数 -----//\nbool f_ans(int , int  , int , int , int , int);\n\n\n//----- ブロックの入力は長くなるので関数で -----//\nint f_block_syokika(S_block[] , int , int , int);\n\n\n\n//----- マップを-1で初期化する変数 -----//\nvoid f_mapsyokika(void);\n\n\n\n//----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(メモリ節約のために構造体は参照で受ける) -----//\nvoid f_okmap(S_block[] , int , int , int , int);\n\n\n\n\n//*****----- main -----*****//\n\nint main(void)\n{\n\t//ボードの大きさ\n\tint tate = 0 , yoko = 0;\n\t//スタートの座標\n\tint startx = 0 , starty = 0;\n\t//ゴール座標\n\tint goalx = 0 , goaly = 0;\n\t//ブロックの個数\n\tint n = 0;\n\t//スタートと同じ色\n\tint startcolor = 0;\n\n\twhile (1)\n\t{\n\t\t//それぞれ入力\n\t\tscanf(\"%d%d\" , &tate , &yoko);\n\t\tif (tate == 0 && yoko == 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t//スタート・ゴール座標\n\t\tscanf(\"%d%d\" , &startx , &starty);\n\t\tscanf(\"%d%d\" , &goalx , &goaly);\n\t\t//ブロックの個数\n\t\tscanf(\"%d\" , &n);\n\n\t\t//ブロックの分だけ領域を確保する\n\t\tS_block *s_block = new S_block[n];\n\n\t\t//関数で初期化\n\t\tstartcolor = f_block_syokika(s_block , n , starty , startx);\n\t\t//次にマップを初期化\n\t\tf_mapsyokika();\n\n\t\t//mapにSTARTを振り分ける\n\t\tf_okmap(s_block , starty , startx , startcolor , n);\n\n\t\tif (f_ans(starty , startx , goaly , goalx , tate , yoko) == true)\n\t\t{\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\n\t\t//一度メモリを解放\n\t\tdelete []s_block;\n\t}\n}\n\n\n\n\n//*****----- ブロックの情報を入力する関数 -----*****//\n\nint f_block_syokika(S_block s_data[] , int n , int starty , int startx)\n{\n\t//スタートの色を取り出す変数\n\tint startcolor = 0;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d%d%d\" , &s_data[i].iro , &s_data[i].muki , &s_data[i].x , &s_data[i].y);\n\n\t\t//色を取り出す(横向きなら)\n\t\tif (s_data[i].muki == 1)\n\t\t{\n\t\t\t//横向きに設置したと仮定し、その中にスタート座標が含まれているかどうか調べる\n\t\t\tif ((starty <= s_data[i].y + 1 && starty >= s_data[i].y) && (startx >= s_data[i].x && startx <= s_data[i].x + 3))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t\t//縦向きだった\n\t\telse\n\t\t{\n\t\t\t//縦向きに設置したと仮定し、その中にスタート座標が含まれているか調べる\n\t\t\tif ((starty <= s_data[i].y + 3 && starty >= s_data[i].y) && (startx >= s_data[i].x && s_data[i].x + 1))\n\t\t\t{\n\t\t\t\tstartcolor = s_data[i].iro;\n\t\t\t}\n\t\t}\n\t}\n\n\t//初期座標の値を返す\n\treturn startcolor;\n}\n\n\n\n//*****----- 答えを求める関数 -----*****//\n\nbool f_ans(int starty , int startx , int goaly , int goalx , int tateindex , int yokoindex)\n{\n\t//幅優先探索で使うｙとｘ\n\tstd::queue<int> x;\n\tstd::queue<int> y;\n\n\t//最初の座標をキューに追加\n\ty.push(starty);\n\tx.push(startx);\n\n\t/*\n\tfor (int i = 1; i <= tateindex; i++)\n\t{\n\t\tfor (int j = 1; j <= yokoindex; j++)\n\t\t{\n\t\t\tif (wh_map[i][j] == START)\n\t\t\t{\n\t\t\t\tprintf(\"■\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"□\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\n\t//キューがなくなるまで\n\twhile (!x.empty())\n\t{\n\t\t//ｙ座標とｘ座標を取り出す\n\t\tint yy = y.front();\n\t\tint xx = x.front();\n\t\t//デキュー\n\t\ty.pop();\n\t\tx.pop();\n\n\t\t//ゴールにたどり着いた\n\t\tif (yy == goaly && xx == goalx)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t//今いる座標の値を吹っ飛ばす\n\t\twh_map[yy][xx] = -1;\n\n\t\t//四方に散れるか調べる\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\t//次に進む座標を取得\n\t\t\tint nexty = yy + h_tate[i];\n\t\t\tint nextx = xx + h_yoko[i];\n\n\t\t\t//まずは範囲内かどうか調べる\n\t\t\tif (nexty >= 1 && nexty <= tateindex && nextx >= 1 && nextx <= yokoindex)\n\t\t\t{\n\t\t\t\t//そこが通れる場所且つブロックの色が同じとき\n\t\t\t\tif (wh_map[nexty][nextx] == START)\n\t\t\t\t{\n\t\t\t\t\t//ｙとｘをそれぞれ追加\n\t\t\t\t\ty.push(nexty);\n\t\t\t\t\tx.push(nextx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n\n\n//*****----- マップを初期化する関数 -----*****//\n\nvoid f_mapsyokika(void)\n{\n\tfor (int i = 1; i < MAP_MAX + 1; i++)\n\t{\n\t\tfor (int j = 1; j < MAP_MAX + 1; j++)\n\t\t{\n\t\t\twh_map[i][j] = -1;\n\t\t}\n\t}\n}\n\n\n\n//*****----- 初期化したマップの中で、スタートと同じ色を持つブロックを座標に当てはめていく関数(構造体は配列) -----*****//\n\nvoid f_okmap(S_block s_data[] , int starty , int startx , int startcolor , int n)\n{\n\t//printf(\"color = %d\\n\" , startcolor);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (s_data[i].iro == startcolor)\n\t\t{\n\t\t\t//縦か横かによって挙動が変わる\n\t\t\tif (s_data[i].muki == 0)\n\t\t\t{\n\t\t\t\t//2 * 4マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0;k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + j][s_data[i].x + k] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//横だった\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 4 * 2マス初期化\n\t\t\t\tfor (int j = 0; j <= 1; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\twh_map[s_data[i].y + k][s_data[i].x + j] = START;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint w,h;\nint is(int x,int y){\n\treturn (x>=0 && x < w && y>=0 && y< h);\n}\nint main(void){\n\tconst int dx[4]={0,1,0,-1};\n\tconst int dy[4]={1,0,-1,0};\n\tint qx[100000];\n\tint qy[100000];\n\tint p,mx;\n    int n,m[101][101]={0};\n    int xs,ys,xg,yg,a,c,d,x,y,cnt,f;\n\tfor(;;){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\t//printf(\"%d %d\\n\",w,h);\n\t\tif(w==0)break;\n\t\tfor(int i=0;i<w;i++){\n\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\tm[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tfor(int j=0;j<(d==0?2:4);j++){\n\t\t\t\tfor(int k=0;k<(d==0?4:2);k++){\n\t\t\t\t\tm[x-1+k][y-1+j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc = m[xs-1][ys-1];\n\t\tp=0;\n\t\tmx=1;\n\t\tqx[0]=xs-1;\n\t\tqy[0]=ys-1;\n\t\tf=1;\n/*\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d \",m[j][i]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t\t\tprintf(\"%d\\n\",c);*/\n\t\twhile(f && p<mx){\n\t\t\tcnt = 0;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tx = qx[p] + dx[i];\n\t\t\t\ty = qy[p] + dy[i];\n\t\t\t\tif(is(x,y) && m[x][y] == c){\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tqx[p+cnt] = x;\n\t\t\t\t\tqy[p+cnt] = y;\n\t\t\t\t\tif(x == xg-1 && y == yg-1)f=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmx += cnt;\n\t\t\tp++;\n\t\t}\n\t\tputs(f?\"NG\":\"OK\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//メモリ数確認したか?\n#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\ntypedef long long int ll;\nbool s[100][100];\nint w,h,xs,ys,xg,yg,n;\nint boad[100][100];\nint c,d,x,y;\nint X[4]={-1,0,0,1};\nint Y[4]={0,-1,1,0};\nvoid f(int x,int y){\n\ts[x][y]=true;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>=0&&x+X[i]<h&&y+Y[i]>=0&&y+Y[i]<w){\n\t\t\tif(!s[x+X[i]][y+Y[i]]){\n\t\t\t\tif(boad[x][y]==boad[x+X[i]][y+Y[i]]){\n\t\t\t\tf(x+X[i],y+Y[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(true){\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tboad[i][j]=0;\n\t\t\ts[i][j]=false;\n\t\t}\n\t}\n\tscanf(\"%d%d\",&w,&h);\n\tif(w==0&&h==0)return 0;\n\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\tif(d==1){\n\t\t\tfor(int j=x-1;j<x+2-1;j++){\n\t\t\t\tfor(int k=y-1;k<y+4-1;k++){\n\t\t\t\t\tboad[k][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse{\n\t\t\tfor(int j=x-1;j<x+4-1;j++){\n\t\t\t\tfor(int k=y-1;k<y+2-1;k++){\n\t\t\t\t\tboad[k][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(boad[xs-1][ys-1]==0||boad[xg-1][yg-1]==0){\n\t\tprintf(\"NG\\n\");\n\t\tgoto a;\n\t}\n\tf(xs-1,ys-1);\n\t\n\tif(s[xg-1][yg-1]){\n\t\tprintf(\"OK\\n\");\n\t}\n\telse printf(\"NG\\n\");\na:;\n\t}\n    return 0;\n}\n//メモリ数確認したか?"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define INF 1010001000\n#define loop(i, n) for (int i = 0; i < n; i++)\n#define mp make_pair\ntypedef pair<int, int> i_i;\n\nbool dfs(vector<vector<int> > &g);\n\nint sx, sy, gx, gy;\nint n, m; \nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nint main()\n{\n\nwhile(cin >> n >> m,(n|m)){\n m++; n++;\n vector<vector<int> > graph(m,vector<int>(n,0));\n \n cin>>sx>>sy>>gx>>gy;\n int bl;  cin>>bl;\n loop(i, bl){\n  int a,b,c,t; cin>>a>>b>>c>>t;\n  if(b){\n   for(int j=t;j<t+2;j++){\n    for(int k=c;k<c+4;k++){\n     graph[k][j] = a;\n    }\n   } \n  } else {\n   for(int j=c;j<c+2;j++){\n    for(int k=t;k<t+4;k++){\n     graph[k][j] = a;\n    }\n   }\n  }\n }\ncout << ((dfs(graph)) ? \"OK\" : \"NG\") << endl;\n}\nreturn 0;\n}\n\nbool dfs(vector<vector<int> > &g) {\nint cl = g[sx][sy];\nvector<vector<bool> > vsed(m,vector<bool>(n,false));\nqueue<i_i > q;\nq.push(mp(sx,sy));\nwhile(!q.empty()){\nint x = q.front().first, y = q.front().second;\nq.pop();\nif(x == gx && y == gy){\nreturn true;\n}\nif(vsed[x][y]){\ncontinue;\n} else {\nvsed[x][y]=true;\n}\n\nloop(i, 4) {\nint nx = x +dx[i], ny = y +dy[i];\nif(0<nx && nx < n && 0<ny && ny < m){\nif(g[nx][ny] == cl){\nq.push(mp(nx,ny));\n}\n} \n}\n\n}\nreturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<numeric>\n#include<vector>\n#include<cstdio>\n#include<climits>\n#include<cfloat>\n#include<cstring>\n#define foreach(t,p,it) for(t::iterator it=p.begin(),it!=p.end(),++it)\n#define all(p) p.begin(),p.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\nusing namespace std;\n\nconst int W=210,H = 210;\nint block[W][H];\nint ans;\n\nint w,h,xs,ys,xg,yg,n,c,d,x,y;\nvoid solve(int xi,int yi)\n{\n    if(xi==xg && yi==yg){ ans = 1; return;}\n    if(block[xi][yi] == 0) return;\n\n    if(block[xi][yi] == c)\n    {\n        block[xi][yi] = 0;\n        solve(xi-1, yi);\n        solve(xi, yi-1);\n        solve(xi+1, yi);\n        solve(xi, yi+1);\n    }\n    block[xi][yi] = 0;\n    return;\n}\n\nint main()\n{\n    while(cin >> w >> h )\n    {\n        if(w==0 && h==0) break;\n        memset(block,0,sizeof(block));\n        ans = 0;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        cin >> n;\n        REP(n)\n        {\n            cin >> c >> d >> x >> y;\n            if(d == 1) //tate\n            {\n                block[x][y] = c;\n                block[x][y+1] =c;\n                block[x][y+2] = c;\n                block[x][y+3] = c;\n                block[x+1][y] = c;\n                block[x+1][y+1] = c;\n                block[x+1][y+2] = c;\n                block[x+1][y+3] = c;\n            }\n            else\n            {\n                block[x][y] = c;\n                block[x+1][y] = c;\n                block[x+2][y] = c;\n                block[x+3][y] = c;\n                block[x][y+1] = c;\n                block[x+1][y+1] = c;\n                block[x+2][y+1] = c;\n                block[x+3][y+1] = c;\n            }\n        }\n        c = block[xs][ys];\n        solve(xs,ys);\n\n        if(ans) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nbool dfs(int x,int y,int color);\nint w,h;\nint xs,ys;\nint xg,yg;\nint board[111][111];\nint cheak[111][111];\nint xd[]={0,-1,0,1};\nint yd[]={-1,0,1,0};\nint main(){\n  int n;\n  int c,d,x,y;\n  int a[]={1,0,1,0,1,0,1};\n  int b[]={0,1,1,2,2,3,3};\n  while(1){\n    cin >> w >> h;\n    if(w==0 && h==0) break;\n    memset(board,0,sizeof(board));\n    memset(cheak,0,sizeof(cheak));\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      board[y-1][x-1]=c;\n      for(int j=0;j<7;j++){\n\tif(d==0) board[y+a[j]-1][x+b[j]-1]=c;\n\telse board[y+b[j]-1][x+a[j]-1]=c;\n      }\n    }\n    if(board[ys][xs]!=0){\n      if(dfs(xs-1,ys-1,board[ys-1][xs-1])==true) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int x,int y,int color){\n  board[y][x]=0;\n  if(x==xg-1 && y==yg-1) return true;\n  for(int i=0;i<4;i++){\n    int xn=x+xd[i];\n    int yn=y+yd[i];\n    if(xn>=0 && xn<w && yn>=0 && yn<h && board[yn][xn]==color && board[yn][xn]!=0){\n      if(dfs(xn,yn,board[yn][xn])==true) return true;\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, xs, ys, xg, yg, n, sc;\nint map[101][101];\nint dx[] = {1, 0, -1, 0},\tdy[] = {0, 1, 0, -1};\nint hx[] = {0, 1, 2, 3, 0, 1, 2 ,3}, hy[] = {0, 0, 0, 0, 1, 1, 1, 1};\nint vx[] = {0, 0, 0, 0, 1, 1, 1, 1}, vy[] = {0, 1, 2, 3, 0, 1, 2, 3};\nbool flag = false;\n\nvoid dfs(int x, int y){\n\tif(x == xg && y == yg){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tmap[y][x] = 9;\n\tfor(int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif(1 <= nx && nx <= w && 1 <= ny && ny <= h && map[ny][nx] == sc)\tdfs(nx, ny);\n\t}\n\treturn;\n}\n\nint main(void){\n\twhile(true){\n\t\tint c, d, x, y;\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0)\tbreak;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 8; j++)\tmap[y+hy[j]][x+hx[j]] = c;\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 8; j++)\tmap[y+vy[j]][x+vx[j]] = c;\n\t\t\t}\n\t\t}\n\t\tsc = map[ys][xs];\n\t\tdfs(xs, ys);\n\t\tif(flag)\tcout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\t\tif(ban[x][y+1]==c&&visited[x][y+1]==false){\n\t\t\tvisited[x][y+1]=true;\n\t\t\tif(dfs(x,y+1,c))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==c&&visited[x-1][y]==false){\n\t\t\tvisited[x-1][y]=true;\n\t\t\tif(dfs(x-1,y,c))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==c&&visited[x][y-1]==false){\n\t\t\tvisited[x][y-1]=true;\n\t\t\tif(dfs(x,y-1,c))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=-1,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(dfs(xs,ys,ban[xs][ys]))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nclass cordinate\n{\n\npublic:\n\tint x;\n\tint y;\n\n};\n\nint main()\n{\n\twhile(1)\n\t{\n\n\n\t\tint w;\n\t\tint h;\n\t\tcin >> w >> h; \n\t\tif(w == 0 && h == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint xs;\n\t\tint ys;\n\t\tcin >> xs >> ys;\n\t\tint xg;\n\t\tint yg;\n\t\tcin >> xg >> yg;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<vector<int >> vobj;\n\n\t\tfor(int i = 0; i < h; i++)\n\t\t{\n\t\t\tvector<int> lineobj;\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\n\t\t\t\tlineobj.push_back(0);\n\n\t\t\t}\n\t\t\tvobj.push_back(lineobj);\n\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif(d == 0)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 2][y] = c;\n\t\t\t\tvobj[x + 3][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 2][y + 1] = c;\n\t\t\t\tvobj[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\telse if(d == 1)\n\t\t\t{\n\t\t\t\tvobj[x][y] = c;\n\t\t\t\tvobj[x][y + 1] = c;\n\t\t\t\tvobj[x][y + 2] = c;\n\t\t\t\tvobj[x][y + 3] = c;\n\t\t\t\tvobj[x + 1][y] = c;\n\t\t\t\tvobj[x + 1][y + 1] = c;\n\t\t\t\tvobj[x + 1][y + 2] = c;\n\t\t\t\tvobj[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0; i < w - 1; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < h - 1; j++)\n\t\t\t{\n\t\t\t\tcout << vobj[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint startColor;\n\t\tstartColor = vobj[xs - 1][ys - 1];\n\t\tqueue<cordinate> que;\n\n\t\tcordinate obj;\n\t\tobj.x = xg - 1;\n\t\tobj.y = yg - 1;\n\t\tque.push(obj);\n\t\tbool flag = false;\n\t\twhile(1)\n\t\t{\n\t\t\tif(startColor == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcordinate buf;\n\t\t\tbuf = que.front();\n\t\t\tque.pop();\n\n\t\t\tint bx;\n\t\t\tint by;\n\t\t\tbx = buf.x;\n\t\t\tby = buf.y;\n\t\t\tif(bx == xg - 1 && by == yg - 1)\n\t\t\t{\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif(bx + dx[i] >= 0 && bx + dx[i] <= w - 1)\n\t\t\t\t{\n\t\t\t\t\tif(by + dy[i] >= 0 && by + dy[i] <= h - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(vobj[bx + dx[i]][by + dy[i]] == startColor)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcordinate newObject;\n\t\t\t\t\t\t\tnewObject.x = bx + dx[i];\n\t\t\t\t\t\t\tnewObject.y = by + dy[i];\n\t\t\t\t\t\t\tque.push(newObject);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvobj[bx][by] = 0;\n\n\t\t\tif(que.size() == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(flag == true)\n\t\t{\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <exception>\n\nusing namespace std;\n\nint table[100][100];\nint memo[100][100];\n\nint w, h;\nint xs, ys, xg, yg;\nint n;\n\nvoid solve(int xs, int ys, int c)\n{\n\tif( memo[xs][ys] ) {\n\t\treturn;\n\t}\n\n\tif( !( 0 < xs && xs < w+1 && 0 < ys && ys < h+1 && table[xs][ys] == c ) ) {\n\t\tmemo[xs][ys] = 1;\n\t\treturn;\n\t}\n\t\n\tif( xs == xg && ys == yg ) {\n\t\tmemo[xs][ys] = 1;\n\t\tthrow string(\"OK\");\n\t}\n\n\tmemo[xs][ys] = 1;\t\n\n\tsolve(xs+1, ys, c);\n\tsolve(xs, ys+1, c);\t\n\tsolve(xs-1, ys, c);\n\tsolve(xs, ys-1, c);\n\n\treturn;\n}\n\nint main(int argc, char* argv[])\n{\n\twhile(1) {\n\n\t\tfor( int i = 0; i < 100; i++ ) {\n\t\t\tfor( int j = 0; j < 100; j++ ) {\n\t\t\t\ttable[i][j] = 0;\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t}\t\t\n\n\t\tcin >> w >> h;\n\n\t\tif( w == 0 && h == 0 )\n\t\t\tbreak;\n\t\t\t\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor( int i = 0; i < n; i++ ) {\n\n\t\t\tint c; cin >> c;\n\t\t\tint d; cin >> d;\n\t\t\tint x, y; cin >> x >> y;\n\n\t\t\ttable[x][y] = c;\n\t\t\ttable[x][y+1] = c;\n\t\t\ttable[x+1][y] = c;\n\t\t\ttable[x+1][y+1] = c;\n\n\t\t\tif( d == 0 ) {\n\n\t\t\t\ttable[x+2][y] = c;\n\t\t\t\ttable[x+2][y+1] = c;\n\t\t\t\ttable[x+3][y] = c;\n\t\t\t\ttable[x+3][y+1] = c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\t\t} else {\n\n\t\t\t\ttable[x][y+2] = c;\n\t\t\t\ttable[x+1][y+2] = c;\n\t\t\t\ttable[x][y+3] = c;\n\t\t\t\ttable[x+1][y+3] = c;\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif( table[xs][ys] )\n\t\t\t\tsolve(xs, ys, table[xs][ys]);\n\t\t\tcout << \"NG\" << endl;\n\t\t} catch(string& msg) {\n\t\t\tcout << msg << endl;\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid setblock(int c, int d, int x, int y){\n  if(d==0){\n    for(int i=0;i<4;i++){\n      F[y][x+i]=c;\n      F[y+1][x+i]=c;\n    }\n  }else{\n    for(int i=0;i<4;i++){\n      F[y+i][x]=c;\n      F[y+i][x+1]=c;\n    }\n  }\n\n}\n\nvoid DFS(int Y, int X, int c){\n  if(F[Y][X]!=c)\n    return;\n\n  F[Y][X] = 6;\n\n  DFS(Y-1, X  ,c);\n  DFS(Y  , X+1,c);\n  DFS(Y+1, X  ,c);\n  DFS(Y  , X-1,c);\n}\n\nint main(){\n  int w,h,xs,ys,xg,yg,n;\n  while(true){\n  cin >> w >> h;\n  for(int i=0;i<h;i++){\n   for(int k=0;k<w;k++){\n     F[i][k]=-1;\n   }\n  }\n  if(w==0&&h==0){\n    break;\n  }\n  cin >> xs >> ys;\n  cin >> xg >> yg;\n  cin >> n;\n  for(int i=0; i<n; i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    setblock(c,d,x,y);\n  }\n\n  DFS(ys,xs,F[ys][xs]);\n  if(F[yg][xg]==6){\n    cout << \"OK\" << endl;\n  }else{\n    cout << \"NG\" << endl;\n  }\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint dx[] = { 1,-1,0,0 };\nint dy[] = { 0,0,1,-1 };\nint w, h;\n\nint check(int xs, int ys, int xg, int yg ,int c, int board[110][110]) {\n\tint used[110][110] = { 0 };\n\tqueue<pl> q;\n\tq.push({ xs, ys });\n\n\twhile (!q.empty()) {\n\t\tint x = q.front().first;\n\t\tint y = q.front().second;\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint ddx = dx[i] + x;\n\t\t\tint ddy = dy[i] + y;\n\t\t\tif (ddx >= 1 && ddx <= w && ddy >= 1 && ddy <= h && !used[ddy][ddx]) {\n\t\t\t\tused[ddy][ddx] = 1;\n\t\t\t\tif (board[ddy][ddx] == c && ddy == yg && ddx == xg)return 1;\n\t\t\t\telse if (board[ddy][ddx] == c) {\n\t\t\t\t\tq.push({ddx,ddy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w, h) \n\t{\n\t\tint xs, ys, xg, yg;\n\t\tint n;\n\t\tint board[110][110] = { 0 };\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{ \n\t\t\tint c,d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (!d){\n\t\t\t\tfor (int i = y; i < y+2; i++) {\n\t\t\t\t\tfor (int j = x; j < x+4; j++) \n\t\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = y; i < y+4; i++) {\n\t\t\t\t\tfor (int j = x; j < x+2; j++)\n\t\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (check(xs, ys, xg, yg, board[ys][xs], board))\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n\n\ntypedef vector<vector<int> > Matrix;\nint w,h,xs,ys,xg,yg,n,flag;\n\nclass Block{\npublic:\n  int color;\n  int direction;\n  int x,y,dx,dy;\n  void write(Matrix &board){\n    if(direction == 0)\n      dx = 4,dy = 2;\n    else if(direction == 1)\n      dx = 2,dy = 4;\n    for(int i=0; i<dx; ++i){\n      for(int j=0; j<dy; ++j){\n\t(board.at(x+i-1)).at(y+j-1) = color;\n      }\n    }\n  }\n};\n  \nvoid func(Matrix &board,int nx,int ny){\n  if( nx==xg && ny==yg) flag = 1;\n  else if( w<=nx+1 || h<=ny+1) return;\n  if(board[nx][ny]==board[nx+1][ny])\n    func(board,nx+1,ny);\n  if(board[nx][ny]==board[nx][ny+1])\n    func(board,nx,ny+1);\n}\n\n\nint main(void){\n  string res;\n  while(1){\n    cin >> w >> h;\n    if( w==0 && h==0) return 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n    Block *object;\n    object = new Block[n];\n    Matrix board(w, vector<int>(h,0));\n    for(int i=0; i<n; ++i){\n      cin >> object[i].color;\n      cin >> object[i].direction;\n      cin >> object[i].x;\n      cin >> object[i].y;\n      object[i].write(board);\n    }\n    func(board,xs,ys);\n    if(flag==1) res = \"OK\";\n    else res = \"NG\";\n    cout << res << endl;\n    flag = 0;\n    delete[] object;\n    board.clear();\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct cordinate{\n        int y;\n        int x;\n};\ncordinate SIZE,Start,Goal;\nstruct Blocks{\n        int color;\n        int direction;\n        int y;\n        int x;\n};\nBlocks block[100];\nint N,board[100][100];\nint Color,dp[100][100];\nint recursion(int y,int x){\n        int res=0;\n        if(y==Goal.y && x==Goal.x){\n                res=1;\n        }\n        else{\n                dp[y][x]=0;\n                if(board[y+1][x]==Color && dp[y+1][x]==-1)\n                        res+=recursion(y+1,x);\n                if(board[y-1][x]==Color && dp[y-1][x]==-1)\n                        res+=recursion(y-1,x);\n                if(board[y][x+1]==Color && dp[y][x+1]==-1)\n                        res+=recursion(y,x+1);\n                if(board[y][x-1]==Color && dp[y][x-1]==-1)\n                        res+=recursion(y,x-1);\n        }\n        return dp[y][x]=res;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<100 ; i++ )\n                        for(int j=0 ; j<100 ; j++ )\n                                dp[i][j]=-1;\n                cin >> SIZE.x >> SIZE.y;\n                if(SIZE.x+SIZE.y==0)\n                        break;\n                cin >> Start.x >> Start.y;\n                cin >> Goal.x >> Goal.y;\n                cin >> N;\n                for(int i=0 ; i<N ; i++ ){\n                        cin >> block[i].color >> block[i].direction;\n                        cin >> block[i].x >> block[i].y;\n                        if(block[i].direction){\n                                for(int l=block[i].y ; l<block[i].y+4 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+2 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                        else{\n                                for(int l=block[i].y ; l<block[i].y+2 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+4 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                }\n                Color=board[Start.y][Start.x];\n                if(recursion(Start.y,Start.x)>0)\n                        cout <<\"OK\"<<endl;\n                else\n                        cout <<\"NG\"<<endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w,h){\n\t\tchar board[114][514];\n\t\tint pass[114][514];\n\t\t\n\t\tint xs,ys,xg,yg;\n\t\tcin>>xs>>ys>>xg>>yg;\n\t\t\n\t\tfor(int i=0;i<=110;i++){\n\t\tfor(int j=0;j<=110;j++){pass[i][j]=INF;\n\t\t\tboard[i][j]='#';\n\t\t\t}}\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a;\n\t\t\tint b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\t\n\t\t\tif(b==0){\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\tfor(int k=0;k<4;k++)board[d+j][c+k]=a;\n\t\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\tfor(int k=0;k<4;k++)board[d+k][c+j]=a;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\n\t\tqueue<P>Q;\n\t\tQ.push(P(ys,xs));\n\t\tpass[ys][xs]=0;\n\t\t\n\t\twhile(Q.size()){\n\t\t\tP p=Q.front();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif(p.first==yg&&p.second==xg)break;\n\t\t\t\n\t\t\tint dir[2][4]={{1,0,-1,0},{0,1,0,-1}};\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=p.first+dir[0][i];\n\t\t\t\tint nx=p.second+dir[1][i];\n\t\t\t\t\n\t\t\t\tif(0<=ny&&ny<=h&&0<=nx&&nx<=w&&board[ny][nx]==board[ys][xs]&&pass[ny][nx]==INF){\n\t\t\t\t\tQ.push(P(ny,nx));\n\t\t\t\t\tpass[ny][nx]=pass[p.first][p.second]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif(pass[yg][xg]!=INF)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\n\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nvector<int> c(200);\nvector<int> d(200);\nvector<int> x(200);\nvector<int> y(200);\nvector<vector<bool>> visited(200,vector<bool>(200,0));\nvector<vector<int>> maze(200,vector<int>(200,0));\n\nvoid dfs(int x,int y){\n\n    if(visited[x][y]) return ;\n    if(maze[xs][ys]!=maze[x][y]) return ;\n \n    visited[x][y]=true;\n\n    if(x<w) dfs(x+1,y);\n    if(x>1) dfs(x-1,y);\n    if(y<h)dfs(x,y+1);\n    if(y>1)dfs(x,y-1);\n\n}\n\nint main(){\n    while(true){\n        cin>>w>>h;\n        if(w==0&&h==0) break;\n        cin>>xs>>ys;\n        cin>>xg>>yg;\n        cin>>n;\n        \n        c=vector<int>(200,0);\n        d=vector<int>(200,0);\n        x=vector<int>(200,0);\n        y=vector<int>(200,0);\n        visited=vector<vector<bool>>(200,vector<bool>(200,0));\n       \n        for(int i=0;i<n;i++){\n            cin>>c[i]>>d[i]>>x[i]>>y[i];\n            if(d[i]){\n                for(int j=0;j<4;j++)\n                for(int k=0;k<2;k++)\n                maze[x[i]+k][y[i]+j]=c[i];\n            }else{\n                for(int j=0;j<2;j++)\n                for(int k=0;k<4;k++)\n                maze[x[i]+k][y[i]+j]=c[i];\n            }\n        }\n        dfs(xs,ys);\n        if(visited[xg][yg]&&maze[xs][ys]) cout<<\"OK\"<<endl;\n        else cout<<\"NG\"<<endl;\n        \n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint xg,yg,w,h,n;\nchar a[1000][1000],s;\n \nbool dfs(int x,int y)\n{\n        if(x==xg&&y==yg)\n                return true;\n        a[y][x]='0';\n        if(0<=x&&x<w&&0<=y-1&&y-1<h&&a[y-1][x]==s)\n                if(dfs(x,y-1)) return true;\n        if(0<=x&&x<w&&0<=y+1&&y+1<h&&a[y+1][x]==s)\n                if(dfs(x,y+1)) return true;\n        if(0<=x-1&&x-1<w&&0<=y&&y<h&&a[y][x-1]==s)\n                if(dfs(x-1,y))  return true;\n        if(0<=x+1&&x+1<w&&0<=y&&y<h&&a[y][x+1]==s)\n                if(dfs(x+1,y)) return true;\n        return false;\n}\n \nint main()\n{\n        int xs,ys,xb,yb,co,d,i,j;\n        while(cin>>w>>h,w)\n        {\n                cin>>xs>>ys>>xg>>yg;\n                for(i=0;i<h;i++)\n                {\n                        for(j=0;j<w;j++)\n                        {\n                                a[i][j]='0';\n                        }\n                }\n                cin>>n;\n                for(i=0;i<n;i++)\n                {\n                        cin>>co>>d>>xb>>yb;\n                        if(d)\n                        {\n                                if(co==1)\n                                {\n                                        a[yb][xb]='1';\n                                        a[yb][xb+1]='1';\n                                        a[yb+1][xb]='1';\n                                        a[yb+1][xb+1]='1';\n                                        a[yb+2][xb]='1';\n                                        a[yb+2][xb+1]='1';\n                                        a[yb+3][xb]='1';\n                                        a[yb+3][xb+1]='1';\n                                }\n                                else if(co==2)\n                                {\n                                        a[yb][xb]='2';\n                                        a[yb][xb+1]='2';\n                                        a[yb+1][xb]='2';\n                                        a[yb+1][xb+1]='2';\n                                        a[yb+2][xb]='2';\n                                        a[yb+2][xb+1]='2';\n                                        a[yb+3][xb]='2';\n                                        a[yb+3][xb+1]='2';\n                                }\n                                else if(co==3)\n                                {\n                                        a[yb][xb]='3';\n                                        a[yb][xb+1]='3';\n                                        a[yb+1][xb]='3';\n                                        a[yb+1][xb+1]='3';\n                                        a[yb+2][xb]='3';\n                                        a[yb+2][xb+1]='3';\n                                        a[yb+3][xb]='3';\n                                        a[yb+3][xb+1]='3';\n                                }\n                                else if(co==4)\n                                {\n                                        a[yb][xb]='4';\n                                        a[yb][xb+1]='4';\n                                        a[yb+1][xb]='4';\n                                        a[yb+1][xb+1]='4';\n                                        a[yb+2][xb]='4';\n                                        a[yb+2][xb+1]='4';\n                                        a[yb+3][xb]='4';\n                                        a[yb+3][xb+1]='4';\n                                }\n                                else\n                                {\n                                        a[yb][xb]='5';\n                                        a[yb][xb+1]='5';\n                                        a[yb+1][xb]='5';\n                                        a[yb+1][xb+1]='5';\n                                        a[yb+2][xb]='5';\n                                        a[yb+2][xb+1]='5';\n                                        a[yb+3][xb]='5';\n                                        a[yb+3][xb+1]='5';\n                                }\n                        }\n                        else\n                        {\n                                if(co==1)\n                                {\n                                        a[yb][xb]='1';\n                                        a[yb+1][xb]='1';\n                                        a[yb][xb+1]='1';\n                                        a[yb+1][xb+1]='1';\n                                        a[yb][xb+2]='1';\n                                        a[yb+1][xb+2]='1';\n                                        a[yb][xb+3]='1';\n                                        a[yb+1][xb+3]='1';\n                                }\n                                else if(co==2)\n                                {\n                                        a[yb][xb]='2';\n                                        a[yb+1][xb]='2';\n                                        a[yb][xb+1]='2';\n                                        a[yb+1][xb+1]='2';\n                                        a[yb][xb+2]='2';\n                                        a[yb+1][xb+2]='2';\n                                        a[yb][xb+3]='2';\n                                        a[yb+1][xb+3]='2';\n                                }\n                                else if(co==3)\n                                {\n                                        a[yb][xb]='3';\n                                        a[yb+1][xb]='3';\n                                        a[yb][xb+1]='3';\n                                        a[yb+1][xb+1]='3';\n                                        a[yb][xb+2]='3';\n                                        a[yb+1][xb+2]='3';\n                                        a[yb][xb+3]='3';\n                                        a[yb+1][xb+3]='3';\n                                }\n                                else if(co==4)\n                                {\n                                        a[yb][xb]='4';\n                                        a[yb+1][xb]='4';\n                                        a[yb][xb+1]='4';\n                                        a[yb+1][xb+1]='4';\n                                        a[yb][xb+2]='4';\n                                        a[yb+1][xb+2]='4';\n                                        a[yb][xb+3]='4';\n                                        a[yb+1][xb+3]='4';\n                                }\n                                else\n                                {\n                                        a[yb][xb]='5';\n                                        a[yb+1][xb]='5';\n                                        a[yb][xb+1]='5';\n                                        a[yb+1][xb+1]='5';\n                                        a[yb][xb+2]='5';\n                                        a[yb+1][xb+2]='5';\n                                        a[yb][xb+3]='5';\n                                        a[yb+1][xb+3]='5';\n                                }\n                        }\n                }\n                n=0;\n                s=a[ys][xs];\n                if(s!='0'){\n                        if(dfs(xs,ys)){\n                        \tcout<<\"OK\"<<endl;\n                        }\n                        else {\n                        \tcout<<\"NG\"<<endl;\n                        }\n                 }\n//                if(n)\n//                        cout<<\"OK\"<<endl;\n//                else\n//                        cout<<\"NG\"<<endl;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <cstdio>\n#include <cctype>\n#include <queue>\n#include <complex>\n#include <climits>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint maze[110][110];\nint f[110][110];\nint w, h, xs, ys, xg, yg, res = 0;\nint color;\n\nvoid dfs(int cx, int cy){\n\tif(f[cx][cy]) return ;\n\tf[cx][cy] = 1;\n\n\tif(cx == xg && cy == yg){\n\t\tres = 1;\n\t\treturn ;\n\t}\n\tfor(int dx=-1; dx<=1; ++dx){\n\t\tfor(int dy=-1; dy<=1; ++dy){\n\t\t\tif(abs(dx-dy) != 1) continue;\n\t\t\tint nx = cx + dx, ny = cy + dy;\n\t\t\tif(maze[nx][ny] == color){\n\t\t\t\tdfs(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0) break;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<110; ++i){\n\t\t\tfor(int j=0; j<110; ++j){\n\t\t\t\tmaze[i][j] = 0;\n\t\t\t\tf[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j=y; j<=y+1; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+3; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d == 1){\n\t\t\t\tfor(int j=y; j<=y+3; ++j){\n\t\t\t\t\tfor(int k=x; k<=x+1; ++k){\n\t\t\t\t\t\tmaze[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcolor = maze[xs][ys];\n\n\t\tdfs(xs, ys);\n\n\t\tif(res){\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint w,h,xg,yg,n,ans = 0;\nint mas[110][110];\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\nvoid block(int x, int y, int m);\nint main(){\n  int c,d,x,y,xs,ys;\n  while(1){\n    memset(mas,0,sizeof(mas));\n    ans = 0;\n    scanf(\"%d %d\",&w,&h);\n    if(w == 0 && h == 0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    for(int u = 0; u < n; u++){\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n\tfor(int i = y; i < y + 2; i++){\n\t  for(int j = x; j < x + 4; j++){\n\t    mas[i][j] = c;\n\t  }\n\t}\n      }\n      else {\n\tfor(int i = y; i < y + 4; i++){\n\t  for(int j = x; j < x + 2; j++){\n\t    mas[i][j] = c;\n\t  }\n\t}\n      }\n    }\n    if(mas[ys][xs] != 0){\n      block(xs,ys,mas[ys][xs]);\n    }\n    if(ans == 1)cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}\n\nvoid block(int x, int y, int m){\n  if(x == xg && y == yg){\n    ans = 1;\n    return ;\n  }\n  mas[y][x] = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(mas[ny][nx] == m && nx <= w && nx > 0 && ny <= h && ny > 0 && mas[ny][nx] != 0){\n      block(nx,ny,mas[ny][nx]);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\n \nvoid meiro(int W,int H,int c){\n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = -1;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w==0 && h==0){\n      break;\n    }\n \n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 10;\n      }\n    }\n \n    int xs,ys,xg,yg;\n    cin >> xs >> ys >> xg >> yg;\n \n    int n;\n    cin >> n;\n \n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }else{\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n \n    meiro(xs,ys,C[xs][ys]);\n \n    if(C[xg][yg] == -1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h;\nint field[104][104];\nint gx,gy;\nint sc;\n\nvoid init()\n{\n\tfor(int i=0;i<104;i++){\n\t\tfor(int j=0;j<104;j++){\n\t\t\tfield[i][j] = 0;\n\t\t}\n\t}\n}\nbool search(int x,int y)\n{\n\tbool flag = false;\n\tif(x == gx && y == gy)\n\t\tflag = true;\n\telse{\n\t\tint vectorx[4] = {-1,0,1,0},vectory[4] = {0,-1,0,1};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(x+vectorx[i] >= 0 && y+vectory[i] >= 0 && x+vectorx[i] < w && y+vectory[i] < h){\n\t\t\t\tif(field[x+vectorx[i]][y+vectory[i]] == sc){\n\t\t\t\t\tfield[x][y] = -1;\n\t\t\t\t\tflag |= search(x+vectorx[i],y+vectory[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\nint main()\n{\n\twhile(cin >> w >> h){\n\t\tif(w == 0 && h == 0)\n\t\t\tbreak;\n\t\tinit();\n\t\tint sx,sy;\n\t\tcin >> sx >> sy;\n\t\tcin >> gx >> gy;\n\t\tint n,c,x,y;\n\t\tbool d;\n\t\tcin >> n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tint vectorx,vectory;\n\t\t\tif(d == 0){\n\t\t\t\tvectorx = 4;vectory = 2;\n\t\t\t}else{\n\t\t\t\tvectorx = 2;vectory = 4;\n\t\t\t}\n\t\t\tfor(int j=0;j<vectorx;j++){\n\t\t\t\tfor(int k=0;k<vectory;k++){\n\t\t\t\t\tfield[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc = field[sx][sy];\n\t\tif(field[sx][sy] == 0 || field[gx][gy] == 0)\n\t\t\tcout << \"NG\" << endl;\n\t\telse{\n\t\t\tif(search(sx,sy))\n\t\t\t\tcout << \"OK\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstruct cordinate{\n        int y;\n        int x;\n};\ncordinate SIZE,Start,Goal;\nstruct Blocks{\n        int color;\n        int direction;\n        int y;\n        int x;\n};\nBlocks block[200];\nint N,board[200][200];\nint Color,dp[200][200];\nint recursion(int y,int x){\n        int res=0;\n        if(y==Goal.y && x==Goal.x){\n                res=1;\n        }\n        else if(dp[y][x]!=-1)\n                return dp[y][x];\n        else{\n                dp[y][x]=0;\n                if(board[y+1][x]==Color && dp[y+1][x]==-1)\n                        res+=recursion(y+1,x);\n                if(board[y-1][x]==Color && dp[y-1][x]==-1)\n                        res+=recursion(y-1,x);\n                if(board[y][x+1]==Color && dp[y][x+1]==-1)\n                        res+=recursion(y,x+1);\n                if(board[y][x-1]==Color && dp[y][x-1]==-1)\n                        res+=recursion(y,x-1);\n        }\n        return dp[y][x]=res;\n}\nint main(){\n        while(true){\n                for(int i=0 ; i<100 ; i++ )\n                        for(int j=0 ; j<100 ; j++ ){\n                                dp[i][j]=-1;\n                                board[i][j]=0;\n                        }\n                cin >> SIZE.x >> SIZE.y;\n                if(SIZE.x+SIZE.y==0)\n                        break;\n                cin >> Start.x >> Start.y;\n                cin >> Goal.x >> Goal.y;\n                cin >> N;\n                for(int i=0 ; i<N ; i++ ){\n                        cin >> block[i].color >> block[i].direction;\n                        cin >> block[i].x >> block[i].y;\n                        if(block[i].direction){\n                                for(int l=block[i].y ; l<block[i].y+4 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+2 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                        else{\n                                for(int l=block[i].y ; l<block[i].y+2 ; l++ ){\n                                        for(int j=block[i].x ; j<block[i].x+4 ; j++ ){\n                                                board[l][j]=block[i].color;\n                                        }\n                                }\n                        }\n                }\n                Color=board[Start.y][Start.x];\n                if(recursion(Start.y,Start.x)>0)\n                        cout <<\"OK\"<<endl;\n                else\n                        cout <<\"NG\"<<endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 110 ] )\n{\n\tcame[ y ][ x ] = false ;\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 110 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h ,w & h )\n\t{\n\t\tbool came[ 110 ][ 110 ] = { false } ;\n\t\tint map[ 110 ][ 110 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nint C[102][102];\nint ans;\nint xg,yg;\n \nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n \n  if(C[W][H]!=c){\n    return;\n  }\n \n  C[W][H] = 0;\n \n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n \nint main(){\n  while(1){\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        C[i][j] = 0;\n      }\n    }\n     \n    int w,h;\n    cin >> w >> h;\n \n    if(w==0 && h==0){\n      break;\n    }\n \n    int xs,ys;\n    cin >> xs >> ys;\n \n    cin >> xg >> yg;\n \n    int n;\n    cin >> n;\n    int c,d,x,y;\n \n    int cbase;\n \n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n \n      if(d==0){\n        for(int j=x;j<x+4;j++){\n          for(int k=y;k<y+2;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n      if(d==1){\n        for(int j=x;j<x+2;j++){\n          for(int k=y;k<y+4;k++){\n            C[j][k]=c;\n          }\n        }\n      }\n    }\n    ans = 0;\n if(C[xs][ys] == 0){\n      cout << \"NG\" << endl;\n      continue;\n    }\n    meiro(xs,ys,C[xs][ys]);\n   \n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//インクルード文\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <stdlib.h>\n#include <cstdio>\n#include <string>\n//#include <assert.h>\n\n//:std省略\nusing namespace std;\n\n//グローバル変数\nint f[1000][1000];\n\n//マクロ指定\n#define fc f[x + j][y + l] = c\n\n//深さ優先探索( dfs = Depth - First Search )\nvoid dfs(int a, int b, int c) {\n\n\tif (f[a][b] == c) {\n\n\n\t\tf[a][b] = 10;\n\t\tdfs(a + 1, b, c);\n\t\tdfs(a - 1, b, c);\n\t\tdfs(a, b + 1, c);\n\t\tdfs(a, b - 1, c);\n\n\n\t}\n\n//\telse return;\n\n}\n\n//メイン文\nint main(){\n\n\tint w, h, n = 0;\n\tint i, j, l;\n\tint xs, ys; \n\tint xg, yg;\n\n\tconst int cnt = w + h;\n\n\twhile(true) {\n\t\tcin >> w >> h;\n\n\t\t\n\t\tif ( cnt == 0) break;\n\t\t\n\t\tfor (i = 1; i <= h; ++i) {\n\t\t\tfor (j = 1; j <= w; ++j) {\n\t\t\t\tf[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\n\t\t\tcin >> c >> d;\n\t\t\tcin >> x >> y;\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l = 0; l < 2; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {//d==1\n\n\t\t\t\t\n\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l= 0; l < 4; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l = 0; l < 4; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l= 0; l < 2; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n*/\n\n\n\t\tdfs(xs, ys, f[xs][ys]);\n\n\n//\t\tchar gg = 'OK';\n//\t\tchar ggwp = 'NG';\n\n\n\t\t\n\n\t\tif (f[xg][yg] == 10) printf(\"OK\\n\");\n\n\t\telse \t\t         printf(\"NG\\n\");\n\n\n\n\t\t\t//\t\t\tassert(i == 10);\n\t\t\t//\t\t\tassert(i = 9);\n\t\t\t//\t\t\tassert(i = 8);\n\t\t\t//\t\t\tassert(i = 7);\n\t\t\t//\t\t\tassert(i = 6);\n\t\t\t//\t\t\tassert(i = 5);\n\t\t\t//\t\t\tassert(i = 4);\n\t\t\t//\t\t\tassert(i = 3);\n\t\t\t//\t\t\tassert(i = 2);\n\t\t\t//\t\t\tassert(i = 1);\n\n\t\t\n\n\n\t}\n\treturn 0;\n}\n\n/*\n\n\n20 20\n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y, color;\n\tvector< vector< int > > field;\n\tqueue< complex< int > > que;\n\tbool exist;\n\t\n\twhile(cin >> w >> h, w){\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\t\n\t\tfield.resize(w);\n\t\tfor(int i = 0; i < w; ++i) field[i].resize(h);\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j = 0; j < 2; ++j){\n\t\t\t\t\tfor(int k = 0; k < 4; ++k){\n\t\t\t\t\t\tfield[x + j - 1][y + k - 1] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tque.push(complex< int >(xs - 1, ys - 1));\n\t\tcolor = field[xs - 1][ys - 1];\n\t\texist = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tcomplex< int > pos = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(pos.real() == xg - 1 && pos.imag() == yg - 1){\n\t\t\t\texist = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(pos.real() > 0 && field[pos.real() - 1][pos.imag()] == color) que.push(pos + complex< int >(-1, 0));\n\t\t\tif(pos.real() < w - 1 && field[pos.real() + 1][pos.imag()] == color) que.push(pos + complex< int >(1, 0));\n\t\t\tif(pos.imag() > 0 && field[pos.real()][pos.imag() - 1] == color) que.push(pos + complex< int >(0, -1));\n\t\t\tif(pos.imag() < h - 1 && field[pos.real()][pos.imag() + 1] == color) que.push(pos + complex< int >(0, 1));\n\t\t\t\n\t\t\tfield[pos.real()][pos.imag()] = 0;\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << (exist ? \"OK\" : \"NG\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint map[101][101];\nstring ans;\nvoid fun(int y,int x){\n    if(map[y][x]==map[ys][xs]){\n        map[y][x]=7;\n    }\n    else\n        return;\n    if(x<1||w<x||y<1||h<y)\n        return;\n    if(map[y+1][x+1]==map[yg][xg]){\n        ans=\"OK\";\n        return;\n    }\n    fun(y,x+2);\n    fun(y,x-2);\n    fun(y+2,x);\n    fun(y-2,x);\n}\nvoid mc(){\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin >> c >> d >> x >> y;\n        if(d==0){\n            for(int j=0;j<2;j++){\n                for(int k=0;k<4;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<4;j++){\n                for(int k=0;k<2;k++){\n                    map[y+j][x+k]=c;\n                }\n            }\n        }\n    }\n}\nint main(){\n    while(cin >> w >> h,w){\n    \tans=\"NG\";\n        cin >> xs >> ys >> xg >> yg >> n;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                map[i][j]=0;\n            }\n        }\n        mc();\n        if(map[ys][xs]==0||map[yg][xg]==0);\n        else\n        \tfun(ys,xs);\n        /*for(int i=1;i<w;i++){\n        \tfor(int j=1;j<h;j++){\n        \t\tcout << map[i][j];\n        \t}\n        \tcout << endl;\n        }*/\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nint W,H,sx,sy,gx,gy,color;\nint dx[8]={0,0,0,0,1,1,1,1},dy[8]={0,1,2,3,0,1,2,3},cx[4]={-1,0,0,1},cy[4]={0,-1,1,0};\nvvi field;\nvvb used;\n\nbool solve(int x,int y,int color,vvb& used){\n\tused[x][y]=1;\n\tif(x==gx&&y==gy) return 1;\n\tfor(int i=0;i<4;i++){\n\t\tint tmpx=x+cx[i],tmpy=y+cy[i];\n\t\tif(tmpx>=0&&tmpx<W&&tmpy>=0&&tmpy<H&&field[tmpx][tmpy]==color&&!used[tmpx][tmpy]){\n\t\t\tif(solve(tmpx,tmpy,color,used)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(!W) break;\n\t\tfield=vvi(W,vi(H,-1));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\t\tint n;\n\t\tcin>>n;\n\t\tint c,d,x,y;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(d){\n\t\t\t\tfor(int i=0;i<8;i++) field[x+dx[i]][y+dy[i]]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<8;i++) field[x+dy[i]][y+dx[i]]=c;\n\t\t\t}\n\t\t}\n\t\tif(field[sx][sy]==-1||field[gx][gy]==-1) cout<<\"NG\"<<endl;\n\t\telse {\n\t\t\tint color=field[sx][sy];\n\t\t\tused=vvb(H,vb(W));\n\t\t\tif(solve(sx,sy,color,used)) cout<<\"OK\"<<endl;\n\t\t\telse cout<<\"NG\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pll> pip;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS  = 1e-9;\n\nint dx[2][8] = {\n\t{ 0,1,2,3,0,1,2,3 },\n\t{ 0,1,0,1,0,1,0,1 }\n};\n\nint dy[2][8] = {\n\t{ 0,0,0,0,1,1,1,1 },\n\t{ 0,0,1,1,2,2,3,3 }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w || h) {\n\t\tint sx, sy, gx, gy;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n\t\tsx--; sy--; gx--; gy--;\n\t\t\n\t\tint maps[100][100];\n\t\tmemset(maps, -1, sizeof(maps));\n\t\t\n\t\tint n; cin >> n;\n\t\t\n\t\tREP(i, n) {\n\t\t\tint c, d, x, y;\n\t\t\tscanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\t\t\tx--; y--;\n\t\t\t\n\t\t\tREP(j, 8) {\n\t\t\t\tint xx = x + dx[d][j], yy = y + dy[d][j];\n\t\t\t\tmaps[yy][xx] = c - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint num = maps[sy][sx];\n\t\tbool done[100][100] = {};\n\t\t\n\t\tqueue<pii> que;\n\t\tif (num != -1) que.push(pii(sy, sx));\n\t\tdone[sy][sx] = true;\n\t\t\n\t\twhile (!que.empty()) {\n\t\t\tpii now = que.front(); que.pop();\n\t\t\tint x = now.se, y = now.fi;\n\t\t\t\n\t\t\tint ddx[4] = {1,0,-1,0}, ddy[4] = {0,1,0,-1};\n\t\t\tREP(i, 4) {\n\t\t\t\tint xx = x + ddx[i], yy = y + ddy[i];\n\t\t\t\tif (!(xx >= 0 && xx < w && yy >= 0 && yy < h)) continue;\n\t\t\t\tif (maps[yy][xx] != num || done[yy][xx]) continue;\n\t\t\t\tdone[yy][xx] = true;\n\t\t\t\tque.push(pii(yy, xx));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (done[gy][gx] && num != -1) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#pragma region defins\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\n#pragma endregion\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid(105, vector<int>(105));\nvector <vector<bool > > grid_visited(105, vector<bool>(105, false));\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\treturn (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\t\tloop(j, w)\n\t\t\t\t{\n\t\t\t\t\tcout << grid[i][j] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101],w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy))r=1;\n\tif(x>1&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>1&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\td?bw=2,bh=4:bh=2,bw=4;\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])dfs(sx,sy,m[sx][sy]),m[sx][sy] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n  \nint F[105][105];\nint xg,yg,w,h;\n  \n  \nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n  \n  \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<105; i++){\n      for(int j=0; j<105; j++){\n        F[i][j] = 10;\n      }\n    }\n      \n    cin >> xs >> ys >> xg >> yg >> n;\n  \n  \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n  \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\nusing namespace std;\n#define MAX 101\n#define Nll -1\nint w,h;\nint xs,ys,xg,yg;\nint blockNm;\nint map[MAX][MAX];\ntypedef queue < pair<int,int> > Queue;\nvoid setBlock(int color,int dir,int x,int y){\n\tint dx[]={2,0};\n\tint dy[]={0,2};\n\tint xb=x,yb=y;//x_base,y_base\n\tfor(int i=0;i<2;i++,xb+=dx[dir],yb+=dy[dir]){\n\t\tmap[yb][xb]\n\t\t        =map[yb][xb+1]\n\t\t        =map[yb+1][xb]\n\t\t        =map[yb+1][xb+1]=color;\n\t}\n}\nvoid init(){\n\tfor(int i=0;i<MAX;i++)for(int j=0;j<MAX;j++)map[i][j]=-1;\n}\nvoid print(){\n\tfor(int i=0;i<h;i++){for(int j=0;j<w;j++)printf(\"%2d\",map[i][j]);cout<<endl;}\n}\nbool isGoal(int xs,int ys,int xg,int yg){\n\tint color=map[xs][ys];\n\tint dx[]={ 0, 1, 0,-1};\n\tint dy[]={-1, 0, 1, 0};\n\tQueue q;\n\tq.push(pair<int,int>(xs,ys));\n\twhile(!q.empty()){\n\t\tpair<int,int> cur=q.front();q.pop();\n\t\tif(cur.first==xg&&cur.second==yg)return true;\n\t\tmap[cur.first][cur.second]=Nll;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(cur.first+dx[i]<1||cur.first+dx[i]>w\n\t\t\t\t\t||cur.second+dy[i]<1||cur.second+dy[i]>h\n\t\t\t\t\t||map[cur.first+dx[i]][cur.second+dy[i]]==Nll\n\t\t\t\t\t||map[cur.first+dx[i]][cur.second+dy[i]]!=color)continue;\n\t\t\tq.push(pair<int,int>(cur.first+dx[i],cur.second+dy[i]));\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin>>w>>h&&(w||h)){\n\t\tinit();\n\t\tcin>>xs>>ys>>xg>>yg>>blockNm;\n\t\tfor(int i=0;i<blockNm;i++){\n\t\t\tint color,dir,x,y;\n\t\t\tcin>>color>>dir>>x>>y;\n\t\t\tsetBlock(color,dir,x,y);\n\t\t}\n\t\t//print();\n\t\tstring ans=isGoal(xs,ys,xg,yg)?\"OK\":\"NO\";\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w,h){\n\t\tchar board[114][514];\n\t\tint pass[114][514];\n\t\t\n\t\tint xs,ys,xg,yg;\n\t\tcin>>xs>>ys>>xg>>yg;\n\t\t\n\t\tfor(int i=0;i<=w;i++){\n\t\tfor(int j=0;j<=h;j++){pass[i][j]=INF;\n\t\t\tboard[i][j]='#';\n\t\t\t}}\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a;\n\t\t\tint b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\t\n\t\t\tif(b==0){\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\tfor(int k=0;k<4;k++)board[d+j][c+k]=a;\n\t\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\tfor(int k=0;k<4;k++)board[d+k][c+j]=a;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\n\t\tqueue<P>Q;\n\t\tQ.push(P(ys,xs));\n\t\tpass[ys][xs]=0;\n\t\t\n\t\twhile(Q.size()){\n\t\t\tP p=Q.front();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif(p.first==yg&&p.second==xg)break;\n\t\t\t\n\t\t\tint dir[2][4]={{1,0,-1,0},{0,1,0,-1}};\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=p.first+dir[0][i];\n\t\t\t\tint nx=p.second+dir[1][i];\n\t\t\t\t\n\t\t\t\tif(0<=ny&&ny<=h&&0<=nx&&nx<=w&&board[ny][nx]==board[ys][xs]){\n\t\t\t\t\tQ.push(P(ny,nx));\n\t\t\t\t\tpass[ny][nx]=pass[p.first][p.second]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif(pass[yg][xg]!=INF)cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t\n\t\t}\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y;\n\tstate(int x, int y) : x(x), y(y) {};\n};\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w) {\n\t\tvvi field(h+1, vi(w+1));\n\t\tvvi visit(h+1, vi(w+1));\n\t\t\n\t\tint xs, ys, xg, yg, n;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tint c, d, x, y;\n\t\tREP(i, n) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tREP(j, 4) {\n\t\t\t\tREP(k, 2) {\n\t\t\t\t\tif(d) {\n\t\t\t\t\t\tfield[y+j][x+k] = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfield[y+k][x+j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> S;\n\t\tS.push(state(xs, ys));\n\t\tint color = field[ys][xs];\n\t\tbool goal = false;\n\t\twhile(!S.empty()) {\n\t\t\tstate st = S.top();\n\t\t\tS.pop();\n\n\t\t\tif(st.x == xg && st.y == yg) {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint nx, ny;\n\t\t\tREP(d, 4) {\n\t\t\t\tnx = st.x + dx[d];\n\t\t\t\tny = st.y + dy[d];\n\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny<h) {\n\t\t\t\t\tif(!visit[ny][nx] && field[ny][nx] == color) {\n\t\t\t\t\t\tvisit[ny][nx] = 1;\n\t\t\t\t\t\tS.push(state(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif(goal) {\n\t\t\tcout << \"OK\" << endl;\n\t\t} else {\n\t\t\tcout << \"NG\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\nint board[128][128];\nbool memo[128][128];\nint w, h;\n\nvoid judge(int x, int y, int c){\n  if(x<0 || y<0 || x>=w || y>=h)return;\n  if(board[y][x]!=c)return;\n  if(memo[y][x])return;\n  memo[y][x] = 1;\n  judge(x-1, y, c);\n  judge(x+1, y, c);\n  judge(x, y-1, c);\n  judge(x, y+1, c);\n  return;\n}\n\nint main(){\n  int xs, ys, xg, yg, n, i, j, k, c, d, x, y;\n  while(cin>> w >> h, w+h){\n    for(i=0; i<128; i++){\n      for(j=0; j<128; j++){\n        board[i][j] = 0;\n        memo[i][j] = 0;\n      }\n    }\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(i=0; i<n; i++){\n      cin >> c >> d >> x >> y;\n      if(d==0){\n        for(j=y-1; j<y+1; j++){\n          for(k=x-1; k<x+3; k++){\n            board[j][k] = c;\n          }\n        }\n      }else{\n        for(j=y-1; j<y+3; j++){\n          for(k=x-1; k<x+1; k++){\n            board[j][k] = c;\n          }\n        }\n      }\n    }\n    judge(xs-1, ys-1, board[ys-1][xs-1]);\n    if(memo[yg-1][xg-1]==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<queue>\nusing namespace std;\nint field[128][128];\nbool memo[128][128];\nint dx[] = {-1,0,0,1},dy[] = {0,-1,1,0};\nint w,h;\nvoid func(int x,int y,int c){\n\tif(memo[y][x])return ;\n\tif(field[y][x] != c)return ;\n\tmemo[y][x] = 1;\n\tfor(int i = 0; i < 4; i++){\n\t\tfunc(x+dx[i],y+dy[i],c);\n\t}\n}\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w,h){\n\t\tint xs,ys,xg,yg,n;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tscanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d == 0){\n\t\t\t\tfor(int j = x; j < x + 4; j++){\n\t\t\t\t\tfield[y][j] = c;\n\t\t\t\t\tfield[y+1][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = y; j < y + 4; j++){\n\t\t\t\t\tfield[j][x] = c;\n\t\t\t\t\tfield[j][x+1] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunc(xs,ys,field[ys][xs]);\n\t\tcout << (memo[yg][xg]==1?\"OK\":\"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint field[100][100],b[100][100],X,Y,n,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},I,sX,sY,gX,gY,ans=999999,sgc;\nint func(int x,int y){\n\tfor(I=0;I<4;I++){\n\t\tint xx=x+dx[I];\n\t\tint yy=y+dy[I];\n\t\tif(xx==gX&&yy==gY){\n\t\t\tans=min(b[x][y]+1,ans);\n\t\t}\n\t\tif(xx>0&&yy>0&&xx<=X&&yy<=Y&&field[xx][yy]==sgc&&b[xx][yy]==0){\n\t\t\tb[xx][yy]=b[x][y]+1;\n\t\t\tfunc(xx,yy);\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,i2,c,d,x,y;\n\tcin>>X>>Y;\n\twhile(X!=0){\n\t\tcin>>sX>>sY>>gX>>gY>>n;\n\t\tans=999999;\n\t\tfor(i=1;i<100;i++){\n\t\t\tc=0;\n\t\t\td=0;\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t\tfor(i2=1;i2<100;i2++){\n\t\t\t\tfield[i][i2]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+2][y]=c;\n\t\t\t\tfield[x+3][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+2][y+1]=c;\n\t\t\t\tfield[x+3][y+1]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfield[x][y]=c;\n\t\t\t\tfield[x][y+1]=c;\n\t\t\t\tfield[x][y+2]=c;\n\t\t\t\tfield[x][y+3]=c;\n\t\t\t\tfield[x+1][y]=c;\n\t\t\t\tfield[x+1][y+1]=c;\n\t\t\t\tfield[x+1][y+2]=c;\n\t\t\t\tfield[x+1][y+3]=c;\n\t\t\t}\n\t\t}\n\t\tsgc=field[sX][sY];\n\t\tfunc(sX,sY);\n\t\tif(ans==999999)cout<<\"NG\"<<endl;\n\t\telse cout<<\"OK\"<<endl;\n\t\tcin>>X>>Y;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std ;\n\nint map[ 100 ][ 100 ] ;\nint w ,h ;\nint gx ,gy ;\nint way ;\n\nstruct ST\n{\n\tint x ;\n\tint y ;\n} ;\n\nST s ,d ;\n\nvoid ans()\n{\n\tqueue< ST > que ;\n\tint mx[ 4 ] = { 1 ,0 ,0 ,-1 } ;\n\tint my[ 4 ] = { 0 ,1 ,-1 ,0 } ;\n\tbool came[ 100 ][ 100 ] = { false } ;\n\tque.push( s ) ;\n\tcame[ s.y ][ s.x ] = true ;\n\twhile( ! que.empty() )\n\t{\n\t\ts = que.front() ;\n\t\tif( s.x == gx && s.y == gy )\n\t\t{\n\t\t\tcout << \"OK\" << endl ;\n\t\t\treturn ;\n\t\t}\n\t\tque.pop() ;\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\ts.x += mx[ i ] ;\n\t\t\ts.y += my[ i ] ;\n\t\t\tif( came[ s.y ][ s.x ] == false && map[ s.y ][ s.x ] == way )\n\t\t\t{\n\t\t\t\tcame[ s.y ][ s.x ] = true ;\n\t\t\t\tque.push( s ) ;\n\t\t\t\ts.x -= mx[ i ] ;\n\t\t\t\ts.y -= my[ i ] ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NG\" << endl ;\n}\n\n\nint main()\n{\n\twhile( cin >> w >> h ,h )\n\t{\n\t\tint n ;\n\t\tint color ,muki ,x ,y ;\n\t\tcin >> s.x >> s.y ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\twhile( n )\n\t\t{\n\t\t\tn-- ;\n\t\t\tcin >> color >> muki >> x >> y ;\n\t\t\tx-- ;\n\t\t\ty-- ;\n\t\t\tif( muki )\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 2 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgx-- ;\n\t\ts.x-- ;\n\t\tgy-- ;\n\t\ts.y-- ;\n\t\tway = map[ s.y ][ s.x ] ;\n\t\tans() ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\t/*for (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}*/\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\t/*for (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 100\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint w, h, xs, ys, xg, yg, G[MAX+2][MAX+2];\n\nbool dfs(int x, int y, int color){\n\tif(color == 0 || G[x][y] != color) return false;\n\tif(x==xg&&y==yg) return true;\n\tG[x][y] = 0;\n\tfor(int r=0; r<4; r++){\n\t\tif(dfs(x+dx[r], y+dy[r], color)) return true;\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\tint n, c, d, bx, by;\n\twhile(cin>>w>>h, w&&h){\n\t\tfor(int x=0; x<w+2; x++){\n\t\t\tfor(int y=0; y<h+2; y++){\n\t\t\t\tG[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> c >> d >> bx >> by;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tif(d==0) G[bx+i][by+j] = c; \n\t\t\t\t\telse G[bx+j][by+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(xs, ys, G[xs][ys])) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint xs,ys,c,a[105][105],memo[105][105],ans,p,w,h;\n\nint solve(int yg,int xg){\n\n  a[yg][xg] = 0;\n\n  if(xs == xg && ys == yg) return ans = 1;\n\n  else if(yg - 1 > 0 && a[yg-1][xg] == p) solve(yg-1,xg);\n  else if(xg - 1 > 0 && a[yg][xg-1] == p) solve(yg,xg-1);\n  else if(yg + 1 <= w && a[yg+1][xg] == p) solve(yg+1,xg);\n  else if(xg + 1 <= h && a[yg][xg+1] == p) solve(yg,xg+1);\n}\n\nint main(){\n  int xg,yg,n,d,x,y;\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    memset(a,0,sizeof(a));\n    memset(memo,0,sizeof(memo));\n    ans = 0;\n\n    cin >> xs >> ys >> xg >> yg >> n;\n\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n\n      if(d == 0){\n\tfor(int i=y;i<y+2;i++){\n\t  for(int j=x;j<x+4;j++) a[i][j] = c;\n\t}\n      }\n\n      else if(d == 1){\n\tfor(int i=y;i<y+4;i++){\n\t  for(int j=x;j<x+2;j++) a[i][j] = c;\n\t}\n      }\n    }\n\n    p = a[yg][xg];\n    solve(yg,xg);\n\n    if(ans == 1)   cout << \"OK\" << endl;\n    else if(ans == 0)cout << \"NG\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint xs, ys;\nint xg, yg;\nint maze[102][102];\n\nusing P = pair<int, int>;\nvoid solve() {\n    int c = maze[ys][xs];\n    queue<P> que;\n    que.push(P(ys, xs));\n    set<P> visited;\n    visited.insert(P(ys, xs));\n    bool ok = false;\n    while (que.size()) {\n        auto p = que.front();\n        que.pop();\n        int y = p.first;\n        int x = p.second;\n        if (yg == y && xg == x) ok = true;\n        rep(k, 4) {\n            int ny = y + dy[k];\n            int nx = x + dx[k];\n            if (ny < 0 || nx < 0) continue;\n            if (h <= ny || w <= nx) continue;\n            if (maze[ny][nx] != c) continue;\n            if (visited.count(P(ny, nx))) continue;\n            visited.insert(P(ny, nx));\n            que.push(P(ny, nx));\n        }\n    }\n    cout << (ok ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        rep(i, 102) rep(j, 102) maze[i][j] = -1;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        int n;\n        cin >> n;\n        rep(_, n) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            if (d == 0) {\n                rep(i, 2) rep(j, 4) maze[y + i][x + j] = c;\n            } else {\n                rep(i, 4) rep(j, 2) maze[y + i][x + j] = c;\n            }\n        }\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <set>\n#include <algorithm>\n#include <array>\n#include <complex>\n#include <utility>\n#include <map>\nint needleX[4] = { -1,0,1,0 };\nint needleY[4] = { 0,1,0,-1 };\nbool dfs(int start,int goal,int x, int y, int goalx, int goaly, std::vector<std::vector<bool>>&canGo) {\n    if (x == goalx && y == goaly) { return true; }\n    if (start == -1 || goal == -1) { return false; }\n    if (start != goal) {\n        return false;\n    }\n    canGo[y][x] = false;\n    for (int i = 0; i < 4; i++) {\n        int next_x = x + needleX[i];\n        int next_y = y + needleY[i];\n\n        if (canGo[next_y][next_x]) {\n            bool flag = dfs(start, goal,next_x, next_y, goalx, goaly, canGo);\n            if (flag)\n                return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    int h, w, n;\n    std::cin >> w >> h;\n    std::vector<std::string> ans;\n    while(h!=0|| w!=0){\n        int color=-1, orient, leftX, leftY;\n        int sx, sy, gx, gy;\n        std::cin >> sx >> sy >> gx >> gy;\n        std::vector<std::vector<int>> board(h + 2, std::vector<int>(w+ 2, 0));\n        std::vector<std::vector<bool>> canGo(h + 2, std::vector<bool>(w + 2, false));\n        std::cin >> n;\n        int start = -1, goal = -1;\n        for (int i = 0; i < n; i++) {\n            std::cin >> color >> orient >> leftX >> leftY;\n\n\n            if (orient == 0) {\n                for (int j = 0; j <= 3; j++) {\n                    for (int k = 0; k <= 1; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (int j = 0; j <= 1; j++) {\n                    for (int k = 0; k <= 3; k++) {\n                        board[leftY + k][leftX + j] = color;\n                        if (leftX + j == sx && leftY + k == sy) {\n                            start = color;\n                        }\n                        else if (leftX + j == gx && leftY + k == gy) {\n                            goal = color;\n                        }\n                    }\n                }\n            }\n        }\n       /* for (int i = 0; i <= w; i++) {\n            for (int j = 0; j <= h; j++) {\n                std::cout << board[i][j] << \" \";\n            }\n            std::cout << std::endl;\n        }*/\n        if (start != -1) {\n            for (int i = 0; i <= h; i++) {\n                for (int j = 0; j <= w; j++) {\n                    if (board[i][j] == start) {\n                        canGo[i][j] = true;\n                    }\n                }\n            }\n        }\n        bool result = dfs(start,goal,sx, sy, gx, gy, canGo);\n        if (result) { ans.push_back(\"OK\"); }\n        else { ans.push_back(\"NG\"); }\n        std::cin >> h >> w;\n    }\n    int anssize = ans.size();\n    for (int i = 0; i < anssize; i++) {\n        std::cout << ans[i] << std::endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 1000000007\n#define MOD 1000000007\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\ntypedef pair<int, string> PSI;\n\nint w, h, sx, sy, gx, gy;\nint n, c, d, x, y;\n\nbool ans;\n\nint table[110][110];\nint dis[110][110];\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\n\nvoid solve(){\n\tREP(i, 110)REP(j, 110)dis[i][j] = INF;\n\tdis[sy][sx] = 0;\n\n\tqueue<P> que;\n\tque.push(P(sy, sx));\n\n\twhile (que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\tif (p.first == gy&&p.second == gx){\n\t\t\tans = 1;\n\t\t\treturn;\n\t\t}\n\t\tREP(i, 4){\n\t\t\tint nx = p.second + dx[i], ny = p.first + dy[i];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h){\n\t\t\t\tif (table[ny][nx] == table[p.first][p.second]\n\t\t\t\t\t&&dis[ny][nx] == INF){\n\t\t\t\t\tdis[ny][nx] = dis[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> w >> h&&w + h){\n\t\tans = 0;\n\t\tREP(i, 110)REP(j, 110){\n\t\t\ttable[i][j] = 0;\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tdis[sy][sx] = 1;\n\n\t\tcin >> n;\n\t\tREP(i, n){\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0){\n\t\t\t\tREP(i, 2){\n\t\t\t\t\tREP(j, 4){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tREP(i, 4){\n\t\t\t\t\tREP(j, 2){\n\t\t\t\t\t\ttable[y + i][x + j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\tif (ans)cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nint main(){\n\twhile (1) {\n\t\tint w,h,xs,ys,xg,yg,n;\n\t\tcin>>w>>h;\n\t\tif(!w) break;\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\tint board[w][h];\n\t\tbool visited[w][h];\n\t\tmemset(board,0,sizeof board);\n\t\tmemset(visited,0,sizeof visited);\n\t\tqueue<pair<int,int>> que;\n\t\tque.emplace(--xs,--ys);\n\t\tvisited[xs][ys] = true;\n\t\txg--;yg--;\n\t\tint area[2][2][8] = {{{-1,0,1,2,-1,0,1,2},{-1,-1,-1,-1,0,0,0,0}},\n\t\t    {{-1,-1,-1,-1,0,0,0,0},{-1,0,1,2,-1,0,1,2}}};\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c,d,x,y;\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\tboard[area[d][0][i]+x][area[d][1][i]+y] = c;\n\t\t}\n\t\tconstexpr int dx[]={0,-1,1,0},dy[]={1,0,0,-1};\n\t\twhile (!que.empty()) {\n\t\t\tauto now = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = now.first+dx[i],ny = now.second+dy[i];\n\t\t\t\tif(nx >= 0 && nx < w && ny >= 0 && ny < h && board[nx][ny] == board[xs][ys] && !visited[nx][ny]){\n\t\t\t\t\tvisited[nx][ny] = true;\n\t\t\t\t\tque.emplace(nx,ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs((visited[xg][yg]) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint data[102][102];\n\nvoid DFS(int x,int y,int gx,int gy,bool &Flag,int color){\n  if((data[y][x]!=color)||(Flag==true))\n    return;\n  if((x==gx)&&(y==gy)){\n    Flag=true;\n    return;\n  }\n  data[y][x]=0;\n  DFS(x,y+1,gx,gy,Flag,color);\n  DFS(x,y-1,gx,gy,Flag,color);\n  DFS(x+1,y,gx,gy,Flag,color);\n  DFS(x-1,y,gx,gy,Flag,color);\n}\n\n\nint main(){\n  int w,h;\n  int sx,sy;\n  int gx,gy;\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)\n      break;\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        data[i][j]=0;\n      }\n    }\n    cin>>sx>>sy;\n    cin>>gx>>gy;\n    int n;\n    cin>>n;\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      if(d){\n        for(int j=0;j<4;j++){\n          for(int z=0;z<2;z++){\n            data[j+y][z+x]=c;\n          }\n        }\n      }else if(!d){\n        for(int j=0;j<2;j++){\n          for(int z=0;z<4;z++){\n            data[j+y][z+x]=c;\n          }\n        }\n      }\n      /*\n      for(int j=0;j<h+1;j++){\n        for(int z=0;z<w+1;z++){\n          cout<<data[j][z];\n        }\n        cout<<endl;\n      }*/\n    }\n    bool Flag=false;\n    int color=data[sy][sx];\n    if(color!=0)\n      DFS(sx,sy,gx,gy,Flag,color);\n    if (Flag){\n      cout<<\"OK\"<<endl;\n    }else if(!Flag){\n      cout<<\"NG\"<<endl;\n    }\n  }\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dy[] = {1, 0, 0, -1};\nint dx[] = {0, 1, -1, 0};\nint b[110][110];\nint w, h;\nint xs, ys, xg, yg;\nint color;\nbool flag = false;\nbool used[110][110];\n\nvoid dfs(int y, int x, int py, int px){\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(used[ny][nx]) continue;//???????????¨???????????????????????????\n\t\tif(!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\tif(b[ny][nx] != color) continue;\n\t\tif(ny == py && nx == px) continue;//??????????????¢\n\t\tif(ny == yg && nx == xg){\n\t\t\tused[ny][nx] = true;\n\t\t\tflag = true; return;//????????????\n\t\t}\n\t\tused[ny][nx] = true;\n\t\tdfs(ny, nx, y, x);\n\t}\n\treturn;//????????¢?????¨???????????????\n}\n\nint main(void){\n\twhile(1){\n\t\trep(i, 110)rep(j, 110){\n\t\t\tb[i][j] = -1; used[i][j] = false;\n\t\t}\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tint n; cin >> n;\n\t\trep(i, n){\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--; y--;\n\t\t\tif(d == 0){//?¨?\n\t\t\t\tb[y][x] = b[y][x + 1] = b[y][x + 2] = b[y][x + 3] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = b[y + 1][x + 2] = b[y + 1][x + 3] = c;\n\t\t\t}else{//???\n\t\t\t\tb[y][x] = b[y][x + 1] = c;\n\t\t\t\tb[y + 1][x] = b[y + 1][x + 1] = c;\n\t\t\t\tb[y + 2][x] = b[y + 2][x + 1] = c;\n\t\t\t\tb[y + 3][x] = b[y + 3][x + 1] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = b[ys][xs];\n\t\tif(color == -1) {//?????????????????????????????????\n\t\t\tprintf(\"NG\\n\"); continue;\n\t\t}\n\t\tused[ys][xs] = true; flag = false;\n\t\tdfs(ys, xs, -1, -1);\n\t\tif(flag) printf(\"OK\\n\");\n\t\telse printf(\"NG\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 100\nusing namespace std;\n\nint map[MAX+2][MAX+2];\nbool check[MAX+2][MAX+2];\nint dx[4] = { -1,1,0,0};\nint dy[4] = { 0,0,-1,1};\n\nint main () {\n\n  while ( true ) {\n\n    queue<int> next;\n\n    while( !next.empty() ) {\n      next.pop();\n    }\n    \n    int w,h;\n    cin >> w >> h ;\n\n    if ( w == 0 )\n      break;\n\n    int xs,ys;\n    cin >> xs >> ys;\n    \n    int xg, yg;\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n\n    int c,d,x,y;\n\n    for ( int i=0; i<MAX+2; i++ ) {\n      for ( int j=0; j<MAX+2; j++ ) {\n\tmap[i][j] = 0;\n\tcheck[i][j] = true;\n      }\n    }\n\n    for ( int i=0; i<n; i++ ) {\n      cin >> c >> d >> x >> y;\n      \n      //int count = 0;\n      for ( int j=0; j<2; j++ ) {\n\tfor ( int k=0; k<4; k++ ) {\n\t  //cout << count;\n\t  if ( d == 0 ) {\n\t    map[y+j][x+k] = c;\n\t  } else {\n\t    map[y+k][x+j] = c;\n\t  }\n\t}\n      }\n      //cout << endl;\n    }\n\n    next.push(y*1000 + x );\n\n    int point;\n    bool goal = false;\n\n    int sc = map[ys][xs];\n\n    /*\n    for ( int i=0; i<=h; i++ ) {\n      for ( int j=0; j<=w; j++ ) {\n\tcout << map[i+1][j+1];\n      }\n      cout << endl;\n    }\n    cout << endl;\n    */\n    int xn,yn;\n    if ( map[yg][xg] == sc ) {\n      if ( sc == 0 || map[yg][xg] ) {\n      while ( !next.empty() ) {\n\tpoint = next.front();\n\tnext.pop();\n\txn = point%1000;\n\tyn = point/1000;\n\n\tif (map[yn][xn] == 0 )\n\t  continue;\n\n\tif (point == yg*1000+xg) {\n\t  goal = true;\n\t  break;\n\t}\n\n\tfor ( int i=0; i<4; i++ ) {\n\t  if ( check[yn+dy[i]][xn+dx[i]] ) {\n\t    check[yn+dy[i]][xn+dx[i]] = false;\n\t    if ( map[yn+dy[i]][xn+dx[i]] == sc ) {\n\t      next.push((yn+dy[i])*1000+ xn +dx[i]);\n\t    }\n\t  }\n\t}\n      }\n      }\n    }\n\n    if ( goal )\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}\n    \n      \n      "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xx[4] = {0, 1, 0, -1};\nint yy[4] = {1, 0, -1, 0};\nint block[101][101];\nint already[101][101];\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\nint dfs(int nowx, int nowy);\n\nint main(){\n  while(1){\n    memset(block, 0, sizeof(block));\n    memset(already, 0, sizeof(already));\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      int high, wide;\n      if(d){\n\thigh = 4; wide = 2;\n      }\n      else{\n\thigh = 2; wide = 4;\n      }\n      for(int j = 0; j < high; j++){\n\tfor(int k = 0; k < wide; k++){\n\t  block[y+j][x+k] = c;\n\t}\n      }\n    }\n    int ans = dfs(xs, ys);\n    if(ans) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n}\n\nint dfs(int nowx, int nowy){\n  int a = 0;\n  already[nowy][nowx] = 1;\n  if(nowx == xg && nowy == yg) return 1;\n  for(int i = 0; i < 4; i++){\n    int nextx = nowx + xx[i];\n    int nexty = nowy + yy[i];\n    if(0 < nextx && 0 < nexty && nextx <= w && nexty <= h && already[nexty][nextx] != 1 && block[nexty][nextx] == block[ys][xs]) a += dfs(nextx, nexty);\n  }\n  return a;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define size_max 100+10\n\n#define Y first\n#define X second\n\nint mx[4] = { 1,-1,0,0 };\nint my[4] = { 0,0,1,-1 };\n\nint map[size_max][size_max];\n\n\nvoid paint(int c, int y, int x, int H, int W)\n{\n\tint i, j;\n\tfor (i = y; i < y + H; i++)\n\t{\n\t\tfor (j = x; j < x + W; j++)\n\t\t{\n\t\t\tmap[i][j] = c;\n\t\t}\n\t}\n}\n\n\nvoid chek(int w, int h)\n{\n\tint i, j;\n\tfor (i = 0; i <= h + 1; i++)\n\t{\n\t\tfor (j = 0; j <= w + 1; j++)\n\t\t{\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\ntypedef pair<int, int> PR;\n\nint main(void)\n{\n\tPR now, tmp;\n\tqueue<PR> QU;\n\n\tint w, h;\n\tint xs, ys, xg, yg, n;\n\tint c, d, set_x, set_y;\n\n\tint i, j;\n\n\twhile ((cin >> w >> h), w != 0 && h != 0)\n\t{\n\t\tmemset(map, 0, sizeof map);\n\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> c >> d >> set_x >> set_y;\n\n\t\t\tif (d == 0)\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 2, 4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpaint(c, set_y, set_x, 4, 2);\n\t\t\t}\n\t\t}\n\n\t\t//chek(w, h);\n\n\t\tif (map[ys][xs] == 0)\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tnow = make_pair(ys, xs);\n\t\tQU.push(now);\n\n\t\tbool goal = false;\n\t\twhile (!QU.empty())\n\t\t{\n\t\t\tnow = QU.front();\n\t\t\tQU.pop();\n\n\t\t\tif (map[now.Y][now.X] != -1)\n\t\t\t{\n\t\t\t\tmap[now.Y][now.X] = -1;\n\n\t\t\t\tif (now.Y == yg && now.X == xg)\n\t\t\t\t{\n\t\t\t\t\tgoal = true;\n\t\t\t\t\twhile (!QU.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tQU.pop();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\t\tif (map[now.Y + my[i]][now.X + mx[i]] == c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = make_pair(now.Y + my[i], now.X + mx[i]);\n\t\t\t\t\t\tQU.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (goal)\n\t\t{\n\t\t\tcout << \"OK\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NG\\n\";\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal;          //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",mass[i][j]);\n      }\n      printf(\"     \");\n      for(j=0;j<w;j++){\n\tprintf(\"%2d\",data[i][j]);\n      }\n      printf(\"\\n\");\n    }\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else {\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sy,sx));     //queにスタート位置の座標を格納\n  data[sy][sx]=0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      break;\n    }\n    for(i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[i][j] = 0;\n      }\n    }\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n\n      if(d[i]==0 && c[i]==cbase){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1 && c[i]==cbase){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,cbase);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int MAX_WH = 100;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint w, h;\nint sx, sy, gx, gy;\nint col;\nint field[MAX_WH + 1][MAX_WH + 1];\n\nbool solve(int x, int y) {\n\tif (x == gx && y == gy) return true;\n\tfield[x][y] = -1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nextX = x + dx[i];\n\t\tint nextY = y + dy[i];\n\t\tif (0 < nextX && nextX <= w && 0 < nextY && nextY <= h && col == field[nextX][nextY]) {\n\t\t\tif (solve(nextX, nextY)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main () {\n\twhile (cin >> w >> h, w || h) {\n\t\tmemset(field, 0, sizeof(field));\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tfield[x + j][y + i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tfield[x + j][y + i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcol = field[sx][sy];\n\t\tcout << (solve(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid\nDFS (int Y, int X, int A)\n{\n  if (F[Y][X] != A)\n    return;\n\n  F[Y][X] = 7;\n\n  DFS (Y - 1, X, A);\n  DFS (Y, X + 1, A);\n  DFS (Y + 1, X, A);\n  DFS (Y, X - 1, A);\n}\n\nint\nmain ()\n{\n  int w, h;\n  int xs, ys;\n  int xg, yg;\n  int n;\n  int c, d, x, y;\n\n  while (true)\n    {\n      cin >> w >> h;\n      if (w == 0 && h == 0)\n\tbreak;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n\n      for (int i = 0; i < n; i++)\n\t{\n\t  cin >> c >> d >> x >> y;\n\t  if (d == 0)\n\t    {\n\t      for (int a = 0; a < 4; a++)\n\t\t{\n\t\t  for (int b = 0; b < 2; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\n\t    }\n\t  else\n\t    {\n\t      for (int a = 0; a < 2; a++)\n\t\t{\n\t\t  for (int b = 0; b < 4; b++)\n\t\t    {\n\t\t      F[y + b][x + a] = c;\n\t\t    }\n\t\t}\n\t    }\n\n\t}\n\n\n      if (F[ys][xs] == 0 || F[ys][xs] == 1 || F[ys][xs] == 2 || F[ys][xs] == 3\n\t  || F[ys][xs] == 4 || F[ys][xs] == 5)\n\t{\n\t  DFS (ys, xs, F[ys][xs]);\n\t}\n\n      if (F[yg][xg] == F[ys][xs])\n\t{\n\t  cout << \"OK\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"NG\" << endl;\n\t}\n   \n    /*for (int y = 0; y < h; y++)\n\t{\n\t  for (int x = 0; x < w; x++)\n\t    {\n\t      cout << F[y][x];\n\t    }\n         cout << endl;\n\t}*/\n   \n    for (int y = 1; y <= h; y++)\n\t{\n\t  for (int x = 1; x <= w; x++)\n\t    {\n\t      F[y][x] = 0;\n\t    }\n\t}\n\n    \n   \n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[101][101];\nlong long ds[101][101];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==1){//???\n\t\t\t\tfor(m=0;m<2;m++){\n\t\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//?¨?\n\t\t\t\tfor(m=0;m<4;m++){\n\t\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(brock[xs][ys]!=brock[xg][yg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[xs][ys];\n\t\t\tds[xs][ys]=1;\n\t\t\tS.push(ma);\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==xg&&ba.b==yg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t}\n\t\t\t\tif(ba.c!=brock[xg][yg]){\n\t\t\t\t\tS.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=w&&ba.b+q[i]>0&&ba.b+q[i]<=h&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=ba.c;\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint F[102][102];\n\nvoid DFS(int Y,int X,int C){\n   if(F[Y][X]!=C)\n      return;\n   F[Y][X]=6;\n   DFS(Y-1,X,C);\n   DFS(Y,X+1,C);\n   DFS(Y+1,X,C);\n   DFS(Y,X-1,C);\n} \n\nint main(){\n   int w,h,xs,ys,xg,yg,n;\n   int c,d,x,y;\n   while(true){\n      cin >> w >> h;\n      if(w==0&&h==0)\n         break;\n      cin >> xs >> ys;\n      cin >> xg >> yg;\n      cin >> n;\n      for(int i=1;i<=n;i++){\n         cin >> c >> d >> x >> y;\n         if(d==0){\n             F[y+1][x+1]=c;\n             F[y+1][x+2]=c;\n             F[y+1][x+3]=c;\n             F[y+1][x+4]=c;  \n             F[y+2][x+1]=c;\n             F[y+2][x+2]=c;\n             F[y+2][x+3]=c;\n             F[y+2][x+4]=c;   \n         }\n         else{\n             F[y+1][x+1]=c;\n             F[y+2][x+1]=c;\n             F[y+3][x+1]=c;\n             F[y+4][x+1]=c;  \n             F[y+1][x+2]=c;\n             F[y+2][x+2]=c;\n             F[y+3][x+2]=c;\n             F[y+4][x+2]=c;   \n         }\n      }\n      if(F[ys+1][xs+1]!=1&&F[ys+1][xs+1]!=2&&F[ys+1][xs+1]!=3&&F[ys+1][xs+1]!=4&&F[ys+1][xs+1]!=5)\n         cout << \"NG\" << endl;\n      else{\n         DFS(ys+1,xs+1,c);\n         if(F[yg+1][xg+1]==F[ys+1][xs+1])\n            cout << \"OK\" << endl;\n         else\n            cout << \"NG\" << endl;\n         for(int i=1;i<=w;i++)\n            for(int j=1;j<=h;j++)\n               F[i][j]=0;\n      }\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint m[101][101],w,h,r,gx,gy;\nvoid dfs(int x,int y,int c){\n\tif(!(x-gx)&&!(y-gy))r=1;\n\tif(x>1&&m[x-1][y]==c)m[x-1][y]=0,dfs(x-1,y,c);\n\tif(x<=w&&m[x+1][y]==c)m[x+1][y]=0,dfs(x+1,y,c);\n\tif(y>1&&m[x][y-1]==c)m[x][y-1]=0,dfs(x,y-1,c);\n\tif(y<=h&&m[x][y+1]==c)m[x][y+1]=0,dfs(x,y+1,c);\n\treturn ;\n}\n\nint main(){\n\t//whÍ{[hÌå«³AnÍubNÌÂ\n\tint n,c,d,sx,sy,bx,by;\n\t\n\twhile(std::cin>>w>>h,w&&h){\n\t\tfor(int y=0;y<101;y++){\n\t\t\tfor(int x=0;x<101;x++){\n\t\t\t\tm[x][y] = 0;\n\t\t\t}\n\t\t}\n\t\tr=0;\n\t\tstd::cin>>sx>>sy;\n\t\tstd::cin>>gx>>gy;\n\t\tstd::cin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstd::cin>>c>>d>>bx>>by;\n\t\t\tint bw,bh;\n\t\t\td?bw=2,bh=4:bh=2,bw=4;\n\t\t\tfor(int y=by;y<=by+bh;y++){\n\t\t\t\tfor(int x=bx;x<=bx+bw;x++){\n\t\t\t\t\tm[x][y] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m[sx][sy])dfs(sx,sy,m[sx][sy]),m[sx][sy] = 0;\n\t\tif(r)std::cout<<\"OK\"<<std::endl;\n\t\telse{std::cout<<\"NG\"<<std::endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mp[101][101];\nint sx, sy, gx, gy;\nint w, h;\n\nint dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\n\nbool dfs(int y, int x, int c)\n{\n\tif (y < 1 || y > h || x < 1 || x > w || mp[y][x] != c) return false;\n\n\tif (y == gy && x == gx) return true;\n\n\tmp[y][x] = 0;\n\n\tbool res = false;\n\n\tfor (int i = 0; i < 4; ++i) res = res || dfs(y + dy[i], x + dx[i], c);\n\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w || h) {\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tint n; cin >> n;\n\t\twhile (n--) {\n\t\t\tint c, d, x, y; cin >> c >> d >> x >> y;\n\n\t\t\tif (d) {\n\t\t\t\tfor (int i = 0; i < 4; ++i) for (int j = 0; j < 2; ++j) mp[y+i][x+j] = c;\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < 2; ++i) for (int j = 0; j < 4; ++j) mp[y+i][x+j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcout << (dfs(sy, sx, mp[sy][sx]) ? \"OK\" : \"NG\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nint Block(int,int);\nint c,d,x,y,xg,yg,w,h,M,Flag;\nint MAP[102][102],MF[102][102];\nint main(void)\n{\n\tint xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(Block(xs,ys))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nint Block(int X,int Y)\n{\n\t\n\t//printf(\"%d\",M);\n\tprintf(\"%d %d\\n\",X,Y);\n\tif(X == xg && Y == yg)\n\t\treturn 1;\n\tif(MAP[Y][X] != M || MF[Y][X] == 1 || X < 1 || Y < 1 || X > w || Y > h) return 0;\n\tMF[Y][X] = 1;\n\treturn Block(X,Y-1) || Block(X,Y+1) || Block(X-1,Y) || Block(X+1,Y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, w, h, xs, ys, xg, yg, f[105][105] = { 0 }, dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 }, used[105][105] = { 0 }, color = 0;\nbool flag;\nvoid dfs(int y, int x) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (xg == nx&&yg == ny) {\n\t\t\tflag = true;\n\t\t\treturn;\n\t\t}\n\t\tif (used[ny][nx]) continue;\n\t\tif (1 <= nx&&nx <= w && 1 <= ny&&ny <= h&&f[ny][nx] == color) {\n\t\t\tused[ny][nx] = 1;\n\t\t\tdfs(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (1) {\n\t\tcolor = -1;\n\t\tflag = false;\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) return 0;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tf[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tused[ys][xs] = 1;\n\t\tcolor = f[ys][xs];\n\t\tdfs(ys, xs);\n\t\tif (color == -1) {//?????????????????????????????????\n\t\t\tcout << \"NG\" << endl; continue;\n\t\t}\n\t\tif (flag) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint xs, ys;\nint xg, yg;\nint maze[102][102];\n\nusing P = pair<int, int>;\nvoid solve() {\n    int c = maze[ys][xs];\n    queue<P> que;\n    que.push(P(ys, xs));\n    set<P> visited;\n    visited.insert(P(ys, xs));\n    bool ok = false;\n    while (que.size()) {\n        auto p = que.front();\n        que.pop();\n        int y = p.first;\n        int x = p.second;\n        if (yg == y && xg == x) ok = true;\n        rep(k, 4) {\n            int ny = y + dy[k];\n            int nx = x + dx[k];\n            if (ny < 0 || nx < 0) continue;\n            if (h <= ny || w <= nx) continue;\n            if (maze[ny][nx] != c) continue;\n            if (visited.count(P(ny, nx))) continue;\n            visited.insert(P(ny, nx));\n            que.push(P(ny, nx));\n        }\n    }\n    cout << (ok ? \"OK\" : \"NG\") << endl;\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        rep(i, 102) rep(j, 102) maze[i][j] = -1;\n        cin >> xs >> ys;\n        cin >> xg >> yg;\n        xs--, ys--;\n        xg--, yg--;\n        int n;\n        cin >> n;\n        rep(_, n) {\n            int c, d, x, y;\n            cin >> c >> d >> x >> y;\n            x--, y--;\n            if (d == 0) {\n                rep(i, 2) rep(j, 4) maze[y + i][x + j] = c;\n            } else {\n                rep(i, 4) rep(j, 2) maze[y + i][x + j] = c;\n            }\n        }\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint F[102][102];\n\nvoid DFScolor(int X,int Y,int color,int Xg,int Yg){\n\n\tif(F[X][Y]!=color)\n\t\treturn;\n\t\n\tF[X][Y]=0;\n\tDFScolor(X-1,Y,color,Xg,Yg);\n\tDFScolor(X,Y+1,color,Xg,Yg);\n\tDFScolor(X+1,Y,color,Xg,Yg);\n\tDFScolor(X,Y-1,color,Xg,Yg);\n\t\n}\n\n\nint main(){\nwhile(1){\n\tint H,W,xg,yg,xs,ys,n;\n\tcin>>H>>W;\n\tif(W==0&&H==0)\n\t\treturn 0;\n\tcin>>xs>>ys;\n\tcin>>xg>>yg;\t\n\tcin>>n;\n\tint c,d,x,y;\n\tint xb[n],yb[n],colo[n];\n\tfor(int i=0;i<n;i++){\n\t\t\n\t\tcin>>c>>d>>x>>y;\n\t\tcolo[i]=c;\n\t\txb[i]=x;\n\t\tyb[i]=y;\n\t\tif(d==0){\n\t\t\tfor(int o=y;o<y+2;o++){\n\t\t\t\tfor(int j=x;j<x+4;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(d==1){\n\t\t\tfor(int o=y;o<y+4;o++){\n\t\t\t\tfor(int j=x;j<x+2;j++){\n\t\t\t\t\tF[j][o]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(xb[i]==xs&&yb[i]==ys){\n\t\t\tDFScolor(xb[i],yb[i],colo[i],xg,yg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(F[xg][yg]==0)\n\t\tcout<<\"OK\"<<endl;\n\tif(F[xg][yg]!=0)\n\t\tcout<<\"NG\"<<endl;\n\t\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//インクルード文\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <stdlib.h>\n#include <cstdio>\n#include <string>\n//#include <assert.h>\n\n//:std省略\nusing namespace std;\n\n//グローバル変数\nint f[1000][1000];\n\n//マクロ指定\n#define fc f[x + j][y + l] = c\n\n//深さ優先探索( dfs = Depth - First Search )\nvoid dfs(int a, int b, int c) {\n\n\tif (f[a][b] == c) {\n\n\n\t\tf[a][b] = 10;\n\t\tdfs(a + 1, b, c);\n\t\tdfs(a - 1, b, c);\n\t\tdfs(a, b + 1, c);\n\t\tdfs(a, b - 1, c);\n\n\n\t}\n\n//\telse return;\n\n}\n\n//メイン文\nint main(){\n\n\tint w, h, n = 0;\n\tint i, j, l;\n\tint xs, ys; \n\tint xg, yg;\n\n\tconst int cnt = w + h;\n\n\tfor(;;) {\n\t\tcin >> w >> h;\n\n\t\t\n\t\tif ( cnt == 0) break;\n\t\t\n\t\tfor (i = 1; i <= h; ++i) {\n\t\t\tfor (j = 1; j <= w; ++j) {\n\t\t\t\tf[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\tcin >> n;\n\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tint c, d, x, y;\n\n\t\t\tcin >> c >> d;\n\t\t\tcin >> x >> y;\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l = 0; l < 2; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {//d==1\n\n\t\t\t\t\n\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l= 0; l < 4; ++l) {\n\t\t\t\t\t\tfc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\n\t\t\tif (d == 0) {\n\t\t\t\tfor (j = 0; j < 2; ++j) {\n\t\t\t\t\tfor (l = 0; l < 4; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (l= 0; l < 2; ++l) {\n\t\t\t\t\t\tf[x + j][y + l] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\n*/\n\n\n\t\tdfs(xs, ys, f[xs][ys]);\n\n\n//\t\tchar gg = 'OK';\n//\t\tchar ggwp = 'NG';\n\n\n\t\t\n\n\t\tif (f[xg][yg] == 10) printf(\"OK\\n\");\n\n\t\telse \t\t         printf(\"NG\\n\");\n\n\n\n\t\t\t//\t\t\tassert(i == 10);\n\t\t\t//\t\t\tassert(i = 9);\n\t\t\t//\t\t\tassert(i = 8);\n\t\t\t//\t\t\tassert(i = 7);\n\t\t\t//\t\t\tassert(i = 6);\n\t\t\t//\t\t\tassert(i = 5);\n\t\t\t//\t\t\tassert(i = 4);\n\t\t\t//\t\t\tassert(i = 3);\n\t\t\t//\t\t\tassert(i = 2);\n\t\t\t//\t\t\tassert(i = 1);\n\n\t\t\n\n\n\t}\n}\n\n/*\n\n\n20 20\n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<25;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nint W,H,sx,sy,gx,gy,color;\nint dx[8]={0,0,0,0,1,1,1,1},dy[8]={0,1,2,3,0,1,2,3},cx[4]={-1,0,0,1},cy[4]={0,-1,1,0};\nvvi field;\nvvb used;\n\nbool solve(int x,int y,int color,vvb& used){\n\tused[x][y]=1;\n\tif(x==gx&&y==gy) return 1;\n\tfor(int i=0;i<4;i++){\n\t\tint tmpx=x+cx[i],tmpy=y+cy[i];\n\t\tif(tmpx>=0&&tmpx<W&&tmpy>=0&&tmpy<H&&field[tmpx][tmpy]==color&&!used[tmpx][tmpy]){\n\t\t\tif(solve(tmpx,tmpy,color,used)) return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(!W) break;\n\t\tfield=vvi(H,vi(W,-1));\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tsx--;\n\t\tsy--;\n\t\tgx--;\n\t\tgy--;\n\t\tint n;\n\t\tcin>>n;\n\t\tint c,d,x,y;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(d){\n\t\t\t\tfor(int i=0;i<8;i++) field[x+dx[i]][y+dy[i]]=c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<8;i++) field[x+dy[i]][y+dx[i]]=c;\n\t\t\t}\n\t\t}\n\t\tif(field[sx][sy]==-1||field[gx][gy]==-1) cout<<\"NG\"<<endl;\n\t\telse {\n\t\t\tint color=field[sx][sy];\n\t\t\tused=vvb(H,vb(W));\n\t\t\tif(solve(sx,sy,color,used)) cout<<\"OK\"<<endl;\n\t\t\telse cout<<\"NG\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 100\n\nint map[MAX][MAX];\nint xs, ys, xg, yg;\nint n;\nint w, h;\nint c, d, x, y;\nint count = 0;\nint color;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid jadge(int x, int y){\n\tif(count == 0){\n\t\tif(0 <= x && x < w && 0 <= y && y < h && map[x][y] == color){\n\t\t\tmap[x][y] = 9;\n\t\t\tif(x == xg && y == yg){\n\t\t\t\tcount = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=0; i < 4; i++){\n\t\t\t\tjadge(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\t\tcount = 0;\n\n\t\tfor(int i=0; i < MAX; i++){\n\t\t\tfor(int j=0; j< MAX; j++){\n\t\t\t\tmap[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\n\t\tcin >> xs >> ys;\n\t\tcin >> xg >> yg;\n\t\txs--; ys--; xg--; yg--;\n\t\tcin >> n;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tcin >> c >> d >> y >> x;\n\n\t\t\tfor(int i=0;  i < 4; i++){\n\t\t\t\tfor(int j=0; j < 2; j++){\n\t\t\t\t\tif(d == 1){\n\t\t\t\t\t\tmap[x-1+i][y-1+j] = c;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[x-1+j][y-1+i] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[xs][ys] != map[xg][yg]){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[xs][ys] == 0 || map[xg][yg] == 0){\n\t\t\tcout << \"NG\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcolor = map[xs][ys];\n\n\t\tjadge(xs, ys);\n\n\t\tif(count == 1) cout << \"OK\" << endl;\n\t\telse cout << \"NG\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<stdlib.h>\n#include<queue>\n#include<map>\n#include<vector>\n#include<list>\n#include<stack>\n#include<functional>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef unsigned long long ull; typedef long long ll;\n\nconst int INF=100000000; int dx[4]={1,0,-1,0}; int dy[4]={0,1,0-1};\n\ntypedef pair<int ,int > P;\n\nchar maze[105][105];\n\nint sx,sy; int gx,gy; int w,h;\n\nchar sc; //スタート地点のカラー\n\n//stdin //stdout\n\nvoid dfs(int x,int y) { maze[x][y]='9';\n\nfor(int i=0;i<4;i++) { int nx=x+dx[i]; int ny=y+dy[i];\n\nif(0<=nx && nx<=w && 0<=ny && ny<=h &&maze[nx][ny] != '0'&&maze[nx][ny] != '9') { dfs(nx,ny); }\n\n} return ; }\n\nvoid solve() {\n\nrep(i,101) rep(j,101) maze[i][j]='0';\n\nint n; char c; int d; int x,y;\n\ncin>>sy>>sx; cin>>gy>>gx;\n\ncin>>n;\n\nrep(i,n) { cin>>c>>d>>y>>x;\n\nif(d==1) { rep(i,4) { rep(j,2) { maze[x+i][y+j]=c;\n\n} } } else if (d==0) { rep(i,2) { rep(j,4) { maze[x+i][y+j]=c;\n\n} } }\n\n} //6 6 //1 1 //3 6 //2 //1 0 1 1 //1 1 3 3 // rep(i,w+1) // { // rep(j,h+1) // { // cout<<maze[i][j]; //// } // cout<<endl; // } //// cout<<maze[gx][gy]<<endl;\n\nif(maze[sx][sy]=='0') { cout<<\"NG\"<<endl; return; } else { sc=maze[sx][sy]; dfs(sx,sy); }\n\n//rep(i,w+1) //{ // rep(j,h+1) // { // cout<<maze[i][j];\n\n// } // cout<<endl; //}\n\nif(maze[gx][gy]=='9') { cout<<\"OK\"<<endl; return; } else { cout<<\"NG\"<<endl; return; }\n\n}\n\nint main() {\n\nwhile(cin>>w>>h) { if(w==0 && h==0) { return 0; } else { solve(); } }\n\nreturn 0; }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std ;\n\nint map[ 100 ][ 100 ] ;\nint w ,h ;\nint gx ,gy ;\nint way ;\n\nstruct ST\n{\n\tint x ;\n\tint y ;\n} ;\n\nST s ,d ;\n\nvoid ans()\n{\n\tqueue< ST > que ;\n\tint mx[ 4 ] = { 1 ,0 ,0 ,-1 } ;\n\tint my[ 4 ] = { 0 ,1 ,-1 ,0 } ;\n\tbool came[ 100 ][ 100 ] = { false } ;\n\tque.push( s ) ;\n\tcame[ s.y ][ s.x ] = true ;\n\twhile( ! que.empty() )\n\t{\n\t\ts = que.front() ;\n\t\tif( s.x == gx && s.y == gy )\n\t\t{\n\t\t\tcout << \"OK\" << endl ;\n\t\t\treturn ;\n\t\t}\n\t\tque.pop() ;\n\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t{\n\t\t\ts.x += mx[ i ] ;\n\t\t\ts.y += my[ i ] ;\n\t\t\tif( came[ s.y ][ s.x ] == false && map[ s.y ][ s.x ] == way )\n\t\t\t{\n\t\t\t\tcame[ s.y ][ s.x ] = true ;\n\t\t\t\tque.push( s ) ;\n\t\t\t\ts.x -= mx[ i ] ;\n\t\t\t\ts.y -= my[ i ] ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NG\" << endl ;\n}\n\n\nint main()\n{\n\twhile( cin >> w >> h ,h )\n\t{\n\t\tint n ;\n\t\tint color ,muki ,x ,y ;\n\t\tcin >> s.x >> s.y ;\n\t\tcin >> gx >> gy ;\n\t\tcin >> n ;\n\t\twhile( n )\n\t\t{\n\t\t\tn-- ;\n\t\t\tcin >> color >> muki >> x >> y ;\n\t\t\tx-- ;\n\t\t\ty-- ;\n\t\t\tif( muki )\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 4 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor( int i = 0 ; i < 2 ; i++ )\n\t\t\t\t{\n\t\t\t\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tmap[ y + i ][ x + j ] = color ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgx-- ;\n\t\ts.x-- ;\n\t\tgy-- ;\n\t\ts.y-- ;\n\t\tway = map[ s.y ][ s.x ] ;\n\t\tif( map[ s.y ][ s.x ] == way )\n\t\t{\n\t\t\tans() ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NA\" << endl ;\n\t\t}\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint field[102][102];//y,x\nbool flag;\nint sx,sy,gx,gy,col;\n\nvoid erase(){\n\tfor(int i=0; i<102; i++)\n\t\tfor(int j=0; j<102; j++)\n\t\t\tfield[i][j] = 0;\n}\n\nvoid DFS(int x, int y){\n\tif(field[y][x] != col)\n\t\treturn;\n\tif(x == gx && y == gy){\n\t\tflag = true;\n\t\treturn;\n\t}\n\tif(sx < gx)\n\tDFS(x+1, y);\n\tif(flag)\n\t\treturn;\n\tif(sy < gy)\n\tDFS(x, y+1);\n\tif(flag)\n\t\treturn;\n\tif(sx > gx)\n\tDFS(x-1, y);\n\tif(flag)\n\t\treturn;\n\tif(sy > gy)\n\tDFS(x, y-1);\n}\n\nint main(){\n\tint n,c,d,bx,by;\n\twhile(true){\n\t\tflag = false;\n\t\terase();\n\n\t\tstd::cin >> c >> d;\n\t\tif(!c && !d)\n\t\t\treturn 0;\n\n\t\tstd::cin >> sx >> sy;\n\t\tstd::cin >> gx >> gy;\n\n\t\tstd::cin >> n;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tstd::cin >> c >> d >> bx >> by;\n\t\t\tif(d==0)\n\t\t\t\tfor(int h=by; h<by+2; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+4; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t\telse\n\t\t\t\tfor(int h=by; h<by+4; h++)\n\t\t\t\t\tfor(int w=bx; w<bx+2; w++)\n\t\t\t\t\t\tfield[h][w] = c;\n\t\t}\n\n\t\tcol = field[gy][gx];\n\t\tDFS(sx, sy);\n\t\tif(flag)\n\t\t\tstd::cout << \"OK\\n\";\n\t\telse\n\t\t\tstd::cout << \"NG\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\n\nint DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='w'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_Y(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='y'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg&&X==Yg){\n    c++;\n  }\n}\nint DFS_G(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='g'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\nint DFS_B(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='b'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n  int DFS_R(int Y,int X,int Xg,int Yg,int c){\n  if(F[Y][X]!='r'){\n    return c;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n  if(Y==Xg,X==Yg){\n    c++;\n  }\n}\n\nint main(){\n  int c[5];\n  int d[1];\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  int x[n];\n  int y[n];\n  cin>>w>>h;\n  while(w!=0){\n    int a=0;\n    int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n        int a=0;\n        int b=0;\n      if(d[i]==0){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      cnt=DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      cnt=DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      cnt=DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      cnt=DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      cnt=DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint board[100][100];\nbool vst[100][100];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,xs,ys,xg,yg,n;\nbool dfs(int x,int y) {\n\tif(x==xg && y==yg)\n\t\treturn true;\n\tvst[x][y]=true;\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0>nx||nx>=w||0>ny||ny>=h)\n\t\t\tcontinue;\n\t\tif(board[nx][ny]!=board[xs][ys])\n\t\t\tcontinue;\n\t\tif(vst[nx][ny])\n\t\t\tcontinue;\n\t\tif(dfs(nx,ny)) return true;\n\t}\n\treturn false;\n}\nint main() {\n\twhile(scanf(\"%d %d\",&w,&h),w|h) {\n\t\tscanf(\"%d %d\",&xs,&ys); xs--;ys--;\n\t\tscanf(\"%d %d\",&xg,&yg); xg--;yg--;\n\t\tscanf(\"%d\",&n);\n\t\tmemset(board,0,sizeof(board));\n\t\tmemset(board,0,sizeof(vst));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint c,d,x,y;\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y); x--;y--;\n\t\t\tif(d==0) {\n\t\t\t\tfor(int i=0;i<4;i++) for(int j=0;j<2;j++)\n\t\t\t\t\tboard[x+i][y+j]=c;\n\t\t\t}else {\n\t\t\t\tfor(int i=0;i<2;i++) for(int j=0;j<4;j++)\n\t\t\t\t\tboard[x+i][y+j]=c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",dfs(xs,ys)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX = 101;\n\nint maze[MAX][MAX];\nbool come[MAX][MAX];\nP s,g;\nint W,H,c;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  memset(maze,0,sizeof(maze));\n}\n\n\nvoid input_B(){\n  int n;\n  cin >> n;\n  while(n--){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d){\n      for(int i = y; i < y+4; i++)\n\tfor(int j = x; j < x+2; j++)\n\t  maze[i][j] = c;\n    }else{\n      for(int i = y; i < y+2; i++)\n\tfor(int j = x; j < x+4; j++)\n\t  maze[i][j] = c;\n    }\n  }\n}\n\n\nvoid solve(P p){\n  \n  if(come[p.second][p.first] == false){\n    come[p.second][p.first] = true;\n    for(int i = 0; i < 4; i++)\n      if(0 < p.first+dx[i] && p.first+dx[i] <= W &&\n\t 0 < p.second+dy[i] && p.second+dy[i] <= H &&\n\t maze[p.second][p.first] == c) solve(P(p.first+dx[i],p.second+dy[i]));\n  }\n}\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    cin >> s.first >> s.second;\n    cin >> g.first >> g.second;\n    input_B();\n    c = maze[s.second][s.first];\n    solve(s);\n    if(come[g.second][g.first]) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n#define repeat(n, i) for(int i=0; i<(n); i++)\nint w, h;\nint xs, ys;\nint xg, yg;\nint n;\n\nint st_color;\n\nint board[300][300];\n\n#define VISITED 6\n\nbool get_input() {\n    memset(board, 0, sizeof(board));\n    cin >> w >> h;\n    if (w == 0 && h == 0) return false;\n//    board.resize(h);\n//    repeat(h, i) board[i].resize(w);\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    repeat(n, i) {\n        int c, d, x, y;\n        cin >> c >> d >> x >> y;\n        if (d == 1) {\n            for (int j = y-1; j < y-1+4; j++) {\n                for (int k = x-1; k < x-1+2; k++) {\n                    board[j][k] = c;\n                }\n            }\n        } else {\n            for (int j = y-1; j < y-1+2; j++) {\n                for (int k = x-1; k < x-1+4; k++) {\n                    board[j][k] = c;\n                }\n            }\n        }\n    }\n    st_color = board[ys-1][xs-1];\n    return true;\n}\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool possible;\nvoid dfs(int x, int y) {\n    board[y-1][x-1] = VISITED;\n    if (x == xg && y == yg) {\n        possible = true;\n        return;\n    }\n    repeat(4, i) {\n        int nx = x+dx[i], ny = y+dy[i];\n        if (1 <= nx && nx <= w && 1 <= ny && ny <= h) {\n            if (board[ny-1][nx-1] == st_color) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\n// debug \n//void solve() {\n//    repeat(h, i) {\n//        repeat(w, j) {\n//            cout << board[i][j] << ' ';\n//        }\n//        cout << endl;\n//    }\n//}\n\nvoid solve() {\n    possible = false; dfs(xs, ys);\n    if (possible) cout << \"OK\" << endl;\n    else cout << \"NG\" << endl;\n}\n\nint main() {\n    while (get_input()) {\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint weight, hight;\nint g[110][110];\nint sc;\nint sx, sy, gx, gy;\nbool flag = false;\nconst int vx[4] = {0, 0, -1, 1};\nconst int vy[4] = {1, -1, 0, 0};\n\nvoid dfs(int x, int y){\n    if(x == gx && y == gy){\n        flag = true;\n        return;\n    }\n    \n    for(int vh = 0;vh < 4;vh++){\n        for(int vw = 0;vw < 4;vw++){\n            int nx = x + vx[vw];\n            int ny = y + vy[vh];\n            if(nx >= 0 && nx < weight && ny >= 0 && ny < hight){\n                if(g[ny][nx] == sc){\n                    g[y][x] = 8;\n                    dfs(nx, ny);\n                }\n            }\n        }\n    }\n    \n    return ;\n}\n\nvoid disp(){\n    for(int i = 0;i < hight;i++){\n        for(int j = 0;j < weight;j++){\n            cout << g[i][j];\n        }cout << endl;\n    }\n}\n\nint main(){\n    int dn, c, d, x, y;\n    \n    while(cin >> weight >> hight){\n        if(weight == 0 && hight == 0){\n            break;\n        }\n        \n        cin >> sx >> sy >> gx >> gy >> dn;\n        \n        for(int i = 0;i < dn;i++){\n            cin >> c >> d >> x >> y;\n            \n            if(sx == x && sy == y){\n                sc = c;\n            }\n            \n            if(d == 0){\n                for(int h = 0;h < 2;h++){\n                    for(int w = 0;w < 4;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }else{\n                for(int h = 0;h < 4;h++){\n                    for(int w = 0;w < 2;w++){\n                        g[y+h][x+w] = c;\n                    }\n                }\n            }\n        }\n\n        flag = false;\n        dfs(sx, sy);\n        \n        if(flag){\n            cout << \"OK\\n\";\n        }else{\n            cout << \"NG\\n\";\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[105][105];\nint xg,yg;\n\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n\n  F[Y][X] = -1;\n  DFS(Y-1,X  ,c);\n  DFS(Y  ,X+1,c);\n  DFS(Y+1,X  ,c);\n  DFS(Y  ,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<20; i++){\n      for(int j=0; j<20; j++){\n        F[i][j]=0;\n      }\n    }\n    \n    cin >> xs >> ys >> xg >> yg >> n;\n\n\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n\n  DFS(xs,ys,F[xs][ys]);\n\n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<list>\n\ntypedef struct block\n{\n\tint x;\n\tint y;\n\tint h;\n\tint w;\n\tint color;\n}block;\n\nblock blocks[1280];\n\nstd::queue<int> que;\nstd::list<int> adjacive[1280];\n\nvoid makelist(int n);\nbool BFS(int start,int goal);\n\nint main()\n{\n\tint n,w,h,xs,ys,xg,yg,start,goal;\n\twhile(1)\n\t{\n\t\twhile(!que.empty()){que.pop();}\n\t\tstart=-1;\n\t\tgoal=-1;\n\t\tstd::cin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tstd::cin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint c,d,x,y;\n\t\t\tstd::cin>>c>>d>>x>>y;\n\t\t\tblocks[i].color=c;\n\t\t\tblocks[i].x=x;\n\t\t\tblocks[i].y=y;\n\t\t\tif(d==0)\n\t\t\t{\n\t\t\t\tblocks[i].h=2;\n\t\t\t\tblocks[i].w=4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblocks[i].h=4;\n\t\t\t\tblocks[i].w=2;\n\t\t\t}\n\t\t\tif(blocks[i].x<=xs&&blocks[i].x+blocks[i].w-1>=xs&&blocks[i].y<=ys&&blocks[i].y+blocks[i].h-1>=ys)\n\t\t\t{\n\t\t\t\tstart=i;\n\t\t\t}\n\t\t\telse if(blocks[i].x<=xg&&blocks[i].x+blocks[i].w-1>=xg&&blocks[i].y<=yg&&blocks[i].y+blocks[i].h-1>=yg)\n\t\t\t{\n\t\t\t\tgoal=i;\n\t\t\t}\n\t\t}\n\t\tmakelist(n);\n\t\tif(BFS(start,goal))\n\t\t{\n\t\t\tstd::cout<<\"OK\"<<std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cout<<\"NG\"<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid makelist(int n)\n{\n#define x1 blocks[i].x\n#define y1 blocks[i].y\n#define h1 blocks[i].h\n#define w1 blocks[i].w\n#define x2 blocks[j].x\n#define y2 blocks[j].y\n#define h2 blocks[j].h\n#define w2 blocks[j].w\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadjacive[i].clear();\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(blocks[i].color==blocks[j].color)\n\t\t\t{\n\t\t\t\tif((x1==x2+w2&&y1<=y2+h2-1&&y1+h1-1>=y2)||(x2==x1+w1&&y1<=y2+h2-1&&y1+h1-1>=y2)||(y1==y2+h2&&x1<=x2+w2-1&&x1+w1-1>=x2)||(y2==y1+h1&&x1<=x2+w2-1&&x1+w1-1>=x2))\n\t\t\t\t{\n\t\t\t\t\tadjacive[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool BFS(int start,int goal)\n{\n\tint survey;\n\tque.push(start);\n\t\n\twhile(!que.empty())\n\t{\n\t\tsurvey=que.front();\n\t\tque.pop();\n\t\tfor(std::list<int>::iterator it=adjacive[survey].begin();it!=adjacive[survey].end();it++)\n\t\t{\n\t\t\t\tque.push(*it);\n\t\t}\n\t\tadjacive[survey].clear();\n\t\tif(survey==goal)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string.h>\nusing namespace std;\nstruct ST {\n\tint a;\n\tint b;\n\tint c;\n};\nlong long brock[1000][1000];\nlong long ds[1000][1000];\nint q[4]={0,-1,0,1};\nint p[4]={1,0,-1,0};\nint main(){\n\tstack <ST> S;\n\tST ma;\n\tST ba;\n\tint w,h;//???????????§??????\n\tint xs,ys;//??????????????§?¨?\n\tint xg,yg;//??´????????§?¨?\n\tint n;//????????????????????°\n\tint c,d,x,y;//????????????????????±\n\tint i,j,m,check=0;\n\twhile(1){\n\t\tmemset(ds,0,sizeof(ds));\n\t\tmemset(brock,0,sizeof(brock));\n\t\tcin>>w>>h;//???????????§????????\\???\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tcin>>xs>>ys>>xg>>yg;//??????????????¨??´???????????§?¨???\\???\n\t\tcin>>n;//????????????????????°\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==1){//???\n\t\t\t\tfor(m=0;m<2;m++){\n\t\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{//?¨?\n\t\t\t\tfor(m=0;m<4;m++){\n\t\t\t\t\tfor(j=0;j<2;j++){\n\t\t\t\t\t\tbrock[x+m][y+j]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(brock[xs][ys]!=brock[xg][yg]){\n\t\t\tcout<<\"NG\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tma.a=xs;\n\t\t\tma.b=ys;\n\t\t\tma.c=brock[xs][ys];\n\t\t\tds[xs][ys]=1;\n\t\t\tS.push(ma);\n\t\t\tcheck=0;\n\t\t\twhile(!S.empty()){\n\t\t\t\tba=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tds[ba.a][ba.b]=1;\n\t\t\t\tif(ba.a==xg&&ba.b==yg){\n\t\t\t\t\tcheck=1;\n\t\t\t\t}\n\t\t\t\tif(ba.c!=brock[xg][yg]){\n\t\t\t\t\tS.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(i=0;i<4;i++){\n\t\t\t\t\t\tif(ba.a+p[i]>0&&ba.a+p[i]<=w&&ba.b+q[i]>0&&ba.b+q[i]<=h&&ds[ba.a+p[i]][ba.b+q[i]]==0){\n\t\t\t\t\t\t\tma.a=ba.a+p[i];\n\t\t\t\t\t\t\tma.b=ba.b+q[i];\n\t\t\t\t\t\t\tma.c=ba.c;\n\t\t\t\t\t\t\tS.push(ma);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==1){\n\t\t\t\tcout<<\"OK\"<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<\"NG\"<<endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nvoid Block(int,int);\nint c,d,x,y,xg,yg,M,Flag=0;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint w,h,xs,ys,n;\n\twhile(1){\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(MAP[ys][xs] == MAP[yg][xg])\n\t\t\tBlock(xs,ys);\n\t\tif(Flag==1)\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nvoid Block(int X,int Y)\n{\n\tMF[Y][X] = 1;\n\t//printf(\"%d\",M);\n\tif(X == xg && Y == yg)\n\t\tFlag = 1;\n\tif(MAP[Y-1][X] == M && MF[Y-1][X] == 0) Block(X,Y-1); //???\n\tif(MAP[Y+1][X] == M && MF[Y+1][X] == 0) Block(X,Y+1); //???\n\tif(MAP[Y][X-1] == M && MF[Y][X-1] == 0) Block(X-1,Y); //???\n\tif(MAP[Y][X+1] == M && MF[Y][X+1] == 0) Block(X+1,Y); //???\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\t\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][y]){\n\t\t\tif(dfs(x-1,y))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][y]){\n\t\t\tif(dfs(x,y-1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\nvector < vector <int> > block_map;\nvector < vector <bool> > visited;\n\nint xs, ys;\nint xg, yg;\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, -1, 0, 1 };\n\nbool dfs( int x, int y )\n{\n\tif ( block_map[y][x] != block_map[yg][xg] )\n\t\treturn false;\n\tif ( x == xg && y == yg )\n\t\treturn true;\n\n\tfor ( int i = 0; i < 4; i++ )\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif ( nx < 0 || nx >= w || ny < 0 || ny >= h )\n\t\t\tcontinue;\n\n\t\tif ( visited[ny][nx] == false && block_map[ny][nx] == block_map[ys][xs] )\n\t\t{\n\t\t\tvisited[ny][nx] = true;\n\t\t\tif ( dfs( nx, ny ) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvisited[ny][nx] = false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main( void )\n{\n\twhile ( 1 )\n\t{\n\t\tcin >> w >> h;\n\t\tif ( w == 0 && h == 0 )\n\t\t\tbreak;\n\n\t\tblock_map = vector < vector <int> >( h, vector <int>(w,0) );\n\t\tvisited = vector < vector <bool> >( h, vector <bool>(w,false) );\n\n\t\tcin >> xs >> ys >> xg >> yg;\n\n\t\txs--;\n\t\tys--;\n\t\txg--;\n\t\tyg--;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor ( int i = 0; i < n; i++ )\n\t\t{\n\t\t\tint c, d, x, y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tx--;\n\t\t\ty--;\n\n\t\t\tif ( d == 0 )\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 2; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 4; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor ( int by = 0; by < 4; by++ )\n\t\t\t\t{\n\t\t\t\t\tfor ( int bx = 0; bx < 2; bx++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tblock_map[y+by][x+bx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvisited[ys][xs] = true;\n\t\tif ( dfs( xs, ys ) )\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint w,h,sx,sy,gx,gy,d[100][100],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<=y+2+di*2;j++)for(int k=x;k<=x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tbfs();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef pair<int,int> PII;\ntypedef long long ll;\n\nint xs,ys,xg,yg;\nint board[102][102];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool dfs(int x,int y,int c){\n\tif(board[y][x] != c) return false;\n\tif(x == xg && y == yg) return true;\n\tboard[y][x] = 0;\n\tbool flag = false;\n\tfor(int dir = 0;dir<4;dir++){\n\t\tif(dfs(x+dx[dir],y+dy[dir],c)){\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(){\n\tint w,h;\n\tint n,col;\n\tint c,d,x,y;\n\tint pos0_x[8] = {0,0,1,1,2,2,3,3};\n\tint pos0_y[8] = {0,1,0,1,0,1,0,1};\n\tint pos1_x[8] = {0,0,0,0,1,1,1,1};\n\tint pos1_y[8] = {0,1,2,3,0,1,2,3};\n\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(!w&&!h)break;\n\t\tcin>>xs>>ys>>xg>>yg>>n;\n\t\tfor(y = 0;y<102;y++)\n\t\t\tfor(x = 0;x<102;x++)\n\t\t\t\tboard[y][x] = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin>>c>>d>>x>>y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int j = 0;j<8;j++)\n\t\t\t\t\tboard[y+pos0_y[j]][x+pos0_x[j]] = c;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0;j<8;j++)\n\t\t\t\t\tboard[y+pos1_y[j]][x+pos1_x[j]] = c;\n\t\t\t}\n\t\t}\n\t\tcol = board[ys][xs];\n\t\tif(col==0)col=6;\n\t\tif(dfs(xs,ys,col))\n\t\t\tcout<<\"OK\"<<endl;\n\t\telse\n\t\t\tcout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#define ll long long\n#define loop(i,n) for (int i = 0; i < n; i++)\n#define loops(i,f,n) for (int i = (f); i < n; i++)\n#define INF 100000000000000\n#define sort(a) sort(a.begin(),a.end())\n#define rsort(a) sort(a.rbegin(),a.rend())\nusing namespace std;\nint w, h, sx, sy, gx, gy, n;\nvector <vector<int > > grid;\nvector <vector<bool > > grid_visited;\nvoid input(int c, int d, int x, int y)\n{\n\tif (d == 0)//yokonaga\n\t{\n\t\tloop(i, 2)\n\t\t{\n\t\t\tloop(j, 4)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n\telse//tatenaga\n\t{\n\t\tloop(i, 4)\n\t\t{\n\t\t\tloop(j, 2)\n\t\t\t{\n\t\t\t\tgrid[y + i][x + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}\nbool a = false;\nbool dfs(int nx, int ny)\n{\n\tif (nx == gx&&ny == gy)return true;\n\tif (nx < 0 || ny < 0 || nx >= h || ny >= w || grid[nx][ny] == 0 || grid_visited[nx][ny])return false;\n\tgrid_visited[nx][ny] = true;\n\tif ((nx + 1) >= 0 && ny >= 0 && (nx + 1) < h && ny < w)if (grid[nx + 1][ny] == grid[nx][ny])a |= dfs(nx + 1, ny);\n\tif (nx >= 0 && (ny + 1) >= 0 && nx < h && (ny + 1) < w)if (grid[nx][ny + 1] == grid[nx][ny])a |= dfs(nx, ny + 1);\n\tif ((nx - 1) >= 0 && ny >= 0 && (nx - 1) < h && ny < w)if (grid[nx - 1][ny] == grid[nx][ny])a |= dfs(nx - 1, ny);\n\tif (nx >= 0 && (ny - 1) >= 0 && nx < h && (ny - 1) < w)if (grid[nx][ny - 1] == grid[nx][ny])a |= dfs(nx, ny - 1);\n\t//return (dfs(nx + 1, ny) || dfs(nx, ny + 1) || dfs(nx - 1, ny) || dfs(nx, ny - 1));\n\treturn a;\n\treturn false;\n}\nint main()\n{\n\twhile (1)\n\t{\n\t\tcin >> w >> h;\n\t\tif (!w && !h) break;\n\t\telse\n\t\t{\n\t\t\tgrid = vector<vector<int> >(105, vector<int>(105, 0));\n\t\t\tgrid_visited = vector <vector<bool > > (105, vector<bool>(105, false));\n\t\t\tcin >> sx >> sy >> gx >> gy >> n;\n\t\t\tsx--; sy--; gx--; gy--;\n\t\t\tloop(i, n)\n\t\t\t{\n\t\t\t\tint c, d, x, y;\n\t\t\t\tcin >> c >> d >> x >> y;\n\t\t\t\tx--; y--;\n\t\t\t\tinput(c, d, x, y);\n\t\t\t}\n\t\t\t/*loop(i, h)\n\t\t\t{\n\t\t\tloop(j, w)\n\t\t\t{\n\t\t\tcout << grid[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\ta = false;\n\n\t\t\tcout << (dfs(sx, sy) ? \"OK\" : \"NG\") << endl;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<stack>\nstruct p{\n\tint x;\n\tint y;\n};\nusing namespace std;\nint main(){\n\tint w,h,sx,sy,gx,gy,n,c,d,x,y,i,j,k,o;\n\tint map[100][100];\n\tint used[100][100];\n\tint mx[4]={-1,0,1,0};\n\tint my[4]={0,-1,0,1};\n\tp v,u;\n\tstack<p> s;\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0&&h==0){\n\t\t\tbreak;\n\t\t}\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(used,0,sizeof(used));\n\t\tscanf(\"%d %d\",&sx,&sy);\n\t\tsx--;\n\t\tsy--;\n\t\tscanf(\"%d %d\",&gx,&gy);\n\t\tgx--;\n\t\tgy--;\n\t\tscanf(\"%d\",&n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(!d){\n\t\t\t\tfor(j=y;j<y+2;j++){\n\t\t\t\t\tfor(k=x;k<x+4;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=y;j<y+4;j++){\n\t\t\t\t\tfor(k=x;k<x+2;k++){\n\t\t\t\t\t\tmap[j][k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(map[sy][sx]!=map[gy][gx]){\n\t\t\tprintf(\"NG\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tv.x=sx;\n\t\tv.y=sy;\n\t\ts.push(v);\n\t\to=0;\n\t\twhile(!s.empty()){\n\t\t\tv=s.top();\n\t\t\ts.pop();\n\t\t\tif(used[v.y][v.x]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tused[v.y][v.x]=1;\n\t\t\t}\n\t\t\tif(v.x==gx&&v.y==gy){\n\t\t\t\to=1;\n\t\t\t\twhile(!s.empty){\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<4;i++){\n\t\t\t\tu=v;\n\t\t\t\tu.x+=mx[i];\n\t\t\t\tu.y+=my[i];\n\t\t\t\tif(u.x>=0&&u.x<w&&u.y>=0&&u.y<h&&map[u.y][u.x]==map[sy][sx]){\n\t\t\t\t\ts.push(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(o){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int H, W;\n    while (cin >> W >> H, H || W) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        int M;\n        cin >> M;\n        vector<vector<int> > d(W+1, vector<int>(H+1));\n        vector<vector<int> > used(W+1, vector<int>(H+1));\n\n        for (int i = 0; i < M; i++) {\n            int c, dir, x, y;\n            cin >> c >> dir >> x >> y;\n            if (!dir) {\n                for (int j = 0; j < 4; j++) {\n                    for (int k = 0; k < 2; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            } else {\n                for (int j = 0; j < 2; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        d[x + j][y + k] = c;\n                    }\n                }\n            }\n        }\n\n        for (auto i : d) {\n            for (auto j : i) cout << j;\n            cout << endl;\n        }\n\n        int dx[] = {0, 1, 0, -1};\n        int dy[] = {1, 0, -1, 0};\n\n        queue<int> qx, qy;\n        qx.push(sx);\n        qy.push(sy);\n\n        while (qx.size()) {\n            int x = qx.front(); qx.pop();\n            int y = qy.front(); qy.pop();\n\n            if (used[x][y]) continue;\n            used[x][y] = 1;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (0 <= nx && nx <= H && 0 <= ny && ny <= W && !used[nx][ny] && d[x][y] == d[nx][ny]) {\n                    qx.push(nx);\n                    qy.push(ny);\n                }\n            }\n        }\n\n        if (d[gx][gy] > 0 && used[gx][gy]) cout << \"OK\" << endl;\n        else cout << \"NG\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint w,h;\nint map[101][101];\nint xg,yg;\n\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid mapout()\n{\n  for(int xx=0;xx<h;xx++,cout<<endl)\n    for(int yy=0;yy<w;yy++)\n      if(map[xx][yy]!=-1)\n      cout<<map[xx][yy];\n      else\n\tcout<<\"X\";\n}\n\nbool check(int x,int y)\n{\n  //  cout<<\"check \"<<x<<\" \"<<y<<\";\"<<map[x][y]<<endl;\n  if(x==xg&&y==yg)\n    return true;\n  int buf=map[x][y];\n  map[x][y]=-1;\n  for(int i=0;i<4;i++)\n    {\n      if(x+dx[i]>=0&&x+dx[i]<h&&\n\t y+dy[i]>=0&&y+dy[i]<w&&\n\t buf==map[x+dx[i]][y+dy[i]] &&\n\t map[x+dx[i]][y+dy[i]]!=-1 &&\n\t check(x+dx[i],y+dy[i]))\n\treturn true;\n    }\n\n  \n  return false;\n}\n\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      memset(map,-1,sizeof(map));\n      int xs,ys;\n      cin>>xs>>ys;\n      cin>>xg>>yg;\n      xs--;ys--;\n      xg--;yg--;\n      \n      int n;\n      cin>>n;\n      for(;n--;)\n\t{\n\t  int c,d,x,y;\n\t  cin>>c>>d>>y>>x;\n\t  x--;y--;\n\t  if(d==0)\n\t    {\n\t      for(int xx=x;xx<x+2;xx++)\n\t\tfor(int yy=y;yy<y+4;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t  else\n\t    {\n\t      for(int xx=x;xx<x+4;xx++)\n\t\tfor(int yy=y;yy<y+2;yy++)\n\t\t  map[xx][yy]=c;\n\t    }\n\t}\n      //   mapout();\n      if(check(xs,ys))\n\tcout<<\"OK\"<<endl;\n      else \n\tcout<<\"NG\"<<endl;\n    }\n  \n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint show=0;\nint w,h,sx,sy,gx,gy,d[101][101],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},C;\nint field[101][101];\nconst int INF=9999999;\ntypedef pair<int,int> P;\n\nvoid bfs(){\n\tqueue<P> que;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)d[i][j]=INF;\n\tque.push(P(sy,sx));\n\td[sy][sx]=0;\n\twhile(!que.empty()){\n\t\tP p=que.front(); que.pop();\n\t\tif(p.first==gy&&p.second==gx)break;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ny=p.first+dx[i],nx=p.second+dy[i];\n\t\t\tif(1<=ny&&ny<=h&&1<=nx&&nx<=w&&field[ny][nx]==C&&d[ny][nx]==INF){\n\t\t\tque.push(P(ny,nx));\n\t\t\td[ny][nx]=d[p.first][p.second]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(d[gy][gx]==INF)cout<<\"NG\"<<endl;\n\telse cout<<\"OK\"<<endl;\n}\n\nint main() {\n\twhile(cin>>h>>w){\n\t\tif(!h)return 0;\n\t\tint n,c,di,x,y;\n\t\tcin>>sx>>sy>>gx>>gy>>n;\n\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++)field[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>c>>di>>x>>y;\n\t\t\tfor(int j=y;j<y+2+di*2;j++)for(int k=x;k<x+2+!di*2;k++)field[j][k]=c;\n\t\t}\n\t\tC=field[1][1];\n\t\tif(!C)cout<<\"NG\"<<endl;\n\t\telse bfs();\n\t\tif(show)for(int i=1;i<=h;i++){for(int j=1;j<=w;j++){if(field[i][j])cout<<field[i][j];else cout<<\" \";}cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing V = vector<int>;\nusing VV = vector<V>;\nstruct P {int x, y;};\n\nint main() {\n\tint dx[] = {4, 2}, dy[] = {2, 4};\n\tfor (int w, h; w = in(), h = in();) {\n\t\tP s = {in(), in()}, g = {in(), in()};\n\t\tint n = in();\n\t\tVV m(h + 2, V(w + 2));\n\t\twhile (n--) {\n\t\t\tint c = in(), d = in(), x = in(), y = in();\n\t\t\tfor (int i = 0; i < dy[d]; i++)\n\t\t\t\tfor (int j = 0; j < dx[d]; j++)\n\t\t\t\t\tm[i + y][j + x] = c;\n\t\t}\n\t\tint c = m[s.y][s.x];\n\t\tm[s.y][s.x] = 0;\n\t\tfunction<bool(int, int)> f = [&](int x, int y) {\n\t\t\tif (x == g.x && y == g.y)\n\t\t\t\treturn true;\n\t\t\tP d = {1, 0};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = x + d.x, ty = y + d.y;\n\t\t\t\tif (m[ty][tx] == c) {\n\t\t\t\t\tm[ty][tx] = 0;\n\t\t\t\t\tif (f(tx, ty))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tswap(d.x, d.y *= -1);\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\toutl(c ? f(s.x, s.y) ? \"OK\" : \"NG\" : \"NG\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint xx[4] = {0, 1, 0, -1};\nint yy[4] = {1, 0, -1, 0};\nint block[100][100];\nbool already[100][100];\nint w, h;\nint xs, ys;\nint xg, yg;\nbool dfs(int nex, int ney);\n\nint main(){\n  int n;\n  \n  while(1){\n    memset(block, 0, sizeof(block));\n    memset(already, 0, sizeof(already));\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    cin >> xs >> ys;\n    cin >> xg >> yg;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n      int c, d, x, y;\n      int wide, high;\n      cin >> c >> d >> x >> y;\n      if(d){\n\twide = 2; high = 4;\n      }\n      else{\n\twide = 4; high = 2;\n      }\n      for(int j = 0; j < high; j++){\n\tfor(int k = 0; k < wide; k++){\n\t  block[y+j][x+k] = c;\n\t}\n      }\n    }\n    bool ans = false;\n    if(block[ys][xs] == block[yg][xg]){\n      ans = dfs(xs, ys);\n      if(ans) cout << \"OK\" << endl;\n      else cout << \"NG\" << endl;\n    }\n    else cout << \"NG\" << endl;\n  }\n}\n\nbool dfs(int nex, int ney){\n  already[nex][ney] = true;\n  if(nex == xg && ney == yg) return true;\n  for(int i = 0; i < 4; i++){\n    int nx = nex + xx[i];\n    int ny = ney + yy[i];\n    if(0 <= nx && 0 <= ny && ny < h && nx < w && !already[ny][nx] && block[ys][xs] == block[ny][nx]) return dfs(nx, ny);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 0;\n      }\n    }\n       \n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvoid PutBlock(vector< vector<int> >&, int, int, int, int);\nvoid CheckMaze1(vector< vector<int> >&, int&, int, int, int, int, int);\nvoid CheckMaze2(vector< vector<int> >&, int&, int, int, int, int, int);\n\nint main(){\n  int k, i, j, w, h, n, xs, ys, xg, yg, c, d, x, y, color, ans;\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    vector<int> _data(w, 0);\n    vector< vector<int> > data(h, w);\n\n    cin >> ys >> xs;\n    cin >> yg >> xg;\n    --xs;\n    --xg;\n    --ys;\n    --yg;\n\n    cin >> n;\n\n    for(i=0; i<n; ++i){\n      cin >> c >> d >> y >> x;\n      PutBlock(data, c, d, x-1, y-1);\n    }\n\n    color = data[xs][ys];\n\n    ans = 0;\n    CheckMaze1(data, ans, color, xs, ys, xg, yg);\n\n    if(ans == 1)\n      cout << \"OK\" << endl;\n    else\n      cout << \"NG\" << endl;\n  }\n\n  return 0;\n}\n\nvoid PutBlock(vector< vector<int> >& data, int c, int d, int x, int y){\n  int i, j;\n  if(d == 0){\n    for(i=x; i<x+2; ++i){\n      for(j=y; j<y+4; ++j)\n\tdata[i][j] = c;\n    }\n  }else{\n    for(i=x; i<x+4; ++i){\n      for(j=y; j<y+2; ++j)\n\tdata[i][j] = c;\n    }\n  }\n}\n\nvoid CheckMaze1(vector< vector<int> >& data, int& ans, int color, int x, int y, int xg, int yg){\n  data[x][y] = -1;\n  if(x == xg && y == yg) ans = 1;\n\n  CheckMaze2(data, ans, color, x-1, y, xg, yg);\n  CheckMaze2(data, ans, color, x, y-1, xg, yg);\n  CheckMaze2(data, ans, color, x+1, y, xg, yg);\n  CheckMaze2(data, ans, color, x, y+1, xg, yg);\n}\n\nvoid CheckMaze2(vector< vector<int> >& data, int& ans, int color, int x, int y, int xg, int yg){\n  if(x > -1 && x < data.size() && y > -1 && y < data[0].size() && data[x][y] == color)\n    CheckMaze1(data, ans, color, x, y, xg, yg);\n}"
  },
  {
    "language": "C++",
    "code": "/* 0207 */\n#include <iostream>\nusing namespace std;\nint n,w,h;\nint M[101][101];\nint a,b,c,d;\n\nint walk(int x,int y,int color){\n\tif(x<1||w<x||y<1||h<y)return 0;\n\tif(color!=M[x][y]||color==0)return 0;\n\tM[x][y]=9;\n\tif(x==c&&y==d)return 1;\n\tif(walk(x+1,y,color)||\n\t\t\twalk(x-1,y,color)||\n\t\t\twalk(x,y+1,color)||\n\t\t\twalk(x,y-1,color))return 1;\n\treturn 0;\n}\nint main(void){\n\twhile(cin>>w>>h,w||h){\n\t\tcin>>a>>b>>c>>d;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tM[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint w,x,y,z;\n\t\t\tcin>>w>>x>>y>>z;\n\t\t\tif(x){\n\t\t\t\tfor(int Y=z;Y<z+4;Y++){\n\t\t\t\t\tfor(int X=y;X<y+2;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int Y=z;Y<z+2;Y++){\n\t\t\t\t\tfor(int X=y;X<y+4;X++){\n\t\t\t\t\t\tM[Y][X]=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(walk(a,b,M[a][b]))cout<<\"OK\"<<endl;\n\t\telse cout<<\"NG\"<<endl;\n\t\t// if(M[c][d]==9)cout<<\"OK\"<<endl;\n\t\t// else cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\nint gx,gy;\nbool goal_flag;\nvoid DFS(int x,int y,board b,int c){\n\n    if(b.mass[y][x]!=c || b.mass[y][x]==0)return;\n    if(x==gx&&y==gy){goal_flag=true;return;}\n    b.mass[y][x]=0;\n    DFS(x+1,y,b,c);\n    DFS(x-1,y,b,c);\n    DFS(x,y+1,b,c);\n    DFS(x,y-1,b,c);\n}\n\nint main(){\n  int h,w;\n  int start_x,start_y;\n\n  int n;\n  int c,d,x,y;\n  board b;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    cin>>start_x>>start_y;\n    cin>>gx>>gy;\n    cin>>n;\n    for(int i=0;i<h+2;i++){\n      for(int j=0;j<w+2;j++){\n        b.mass[i][j]=0;\n      }\n    }\n\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n  if(W==xg && H==yg){\n    ans = 1;\n    return;\n  }\n\n  if(C[W][H]!=c){\n    return;\n  }\n\n  C[W][H] = '.';\n\n  meiro(W-1,H  ,c);\n  meiro(W  ,H+1,c);\n  meiro(W+1,H  ,c);\n  meiro(W  ,H-1,c);\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin >> w >> h;\n\n    if(w==0 && h==0){\n      break;\n    }\n\n    int xs,ys;\n    cin >> xs >> ys;\n\n    cin >> xg >> yg;\n\n    int n;\n    cin >> n;\n    int c[n],d[n],x[n],y[n];\n\n    int cbase;\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n        C[w][h] = 0;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n      if(d[i]==0){\n        for(int j=x[i];j<x[i]+4;j++){\n          for(int k=y[i];k<y[i]+2;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n      if(d[i]==1){\n        for(int j=x[i];j<x[i]+2;j++){\n          for(int k=y[i];k<y[i]+4;k++){\n            C[j][k]=c[i];\n          }\n        }\n      }\n\n      if(x[i]==xs &&y[i]==ys){\n        cbase = c[i];\n      }\n    }\n    ans = 0;\n    meiro(xs,ys,C[xs][ys]);\n\n    if(ans==1){\n      cout << \"OK\" << endl;\n    }else{\n      cout << \"NG\" << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\nusing namespace std;\n\nint C[102][102];\nint ans;\nint xg,yg;\n\nvoid meiro(int W,int H,int c){\n if(W==xg && H==yg){\n   ans = 1;\n   return;\n }\n\n if(C[W][H]!=c){\n   return;\n }\n\n C[W][H] = '.';\n\n meiro(W-1,H  ,c);\n meiro(W  ,H+1,c);\n meiro(W+1,H  ,c);\n meiro(W  ,H-1,c);\n}\n\nint main(){\n while(1){\n   int w,h;\n   cin >> w >> h;\n\n   if(w==0 && h==0){\n     break;\n   }\n\n   int xs,ys;\n   cin >> xs >> ys;\n\n   cin >> xg >> yg;\n\n   int n;\n   cin >> n;\n   int c[n],d[n],x[n],y[n];\n\n   int cbase;\n\n   for(int i=0;i<n;i++){\n     cin >> c[i] >> d[i] >> x[i] >> y[i];\n\n     if(d[i]==0){\n       for(int j=x[i];j<x[i]+4;j++){\n         for(int k=y[i];k<y[i]+2;k++){\n           C[j][k]=c[i];\n         }\n       }\n     }\n     if(d[i]==1){\n       for(int j=x[i];j<x[i]+2;j++){\n         for(int k=y[i];k<y[i]+4;k++){\n           C[j][k]=c[i];\n         }\n       }\n     }\n\n     if(x[i]==1 &&y[i]==1){\n       cbase = c[i];\n     }\n   }\n   ans = 0;\nif(cbasew == 0){\n cout << \"NG\"<<endl;\n continue;\n}\n   meiro(xs,ys,cbase);\n\n   if(ans==1){\n     cout << \"OK\" << endl;\n   }else{\n     cout << \"NG\" << endl;\n   }\n }\n\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 0;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tcin >> w >> h;\t\t\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tcin>>xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\t\tcolor = map[xs][ys];\n\t\tif(color!=0)\n\t\t\troute(xs, ys, color);\n\t\tif (map[xg][yg]==0)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar F[102][102];\n\nvoid DFS_W(int Y,int X,int Xg,int Yg,int c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='w')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_W(Y-1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X+1,Xg,Yg,c);\n  DFS_W(Y+1,X  ,Xg,Yg,c);\n  DFS_W(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_Y(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='y')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_Y(Y-1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X+1,Xg,Yg,c);\n  DFS_Y(Y+1,X  ,Xg,Yg,c);\n  DFS_Y(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_G(int Y,int X,int Xg,int Yg,int &c){\n  if((Y==Xg&&X==Yg)||(c!= 0)){\n    c=1;\n  }\n  if(F[Y][X]!='g'){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_G(Y-1, X  ,Xg,Yg,c);\n  DFS_G(Y  ,X+1,Xg,Yg,c);\n  DFS_G(Y+1,X  ,Xg,Yg,c);\n  DFS_G(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_B(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='b')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_B(Y-1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X+1,Xg,Yg,c);\n  DFS_B(Y+1,X  ,Xg,Yg,c);\n  DFS_B(Y  ,X-1,Xg,Yg,c);\n}\nvoid DFS_R(int Y,int X,int Xg,int Yg,int &c){\n  if(Y==Xg&&X==Yg){\n    c=1;\n  }\n  if((F[Y][X]!='r')||(c!=0)){\n    return;\n  }\n  F[Y][X]='.';\n  DFS_R(Y-1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X+1,Xg,Yg,c);\n  DFS_R(Y+1,X  ,Xg,Yg,c);\n  DFS_R(Y  ,X-1,Xg,Yg,c);\n}\n\nint main(){\n\n  for(int i=0;i<102;i++){\n    for(int j=0;j<102;j++){\n      F[j][i]='0';\n    }\n  }\n  int w;\n  int h;\n  int xs;\n  int ys;\n  int xg;\n  int yg;\n  int n;\n  cin>>w>>h;\n  while(1){\n    //int a=0;\n    //int b=0;\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    cin>>n;\n    int c[n];\n    int d[n];\n    int x[n];\n    int y[n];\n    for(int i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      //int a=0;\n      //int b=0;\n      if(d[i]==0) {\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='w';\n            F[y[i]+1][x[i]+z] ='w';\n          }\n        }else if(c[i]==2){\n\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='y';\n            F[y[i]+1][x[i]+z] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='g';\n            F[y[i]+1][x[i]+z] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='b';\n            F[y[i]+1][x[i]+z] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]][x[i]+z] ='r';\n            F[y[i]+1][x[i]+z] ='r';\n          }\n        }\n      }else if(d[i]==1){\n        if(c[i]==1){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='w';\n            F[y[i]+z][x[i]+1] ='w';\n          }\n        }else if(c[i]==2){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='y';\n            F[y[i]+z][x[i]+1] ='y';\n          }\n        }else if(c[i]==3){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='g';\n            F[y[i]+z][x[i]+1] ='g';\n          }\n        }else if(c[i]==4){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='b';\n            F[y[i]+z][x[i]+1] ='b';\n          }\n        }else if(c[i]==5){\n          for(int z=0;z<4;z++){\n            F[y[i]+z][x[i]] ='r';\n            F[y[i]+z][x[i]+1] ='r';\n          }\n        }\n      }\n    }\n    int cnt=0;\n    if(F[ys][xs]=='w'){\n      DFS_W(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='y'){\n      DFS_Y(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='g'){\n      DFS_G(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='b'){\n      DFS_B(ys,xs,xg,yg,cnt);\n    }else if(F[ys][xs]=='r'){\n      DFS_R(ys,xs,xg,yg,cnt);\n    }\n    if(cnt==0){\n      cout<<\"NG\"<<endl;\n    }else if(cnt==1){\n      cout<<\"OK\"<<endl;\n    }\n    cin>>w>>h;\n    if((w==0)&&(h==0))\n      break;\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n        F[i][j]='0';\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct board{\n  int mass[102][102];\n};\n\nbool goal_flag;\nvoid DFS(int x,int y,int gx,int gy,board b,int c){\n    if(b.mass[y][x]!=c)return;\n    if(!b.mass[y][x])return;\n    b.mass[y][x]=-1;\n    if(x==gx&&y==gy)goal_flag=true;\n    DFS(x+1,y,gx,gy,b,c);\n    DFS(x-1,y,gx,gy,b,c);\n    DFS(x,y+1,gx,gy,b,c);\n    DFS(x,y-1,gx,gy,b,c);\n}\n\nint main(){\n  while(1){\n    int h,w;\n    int start_x,start_y;\n    int goal_x,goal_y;\n    int n;\n\n    cin>>w>>h;\n    if(w==0&&h==0)return 0;\n    cin>>start_x>>start_y;\n    cin>>goal_x>>goal_y;\n    cin>>n;\n\n    board b;\n    for(int i=0;i<102;i++){\n      for(int j=0;j<102;j++){\n          b.mass[i][j]=0;\n        }\n      }\n\n    int c,d,x,y;\n    for(int i=0;i<n;i++){\n        cin>>c>>d>>x>>y;\n        for(int j=0;j<2;j++){\n          for(int k=0;k<4;k++){\n            if(d==0){b.mass[y+j][x+k]=c;}\n            else if(d==1){b.mass[y+k][x+j]=c;}\n          }\n        }\n    }\n    goal_flag=false;\n    DFS(start_x,start_y,goal_x,goal_y,b,b.mass[start_y][start_x]);\n    if(goal_flag)cout<<\"OK\";\n    else cout<<\"NG\";\n    cout<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n,ban[111][111]={{0},{0}};\nbool visited [101][101];\nconst int START=4545191;\nconst int GOAL=454545;\n\n\tbool dfs(int x,int y){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tif(xg==x&&yg==y)return true;\n\t\t//if(ban[xs][ys]==0)return false;\n\t\tif(ban[x+1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x+1,y))return true;\n\t\t}\n\t\tif(ban[x][y+1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y+1))return true;\n\t\t}\n\t\tif(x>=2&&ban[x-1][y]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x-1,y))return true;\n\t\t}\n\t\tif(y>=2&&ban[x][y-1]==ban[xs][ys]&&visited[x][y]==false){\n\t\t\tvisited[x][y]=true;\n\t\t\tif(dfs(x,y-1))return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\nint main(){\n\n\twhile(cin>>w>>h&&w&&h){\n\tcin>>xs>>ys>>xg>>yg>>n;\n\tfor(int i=0;i<101;i++)\n\tfor(int j=0;j<101;j++)ban[i][j]=0,visited[i][j]=false;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint c,d,x,y;\n\t\tcin>>c>>d>>x>>y;\n\t\tif(!d){\n\t\t\tfor(int i=x;i<x+4;i++){\n\t\t\t\tfor(int j=y;j<y+2;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\tfor(int i=x;i<x+2;i++){\n\t\t\t\tfor(int j=y;j<y+4;j++){\n\t\t\t\t\tban[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(dfs(xs,ys))cout<<\"OK\"<<endl;\n\telse cout<<\"NG\"<<endl;\n\t}\n\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint board[102][102];\nint xg , yg;\nint w, h;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint sc;\nbool b;\n\nvoid dfs(int x , int y){\n\tif(x==xg&&y==yg) {b=true;return;}\n\tfor(int i=0;i<4;++i){\n\t\tint tx=x+dx[i];\n\t\tint ty=y+dy[i];\n\t\tif(tx<=0||ty<=0||tx>w||ty>h) continue;\n\t\tif(board[tx][ty]!=sc || board[tx][ty]==0) continue;\n\t\tif(b) continue;\n\t\tdfs(tx,ty);\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h , w||h){\n\t\tint xs , ys;\n\t\tint n;\n\t\tb=false;\n\t\tmemset(board,0,sizeof(board));\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint c , d , x , y;\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif(d==0){\n\t\t\t\tfor(int k=0;k<2;++k){\n\t\t\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(d==1){\n\t\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\t\tfor(int j=0;j<2;++j){\n\t\t\t\t\t\tboard[x+j][y+k]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc=board[xs][ys];\n\t\tdfs(xs,ys);\n\t\tcout << ( b ? \"OK\" : \"NG\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\nint C,goal,n,x,y,xs,ys,xg,yg,mas[110][110]={{0}};\nint dx[4]={0,0,1,1};\nint dy[4]={0,1,0,1};\nint d[110][110];\ntypedef pair<int,int>P;\n\nint bfs();\nint main(){\n\n  while(1){\n    goal=0;\n    memset(mas,0,sizeof(mas));\n    cin >> x >> y;//ボードの大きさ。 ※：x=横。y=縦。\n    if(x==0 && y==0){\n      break;\n    }\n    cin >> xs >> ys;//スタート地点。\n    cin >> xg >> yg;//ゴール地点。\n    cin >> n;//ブロックの数。\n    \n    //色染め。\n    int color,dire,xx,yy;\n    for(int t=0;t<n;t++){\n      cin >> color >> dire >> xx >> yy;\n      if(dire==0){\n\tfor(int i=0;i<2;i++){\n\t  for(int j=0;j<4;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n      else{\n\tfor(int i=0;i<4;i++){\n\t  for(int j=0;j<2;j++){\n\t    mas[yy+i][xx+j]=color;\n\t  }\n\t}\n      }\n      \n    }\n    \n    //通る色　摘出。\n    C=mas[1][1];\n    \n    bfs();\n    \n    if(goal==1){\n      cout << \"OK\" << endl;\n    }\n    else{\n      cout << \"NG\" << endl;\n    }\n    \n  }\n}\n\nint bfs(){\n  queue<P>que;\n  memset(d,-1,sizeof(d));\n  que.push(P(ys,xs));\n  d[ys][xs]=0;\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    if(p.first==yg && p.second==xg){\n      goal=1;\n      break;\n    }\n    for(int i=0;i<4;i++){\n      int ny=p.first+dy[i];\n      int nx=p.second+dx[i];\n      if(mas[ny][nx]==C && ny>=1 && ny<=y && nx>=1 && nx<=x && d[ny][nx]==-1){\n\tque.push(P(ny,nx));\n\td[ny][nx]=0;\n      }\n    }\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint w,h;\nint sx,sy,gx,gy;\nint n,c,d,x,y;\nint g[200][200];\nbool use[200][200];\nint dy[] = {-1,-1,0,1,1,1,0,-1}, dx[] = {0,1,1,1,0,-1,-1,-1};\n\nvoid rec(int Y,int X, char c){\n  if(use[Y][X])return;\n  use[Y][X] = true;\n\n  for(int i=0;i<8;i++){\n    int ny = Y+dy[i], nx = X+dx[i];\n    if(ny<1 || nx<1 || ny>h || nx>w)continue;\n    if(g[ny][nx] == c)rec(ny,nx,c);\n  }\n}\n\nint main(){\n  while(cin >> w >> h,w||h){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++)g[i][j] = 0;\n    }\n\n    cin >> sx >> sy >> gx >> gy >> n;\n    for(int i=0;i<n;i++){\n      cin >> c >> d >> x >> y;\n      if(d==0){\n\tfor(int j=0;j<2;j++){\n\t  for(int k=0;k<4;k++){\n\t    g[y+j][x+k] = c;\n\t  }\n\t}\n      }else{\n\tfor(int j=0;j<4;j++){\n\t  for(int k=0;k<2;k++){\n\t    g[y+j][x+k] = c;\n\t  }\n\t}\n      }\n    }\n    /*\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcout << g[i][j] << \" \";\n      }\n      cout << endl;\n    }\n    */\n\n    if(!g[sy][sx] || !g[gy][gx] || g[sy][sx] != g[gy][gx]){\n      cout << \"NG\\n\";\n    }else{\n      rec(sy,sx,g[sy][sx]);\n      cout << (use[gy][gx]?\"OK\":\"NG\") << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102];\nint xg,yg;\nint flag = 0;\n\nvoid DFS(int Y,int X,int c){\n  if(F[Y][X] != c){\n    return;\n  }\n  if(Y == xg && X == yg){\n    flag = 1;\n  }\n\n  F[Y][X] = 0;\n  DFS(Y-1,X  ,c);\n  //DFS(Y-1,X+1,c);\n  DFS(Y  ,X+1,c);\n  //DFS(Y+1,X+1,c);\n  DFS(Y+1,X  ,c);\n  //DFS(Y+1,X-1,c);\n  DFS(Y  ,X-1,c);\n  //DFS(Y-1,X-1,c);\n}\n\n\nint main(){\n  int w,h,xs,ys,n;\n  while(1){\n  cin >> w >> h;\n  if(w == 0 && h == 0)\n    break;\n\n  cin >> xs >> ys >> xg >> yg >> n;\n  for(int i=0;i<n;i++){\n    int c,d,x,y;\n    cin >> c >> d >> x >> y;\n    if(d == 0){\n      for(int j=0;j<4;j++){\n        F[x+j][y] = c;\n        F[x+j][y+1] = c;\n      }\n    } else {\n      for(int j=0;j<4;j++){\n        F[x][y+j] = c;\n        F[x+1][y+j] = c;\n      }\n    }\n  }\n\n  DFS(xs,ys,F[xs][ys]);\n  if(flag == 1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\nusing namespace std ;\n\nint mx[] = { 1 ,0 ,0 ,-1 } ;\nint my[] = { 0 ,1 ,-1 ,0 } ;\n\nint w ,h ;\nint gx ,gy ;\n\nint ok_or_ng( int x ,int y ,bool came[][ 101 ] )\n{\n\tcame[ y ][ x ] = false ;\n\n\tif( x == gx && y == gy )\n\t\treturn 1 ;\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x + mx[ i ] ;\n\t\tint yy = y + my[ i ] ;\n\t\tif( xx > 0 && xx <= w && yy > 0 && yy <= h && came[ yy ][ xx ] )\n\t\t\treturn ok_or_ng( xx ,yy ,came ) ;\n\t}\n\treturn 0 ;\n}\n\nvoid wide( int x ,int y ,int c ,int map[][ 101 ] )\n{\n\n\tfor( int i = 0 ; i < 2 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 4 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nvoid high( int x ,int y ,int c ,int map[][ 101 ] )\n{\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tfor( int j = 0 ; j < 2 ; j++ )\n\t\t\tmap[ y + i ][ x + j ] = c ;\n\t}\n\n\treturn ;\n}\n\nint main()\n{\n\twhile( cin >> w >> h ,w & h )\n\t{\n\t\tbool came[ 101 ][ 101 ] = { false } ;\n\t\tint map[ 101 ][ 101 ] = { 0 } ;\n\n\t\tint sx ,sy ;\n\n\t\tcin >> sx >> sy ;\n\t\tcin >> gx >> gy ;\n\n\t\tint n ;\n\t\tcin >> n ;\t\t\t\t\t// 0 w\t1 h\n\n\t\tint c ,d ,x, y ;\n\t\tfor( int i = 0 ; i < n ; i++ )\n\t\t{\n\t\t\tcin >> c >> d >> x >> y ;\n\t\t\td ? high( x ,y ,c ,map ) : wide( x ,y ,c ,map ) ;\n\t\t}\n\n\t\tc = map[ gy ][ gx ] ;\n\n\t\tfor( int i = 1 ; i <= h ; i++ )\n\t\t{\n\t\t\tfor( int j = 1 ; j <= w ; j++ )\n\t\t\t{printf( \"%d\",map[ i ][ j ] ) ;\n\t\t\t\tif( map[ i ][ j ] == c )\n\t\t\t\t\tcame[ i ][ j ] = true ;\n\t\t\t}printf( \"\\n\" ) ;\n\t\t}\n\n\t\tok_or_ng( sx ,sy ,came ) ? printf( \"OK\\n\" ) : printf( \"NG\\n\" ) ;\n\t}\n\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[101][102];\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif (F[ys][xs] != 0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == 10) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i < H;i++) {\n\t\t\tfor (int j = 0;j < W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint F[102][102] = { 0 };\n\nvoid DFS(int Y, int X, int c) {\n\t//cout << Y << \" \" << X << endl;\n\tif (F[Y][X] != c)\n\t\treturn;\n\tF[Y][X] = 10;\n\tDFS(Y - 1, X, c);//???\n\t\t\t\t\t //DFS(Y - 1, X+1, A_ito);//??????\n\tDFS(Y, X + 1, c);//???\n\t\t\t\t\t //DFS(Y + 1, X+1, A_ito);//??????\n\tDFS(Y + 1, X, c);//???\n\t\t\t\t\t //DFS(Y + 1, X-1, A_ito);//??????\n\tDFS(Y, X - 1, c);//???\n\t\t\t\t\t //DFS(Y - 1, X-1, A_ito);//??????\n}\n\n\nint main()\n{\n\tint xs, ys, xg, yg, n;\n\tint c, d, x, y;\n\tint W = 1, H = 1;\n\n\twhile ((W != 0) && (H != 0)) {\n\t\tcin >> W >> H;\n\t\tfor (int i = 1;i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tF[i][j] = 6;\n\t\t\t}\n\t\t}\n\t\tcin >> xs >> ys >> xg >> yg >> n;\n\t\tfor (int i = 1;i <= n;i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x + 2][y] = c;\n\t\t\t\tF[x + 2][y + 1] = c;\n\t\t\t\tF[x + 3][y] = c;\n\t\t\t\tF[x + 3][y + 1] = c;\n\t\t\t}\n\t\t\tif (d == 1) {\n\t\t\t\tF[x][y] = c;\n\t\t\t\tF[x + 1][y] = c;\n\t\t\t\tF[x][y + 1] = c;\n\t\t\t\tF[x + 1][y + 1] = c;\n\t\t\t\tF[x][y + 2] = c;\n\t\t\t\tF[x + 1][y + 2] = c;\n\t\t\t\tF[x][y + 3] = c;\n\t\t\t\tF[x + 1][y + 3] = c;\n\t\t\t}\n\t\t}\n\t\tif(F[xs][ys]!=0)\n\t\t\tDFS(ys, xs, F[ys][xs]);\n\n\t\tif (F[yg][xg] == F[ys][yg]) {\n\t\t\tcout << \"OK\" << endl;\n\t\t}\n\t\telse { cout << \"NG\" << endl; }\n\t\tfor (int i = 0;i <= H;i++) {\n\t\t\tfor (int j = 0;j <= W;j++) {\n\t\t\t\tF[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n   \nint F[102][102];\nint xg,yg,w,h;\n   \n   \nvoid DFS(int Y,int X,int c){\n  //if(Y < 1 || X < 1)\n    //return;\n  if(F[Y][X] != c){\n    return;\n  }\n   \n  F[Y][X] = -1;\n  DFS(Y+1,X  ,c);\n  DFS(Y-1  ,X,c);\n  DFS(Y,X+1  ,c);\n  DFS(Y  ,X-1,c);\n}\n   \n   \nint main(){\n  int xs,ys,n;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0)\n      break;\nfor(int i=0; i<102; i++){\n      for(int j=0; j<102; j++){\n        F[i][j] = 10;\n      }\n    }\n       F[0][104] = 0;\n    cin >> xs >> ys >> xg >> yg >> n;\n   \n   \n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin >> c >> d >> x >> y;\n      if(c == 0)\n         c = 1919810;\n      if(d == 0){\n        for(int j=0;j<4;j++){\n          F[x+j][y] = c;\n          F[x+j][y+1] = c;\n        }\n      } else {\n        for(int j=0;j<4;j++){\n          F[x][y+j] = c;\n          F[x+1][y+j] = c;\n        }\n      }\n    }\n  DFS(xs,ys,F[xs][ys]);\n   \n  if(F[xg][yg] == -1){\n    cout << \"OK\" << endl;\n  } else {\n    cout << \"NG\" <<endl;\n  }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w+h){\n    int xs,ys,xg,yg;\n    bool Map[h+10][w+10]={};\n    bool flag=false;\n    cin>>xs>>ys>>xg>>yg;\n    xs--;ys--;xg--;yg--;\n    int n;cin>>n;\n    int Map2[h+10][w+10]={};\n    Map[ys][xs]=true;\n    queue<pair<int,int> >que;\n    que.push(mp(ys,xs));\n    for(int i=0;i<n;i++){\n      int c,d,x,y;\n      cin>>c>>d>>x>>y;\n      x--;y--;\n      if(d==0){\n\tfor(int i=y;i<y+2;i++)\n\t  for(int j=x;j<x+4;j++)\n\t    Map2[i][j]=c;\n      }else if(d==1){\n\tfor(int i=y;i<y+4;i++)\n\t  for(int j=x;j<x+2;j++)\n\t    Map2[i][j]=c;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)\n\tcout<<Map2[i][j]<<\" \";\n      cout<<endl;\n    }\n    int vx[8]={0,-1,0,1,1,1,-1,-1};\n    int vy[8]={1,0,-1,0,-1,1,-1,1};\n    while(!que.empty()){\n      pair<int,int>now=que.front();\n      que.pop();\n      if(now.F==xg&&now.S==yg){\n\tflag=true;\n\tbreak;\n      }\n      for(int kk=0;kk<8;kk++){\n\tint as=now.F+vx[kk];int bs=now.S+vy[kk];\n\tif(as<h&&as>=0&&bs<w&&bs>=0&&Map2[now.F][now.S]==Map2[as][bs]&&!Map[as][bs]){\n\t  que.push(mp(as,bs));\n\t  Map[as][bs]=true;\n\t}\n      }\n    }\n    if(flag)\n      cout<<\"OK\"<<endl;\n    else\n      cout<<\"NG\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#define SIZE 110\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvoid make_mass(void);   //マス作成用関数\nvoid solve(void);       //処理\n\nint n;             //ブロックの個数\nint w,h;           //ボードの幅、高さ\nint goal=0;        //迷路になっているか\nint scolor;        //スタート位置の色\nint sx,sy,gx,gy;   //スタートの座標、ゴールの座標\nint mass[SIZE][SIZE];\nint data[SIZE][SIZE];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint c[SIZE],d[SIZE],x[SIZE],y[SIZE];       //ブロックの色、向き、左上の座標\n\n\nint main(){\n\n  int i,j;             //カウンタ変数\n\n  while(1){\n\n    /*情報の入力*/\n    cin>>w>>h;\n\n    if(w==h && w==0){break;}\n    \n    cin>>sx>>sy;\n    cin>>gx>>gy;  \n    cin>>n;\n    \n    for(i=0;i<n;i++){\n      cin>>c[i]>>d[i]>>x[i]>>y[i];\n      \n    }\n    \n    make_mass();\n\n    solve();\n     \n    if(goal==1){\n      cout<<\"OK\"<<endl;\n      goal=0;\n    } else if(goal==0){\n      cout<<\"NG\"<<endl;\n      }\n  }\n  \n  return 0;\n}\nvoid make_mass(void){\n  \n  int i,j;\n\n  memset(mass,0,sizeof(mass));\n\n  /*マスの作成*/\n  for(i=0;i<n;i++){\n    if(d[i]==0){       //横向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]][x[i]+j]=c[i];\n\tmass[y[i]+1][x[i]+j]=c[i];\n      }\n    }\n    if(d[i]==1){              //縦向きなら\n      for(j=0;j<4;j++){\n\tmass[y[i]+j][x[i]]=c[i];\n\tmass[y[i]+j][x[i]+1]=c[i];\n      }\n    }\n  }\n  \n  scolor=mass[sy][sx];\n\n  \n  return;\n}\nvoid solve(void){\n  \n  int i,j;\n  queue<P> que;\n  memset(data,-1,sizeof(data));\n  que.push(P(sx,sy));     //queにスタート位置の座標を格納\n  data[sy][sx]==0;\n  \n  while(!que.empty()){    //queが空でない間\n    P p=que.front();\n    que.pop();\n    \n    if(p.first==gy && p.second==gx){\n      goal=1;\n      /* cout<<\" (^q^)くおえうえーーーるえうおおおwwww\"<<endl;*/\n      break;\n    }\n    for(i=0;i<4;i++){\n      int nx=p.first+dx[i];\n      int ny=p.second+dy[i];\n      if(nx>=0 && nx<w && ny>=0 && ny<h && mass[ny][nx]==scolor && data[ny][nx]==-1){\n\tque.push(P(nx,ny));\n\tdata[ny][nx]=1;\n      }\n    }\n  }\n  return;\n}\n/*\n花火は他人に向けちゃダメだよ。\n\n( ・ω・)o─━・*:・:・(※)`Д´)アヂィ!\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint map[102][102];\n\nvoid route(int w, int h, int color) {\n\tif (map[w][h] != color)\n\t\treturn;\n\tmap[w][h] = 10;\n\troute(w, h + 1, color);\n\troute(w + 1, h, color);\n\troute(w, h - 1, color);\n\troute(w - 1, h, color);\n}\n\n\nint main() {\n\tint h, w, xs, ys, xg, yg, n;\n\tint c, d, x, y,color;\n\n\twhile (1) {\n\t\tfor (int i = 0; i < 102; i++)\n\t\t\tfor (int j = 0; j < 102; j++)\n\t\t\t\tmap[i][j] = 0;\n\t\tcin >> w >> h;\t\t\n\t\tif (w == 0 && h == 0)\n\t\t\tbreak;\n\n\t\tcin>>xs >> ys >> xg >> yg >> n;\n\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> c >> d >> x >> y;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[j + x][y] = map[j + x][y + 1] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\t\tmap[x][y + j] = map[x + 1][y + j] = c;\n\t\t\t}\n\t\t}\n\n\t\tcolor = map[xs][ys];\n\t\troute(xs, ys, color);\n\t\t\n\t\tif (map[xg][yg]==10)\n\t\t\tcout << \"OK\" << endl;\n\t\telse\n\t\t\tcout << \"NG\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint w,h,xs,ys,xg,yg,n;\nint c,d,x,y,ans=0,f=0;\nint map[101][101]={0},v[101][101]={0};\nint root(int x,int y,int vmap[][101]){\n\tint mx[]={0,1,0,-1},fx;\n\tint my[]={1,0,-1,0},fy;\n\tif(x==xg&&y==yg){\n\t\tf=1;\n\t\treturn f;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tfx=x+mx[i];\n\t\tfy=y+my[i];\n\t\tif(map[fy][fx]==map[xs][ys]&&fy>=0&&fy<h&&fx>=0&&fx<w&&vmap[fy][fx]==0){\n\t\t\tvmap[fy][fx]=1;\n\t\t\treturn root(fx,fy,vmap);\n\t\t}\n\t}\n\treturn f;\n}\nint main(){\n\tscanf(\"%d %d\",&w ,&h);\n\twhile(w!=0&&h!=0){\n\t\tscanf(\"%d %d %d %d %d\",&xs ,&ys ,&xg ,&yg ,&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c ,&d ,&x ,&y);\n\t\t\tif(d==0){\n\t\t\t\tfor(int w=x;w<x+4;w++){\n\t\t\t\t\tfor(int h=y;h<y+2;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==1){\n\t\t\t\tfor(int w=x;w<x+2;w++){\n\t\t\t\t\tfor(int h=y;h<y+4;h++){\n\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i=0;i<w;i++){\n\t\t\tfor(int i1=0;i1<h;i1++){\n\t\t\t\tprintf(\"%d \",map[i][i1]);\n\t\t\t}printf(\"\\n\");\n\t\t}*/\n\t\tx=xs;\n\t\ty=ys;\n\t\tans=root(x,y,v);\n\t\tif(ans==1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t\tfor(int i=0;i<101;i++){\n\t\t\tfor(int i1=0;i1<101;i1++){\n\t\t\t\tmap[i][i1]=0;\n\t\t\t\tv[i][i1]=0;\n\t\t\t}\n\t\t}\n\t\tf=0;\n\t\tans=0;\n\t\tscanf(\"%d %d\",&w ,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint block[100][100];\nint xs, ys, xg, yg, n, w, h;\n\nbool dfs(int x, int y, int c)\n{\n  if(block[x][y] != c || block[x][y] == 0)\n    return false;\n  if(x == xg && y == yg)\n    return true;\n  bool b = false;\n  block[x][y] = 0;\n  if(x < w - 1)\n    b |= dfs(x + 1, y, c);\n  if(x > 0 && !b)\n    b |= dfs(x - 1, y, c);\n  if(y < h - 1 && !b)\n    b |= dfs(x, y + 1, c);\n  if(y > 0 && !b)\n    b |= dfs(x, y - 1, c);\n  block[x][y] = c;\n  return b;\n}\n\nint main()\n{\n  while(true)\n  {\n    cin >> w >> h;\n    if(!w && !h)\n      break;\n    cin >> xs >> ys\n      >> xg >> yg >> n;\n    xs--; ys--;\n    xg--; yg--;\n    \n    for(int i = 0; i < n; i++)\n    {\n      int c, d, x, y;\n      cin >> c >> d >> x >> y;\n      x--; y--;\n      block[x][y] = c;\n      block[x + 1][y] = c;\n      block[x][y + 1] = c;\n      block[x + 1][y + 1] = c;\n      if(d == 0)\n        x += 2;\n      else\n        y += 2;\n      block[x][y] = c;\n      block[x + 1][y] = c;\n      block[x][y + 1] = c;\n      block[x + 1][y + 1] = c;\n    }\n    if(dfs(xs, ys, block[xs][ys]))\n      cout << \"OK\\n\";\n    else\n      cout << \"NG\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) return 0;\n\n        int sx, sy, gx, gy; cin>>sx>>sy>>gx>>gy;\n        sx--, sy--, gx--, gy--;\n\n        int n; cin>>n;\n        vector<vector<int>> board(h, vector<int>(w, 0));\n        while(n--){\n            int c, d, x, y; cin>>c>>d>>x>>y;\n            x--, y--;\n            if(d == 0){\n                for(int i=y; i<=y+1; i++){\n                    for(int j=x; j<=x+3; j++){\n                        board[i][j] = c;\n                    }\n                }\n            }\n            else{\n                for(int i=y; i<=y+3; i++){\n                    for(int j=x; j<=x+1; j++){\n                        board[i][j] = c;\n                    }\n                }\n            }\n        }\n\n        queue<P> que;\n        que.push(P(sy, sx));\n        int color = board[sy][sx];\n        board[sy][sx] = 0;\n        if(color == 0){\n            cout << \"NG\" << endl;\n            continue;\n        }\n\n        while(que.size()){\n            int cy, cx;\n            tie(cy, cx) = que.front();\n            que.pop();\n\n            if(cy == gy && cx == gx){\n                cout << \"OK\" << endl;\n                goto END;\n            }    \n\n            for(int i=0; i<4; i++){\n                int ny = cy + dy[i];\n                int nx = cx + dx[i];\n\n                if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                    if(board[ny][nx] == color){\n                        board[ny][nx] = 0;\n                        que.push(P(ny, nx));\n                    }\n                }\n            }\n        }\n\n        cout << \"NG\" << endl;\n        END:;\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef struct p{\n\tint x,y;\n}P;\nP q[500],sq[500],s,g,n;\nint qn,sqn;\nint map[105][105];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint i,j,w,h,m,c,d,x,y,a,b;\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0)break;\n\t\tscanf(\"%d%d\",&s.x,&s.y);\n\t\tscanf(\"%d%d\",&g.x,&g.y);\n\t\tscanf(\"%d\",&m);\n\t\tmemset(map,0,sizeof(map));\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tif(d==0)a=4,b=2;\n\t\t\telse a=2,b=4;\n\t\t\tfor(i=y;i<y+b;i++){\n\t\t\t\tfor(j=x;j<x+a;j++){\n\t\t\t\t\tmap[i][j]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//for(i=0;i<=10;i++)for(j=0;j<=10;j++)printf(\"%d%s\",map[i][j],(j==10)?\"\\n\":\"\");\n\t\t\n\t\tq[0]=s;qn=1;\n\t\tc=map[s.y][s.x];\n\t\tmap[s.y][s.x]=0;\n\t\tif(c==0){\n\t\t\tqn=0;\n\t\t\tgoto nex;\n\t\t}\n\t\twhile(qn!=0){\n\t\t\tsqn=0;\n\t\t\tfor(i=0;i<qn;i++){\n\t\t\t\t//printf(\"%d %d\\n\",q[i].x,q[i].y);\n\t\t\t\tif(q[i].x==g.x && q[i].y==g.y)goto nex;\n\t\t\t\tfor(j=0;j<4;j++){\n\t\t\t\t\tn=(P){q[i].x+dx[j],q[i].y+dy[j]};\n\t\t\t\t\tif(map[n.y][n.x]==c){\n\t\t\t\t\t\tsq[sqn++]=n;\n\t\t\t\t\t\tmap[n.y][n.x]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(q,sq,sizeof(P)*sqn);\n\t\t\tqn=sqn;\n\t\t}\n\t\tnex:\n\t\tprintf(\"%s\\n\",(qn==0)?\"NG\":\"OK\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={2,2,3,3,0,0,1,1,0,1,0,1};\n  int Y[]={0,1,0,1,0,1,0,1,2,2,3,3};\n  int XX[]={0,1,0,-1};\n  int YY[]={1,0,-1,0};\n  int h,w,sx,sy,gx,gy,n,a,b,c,d,t,r,i,j,k,nx,ny,x[10000],y[10000];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    char m[101][101]={0};\n    scanf(\"%d %d %d %d\",&sx,&sy,&gx,&gy);\n    scanf(\"%d\",&n);\n    while(n--){\n      scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n      for(i=b*4;i<8+b*4;i++)m[d+Y[i]][c+X[i]]=a;\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%d \",m[i][j]);\n      printf(\"\\n\");\n      }*/\n    if(m[sy][sx]!=m[gy][gx])printf(\"NG\\n\");\n    else {\n      x[t=0]=sx;\n      y[t]=sy;\n      m[sy][sx]=0;\n      for(r=1;r-t;t++){\n\tfor(k=0;k<4;k++){\n\t  nx=x[t]+XX[k];\n\t  ny=y[t]+YY[k];\n\t  if(nx<1||w<nx||ny<1||h<ny)continue;\n\t  if(m[gy][gx]==m[ny][nx]){\n\t    x[r]=nx;\n\t    y[r]=ny;\n\t    m[y[r]][x[r++]]=0;\n\t    if(nx==gx&&ny==gy)break;\n\t  }\n\t}\n\tif(nx==gx&&ny==gy)break;\n      }\n      /*for(i=0;i<=h;i++){\n\tfor(j=0;j<=w;j++)printf(\"%d \",m[i][j]);\n\tprintf(\"\\n\");\n\t}*/\n      if(r-t)printf(\"OK\\n\");\n      else   printf(\"NG\\n\");\n    }\n  }\n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\nint map[101][101],line[5]={0,1,0,-1,0},sign;\nvoid set(int x,int y,int d,int c){\n    int i;\n    if(d)\n        for(i=0;i<4;i++){\n            map[y+i][x]=c;\n            map[y+i][x+1]=c;\n        }\n    else\n        for(i=0;i<4;i++){\n            map[y][x+i]=c;\n            map[y+1][x+i]=c;\n        }\n}\nvoid search(int x,int y,int gx,int gy,int c){\n    int i;\n    if(map[y][x]!=c)\n        return;\n    if(x==gx&&y==gy){\n        sign=1;\n        return;\n    }\n    map[y][x]=0;\n    for(i=0;i<4;i++)\n        search(x+line[i+1],y+line[i],gx,gy,c);\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,i,c,d,x,y;\n    for(;memset(map,0,sizeof(map)),sign=0,scanf(\"%d %d\",&w,&h),h;){\n        scanf(\"%d %d %d %d %d\",&xs,&ys,&xg,&yg,&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            set(x,y,d,c);\n        }\n        if(map[ys][xs])\n            search(xs,ys,xg,yg,map[ys][xs]);\n        printf(\"%s\\n\",sign?\"OK\":\"NG\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define REP(i,m,n) for(i=m;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\nconst char Dx[]={1,0,-1,0},Dy[]={0,1,0,-1};\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i;\n  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;\n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \nrep(i,4)if(dfs(x+Dx[i],y+Dy[i]))return 1;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint w, h, xs, ys, xg, yg, board[105][105], start_color;\n\nint dfs(int x, int y){\n  int i;\n  if(x == xg && y == yg)return 1;\n  if(board[x][y] != start_color)return 0;\n  board[x][y] = 0;\n  int xi[] = {0, 1, 0, -1}, yi[] = {1, 0, -1, 0};\n  for(i = 0;i < 4;i++){\n    if(dfs(x + xi[i], y + yi[i]))\n      return 1;\n  }\n  return 0;\n}\n\nint main(){\n  int n, c, d, x, y, i, j;\n  while(1){\n    memset(board, 0, sizeof(board));\n    scanf(\"%d%d\", &w, &h);\n    if(w == 0 && h == 0)return 0;\n    for(i = 1;i <= h;i++)\n      for(j = 1;j <= w;j++)\n\tboard[i][j] = -1;\n    scanf(\"%d%d\", &xs, &ys);\n    scanf(\"%d%d\", &xg, &yg);\n    scanf(\"%d\", &n);\n    while(n--){\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n      if(d == 1){\n\tfor(i = x;i < x + 2;i++)\n\t  for(j = y;j < y + 4;j++)\n\t    board[i][j] = c;\n      }\n      if(d == 0){\n\tfor(i = x;i < x + 4;i++)\n\t  for(j = y;j < y + 2;j++)\n\t    board[i][j] = c;\n      }\n    }\n    start_color = board[xs][ys];\n    if(dfs(xs, ys))\n      puts(\"OK\");\n    else\n      puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,sx,sy,gx,gy,n,b[102][102],f[102][102],c,d,p[2],i,j,m[2]={2,4},mv[5]={1,0,-1,0,1};\n\nvoid df(int px,int py)\n{\n\tint i;\n\tf[py][px]=1;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(!f[py+mv[i]][px+mv[i+1]]&&b[py+mv[i]][px+mv[i+1]]==b[py][px])\n\t\t\tdf(px+mv[i+1],py+mv[i]);\n\t}\n\treturn;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(b,0,sizeof(b));\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\tfor(;n--;)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&p[0],&p[1]);\n\t\t\tfor(i=0;i<m[d];i++)\n\t\t\t\tfor(j=0;j<m[!d];j++)\n\t\t\t\t\tb[p[1]+i][p[0]+j]=c;\n\t\t}\n\t\tif(b[sy][sx]!=0)\n\t\t\tdf(sx,sy);\n\t\tprintf(\"%s\\n\",f[gy][gx]?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "w,h,xs,ys,xg,yg,c;\nm[102][102];\nC(x,y){\n\tif(m[x][y]==c){\n\t\tm[x][y]=-1;\n\t\tC(x-1,y);\n\t\tC(x+1,y);\n\t\tC(x,y-1);\n\t\tC(x,y+1);\n\t}\n}\nmain(){\n\tint n,d,x,y,i,j;\n\tfor(;scanf(\"%d%d%d%d%d%d%d\",&w,&h,&xs,&ys,&xg,&yg,&n),w;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<(d?2:4);i++)\n\t\t\t\tfor(j=0;j<(d?4:2);j++)\n\t\t\t\t\tm[x+i][y+j]=c;\n\t\t}\n\t\tc=m[xs][ys];\n\t\tC(xs,ys);\n\t\tputs(m[xg][yg]==-1?\"OK\":\"NG\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint QX[10202]={0};\nint QY[10202]={0};\nconst int X[4]={0,1,0,-1};\nconst int Y[4]={1,0,-1,0};\nint main(){\n  int w,h,sx,sy,gy,gx,c,d,x,y,n;\n  int i,q,r,a,j;\n  while(1){\n    scanf(\"%d %d\",&w,&h);\n    if(w==0&&h==0)break;\n    int m[102][102]={{0}};\n    scanf(\"%d %d\",&sx,&sy);\n    scanf(\"%d %d\",&gx,&gy);\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      m[y][x]=m[y+1][x]=m[y][x+1]=m[y+1][x+1]=c;\n      if(d==0)x+=2;\n      else    y+=2;\n      m[y][x]=m[y+1][x]=m[y][x+1]=m[y+1][x+1]=c;\n    }\n    a=0;\n    if(m[sy][sx]==m[gy][gx]){\n      q=0;\n      c=m[sy][sx];\n      QY[0]=sy;\n      QX[0]=sx;\n      r=1;\n      m[sy][sx]=0;\n      while(q!=r){\n\tfor(i=0;i<4;i++){\n\t  if(m[QY[q]+Y[i]][QX[q]+X[i]]==c){\n\t    if(QY[q]+Y[i]==gy&&QX[q]+X[i]==gx){\n\t      a=1;\n\t      break;\n\t    }\n\t    QY[r]=QY[q]+Y[i];\n\t    QX[r]=QX[q]+X[i];\n\t    m[QY[q]+Y[i]][QX[q]+X[i]]=0;\n\t    r++;\n\t  }\n\t}\n\tif(a)break;\n\tq++;\n      }\n    }\n    if(a)printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[102][102];\nint canwalk;\nint judgeOK;\nmaze(int nowy,int nowx,int gy,int gx){\n    map[nowy][nowx]=0;\n    /*\n    printf(\"%d %d %d\\n\",nowx,nowy,judgeOK);\n    */\n    if(judgeOK==1)\n        canwalk=6;\n    if(nowy==gy&&nowx==gx){\n        judgeOK=1;\n    }\n    if(map[nowy][nowx+1]==canwalk)\n        maze(nowy,nowx+1,gy,gx);\n    if(map[nowy+1][nowx]==canwalk)\n        maze(nowy+1,nowx,gy,gx);\n    if(map[nowy][nowx-1]==canwalk)\n        maze(nowy,nowx-1,gy,gx);\n    if(map[nowy-1][nowx]==canwalk)\n        maze(nowy-1,nowx,gy,gx);\n    return judgeOK;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    for(;;){\n        for(i=0;i<102;i++){\n            for(j=0;j<102;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        /*\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n        puts(\"\");\n        }\n        */\n            judgeOK=0;\n        if(map[ys][xs]==map[yg][xg]){\n            if(map[ys][xs]!=0){\n                canwalk=map[ys][xs];\n                judgeOK=maze(ys,xs,yg,xg);\n            }\n        }\n        if(judgeOK==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    int c2;    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = c;\n                    board[y + 1][x + j] = c;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = c;\n                    board[y + j][x + 1] = c;\n                }\n            }\n        }\n        \n        \n        c2 = board[ys][xs];\n        board[ys][xs] = -1;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == c2){\n                        if (board[i][j - 1] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                        else if (board[i][j + 1] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                        else if (board[i + 1][j] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                        else if (board[i - 1][j] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == -1){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "20 20 \n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\n  int BY[]={0,0,1,1,0,0,1,1,2,2,3,3};\n  int BX[]={2,3,2,3,0,1,0,1,0,1,0,1};\n  int w,h,x[10010],y[10010],gx,gy,by,bx,n,ny,nx,i,j,c,t,r,sc,d;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int m[110][110]={0};\n    scanf(\"%d %d %d %d %d\",&x[0],&y[0],&gx,&gy,&n);\n    while(n--){\n      scanf(\"%d %d %d %d\",&c,&d,&bx,&by);\n      for(i=0;i<8;i++)m[by+BY[d*4+i]][bx+BX[d*4+i]]=c;\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%d \",m[i][j]);\n      printf(\"\\n\");\n      }//*/\n    sc=m[y[0]][x[0]];\n    m[y[0]][x[0]]=t=0;\n    if(sc==0){\n      printf(\"NG\\n\");\n      continue;\n    }\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(m[ny][nx]-sc)continue;\n\tm[ny][nx]=0;\n\ty[r  ]=ny;\n\tx[r++]=nx;\n      }\n    }\n    if(m[gy][gx])printf(\"NG\\n\");\n    else         printf(\"OK\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,sx,sy,gx,gy,n,b[110][110],c,d,p[2],i,j,m[2]={2,4},mv[5]={0,1,0,-1,0},tag;\n\nint df(int px,int py)\n{\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(b,0,sizeof(b));\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\tfor(;n--;)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&p[0],&p[1]);\n\t\t\tfor(i=0;i<m[d];i++)\n\t\t\t\tfor(j=0;j<m[!d];j++)\n\t\t\t\t\tb[p[1]+i][p[0]+j]=c;\n\t\t}\n\t\ttag=b[sy][sx];\n\t\tprintf(\"%s\\n\",tag&&df(sx,sy)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nvoid dequeue(int *x, int *y);\n\n\nint main()\n{\n\tint width, height, xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tfor(i = 0; i < 101; i++) {\n\t\t\tfor(j = 0; j < 101; j++) {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t\tvisited[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < 10000; i++) {\n\t\t\tfor(j = 0; j < 2; j++) {\n\t\t\t\tqueue[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(!bfs(xstart, ystart)) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\n\tenqueue(xstart, ystart);\n\tdo {\n\t\tdequeue(&x, &y);\n\t\tif(x == xgoal && y == ygoal) return 0;\n\t\tif(!visited[x + 1][y] && board[x + 1][y] == expectedcolor) enqueue(x + 1, y);\n\t\tif(!visited[x][y + 1] && board[x][y + 1] == expectedcolor) enqueue(x, y + 1);\n\t\tif(!visited[x + 1][y + 1] && board[x + 1][y + 1] == expectedcolor) enqueue(x + 1, y + 1);\n\n\t} while(head != tail);\n\treturn -1;\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nvoid dequeue(int *x, int *y)\n{\n\t*x = queue[head][0];\n\t*y = queue[head][1];\n\thead++;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 100\n\nstatic\nconst int dx[ ] = { 1, 0, -1, 0 };\nstatic\nconst int dy[ ] = { 0, 1, 0, -1 };\nstatic\nint map[ N + 1 ][ N + 1 ];\nstatic\nint w, h;\nstatic\nint sc;\nstatic\nint xg, yg;\n\nint dfs (\n  int x,\n  int y\n  )\n{\n#if 0\n  int res;\n#endif\n\n  if ( x < 1 || x >= w || y < 1 || y >= h ) return ( 0 );  \n  if ( x == xg && y == yg )   return ( 1 );\n  if ( map[ x ][ y ] != sc )  return ( 0 );\n\n  map[ x ][ y ] = -1;\n#if 0\n  res = dfs ( x + 1, y )\n     || dfs ( x, y + 1 )\n     || dfs ( x - 1, y )\n     || dfs ( x, y - 1 );\n  map[ x ][ y ] = sc;\n\n  return ( res );\n#endif\n  return ( dfs ( x + 1, y )\n        || dfs ( x, y + 1 )\n        || dfs ( x - 1, y )\n        || dfs ( x, y - 1 ) );\n}\n\nint main (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    int xs, ys;\n    int n;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( w == 0 && h == 0 ) break;\n\n    scanf ( \"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &n );\n\n    while ( n-- )\n    {\n      int c, d, x, y;\n     \n      scanf ( \"%d%d%d%d\", &c, &d, &x, &y );\n      map[ x ][ y ] =\n      map[ x + 1 ][ y ] =\n      map[ x ][ y + 1 ] =\n      map[ x + 1 ][ y + 1 ] = c;\n      if ( d )\n      {\n        map[ x ][ y + 2 ] =\n        map[ x ][ y + 3 ] =\n        map[ x + 1 ][ y + 2 ] =\n        map[ x + 1 ][ y + 3 ] = c;\n      }\n      else\n      {\n        map[ x + 2 ][ y ] =\n        map[ x + 2 ][ y + 1 ] =\n        map[ x + 3 ][ y ] =\n        map[ x + 3 ][ y + 1 ] = c;\n      }\n    }\n\n    sc = map[ xs ][ ys ];\n    puts ( dfs ( xs, ys ) ? \"OK\" : \"NG\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = 1;\n                    board[y + 1][x + j] = 1;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = 1;\n                    board[y + j][x + 1] = 1;\n                }\n            }\n        }\n        \n        if (board[ys][xs] != 0){\n            printf(\"NG\\n\");\n            continue;\n        }\n        \n        \n        board[ys][xs] = 2;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == 1){\n                        if (board[i][j - 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        else if (board[i][j + 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        else if (board[i + 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        else if (board[i - 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == 2){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  int g=0;\n  while(1){\n    if(g==2)break;\n   \n\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<11;i++){\n      for(j=0;j<11;j++){\n\tprintf(\"%2d\",boad[i][j]);\n      }\n      printf(\"\\n\");\n    }\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    g++;\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<11;i++){\n      for(j=0;j<11;j++){\n\tprintf(\"%2d\",boad[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    c=boad[xs][ys];\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i+j)==1 && boad[x+i][y+j]!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[101][101];\nint w, h;\n\nint dfs(int xs, int ys, int c, int xg, int yg)\n{\n\tint dx, dy;\n\tif (xs == xg && ys == yg){\n\t\treturn (1);\n\t}\n\t\n\tmap[ys][xs] = -1;\n\t\n\tif (xs + 1 <= w && map[ys][xs + 1] == c){\n\t\tif (dfs(xs + 1, ys, c, xg, yg)){\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (ys + 1 <= h && map[ys + 1][xs] == c){\n\t\tif (dfs(xs, ys + 1, c, xg, yg)){\n\t\t\treturn (1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\t\n\tint i, j, k;\n\tint xs, ys, xg, yg;\n\tint n;\n\tint c, d, x, y;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (!(w + h)){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &xs, &ys);\n\t\tscanf(\"%d%d\", &xg, &yg);\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tif (d == 0){\n\t\t\t\tfor (j = 0; j < 2; j++){\n\t\t\t\t\tfor (k = 0; k < 4; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\t\tfor (k = 0; k < 2; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (dfs(xs, ys, map[ys][xs], xg, yg)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar map[20][13][13];\nint nya;\nvoid a_land(int y,int x){\n    map[nya][y][x]='0';\n    /*\n    printf(\"%d %d\\n\",x,y);\n    */\n    if(map[nya][y-1][x]=='1'&&y!=0){\n        a_land(y-1,x);\n    }\n    if(map[nya][y][x+1]=='1'&&x!=11){\n        a_land(y,x+1);\n    }\n    if(map[nya][y+1][x]=='1'&&y!=11){\n        a_land(y+1,x);\n    }\n    if(map[nya][y][x-1]=='1'&&x!=0){\n        a_land(y,x-1);\n    }\n}\nint main(void){\n    int i,j,n=0;\n    for(nya=0;;nya++){\n        for(i=0;i<12;i++){\n            if(scanf(\"%s\",map[nya][i]) == EOF) {\n                goto end;\n            }\n        }\n        for(i=0;i<12;i++){\n            for(j=0;j<12;j++){\n                if(map[nya][i][j]=='1'){\n                    map[nya][i][j]=='0';\n                    a_land(i,j);\n                    n++;\n                    /*\n                    printf(\"-----\\n\");\n                    */\n                }\n            }\n        }\n    printf(\"%d\\n\",n);\n    n=0;\n    getchar();\n    }\nend:\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  int g=0;\n  while(1){\n    if(g==2)break;\n   \n\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<11;i++){\n      for(j=0;j<11;j++){\n\tprintf(\"%2d\",boad[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    g++;\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[101][101];\nint maze(int nowx,int nowy,int gx,int gy,int canwalk,int goalsitazeyattazehuuuuuuu){\n    map[nowx][nowy]=0;\n    if(nowx==gx&&nowy==gy)\n        goalsitazeyattazehuuuuuuu=1;\n    if(goalsitazeyattazehuuuuuuu==1)\n        return (-1,-1,-1,-1,-1,1);\n    else{\n        if(map[nowx+1][nowy]==canwalk)\n            return maze(nowx+1,nowy,gx,gy,canwalk,0);\n        if(map[nowx][nowy+1]==canwalk)\n            return maze(nowx,nowy+1,gx,gy,canwalk,0);\n        if(map[nowx-1][nowy]==canwalk)\n            return maze(nowx-1,nowy,gx,gy,canwalk,0);\n        if(map[nowx][nowy-1]==canwalk)\n            return maze(nowx,nowy-1,gx,gy,canwalk,0);\n    }\n    return goalsitazeyattazehuuuuuuu;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    int can;\n    int judge;\n    for(;;){\n        judge=0;\n        for(i=0;i<101;i++){\n            for(j=0;j<101;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        /*\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n            puts(\"\");\n        }\n        */\n        can=map[xs][ys];\n        if(can!=0&&map[xg][yg]!=0)\n            judge=maze(xs,ys,xg,yg,can,0);\n        if(judge==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<ww;i++)\n      for(j=0;j<hh;j++)\n\tbd[px+i][py+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[px][py])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     for(j=-1;j<h0+1;j++)\n       paint(bx+i,by+j,col);\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n\n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      //show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      \n      paint(1,1,2);\n      show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 100\n\nstatic\nint map[ N + 1 ][ N + 1 ];\nstatic\nint w, h;\nstatic\nint sc;\nstatic\nint xg, yg;\n\nint dfs (\n  int x,\n  int y\n  )\n{\n#if 0\n  int res;\n#endif\n\n  if ( x < 0 || x >= w || y < 0 || y >= h ) return ( 0 );  \n  if ( x == xg && y == yg )   return ( 1 );\n  if ( map[ x ][ y ] != sc )  return ( 0 );\n\n  map[ x ][ y ] = -1;\n#if 0\n  res = dfs ( x + 1, y )\n     || dfs ( x, y + 1 )\n     || dfs ( x - 1, y )\n     || dfs ( x, y - 1 );\n  map[ x ][ y ] = sc;\n\n  return ( res );\n#endif\n  return ( dfs ( x + 1, y )\n        || dfs ( x, y + 1 )\n        || dfs ( x - 1, y )\n        || dfs ( x, y - 1 ) );\n}\n\nint main (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    int xs, ys;\n    int n;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( w == 0 && h == 0 ) break;\n\n    scanf ( \"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &n );\n\n    while ( n-- )\n    {\n      int c, d, x, y;\n     \n      scanf ( \"%d%d%d%d\", &c, &d, &x, &y );\n      map[ x ][ y ] =\n      map[ x + 1 ][ y ] =\n      map[ x ][ y + 1 ] =\n      map[ x + 1 ][ y + 1 ] = c;\n      if ( d )\n      {\n        map[ x ][ y + 2 ] =\n        map[ x ][ y + 3 ] =\n        map[ x + 1 ][ y + 2 ] =\n        map[ x + 1 ][ y + 3 ] = c;\n      }\n      else\n      {\n        map[ x + 2 ][ y ] =\n        map[ x + 2 ][ y + 1 ] =\n        map[ x + 3 ][ y ] =\n        map[ x + 3 ][ y + 1 ] = c;\n      }\n    }\n\n    sc = map[ xs ][ ys ];\n    puts ( dfs ( xs, ys ) ? \"OK\" : \"NG\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    c=boad[xs][ys];\n\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\n\tif(boad[i][j]!=-1)printf(\"%2d\",boad[i][j]);\n\telse printf(\"  \");\n      printf(\"\\n\");\n      }*/\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[x][y]==0 || c==0)  return;\n  if(map[x][y]!=c && map[x][y]!=9)  return;\n  if(map[x][y]==9){\n    map[x][y]=7;\n    return;\n  } \n  map[x][y]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[N][N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0){\n      break;\n    }\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<2;k++){\n          for(l=0;l<4;l++){\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n          }\n        }\n      }else if(d[i][j]==1){\n        for(k=0;k<4;k++){\n          for(l=0;l<2;l++){\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n          }\n        }\n      }\n    }\n    map[xg[i]][yg[i]]=9;\n    search(map,xs[i],ys[i],map[xs[i]][ys[i]]);\n    if(map[xg[i]][yg[i]]==7)        printf(\"OK\\n\");\n    else if(map[xg[i]][yg[i]]==9)   printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = c;\n                    board[y + 1][x + j] = c;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = c;\n                    board[y + j][x + 1] = c;\n                }\n            }\n        }\n        \n        if (board[ys][xs] != c){\n            printf(\"NG\\n\");\n            continue;\n        }\n        \n        board[ys][xs] = -1;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == c){\n                        if (board[i][j - 1] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                        else if (board[i][j + 1] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                        else if (board[i + 1][j] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                        else if (board[i - 1][j] == -1){\n                            board[i][j] = -1;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == -1){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 100\n\nstatic\nint map[ N + 1 ][ N + 1 ];\nstatic\nint w, h;\nstatic\nint sc;\nstatic\nint xg, yg;\n\nint dfs (\n  int x,\n  int y\n  )\n{\n#if 0\n  int res;\n#endif\n\n  if ( x < 1 || x > w || y < 1 || y > h ) return ( 0 );  \n  if ( map[ x ][ y ] != sc )  return ( 0 );\n  if ( x == xg && y == yg )   return ( 1 );\n\n  map[ x ][ y ] = -1;\n#if 0\n  res = dfs ( x + 1, y )\n     || dfs ( x, y + 1 )\n     || dfs ( x - 1, y )\n     || dfs ( x, y - 1 );\n  map[ x ][ y ] = sc;\n\n  return ( res );\n#endif\n  return ( dfs ( x + 1, y )\n        || dfs ( x, y + 1 )\n        || dfs ( x - 1, y )\n        || dfs ( x, y - 1 ) );\n}\n\nint main (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    int xs, ys;\n    int n;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( w == 0 && h == 0 ) break;\n\n    scanf ( \"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &n );\n    memset ( map, 0, sizeof ( map ) );\n\n    while ( n-- )\n    {\n      int c, d, x, y;\n\n      scanf ( \"%d%d%d%d\", &c, &d, &x, &y );\n      map[ x ][ y ] =\n      map[ x ][ y + 1 ] =\n      map[ x + 1 ][ y ] =\n      map[ x + 1 ][ y + 1 ] = c;\n      if ( d )\n      {\n        map[ x ][ y + 2 ] =\n        map[ x ][ y + 3 ] =\n        map[ x + 1 ][ y + 2 ] =\n        map[ x + 1 ][ y + 3 ] = c;\n      }\n      else\n      {\n        map[ x + 2 ][ y ] =\n        map[ x + 2 ][ y + 1 ] =\n        map[ x + 3 ][ y ] =\n        map[ x + 3 ][ y + 1 ] = c;\n      }\n    }\n\n    sc = map[ xs ][ ys ];\n    puts ( dfs ( xs, ys ) ? \"OK\" : \"NG\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint x_max,y_max;\nchar map[102][102];\nchar visited[102][102];\n\nvoid tadoru(int x,int y,char color) {\n\tif(map[y][x]!=color || visited[y][x])return;\n\tvisited[y][x]=1;\n\ttadoru(x-1,y,color);\n\ttadoru(x+1,y,color);\n\ttadoru(x,y-1,color);\n\ttadoru(x,y+1,color);\n}\n\nint main(void) {\n\tint start_x,start_y;\n\tint goal_x,goal_y;\n\tint block_num;\n\tint block_color,block_muki;\n\tint block_x,block_y;\n\tint i;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&x_max,&y_max);\n\t\tif(x_max==0 && y_max==0)break;\n\t\tscanf(\"%d%d\",&start_x,&start_y);\n\t\tscanf(\"%d%d\",&goal_x,&goal_y);\n\t\tscanf(\"%d\",&block_num);\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(i=0;i<block_num;i++) {\n\t\t\tscanf(\"%d%d%d%d\",\n\t\t\t\t&block_color,&block_muki,&block_x,&block_y);\n\t\t\tmap[block_y  ][block_x  ]=block_color;\n\t\t\tmap[block_y+1][block_x  ]=block_color;\n\t\t\tmap[block_y  ][block_x+1]=block_color;\n\t\t\tmap[block_y+1][block_x+1]=block_color;\n\t\t\tif(block_muki) {\n\t\t\t\tmap[block_y+2][block_x  ]=block_color;\n\t\t\t\tmap[block_y+3][block_x  ]=block_color;\n\t\t\t\tmap[block_y+2][block_x+1]=block_color;\n\t\t\t\tmap[block_y+3][block_x+1]=block_color;\n\t\t\t} else {\n\t\t\t\tmap[block_y  ][block_x+2]=block_color;\n\t\t\t\tmap[block_y+1][block_x+2]=block_color;\n\t\t\t\tmap[block_y  ][block_x+3]=block_color;\n\t\t\t\tmap[block_y+1][block_x+3]=block_color;\n\t\t\t}\n\t\t}\n\t\ttadoru(start_x,start_y,map[start_y][start_x]);\n\t\tputs(visited[goal_y][goal_x]?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    c=boad[xs][ys];\n\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\n\tprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i+j)==1 && boad[x+i][y+j]!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[x][y]==0 || c==0)  return;\n  if(map[x][y]==9){\n    map[x][y]=7;\n    return;\n  } \n  if(map[x][y]!=c)  return;\n  map[x][y]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[N][N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0)  break;\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<2;k++)\n          for(l=0;l<4;l++)\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n      }else if(d[i][j]==1){\n        for(k=0;k<4;k++)\n          for(l=0;l<2;l++)\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n      }\n    }\n    map[xg[i]][yg[i]]=9;\n    search(map,xs[i],ys[i],map[xs[i]][ys[i]]);\n    if(map[xg[i]][yg[i]]==7)  printf(\"OK\\n\");\n    else                      printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "b[101][101];xg,yg;\nr(x,y,c){if(c!=b[x][y])return 0;if(x==xg&&y==yg)return 1;b[x][y]=0;return r(x+1,y,c)||r(x,y+1,c)||r(x-1,y,c)||r(x,y-1,c)?1:0;}\nmain(xs,ys,n,c,d,x,y){\nfor(;scanf(\"%d%d\",&x,&y),x;puts(b[xs][ys]&&b[xg][yg]&&b[xs][ys]==b[xg][yg]&&r(xs,ys,b[xs][ys])?\"OK\":\"NG\"))\nfor(scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);n;n--)\nif(scanf(\"%d%d%d%d\",&c,&d,&x,&y),d)b[x][y]=b[x+1][y]=b[x][y+1]=b[x+1][y+1]=b[x][y+2]=b[x+1][y+2]=b[x][y+3]=b[x+1][y+3]=c;else b[x][y]=b[x+1][y]=b[x+2][y]=b[x+3][y]=b[x][y+1]=b[x+1][y+1]=b[x+2][y+1]=b[x+3][y+1]=c;\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  int g=0;\n  while(1){\n    if(g==2)break;\n   \n\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<11;i++){\n      for(j=0;j<11;j++){\n\tprintf(\"%2d\",boad[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    g++;\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i+j)==1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "20 20 \n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[y][x]==0 || c==0){\n    return;\n  }\n  if(map[y][x]!=c && map[y][x]!=9){\n    return;\n  }\n  if(map[y][x]==9){\n    map[y][x]=7;\n    return;\n  } \n  map[y][x]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[N][N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0){\n      break;\n    }\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    printf(\"%d %d\\n\",w[i],h[i]);\n    printf(\"%d %d\\n\",xs[i],ys[i]);\n    printf(\"%d %d\\n\",xg[i],yg[i]);\n    printf(\"%d\\n\",n[i]);\n    for(j=0;j<n[i];j++){\n      printf(\"%d %d %d %d\\n\",c[i][j],d[i][j],x[i][j],y[i][j]);\n    }\n  }\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<2;k++){\n          for(l=0;l<4;l++){\n            map[y[i][j]+k][x[i][j]+l]=c[i][j];\n          }\n        }\n      }else if(d[i][j]==1){\n        for(k=0;k<4;k++){\n          for(l=0;l<2;l++){\n            map[y[i][j]+k][x[i][j]+l]=c[i][j];\n          }\n        }\n      }\n    }\n    printf(\"s:%d\\n\",map[ys[i]][xs[i]]);\n    printf(\"g:%d\\n\",map[yg[i]][xg[i]]);\n    map[xg[i]][yg[i]]=9;\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        printf(\"%d\",map[j][k]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    search(map,xs[i],ys[i],map[ys[i]][xs[i]]);\n    if(map[yg[i]][xg[i]]==7){\n      printf(\"OK\\n\");\n    }else if(map[yg[i]][xg[i]]==9){\n      printf(\"NG\\n\");\n    }\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        printf(\"%d\",map[j][k]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,sx,sy,gx,gy,n,b[102][102],f[102][102],c,d,p[2],i,j,m[2]={2,4},mv[5]={1,0,-1,0,1};\n\nint df(int px,int py)\n{\n\tint i,t=0;\n\tf[py][px]=1;\n\tif(px==gx&&py==gy)\n\t\treturn 1;\n\telse\n\t\tfor(i=0;i<4;i++)\n\t\t{\n\t\t\tif(b[py+mv[i]][px+mv[i+1]]==b[py][px]&&!f[py+mv[i]][px+mv[i+1]])\n\t\t\t\tt+=df(px+mv[i+1],py+mv[i]);\n\t\t}\n\treturn t;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(b,0,sizeof(b));\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\tfor(;n--;)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&p[0],&p[1]);\n\t\t\tfor(i=0;i<m[d];i++)\n\t\t\t\tfor(j=0;j<m[!d];j++)\n\t\t\t\t\tb[p[1]+i][p[0]+j]=c;\n\t\t}\n\t\tprintf(\"%s\\n\",b[sx][sy]>0&&df(sx,sy)?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "b[101][101];xg,yg;r(x,y,c){if(c!=b[x][y])return 0;if(x==xg&&y==yg)return 1;b[x][y]=0;return r(x+1,y,c)||r(x,y+1,c)||r(x-1,y,c)||r(x,y-1,c)?1:0;}main(xs,ys,n,c,d,x,y){for(;scanf(\"%d%d\",&x,&y),x;puts(b[xs][ys]&&b[xg][yg]&&b[xs][ys]==b[xg][yg]&&r(xs,ys,b[xs][ys])?\"OK\":\"NG\"))for(scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);n;n--)if(scanf(\"%d%d%d%d\",&c,&d,&x,&y),d)b[x][y]=b[x+1][y]=b[x][y+1]=b[x+1][y+1]=b[x][y+2]=b[x+1][y+2]=b[x][y+3]=b[x+1][y+3]=c;else b[x][y]=b[x+1][y]=b[x+2][y]=b[x+3][y]=b[x][y+1]=b[x+1][y+1]=b[x+2][y+1]=b[x+3][y+1]=c;return 0;}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg < bx+w0 && \n     yg >= by && yg < by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      //show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = 1;\n                    board[y + 1][x + j] = 1;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = 1;\n                    board[y + j][x + 1] = 1;\n                }\n            }\n        }\n        \n        board[ys][ys] = 2;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == 1){\n                        if (board[i][j - 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i - 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == 2){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 100\n\nstatic\nint map[ N + 1 ][ N + 1 ];\nstatic\nint w, h;\nstatic\nint sc;\nstatic\nint xg, yg;\n\nint dfs (\n  int x,\n  int y\n  )\n{\n#if 0\n  int res;\n#endif\n\n  if ( x < 1 || x >= w || y < 1 || y >= h ) return ( 0 );  \n  if ( map[ x ][ y ] != sc )  return ( 0 );\n  if ( x == xg && y == yg )   return ( 1 );\n\n  map[ x ][ y ] = -1;\n#if 0\n  res = dfs ( x + 1, y )\n     || dfs ( x, y + 1 )\n     || dfs ( x - 1, y )\n     || dfs ( x, y - 1 );\n  map[ x ][ y ] = sc;\n\n  return ( res );\n#endif\n  return ( dfs ( x + 1, y )\n        || dfs ( x, y + 1 )\n        || dfs ( x - 1, y )\n        || dfs ( x, y - 1 ) );\n}\n\nint main (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    int xs, ys;\n    int n;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( w == 0 && h == 0 ) break;\n\n    scanf ( \"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &n );\n\n    while ( n-- )\n    {\n      int c, d, x, y;\n     \n      scanf ( \"%d%d%d%d\", &c, &d, &x, &y );\n      map[ x ][ y ] =\n      map[ x + 1 ][ y ] =\n      map[ x ][ y + 1 ] =\n      map[ x + 1 ][ y + 1 ] = c;\n      if ( d )\n      {\n        map[ x ][ y + 2 ] =\n        map[ x ][ y + 3 ] =\n        map[ x + 1 ][ y + 2 ] =\n        map[ x + 1 ][ y + 3 ] = c;\n      }\n      else\n      {\n        map[ x + 2 ][ y ] =\n        map[ x + 2 ][ y + 1 ] =\n        map[ x + 3 ][ y ] =\n        map[ x + 3 ][ y + 1 ] = c;\n      }\n    }\n\n    sc = map[ xs ][ ys ];\n    puts ( dfs ( xs, ys ) ? \"OK\" : \"NG\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint *p;\nint *r;\nint w,h,xg,yg;\nvoid place(int c,int d,int x,int y)\n{\n  *(p+((w+1)*y+x)) = c;\n  *(p+((w+1)*y+x+1)) = c;\n  *(p+((w+1)*(y+1)+x)) = c;\n  *(p+((w+1)*(y+1)+x+1)) = c;\n  if(d==0){\n    *(p+((w+1)*y+x+2)) = c;\n    *(p+((w+1)*y+x+3)) = c;\n    *(p+((w+1)*(y+1)+x+2)) = c;\n    *(p+((w+1)*(y+1)+x+3)) = c;\n  }else{\n    *(p+((w+1)*(y+2)+x)) = c;\n    *(p+((w+1)*(y+2)+x+1)) = c;\n    *(p+((w+1)*(y+3)+x)) = c;\n    *(p+((w+1)*(y+3)+x+1)) = c;\n  }\n}\nint search(int x,int y)\n{\n  int a=0;\n  int c= *(p+((w+1)*y+x));\n  if(x==xg && y==yg) return 1;\n  *(r+((w+1)*y+x)) = 1;\n  if (*(p+((w+1)*y+x-1)) == c && *(r+((w+1)*y+x-1)) == 0)\n    a += search(x-1,y);\n  if (*(p+((w+1)*y+x+1)) == c && *(r+((w+1)*y+x+1)) == 0)\n    a += search(x+1,y);\n  if (*(p+((w+1)*(y-1)+x)) == c && *(r+((w+1)*(y-1)+x)) == 0)\n    a += search(x,y-1);\n  if (*(p+((w+1)*(y+1)+x)) == c && *(r+((w+1)*(y+1)+x)) == 0)\n    a += search(x,y+1);\n  return a;\n}\nvoid show()\n{\n  int i,j;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      printf(\"%d\",*(p+((w+1)*i+j)));\n    }\n    printf(\"\\n\");\n  }\n}\nint main()\n{\n  int xs,ys,n,c,d,x,y;\n  for(;;){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    p = (int*)(malloc(sizeof(int)*(w+1)*(h+1)));\n    memset(p,0,sizeof(int)*(w+1)*(h+1));\n    r = (int*)(malloc(sizeof(int)*(w+1)*(h+1)));\n    memset(r,0,sizeof(int)*(w+1)*(h+1));\n    scanf(\"%d%d\",&xs,&ys);\n    scanf(\"%d%d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    while(n>0){\n      scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n      place(c,d,x,y);\n      n--;\n    }\n    //show();\n    if(search(xs,ys)) printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    free(p);\n    free(r);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && x+i!=-1 && y+j!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n \nint w, h, xs, ys, xg, yg, board[105][105], start_color;\n \nint dfs(int x, int y){\n  int i;\n  if(board[x][y] != start_color)return 0;\n  if(x == xg && y == yg)return 1;\n  board[x][y] = 0;\n  int xi[] = {0, 1, 0, -1}, yi[] = {1, 0, -1, 0};\n  for(i = 0;i < 4;i++)\n    if(dfs(x + xi[i], y + yi[i]))\n      return 1;\n \n  return 0;\n}\n \nint main(){\n  int n, c, d, x, y, i, j;\n  while(1){\n    memset(board, 0, sizeof(board));\n    scanf(\"%d%d\", &w, &h);\n    if(w == 0 && h == 0)return 0;\n    scanf(\"%d%d\", &xs, &ys);\n    scanf(\"%d%d\", &xg, &yg);\n    scanf(\"%d\", &n);\n    while(n--){\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n      if(d == 1){\n    for(i = x;i < x + 2;i++)\n      for(j = y;j < y + 4;j++)\n        board[i][j] = c;\n      }\n      if(d == 0){\n    for(i = x;i < x + 4;i++)\n      for(j = y;j < y + 2;j++)\n        board[i][j] = c;\n      }\n    }\n    start_color = board[xs][ys];\n    if(start_color != 0 && dfs(xs, ys))\n      puts(\"OK\");\n    else\n      puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define REP(i,m,n) for(i=m;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nint Dx[]={1,0,-1,0},Dy[]={0,1,0,-1};\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n    }\n    c=boad[ys][xs];\n\n    if(c && dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n\n  }\n  return 0;\n}\n  \nint dfs(int x,int y)\n{\n  int i;\n  if(x<=0||x>w||y<=0||y>h||boad[y][x]!=c)return 0;\n  if(x==xg&&y==yg)return 1;\n  boad[y][x]=0;\n  rep(i,4)if(dfs(x+Dx[i],y+Dy[i]))return 1;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  int g=0;\n  while(1){\n    if(g==2)break;\n   \n\n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<11;i++){\n      for(j=0;j<11;j++){\n\tprintf(\"%2d\",boad[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    c=boad[xs][ys];\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    g++;\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i+j)==1 && boad[x+i][y+j]!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint w, h, xs, ys, xg, yg, board[105][105], start_color;\n\nint dfs(int x, int y){\n  int i;\n  if(x == xg && y == yg)return 1;\n  if(board[x][y] != start_color)return 0;\n  board[x][y] = 0;\n  int xi[] = {0, 1, 0, -1}, yi[] = {1, 0, -1, 0};\n  for(i = 0;i < 4;i++){\n    if(dfs(x + xi[i], y + yi[i]))\n      return 1;\n  }\n  return 0;\n}\n\nint main(){\n  int n, c, d, x, y, i, j;\n  while(1){\n    memset(board, -1, sizeof(board));\n    scanf(\"%d%d\", &w, &h);\n    if(w == 0 && h == 0)return 0;\n    scanf(\"%d%d\", &xs, &ys);\n    scanf(\"%d%d\", &xg, &yg);\n    scanf(\"%d\", &n);\n    while(n--){\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n      if(d == 1){\n\tfor(i = x;i < x + 2;i++)\n\t  for(j = y;j < y + 4;j++)\n\t    board[i][j] = c;\n      }\n      if(d == 0){\n\tfor(i = x;i < x + 4;i++)\n\t  for(j = y;j < y + 2;j++)\n\t    board[i][j] = c;\n      }\n    }\n    start_color = board[xs][ys];\n    if(start_color != -1 && dfs(xs, ys))\n      puts(\"OK\");\n    else\n      puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[102][102];\nint canwalk;\nint judgeOK;\nmaze(int nowy,int nowx,int gy,int gx){\n    map[nowy][nowx]=0;\n\n    printf(\"%d %d %d\\n\",nowx,nowy,judgeOK);\n    if(nowy==gy&&nowx==gx){\n        judgeOK=1;\n    }\n    if(map[nowy][nowx+1]==canwalk)\n        maze(nowy,nowx+1,gy,gx);\n    if(map[nowy+1][nowx]==canwalk)\n        maze(nowy+1,nowx,gy,gx);\n    if(map[nowy][nowx-1]==canwalk)\n        maze(nowy,nowx-1,gy,gx);\n    if(map[nowy-1][nowx]==canwalk)\n        maze(nowy-1,nowx,gy,gx);\n    return judgeOK;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    int judge;\n    for(;;){\n        for(i=0;i<102;i++){\n            for(j=0;j<102;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n        puts(\"\");\n        }\n\n            judge=0;\n        if(map[ys][xs]==map[yg][xg]){\n            if(map[ys][xs]!=0){\n                canwalk=map[ys][xs];\n                judge=maze(ys,xs,yg,xg);\n            }\n        }\n        if(judge==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nvoid dequeue(int *x, int *y);\n\n\nint main()\n{\n\tint width, height, xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(!bfs(xstart, ystart)) {\n\t\t\tputs(\"OK\");\n\t\t} else {\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\t\n\tenqueue(xstart, ystart);\n\tdo {\n\t\tdequeue(&x, &y);\n\t\tif(!visited[x + 1][y] && board[x + 1][y] == expectedcolor) enqueue(x + 1, y);\n\t\tif(!visited[x][y + 1] && board[x][y + 1] == expectedcolor) enqueue(x, y + 1);\n\t\tif(!visited[x + 1][y + 1] && board[x + 1][y + 1] == expectedcolor) enqueue(x + 1, y + 1);\n\n\t} while(head != tail);\n\tif(x == xgoal && y == ygoal) return 0;\n\telse return -1;\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nvoid dequeue(int *x, int *y)\n{\n\t*x = queue[head][0];\n\t*y = queue[head][1];\n\thead++;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[101][101];\nint maze(int nowx,int nowy,int gx,int gy,int canwalk,int goalsitazeyattazehuuuuuuu){\n    map[nowx][nowy]=0;\n    if(goalsitazeyattazehuuuuuuu=1)\n        return (-1,-1,-1,-1,-1,1);\n    else{\n        if(map[nowx+1][nowy]==canwalk)\n            return maze(nowx+1,nowy,gx,gy,canwalk,0);\n        if(map[nowx][nowy+1]==canwalk)\n            return maze(nowx,nowy+1,gx,gy,canwalk,0);\n        if(map[nowx-1][nowy]==canwalk)\n            return maze(nowx-1,nowy,gx,gy,canwalk,0);\n        if(map[nowx][nowy-1]==canwalk)\n            return maze(nowx,nowy-1,gx,gy,canwalk,0);\n    }\n    return goalsitazeyattazehuuuuuuu;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    int can;\n    int judge;\n    for(;;){\n        judge=0;\n        for(i=0;i<101;i++){\n            for(j=0;j<101;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n            puts(\"\");\n        }\n        can=map[xs][ys];\n        if(can!=0&&map[xg][yg]!=0)\n            judge=maze(xs,ys,xg,yg,can,0);\n        if(judge==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint w, h, xs, ys, xg, yg, board[105][105], start_color;\n\nint dfs(int x, int y){\n  int i;\n  if(board[x][y] != start_color)return 0;\n  if(x == xg && y == yg)return 1;\n  board[x][y] = 0;\n  int xi[] = {0, 1, 0, -1}, yi[] = {1, 0, -1, 0};\n  for(i = 0;i < 4;i++)\n    if(dfs(x + xi[i], y + yi[i]))\n      return 1;\n\n  return 0;\n}\n\nint main(){\n  int n, c, d, x, y, i, j;\n  while(1){\n    memset(board, 0, sizeof(board));\n    scanf(\"%d%d\", &w, &h);\n    if(w == 0 && h == 0)return 0;\n    scanf(\"%d%d\", &xs, &ys);\n    scanf(\"%d%d\", &xg, &yg);\n    scanf(\"%d\", &n);\n    while(n--){\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n      if(d == 1){\n\tfor(i = x;i < x + 2;i++)\n\t  for(j = y;j < y + 4;j++)\n\t    board[i][j] = c;\n      }\n      if(d == 0){\n\tfor(i = x;i < x + 4;i++)\n\t  for(j = y;j < y + 2;j++)\n\t    board[i][j] = c;\n      }\n    }\n    start_color = board[xs][ys];\n    if(start_color != 0 && dfs(xs, ys))\n      puts(\"OK\");\n    else\n      puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "w,h,xs,ys,xg,yg,c;\nm[102][102];\nC(x,y){\n\tif(m[x][y]==c){\n\t\tm[x][y]=-1;\n\t\tx>1&&C(x-1,y);\n\t\tx<w&&C(x+1,y);\n\t\ty>1&&C(x,y-1);\n\t\ty<h&&C(x,y+1);\n\t}\n}\nmain(){\n\tint n,d,x,y,i,j;\n\tfor(;scanf(\"%d%d%d%d%d%d%d\",&w,&h,&xs,&ys,&xg,&yg,&n),w;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<(d?2:4);i++)\n\t\t\t\tfor(j=0;j<(d?4:2);j++)\n\t\t\t\t\tm[x+i][y+j]=c;\n\t\t}\n\t\tc=m[xs][ys];\n\t\tC(xs,ys);\n\t\tputs(m[xg][yg]==-1?\"OK\":\"NG\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct blkinfo_t {\n  int c;\n  int d;\n  int x;\n  int y;\n};\n\nint **board;\nint **flag;\n\nint w, h;\nint xg, yg;\n\nvoid createmaze(int n, struct blkinfo_t *blks) {\n  int i;\n  int curx;\n  int cury;\n\n  for(i = 0; i < n; i++) {\n    curx = blks[n].x;\n    cury = blks[n].y;\n\n    if(blks[n].d == 0) {\n      board[cury][curx] = blks[n].c;\n      board[cury][curx+1] = blks[n].c;\n      board[cury][curx+2] = blks[n].c;\n      board[cury][curx+3] = blks[n].c;\n      board[cury+1][curx] = blks[n].c;\n      board[cury+1][curx+1] = blks[n].c;\n      board[cury+1][curx+2] = blks[n].c;\n      board[cury+1][curx+3] = blks[n].c;\n    }\n    else {\n      board[cury][curx] = blks[n].c;\n      board[cury][curx+1] = blks[n].c;\n      board[cury+1][curx] = blks[n].c;\n      board[cury+1][curx+1] = blks[n].c;\n      board[cury+2][curx] = blks[n].c;\n      board[cury+2][curx+1] = blks[n].c;\n      board[cury+3][curx] = blks[n].c;\n      board[cury+3][curx+1] = blks[n].c;\n    }\n  }\n\n  return;\n}\n\nint search(x, y, c) {\n  int result[4] = {0, 0, 0, 0};\n\n  if(flag[y][x] == 1)\n    return -1;\n  if(board[y][x] != c)\n    return -1;\n  if((x == xg) && (y == yg))\n    return 1;\n\n  flag[y][x] = 1;\n\n  if(x+1 > w) {\n    result[0] = search(x+1, y, c);\n  }\n  if(x-1 < 1) {\n    result[1] = search(x-1, y, c);\n  }\n  if(y+1 > h) {\n    result[2] = search(x, y+1, c);\n  }\n  if(y-1 < 1) {\n    result[3] = search(x, y-1, c);\n  }\n\n  if((result[0] == 1) ||\n     (result[1] == 1) ||\n     (result[2] == 1) ||\n     (result[3] == 1))\n    return 1;\n  else\n    return -1;\n}\n\nint main() {\n  int i;\n\n  int xs, ys;\n  int n;\n  int c;\n\n  struct blkinfo_t *blks;\n\n\n  scanf(\"%d %d\", &w , &h);\n  scanf(\"%d %d\", &xs, &ys);\n  scanf(\"%d %d\", &xg, &yg);\n  scanf(\"%d\", &n);\n\n  blks = calloc(n, sizeof(struct blkinfo_t));\n\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d %d %d\", &blks[n].c, &blks[n].d, &blks[n].x, &blks[n].y);\n  }\n\n  board = calloc(w*h, sizeof(int));\n  flag  = calloc(w*h, sizeof(int));\n\n  createmaze(n, blks);\n  c = board[ys][xs];\n\n  if(search(xs, ys, c) == 1)\n    printf(\"OK\");\n  else\n    printf(\"NG\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "w,h,s,t,f,g;m[123][102];c,d,x,y,i,j;C(x,y){m[x][y]-c||(m[x][y]=-1,x>1&&C(x-1,y),x<w&&C(x+1,y),y>1&&C(x,y-1),y<h&&C(x,y+1));}main(n){for(;scanf(\"%d%d%d%d%d%d%d\",&w,&h,&s,&t,&f,&g,&n),w;c=m[s][t],C(s,t),puts(~m[f][g]?\"NG\":\"OK\"))for(memset(m,0,5e4);n--;)for(scanf(\"%d%d%d%d\",&c,&d,&x,&y),i=4-d*2;i--;)for(j=2+d*2;j--;)m[x+i][y+j]=c;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[101][101];\nint maze(int nowx,int nowy,int gx,int gy,int canwalk,int goalsitazeyattazehuuuuuuu){\n    map[nowx][nowy]=0;\n    if(goalsitazeyattazehuuuuuuu=1)\n        return (-1,-1,-1,-1,-1,1);\n    else{\n        if(map[nowx+1][nowy]==canwalk)\n            return maze(nowx+1,nowy,gx,gy,canwalk,0);\n        if(map[nowx][nowy+1]==canwalk)\n            return maze(nowx,nowy+1,gx,gy,canwalk,0);\n        if(map[nowx-1][nowy]==canwalk)\n            return maze(nowx-1,nowy,gx,gy,canwalk,0);\n        if(map[nowx][nowy-1]==canwalk)\n            return maze(nowx,nowy-1,gx,gy,canwalk,0);\n    }\n    return goalsitazeyattazehuuuuuuu;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    int can;\n    int judge;\n    for(;;){\n        judge=0;\n        for(i=0;i<101;i++){\n            for(j=0;j<101;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        /*\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n            puts(\"\");\n        }\n        */\n        can=map[xs][ys];\n        if(can!=0&&map[xg][yg]!=0)\n            judge=maze(xs,ys,xg,yg,can,0);\n        if(judge==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,sx,sy,gx,gy,n,b[110][110],c,d,p[2],i,j,m[2]={2,4},mv[5]={0,1,0,-1,0},tag;\n\nint df(int px,int py)\n{\n\tint i;\n\tif(px==gx&&py==gy)\n\t\treturn 1;\n\telse\n\t{\n\t\tb[py][px]=0;\n\t\tfor(i=0;i<4;i++)\n\t\t\tif(b[py+mv[i]][px+mv[i+1]]==tag&&df(px+mv[i+1],py+mv[i]))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(b,0,sizeof(b));\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\tfor(;n--;)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&p[0],&p[1]);\n\t\t\tfor(i=0;i<m[d];i++)\n\t\t\t\tfor(j=0;j<m[!d];j++)\n\t\t\t\t\tb[p[1]+i][p[0]+j]=c;\n\t\t}\n\t\ttag=b[sy][sx];\n\t\tprintf(\"%s\\n\",tag&&df(sx,sy)?\"OK\":\"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    c=boad[xs][ys];\n\n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\n\tif(boad[i][j]!=-1)printf(\"%2d\",boad[i][j]);\n\telse printf(\"  \");\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nvoid haichi(void);\nint Block(int,int);\nint c,d,x,y,xg,yg,w,h,M,Flag;\nint MAP[101][101],MF[101][101];\nint main(void)\n{\n\tint xs,ys,n;\n\twhile(1){\n\t\tFlag=0;\n\t\tmemset(MAP,0,sizeof(MAP));\n\t\tmemset(MF,0,sizeof(MF));\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tscanf(\"%d %d %d %d\",&xs,&ys,&xg,&yg);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d %d %d %d\",&c,&d,&x,&y);\n\t\t\thaichi();\n\t\t}\n\t\t/*for(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tprintf(\"%d\",MAP[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tM = MAP[ys][xs];//\n\t\tif(Block(xs,ys))\n\t\t\tprintf(\"OK\\n\");\n\t\telse\n\t\t\tprintf(\"NG\\n\");\n\t}\n\treturn 0;\n}\n\nvoid haichi(void)\n{\n\tif(d==0){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;MAP[y][x+2]=c;MAP[y][x+3]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;MAP[y+1][x+2]=c;MAP[y+1][x+3]=c;\n\t}\n\telse if(d==1){\n\t\tMAP[y][x]=c;MAP[y][x+1]=c;\n\t\tMAP[y+1][x]=c;MAP[y+1][x+1]=c;\n\t\tMAP[y+2][x]=c;MAP[y+2][x+1]=c;\n\t\tMAP[y+3][x]=c;MAP[y+3][x+1]=c;\n\t}\n}\n\nint Block(int X,int Y)\n{\n\t\n\t//printf(\"%d\",M);\n\tprintf(\"%d %d\\n\",X,Y);\n\tif(X == xg && Y == yg)\n\t\treturn 1;\n\tif(MAP[Y][X] != M || MF[Y][X] == 1 || X < 1 || Y < 1 || X > w || Y > h) return 0;\n\tMF[Y][X] = 1;\n\treturn Block(X,Y-1) || Block(X,Y+1) || Block(X-1,Y) || Block(X+1,Y);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nvoid dequeue(int *x, int *y);\n\n\nint main()\n{\n\tint width, height, xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(!bfs(xstart, ystart)) {\n\t\t\tputs(\"OK\");\n\t\t} else {\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\t\n\tenqueue(xstart, ystart);\n\tdo {\n\t\tdequeue(&x, &y);\n\t\tif(!visited[x + 1][y] && board[x + 1][y] == expectedcolor) enqueue(x + 1, y);\n\t\tif(!visited[x][y + 1] && board[x][y + 1] == expectedcolor) enqueue(x, y + 1);\n\t\tif(!visited[x + 1][y + 1] && board[x + 1][y + 1] == expectedcolor) enqueue(x + 1, y + 1);\n\n\t} while(head != tail);\n\tif(x == xgoal && y == ygoal) return 0;\n\telse return -1;\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nvoid dequeue(int *x, int *y)\n{\n\t*x = queue[head][0];\n\t*y = queue[head][1];\n\thead++;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint w, h, xs, ys, xg, yg, board[105][105], start_color;\n\nint dfs(int x, int y){\n  int i;\n  if(x == xg && y == yg)return 1;\n  if(board[x][y] != start_color)return 0;\n  board[x][y] = 0;\n  int xi[] = {0, 1, 0, -1}, yi[] = {1, 0, -1, 0};\n  for(i = 0;i < 4;i++){\n    if(dfs(x + xi[i], y + yi[i]))\n      return 1;\n  }\n  return 0;\n}\n\nint main(){\n  int n, c, d, x, y, i, j;\n  while(1){\n    memset(board, 0, sizeof(board));\n    scanf(\"%d%d\", &w, &h);\n    if(w == 0 && h == 0)return 0;\n    for(i = 1;i <= w;i++)\n      for(j = 1;j <= h;j++)\n\tboard[i][j] = -1;\n    scanf(\"%d%d\", &xs, &ys);\n    scanf(\"%d%d\", &xg, &yg);\n    scanf(\"%d\", &n);\n    while(n--){\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n      if(d == 1){\n\tfor(i = x;i < x + 2;i++)\n\t  for(j = y;j < y + 4;j++)\n\t    board[i][j] = c;\n      }\n      if(d == 0){\n\tfor(i = x;i < x + 4;i++)\n\t  for(j = y;j < y + 2;j++)\n\t    board[i][j] = c;\n      }\n    }\n    start_color = board[xs][ys];\n    if(dfs(xs, ys))\n      puts(\"OK\");\n    else\n      puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint w, h;\nint xs, ys, xg, yg;\nint map[100][100];\nint scolor;\n\nint visit(int x, int y) {\n  static int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n  int nx, ny, i;\n  if(map[y][x] == scolor) {\n    map[y][x] = 0;\n    if(x == xg && y == yg) return 1;\n    for(i = 0; i < 4; i++) {\n      nx = x + d[i][0];\n      ny = y + d[i][1];\n      printf(\"%d, %d \\n\", nx, ny);\n      if(nx >= 0 && nx < w && ny >= 0 && ny < h && map[ny][nx] != 0) {\n\tif(visit(nx, ny) == 1) return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  int c, d, x, y;\n  int i, j,k;\n\n  int temp1, temp2;\n\n  while(1){\n    \n    for(i=0;i<100;i++){\n      for(j=0;j<100;j++){\n\tmap[i][j]=0;\n      }\n    }\n    \n    scanf(\"%d %d\", &w, &h);\n    if(w==0 && h==0) break;\n\n    scanf(\"%d %d\", &xs, &ys);\n    scanf(\"%d %d\", &xg, &yg);\n    xs--;\n    ys--;\n    xg--;\n    yg--;\n\n    scanf(\"%d\", &n);\n\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\n      if(d == 0) {\n\ttemp1 = 2;\n\ttemp2 = 4;\n      } else {\n\ttemp1 = 4;\n\ttemp2 = 2;\n      }\n      for(j = 0; j < temp1; j++)\n\tfor(k = 0; k < temp2; k++)\n\t  map[y-1+j][x-1+k] = c;\n    }\n    scolor = map[ys][xs];\n\n    if(visit(xs, ys) == 1) {\n      printf(\"OK\\n\");\n    } else {\n      printf(\"NG\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 100\n\nstatic\nint map[ N + 1 ][ N + 1 ];\nstatic\nint w, h;\nstatic\nint sc;\nstatic\nint xg, yg;\n\nint dfs (\n  int x,\n  int y\n  )\n{\n#if 0\n  int res;\n#endif\n\n  if ( x < 1 || x >= w || y < 1 || y >= h ) return ( 0 );  \n  if ( map[ x ][ y ] != sc )  return ( 0 );\n  if ( x == xg && y == yg )   return ( 1 );\n\n  map[ x ][ y ] = -1;\n#if 0\n  res = dfs ( x + 1, y )\n     || dfs ( x, y + 1 )\n     || dfs ( x - 1, y )\n     || dfs ( x, y - 1 );\n  map[ x ][ y ] = sc;\n\n  return ( res );\n#endif\n  return ( dfs ( x + 1, y )\n        || dfs ( x, y + 1 )\n        || dfs ( x - 1, y )\n        || dfs ( x, y - 1 ) );\n}\n\nint main (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    int xs, ys;\n    int n;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( w == 0 && h == 0 ) break;\n\n    scanf ( \"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &n );\n\n    while ( n-- )\n    {\n      int c, d, x, y;\n\n      memset ( map, 0, sizeof ( map ) );\n\n      scanf ( \"%d%d%d%d\", &c, &d, &x, &y );\n      map[ x ][ y ] =\n      map[ x + 1 ][ y ] =\n      map[ x ][ y + 1 ] =\n      map[ x + 1 ][ y + 1 ] = c;\n      if ( d )\n      {\n        map[ x ][ y + 2 ] =\n        map[ x ][ y + 3 ] =\n        map[ x + 1 ][ y + 2 ] =\n        map[ x + 1 ][ y + 3 ] = c;\n      }\n      else\n      {\n        map[ x + 2 ][ y ] =\n        map[ x + 2 ][ y + 1 ] =\n        map[ x + 3 ][ y ] =\n        map[ x + 3 ][ y + 1 ] = c;\n      }\n    }\n\n    sc = map[ xs ][ ys ];\n    puts ( dfs ( xs, ys ) ? \"OK\" : \"NG\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[101][101];\nint maze(int nowx,int nowy,int gx,int gy,int canwalk,int goalsitazeyattazehuuuuuuu){\n    int deep;\n    map[nowy][nowx]=0;\n    /*\n    printf(\"%d %d\\n\",nowx,nowy);\n    */\n    if(nowx==gx&&nowy==gy)\n        goalsitazeyattazehuuuuuuu=1;\n    if(goalsitazeyattazehuuuuuuu==1)\n        return (-1,-1,-1,-1,-1,1);\n    else{\n        if(map[nowy][nowx+1]==canwalk&&nowx<100)\n            return maze(nowx+1,nowy,gx,gy,canwalk,goalsitazeyattazehuuuuuuu);\n        if(map[nowy+1][nowx]==canwalk&&nowy<100){\n            return maze(nowx,nowy+1,gx,gy,canwalk,goalsitazeyattazehuuuuuuu);\n            }\n        if(map[nowy][nowx-1]==canwalk&&nowx>0)\n            return maze(nowx-1,nowy,gx,gy,canwalk,goalsitazeyattazehuuuuuuu);\n        if(map[nowy-1][nowx]==canwalk&&nowy>0)\n            return maze(nowx,nowy-1,gx,gy,canwalk,goalsitazeyattazehuuuuuuu);\n    }\n    return goalsitazeyattazehuuuuuuu;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    int can;\n    int judge;\n    for(;;){\n        judge=0;\n        for(i=0;i<101;i++){\n            for(j=0;j<101;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                        if(x+k<w&&y+j<h)\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        /*\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n            puts(\"\");\n        }\n        */\n        can=map[xs][ys];\n        if(can!=0&&map[xg][yg]!=0&&map[xs][ys]==map[xg][yg])\n            judge=maze(xs,ys,xg,yg,can,0);\n        if(judge==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint w, h;\nint xs, ys, xg, yg;\nint map[100][100];\nint scolor;\n\nint visit(int x, int y) {\n  static int d[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n  int nx, ny, i;\n  if(map[y][x] == scolor) {\n    map[y][x] = 0;\n    if(x == xg && y == yg) return 1;\n    for(i = 0; i < 4; i++) {\n      nx = x + d[i][0];\n      ny = y + d[i][1];\n      if(nx >= 0 && nx < w && ny >= 0 && ny < h && map[ny][nx] != 0) {\n\tif(visit(nx, ny) == 1) return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  int c, d, x, y;\n  int i, j,k;\n\n  int temp1, temp2;\n\n  while(1){\n    \n    for(i=0;i<100;i++){\n      for(j=0;j<100;j++){\n\tmap[i][j]=0;\n      }\n    }\n    \n    scanf(\"%d %d\", &w, &h);\n    if(w==0 && h==0) break;\n\n    scanf(\"%d %d\", &xs, &ys);\n    scanf(\"%d %d\", &xg, &yg);\n    xs--;\n    ys--;\n    xg--;\n    yg--;\n\n    scanf(\"%d\", &n);\n\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\", &c, &d, &x, &y);\n\n      if(d == 0) {\n\ttemp1 = 2;\n\ttemp2 = 4;\n      } else {\n\ttemp1 = 4;\n\ttemp2 = 2;\n      }\n      for(j = 0; j < temp1; j++)\n\tfor(k = 0; k < temp2; k++)\n\t  map[y-1+j][x-1+k] = c;\n    }\n    scolor = map[ys][xs];\n\n    if(visit(xs, ys) == 1) {\n      printf(\"OK\\n\");\n    } else {\n      printf(\"NG\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nvoid dequeue(int *x, int *y);\n\n\nint main()\n{\n\tint width, height, xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(!bfs(xstart, ystart)) {\n\t\t\tputs(\"OK\");\n\t\t} else {\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\t\n\tenqueue(xstart, ystart);\n\tdo {\n\t\tdequeue(&x, &y);\n\t\tif(!visited[x + 1][y] && board[x + 1][y] == expectedcolor) enqueue(x + 1, y);\n\t\tif(!visited[x][y + 1] && board[x][y + 1] == expectedcolor) enqueue(x, y + 1);\n\t\tif(!visited[x + 1][y + 1] && board[x + 1][y + 1] == expectedcolor) enqueue(x + 1, y + 1);\n\n\t} while(head != tail);\n\tif(x == xgoal && y == ygoal) return 0;\n\telse return -1;\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nvoid dequeue(int *x, int *y)\n{\n\t*x = queue[head][0];\n\t*y = queue[head][1];\n\thead++;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,sx,sy,gx,gy,n,b[110][110],c,d,p[2],i,j,m[2]={2,4},mv[5]={0,1,0,-1,0},tag;\n\nint df(int px,int py)\n{\n\tint i;\n\tif(py<1||py>y||px<1||py>x||b[py][px]!=tag)\n\t\treturn 0;\n\tif(py==gy&&px==gx)\n\t\treturn 1;\n\tb[py][px]=0;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(df(px+mv[i+1],py+mv[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(b,0,sizeof(b));\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\tfor(;n--;)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&p[0],&p[1]);\n\t\t\tfor(i=0;i<m[d];i++)\n\t\t\t\tfor(j=0;j<m[!d];j++)\n\t\t\t\t\tb[p[1]+i][p[0]+j]=c;\n\t\t}\n\t\ttag=b[sy][sx];\n\t\tprintf(\"%s\\n\",tag&&df(sx,sy)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint x,y,sx,sy,gx,gy,n,b[110][110],c,d,p[2],i,j,m[2]={2,4},mx[4]={0,1,0,-1},my[4]={1,0,-1,0},tag;\n\nint df(int px,int py)\n{\n\tint i;\n\tif(py<1||py>y||px<1||px>x||b[py][px]!=tag)\n\t\treturn 0;\n\tif(py==gy&&px==gx)\n\t\treturn 1;\n\tb[py][px]=0;\n\tfor(i=0;i<4;i++)\n\t{\n\t\tif(df(px+mx[i],py+my[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&x,&y),x;)\n\t{\n\t\tmemset(b,0,sizeof(b));\n\t\tscanf(\"%d%d\",&sx,&sy);\n\t\tscanf(\"%d%d\",&gx,&gy);\n\t\tscanf(\"%d\",&n);\n\t\tfor(;n--;)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&p[0],&p[1]);\n\t\t\tfor(i=0;i<m[d];i++)\n\t\t\t\tfor(j=0;j<m[!d];j++)\n\t\t\t\t\tb[p[1]+i][p[0]+j]=c;\n\t\t}\n\t\ttag=b[sy][sx];\n\t\tprintf(\"%s\\n\",tag&&df(sx,sy)?\"OK\":\"NG\");\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[101][101];\nint w, h;\n\nint dfs(int xs, int ys, int c, int xg, int yg)\n{\n\tif (xs == xg && ys == yg){\n\t\treturn (1);\n\t}\n\t\n\tmap[ys][xs] = -1;\n\t\n\tif (1 <= xs - 1 && map[ys][xs - 1] == c){\n\t\tif (dfs(xs - 1, ys, c, xg, yg) == 1){\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (1 <= ys - 1 && map[ys - 1][xs] == c){\n\t\tif (dfs(xs, ys - 1, c, xg, yg) == 1){\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (xs + 1 <= w && map[ys][xs + 1] == c){\n\t\tif (dfs(xs + 1, ys, c, xg, yg) == 1){\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (ys + 1 <= h && map[ys + 1][xs] == c){\n\t\tif (dfs(xs, ys + 1, c, xg, yg) == 1){\n\t\t\treturn (1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\t\n\tint i, j, k;\n\tint xs, ys, xg, yg;\n\tint n;\n\tint c, d, x, y;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (!(w + h)){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &xs, &ys);\n\t\tscanf(\"%d%d\", &xg, &yg);\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tif (d == 0){\n\t\t\t\tfor (j = 0; j < 2; j++){\n\t\t\t\t\tfor (k = 0; k < 4; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\t\tfor (k = 0; k < 2; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dfs(xs, ys, map[ys][xs], xg, yg) == 1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\n  int BY[]={0,0,1,1,0,0,1,1,2,2,3,3};\n  int BX[]={2,3,2,3,0,1,0,1,0,1,0,1};\n  int w,h,x[10010],y[10010],gx,gy,by,bx,n,ny,nx,i,j,c,t,r,sc,d;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int m[110][110]={0};\n    scanf(\"%d %d %d %d %d\",&x[0],&y[0],&gx,&gy,&n);\n    while(n--){\n      scanf(\"%d %d %d %d\",&c,&d,&bx,&by);\n      for(i=0;i<8;i++)m[by+BY[d*4+i]][bx+BX[d*4+i]]=c;\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%d \",m[i][j]);\n      printf(\"\\n\");\n      }//*/\n    sc=m[y[0]][x[t=0]];\n    m[y[0]][x[0]]=0;\n    if(sc==0){\n      printf(\"NG\\n\");\n      continue;\n    }\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(m[ny][nx]-sc)continue;\n\tm[ny][nx]=6;\n\ty[r  ]=ny;\n\tx[r++]=nx;\n      }\n    }\n    if(m[gy][gx]-6)printf(\"NG\\n\");\n    else           printf(\"OK\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint p[101][101];\nint r[101][101];\nint w,h,xg,yg;\nvoid place(int c,int d,int x,int y)\n{\n  p[y][x] = c;\n  p[y][x+1] = c;\n  p[y+1][x] = c;\n  p[y+1][x+1] = c;\n  if(d==0){\n    p[y][x+2] = c;\n    p[y][x+3] = c;\n    p[y+1][x+2] = c;\n    p[y+1][x+3] = c;\n  }else{\n    p[y+2][x] = c;\n    p[y+2][x+1] = c;\n    p[y+3][x] = c;\n    p[y+3][x+1] = c;\n  }\n}\nint search(int x,int y)\n{\n  int a=0;\n  int c=p[y][x];\n  if(x==xg && y==yg) return 1;\n  r[y][x] = 1;\n  if (p[y][x-1] == c && r[y][x-1] == 0)\n    a += search(x-1,y);\n  if (p[y][x+1] == c && r[y][x+1] == 0)\n    a += search(x+1,y);\n  if (p[y-1][x] == c && r[y-1][x] == 0)\n    a += search(x,y-1);\n  if (p[y+1][x] == c && r[y+1][x] == 0)\n    a += search(x,y+1);\n  return a;\n}\nvoid show()\n{\n  int i,j;\n  for(i=1;i<=h;i++){\n    for(j=1;j<=w;j++){\n      printf(\"%d\",p[i][j]);\n    }\n    printf(\"\\n\");\n  }\n}\nint main()\n{\n  int xs,ys,n,c,d,x,y;\n  for(;;){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0&&h==0)break;\n    memset(p,0,sizeof(p));\n    memset(r,0,sizeof(r));\n    scanf(\"%d%d\",&xs,&ys);\n    scanf(\"%d%d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    while(n>0){\n      scanf(\"%d%d%d%d\",&c,&d,&x,&y);\n      place(c,d,x,y);\n      n--;\n    }\n    //show();\n    if(search(xs,ys)) printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint flag=0;\nint mp[102][102];\nint sn[102][102];\nint bc;\n\nint px[4]={0,1,0,-1};\nint py[4]={1,0,-1,0};\n\nint slv(int xs,int ys);\n\nint w,h,xg,yg;\nint n,c,d,x,y;  \nint i,j,k;\n\nint main(){\n  int xs,ys;\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0)return(0);\n    cin>>xs>>ys;\n    cin>>xg>>yg;\n    flag=0;\n    cin>>n;\n    memset(mp,0,sizeof(mp));\n    memset(sn,0,sizeof(sn));\n    for( i=0;i<n;i++){\n      cin>>c>>d>>x>>y;\n      if(d==1){\n\tfor( j=0;j<4;j++){\n\t  for( k=0;k<2;k++)mp[x+k][y+j]=c;\n\t}\n      }\n      else{\n\tfor( j=0;j<2;j++){\n\t  for( k=0;k<4;k++)mp[x+k][y+j]=c;\n\t}\n      }\n    }\n    \n    bc=mp[xs][ys];\n    \n    slv(xs,ys);\n    \n    if(flag)cout<<\"OK\"<<endl;\n    else cout<<\"NG\"<<endl;\n    \n  }\n}\n\nint slv(int xs,int ys){\n  if(xs==xg && ys==yg){\n    flag=1;\n    return(0);\n  }\n  \n  for(i=0;i<4;i++){\n    xs+=px[i];\n    ys+=py[i];\n    if(bc==mp[xs][ys] && sn[xs][ys]==0){\n      sn[xs][ys]=1;\n      slv(xs,ys);\n    }\n    xs-=px[i];\n    ys-=py[i];\n  }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint map[102][102];\nint canwalk;\nint judgeOK;\nmaze(int nowy,int nowx,int gy,int gx){\n    map[nowy][nowx]=0;\n    /*\n    printf(\"%d %d %d\\n\",nowx,nowy,judgeOK);\n    */\n    if(nowy==gy&&nowx==gx){\n        judgeOK=1;\n    }\n    if(map[nowy][nowx+1]==canwalk)\n        maze(nowy,nowx+1,gy,gx);\n    if(map[nowy+1][nowx]==canwalk)\n        maze(nowy+1,nowx,gy,gx);\n    if(map[nowy][nowx-1]==canwalk)\n        maze(nowy,nowx-1,gy,gx);\n    if(map[nowy-1][nowx]==canwalk)\n        maze(nowy-1,nowx,gy,gx);\n    return judgeOK;\n}\nint main(void){\n    int w,h,xs,ys,xg,yg,n,c,d,x,y;\n    int i,j,k;\n    for(;;){\n        for(i=0;i<102;i++){\n            for(j=0;j<102;j++){\n                map[i][j]=0;\n            }\n        }\n        scanf(\"%d %d\",&w,&h);\n        if(w==0&&h==0)\n            break;\n        scanf(\"%d %d\",&xs,&ys);\n        scanf(\"%d %d\",&xg,&yg);\n        xs--,ys--,xg--,yg--;\n        scanf(\"%d\",&n);\n        for(i=0;i<n;i++){\n            scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n            x--,y--;\n            if(d==0){\n                for(j=0;j<2;j++){\n                    for(k=0;k<4;k++){\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n            else{\n                for(j=0;j<4;j++){\n                    for(k=0;k<2;k++){\n                            map[y+j][x+k]=c;\n                    }\n                }\n            }\n        }\n        /*\n        for(i=0;i<w;i++){\n            for(j=0;j<h;j++){\n                printf(\"%d \",map[i][j]);\n            }\n        puts(\"\");\n        }\n        */\n            judgeOK=0;\n        if(map[ys][xs]==map[yg][xg]){\n            if(map[ys][xs]!=0){\n                canwalk=map[ys][xs];\n                judgeOK=maze(ys,xs,yg,xg);\n            }\n        }\n        if(judgeOK==1)\n            puts(\"OK\");\n        else\n            puts(\"NG\");\n    }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = 1;\n                    board[y + 1][x + j] = 1;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = 1;\n                    board[y + j][x + 1] = 1;\n                }\n            }\n        }\n        \n        board[ys][ys] = 2;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == 1){\n                        if (board[i][j - 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i - 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i][j + 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i + 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == 2){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 500\n#define M 100\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[y][x]==0 || c==0){\n    return;\n  }\n  if(map[y][x]!=c && map[y][x]!=9){\n    return;\n  }\n  if(map[y][x]==9){\n    map[y][x]=7;\n    return;\n  } \n  map[y][x]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w,h;\n  int xs,ys,xg,yg,n;\n  int c[N],d[N],x[N],y[N];\n  int map[M][M];\n  int ans[N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w,&h);\n    if(w==0 && h==0){\n      break;\n    }\n    scanf(\"%d%d\",&xs,&ys);\n    scanf(\"%d%d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    for(j=0;j<n;j++){\n      scanf(\"%d%d%d%d\",&c[j],&d[j],&x[j],&y[j]);\n    }\n    for(j=0;j<w;j++){\n      for(k=0;k<h;k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n;j++){\n      if(d[j]==0){\n        for(k=0;k<2;k++){\n          for(l=0;l<4;l++){\n            map[y[j]+k][x[j]+l]=c[j];\n          }\n        }\n      }else if(d[j]==1){\n        for(k=0;k<4;k++){\n          for(l=0;l<2;l++){\n            map[y[j]+k][x[j]+l]=c[j];\n          }\n        }\n      }\n    }\n    map[xg][yg]=9;\n    search(map,xs,ys,map[ys][xs]);\n    if(map[yg][xg]==7){\n      ans[i]=1;\n    }else if(map[yg][xg]==9){\n      ans[i]=0;\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    if(ans[i]==1){\n      printf(\"OK\\n\");\n    }else{\n      printf(\"NG\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0207\nTitle Block\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n//#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n#include <setjmp.h>\n//Global data section\nint w,h;\nint xs,ys;\nint xg,yg;\nint n;\nint c[100];\nint d[100];\nint x[100],y[100];\nint bd[100][100];\njmp_buf env;\n\n//\nvoid init()\n{\n  int i,j;\n  for(i=0;i<h;i++)\n    for(j=0;j<w;j++)\n      bd[i][j]=0;\n  for(i=0;i<100;i++)\n    {\n      x[i]=y[i]=d[i]=c[i]=0;\n    }\n}\nint get_block(int px,int py)\n{\n  int i;\n  // printf(\"GB%d,%d\\n\",px,py);\n  for(i=0;i<n;i++)\n    if(d[i]==0)         // yokonaga\n\t{\n\t  if(px-x[i] >=0 && px-x[i] <=3 && \n\t     py-y[i] >=0 && py-y[i] <= 1)\n\t    return(i);\n\t}\n    else if(d[i]==1)         // tatenaga\n      {\n\tif(px-x[i] >=0 && px-x[i] <=1 && \n\t   py-y[i] >=0 && py-y[i] <=3)\n\t  return(i);\n      }\n  return(-1);\n}\nint show()\n{\n  int i,j;\n  for(i=1;i<=h;i++)\n    {\n      for(j=1;j<=w;j++)\n\tprintf(\"%d\",bd[i][j]);\n      printf(\"\\n\");\n    }\n  printf(\"\\n\");\n}\nvoid paint0(int px,int py,int col,int ww,int hh)\n{\n  int i,j;\n  //printf(\"P0 %d %d\\n\",px,py);\n\n    for(i=0;i<hh;i++)\n      for(j=0;j<ww;j++)\n\tbd[py+i][px+j]=col;\n}\nint paint(int px,int py,int col)\n{\n  int cc,blk,dir,bx,by,w0,h0,i,j;\n  //printf(\"xyc=%d %d %d\\n\",px,py,col);\n\n  if(px < 1 ||py < 1) //out of bound\n    return(0);\n  if(bd[py][px])  // already painted\n    return(0);\n  blk=get_block(px,py);  // get block no of this place\n  //printf(\"blk=%d\\n\",blk);\n  if(blk<0)\n    return(0);\n  cc=c[blk];\n  dir=d[blk];\n  if(cc != col)\n    return(0);             // different color\n\n  bx=x[blk];\n  by=y[blk];\n   if(dir==0)         // yokonaga\n     { w0=4;h0=2;}\n   else\n     { w0=2;h0=4;}\n\n  paint0(bx,by,col,w0,h0); // paint this block\n\n  if(xg >= bx && xg <= bx+w0 && \n     yg >= by && yg <= by+h0 )     // reach the goal\n    {\n      longjmp(env,1);\n    }\n\n   for(i=-1;i<w0+1;i++)\n     if(i==-1||i==w0)\n       for(j=0;j<h0;j++)\n\t paint(bx+i,by+j,col);\n     else\n       for(j=-1;j<h0+1;j++)\n\t paint(bx+i,by+j,col);\n\n   return(0);\n}\nmain()\n{\n  int i,bl,col,dir,ret;\n  while(EOF != scanf(\"%d %d\",&w,&h) && (w || h))\n    {\n      init();\n      scanf(\"%d %d\",&xs,&ys);\n      scanf(\"%d %d\",&xg,&yg);\n      scanf(\"%d\",&n);\n      for(i=0;i<n;i++)\n\tscanf(\"%d %d %d %d\",&(c[i]),&(d[i]),&(x[i]),&(y[i]));\n      \n      bl = get_block(xs,ys);\n      col=c[bl];\n      if(setjmp(env)==0)\n\t{\n\t  ret = paint(xs,ys,col);\n\t}\n      else\n\tret=-1;\n      \n      paint(1,1,2);\n      // show();\n      printf(\"%s\\n\",ret?\"OK\":\"NG\");\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nint dequeue(int expectedcolor);\n\n\nint main()\n{\n\tint width, height, xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(bfs(xstart, ystart)) {\n\t\t\tputs(\"OK\\n\");\n\t\t} else {\n\t\t\tputs(\"NG\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\t\n\tenqueue(xstart, ystart);\n\twhile(!dequeue(expectedcolor));\n\tif (queue[head][0] == xgoal && queue[head][1] == ygoal) {\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nint dequeue(int expectedcolor)\n{\n\tif (!visited[ queue[head][0] ][ queue[head][1] ] && board[ queue[head][0] ][ queue[head][1] ] == expectedcolor) {\n\t\tif (!visited[ queue[head][0] + 1 ][ queue[head][1] ])\n\t\t\tenqueue(queue[head][0] + 1, queue[head][1]);\t\t/*右*/\n\n\t\tif (!visited[ queue[head][0] ][ queue[head][1] + 1 ])\n\t\t\tenqueue(queue[head][0], queue[head][1] + 1);\t\t/*下*/\n\n\t\tif (!visited[ queue[head][0] + 1][ queue[head][1] + 1 ])\n\t\t\tenqueue(queue[head][0] + 1, queue[head][1] + 1);\t/*右下*/\n\n\t\thead++;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N 100\n\nstatic\nint map[ N + 1 ][ N + 1 ];\nstatic\nint w, h;\nstatic\nint sc;\nstatic\nint xg, yg;\n\nint dfs (\n  int x,\n  int y\n  )\n{\n  int res;\n\n  if ( x < 0 || x >= w || y < 0 || y >= h ) return ( 0 );  \n  if ( x == xg && y == yg )   return ( 1 );\n  if ( map[ x ][ y ] != sc )  return ( 0 );\n\n  map[ x ][ y ] = -1;\n  res = dfs ( x + 1, y )\n     || dfs ( x, y + 1 )\n     || dfs ( x - 1, y )\n     || dfs ( x, y - 1 );\n  map[ x ][ y ] = sc;\n\n  return ( res );\n}\n\nint main (\n  void\n  )\n{\n  for ( ; ; )\n  {\n    int xs, ys;\n    int n;\n\n    scanf ( \"%d%d\", &w, &h );\n    if ( w == 0 && h == 0 ) break;\n\n    scanf ( \"%d%d%d%d%d\", &xs, &ys, &xg, &yg, &n );\n\n    while ( n-- )\n    {\n      int c, d, x, y;\n     \n      scanf ( \"%d%d%d%d\", &c, &d, &x, &y );\n      map[ x ][ y ] =\n      map[ x + 1 ][ y ] =\n      map[ x ][ y + 1 ] =\n      map[ x + 1 ][ y + 1 ] = c;\n      if ( d )\n      {\n        map[ x ][ y + 2 ] =\n        map[ x ][ y + 3 ] =\n        map[ x + 1 ][ y + 2 ] =\n        map[ x + 1 ][ y + 3 ] = c;\n      }\n      else\n      {\n        map[ x + 2 ][ y ] =\n        map[ x + 2 ][ y + 1 ] =\n        map[ x + 3 ][ y ] =\n        map[ x + 3 ][ y + 1 ] = c;\n      }\n    }\n\n    sc = map[ xs ][ ys ];\n    puts ( dfs ( xs, ys ) ? \"OK\" : \"NG\" );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      int a,b;\n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\");\n    else printf(\"NG\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i)+abs(j)==1 && boad[x+i][y+j]!=-1)\n\tif(dfs(x+i,y+j))return 1;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[y][x]==0 || c==0){\n    return;\n  }\n  if(map[y][x]!=c && map[y][x]!=9){\n    return;\n  }\n  if(map[y][x]==9){\n    map[y][x]=7;\n    return;\n  } \n  map[y][x]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[N][N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0){\n      break;\n    }\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<2;k++){\n          for(l=0;l<4;l++){\n            map[y[i][j]+k][x[i][j]+l]=c[i][j];\n          }\n        }\n      }else if(d[i][j]==1){\n        for(k=0;k<4;k++){\n          for(l=0;l<2;l++){\n            map[y[i][j]+k][x[i][j]+l]=c[i][j];\n          }\n        }\n      }\n    }\n    map[xg[i]][yg[i]]=9;\n    search(map,xs[i],ys[i],map[ys[i]][xs[i]]);\n    if(map[yg[i]][xg[i]]==7){\n      printf(\"OK\\n\");\n    }else if(map[yg[i]][xg[i]]==9){\n      printf(\"NG\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[101][101];\nint w, h;\n\nint dfs(int xs, int ys, int c, int xg, int yg)\n{\n\tint dx, dy;\n\tif (xs == xg && ys == yg){\n\t\treturn (1);\n\t}\n\t\n\tmap[xs][ys] = -1;\n\t\n\tif (xs + 1 <= w && map[xs + 1][ys] == c){\n\t\tif (dfs(xs + 1, ys, c, xg, yg)){\n\t\t\treturn (1);\n\t\t}\n\t}\n\tif (ys + 1 <= h && map[xs][ys + 1] == c){\n\t\tif (dfs(xs, ys + 1, c, xg, yg)){\n\t\t\treturn (1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\t\n\tint i, j, k;\n\tint xs, ys, xg, yg;\n\tint n;\n\tint c, d, x, y;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (!(w + h)){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &xs, &ys);\n\t\tscanf(\"%d%d\", &xg, &yg);\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tif (d == 0){\n\t\t\t\tfor (j = 0; j < 2; j++){\n\t\t\t\t\tfor (k = 0; k < 4; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\t\tfor (k = 0; k < 2; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (dfs(xs, ys, map[xs][ys], xg, yg)){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint search(xs, ys, c) {\n\n}\n\nstruct blkinfo_t {\n  int c;\n  int d;\n  int x;\n  int y;\n};\n\nint **board;\nint **flag;\n\nint xg, yg;\n\nvoid createmaze(int n, struct blkinfo_t *blks) {\n  int i;\n  int curx;\n  int cury;\n\n  for(i = 0; i < n; i++) {\n    curx = blks[n].x;\n    cury = blks[n].y;\n\n    if(d == 0) {\n      board[cury][curx] = blks[n].c;\n      board[cury][curx+1] = blks[n].c;\n      board[cury][curx+2] = blks[n].c;\n      board[cury][curx+3] = blks[n].c;\n      board[cury+1][curx] = blks[n].c;\n      board[cury+1][curx+1] = blks[n].c;\n      board[cury+1][curx+2] = blks[n].c;\n      board[cury+1][curx+3] = blks[n].c;\n    }\n    else {\n      board[cury][curx] = blks[n].c;\n      board[cury][curx+1] = blks[n].c;\n      board[cury+1][curx] = blks[n].c;\n      board[cury+1][curx+1] = blks[n].c;\n      board[cury+2][curx] = blks[n].c;\n      board[cury+2][curx+1] = blks[n].c;\n      board[cury+3][curx] = blks[n].c;\n      board[cury+3][curx+1] = blks[n].c;\n    }\n  }\n\n  return;\n}\n\nint search(x, y, c) {\n  int result[4] = {0, 0, 0, 0};\n\n  if(flag[y][x] == 1)\n    return -1;\n  if(board[y][x] != c)\n    return -1;\n  if((x == xg) && (y == yg))\n    return 1;\n\n  flag[y][x] = 1;\n\n  if(x+1 > w) {\n    result[0] = search(x+1, y, c);\n  }\n  if(x-1 < 1) {\n    result[1] = search(x-1, y, c);\n  }\n  if(y+1 > h) {\n    result[2] = search(x, y+1, c);\n  }\n  if(y-1 < 1) {\n    result[3] = search(x, y-1, c);\n  }\n\n  if((result[0] == 1) ||\n     (result[1] == 1) ||\n     (result[2] == 1) ||\n     (result[3] == 1))\n    return 1;\n  else\n    return -1;\n}\n\nint main() {\n  int i;\n\n  int w, h;\n  int xs, ys;\n  int n;\n\n  struct blkinfo_t *blks;\n\n\n  scanf(\"%d %d\", w , h);\n  scanf(\"%d %d\", xs, ys);\n  scanf(\"%d %d\", xg, yg);\n  scanf(\"%d\", n);\n\n  blks = calloc(n, sizeof(struct blkinfo_t));\n\n  for(i = 0; i < n; i++) {\n    scanf(\"%d %d %d %d\", blks[n].c, blks[n].d, blks[n].x, blks[n].y);\n  }\n\n  board = calloc(w*h, sizeof(int));\n  flag  = calloc(w*h, sizeof(int));\n\n  if(search(xs, ys, c) == 1)\n    printf(\"OK\");\n  else\n    printf(\"NG\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\n  int BY[]={0,0,1,1,0,0,1,1,2,2,3,3};\n  int BX[]={2,3,2,3,0,1,0,1,0,1,0,1};\n  int w,h,x[10010],y[10010],gx,gy,by,bx,n,ny,nx,i,j,c,t,r,sc,d;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int m[110][110]={0};\n    scanf(\"%d %d %d %d %d\",&x[0],&y[0],&gx,&gy,&n);\n    while(n--){\n      scanf(\"%d %d %d %d\",&c,&d,&bx,&by);\n      for(i=0;i<8;i++)m[by+BY[d*4+i]][bx+BX[d*4+i]]=c;\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%d \",m[i+1][j+1]);\n      printf(\"\\n\");\n      }//*/\n    sc=m[y[0]][x[0]];\n    m[y[0]][x[0]]=t=0;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(m[ny][nx]-sc)continue;\n\tm[ny][nx]=0;\n\ty[r  ]=ny;\n\tx[r++]=nx;\n      }\n    }\n    if(m[gy][gx])printf(\"NG\\n\");\n    else         printf(\"OK\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nint dequeue(int expectedcolor);\n\n\nint main()\n{\n\tint width, height, xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(bfs(xstart, ystart)) {\n\t\t\tputs(\"OK\");\n\t\t} else {\n\t\t\tputs(\"NG\");\n\t\t}\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\t\n\tenqueue(xstart, ystart);\n\twhile(!dequeue(expectedcolor));\n\tif (queue[head][0] == xgoal && queue[head][1] == ygoal) {\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nint dequeue(int expectedcolor)\n{\n\tif (!visited[ queue[head][0] ][ queue[head][1] ] && board[ queue[head][0] ][ queue[head][1] ] == expectedcolor) {\n\t\tif (!visited[ queue[head][0] + 1 ][ queue[head][1] ])\n\t\t\tenqueue(queue[head][0] + 1, queue[head][1]);\t\t/*右*/\n\n\t\tif (!visited[ queue[head][0] ][ queue[head][1] + 1 ])\n\t\t\tenqueue(queue[head][0], queue[head][1] + 1);\t\t/*下*/\n\n\t\tif (!visited[ queue[head][0] + 1][ queue[head][1] + 1 ])\n\t\t\tenqueue(queue[head][0] + 1, queue[head][1] + 1);\t/*右下*/\n\n\t\thead++;\n\t\treturn 0;\n\t} else {\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "w,h,xs,ys,xg,yg,c;\nm[102][102];\nC(x,y){\n\tif(m[x][y]==c){\n\t\tm[x][y]=0;\n\t\tC(x-1,y);\n\t\tC(x+1,y);\n\t\tC(x,y-1);\n\t\tC(x,y+1);\n\t}\n}\nmain(){\n\tint n,d,x,y,i,j;\n\tfor(;scanf(\"%d%d%d%d%d%d%d\",&w,&h,&xs,&ys,&xg,&yg,&n),w;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d%d\",&c,&d,&x,&y);\n\t\t\tfor(i=0;i<(d?2:4);i++)\n\t\t\t\tfor(j=0;j<(d?4:2);j++)\n\t\t\t\t\tm[x+i][y+j]=c;\n\t\t}\n\t\tc=m[xs][ys];\n\t\tif(c)\n\t\t\tC(xs,ys);\n\t\tputs(m[xg][yg]?\"NG\":\"OK\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = 1;\n                    board[y + 1][x + j] = 1;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = 1;\n                    board[y + j][x + 1] = 1;\n                }\n            }\n        }\n        \n        board[ys][xs] = 2;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == 1){\n                        if (board[i][j - 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i - 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i][j + 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i + 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == 2){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = 1;\n                    board[y + 1][x + j] = 1;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = 1;\n                    board[y + j][x + 1] = 1;\n                }\n            }\n        }\n        \n        board[ys][xs] = 2;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == 1){\n                        if (board[i][j - 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        else if (board[i][j + 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        else if (board[i + 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        else if (board[i - 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == 2){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint w, h, xs, ys, xg, yg, board[105][105], start_color;\n\nint dfs(int x, int y){\n  int i;\n  if(board[x][y] != start_color)return 0;\n  if(x == xg && y == yg)return 1;\n  board[x][y] = 0;\n  int xi[] = {0, 1, 0, -1}, yi[] = {1, 0, -1, 0};\n  for(i = 0;i < 4;i++)\n    if(dfs(x + xi[i], y + yi[i]))\n      return 1;\n\n  return 0;\n}\n\nint main(){\n  int n, c, d, x, y, i, j;\n  while(1){\n    memset(board, 0, sizeof(board));\n    scanf(\"%d%d\", &w, &h);\n    if(w == 0 && h == 0)return 0;\n    scanf(\"%d%d\", &xs, &ys);\n    scanf(\"%d%d\", &xg, &yg);\n    scanf(\"%d\", &n);\n    while(n--){\n      scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n      if(d == 1){\n\tfor(i = x;i < x + 2;i++)\n\t  for(j = y;j < y + 4;j++)\n\t    board[i][j] = c;\n      }\n      if(d == 0){\n\tfor(i = x;i < x + 4;i++)\n\t  for(j = y;j < y + 2;j++)\n\t    board[i][j] = c;\n      }\n    }\n    start_color = board[xs][ys];\n    if(dfs(xs, ys))\n      puts(\"OK\");\n    else\n      puts(\"NG\");\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\nint dfs(int,int);\nint boad[102][102];\nint w,h,xs,ys,xg,yg,n,c,d;\n\nint main(void){\n  int x,y,i,j;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<102;i++){\n      for(j=0;j<102;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d==0){\n\tfor(i=y;i<y+2;i++){\n\t  for(j=x;j<x+4;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n      }\n      else if(d==1){\n\tfor(i=x;i<x+2;i++){\n\t  for(j=y;j<y+4;j++){\n\t    boad[j][i]=c;\n\t  }\n\t}\n      }\n    }\n    c=boad[xs][ys];\n\n    for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\n\tprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n}\n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i,j,res=0;\n  \n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \n  for(i=-1;i<2;i++){\n    for(j=-1;j<2;j++){\n      if(boad[x+i][y+j]==c && abs(i+j)==1 && boad[x+i][y+j]!=-1)res+=dfs(x+i,y+j);\n    }\n  }\n  return (res>0)?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[101][101];\nint w, h;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint dfs(int xs, int ys, int c, int xg, int yg)\n{\n\tint i;\n\tif (xs == xg && ys == yg){\n\t\treturn (1);\n\t}\n\t\n\tmap[ys][xs] = -1;\n\t\n\tfor (i = 0; i < 4; i++){\n\t\tint nx = xs + dx[i], ny = ys + dy[i];\n\t\tif (1 <= nx && nx <= w && 1 <= ny && ny <= h && map[ny][nx] == c && dfs(nx, ny, c, xg, yg)){\n\t\t\treturn (1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\t\n\tint i, j, k;\n\tint xs, ys, xg, yg;\n\tint n;\n\tint c, d, x, y;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (!(w + h)){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\", &xs, &ys);\n\t\tscanf(\"%d%d\", &xg, &yg);\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x, &y);\n\t\t\t\n\t\t\tif (d == 0){\n\t\t\t\tfor (j = 0; j < 2; j++){\n\t\t\t\t\tfor (k = 0; k < 4; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = 0; j < 4; j++){\n\t\t\t\t\tfor (k = 0; k < 2; k++){\n\t\t\t\t\t\tmap[y + j][x + k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (map[ys][xs] && dfs(xs, ys, map[ys][xs], xg, yg) == 1){\n\t\t\tprintf(\"OK\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"NG\\n\");\n\t\t}\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\n  int BY[]={0,0,1,1,0,0,1,1,2,2,3,3};\n  int BX[]={2,3,2,3,0,1,0,1,0,1,0,1};\n  int w,h,x[10000],y[10000],gx,gy,by,bx,n,ny,nx,i,j,c,t,r,sc,d;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int m[110][110]={0};\n    scanf(\"%d %d %d %d %d\",&x[0],&y[0],&gx,&gy,&n);\n    while(n--){\n      scanf(\"%d %d %d %d\",&c,&d,&bx,&by);\n      for(i=0;i<8;i++)m[by+BY[d*4+i]][bx+BX[d*4+i]]=c;\n    }\n    sc=m[y[0]][x[0]];\n    m[y[0]][x[0]]=t=0;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(m[ny][nx]-sc)continue;\n\tif(ny==gy&&nx==gx)goto END;\n\tm[ny][nx]=0;\n\ty[r  ]=ny;\n\tx[r++]=nx;\n      }\n    }\n  END:\n    if(r-t)printf(\"OK\\n\");\n    else   printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "b[101][101];xg,yg;r(x,y,c){if(c!=b[x][y])return 0;if(x==xg&&y==yg)return 1;b[x][y]=0;return r(x+1,y,c)||r(x,y+1,c)||r(x-1,y,c)||r(x,y-1,c)?1:0;}main(xs,ys,n,c,d,x,y){for(;scanf(\"%d%d\",&x,&y),x;puts(b[xs][ys]&&b[xg][yg]&&b[xs][ys]==b[xg][yg]&&r(xs,ys,b[xs][ys])?\"OK\":\"NG\"))for(scanf(\"%d%d%d%d%d\",&xs,&ys,&xg,&yg,&n);n;n--)if(scanf(\"%d%d%d%d\",&c,&d,&x,&y),d)b[x][y]=b[x+1][y]=b[x][y+1]=b[x+1][y+1]=b[x][y+2]=b[x+1][y+2]=b[x][y+3]=b[x+1][y+3]=c;else b[x][y]=b[x+1][y]=b[x+2][y]=b[x+3][y]=b[x][y+1]=b[x+1][y+1]=b[x+2][y+1]=b[x+3][y+1]=c;exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define REP(i,m,n) for(i=m;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nint dfs(int,int);\nint boad[110][110];\nint w,h,xs,ys,xg,yg,n,c,d;\nconst int Dx[]={1,0,-1,0},Dy[]={0,1,0,-1};\nint main(void){\n  int x,y,i,j,a,b;\n\n  while(1){\n   \n    scanf(\"%d %d\",&w,&h);\n    if(w==0 && h==0)break;\n    scanf(\"%d %d\",&xs,&ys);\n    scanf(\"%d %d\",&xg,&yg);\n    scanf(\"%d\",&n);\n    \n    for(i=0;i<110;i++){\n      for(j=0;j<110;j++){\n\tboad[i][j]=-1;\n      }\n    }\n    int k;\n    for(k=0;k<n;k++){\n      scanf(\"%d %d %d %d\",&c,&d,&x,&y);\n      \n      if(d){a=4;b=2;}\n      else {a=2;b=4;}\n\tfor(i=y;i<y+a;i++){\n\t  for(j=x;j<x+b;j++){\n\t    boad[i][j]=c;\n\t  }\n\t}\n\n    }\n    c=boad[xs][ys];\n \n  \n    if(dfs(xs,ys))printf(\"OK\\n\");\n    else printf(\"NG\\n\");\n    /*for(i=0;i<15;i++){\n      for(j=0;j<15;j++)\nprintf(\"%2d\",boad[i][j]);\n      printf(\"\\n\");\n      }*/\n  }\n  return 0;\n}\n  \nint dfs(int x,int y){\n  int i;\n  if(x<=0||x>w||y<=0||y>h||boad[x][y]!=c)return 0;\n  if(x==xg && y==yg)return 1;\n  \n  boad[x][y]=-1;\n  \nrep(i,4)if(dfs(x+Dx[i],y+Dy[i]))return 1;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    int board[102][102];\n    int w, h;\n    int xs, ys, xg, yg;\n    int c, d, x, y;\n    int n;\n    int i, j;\n    int flag;\n    \n    while (1){\n        scanf(\"%d%d\", &w, &h);\n        if (w == 0 && h == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &xs, &ys, &xg, &yg);\n\n        memset(board, 0, sizeof(board));\n\n        scanf(\"%d\", &n);\n        for (i = 0; i < n; i++){\n            scanf(\"%d%d%d%d\", &c, &d, &x, &y);\n            \n            if (d == 0){\n                for (j = 0; j < 4; j++){\n                    board[y    ][x + j] = 1;\n                    board[y + 1][x + j] = 1;\n                }\n            }\n            else {\n                for (j = 0; j < 4; j++){\n                    board[y + j][x    ] = 1;\n                    board[y + j][x + j] = 1;\n                }\n            }\n        }\n        \n        board[ys][ys] = 2;\n        \n        while (1){\n            flag = 0;\n            for (i = 1; i <= h; i++){\n                for (j = 1; j <= w; j++){\n                    if (board[i][j] == 1){\n                        if (board[i][j - 1] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                        if (board[i - 1][j] == 2){\n                            board[i][j] = 2;\n                            flag = 1;\n                        }\n                    }\n                }\n            }\n            if (flag == 0){\n                break;\n            }\n        }\n        \n        if (board[yg][xg] == 2){\n            printf(\"OK\\n\");\n        }\n        else {\n            printf(\"NG\\n\");\n        }\n    }\n    return (0);\n}\n                    \n\n        \n        \n        "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint width, height, xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nvoid dequeue(int *x, int *y);\n\n\nint main()\n{\n\tint xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tfor(i = 0; i < 101; i++) {\n\t\t\tfor(j = 0; j < 101; j++) {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t\tvisited[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < 10000; i++) {\n\t\t\tfor(j = 0; j < 2; j++) {\n\t\t\t\tqueue[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(!bfs(xstart, ystart)) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\n\tenqueue(xstart, ystart);\n\tdo {\n\t\tdequeue(&x, &y);\n\t\tif(x == xgoal && y == ygoal) return 0;\n\t\tif(x < width && !visited[x + 1][y] && board[x + 1][y] == expectedcolor) enqueue(x + 1, y);\n\t\tif(y < height && !visited[x][y + 1] && board[x][y + 1] == expectedcolor) enqueue(x, y + 1);\n\t\tif(x < width && y < height && !visited[x + 1][y + 1] && board[x + 1][y + 1] == expectedcolor) enqueue(x + 1, y + 1);\n\n\t} while(head != tail);\n\treturn -1;\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nvoid dequeue(int *x, int *y)\n{\n\t*x = queue[head][0];\n\t*y = queue[head][1];\n\thead++;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[x][y]==0 || c==0)  return;\n  if(map[x][y]!=c && map[x][y]!=9)  return;\n  if(map[x][y]==9){\n    map[x][y]=7;\n    return;\n  } \n  map[x][y]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[N][N];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0)  break;\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    printf(\"%d %d\\n\",w[i],h[i]);\n    printf(\"%d %d\\n\",xs[i],ys[i]);\n    printf(\"%d %d\\n\",xg[i],yg[i]);\n    printf(\"%d\\n\",n[i]);\n    for(j=0;j<n[i];j++){\n      printf(\"%d %d %d %d\\n\",c[i][j],d[i][j],x[i][j],y[i][j]);\n    }\n  }\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<2;k++)\n          for(l=0;l<4;l++)\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n      }else if(d[i][j]==1){\n        for(k=0;k<4;k++)\n          for(l=0;l<2;l++)\n            map[x[i][j]+l][y[i][j]+k]=c[i][j];\n      }\n    }\n    map[xg[i]][yg[i]]=9;\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        printf(\"%d\",map[k][j]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n    printf(\"%d\\n\",map[xs[i]][ys[i]]);\n    search(map,xs[i],ys[i],map[xs[i]][ys[i]]);\n    if(map[xg[i]][yg[i]]==7)        printf(\"OK\\n\");\n    else if(map[xg[i]][yg[i]]==9)   printf(\"NG\\n\");\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        printf(\"%d\",map[k][j]);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"\\n\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 100\n#define M 500\n\nvoid search(int map[100][100],int x,int y,int c){\n  if(map[x][y]==0)  return;\n  if(map[x][y]==9){\n    map[x][y]=7;\n    return;\n  } \n  if(map[x][y]!=c)  return;\n  map[x][y]=7;\n  search(map,x-1,y,c);\n  search(map,x+1,y,c);\n  search(map,x,y-1,c);\n  search(map,x,y+1,c);\n}\n\nint main(void){\n  int i,num,j,k,l;\n  int w[N],h[N];\n  int xs[N],ys[N];\n  int xg[N],yg[N];\n  int n[N];\n  int c[N][M],d[N][M],x[N][M],y[N][M];\n  int map[100][100];\n\n  for(i=0;;i++){\n    scanf(\"%d%d\",&w[i],&h[i]);\n    if(w[i]==0 && h[i]==0)  break;\n    scanf(\"%d%d\",&xs[i],&ys[i]);\n    scanf(\"%d%d\",&xg[i],&yg[i]);\n    scanf(\"%d\",&n[i]);\n    for(j=0;j<n[i];j++){\n      scanf(\"%d%d%d%d\",&c[i][j],&d[i][j],&x[i][j],&y[i][j]);\n    }\n  }\n  num=i;\n  for(i=0;i<num;i++){\n    for(j=0;j<w[i];j++){\n      for(k=0;k<h[i];k++){\n        map[j][k]=0;\n      }\n    }\n    for(j=0;j<n[i];j++){\n      if(d[i][j]==0){\n        for(k=0;k<4;k++)\n          for(l=0;l<2;l++)\n            map[x[i][j]+k][y[i][j]+l]=c[i][j];\n      }else if(d[i][j]==1){\n        for(k=0;k<2;k++)\n          for(l=0;l<4;l++)\n            map[x[i][j]+k][y[i][j]+l]=c[i][j];\n      }\n    }\n    map[xg[i]][yg[i]]=9;\n    search(map,xs[i],ys[i],map[xs[i]][ys[i]]);\n    if(map[xg[i]][yg[i]]==7)  printf(\"OK\\n\");\n    else                      printf(\"NG\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-2 0207: Block\n// 2017.8.22 bal4u@uu\n// ??£?????§?????§?????? union set\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1252\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\ntypedef struct { int c, b; } M;\nM map[103][103];\n\nint x[2], y[2], b[2], col;  // start, goal's pos. color\n\nint tbl[2][12][2] = {\n{ { 0,-1 }, { 1,-1 }, { 2,-1 }, { 3,-1 }, { 4, 0 }, { 4, 1 },\n  { 3, 2 }, { 2, 2 }, { 1, 2 }, { 0, 2 }, {-1, 1 }, {-1, 0 } },\n{ { 0,-1 }, { 1,-1 }, { 2, 0 }, { 2, 1 }, { 2, 2 }, { 2, 3 },\n  { 1, 4 }, { 0, 4 }, {-1, 3 }, {-1, 2 }, {-1, 1 }, {-1, 0 } } };\n\nint main()\n{\n\n\tint w, h, n, c, d, x1, y1, x2, y2;\n\tint i, j, ng, on, xx, yy;\n\n\twhile (scanf(\"%d%d\", &w, &h) && w) {\n\t\tcol = 0, ng = 0, on = 0;\n\t\tmemset(map, 0, sizeof(map));\n\t\tscanf(\"%d%d%d%d%d\", x, y, x+1, y+1, &n);\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &c, &d, &x1, &y1);\n\t\t\tif (d) x2 = x1+1, y2 = y1+3;\n\t\t\telse   x2 = x1+3, y2 = y1+1;\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (x1 <= x[j] && x[j] <= x2 && y1 <= y[j] && y[j] <= y2) {\n\t\t\t\t\tb[j] = i, on++;\n\t\t\t\t\tif (!col) col = c;\n\t\t\t\t\telse if (col != c) ng = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmake_set(i);\n\t\t\tfor (xx = x1; xx <= x2; xx++) for (yy = y1; yy <= y2; yy++)\n\t\t\t\tmap[xx][yy].c = c, map[xx][yy].b = i;\n\t\t\tfor (j = 0; j < 12; j++) {\n\t\t\t\txx = x1 + tbl[d][j][0], yy = y1 + tbl[d][j][1];\n\t\t\t\tif (map[xx][yy].c == c) {\n\t\t\t\t\tint bb = map[xx][yy].b;\n\t\t\t\t\tif (find_set(i) != find_set(bb)) union_set(i, bb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs((!ng && on == 2 && p[b[0]] == p[b[1]]) ? \"OK\" : \"NG\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,n,a,b,c,d;\n  int by[]={0,0,1,1,0,0,1,1,2,2,3,3};\n  int bx[]={2,3,2,3,0,1,0,1,0,1,0,1};\n  int Y[]={1,0,-1,0};\n  int X[]={0,1,0,-1};\n  int y[10010],x[10010],gy,gx,ny,nx,i,j,t,r;\n  while(scanf(\"%d %d\",&w,&h),h){\n    scanf(\"%d %d %d %d %d\",&x[0],&y[0],&gx,&gy,&n);\n    int m[110][110]={};\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n      for(j=0;j<8;j++)m[d+by[j+b*4]+1][c+bx[j+b*4]+1]=a;\n    }\n    c=m[++y[0]][++x[0]];\n    m[y[t=0]][x[0]]=6;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(m[ny][nx]-c)continue;\n\tm[y[r]=ny][x[r]=nx]=6;\n\tr++;\n      }\n    }\n    printf(\"%s\\n\",m[gy][gx]-6?\"NG\":\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,n,a,b,c,d;\n  int by[]={0,0,1,1,0,0,1,1,2,2,3,3};\n  int bx[]={2,3,2,3,0,1,0,1,0,1,0,1};\n  int Y[]={1,0,-1,0};\n  int X[]={0,1,0,-1};\n  int y[100010],x[100010],gy,gx,ny,nx,i,j,t,r;\n  while(scanf(\"%d %d\",&w,&h),h){\n    scanf(\"%d %d %d %d %d\",&x[0],&y[0],&gx,&gy,&n);\n    int m[110][110]={};\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n      for(j=0;j<8;j++)m[d+by[j+b*4]][c+bx[j+b*4]]=a;\n    }\n    /*for(i=0;i<w;i++){\n      for(j=0;j<h;j++)printf(\"%d \",m[i][j]);printf(\"\\n\");\n      }//*/\n    c=m[y[0]][x[0]];\n    m[y[t=0]][x[0]]=6;\n    for(r=1;r-t&&c;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(m[ny][nx]-c)continue;\n\tm[y[r]=ny][x[r]=nx]=6;\n\tr++;\n      }\n    }\n    printf(\"%s\\n\",m[gy][gx]-6?\"NG\":\"OK\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define HORIZONTAL 0\n#define VERTICAL 1\n\n\nint board[101][101], visited[101][101];\t/* board[0][0]は使わない */\nint queue[10000][2], head = 0, tail = 0;\nint width, height, xgoal, ygoal;\n\nint bfs(int x, int y);\nvoid enqueue(int x, int y);\nvoid dequeue(int *x, int *y);\n\n\nint main()\n{\n\tint xstart, ystart, n, color, direction, x, y, blockw, blockh;\n\tint i, j, k;\n\twhile (1) {\n\t\tfor(i = 0; i < 101; i++) {\n\t\t\tfor(j = 0; j < 101; j++) {\n\t\t\t\tboard[i][j] = 0;\n\t\t\t\tvisited[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < 10000; i++) {\n\t\t\tfor(j = 0; j < 2; j++) {\n\t\t\t\tqueue[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tscanf(\"%d %d\", &width, &height);\n\t\tif(width == 0 && height == 0)\n\t\t\tbreak;\n\t\tscanf(\"%d %d\", &xstart, &ystart);\n\t\tscanf(\"%d %d\", &xgoal, &ygoal);\n\t\tscanf(\"%d\", &n);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d %d\", &color, &direction, &x, &y);\n\t\t\tswitch (direction) {\n\t\t\t\tcase HORIZONTAL:\n\t\t\t\t\tblockw = 4, blockh = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase VERTICAL:\n\t\t\t\t\tblockw = 2, blockh = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (j = 0; j < blockw; j++) {\n\t\t\t\tfor (k = 0; k < blockh; k++) {\n\t\t\t\t\tboard[x + j][y + k] = color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* BFS開始 */\n\t\tif(!bfs(xstart, ystart)) puts(\"OK\");\n\t\telse puts(\"NG\");\n\t}\n\treturn 0;\n}\n\nint bfs(int xstart, int ystart)\n{\n\tint x, y;\n\tint expectedcolor = board[xstart][ystart];\n\tenqueue(xstart, ystart);\n\tdo {\n\t\tdequeue(&x, &y);\n\t\tif(x == xgoal && y == ygoal) return 0;\n\t\tif(x < width && !visited[x + 1][y] && board[x + 1][y] == expectedcolor) enqueue(x + 1, y);\n\t\tif(y < height && !visited[x][y + 1] && board[x][y + 1] == expectedcolor) enqueue(x, y + 1);\n\t\tif(x > 1 && !visited[x - 1][y] && board[x - 1][y] == expectedcolor) enqueue(x - 1, y);\n\t\tif(y > 1 && !visited[x][y - 1] && board[x][y - 1] == expectedcolor) enqueue(x, y - 1);\n\n\t} while(head != tail);\n\treturn -1;\n\n}\n\nvoid enqueue(int x, int y)\n{\n\tvisited[x][y] = 1;\n\tqueue[tail][0] = x, queue[tail][1] = y;\n\ttail++;\n}\n\nvoid dequeue(int *x, int *y)\n{\n\t*x = queue[head][0];\n\t*y = queue[head][1];\n\thead++;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>?): Unit {\n    val neighbors = listOf(Point(1, 0), Point(-1, 0), Point(0, 1), Point(0, -1))\n    while(true){\n        val (w, h) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (w == 0 && h == 0) return\n        val board = Array(h){IntArray(w){0}}\n        val (sx, sy) = readLine()!!.trim().split(' ').map(String::toInt)\n        val (gx, gy) = readLine()!!.trim().split(' ').map(String::toInt)\n        val start = Point(sx - 1, sy - 1)\n        val goal = Point(gx - 1, gy - 1)\n        val n = readLine()!!.trim().toInt()\n        repeat(n){\n            val (c, d, x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n            for (cell in Block(Point(x - 1, y - 1), d).cells()) {\n                board[cell.y][cell.x] = c\n            }\n        }\n        val queue: Queue<Point> = LinkedList()\n        if (board[start.y][start.x] != 0) queue.add(start)\n        while(queue.isNotEmpty() && queue.peek() != goal){\n            val current = queue.poll()\n            for (neighbor in neighbors.map{it + current}) if (neighbor.y in 0 until h && neighbor.x in 0 until w && board[neighbor.y][neighbor.x] != 0){\n                if (board[current.y][current.x] == board[neighbor.y][neighbor.x]){\n                    queue.add(neighbor)\n                }\n            }\n            board[current.y][current.x] = 0\n        }\n        println(\n                if (queue.isNotEmpty()) \"OK\" else \"NG\"\n        )\n    }\n}\ndata class Point(val x: Int, val y: Int) {\n    operator fun plus(that: Point): Point = Point(x + that.x, y + that.y)\n}\ndata class Block(val position: Point, val state: Int) {\n    fun cells(): Iterable<Point> {\n        return when(state){\n            0 -> listOf(Point(0, 0), Point(1, 0), Point(2, 0), Point(3, 0),\n                    Point(0, 1), Point(1, 1), Point(2, 1), Point(3, 1)).map{it + position}\n            else -> listOf(Point(0, 0), Point(0, 1), Point(0, 2), Point(0, 3),\n                    Point(1, 0), Point(1, 1), Point(1, 2), Point(1, 3)).map{it + position}\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 && (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tchar[][] b = new char[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.next().charAt(0), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg] && b[xs][ys] != '0') {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void setBlock(char[][] b, char c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tpublic static void solid(char[][] b, char c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = '*';\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,xs,ys,xg,yg,n,c;\n\tstatic boolean f;\n\tstatic int[][] field;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin  = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tf=false;\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfield=new int[w+2][h+2];\n\t\t\txs=cin.nextInt();\n\t\t\tys=cin.nextInt();\n\t\t\txg=cin.nextInt();\n\t\t\tyg=cin.nextInt();\n\t\t\tn=cin.nextInt();\n\t\t\tfor(int i = 0;i<n;i++){\n\t\t\t\tint c = cin.nextInt();\n\t\t\t\tint d = cin.nextInt();\n\t\t\t\tint x = cin.nextInt();\n\t\t\t\tint y = cin.nextInt();\n\t\t\t\tif(d==0){\n\t\t\t\t\tfor(int j = 0;j<4;j++){\n\t\t\t\t\t\tfor(int k = 0;k<2;k++){\n\t\t\t\t\t\t\tfield[j+x][k+y]=c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j = 0;j<2;j++){\n\t\t\t\t\t\tfor(int k = 0;k<4;k++){\n\t\t\t\t\t\t\tfield[j+x][k+y]=c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i<w+2;i++){\n\t\t\t\tfor(int j = 0;j<h+2;j++){\n\t\t\t\t\t//System.out.print(field[j][i]);\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\tc = field[xs][ys];\n\t\t\tif(c==0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(xs,ys);\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\tstatic void dfs(int x,int y){\n\t\t//System.out.println(field[x][y]+\" \" + x+\" \" + y);\n\t\tfield[x][y]=0;\n\t\tif(x==xg&&y==yg){\n\t\t\tf=true;\n\t\t}\n\t\tfor(int i = 0;i<4;i++){\n\t\t\tint xx=x+v1[i];\n\t\t\tint yy=y+v2[i];\n\t\t\tif(field[xx][yy]==c){\n\t\t\t\tdfs(xx,yy);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint w, h;\n\tint sx, sy;\n\tint gx, gy;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\t\t\tif((w|h)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsx=sc.nextInt();\n\t\t\tsy=sc.nextInt();\n\t\t\tgx=sc.nextInt();\n\t\t\tgy=sc.nextInt();\n\t\t\tint n=sc.nextInt();\n\t\t\ta=new int[h][w];\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\tint c=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tint x=sc.nextInt();\n\t\t\t\tint y=sc.nextInt();\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\tif(d==0){\n\t\t\t\t\t\t\ta[y+j][x+i]=c;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tboolean[][] visited=new boolean[h][w];\n\t\tint c=a[sy][sx];\n\n\t\tque.offer(new P(sx, sy));\n\t\tvisited[sy][sx]=true;\n\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i]);\n\t\t\t\tif(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&a[q.y][q.x]==c\n\t\t\t\t\t\t&&!visited[q.y][q.x]){\n\t\t\t\t\tque.offer(q);\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(visited[gy][gx]?\"OK\":\"NG\");\n\t}\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x,y+1) || move(x-1,y) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfield = new int[102][102];\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0; i < 102; i++){\n\t\t\t\tfor(int j=0;j < 102; j++){\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tboolean ans;\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tans= false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = move(xs, ys);\n\t\t\t}\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "20 20 \n1 1\n9 9\n7\n2 0 1 1\n5 1 1 3\n2 1 3 3\n1 1 5 2\n5 1 7 3\n2 0 2 7\n2 0 6 8\n20 20\n9 9\n1 1\n6\n2 0 1 1\n1 0 5 1\n2 1 1 3\n5 0 1 7\n3 1 5 5\n4 1 8 5\n0 0"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 & (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tint[][] b = new int[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.nextInt(), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tstatic void setBlock(int[][] b, int c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tstatic void solid(int[][] b, int c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = -1;\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 && (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tchar[][] b = new char[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.next().charAt(0), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void setBlock(char[][] b, char c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tpublic static void solid(char[][] b, char c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = '*';\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tPoint s, g;\n\t\n\tint[][] map;\n\tboolean[][] visited;\n\t\n\tint dpx[] = {4, 2};\n\tint dpy[] = {2, 4};\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\ts = new Point(sc.nextInt(), sc.nextInt());\n\t\t\tg = new Point(sc.nextInt(), sc.nextInt());\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tvisited = new boolean[h+2][w+2];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tfor(int j=x;j<x+dpx[d];j++) for(int k=y;k<y+dpy[d];k++)\n\t\t\t\t\tmap[k][j] = c;\n\t\t\t}\n//\t\t\tfor(int i=0;i<h;i++) {\n//\t\t\t\tfor(int j=0;j<w;j++) System.out.print(map[i+1][j+1] + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\tif(dfs()) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NG\");\n\t\t}\n\t}\n\t\n\tboolean isGoal(Point p) {\n\t\treturn p.x == g.x && p.y == g.y;\n\t}\n\tboolean dfs() {\n\t\tLinkedList<Point> queue = new LinkedList<Point>();\n\t\tqueue.add(s);\n\t\tif( map[s.y][s.x] == 0) return false;\n\t\twhile(!queue.isEmpty()) {\n\t\t\tPoint p = queue.removeFirst();\n//\t\t\tSystem.out.println(p.x + \" \" + p.y + \" \" + map[p.y][p.x]);\n\t\t\tvisited[p.y][p.x]= true; \n\t\t\tif(isGoal(p)) return true;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tif(!visited[p.y+dy[i]][p.x+dx[i]] && map[p.y+dy[i]][p.x+dx[i]] == map[s.y][s.x])\n\t\t\t\t\tqueue.addLast(new Point(p.x+dx[i], p.y+dy[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tclass Point {\n\t\tint x, y;\n\t\tPoint(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\n\t    if(block[xs][ys]!=block[xg][yg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\n\t    int rc = block[xs][ys];\n\t    for(int i=1; i<w; i++)\n\t\tfor(int k=1; k<h; k++)\n\t\t    if(block[i][k]==rc) route[i][k] = true;\n\t    System.out.println(search(xs, ys, route) ? \"OK\":\"NG\");\n\t}\n    }\n\n    boolean search(int x, int y, boolean[][] r){\n\t//show();\n\tif(x==xg && y==yg)\n\t    return true;\n\t\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(route[a][b]){\n\t\t    r[x][y] = false;\n\t\t    if(search(a, b, r))\n\t\t\treturn true;\n\t\t    r[x][y] = true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[w][h];\n\troute = new boolean[w][h];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[a][b] = c;\n\t    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[a][b] = c;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] field;\n\tstatic int xg, yg;\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = s.nextInt();\n\t\t\th = s.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\n\t\t\tfield = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint xs = s.nextInt();\n\t\t\tint ys = s.nextInt();\n\t\t\txg = s.nextInt();\n\t\t\tyg = s.nextInt();\n\n\t\t\tint n = s.nextInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint c = s.nextInt();\n\t\t\t\tint d = s.nextInt();\n\t\t\t\tint x = s.nextInt();\n\t\t\t\tint y = s.nextInt();\n\n\t\t\t\tif (d == 0)\n\t\t\t\t\tfor (int k = x - 1; k < x + 3; k++)\n\t\t\t\t\t\tfor (int j = y - 1; j < y + 1; j++)\n\t\t\t\t\t\t\tfield[k][j] = c;\n\t\t\t\tif (d == 1)\n\t\t\t\t\tfor (int k = x - 1; k < x + 1; k++)\n\t\t\t\t\t\tfor (int j = y - 1; j < y + 3; j++)\n\t\t\t\t\t\t\tfield[k][j] = c;\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (field[i][j] != field[ys - 1][xs - 1])\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\n\t\t\tboolean b = false;\n\t\t\tif (field[ys - 1][xs - 1] > 0)\n\t\t\t\tb = search(xs, ys, field[ys - 1][xs - 1]);\n\t\t\tif (b)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t\ts.close();\n\t}\n\n\tstatic boolean search(int x, int y, int c) {\n\t\tfield[y][x] = 0;\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\tint[] dy = { -1, 0, 1, 0 };\n\t\tboolean b = false;\n\t\tif (x == xg - 1 && y == yg - 1)\n\t\t\tb = true;\n\t\telse {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h) {\n\t\t\t\t\tif (field[y + dy[i]][x + dx[i]] == c)\n\t\t\t\t\t\tb = search(x + dx[i], y + dy[i], c);\n\t\t\t\t\tif (b)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main{\n\n\tpublic static void main(String args[]){\n\t\tnew Main().mainrun();\n\t}\n\n\tprivate Scanner scan;\n\tprivate int W,H,startx,starty,goalx,goaly,N,baseC;\n\tprivate boolean flag = false;\n\tprivate int[][] F;\n\tprivate int[][] vec = {{-1,0},{0,1},{1,0},{0,-1}};\n\tprivate boolean[][] State;\n\tprivate Stack<Integer[]> stack;\n\n\tpublic void mainrun() {\n\n\t\tscan = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tW = scan.nextInt();\n\t\t\tH = scan.nextInt();\n\n\t\t\tif(W == 0 || H == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tF = new int[H + 2][W + 2];\n\t\t\tState = new boolean[H + 2][W + 2];\n\n\t\t\tfor(int i = 0;i < H + 2 ;i++) {\n\t\t\t\tArrays.fill(F[i],0);\n\t\t\t\tArrays.fill(State[i], false);\n\t\t\t}\n\n\t\t\tstartx = scan.nextInt();\n\t\t\tstarty = scan.nextInt();\n\n\t\t\tgoalx = scan.nextInt();\n\t\t\tgoaly = scan.nextInt();\n\n\t\t\tN = scan.nextInt();\n\n\t\t\tstack = new Stack<>();\n\n\t\t\tflag = false;\n\n\t\t\tfor(int i = 0;i < N ;i++) {\n\t\t\t\tint c = scan.nextInt();\n\t\t\t\tint d = scan.nextInt();\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\n\t\t\t\tfor(int j = y;j < y + (d == 0 ? 2 : 4);j++ ) {\n\t\t\t\t\tfor(int k = x;k < x + (d == 1 ? 2 : 4);k++) {\n\t\t\t\t\t\tF[j][k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbaseC = F[starty][startx];\n\n\t\t\tState[starty][startx] = true;\n\t\t\tstack.push(new Integer[] {startx,starty});\n\t\t\tmove();\n\n\n\t\t\tSystem.out.println(flag ? \"OK\" : \"NG\");\n\t\t}\n\t\tscan.close();\n\t}\n\n\tprivate void move() {\n\n\t\twhile(!stack.empty()) {\n\n\t\t\tInteger[] point = stack.pop();\n\t\t\tint x = point[0];\n\t\t\tint y = point[1];\n\n\t\t\tif(x == goalx && y == goaly || flag) {\n\t\t\t\tflag = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor(int i = 0;i < 4;i++) {\n\n\t\t\t\tint nx = x + vec[i][1];\n\t\t\t\tint ny = y + vec[i][0];\n\n\t\t\t\tif( nx == 0 || nx == W + 1 || ny == 0 || ny == H + 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(F[ny][nx] == baseC && !State[ny][nx]) {\n\t\t\t\t\tState[ny][nx] = true;\n\t\t\t\t\tstack.push(new Integer[] {nx,ny});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Data{\n\tint x;\n\tint y;\n\tpublic Data(int x,int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int W,H;\n\tstatic int map[][];\n\tstatic int C,xg,yg,judge=0;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tmap=new int[H+1][W+1];\n\t\t\tint xs=in.nextInt(),ys=in.nextInt();\n\t\t\txg=in.nextInt();yg=in.nextInt();\n\t\t\tint n=in.nextInt();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint c=in.nextInt(),d=in.nextInt();\n\t\t\t\tint x=in.nextInt(),y=in.nextInt();\n\t\t\t\tif(d==0)\n\t\t\t\t{\n\t\t\t\t\tfor(int h=y;h<y+2;h++)\n\t\t\t\t\t\tfor(int w=x;w<x+4;w++)\n\t\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int h=y;h<y+4;h++)\n\t\t\t\t\t\tfor(int w=x;w<x+2;w++)\n\t\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tC=map[ys][xs];\n\t\t\tif(C!=0&&solve(ys,xs)==1)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t}\n\n\tpublic static int solve(int h, int w)\n\t{\n\t\tif(h==yg&&w==xg)\n\t\t{\n\t\t\tjudge=1;\n\t\t\treturn judge;\n\t\t}\n\t\tmap[h][w]=0;\n\t\tif(h-1>=1&&map[h-1][w]==C)\n\t\t\tsolve(h-1,w);\n\t\tif(w-1>=1&&map[h][w-1]==C)\n\t\t\tsolve(h,w-1);\n\t\tif(h+1<=H&&map[h+1][w]==C)\n\t\t\tsolve(h+1,w);\n\t\tif(w+1<=W&&map[h][w+1]==C)\n\t\t\tsolve(h,w+1);\n\n\t\treturn judge;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x,y+1) || move(x-1,y) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfield = new int[102][102];\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0; i < 102; i++){\n\t\t\t\tfor(int j=0;j < 102; j++){\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tboolean ans;\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tans= false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = move(xs, ys);\n\t\t\t}\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\nclass Main{\n\tstatic int map[][];\n\tstatic int fl[][] = {{4, 2}, {2, 4}};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tString string, str[];\n\t\t\n\t\tint w, h, n, t[][], c, d, x, y;\n\t\tboolean visit[][], judge;\n\t\twhile(!(string = reader.readLine()).equals(\"0 0\")){\n\t\t\tstr = string.split(\" \");\n\t\t\tw = Integer.valueOf(str[0]);\n\t\t\th = Integer.valueOf(str[1]);\n\t\t\t\n\t\t\tmap = new int[w][h];\n\t\t\tvisit = new boolean[w][h];\n\t\t\tjudge = false;\n\t\t\t\n\t\t\tt = new int[2][2];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tt[i][0] = Integer.valueOf(str[0]) - 1;\n\t\t\t\tt[i][1] = Integer.valueOf(str[1]) - 1;\n\t\t\t}\n\t\t\tn = Integer.valueOf(reader.readLine());\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tc = Integer.valueOf(str[0]);\n\t\t\t\td = Integer.valueOf(str[1]);\n\t\t\t\tx = Integer.valueOf(str[2]) - 1;\n\t\t\t\ty = Integer.valueOf(str[3]) - 1;\n\t\t\t\t\n\t\t\t\tapp.set(c, d, x, y);\n\t\t\t}\n\t\t\t\n\t\t\tStack<int[]> s = new Stack<int[]>();\n\t\t\ts.push(t[0]);\n\t\t\t\n\t\t\tint sign = map[t[0][0]][t[0][1]];\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tint now[] = s.pop();\n\t\t\t\t\n\t\t\t\tif(now[0] < 0 || now[0] >= w || now[1] < 0 || now[1] >= h || visit[now[0]][now[1]] || map[now[0]][now[1]] != sign) continue;\n\t\t\t\tvisit[now[0]][now[1]] = true;\n\t\t\t\t\n\t\t\t\tif(now[0] == t[1][0] && now[1] == t[1][1]){\n\t\t\t\t\tjudge = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ts.push(new int[]{now[0] + 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0] - 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0], now[1] + 1});\n\t\t\t\ts.push(new int[]{now[0], now[1] - 1});\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(judge ? \"OK\" : \"NG\");\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic void set(int c, int d, int x, int y){\n\t\tfor(int i = 0; i < fl[d][0]; i++){\n\t\t\tfor(int j = 0; j < fl[d][1]; j++){\n\t\t\t\tmap[x + i][y + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\nclass Point {\n\tint x,y;\n\tPoint(int x,int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Main {\n\tpublic static void main(String args[]) {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString buf;\n\t\tint w,h,xs,ys,xg,yg,n,c,d,x,y;\n\n\t\ttry {\n\t\t\twhile (!(buf = br.readLine()).equals(\"0 0\")) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(buf);\n\t\t\t\tw = Integer.parseInt(st.nextToken());\n\t\t\t\th = Integer.parseInt(st.nextToken());\n\t\t\t\tint board[][] = new int[h][w];\n\t\t\t\tint check[][] = new int[h][w];\n\t\t\t\tfor (int i=0;i<h;i++) {\n\t\t\t\t\tArrays.fill(board[i],-1);\n\t\t\t\t\tArrays.fill(check[i],0);\n\t\t\t\t}\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\txs = Integer.parseInt(st.nextToken())-1;\n\t\t\t\tys = Integer.parseInt(st.nextToken())-1;\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\txg = Integer.parseInt(st.nextToken())-1;\n\t\t\t\tyg = Integer.parseInt(st.nextToken())-1;\n\t\t\t\tn = Integer.parseInt(br.readLine());\n\t\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t\tc = Integer.parseInt(st.nextToken());\n\t\t\t\t\td = Integer.parseInt(st.nextToken());\n\t\t\t\t\tx = Integer.parseInt(st.nextToken());\n\t\t\t\t\ty = Integer.parseInt(st.nextToken());\n\t\t\t\t\tPutBlock(board,x,y,c,d);\n\t\t\t\t}\n\t\t\t\tif (board[ys][xs]==-1) {\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean OK = false;\n\t\t\t\tPoint queue[] = new Point[h*w];\n\t\t\t\tint p = 0;\n\t\t\t\tqueue[p++] = new Point(xs,ys);\n\t\t\t\twhile (p>0) {\n\t\t\t\t\tPoint dq = queue[--p];\n\t\t\t\t\tcheck[dq.y][dq.x] = 1;\n\t\t\t\t\tif (dq.x==xg&&dq.y==yg) {\n\t\t\t\t\t\tOK = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (dq.x>0) {\n\t\t\t\t\t\tif (board[dq.y][dq.x-1]==board[dq.y][dq.x]&&check[dq.y][dq.x-1]==0) {\n\t\t\t\t\t\t\tqueue[p++] = new Point(dq.x-1,dq.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dq.x<w-1) {\n\t\t\t\t\t\tif (board[dq.y][dq.x+1]==board[dq.y][dq.x]&&check[dq.y][dq.x+1]==0) {\n\t\t\t\t\t\t\tqueue[p++] = new Point(dq.x+1,dq.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dq.y>0) {\n\t\t\t\t\t\tif (board[dq.y-1][dq.x]==board[dq.y][dq.x]&&check[dq.y-1][dq.x]==0) {\n\t\t\t\t\t\t\tqueue[p++] = new Point(dq.x,dq.y-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (dq.y<h-1) {\n\t\t\t\t\t\tif (board[dq.y+1][dq.x]==board[dq.y][dq.x]&&check[dq.y+1][dq.x]==0) {\n\t\t\t\t\t\t\tqueue[p++] = new Point(dq.x,dq.y+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (OK) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void PutBlock(int[][] b,int x,int y,int c,int target) {\n\t\tif (target==0) {\n\t\t\tfor (int i=y-1;i<y+1;i++) {\n\t\t\t\tfor (int j=x-1;j<x+3;j++) b[i][j] = c;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i=y-1;i<y+3;i++) {\n\t\t\t\tfor (int j=x-1;j<x+1;j++) b[i][j] = c;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void PrintBoard(int[][] b,int h,int w) {\n\t\tfor (int i=0;i<h;i++) {\n\t\t\tfor (int j=0;j<w;j++) System.out.print(b[i][j]+\" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 & (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tint[][] b = new int[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.nextInt(), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tstatic void setBlock(int[][] b, int c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tstatic void solid(int[][] b, int c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = -1;\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 1, 0, -1, -1, -1, 0, 1};\n    int[] dirY = {0, -1, -1, -1, 0, 1, 1, 1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\n\t    if(block[xs][ys]!=block[xg][yg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\n\t    int rc = block[xs][ys];\n\t    for(int i=1; i<w; i++)\n\t\tfor(int k=1; k<h; k++)\n\t\t    if(block[i][k]==rc) route[i][k] = true;\n\t    //show();\n\t    System.out.println(search(xs, ys, route) ? \"OK\":\"NG\");\n\t    //show();\n\t}\n    }\n\n    boolean search(int x, int y, boolean[][] r){\n\n\tif(x==xg && y==yg)\n\t    return true;\n\t\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(route[a][b]){\n\t\t    r[x][y] = false;\n\t\t    if(search(a, b, r))\n\t\t\treturn true;\n\t\t    r[x][y] = true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[w][h];\n\troute = new boolean[w][h];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[a][b] = c;\n\t    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[a][b] = c;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0207();\n\t}\n\t\n\t// WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[w+2][h+2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t\tint[] vx={1,0,-1,0}, vy={0,1,0,-1};\n\t\t\tint xx=sx, yy=sy, cc=b[sx][sy], v=0, count=0, max=w*h;\n\t\t\tif(cc<1){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tcount++;\n\t\t\t\tif(count>=max){\n\t\t\t\t\tout.println(\"NG\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(xx==gx && yy==gy && b[xx][yy]==cc){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//b[xx][yy]=6;\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"X\"+xx+\" Y\"+yy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\txx-=vx[v];\tyy-=vy[v];\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\t//out.println(\"END : X\"+xx+\" Y\"+yy);\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ1136(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tsolve1136(n);\n\t\t\tout.println(\"+++++\");\n\t\t}\n\t}\n\tvoid solve1136(int N){\t// N本の折れ線\n\t\t// 元の直線0\n\t\tint a0=sc.nextInt();\n\t\tint[] v0=new int[a0], len0=new int[a0];\n\t\tint lx=sc.nextInt(), ly=sc.nextInt();\n\t\tfor(int i=1; i<a0; i++){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tv0[i]=v1136(x,y,lx,ly);\n\t\t\tlen0[i]=max(abs(y-ly),abs(x-lx));\n\t\t\tlx=x;\tly=y;\n\t\t}\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tint a=sc.nextInt();\n\t\t\t//if(a!=a0)\tcontinue;\n\t\t\t// a!=a0で飛ばした時に読み込みがずれる\n\t\t\tint[] v=new int[a], len=new int[a];\n\t\t\tlx=sc.nextInt();\tly=sc.nextInt();\n\t\t\tfor(int j=1; j<a; j++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt();\n\t\t\t\tv[j]=v1136(x,y,lx,ly);\n\t\t\t\tlen[j]=max(abs(y-ly),abs(x-lx));\n\t\t\t\tlx=x;\tly=y;\n\t\t\t}\n\t\t\tif(a!=a0)\tcontinue;\n\t\t\tif(isSame(v0,len0,v,len))\tout.println(i);\n\t\t\telse if(isSame2(v0,len0,v,len))\tout.println(i);\n\t\t}\n\t}\n\tint v1136(int x, int y, int lx, int ly){\n\t\tif(y>ly)\treturn 1;\n\t\telse if(x>lx)\treturn 2;\n\t\telse if(y<ly)\treturn 3;\n\t\telse if(x<lx)\treturn 4;\n\t\treturn 0;\n\t}\n\tboolean isSame(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<len.length; i++){\n\t\t\tif(len0[i]!=len[i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tboolean isSame2(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tif(len0[i]!=len[v.length-i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[v.length-i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tint[] turn1136(int[] v, int n){\n\t\tif(n==0)\treturn v;\n\t\tint[] ans=new int[v.length];\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tans[i]=v[i]+n>4? 1: v[i]+n;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0141(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==1){\n\t\t\t\tout.println(\"#\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar[][] c=new char[n+1][n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=n; j++)\tc[i][j]=' ';\n\t\t\t}\n\t\t\tfor(int i=n; i>0; i--)\tc[1][i]='#';\n\t\t\tfor(int i=1; i<=n; i++)\tc[i][1]='#';\n\t\t\tif(n>2){\n\t\t\t\tfor(int i=1; i<=n; i++)\tc[n][i]='#';\n\t\t\t}\n\t\t\tif(n>3){\n\t\t\t\tfor(int i=n; i>2; i--)\tc[i][n]='#';\n\t\t\t}\n\t\t\tif(n>4){\n\t\t\t\tint[] vx={0, 1, 0, -1,1,1,-1,-1};\n\t\t\t\tint[] vy={-1, 0, 1, 0,-1,1,-1,1};\n\t\t\t\tc=solve141(3, n-1, n, c, vx, vy, 0);\n\t\t\t}\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tfor(int i=1; i<=n; i++)\tout.print(c[i][j]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tif(I!=N)\tout.println();\t// 最後のデータセットの改行\n\t\t}\n\t}\n\t// 今のx,y　n縦横　c版　vx,vy移動,　f方向\n\tchar[][] solve141(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\twhile(true){\n\t\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\tc[x][y]='#';\n\t\t\t\t//return solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tx=xx;\ty=yy;\n\t\t\t\tf= f+1<4? f+1: 0;\n\t\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\t\t//return solve141(x, y, n,c,vx,vy,f);\n\t\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\t\tbreak;\n\t\t}\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t// 再帰だとスタックオーバーフロー（手元では106まで行けたが）\n\tchar[][] solve141old(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\tboolean flag=true;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\treturn c;\n\t\t}\n\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\tc[x][y]='#';\n\t\t\treturn solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t}else{\n\t\t\tx=xx;\ty=yy;\n\t\t\tf= f+1<4? f+1: 0;\n\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\treturn solve141(x, y, n,c,vx,vy,f);\n\t\t\t}\n\t\t}\n\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t\n\tvoid AOJ0140(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt();\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tif(n>5){\n\t\t\t\tif(m<6){\n\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\tfor(int i=5; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t\t}else{\n\t\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=5; i>=0; i--)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=1; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\telse\tfor(int i=n; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t}\n\t\t\tsb.deleteCharAt(sb.length()-1);\n\t\t\tout.println(sb);\n\t\t}\n\t}\n\t\n\tvoid AOJ1135(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=sc.nextInt(), year=sc.nextInt(), n=sc.nextInt(), ans=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(sc.nextInt()==1)\tans=max(ans, huku(a,year,sc.nextDouble(),sc.nextInt()));\n\t\t\t\telse\tans=max(ans, tan(a,year,sc.nextDouble(), sc.nextInt()));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint huku(int a, int year, double rate, int t){\n\t\tfor(int i=0; i<year; i++){\n\t\t\tint temp=(int) (a*rate);\n\t\t\ta+=temp-t;\n\t\t}\n\t\treturn a;\n\t}\n\tint tan(int a, int year, double rate, int t){\n\t\tint r=0;\n\t\tfor(int i=0; i<year; i++){\n\t\t\tr+=a*rate;\n\t\t\ta-=t;\n\t\t}\n\t\treturn a+r;\n\t}\n\t\n\tvoid AOJ1142(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=1; i<s.length(); i++){\n\t\t\t\tString a=s.substring(0, i), b=s.substring(i);\n\t\t\t\tString aa=new StringBuilder(a).reverse().toString(), bb=new StringBuilder(b).reverse().toString();\n\t\t\t\t//out.println(\"A:\"+a+\" AA:\"+aa+\" B:\"+b+\" BB:\"+bb);\n\t\t\t\tmap.put(a+b,1);\n\t\t\t\tmap.put(aa+b,1);\n\t\t\t\tmap.put(a+bb,1);\n\t\t\t\tmap.put(aa+bb,1);\n\t\t\t\tmap.put(b+a,1);\n\t\t\t\tmap.put(bb+a, 1);\n\t\t\t\tmap.put(b+aa, 1);\n\t\t\t\tmap.put(bb+aa, 1);\n\t\t\t\t//out.println(map);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(map.size());\n\t\t}\n\t}\n\t\n\tvoid AOJ1137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=toInt(sc.next()),b=toInt(sc.next());\n\t\t\t//out.println(\"A:\"+a+\" B:\"+b);\n\t\t\tout.println(toMcxi(a+b));\n\t\t}\n\t}\n\tint toInt(String s){\n\t\tint ans=0,temp=1;\n\t\tchar[] c=s.toCharArray();\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tif(c[i]=='m'){\n\t\t\t\tans+=temp*1000;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='c'){\n\t\t\t\tans+=temp*100;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='x'){\n\t\t\t\tans+=temp*10;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='i'){\n\t\t\t\tans+=temp;\n\t\t\t\ttemp=1;\n\t\t\t}else{\n\t\t\t\ttemp=Character.digit(c[i],10);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tString toMcxi(int n){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tif(n/1000>0){\n\t\t\tsb.append(n/1000==1?\"m\":(n/1000)+\"m\");\n\t\t\tn%=1000;\n\t\t}\n\t\tif(n/100>0){\n\t\t\tsb.append(n/100==1?\"c\":(n/100)+\"c\");\n\t\t\tn%=100;\n\t\t}\n\t\tif(n/10>0){\n\t\t\tsb.append(n/10==1?\"x\":(n/10)+\"x\");\n\t\t\tn%=10;\n\t\t}\n\t\tif(n>0)\tsb.append(n==1?\"i\":n+\"i\");\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tlong s=sc.nextLong();\n\t\t\tout.println(\"Case \"+i+\":\");\n\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\ts*=s;\ts/=100;\ts%=10000;\n\t\t\t\tout.println(s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t    ArrayList<Integer> prime = new ArrayList<Integer>();\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for (int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            prime.add(i);\n\t            for (int j=i+i; j<=N; j+=i)    list[j] = false;\n\t        }\n\t    }\n\t    return prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for(int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            for (int j=i+i; j<=N; j+=i)     list[j] = false;\n\t        }\n\t    }\n\t    return list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t    for(int i=2; i*i<=n; i++){\n\t        if(n%i==0)     return false;\n\t    }\n\t    return true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Block\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tint[][] m = new int[h][w];\n\t\t\tint sj = sc.nextInt()-1;\n\t\t\tint si = sc.nextInt()-1;\n\t\t\tint gj = sc.nextInt()-1;\n\t\t\tint gi = sc.nextInt()-1;\n\t\t\tint n = sc.nextInt();\n\t\t\twhile(n--!=0){\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint tj = sc.nextInt()-1;\n\t\t\t\tint ti = sc.nextInt()-1;\n\t\t\t\tif(d==0)for(int i=0;i<2;i++)for(int j=0;j<4;j++)m[ti+i][tj+j]=c;\n\t\t\t\telse for(int i=0;i<4;i++)for(int j=0;j<2;j++)m[ti+i][tj+j]=c;\n\t\t\t}\n\t\t\tif(m[si][sj]==0||m[gi][gj]==0||m[si][sj]!=m[gi][gj]){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint x = m[si][sj];\n\t\t\tboolean f = false;\n\t\t\tboolean[][] v = new boolean[h][w];\n\t\t\tv[si][sj] = true;\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tl.add(new int[]{si,sj});\n\t\t\twhile(!l.isEmpty()){\n\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\tfor(int a[] : l){\n\t\t\t\t\tint i = a[0];\n\t\t\t\t\tint j = a[1];\n\t\t\t\t\tif(i==gi&&j==gj){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!v[ni][nj]&&m[ni][nj]==x){\n\t\t\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\t\t\tnext.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(f?\"OK\":\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int w, h;\n\tstatic int a[][];\n\n\tpublic static void f(int x, int y, int c) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y) {\n\t\t\treturn ;\n\t\t}\n\t\tif (a[y][x] != c) {\n\t\t\treturn ;\n\t\t}\n\t\ta[y][x] = -1;\n\t\tf(x + 1, y, c);\n\t\tf(x - 1, y, c);\n\t\tf(x, y + 1, c);\n\t\tf(x, y - 1, c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint sx, sy;\n\t\tint gx, gy;\n\t\tint dx0[] = {0, 0, 1, 1, 2, 2, 3, 3};\n\t\tint dy0[] = {0, 1, 0, 1, 0, 1, 0, 1};\n\t\tint dx1[] = {0, 0, 0, 0, 1, 1, 1, 1};\n\t\tint dy1[] = {0, 1, 2, 3, 0, 1, 2, 3};\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsx = sc.nextInt() - 1;\n\t\t\tsy = sc.nextInt() - 1;\n\t\t\tgx = sc.nextInt() - 1;\n\t\t\tgy = sc.nextInt() - 1;\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[h][w];\n\t\t\twhile (n-- != 0) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (d == 0) {\n\t\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t\ta[y + dy0[i]][x + dx0[i]] = c;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t\ta[y + dy1[i]][x + dx1[i]] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tf(sx, sy, a[sy][sx]);\n\t\t\tif (a[sy][sx] == 0 || a[gy][gx] == 0) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t} else if (0 <= a[gy][gx]) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y;\n\tint[][] map;\n\tint[][] visit;\n\tboolean flag = false;\n\t\n\tvoid loop(int p, int q, int r){\n\t\tif(p==yg && q==xg) flag = true;\n\t\tvisit[p][q] = 1;\n\t\t\n\t\tif(visit[p][q+1]==0 && map[p][q+1]==r) loop(p,q+1,r);\n\t\tif(visit[p+1][q]==0 && map[p+1][q]==r) loop(p+1,q,r);\n\t\tif(visit[p][q-1]==0 && map[p][q-1]==r) loop(p,q-1,r);\n\t\tif(visit[p-1][q]==0 && map[p-1][q]==r) loop(p-1,q,r);\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0) return;\n\t\t\txs = sc.nextInt();\n\t\t\tys = sc.nextInt();\n\t\t\txg = sc.nextInt();\n\t\t\tyg = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tflag = false;\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tvisit = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc = sc.nextInt();\n\t\t\t\td = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tif(d==0){\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y][x+j]=c;\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+1][x+j]=c;\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+j][x]=c;\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+j][x+1]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(map[ys][xs]==0) flag = false;\n\t\t\telse loop(xs, ys, map[ys][xs]);\n\t\t\tif(flag==true) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NG\");\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[]{-1,0,1,0},dy = new int[]{0,-1,0,1};\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tMainLoop : while(true){\n\t\t\tint w = Integer.parseInt(scan.next());\n\t\t\tint h = Integer.parseInt(scan.next());\n\t\t\tif(w==0) break;\n\t\t\tbyte[][] map = new byte[h][w];\n\n\t\t\tint sx = Integer.parseInt(scan.next())-1;\n\t\t\tint sy = Integer.parseInt(scan.next())-1;\n\t\t\tint gx = Integer.parseInt(scan.next())-1;\n\t\t\tint gy = Integer.parseInt(scan.next())-1;\n\t\t\tint n = Integer.parseInt(scan.next());\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbyte c = scan.nextByte();\n\t\t\t\tint d = Integer.parseInt(scan.next());\n\t\t\t\tint x = Integer.parseInt(scan.next())-1;\n\t\t\t\tint y = Integer.parseInt(scan.next())-1;\n\t\t\t\tfor (int j = 0; j < (d==0 ? 2 : 4) ; j++)\n\t\t\t\t\tfor (int j2 = 0; j2 < (d==0 ? 4 : 2) ; j2++)\n\t\t\t\t\t\tmap[j+y][j2+x] = c;\n\n\t\t\t}\n\n\t\t\tif(map[sy][sx]==0){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint color = map[sy][sx];\n\t\t\tLinkedList<int[]> que = new LinkedList<int[]>();\n\t\t\tque.offer(new int[]{sx,sy});\n\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tint[] pos = que.poll();\n\t\t\t\tmap[pos[1]][pos[0]]=0;\n\t\t\t\tif(pos[0]==gx && pos[1]==gy){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tcontinue MainLoop;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = pos[0]+dx[i],ny = pos[1]+dy[i];\n\t\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && color==map[ny][nx])\n\t\t\t\t\t\tque.offer(new int[]{nx,ny});\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(\"NG\");\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint xs = scanner.nextInt();\n\t\t\tint ys = scanner.nextInt();\n\t\t\txg = scanner.nextInt();\n\t\t\tyg = scanner.nextInt();\n\t\t\tint n = scanner.nextInt();\n\t\t\tmap = new int[h + 2][w + 2];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (d == 0) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tmap[j + y][k + x] = c;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\t\tmap[j + y][k + x] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor = map[ys][xs];\n\t\t\tb = new boolean[h + 2][w + 2];\n\t\t\tif (color == 0)\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\telse\n\t\t\t\tSystem.out.println(slove(xs, ys) ? \"OK\" : \"NG\");\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int x, int y) {\n\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\tpq.add(new Point(y, x, getDis(x, y)));\n\t\tb[y][x] = true;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPoint point = pq.poll();\n\t\t\tx = point.x;\n\t\t\ty = point.y;\n\n\t\t\tif (point.dis == 0)\n\t\t\t\treturn true;\n\n\t\t\tfor (int[] a : dxy) {\n\t\t\t\tint dx = a[1] + x;\n\t\t\t\tint dy = a[0] + y;\n\t\t\t\tif (b[dy][dx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (map[dy][dx] != color)\n\t\t\t\t\tcontinue;\n\t\t\t\tpq.add(new Point(dy, dx, getDis(dx, dy)));\n\t\t\t\tb[dy][dx] = true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate int getDis(int x, int y) {\n\t\treturn Math.abs(yg - y) + Math.abs(xg - x);\n\t}\n\n\tclass Point implements Comparable<Point> {\n\t\tint y;\n\t\tint x;\n\t\tint dis;\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.dis - o.dis;\n\t\t}\n\n\t\tpublic Point(int y, int x, int dis) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.dis = dis;\n\t\t}\n\t}\n\n\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tboolean[][] b;\n\tint[][] map;\n\tint xg;\n\tint yg;\n\tint color;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tint xs = scanner.nextInt();\n\t\t\tint ys = scanner.nextInt();\n\t\t\txg = scanner.nextInt();\n\t\t\tyg = scanner.nextInt();\n\t\t\tint n = scanner.nextInt();\n\t\t\tmap = new int[h + 2][w + 2];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tint d = scanner.nextInt();\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (d == 0) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tmap[j + y][k + x] = c;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\t\tmap[j + y][k + x] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolor = map[ys][xs];\n\t\t\tb = new boolean[h + 2][w + 2];\n\t\t\tif (color == 0)\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\telse\n\t\t\t\tSystem.out.println(slove(xs, ys) ? \"OK\" : \"NG\");\n\t\t}\n\n\t}\n\n\tprivate boolean slove(int x, int y) {\n\t\tb[y][x] = true;\n\t\tif (map[y][x] != color)\n\t\t\treturn false;\n\t\tif (y == yg && x == xg)\n\t\t\treturn true;\n\t\tfor (int[] a : dxy) {\n\t\t\tint dx = a[1] + x;\n\t\t\tint dy = a[0] + y;\n\t\t\tif (b[dy][dx])\n\t\t\t\tcontinue;\n\t\t\tif (slove(dx, dy))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tboolean[][] b;\n\tint[][] map;\n\tint xg;\n\tint yg;\n\tint color;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\n\t    if(block[xs][ys]==0 || block[xs][ys]!=block[xg][yg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\n\t    int rc = block[xs][ys];\n\t    for(int i=1; i<w; i++)\n\t\tfor(int k=1; k<h; k++)\n\t\t    if(block[i][k]==rc) route[i][k] = true;\n\t    System.out.println(search(xs, ys, route) ? \"OK\":\"NG\");\n\t}\n    }\n\n    boolean search(int x, int y, boolean[][] r){\n\t//show();\n\tif(x==xg && y==yg)\n\t    return true;\n\t\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(r[a][b]){\n\t\t    r[x][y] = false;\n\t\t    if(search(a, b, r))\n\t\t\treturn true;\n\t\t    r[x][y] = true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"o\":\"x\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[w][h];\n\troute = new boolean[w][h];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[a][b] = c;\n\t    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[a][b] = c;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] str;\n\t\tString line;\n\t\tint w,h,sx,sy,gx,gy,n;\n\t\tBlock b;\n\t\t\n\t\twhile(true){\n\t\t\tline = sc.nextLine();\n\t\t\tstr = line.split(\" \");\n\t\t\tif(str[0].equals(\"0\") && str[1].equals(\"0\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = Integer.valueOf(str[0]);\n\t\t\th = Integer.valueOf(str[1]);\n\t\t\tline = sc.nextLine();\n\t\t\tstr = line.split(\" \");\n\t\t\tsx = Integer.valueOf(str[0]);\n\t\t\tsy = Integer.valueOf(str[1]);\n\t\t\tline = sc.nextLine();\n\t\t\tstr = line.split(\" \");\n\t\t\tgx = Integer.valueOf(str[0]);\n\t\t\tgy = Integer.valueOf(str[1]);\n\t\t\tb = new Block(w,h,sx,sy,gx,gy);\n\t\t\t\n\t\t\tline = sc.nextLine();\n\t\t\tn = Integer.valueOf(line);\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tb.setBlock(sc.nextLine());\n\t\t\t}\n\t\t\t\n\t\t\tif(b.getResult()){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Block{\n\tint[][] board;\n\tint w,h,sx,sy,gx,gy,c;\n\t\n\tBlock(int w,int h,int sx,int sy,int gx,int gy){\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\tboard = new int[w+1][h+1];\n\t\tthis.sx = sx;\n\t\tthis.sy = sy;\n\t\tthis.gx = gx;\n\t\tthis.gy = gy;\n\t}\n\t\n\tpublic boolean getResult(){\n\t\tc = board[sx][sy];\n\t\t\n\t\treturn checkRoute(c,sx,sy);\n\t}\n\t\n\tprivate boolean checkRoute(int c,int x,int y){\n\t\tboolean result = false;\n\t\t\n\t\tif((x==gx) && (y==gy)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tboard[x][y] = -1;\n\t\tif(x-1 > 0){\n\t\t\tif(board[x-1][y] == c){\n\t\t\t\tresult = checkRoute(c,x-1,y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(x+1 < w+1){\n\t\t\tif(board[x+1][y] == c){\n\t\t\t\tresult = checkRoute(c,x+1,y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y-1 > 0){\n\t\t\tif(board[x][y-1] == c){\n\t\t\t\tresult = checkRoute(c,x,y-1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y+1 < h+1){\n\t\t\tif(board[x][y+1] == c){\n\t\t\t\tresult = checkRoute(c,x,y+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tpublic void setBlock(String line){\n\t\tString[] str = line.split(\" \");\n\t\tint c,d,x,y;\n\t\tc = Integer.valueOf(str[0]);\n\t\td = Integer.valueOf(str[1]);\n\t\tx = Integer.valueOf(str[2]);\n\t\ty = Integer.valueOf(str[3]);\n\t\tif(d == 0){\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tboard[y+i][x+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tboard[y+i][x+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0207();\n\t}\n\t\n\tvoid AOJ1114(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint[][] b=new int[5][5];\n\t\t\tfor(int y=0; y<5; y++){\n\t\t\t\tfor(int x=0; x<5; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=0; i<5; i++){\n\t\t\t\tfor(int j=0; j<5; j++){\n\t\t\t\t\tif(b[i][j]==1)\tans=max(ans,solve1114(i,j,b));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint solve1114(int x,int y,int[][] b){\n\t\tint ans=0;\n\t\tfor(int i=0; i+x<5; i++){\n\t\t\tif(b[i+x][y]==0)\tbreak;\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j+y<5; j++){\n\t\t\t\tfor(int k=0; k<=i; k++){\n\t\t\t\t\tfor(int l=0; l<=j; l++){\n\t\t\t\t\t\tif(b[k+x][l+y]==0){\n\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!flag)\tbreak;\n\t\t\t\tans=max(ans,(i+1)*(j+1));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint step=0;\n\t// バックトラック（TLE）\n\tvoid AOJ1126(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++)\tc[x][y]=line.charAt(x);\n\t\t\t}\n\t\t\tString ans=\"\";\n\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\tif(Character.isDigit(c[x][y])){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]) && c[x-1][y]!='0')\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]) && c[x][y-1]!='0')\tcontinue;\n\t\t\t\t\t\tif(c[x][y]=='0')\tcontinue;\n\t\t\t\t\t\tString temp=solve1126(x,y,\"\"+c[x][y],c,W,H);\n\t\t\t\t\t\tans=compara1126(temp,ans)?temp:ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\t// TODO debug\n\t\tout.println(step+\"steps\");\n\t}\n\tString solve1126(int x,int y,String ans,char[][] c,int W,int H){\n\t\tString r=ans;\n\t\t//TODO debug\n\t\tstep++;\n\t\t//out.println(ans);\n\t\tfor(int i=1; i<3; i++){\n\t\t\tint xx=x+vx[i], yy=y+vy[i];\n\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\tString temp=solve1126(xx,yy,ans+c[xx][yy],c,W,H);\n\t\t\t\tr=compara1126(r,temp)?r:temp;\n\t\t\t\tout.println(temp);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\t// 第一引数aの方が大きい時のみtrue\n\tboolean compara1126(String a,String b){\n\t\tif(a.length()>b.length())\treturn true;\n\t\tif(a.length()==b.length()){\n\t\t\tfor(int i=0; i<a.length(); i++){\n\t\t\t\tif(a.charAt(i)>b.charAt(i))\treturn true;\n\t\t\t\tif(a.charAt(i)<b.charAt(i))\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t// 横型探索（TLE）\n\tvoid OldAOJ1126(){\n\t\tint step=0;\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tString ans=\"\";\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tString[][] close=new String[W][H];\n\t\t\tLinkedList<C1126> open=new LinkedList<C1126>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(Character.isDigit(line.charAt(x))){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]))\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]))\tcontinue;\n\t\t\t\t\t\topen.add(new C1126(x,y,\"\"+c[x][y]));\n\t\t\t\t\t\tclose[x][y]=\"\"+c[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1126 now=open.poll();\n\t\t\t\t// TODO debug\n\t\t\t\tout.println(\"ANS\"+ans+\" NOW\"+now.ans);\n\t\t\t\tans=now.compara(ans)?new String(now.ans):ans;\n\t\t\t\tfor(int i=1; i<3; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\t\t\tC1126 temp=new C1126(xx,yy,now.ans+c[xx][yy]);\n\t\t\t\t\t\tif(close[xx][yy]==null){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}else if(temp.compara(close[xx][yy])){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.println(step+\"step\");\n\t}\n\tclass C1126{\n\t\tint x,y;\tString ans;\n\t\tC1126(int x,int y,String ans){\n\t\t\tthis.x=x;\tthis.y=y;\n\t\t\tif(ans.length()>0){\n\t\t\t\tint i=0;\n\t\t\t\twhile(ans.charAt(i)=='0'){\n\t\t\t\t\tif(++i>=ans.length()-1)\tbreak;\n\t\t\t\t\tans=ans.substring(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ans=ans;\n\t\t}\n\t\tboolean compara(String ans){\n\t\t\tif(this.ans.length()>ans.length())\treturn true;\n\t\t\tif(this.ans.length()==ans.length()){\n\t\t\t\tfor(int i=0; i<ans.length(); i++){\n\t\t\t\t\tif(ans.charAt(i)<this.ans.charAt(i))\treturn true;\n\t\t\t\t\tif(ans.charAt(i)>this.ans.charAt(i))\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ0165(){\n\t\tfinal int MAX=1000000;\n\t\tboolean[] prime=Sieve(MAX);\n\t\tint[] prime2=new int[MAX+1];\n\t\tfor(int i=2; i<=MAX; i++)\tprime2[i]=(prime[i]?prime2[i-1]+1:prime2[i-1]);\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint p=sc.nextInt(), m=sc.nextInt();\n\t\t\t\tint min=max(1,p-m), max=min(MAX, p+m);\n\t\t\t\tint temp=prime2[max]-prime2[min-1];\n\t\t\t\t//out.println(\"TEMP\"+temp);\n\t\t\t\tans+=temp-1;\n\t\t\t}\n\t\t\tout.println(max(0,ans));\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt();\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// TODO 果樹園　RE　横型\n\tvoid AOJ0118(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(), ans=0;\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X+10][Y+10];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\t\tif(c[x][y]=='&')\tcontinue;\n\t\t\t\t\tans++;\n\t\t\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\tchar mark=c[x][y];\n\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\tc[now.x][now.y]='&';\n\t\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]==mark){\n\t\t\t\t\t\t\t\t//out.println((now.x+vx[i])+\" \"+(now.y+vy[i]));\n\t\t\t\t\t\t\t\topen.add(new Point(now.x+vx[i],now.y+vy[i]));\n\t\t\t\t\t\t\t\tc[now.x+vx[i]][now.y+vy[i]]='&';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//out.println(\"ANS\"+ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// Red and Black 横型探索\n\tvoid AOJ1130(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(),sx=0,sy=0,ans=0;\n\t\t\tif(X==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line[x];\n\t\t\t\t\tif(line[x]=='@'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tboolean[][] close=new boolean[X][Y];\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tans++;\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]=='.' && !close[now.x+vx[i]][now.y+vy[i]]){\n\t\t\t\t\t\topen.add(new Point(now.x+vx[i], now.y+vy[i]));\n\t\t\t\t\t\tclose[now.x+vx[i]][now.y+vy[i]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// TODO デパート　TLE MLE WA\n\tvoid AOJ0223(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(),\tY=sc.nextInt();\n\t\t\tif(X==0)\tbreak;\n\t\t\tint tx=sc.nextInt(), ty=sc.nextInt(), kx=sc.nextInt(), ky=sc.nextInt();\n\t\t\tint[][] b=new int[X+1][Y+1];\n\t\t\tfor(int y=1; y<=Y; y++){\n\t\t\t\tfor(int x=1; x<=X; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<C0223> open=new LinkedList<C0223>();\n\t\t\topen.add(new C0223(tx,ty,kx,ky,0));\n\t\t\tint[][][][] close2=new int[X+1][Y+1][X+1][Y+1];\n\t\t\tclose2[tx][ty][kx][ky]=-1;\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC0223 now=open.poll();\n\t\t\t\tif(now.ans()){\n\t\t\t\t\tans=now.sec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.sec>=99)\tbreak;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(0<now.tx+vx[i]&&now.tx+vx[i]<=X && 0<now.ty+vy[i]&&now.ty+vy[i]<=Y && 0<now.kx-vx[i]&&now.kx-vx[i]<=X && 0<now.ky-vy[i]&&now.ky-vy[i]<=Y){\n\t\t\t\t\t\ttx=now.tx;\tty=now.ty;\tkx=now.kx;\tky=now.ky;\n\t\t\t\t\t\tif(b[tx+vx[i]][ty+vy[i]]==0){\n\t\t\t\t\t\t\ttx+=vx[i];\tty+=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[kx-vx[i]][ky-vy[i]]==0){\n\t\t\t\t\t\t\tkx-=vx[i];\tky-=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//out.println(\"TEMP:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t//if(tx==kx && ty==ky)\tans=ans<0?now.sec+1:min(ans,now.sec+1);\n\t\t\t\t\t\tif(close2[tx][ty][kx][ky]==0 || close2[tx][ty][kx][ky]>now.sec+1){\n\t\t\t\t\t\t\t//out.println(\"ADD:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t\topen.add(new C0223(tx,ty,kx,ky,now.sec+1));\n\t\t\t\t\t\t\tclose2[tx][ty][kx][ky]=now.sec+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tclass C0223{\n\t\tint tx,ty,kx,ky,sec;\n\t\tC0223(int tx, int ty, int kx, int ky, int sec){\n\t\t\tthis.tx=tx;\tthis.ty=ty;\tthis.kx=kx;\tthis.ky=ky;\tthis.sec=sec;\n\t\t}\n\t\tboolean ans(){\n\t\t\tif(this.tx==this.kx && this.ty==this.ky)\treturn true;\n\t\t\telse\treturn false;\n\t\t}\n\t}\n\t\n\t\n\t// TODO WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\t\n\t// TODO レゴ　WA\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[W+1][H+1];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO debug\n\t\t\t//de0207(b,W,H);\n\t\t\tint c=b[sx][sy];\n\t\t\tif(c==0){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\tboolean[][] close=new boolean[W+1][H+1];\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tclose[sx][sy]=true;\n\t\t\tString ans=\"NG\";\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W+1, H+1, 1))\tcontinue;\n\t\t\t\t\tif(b[xx][yy]!=c)\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t\tif(xx==gx && yy==gy){\n\t\t\t\t\t\tans=\"OK\";\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t\tArrayList<Integer> prime = new ArrayList<Integer>();\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[1]=false;\n\t\tfor (int i=2; i<=N; i++) {\n\t\t\tif(list[i]) {\n\t\t\t\tprime.add(i);\n\t\t\t\tfor (int j=i+i; j<=N; j+=i)\tlist[j] = false;\n\t\t\t}\n\t\t}\n\t\treturn prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[0]=false;\tlist[1]=false;\n\t\tfor(int j=4; j<=N; j+=2)\tlist[j]=false;\n\t\tfor(int i=3; i*i<=N; i+=2)\tif(list[i])\tfor (int j=i+i; j<=N; j+=i)\tlist[j]=false;\n\t\treturn list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t\tfor(int i=2; i*i<=n; i++){\n\t\t\tif(n%i==0)     return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic boolean solve() {\n\t\tint w = in.nextInt();\n\t\tint h = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\tint gx = in.nextInt(), gy = in.nextInt();\n\n\t\tint[][] t = new int[h][w];\n\t\tint n = in.nextInt();\n\t\tfor (int k=0; k<n; k++) {\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tint x = in.nextInt();\n\t\t\tint y = in.nextInt();\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int i=y; i<y+2; i++) {\n\t\t\t\t\tfor (int j=x; j<x+4; j++) {\n\t\t\t\t\t\tt[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i=y; i<y+4; i++) {\n\t\t\t\t\tfor (int j=x; j<x+2; j++) {\n\t\t\t\t\t\tt[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t[sy][sx] == 0 || t[gy][gx] == 0) {\n\t\t\tout.println(\"NG\");\n\t\t\treturn true;\n\t\t}\n\n\t\tint[] dx = { 0, 1, 0,-1};\n\t\tint[] dy = { 1, 0,-1, 0};\n\n\t\tboolean[][] visited = new boolean[h][w];\n\t\tArrayDeque<int[]> que = new ArrayDeque<>();\n\t\tque.add(new int[]{sy, sx});\n\t\tvisited[sy][sx] = true;\n\n\t\twhile (que.size() > 0) {\n\t\t\tint[] tmp = que.pollFirst();\n\t\t\tint y = tmp[0];\n\t\t\tint x = tmp[1];\n\n\t\t\tif (y == gy && x == gx) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i=0; i<4; i++) {\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tif (ny < 0 || nx < 0 || w <= nx || h <= ny) continue;\n\t\t\t\tif (t[y][x] != t[ny][nx]) continue;\n\t\t\t\tif (visited[ny][nx]) continue;\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\tque.add(new int[]{ny, nx});\n\t\t\t}\n\t\t}\n\n\t\tif (visited[gy][gx]) {\n\t\t\tout.println(\"OK\");\n\t\t} else {\n\t\t\tout.println(\"NG\");\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//0207\n\tstatic class Block{\n\t\tvoid print_answer() {\n\t\t\tfor(;;) {\n\t\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\t// fieldと座標を合わせるための-1\n\t\t\t\tint xs = sc.nextInt()-1, ys = sc.nextInt()-1,\n\t\t\t\t\txg = sc.nextInt()-1, yg = sc.nextInt()-1;\n\t\t\t\tint n = sc.nextInt();\n\n\t\t\t\tint[][] field = new int[h][w];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tint[] block = new int[4];\n\t\t\t\t\tfor(int j=0; j<4; j++) {block[j] = sc.nextInt();}\n\t\t\t\t\tif(block[1] == 0) {\n\t\t\t\t\t\tfor(int j=0; j<2; j++) {\n\t\t\t\t\t\t\tfor(int k=0; k<4; k++) {\n\t\t\t\t\t\t\t\tfield[block[3]-1 + j][block[2]-1 + k] = block[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(block[1] == 1) {\n\t\t\t\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\t\t\t\tfor(int k=0; k<2; k++) {\n\t\t\t\t\t\t\t\tfield[block[3]-1 + j][block[2]-1 + k] = block[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tQueue<Point> que = new LinkedList<Point>();\n\t\t\t\tPoint start = new Point(ys, xs);\n\t\t\t\tPoint goal = new Point(yg, xg);\n\t\t\t\tque.offer(start);\n\n\t\t\t\tint[] dir_y = {-1, 0, 1, 0};\n\t\t\t\tint[] dir_x = { 0, 1, 0,-1};\n\t\t\t\tboolean ans = false;\n\t\t\t\tint mark = field[start.y][start.x];\n\t\t\t\twhile(!que.isEmpty()) {\n\t\t\t\t\tPoint point = que.poll();\n\t\t\t\t\tif(point.y == goal.y && point.x == goal.x) {\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\t\tint ny = point.y + dir_y[i], nx = point.x + dir_x[i];\n\t\t\t\t\t\tif(ny >= 0 && nx >= 0 && ny < h && nx < w) {\n\t\t\t\t\t\t\tif(field[ny][nx] == mark && field[ny][nx] != 0) {\n\t\t\t\t\t\t\t\tque.offer(new Point(ny, nx));\n\t\t\t\t\t\t\t\tfield[ny][nx] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ans) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Point {\n\t\tpublic int y, x;\n\t\tpublic Point(int y, int x) {\n\t\t\tthis.y = y; this.x = x;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tBlock b = new Block();\n\t\tb.print_answer();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    boolean[][] visit;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n    Stack<int[]> st;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    visit = new boolean[h][w];\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search() ? \"OK\":\"NG\");\n\t}\n    }\n\n    boolean search(){\n\tst = new Stack<int[]>();\n\tgetGO(xs, ys);\n\n\twhile(!st.empty()){\n\t    int[] p = st.pop();\n\t    visit[p[1]][p[0]] = true;\n\t    if(p[0]==xg && p[1]==yg) return true;\n\t    getGO(p[0], p[1]);\n\t}\n\treturn false;\n    }\n\n    void getGO(int x, int y){ \n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a] && !visit[b][a]){\n\t\tint[] p = { a, b };\n\t\tst.push(p);\n\t    }\n\t}\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 1, 0, -1, -1, -1, 0, 1};\n    int[] dirY = {0, -1, -1, -1, 0, 1, 1, 1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\n\t    if(block[xs][ys]!=block[xg][yg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\n\t    int rc = block[xs][ys];\n\t    for(int i=1; i<w; i++)\n\t\tfor(int k=1; k<h; k++)\n\t\t    if(block[i][k]==rc) route[i][k] = true;\n\t    System.out.println(search(xs, ys, route) ? \"OK\":\"NG\");\n\t}\n    }\n\n    boolean search(int x, int y, boolean[][] r){\n\t//show();\n\tif(x==xg && y==yg)\n\t    return true;\n\t\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(route[a][b]){\n\t\t    r[x][y] = false;\n\t\t    if(search(a, b, r))\n\t\t\treturn true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[w][h];\n\troute = new boolean[w][h];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[a][b] = c;\n\t    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[a][b] = c;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 && (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tint[][] b = new int[101][101];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.nextInt(), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void setBlock(int[][] b, int c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tpublic static void solid(int[][] b, int c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = -1;\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y;\n\tint[][] map;\n\tint[][] visit;\n\t\n\tvoid loop(int p, int q, int r){\n\t\tvisit[p][q] = 1;\n\t\t\n\t\tif(visit[p][q+1]==0 && map[p][q+1]==r) loop(p,q+1,r);\n\t\tif(visit[p+1][q]==0 && map[p+1][q]==r) loop(p+1,q,r);\n\t\tif(visit[p][q-1]==0 && map[p][q-1]==r) loop(p,q-1,r);\n\t\tif(visit[p-1][q]==0 && map[p-1][q]==r) loop(p-1,q,r);\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0) return;\n\t\t\txs = sc.nextInt();\n\t\t\tys = sc.nextInt();\n\t\t\txg = sc.nextInt();\n\t\t\tyg = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tvisit = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc = sc.nextInt();\n\t\t\t\td = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tif(d==0){\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y][x+j]=c;\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+1][x+j]=c;\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+j][x]=c;\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+j][x+1]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(map[ys][xs]==0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}else{\n\t\t\t\tloop(xs, ys, map[ys][xs]);\n\t\t\t\tif(visit[yg][xg]==1) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\t\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[][] map;\n\tint w, h;\n\tint sx, sy, gx, gy;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tsx = sc.nextInt();\n\t\t\tsy = sc.nextInt();\n\t\t\tgx = sc.nextInt();\n\t\t\tgy = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tfor(int j=x;j<(d==0? x+4:x+2);j++) for(int k=y;k<(d==0? y+2:y+4);k++) \n\t\t\t\t\tmap[k][j] = c;\n\t\t\t}\n//\t\t\tfor(int[] a: map) debug(a);\n\t\t\tif(bfs()) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NG\");\n\t\t}\n\t}\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tboolean bfs() {\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\tboolean visited[][] = new boolean[h+2][w+2];\n\t\tif(map[sy][sx] == 0) return false;\n\t\tque.add(new P(sx, sy, 0));\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP now = que.removeFirst();\n//\t\t\tdebug(now.x, now.y, now.c);\n\t\t\tif(now.x == gx && now.y == gy) return true;\n\t\t\tfor(int i=0;i<4;i++) if(!visited[now.y+dy[i]][now.x+dx[i]] && map[now.y+dy[i]][now.x+dx[i]]==map[now.y][now.x]){\n\t\t\t\tvisited[now.y+dy[i]][now.x+dx[i]] = true;\n\t\t\t\tque.add(new P(now.x+dx[i], now.y+dy[i],now.c+1));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tclass P {\n\t\tint x, y, c;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tc=0;\n\t\t}\n\t\tP(int x, int y, int c) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic class State{\n\t\tint x,y, cost;\n\t\tState(int x,int y, int cost){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t\tthis.cost=cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint w=sc.nextInt();\n\t\t\t\tint h=sc.nextInt();\n\t\t\t\tif(w+h==0) break;\n\t\t\t\tint xs=sc.nextInt();\n\t\t\t\tint ys=sc.nextInt();\n\t\t\t\tint xg=sc.nextInt();\n\t\t\t\tint yg=sc.nextInt();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tint[][] field=new int[h+1][w+1];\n\t\t\t\tint color=0;\n\t\t\t\twhile(n-->0) {\n\t\t\t\t\tint c=sc.nextInt();\n\t\t\t\t\tint d=sc.nextInt();\n\t\t\t\t\tint x=sc.nextInt();\n\t\t\t\t\tint y=sc.nextInt();\n\t\t\t\t\tif(d==0) {\n\t\t\t\t\t\tfor(int i=0; i<2; i++) {\n\t\t\t\t\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\t\t\t\t\tfield[y+i][x+j]=c;\n\t\t\t\t\t\t\t\tif(y+i==ys && x+j==xs) color=c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\t\t\tfor(int j=0; j<2; j++) {\n\t\t\t\t\t\t\t\tfield[y+i][x+j]=c;\n\t\t\t\t\t\t\t\tif(y+i==ys && x+j==xs) color=c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQueue<State> q=new LinkedList<>();\n\t\t\t\tint[][] minstep=new int[h+1][w+1];\n\t\t\t\tint INF=100000000;\n\t\t\t\tint[] dx= {1, 0, -1, 0};\n\t\t\t\tint[] dy= {0, 1, 0, -1};\n\t\t\t\tfor(int i=1; i<=h; i++) {\n\t\t\t\t\tfor(int j=1; j<=w; j++) {\n\t\t\t\t\t\tminstep[i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tq.add(new State(xs, ys, 0));\n\t\t\t\twhile(!q.isEmpty()) {\n\t\t\t\t\tState state=q.poll();\n\t\t\t\t\tif(minstep[state.y][state.x]<INF) continue;\n\t\t\t\t\tminstep[state.y][state.x]=state.cost;\n\t\t\t\t\tif(state.x==xg&&state.y==yg) break;\n\t\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\t\tif(state.x+dx[i]<1 || state.x+dx[i]>w || state.y+dy[i]<1 || state.y+dy[i]>h) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[state.y+dy[i]][state.x+dx[i]]==color) {\n\t\t\t\t\t\t\tq.add(new State(state.x+dx[i], state.y+dy[i], state.cost+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(minstep[yg][xg]==INF? \"NG\":\"OK\");\n\t\t\t\tq.clear();\n\t\t\t}\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x-1,y) || move(x,y+1) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tif(ys == goaly && xs == goalx){\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean ans = move(xs, ys);\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\n/**\n * Block\n */\npublic class P0207 {\n\n\tstatic int[][] board;\n\tfinal static int BLOCK_WIDTH = 4;\n\tfinal static int BLOCK_HEIGHT = 2;\n\tfinal static int EMPTY = 0;\n\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0 0\")) {\n\n\t\t\tw = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\th = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tboard = new int[w + 1][h + 1];\n\n\t\t\tline = br.readLine();\n\t\t\tint xs = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint ys = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tline = br.readLine();\n\t\t\tint xg = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint yg = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tputBlock(br.readLine());\n\t\t\t}\n\n\t\t\tif (solve(xs, ys, xg, yg)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic void putBlock(String info) {\n\t\tStringTokenizer st = new StringTokenizer(info);\n\n\t\tint c, d, x, y;\n\t\tc = Integer.parseInt(st.nextToken());\n\t\td = Integer.parseInt(st.nextToken());\n\t\tx = Integer.parseInt(st.nextToken());\n\t\ty = Integer.parseInt(st.nextToken());\n\n\t\tputBlock(c, d, x, y);\n\t}\n\n\tstatic void putBlock(int c, int d, int x, int y) {\n\n\t\tif (d == 0) {\n\t\t\tfor (int i = x; i < x + BLOCK_WIDTH; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_HEIGHT; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = x; i < x + BLOCK_HEIGHT; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_WIDTH; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean solve(int xs, int ys, int xg, int yg) {\n\n\t\tfinal int V[] = { 1, -1, 0, 0 };\n\t\tfinal int H[] = { 0, 0, 1, -1 };\n\n\t\tif (board[xs][ys] != board[xg][yg]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint[] next, prev;\n\t\tnext = new int[] { xs, ys };\n\t\tArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n\t\tqueue.offer(next);\n\n\t\twhile (!queue.isEmpty()) {\n\n\t\t\tprev = queue.poll();\n\n\t\t\tint px, py, nx, ny, c;\n\t\t\tpx = prev[0];\n\t\t\tpy = prev[1];\n\t\t\tc = board[px][py];\n\t\t\tboard[px][py] = EMPTY;\n\n\t\t\tif (px == xg && py == yg) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tnx = px + V[i];\n\t\t\t\tny = py + H[i];\n\t\t\t\tif (nx > 0 && nx < w + 1 && ny > 0 && ny < h + 1) {\n\t\t\t\t\tif (board[nx][ny] == c) {\n\t\t\t\t\t\tqueue.offer(new int[] { nx, ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x-1,y) || move(x,y+1) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tboolean ans;\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tans= false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = move(xs, ys);\n\t\t\t}\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int W,H;\n\tstatic int map[][];\n\tstatic int C,xg,yg,judge=0;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tmap=new int[H+1][W+1];\n\t\t\tint xs=in.nextInt(),ys=in.nextInt();\n\t\t\txg=in.nextInt();yg=in.nextInt();\n\t\t\tint n=in.nextInt();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint c=in.nextInt(),d=in.nextInt();\n\t\t\t\tint x=in.nextInt(),y=in.nextInt();\n\t\t\t\tif(d==0)\n\t\t\t\t{\n\t\t\t\t\tfor(int h=y;h<y+2;h++)\n\t\t\t\t\t\tfor(int w=x;w<x+4;w++)\n\t\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int h=y;h<y+4;h++)\n\t\t\t\t\t\tfor(int w=x;w<x+2;w++)\n\t\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tC=map[ys][xs];\n\t\t\tif(C!=0&&solve(ys,xs)==1)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t}\n\n\tpublic static int solve(int h, int w)\n\t{\n\t\tif(h==yg&&w==xg)\n\t\t{\n\t\t\tjudge=1;\n\t\t\treturn judge;\n\t\t}\n\t\tmap[h][w]=6;\n\t\tif(h-1>=1&&map[h-1][w]==C)\n\t\t\tsolve(h-1,w);\n\t\tif(w-1>=1&&map[h][w-1]==C)\n\t\t\tsolve(h,w-1);\n\t\tif(h+1<=H&&map[h+1][w]==C)\n\t\t\tsolve(h+1,w);\n\t\tif(w+1<=W&&map[h][w+1]==C)\n\t\t\tsolve(h,w+1);\n\n\t\treturn judge;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    if(block[ys][xs]==0 || block[ys][xs]!=block[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\n\t    makeRoute();\n\t    //show();\n\t    System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      マンハッタン距離が近くなるように道を選ぶ\n      選べなければ行ける所に行く\n      どこにも行けなければほげ。\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(route[b][a] && getD(a, b)<d){\n\t\t    if(search(a, b)) return true;\n\t\t}\n\t\telse if(route[b][a])\n\t\t    if(search(a, b)) return true;\n\t    }\n\t}\n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"o\":\"x\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "//Volume2-0207\nimport java.util.ArrayDeque;\nimport java.util.Scanner;\n\nclass Cell {\n\tpublic int x,y;\n\tCell(int x,int y){\n\t\tthis.x=x; this.y=y;\n\t}\n}\n\nclass Main {\n\n\tprivate static final int              MARK      = 9;\n\tprivate static       int\t          w,h,color;\n\tprivate static final int[][]          chk       = {{-1,0},{0,-1},{1,0},{0,1}};\n\tprivate static       int[][]          board;\n\tprivate static       ArrayDeque<Cell> q         = new ArrayDeque<Cell>();\n\n\tpublic static void main(String[] args){\n\n\t\tint xs,ys,xg,yg,n;\n\t\tString result;\n\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0&&h==0){break;}\n\t\t\tresult = \"\";\n\t\t\tboard = new int[h][w];\n\t\t\txs = sc.nextInt()-1; ys = sc.nextInt()-1;\n\t\t\txg = sc.nextInt()-1; yg = sc.nextInt()-1;\n\t\t\tn  = sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tpaint(sc.nextInt(),sc.nextInt(),sc.nextInt()-1,sc.nextInt()-1);\n\t\t\t}\n\t\t\tif   (search(xs,ys,xg,yg)){result = \"OK\";}\n\t\t\telse                      {result = \"NG\";}\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n\tprivate static void paint(int c,int d,int x,int y){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tif(d==1){\n\t\t\t\t\tboard[y+i][x+j] = c;\n\t\t\t\t} else {\n\t\t\t\t\tboard[y+j][x+i] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean search(int xs,int ys,int xg,int yg){\n\n\t\tboolean ret = false;\n\n\t\tcolor = board[ys][xs];\n\t\tq.clear();\n\t\tq.add(new Cell(xs,ys));\n\n\t\twhile(!q.isEmpty()){\n\t\t\tCell cl = q.poll();\n\t\t\tif(cl.x==xg&&cl.y==yg){\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}else {\n\t\t\t\tboard[cl.y][cl.x] = MARK;\n\t\t\t\tsetAroundCell(cl);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static void setAroundCell(Cell cl){\n\t\tint x,y;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tx = cl.x+chk[i][0];\n\t\t\ty = cl.y+chk[i][1];\n\t\t\tif(0 <= y && y < h && 0 <= x && x < w){\n\t\t\t\tif(board[y][x] == color){\n\t\t\t\t\tq.add(new Cell(x,y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int w, h;\n\tstatic int a[][];\n\n\tpublic static void f(int x, int y, int c) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y) {\n\t\t\treturn ;\n\t\t}\n\t\tif (a[y][x] != c) {\n\t\t\treturn ;\n\t\t}\n\t\ta[y][x] = -1;\n\t\tf(x + 1, y, c);\n\t\tf(x - 1, y, c);\n\t\tf(x, y + 1, c);\n\t\tf(x, y - 1, c);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint sx, sy;\n\t\tint gx, gy;\n\t\tint dx0[] = {0, 0, 1, 1, 2, 2, 3, 3};\n\t\tint dy0[] = {0, 1, 0, 1, 0, 1, 0, 1};\n\t\tint dx1[] = {0, 0, 0, 0, 1, 1, 1, 1};\n\t\tint dy1[] = {0, 1, 2, 3, 0, 1, 2, 3};\n\t\t\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsx = sc.nextInt() - 1;\n\t\t\tsy = sc.nextInt() - 1;\n\t\t\tgx = sc.nextInt() - 1;\n\t\t\tgy = sc.nextInt() - 1;\n\t\t\tn = sc.nextInt();\n\t\t\ta = new int[h][w];\n\t\t\twhile (n-- != 0) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tif (d == 0) {\n\t\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t\ta[y + dy0[i]][x + dx0[i]] = c;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t\ta[y + dy1[i]][x + dx1[i]] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"before\");\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tSystem.out.printf(\"%3d\", a[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tf(sx, sy, a[sy][sx]);\n\t\t\tSystem.out.println(\"after\");\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tSystem.out.printf(\"%3d\", a[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tif (0 <= a[gy][gx]) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 1, 0, -1, -1, -1, 0, 1};\n    int[] dirY = {0, -1, -1, -1, 0, 1, 1, 1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==0 && h==0) break;\n\t    put();\n\n\t    if(block[xs][ys]!=block[xg][yg]){\n\t\tSystem.out.println(\"NG\");\n\t\tbreak;\n\t    }\n\n\t    int rc = block[xs][ys];\n\t    for(int i=1; i<w; i++)\n\t\tfor(int k=1; k<h; k++)\n\t\t    if(block[i][k]==rc) route[i][k] = true;\n\t    //show();\n\t    System.out.println(search(xs, ys, route) ? \"OK\":\"NG\");\n\t    //show();\n\t}\n    }\n\n    boolean search(int x, int y, boolean[][] r){\n\tint dx = Math.abs(xg-x);\n\tint dy = Math.abs(yg-y);\n\n\tif(x==xg && y==yg)\n\t    return true;\n\t\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tint ndx = Math.abs(xg-a);\n\t\tint ndy = Math.abs(yg-b);\n\t\tif(route[a][b]){\n\t\t    r[x][y] = false;\n\t\t    if(search(a, b, r))\n\t\t\treturn true;\n\t\t    r[x][y] = true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[w][h];\n\troute = new boolean[w][h];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[a][b] = c;\n\t    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[a][b] = c;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    public static int[][] board;\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while (true){\n            String[] line0 = br.readLine().split(\" \");\n            int w = Integer.parseInt(line0[0]);\n            int h = Integer.parseInt(line0[1]);\n            if (w == 0 && h == 0){\n                break;\n            }\n            String[] line1 = br.readLine().split(\" \");\n            String[] line2 = br.readLine().split(\" \");\n            int xs = Integer.parseInt(line1[0]);\n            int ys = Integer.parseInt(line1[1]);\n            int xg = Integer.parseInt(line2[0]);\n            int yg = Integer.parseInt(line2[1]);\n            int n = Integer.parseInt(br.readLine());\n            board = new int[h][w];\n            for (int i = 0; i < n; i++){\n                String[] linei = br.readLine().split(\" \");\n                int c = Integer.parseInt(linei[0]);\n                int d = Integer.parseInt(linei[1]);\n                int x = Integer.parseInt(linei[2]);\n                int y = Integer.parseInt(linei[3]);\n                setBlock(c, d, x, y, w, h);\n            }\n            //System.out.println(Arrays.deepToString(board));\n            if (dfs(xs, ys, xg, yg, w, h)){\n                System.out.println(\"OK\");\n            }else{\n                System.out.println(\"NG\");\n            }\n        }\n    }\n    static void setBlock(int c, int d, int x, int y, int w, int h){\n        // add an block to the static board\n        if (d == 0){\n            for (int i = y - 1; i < y + 1; i++){\n                for (int j = x - 1; j < x + 3; j++){\n                    board[i][j] = c;\n                }\n            }\n        }else{ // d == 1\n            for (int i = y - 1; i < y + 3; i++){\n                for (int j = x - 1; j < x + 1; j++){\n                    board[i][j] = c;\n                }\n            }\n        }\n        //System.out.println(Arrays.deepToString(board));\n    }\n    static boolean dfs(int xs, int ys, int xg, int yg, int w, int h){\n        // dfs (xs, ys) to (xg, yg)\n        boolean[][] visited = new boolean[h][w];\n        List<Integer> ls = new ArrayList<Integer>(2);\n        ls.add(xs);\n        ls.add(ys);\n        visited[ys-1][xs-1] = true;\n        int color = board[ys-1][xs-1];\n        List<List<Integer>> stack = new ArrayList<List<Integer>>();\n        stack.add(ls);\n        \n        while (stack.size() > 0){\n            \n            List<Integer> tls = stack.remove(stack.size()-1);\n            \n            int txs = tls.get(0);\n            int tys = tls.get(1);\n            int tcolor = board[tys - 1][txs - 1];\n            int[][] nextcells = {{txs + 1, tys}, {txs - 1, tys}, {txs, tys + 1}, {txs, tys - 1}};\n            for (int i = 0; i < 4; i++){\n                int nextx = nextcells[i][0];\n                int nexty = nextcells[i][1];\n                //System.out.println(nextx + \" \" + nexty);\n                \n                if (1 <= nextx && nextx <= w && 1 <= nexty && nexty <= h && !visited[nexty-1][nextx-1]){\n                    int nextcolor = board[nexty-1][nextx-1];\n                    visited[nexty -1 ][nextx -1] = true;\n                    if (tcolor == nextcolor){\n                        if (nextx == xg && nexty == yg){\n                            return true;\n                        }\n                        List<Integer> nextls = new ArrayList<Integer>();\n                        nextls.add(nextx);\n                        nextls.add(nexty);\n                        stack.add(nextls);\n                        \n                    }\n                }\n            }\n        }\n\t\treturn false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic int w;\n\tstatic int h;\n\tstatic int xs;\n\tstatic int ys;\n\tstatic int xg;\n\tstatic int yg;\n\tstatic int[][] map;\n\tstatic int co;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tw = stdIn.nextInt();\n\t\t\th = stdIn.nextInt();\n\t\t\tif (w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmap = new int[h][w];\n\t\t\txs = stdIn.nextInt();\n\t\t\tys = stdIn.nextInt();\n\t\t\txg = stdIn.nextInt();\n\t\t\tyg = stdIn.nextInt();\n\t\t\tint n = stdIn.nextInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint c = stdIn.nextInt();\n\t\t\t\tint d = stdIn.nextInt();\n\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\tint y = stdIn.nextInt();\n\n\t\t\t\tif (d == 0) {\n\t\t\t\t\tfor (int j = y - 1; j < y + 1; j++) {\n\t\t\t\t\t\tfor (int k = x - 1; k < x + 3; k++) {\n\t\t\t\t\t\t\tmap[j][k] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j = y - 1; j < y + 3; j++) {\n\t\t\t\t\t\tfor (int k = x - 1; k < x + 1; k++) {\n\t\t\t\t\t\t\tmap[j][k] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans;\n\t\t\tco = map[ys-1][xs-1];\n\t\t\tans = solv(xs - 1, ys - 1);\n\t\t\tSystem.out.println((ans) ? \"OK\" : \"NG\");\n\t\t}\n\t}\n\t\n\tstatic boolean solv(int x, int y) {\n\t\t\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return false;\n\t\tif(map[y][x] != co) return false;\n\t\tif(y == yg-1 && x == xg-1) return true;\n\t\tmap[y][x] = -1;\n \t\tif(solv(x+1,y)) return true;\n\t\tif(solv(x-1,y)) return true;\n\t\tif(solv(x,y+1)) return true;\n\t\tif(solv(x,y-1)) return true;\n\t\t\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x,y+1) || move(x-1,y) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tboolean ans;\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tans= false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = move(xs, ys);\n\t\t\t}\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\nclass Main{\n\tstatic int map[][];\n\tstatic int fl[][] = {{4, 2}, {2, 4}};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tString string, str[];\n\t\t\n\t\tint w, h, n, t[][], c, d, x, y;\n\t\tboolean visit[][], judge;\n\t\twhile(!(string = reader.readLine()).equals(\"0 0\")){\n\t\t\tstr = string.split(\" \");\n\t\t\tw = Integer.valueOf(str[0]);\n\t\t\th = Integer.valueOf(str[1]);\n\t\t\t\n\t\t\tmap = new int[w][h];\n\t\t\tvisit = new boolean[w][h];\n\t\t\tjudge = false;\n\t\t\t\n\t\t\tt = new int[2][2];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tt[i][0] = Integer.valueOf(str[0]) - 1;\n\t\t\t\tt[i][1] = Integer.valueOf(str[1]) - 1;\n\t\t\t}\n\t\t\tn = Integer.valueOf(reader.readLine());\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tc = Integer.valueOf(str[0]);\n\t\t\t\td = Integer.valueOf(str[1]);\n\t\t\t\tx = Integer.valueOf(str[2]) - 1;\n\t\t\t\ty = Integer.valueOf(str[3]) - 1;\n\t\t\t\t\n\t\t\t\tapp.set(c, d, x, y);\n\t\t\t}\n\t\t\t\n\t\t\tStack<int[]> s = new Stack<int[]>();\n\t\t\ts.push(t[0]);\n\t\t\t\n\t\t\tint sign = map[t[0][0]][t[0][1]];\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tint now[] = s.pop();\n\t\t\t\t\n\t\t\t\tif(now[0] == t[1][0] && now[1] == t[1][1]){\n\t\t\t\t\tjudge = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now[0] < 0 || now[0] >= w || now[1] < 0 || now[1] >= h || visit[now[0]][now[1]] || map[now[0]][now[1]] != sign) continue;\n\t\t\t\tvisit[now[0]][now[1]] = true;\n\t\t\t\t\n\t\t\t\ts.push(new int[]{now[0] + 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0] - 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0], now[1] + 1});\n\t\t\t\ts.push(new int[]{now[0], now[1] - 1});\n\t\t\t}\n\t\t\t\n\t\t\tif(judge) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NG\");\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic void set(int c, int d, int x, int y){\n\t\tfor(int i = 0; i < fl[d][0]; i++){\n\t\t\tfor(int j = 0; j < fl[d][1]; j++){\n\t\t\t\tmap[x + i][y + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\n\npublic class Main{\n\tstatic int[][] ban;\n\tstatic int[][] visited;\n\tstatic int[] xv= {0,1,0,-1};\n\tstatic int[] yv= {1,0,-1,0};\n\tstatic int w,h,sx,sy,gx,gy;\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\twhile(true) {\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\t\t\tif(h*w==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsx=sc.nextInt();\n\t\t\tsy=sc.nextInt();\n\t\t\tgx=sc.nextInt();\n\t\t\tgy=sc.nextInt();\n\t\t\tban=new int[h+2][w+2];\n\t\t\tvisited=new int[h+2][w+2];\n\t\t\tfor(int i=0; i<=h+1; i++) {\n\t\t\t\tfor(int j=0; j<=w+1; j++) {\n\t\t\t\t\tban[i][j]=0;\t\t//クソガバ初期化\n\t\t\t\t\tvisited[i][j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tint color=sc.nextInt();\n\t\t\t\tint muki=sc.nextInt();//0 1\n\t\t\t\tint xx=sc.nextInt();\n\t\t\t\tint yy=sc.nextInt();\n\t\t\t\tif(muki==0) {\n\t\t\t\t\tban[yy][xx]+=color;\t\t//いもす\n\t\t\t\t\tban[yy+1][xx]+=color;\n\t\t\t\t\tban[yy][xx+4]-=color;\n\t\t\t\t\tban[yy+1][xx+4]-=color;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\tban[yy][xx]+=color;\t//いもす\n\t\t\t\t\t\tban[yy+1][xx]+=color;\n\t\t\t\t\t\tban[yy+2][xx]+=color;\n\t\t\t\t\t\tban[yy+3][xx]+=color;\n\t\t\t\t\t\tban[yy][xx+2]-=color;\n\t\t\t\t\t\tban[yy+1][xx+2]-=color;\n\t\t\t\t\t\tban[yy+2][xx+2]-=color;\n\t\t\t\t\t\tban[yy+3][xx+2]-=color;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<=h+1; i++) {\n\t\t\t\tfor(int j=0; j<w+1; j++) {\n\t\t\t\t\tban[i][j+1]=ban[i][j]+ban[i][j+1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfs(sx,sy,ban[sy][sx]);\n\t\t\tif(visited[gy][gx]==1) {\n\t\t\t\tpl(\"OK\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpl(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void dfs(int x,int y,int color) {\n\t\tif(visited[y][x]==0) {\n\t\t\tvisited[y][x]=1;\n\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\tif(0<=x+xv[i] && x+xv[i]<=w && 0<=y+yv[i] && y+yv[i]<=h) {\n\t\t\t\t\tif(visited[y+yv[i]][x+xv[i]]==0 && color==ban[y+yv[i]][x+xv[i]]) {\n\t\t\t\t\t\tdfs(x+xv[i],y+yv[i],color);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static class Walk{\n\t\tint x,y;\n\t\t\n\t\tpublic Walk(int x, int y){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\t\n\t\t\tfinal int sx = sc.nextInt() - 1;\n\t\t\tfinal int sy = sc.nextInt() - 1;\n\t\t\t\n\t\t\tfinal int gx = sc.nextInt() - 1;\n\t\t\tfinal int gy = sc.nextInt() - 1;\n\t\t\t\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int color = sc.nextInt();\n\t\t\t\tfinal int d = sc.nextInt();\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < (d == 0 ? 2 : 4); j++){\n\t\t\t\t\tfor(int k = 0; k < (d == 0 ? 4 : 2); k++){\n\t\t\t\t\t\tmap[y + j][x + k] = color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int j = 0; j < h; j++){\n//\t\t\t\tfor(int k = 0; k < w; k++){\n//\t\t\t\t\tSystem.out.print(map[j][k] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tboolean[][] is_visited = new boolean[h][w];\n\t\t\tLinkedList<Walk> queue = new LinkedList<Walk>();\n\t\t\t//int color = map[sy][sx];\n\t\t\t\n\t\t\tif(map[sy][sx] != map[gy][gx]){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tqueue.add(new Walk(sx,sy));\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk k = queue.poll();\n\t\t\t\t\n\t\t\t\tif(is_visited[k.y][k.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(k.x == gx && k.y == gy){\n\t\t\t\t\tis_visited[k.y][k.x] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[k.y][k.x] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k.x != 0 && !is_visited[k.y][k.x - 1] && map[k.y][k.x] == map[k.y][k.x - 1]){\n\t\t\t\t\tqueue.add(new Walk(k.x - 1, k.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k.x != w - 1 && !is_visited[k.y][k.x + 1] && map[k.y][k.x] == map[k.y][k.x + 1]){\n\t\t\t\t\tqueue.add(new Walk(k.x + 1, k.y));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k.y != 0 && !is_visited[k.y - 1][k.x] && map[k.y][k.x] == map[k.y - 1][k.x]){\n\t\t\t\t\tqueue.add(new Walk(k.x, k.y - 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(k.y != h - 1 && !is_visited[k.y + 1][k.x] && map[k.y][k.x] == map[k.y + 1][k.x]){\n\t\t\t\t\tqueue.add(new Walk(k.x, k.y + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif(is_visited[gy][gx]){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0207();\n\t}\n\t\n\tvoid AOJ1114(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint[][] b=new int[5][5];\n\t\t\tfor(int y=0; y<5; y++){\n\t\t\t\tfor(int x=0; x<5; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=0; i<5; i++){\n\t\t\t\tfor(int j=0; j<5; j++){\n\t\t\t\t\tif(b[i][j]==1)\tans=max(ans,solve1114(i,j,b));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint solve1114(int x,int y,int[][] b){\n\t\tint ans=0;\n\t\tfor(int i=0; i+x<5; i++){\n\t\t\tif(b[i+x][y]==0)\tbreak;\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j+y<5; j++){\n\t\t\t\tfor(int k=0; k<=i; k++){\n\t\t\t\t\tfor(int l=0; l<=j; l++){\n\t\t\t\t\t\tif(b[k+x][l+y]==0){\n\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!flag)\tbreak;\n\t\t\t\tans=max(ans,(i+1)*(j+1));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint step=0;\n\t// バックトラック（TLE）\n\tvoid AOJ1126(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++)\tc[x][y]=line.charAt(x);\n\t\t\t}\n\t\t\tString ans=\"\";\n\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\tif(Character.isDigit(c[x][y])){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]) && c[x-1][y]!='0')\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]) && c[x][y-1]!='0')\tcontinue;\n\t\t\t\t\t\tif(c[x][y]=='0')\tcontinue;\n\t\t\t\t\t\tString temp=solve1126(x,y,\"\"+c[x][y],c,W,H);\n\t\t\t\t\t\tans=compara1126(temp,ans)?temp:ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\t// TODO debug\n\t\tout.println(step+\"steps\");\n\t}\n\tString solve1126(int x,int y,String ans,char[][] c,int W,int H){\n\t\tString r=ans;\n\t\t//TODO debug\n\t\tstep++;\n\t\t//out.println(ans);\n\t\tfor(int i=1; i<3; i++){\n\t\t\tint xx=x+vx[i], yy=y+vy[i];\n\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\tString temp=solve1126(xx,yy,ans+c[xx][yy],c,W,H);\n\t\t\t\tr=compara1126(r,temp)?r:temp;\n\t\t\t\tout.println(temp);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\t// 第一引数aの方が大きい時のみtrue\n\tboolean compara1126(String a,String b){\n\t\tif(a.length()>b.length())\treturn true;\n\t\tif(a.length()==b.length()){\n\t\t\tfor(int i=0; i<a.length(); i++){\n\t\t\t\tif(a.charAt(i)>b.charAt(i))\treturn true;\n\t\t\t\tif(a.charAt(i)<b.charAt(i))\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t// 横型探索（TLE）\n\tvoid OldAOJ1126(){\n\t\tint step=0;\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tString ans=\"\";\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tString[][] close=new String[W][H];\n\t\t\tLinkedList<C1126> open=new LinkedList<C1126>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(Character.isDigit(line.charAt(x))){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]))\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]))\tcontinue;\n\t\t\t\t\t\topen.add(new C1126(x,y,\"\"+c[x][y]));\n\t\t\t\t\t\tclose[x][y]=\"\"+c[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1126 now=open.poll();\n\t\t\t\t// TODO debug\n\t\t\t\tout.println(\"ANS\"+ans+\" NOW\"+now.ans);\n\t\t\t\tans=now.compara(ans)?new String(now.ans):ans;\n\t\t\t\tfor(int i=1; i<3; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\t\t\tC1126 temp=new C1126(xx,yy,now.ans+c[xx][yy]);\n\t\t\t\t\t\tif(close[xx][yy]==null){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}else if(temp.compara(close[xx][yy])){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.println(step+\"step\");\n\t}\n\tclass C1126{\n\t\tint x,y;\tString ans;\n\t\tC1126(int x,int y,String ans){\n\t\t\tthis.x=x;\tthis.y=y;\n\t\t\tif(ans.length()>0){\n\t\t\t\tint i=0;\n\t\t\t\twhile(ans.charAt(i)=='0'){\n\t\t\t\t\tif(++i>=ans.length()-1)\tbreak;\n\t\t\t\t\tans=ans.substring(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ans=ans;\n\t\t}\n\t\tboolean compara(String ans){\n\t\t\tif(this.ans.length()>ans.length())\treturn true;\n\t\t\tif(this.ans.length()==ans.length()){\n\t\t\t\tfor(int i=0; i<ans.length(); i++){\n\t\t\t\t\tif(ans.charAt(i)<this.ans.charAt(i))\treturn true;\n\t\t\t\t\tif(ans.charAt(i)>this.ans.charAt(i))\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ0165(){\n\t\tfinal int MAX=1000000;\n\t\tboolean[] prime=Sieve(MAX);\n\t\tint[] prime2=new int[MAX+1];\n\t\tfor(int i=2; i<=MAX; i++)\tprime2[i]=(prime[i]?prime2[i-1]+1:prime2[i-1]);\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint p=sc.nextInt(), m=sc.nextInt();\n\t\t\t\tint min=max(1,p-m), max=min(MAX, p+m);\n\t\t\t\tint temp=prime2[max]-prime2[min-1];\n\t\t\t\t//out.println(\"TEMP\"+temp);\n\t\t\t\tans+=temp-1;\n\t\t\t}\n\t\t\tout.println(max(0,ans));\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt();\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// TODO 果樹園　RE　横型\n\tvoid AOJ0118(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(), ans=0;\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X+10][Y+10];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\t\tif(c[x][y]=='&')\tcontinue;\n\t\t\t\t\tans++;\n\t\t\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\tchar mark=c[x][y];\n\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\tc[now.x][now.y]='&';\n\t\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]==mark){\n\t\t\t\t\t\t\t\t//out.println((now.x+vx[i])+\" \"+(now.y+vy[i]));\n\t\t\t\t\t\t\t\topen.add(new Point(now.x+vx[i],now.y+vy[i]));\n\t\t\t\t\t\t\t\tc[now.x+vx[i]][now.y+vy[i]]='&';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//out.println(\"ANS\"+ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// Red and Black 横型探索\n\tvoid AOJ1130(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(),sx=0,sy=0,ans=0;\n\t\t\tif(X==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line[x];\n\t\t\t\t\tif(line[x]=='@'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tboolean[][] close=new boolean[X][Y];\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tans++;\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]=='.' && !close[now.x+vx[i]][now.y+vy[i]]){\n\t\t\t\t\t\topen.add(new Point(now.x+vx[i], now.y+vy[i]));\n\t\t\t\t\t\tclose[now.x+vx[i]][now.y+vy[i]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// TODO デパート　TLE MLE WA\n\tvoid AOJ0223(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(),\tY=sc.nextInt();\n\t\t\tif(X==0)\tbreak;\n\t\t\tint tx=sc.nextInt(), ty=sc.nextInt(), kx=sc.nextInt(), ky=sc.nextInt();\n\t\t\tint[][] b=new int[X+1][Y+1];\n\t\t\tfor(int y=1; y<=Y; y++){\n\t\t\t\tfor(int x=1; x<=X; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<C0223> open=new LinkedList<C0223>();\n\t\t\topen.add(new C0223(tx,ty,kx,ky,0));\n\t\t\tint[][][][] close2=new int[X+1][Y+1][X+1][Y+1];\n\t\t\tclose2[tx][ty][kx][ky]=-1;\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC0223 now=open.poll();\n\t\t\t\tif(now.ans()){\n\t\t\t\t\tans=now.sec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.sec>=99)\tbreak;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(0<now.tx+vx[i]&&now.tx+vx[i]<=X && 0<now.ty+vy[i]&&now.ty+vy[i]<=Y && 0<now.kx-vx[i]&&now.kx-vx[i]<=X && 0<now.ky-vy[i]&&now.ky-vy[i]<=Y){\n\t\t\t\t\t\ttx=now.tx;\tty=now.ty;\tkx=now.kx;\tky=now.ky;\n\t\t\t\t\t\tif(b[tx+vx[i]][ty+vy[i]]==0){\n\t\t\t\t\t\t\ttx+=vx[i];\tty+=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[kx-vx[i]][ky-vy[i]]==0){\n\t\t\t\t\t\t\tkx-=vx[i];\tky-=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//out.println(\"TEMP:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t//if(tx==kx && ty==ky)\tans=ans<0?now.sec+1:min(ans,now.sec+1);\n\t\t\t\t\t\tif(close2[tx][ty][kx][ky]==0 || close2[tx][ty][kx][ky]>now.sec+1){\n\t\t\t\t\t\t\t//out.println(\"ADD:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t\topen.add(new C0223(tx,ty,kx,ky,now.sec+1));\n\t\t\t\t\t\t\tclose2[tx][ty][kx][ky]=now.sec+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tclass C0223{\n\t\tint tx,ty,kx,ky,sec;\n\t\tC0223(int tx, int ty, int kx, int ky, int sec){\n\t\t\tthis.tx=tx;\tthis.ty=ty;\tthis.kx=kx;\tthis.ky=ky;\tthis.sec=sec;\n\t\t}\n\t\tboolean ans(){\n\t\t\tif(this.tx==this.kx && this.ty==this.ky)\treturn true;\n\t\t\telse\treturn false;\n\t\t}\n\t}\n\t\n\t\n\t// TODO WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\t\n\t// TODO レゴ　WA\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[W+2][H+2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO debug\n\t\t\t//de0207(b,W,H);\n\t\t\tint c=b[sx][sy];\n\t\t\tif(c==0){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\tboolean[][] close=new boolean[W+2][H+2];\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tclose[sx][sy]=true;\n\t\t\tString ans=\"NG\";\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=\"OK\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W+1, H+1, 1))\tcontinue;\n\t\t\t\t\tif(b[xx][yy]!=c)\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t\tArrayList<Integer> prime = new ArrayList<Integer>();\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[1]=false;\n\t\tfor (int i=2; i<=N; i++) {\n\t\t\tif(list[i]) {\n\t\t\t\tprime.add(i);\n\t\t\t\tfor (int j=i+i; j<=N; j+=i)\tlist[j] = false;\n\t\t\t}\n\t\t}\n\t\treturn prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[0]=false;\tlist[1]=false;\n\t\tfor(int j=4; j<=N; j+=2)\tlist[j]=false;\n\t\tfor(int i=3; i*i<=N; i+=2)\tif(list[i])\tfor (int j=i+i; j<=N; j+=i)\tlist[j]=false;\n\t\treturn list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t\tfor(int i=2; i*i<=n; i++){\n\t\t\tif(n%i==0)     return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\t\n\t\t\tif((w|h)==0)break;\n\t\t\t\n\t\t\tint[][] m = new int[h][w];\n\t\t\t\n\t\t\tint s_x = sc.nextInt()-1;\n\t\t\tint s_y = sc.nextInt()-1;\n\t\t\tint g_x = sc.nextInt()-1;\n\t\t\tint g_y = sc.nextInt()-1;\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\twhile(n--!=0){\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint t_x = sc.nextInt()-1;\n\t\t\t\tint t_y = sc.nextInt()-1;\n\t\t\t\tif(d==0)for(int i=0;i<2;i++)for(int j=0;j<4;j++)m[t_x+i][t_y+j]=c;\n\t\t\t\telse for(int i=0;i<4;i++)for(int j=0;j<2;j++)m[t_x+i][t_y+j]=c;\n\t\t\t}\n\t\t\t\n\t\t\tif(m[s_x][s_y]==0||m[g_x][g_y]==0||m[s_x][s_y]!=m[g_x][g_y]){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint x = m[s_x][s_y];\n\t\t\t\n\t\t\tboolean f = false;\n\t\t\tboolean[][] v = new boolean[h][w];\n\t\t\tv[s_x][s_y] = true;\n\t\t\t\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tl.add(new int[]{s_x,s_y});\n\t\t\t\n\t\t\twhile(!l.isEmpty()){\n\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\tfor(int a[] : l){\n\t\t\t\t\tint i = a[0];\n\t\t\t\t\tint j = a[1];\n\t\t\t\t\tif(i==g_x&&j==g_y){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tnext.clear();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!v[ni][nj]&&m[ni][nj]==x){\n\t\t\t\t\t\t\tv[ni][nj] = true;\n\t\t\t\t\t\t\tnext.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(f?\" OK\":\"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 && (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tchar[][] b = new char[200][200];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.next().charAt(0), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg] && b[xs][ys] != '0') {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void setBlock(char[][] b, char c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tpublic static void solid(char[][] b, char c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = '*';\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      マンハッタン距離が近くなるように道を選ぶ\n      (マンハッタン短縮を見つけていない間は)行ける所に行く\n      どこにも行けなければほげ。\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\tboolean goodRoute = false;\n\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(route[b][a] && getD(a, b)<d){\n\t\t    goodRoute = true;\n\t\t    if(search(a, b)) return true;\n\t\t}\n\t\telse if(!goodRoute && route[b][a])\n\t\t    if(search(a, b)) return true;\n\t    }\n\t}\n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic boolean solve() {\n\t\tint w = in.nextInt();\n\t\tint h = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tint sx = in.nextInt() - 1, sy = in.nextInt() - 1;\n\t\tint gx = in.nextInt() - 1, gy = in.nextInt() - 1;\n\n\t\tint[][] t = new int[h][w];\n\t\tint n = in.nextInt();\n\t\tfor (int k=0; k<n; k++) {\n\t\t\tint c = in.nextInt();\n\t\t\tint d = in.nextInt();\n\t\t\tint x = in.nextInt() - 1;\n\t\t\tint y = in.nextInt() - 1;\n\t\t\tif (d == 0) {\n\t\t\t\tfor (int i=y; i<y+2; i++) {\n\t\t\t\t\tfor (int j=x; j<x+4; j++) {\n\t\t\t\t\t\tt[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i=y; i<y+4; i++) {\n\t\t\t\t\tfor (int j=x; j<x+2; j++) {\n\t\t\t\t\t\tt[i][j] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t[sy][sx] == 0 || t[gy][gx] == 0) {\n\t\t\tout.println(\"NG\");\n\t\t\treturn true;\n\t\t}\n\n\t\tint[] dx = { 0, 1, 0,-1};\n\t\tint[] dy = { 1, 0,-1, 0};\n\n\t\tboolean[][] visited = new boolean[h][w];\n\t\tArrayDeque<int[]> que = new ArrayDeque<>();\n\t\tque.add(new int[]{sy, sx});\n\t\tvisited[sy][sx] = true;\n\n\t\twhile (que.size() > 0) {\n\t\t\tint[] tmp = que.pollFirst();\n\t\t\tint y = tmp[0];\n\t\t\tint x = tmp[1];\n\n\t\t\tif (y == gy && x == gx) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (int i=0; i<4; i++) {\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tif (ny < 0 || nx < 0 || w <= nx || h <= ny) continue;\n\t\t\t\tif (t[y][x] != t[ny][nx]) continue;\n\t\t\t\tif (visited[ny][nx]) continue;\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\tque.add(new int[]{ny, nx});\n\t\t\t}\n\t\t}\n\n\t\tif (visited[gy][gx]) {\n\t\t\tout.println(\"OK\");\n\t\t} else {\n\t\t\tout.println(\"NG\");\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.annotation.Retention;\nimport java.util.*;\n\nimport org.omg.CORBA.Principal;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0207();\n\t}\n\t\n\tclass AOJ0207{\n\t\tint w,h;\n\t\tint sx,sy,gx,gy;\n\t\tint[][] map;\n\t\t\n\t\tvoid makeBoead(int bx,int by,int muki,int color){\n\t\t\tif(muki==0){//横\n\t\t\t\tfor(int i=0;i<2;i++)for(int s=0;s<4;s++)map[by+i][bx+s]=color;\n\t\t\t}else if(muki==1){\n\t\t\t\tfor(int i=0;i<4;i++)for(int s=0;s<2;s++)map[by+i][bx+s]=color;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid print(){\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic AOJ0207() {\n\t\t\twhile(true){\n\t\t\t\tw = in.nextInt();\n\t\t\t\th = in.nextInt();\n\t\t\t\tif(w==0&&h==0)break;\n\t\t\t\tmap = new int[h+1][w+1];\n\t\t\t\tsx = in.nextInt(); sy = in.nextInt();\n\t\t\t\tgx = in.nextInt(); gy = in.nextInt();\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tint color = in.nextInt();\n\t\t\t\t\tint muki = in.nextInt();\n\t\t\t\t\tint bx = in.nextInt();\n\t\t\t\t\tint by = in.nextInt();\n\t\t\t\t\tmakeBoead(bx, by, muki, color);\n\t\t\t\t}\n//\t\t\t\tprint();\n\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\tlist.add(sx);list.add(sy);\n\t\t\t\tboolean sw = false;//flg\n\t\t\t\tint[] gox = {1,0,-1,0};\n\t\t\t\tint[] goy = {0,1,0,-1};\n\t\t\t\tint target_c = map[sy][sx];\n\t\t\t\twhile(list.size()>0){\n\t\t\t\t\tint x = list.remove();\n\t\t\t\t\tint y = list.remove();\n\t\t\t\t\tif(x==gx&&y==gy){\n\t\t\t\t\t\tsw=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint nx = x+gox[i];\n\t\t\t\t\t\tint ny = y+goy[i];\n\t\t\t\t\t\tif(nx<0||nx>w||ny<0||ny>h)continue;\n\t\t\t\t\t\tif(map[ny][nx]!=target_c)continue;\n\t\t\t\t\t\tmap[ny][nx] = -1;\n\t\t\t\t\t\tlist.add(nx);list.add(ny);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sw? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\nclass Main{\n\tstatic int map[][];\n\tstatic int fl[][] = {{4, 2}, {2, 4}};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tString string, str[];\n\t\t\n\t\tint w, h, n, t[][], c, d, x, y;\n\t\tboolean visit[][], judge;\n\t\twhile(!(string = reader.readLine()).equals(\"0 0\")){\n\t\t\tstr = string.split(\" \");\n\t\t\tw = Integer.valueOf(str[0]);\n\t\t\th = Integer.valueOf(str[1]);\n\t\t\t\n\t\t\tmap = new int[w][h];\n\t\t\tvisit = new boolean[w][h];\n\t\t\tjudge = false;\n\t\t\t\n\t\t\tt = new int[2][2];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tt[i][0] = Integer.valueOf(str[0]) - 1;\n\t\t\t\tt[i][1] = Integer.valueOf(str[1]) - 1;\n\t\t\t}\n\t\t\tn = Integer.valueOf(reader.readLine());\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tc = Integer.valueOf(str[0]);\n\t\t\t\td = Integer.valueOf(str[1]);\n\t\t\t\tx = Integer.valueOf(str[2]);\n\t\t\t\ty = Integer.valueOf(str[3]);\n\t\t\t\t\n\t\t\t\tapp.set(c, d, x, y);\n\t\t\t}\n\t\t\t\n\t\t\tStack<int[]> s = new Stack<int[]>();\n\t\t\ts.push(t[0]);\n\t\t\t\n\t\t\tint sign = map[t[0][0]][t[0][1]];\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tint now[] = s.pop();\n\t\t\t\t\n\t\t\t\tif(now[0] == t[1][0] && now[1] == t[1][1]){\n\t\t\t\t\tjudge = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now[0] < 0 || now[0] >= w || now[1] < 0 || now[1] >= h || visit[now[0]][now[1]] || map[now[0]][now[1]] != sign) continue;\n\t\t\t\tvisit[now[0]][now[1]] = true;\n\t\t\t\t\n\t\t\t\ts.push(new int[]{now[0] + 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0] - 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0], now[1] + 1});\n\t\t\t\ts.push(new int[]{now[0], now[1] - 1});\n\t\t\t}\n\t\t\t\n\t\t\tif(judge) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NG\");\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic void set(int c, int d, int x, int y){\n\t\tfor(int i = 0; i < fl[d][0]; i++){\n\t\t\tfor(int j = 0; j < fl[d][1]; j++){\n\t\t\t\tmap[x + i - 1][y + j - 1] = c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Point {\n\tfinal int x;\n\tfinal int y;\n\n\tPoint( final int x, final int y ) {\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t}\n\n\tpublic boolean equals( final Point p ) {\n\t\treturn x == p.x && y == p.y;\n\t}\n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\t\tfinal Scanner stdin = new Scanner( System.in );\n\n\t\twhile ( true ) {\n\n\t\t\tfinal int w = stdin.nextInt();\n\t\t\tfinal int h = stdin.nextInt();\n\t\t\tfinal int[][] map = new int[ h + 2 ][ w + 2 ];\n\t\t\t\n\t\t\tif ( w == 0 && h == 0 ) break;\n\n\t\t\tfinal Point start = new Point( stdin.nextInt(), stdin.nextInt() );\n\t\t\tfinal Point end = new Point( stdin.nextInt(), stdin.nextInt() );\n\n\t\t\tfinal int n = stdin.nextInt();\n\t\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\t\tfinal int c = stdin.nextInt();\n\t\t\t\tfinal int d = stdin.nextInt();\n\t\t\t\tfinal int xs = stdin.nextInt();\n\t\t\t\tfinal int ys = stdin.nextInt();\n\n\t\t\t\tfinal int dx = d == 0 ? 4 : 2;\n\t\t\t\tfinal int dy = d == 0 ? 2 : 4;\n\t\t\t\t\n\t\t\t\tfor ( int y = ys; y < ys + dy; y++ ) {\n\t\t\t\t\tfor ( int x = xs; x < xs + dx; x++ ) {\n\t\t\t\t\t\tmap[ y ][ x ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif ( solve( map, start, end ) ) {\n\t\t\t\tSystem.out.println( \"OK\" );\n\t\t\t} else {\n\t\t\t\tSystem.out.println( \"NG\" );\n\t\t\t}\n\t\t}\n    }\n\n\tstatic final int VISITED = -1;\n\tstatic final int[] dx = {-1, 0, 1, 0};\n\tstatic final int[] dy = {0, 1, 0, -1};\n\t\n\tstatic boolean solve( final int[][] map, final Point start, final Point end ) {\n\t\t\n\t\tfinal int color = map[ start.y ][ start.x ];\n\t\tfinal int w = map[ 0 ].length - 2;\n\t\tfinal int h = map.length - 2;\n\t\t\n\t\tfinal Queue<Point> que = new ArrayDeque<>();\n\n\t\tque.add( start );\n\n\t\twhile ( !que.isEmpty() ){\n\t\t\tfinal Point p = que.poll();\n\t\t\tmap[ p.y ][ p.x ] = VISITED;\n\t\t\tif ( p.x == end.x && p.y == end.y ) return true;\n\n\t\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\t\tfinal int nx = p.x + dx[ i ];\n\t\t\t\tfinal int ny = p.y + dy[ i ];\n\n\t\t\t\tif ( 1 <= nx && nx <= w && 1 <= ny && ny <= h &&\n\t\t\t\t\t map[ ny ][ nx ] == color ) {\n\n\t\t\t\t\tque.offer( new Point( nx, ny ) );\n\t\t\t\t}\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 && (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tint[][] b = new int[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.nextInt(), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void setBlock(int[][] b, int c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tpublic static void solid(int[][] b, int c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = -1;\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\t//Input\n\t\t\tfinal int w = sc.nextInt(); final int h = sc.nextInt();\n\t\t\tif(w==0 && h==0){ break; }\n\t\t\tfinal int xs = sc.nextInt(); final int ys = sc.nextInt();\n\t\t\tfinal int xg = sc.nextInt(); final int yg = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfinal int c = sc.nextInt();  final int d = sc.nextInt();\n\t\t\t\tfinal int x = sc.nextInt();  final int y = sc.nextInt();\n\t\t\t\tfor(int ty=y; ty<y+2+2*d; ++ty){\n\t\t\t\t\tfor(int tx=x; tx<x+2+2*Math.abs(d-1); ++tx){\n\t\t\t\t\t\tmap[ty][tx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//algorithm(BFS)\n\t\t\tboolean f = true;\n\t\t\tfinal int[][] ofs = {\n\t\t\t\t\t{1, 0}, {0, 1}, {-1, 0}, {0, -1}\n\t\t\t};\n\t\t\tQueue<int[]> que = new LinkedList<int[]>();\n\t\t\tint next[] = {xs, ys};\n\t\t\tque.offer(next);\n\t\t\tfinal int col = map[next[1]][next[0]];\n\t\t\tif(col == 0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[next[1]][next[0]] = 0;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tnext = que.poll();\n\t\t\t\tif(next[0] == xg && next[1] == yg){\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\tif(map[next[0] + ofs[i][0] ][next[1] + ofs[i][1] ] == col){\n\t\t\t\t\t\tfinal int e[] = {\n\t\t\t\t\t\t\t\tnext[0] + ofs[i][0], next[1] + ofs[i][1]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tque.offer(e);\n\t\t\t\t\t\tmap[e[1]][e[0]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[][] map;\n    static int VISITED = -1;\n    public static void main(String[] args) throws java.io.IOException {\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if((w|h)==0)break;\n            map = new int[h][w];\n            int xs = sc.nextInt();\n            int ys = sc.nextInt();\n            int xg = sc.nextInt();\n            int yg = sc.nextInt();\n            int n = sc.nextInt();\n            for(int i=0;i<n;i++){\n                int c = sc.nextInt();\n                int d = sc.nextInt();\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                setBlock(c,d,x,y);\n            }\n            boolean flag = false;\n            Point sp = new Point(xs,ys);\n            Queue<Point> fifo = new LinkedList<Point>();\n            fifo.add(sp);\n            int color = map[ys][xs];\n            while(fifo.peek()!=null){\n                Point p = fifo.poll();\n\n                if(p.x==xg&&p.y==yg){\n                    flag=true;\n                    break;\n                }\n                int x = p.x;\n                int y = p.y;\n\n                int[] dx={1,0,-1,0};\n                int[] dy={0,1,0,-1};\n                for(int i=0;i<4;i++){\n                    int nx = x+dx[i];\n                    int ny = y+dy[i];\n                    if(nx>=0&&nx<w&&ny>=0&&ny<h&&map[ny][nx]==color){\n                        fifo.add(new Point(nx,ny));\n                        map[ny][nx]=VISITED;\n                    }\n                }\n            }\n            System.out.println(\"\"+(flag? \"OK\" : \"NG\"));\n        }\n\n    }\n    public static void setBlock(int c,int d, int x, int y){\n        if(d==0){\n            for(int i=0;i<2;i++){\n                for(int j=0;j<4;j++){\n                    map[y+i][x+j] = c;\n                }\n            }\n        }\n        else{\n            for(int i=0;i<4;i++){\n                for(int j=0;j<2;j++){\n                    map[y+i][x+j] = c;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static final int[] blockW = {4,2};\n\tpublic static final int[] blockH = {2,4};\n\tpublic static final int[] vx = {1,0,-1,0};\n\tpublic static final int[] vy = {0,-1,0,1};\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif (w+h==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPos2d start = new Pos2d(sc.nextInt()-1,sc.nextInt()-1);\n\t\t\tPos2d goal = new Pos2d(sc.nextInt()-1,sc.nextInt()-1);\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] maze = new int[w][h];\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tfor (int j=0;j<blockW[d];j++) {\n\t\t\t\t\tfor (int k=0;k<blockH[d];k++) {\n\t\t\t\t\t\tmaze[x+j][y+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ans = false;\n\t\t\tif (maze[start.x][start.y]!=0) {\n\t\t\t\tint mc = maze[start.x][start.y];\n\t\t\t\tboolean[][] reach = new boolean[w][h];\n\t\t\t\tQueue<Pos2d> q = new ArrayDeque<Pos2d>();\n\t\t\t\tq.offer(start);\n\t\t\t\twhile(!q.isEmpty()) {\n\t\t\t\t\tPos2d p = q.poll();\n\t\t\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\t\t\tint nx = p.x + vx[i];\n\t\t\t\t\t\tint ny = p.y + vy[i];\n\t\t\t\t\t\tif (nx>= 0 && nx<w && ny>=0 && ny<h) {\n\t\t\t\t\t\t\tif (maze[nx][ny]==mc) {\n\t\t\t\t\t\t\t\tif (!reach[nx][ny]) {\n\t\t\t\t\t\t\t\t\treach[nx][ny]=true;\n\t\t\t\t\t\t\t\t\tq.offer(new Pos2d(nx,ny));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = reach[goal.x][goal.y];\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"OK\" : \"NG\");\n\t\t}\n\t}\n}\nclass Pos2d {\n\tpublic int x;\n\tpublic int y;\n\tpublic Pos2d(int x,int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Point {\n\tfinal int x;\n\tfinal int y;\n\n\tPoint( final int x, final int y ) {\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t}\n\n\tpublic boolean equals( final Point p ) {\n\t\treturn x == p.x && y == p.y;\n\t}\n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\t\tfinal Scanner stdin = new Scanner( System.in );\n\n\t\twhile ( true ) {\n\n\t\t\tfinal int w = stdin.nextInt();\n\t\t\tfinal int h = stdin.nextInt();\n\t\t\tfinal int[][] map = new int[ h + 2 ][ w + 2 ];\n\t\t\t\n\t\t\tif ( w == 0 && h == 0 ) break;\n\n\t\t\tfinal Point start = new Point( stdin.nextInt(), stdin.nextInt() );\n\t\t\tfinal Point end = new Point( stdin.nextInt(), stdin.nextInt() );\n\n\t\t\tfinal int n = stdin.nextInt();\n\t\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\t\tfinal int c = stdin.nextInt();\n\t\t\t\tfinal int d = stdin.nextInt();\n\t\t\t\tfinal int xs = stdin.nextInt();\n\t\t\t\tfinal int ys = stdin.nextInt();\n\n\t\t\t\tfinal int dx = d == 0 ? 4 : 2;\n\t\t\t\tfinal int dy = d == 0 ? 2 : 4;\n\t\t\t\t\n\t\t\t\tfor ( int y = ys; y < ys + dy; y++ ) {\n\t\t\t\t\tfor ( int x = xs; x < xs + dx; x++ ) {\n\t\t\t\t\t\tmap[ y ][ x ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif ( solve( map, start, end ) ) {\n\t\t\t\tSystem.out.println( \"OK\" );\n\t\t\t} else {\n\t\t\t\tSystem.out.println( \"NG\" );\n\t\t\t}\n\t\t}\n    }\n\n\tstatic final int VISITED = -1;\n\tstatic final int[] dx = {-1, 0, 1, 0};\n\tstatic final int[] dy = {0, 1, 0, -1};\n\t\n\tstatic boolean solve( final int[][] map, final Point start, final Point end ) {\n\t\t\n\t\tfinal int color = map[ start.y ][ start.x ];\n\t\tfinal int w = map[ 0 ].length - 2;\n\t\tfinal int h = map.length - 2;\n\t\t\n\t\tfinal Queue<Point> que = new ArrayDeque<Point>();\n\n\t\tque.add( start );\n\n\t\twhile ( !que.isEmpty() ){\n\t\t\tfinal Point p = que.poll();\n\t\t\tmap[ p.y ][ p.x ] = VISITED;\n\t\t\tif ( p.x == end.x && p.y == end.y ) return true;\n\n\t\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\t\tfinal int nx = p.x + dx[ i ];\n\t\t\t\tfinal int ny = p.y + dy[ i ];\n\n\t\t\t\tif ( 1 <= nx && nx <= w && 1 <= ny && ny <= h &&\n\t\t\t\t\t map[ ny ][ nx ] == color ) {\n\n\t\t\t\t\tque.offer( new Point( nx, ny ) );\n\t\t\t\t}\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\t//Input\n\t\t\tfinal int w = sc.nextInt(); final int h = sc.nextInt();\n\t\t\tif(w==0 && h==0){ break; }\n\t\t\tfinal int xs = sc.nextInt(); final int ys = sc.nextInt();\n\t\t\tfinal int xg = sc.nextInt(); final int yg = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfinal int c = sc.nextInt();  final int d = sc.nextInt();\n\t\t\t\tfinal int x = sc.nextInt();  final int y = sc.nextInt();\n\t\t\t\tfor(int ty=y; ty<y+2+2*d; ++ty){\n\t\t\t\t\tfor(int tx=x; tx<x+2+2*Math.abs(d-1); ++tx){\n\t\t\t\t\t\tmap[ty][tx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<map.length; ++i){\n\t\t\t\tfor(int j=0; j<map[0].length; ++j){\n\t\t\t\t\tSystem.out.print(map[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.print('\\n');\n\t\t\t}\n\t\t\t\n\t\t\t//algorithm(BFS)\n\t\t\tboolean f = true;\n\t\t\tfinal int[][] ofs = {\n\t\t\t\t\t{1, 0}, {0, 1}, {-1, 0}, {0, -1}\n\t\t\t};\n\t\t\tQueue<int[]> que = new LinkedList<int[]>();\n\t\t\tint next[] = {xs, ys};\n\t\t\tque.offer(next);\n\t\t\tfinal int col = map[next[1]][next[0]];\n\t\t\tif(col == 0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[next[1]][next[0]] = 0;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tnext = que.poll();\n\t\t\t\tif(next[0] == xg && next[1] == yg){\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\tif(map[next[1] + ofs[i][1] ][next[0] + ofs[i][0] ] == col){\n\t\t\t\t\t\tfinal int e[] = {\n\t\t\t\t\t\t\t\tnext[0] + ofs[i][0], next[1] + ofs[i][1]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tque.offer(e);\n\t\t\t\t\t\tmap[e[1]][e[0]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[][] map;\n    static int VISITED = -1;\n    public static void main(String[] args) throws java.io.IOException {\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if((w|h)==0)break;\n            map = new int[h][w];\n            int xs = sc.nextInt()-1;\n            int ys = sc.nextInt()-1;\n            int xg = sc.nextInt()-1;\n            int yg = sc.nextInt()-1;\n            int n = sc.nextInt();\n            for(int i=0;i<n;i++){\n                int c = sc.nextInt();\n                int d = sc.nextInt();\n                int x = sc.nextInt()-1;\n                int y = sc.nextInt()-1;\n                setBlock(c,d,x,y);\n            }\n            boolean flag = false;\n            Point sp = new Point(xs,ys);\n            Queue<Point> fifo = new LinkedList<Point>();\n            fifo.add(sp);\n            int color = map[ys][xs];\n            if(color==VISITED||color!=map[yg][xg]){\n            \tSystem.out.println(\"NG\");\n            \tcontinue;\n            }\n            while(fifo.peek()!=null){\n                Point p = fifo.poll();\n\n                if(p.x==xg&&p.y==yg){\n                    flag=true;\n                    break;\n                }\n                int x = p.x;\n                int y = p.y;\n\n                int[] dx={1,0,-1,0};\n                int[] dy={0,1,0,-1};\n                for(int i=0;i<4;i++){\n                    int nx = x+dx[i];\n                    int ny = y+dy[i];\n                    if(nx>=0&&nx<w&&ny>=0&&ny<h&&map[ny][nx]==color){\n                        fifo.add(new Point(nx,ny));\n                        map[ny][nx]=VISITED;\n                    }\n                }\n            }\n            System.out.println(\"\"+(flag? \"OK\" : \"NG\"));\n        }\n\n    }\n    public static void setBlock(int c,int d, int x, int y){\n        if(d==0){\n            for(int i=0;i<2;i++){\n                for(int j=0;j<4;j++){\n                    map[y+i][x+j] = c;\n                }\n            }\n        }\n        else if(d==1){\n            for(int i=0;i<4;i++){\n                for(int j=0;j<2;j++){\n                    map[y+i][x+j] = c;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 & (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tint[][] b = new int[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.nextInt(), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tstatic void setBlock(int[][] b, int c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tstatic void solid(int[][] b, int c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = -1;\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n\tstatic int[] dx = new int[]{-1,0,1,0},dy = new int[]{0,-1,0,1};\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tMainLoop : while(true){\n\t\t\tint w = Integer.parseInt(scan.next());\n\t\t\tint h = Integer.parseInt(scan.next());\n\t\t\tif(w==0) break;\n\t\t\tbyte[][] map = new byte[h][w];\n\n\t\t\tint sx = Integer.parseInt(scan.next())-1;\n\t\t\tint sy = Integer.parseInt(scan.next())-1;\n\t\t\tint gx = Integer.parseInt(scan.next())-1;\n\t\t\tint gy = Integer.parseInt(scan.next())-1;\n\t\t\tint n = Integer.parseInt(scan.next());\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tbyte c = scan.nextByte();\n\t\t\t\tint d = Integer.parseInt(scan.next());\n\t\t\t\tint x = Integer.parseInt(scan.next())-1;\n\t\t\t\tint y = Integer.parseInt(scan.next())-1;\n\t\t\t\tfor (int j = 0; j < (d==0 ? 2 : 4) ; j++)\n\t\t\t\t\tfor (int j2 = 0; j2 < (d==0 ? 4 : 2) ; j2++)\n\t\t\t\t\t\tmap[j+y][j2+x] = c;\n\n\t\t\t}\n\n\t\t\tif(map[sy][sx]==0){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint color = map[sy][sx];\n\t\t\tStack<int[]> stk = new Stack<int[]>();\n\t\t\tstk.push(new int[]{sx,sy});\n\n\t\t\twhile(!stk.isEmpty()){\n\t\t\t\tint[] pos = stk.pop();\n\t\t\t\tmap[pos[1]][pos[0]]=0;\n\t\t\t\tif(pos[0]==gx && pos[1]==gy){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tcontinue MainLoop;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nx = pos[0]+dx[i],ny = pos[1]+dy[i];\n\t\t\t\t\tif(nx>=0 && nx<w && ny>=0 && ny<h && color==map[ny][nx])\n\t\t\t\t\t\tstk.push(new int[]{nx,ny});\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(\"NG\");\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x-1,y) || move(x,y+1) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tboolean ans = move(xs, ys);\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate void move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn ;\n\t\t}\n\t\tfield[y][x] = -1;\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn ;\n\t\t}\n\t\tmove(x+1,y);\n\t\tmove(x,y+1);\n\t\tmove(x-1,y);\n\t\tmove(x,y-1);\n\t\treturn ;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmove(xs, ys);\n\t\t\t\tif(field[goaly][goalx] == -1)\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ0207();\n\t}\n\t\n\tclass AOJ0207{\n\t\tint w,h;\n\t\tint sx,sy,gx,gy;\n\t\tint[][] map;\n\t\t\n\t\tvoid makeBoead(int bx,int by,int muki,int color){\n\t\t\tif(muki==0){//横\n\t\t\t\tfor(int i=0;i<2;i++)for(int s=0;s<4;s++)map[by+i][bx+s]=color;\n\t\t\t}else if(muki==1){\n\t\t\t\tfor(int i=0;i<4;i++)for(int s=0;s<2;s++)map[by+i][bx+s]=color;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid print(){\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int s=0;s<w;s++)System.out.print(map[i][s]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic AOJ0207() {\n\t\t\twhile(true){\n\t\t\t\tw = in.nextInt();\n\t\t\t\th = in.nextInt();\n\t\t\t\tif(w==0&&h==0)break;\n\t\t\t\tmap = new int[h+1][w+1];\n\t\t\t\tsx = in.nextInt(); sy = in.nextInt();\n\t\t\t\tgx = in.nextInt(); gy = in.nextInt();\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tint color = in.nextInt();\n\t\t\t\t\tint muki = in.nextInt();\n\t\t\t\t\tint bx = in.nextInt();\n\t\t\t\t\tint by = in.nextInt();\n\t\t\t\t\tmakeBoead(bx, by, muki, color);\n\t\t\t\t}\n//\t\t\t\tprint();\n\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\tlist.add(sx);list.add(sy);\n\t\t\t\tboolean sw = false;//flg\n\t\t\t\tint[] gox = {1,0,-1,0};\n\t\t\t\tint[] goy = {0,1,0,-1};\n\t\t\t\tint target_c = map[sy][sx];\n\t\t\t\twhile(list.size()>0){\n\t\t\t\t\tint x = list.remove();\n\t\t\t\t\tint y = list.remove();\n\t\t\t\t\tif(x==gx&&y==gy){\n\t\t\t\t\t\tsw=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint nx = x+gox[i];\n\t\t\t\t\t\tint ny = y+goy[i];\n\t\t\t\t\t\tif(nx<0||nx>w||ny<0||ny>h)continue;\n\t\t\t\t\t\tif(map[ny][nx]!=target_c)continue;\n\t\t\t\t\t\tmap[ny][nx] = -1;\n\t\t\t\t\t\tlist.add(nx);list.add(ny);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sw? \"OK\":\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\nclass Main{\n\tstatic int map[][];\n\tstatic int fl[][] = {{4, 2}, {2, 4}};\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tMain app = new Main();\n\t\tString string, str[];\n\t\t\n\t\tint w, h, n, t[][], c, d, x, y;\n\t\tboolean visit[][], judge;\n\t\twhile(!(string = reader.readLine()).equals(\"0 0\")){\n\t\t\tstr = string.split(\" \");\n\t\t\tw = Integer.valueOf(str[0]);\n\t\t\th = Integer.valueOf(str[1]);\n\t\t\t\n\t\t\tmap = new int[w][h];\n\t\t\tvisit = new boolean[w][h];\n\t\t\tjudge = false;\n\t\t\t\n\t\t\tt = new int[2][2];\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tt[i][0] = Integer.valueOf(str[0]) - 1;\n\t\t\t\tt[i][1] = Integer.valueOf(str[1]) - 1;\n\t\t\t}\n\t\t\tn = Integer.valueOf(reader.readLine());\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tstr = reader.readLine().split(\" \");\n\t\t\t\tc = Integer.valueOf(str[0]);\n\t\t\t\td = Integer.valueOf(str[1]);\n\t\t\t\tx = Integer.valueOf(str[2]) - 1;\n\t\t\t\ty = Integer.valueOf(str[3]) - 1;\n\t\t\t\t\n\t\t\t\tapp.set(c, d, x, y);\n\t\t\t}\n\t\t\t\n\t\t\tStack<int[]> s = new Stack<int[]>();\n\t\t\ts.push(t[0]);\n\t\t\t\n\t\t\tint sign = map[t[0][0]][t[0][1]];\n\t\t\twhile(!s.isEmpty()){\n\t\t\t\tint now[] = s.pop();\n\t\t\t\t\n\t\t\t\tif(now[0] == t[1][0] && now[1] == t[1][1]){\n\t\t\t\t\tjudge = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now[0] < 0 || now[0] >= h || now[1] < 0 || now[1] >= w || visit[now[0]][now[1]] || map[now[0]][now[1]] != sign) continue;\n\t\t\t\tvisit[now[0]][now[1]] = true;\n\t\t\t\t\n\t\t\t\ts.push(new int[]{now[0] + 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0] - 1, now[1]});\n\t\t\t\ts.push(new int[]{now[0], now[1] + 1});\n\t\t\t\ts.push(new int[]{now[0], now[1] - 1});\n\t\t\t}\n\t\t\t\n\t\t\tif(judge) System.out.println(\"OK\");\n\t\t\telse System.out.println(\"NG\");\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic void set(int c, int d, int x, int y){\n\t\tfor(int i = 0; i < fl[d][0]; i++){\n\t\t\tfor(int j = 0; j < fl[d][1]; j++){\n\t\t\t\tmap[x + i][y + j] = c;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString[] str;\n\t\tString line;\n\t\tint w,h,sx,sy,gx,gy,n;\n\t\tBlock b;\n\t\t\n\t\twhile(true){\n\t\t\tline = sc.nextLine();\n\t\t\tstr = line.split(\" \");\n\t\t\tif(str[0].equals(\"0\") && str[1].equals(\"0\")){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tw = Integer.valueOf(str[0]);\n\t\t\th = Integer.valueOf(str[1]);\n\t\t\tline = sc.nextLine();\n\t\t\tstr = line.split(\" \");\n\t\t\tsx = Integer.valueOf(str[0]);\n\t\t\tsy = Integer.valueOf(str[1]);\n\t\t\tline = sc.nextLine();\n\t\t\tstr = line.split(\" \");\n\t\t\tgx = Integer.valueOf(str[0]);\n\t\t\tgy = Integer.valueOf(str[1]);\n\t\t\tb = new Block(w,h,sx,sy,gx,gy);\n\t\t\t\n\t\t\tline = sc.nextLine();\n\t\t\tn = Integer.valueOf(line);\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tb.setBlock(sc.nextLine());\n\t\t\t}\n\t\t\t\n\t\t\tif(b.getResult()){\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass Block{\n\tint[][] board;\n\tint w,h,sx,sy,gx,gy,c;\n\t\n\tBlock(int w,int h,int sx,int sy,int gx,int gy){\n\t\tthis.w = w;\n\t\tthis.h = h;\n\t\tboard = new int[w+1][h+1];\n\t\tthis.sx = sx;\n\t\tthis.sy = sy;\n\t\tthis.gx = gx;\n\t\tthis.gy = gy;\n\t}\n\t\n\tpublic boolean getResult(){\n\t\tc = board[sx][sy];\n\t\t\n\t\treturn checkRoute(c,sx,sy);\n\t}\n\t\n\tprivate boolean checkRoute(int c,int x,int y){\n\t\tboolean result = false;\n\t\t\n\t\tif((x==gx) && (y==gy)){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tboard[x][y] = -1;\n\t\tif(x-1 > 0){\n\t\t\tif(board[x-1][y] == c){\n\t\t\t\tresult = checkRoute(c,x-1,y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(x+1 < w+1){\n\t\t\tif(board[x+1][y] == c){\n\t\t\t\tresult = checkRoute(c,x+1,y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y-1 > 0){\n\t\t\tif(board[x][y-1] == c){\n\t\t\t\tresult = checkRoute(c,x,y-1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(y+1 < h+1){\n\t\t\tif(board[x][y+1] == c){\n\t\t\t\tresult = checkRoute(c,x,y+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tpublic void setBlock(String line){\n\t\tString[] str = line.split(\" \");\n\t\tint c,d,x,y;\n\t\tc = Integer.valueOf(str[0]);\n\t\td = Integer.valueOf(str[1]);\n\t\tx = Integer.valueOf(str[2]);\n\t\ty = Integer.valueOf(str[3]);\n\t\tif(d == 0){\n\t\t\tfor(int i=0;i<2;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tboard[y+i][x+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tboard[y+i][x+j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] field;\n\tstatic int xg, yg;\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = s.nextInt();\n\t\t\th = s.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\n\t\t\tfield = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint xs = s.nextInt();\n\t\t\tint ys = s.nextInt();\n\t\t\txg = s.nextInt();\n\t\t\tyg = s.nextInt();\n\n\t\t\tint n = s.nextInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint c = s.nextInt();\n\t\t\t\tint d = s.nextInt();\n\t\t\t\tint x = s.nextInt();\n\t\t\t\tint y = s.nextInt();\n\n\t\t\t\tif (d == 0)\n\t\t\t\t\tfor (int k = y - 1; k < y + 1; k++)\n\t\t\t\t\t\tfor (int j = x - 1; j < x + 3; j++)\n\t\t\t\t\t\t\tfield[k][j] = c;\n\t\t\t\tif (d == 1)\n\t\t\t\t\tfor (int k = y - 1; k < y + 3; k++)\n\t\t\t\t\t\tfor (int j = x - 1; j < x + 1; j++)\n\t\t\t\t\t\t\tfield[k][j] = c;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (field[i][j] != field[ys - 1][xs - 1])\n\t\t\t\t\t\tfield[i][j] = 0;\n\t\t\t\t}\n\n\t\t\tboolean b = false;\n\t\t\tif (field[ys - 1][xs - 1] > 0)\n\t\t\t\tb = search(xs, ys, field[ys - 1][xs - 1]);\n\t\t\tif (b)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t\ts.close();\n\t}\n\n\tstatic boolean search(int x, int y, int c) {\n\t\tfield[y][x] = 0;\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\tint[] dy = { -1, 0, 1, 0 };\n\t\tboolean b = false;\n\t\tif (x == xg - 1 && y == yg - 1)\n\t\t\tb = true;\n\t\telse {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h) {\n\t\t\t\t\tif (field[y + dy[i]][x + dx[i]] == c)\n\t\t\t\t\t\tb = search(x + dx[i], y + dy[i], c);\n\t\t\t\t\tif (b)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\t//0207\n\tstatic class Block{\n\t\tint[][] field;\n\t\tint w, h;\n\t\tint ys, xs, yg, xg;\n\t\tint[] dir_y = {0, 1, 0,-1};\n\t\tint[] dir_x = {1, 0,-1, 0};\n\t\tboolean ans = false;\n\n\t\tvoid print_answer() {\n\t\t\tfor(;;) {\n\t\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\t\tif(w == 0 && h == 0) break;\n\t\t\t\t// fieldと座標を合わせるための-1\n\t\t\t\txs = sc.nextInt()-1; ys = sc.nextInt()-1;\n\t\t\t\txg = sc.nextInt()-1; yg = sc.nextInt()-1;\n\t\t\t\tint n = sc.nextInt();\n\n\t\t\t\tfield = new int[h][w];\n\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tint[] block = new int[4];\n\t\t\t\t\tfor(int j=0; j<4; j++) {block[j] = sc.nextInt();}\n\t\t\t\t\tsetBlock(block);\n\t\t\t\t}\n\n\t\t\t\tsearchField(ys, xs);\n\n\t\t\t\tif(ans) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\n\t\t// bk = {color, dir, x, y};\n\t\tvoid setBlock(int[] bk) {\n\t\t\tif(bk[1] == 0) {\n\t\t\t\tfor(int i=0; i<2; i++) {\n\t\t\t\t\tfor(int j=0; j<4; j++) {\n\t\t\t\t\t\tfield[bk[3]-1 + i][bk[2]-1 + j] = bk[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(bk[1] == 1) {\n\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\tfor(int j=0; j<2; j++) {\n\t\t\t\t\t\tfield[bk[3]-1 + i][bk[2]-1 + j] = bk[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid searchField(int y, int x) {\n\t\t\tif(y == yg && x == xg) ans = true;\n\t\t\telse {\n\t\t\t\tfor(int i=0; i<4; i++) {\n\t\t\t\t\tint ny = y + dir_y[i], nx = x + dir_x[i];\n\t\t\t\t\tif(ny >= 0 && nx >= 0 && ny < h && nx < w) {\n\t\t\t\t\t\tif(field[ny][nx] == field[ys][xs] && field[ny][nx] != -1) {\n\t\t\t\t\t\t\tfield[ny][nx] = -1;\n\t\t\t\t\t\t\tsearchField(ny, nx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tBlock b = new Block();\n\t\tb.print_answer();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\n/**\n * Block\n */\npublic class Main {\n\n\tstatic int[][] board;\n\tfinal static int BLOCK_WIDTH = 4;\n\tfinal static int BLOCK_HEIGHT = 2;\n\tfinal static int EMPTY = 0;\n\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0 0\")) {\n\n\t\t\tw = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\th = Integer.parseInt(line.trim().substring(line.indexOf(' ') + 1));\n\n\t\t\tboard = new int[w + 1][h + 1];\n\n\t\t\tline = br.readLine();\n\t\t\tint xs = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint ys = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tline = br.readLine();\n\t\t\tint xg = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint yg = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tputBlock(br.readLine());\n\t\t\t}\n\n\t\t\tif (solve(xs, ys, xg, yg)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic void putBlock(String info) {\n\t\tStringTokenizer st = new StringTokenizer(info);\n\n\t\tint c, d, x, y;\n\t\tc = Integer.parseInt(st.nextToken());\n\t\td = Integer.parseInt(st.nextToken());\n\t\tx = Integer.parseInt(st.nextToken());\n\t\ty = Integer.parseInt(st.nextToken());\n\n\t\tputBlock(c, d, x, y);\n\t}\n\n\tstatic void putBlock(int c, int d, int x, int y) {\n\n\t\tif (d == 0) {\n\t\t\tfor (int i = x; i < x + BLOCK_WIDTH; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_HEIGHT; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = x; i < x + BLOCK_HEIGHT; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_WIDTH; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean solve(int xs, int ys, int xg, int yg) {\n\n\t\tfinal int V[] = { 1, -1, 0, 0 };\n\t\tfinal int H[] = { 0, 0, 1, -1 };\n\n\t\tif (board[xs][ys] != board[xg][yg]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint[] next, prev;\n\t\tint color = board[xs][ys];\n\n\t\tnext = new int[] { xs, ys };\n\t\tArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n\n\t\tqueue.offer(next);\n\t\tboard[xs][ys] = EMPTY;\n\n\t\twhile (!queue.isEmpty()) {\n\n\t\t\tprev = queue.poll();\n\n\t\t\tint px, py, nx, ny;\n\t\t\tpx = prev[0];\n\t\t\tpy = prev[1];\n\t\t\tboard[px][py] = EMPTY;\n\n\t\t\tif (px == xg && py == yg) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tnx = px + V[i];\n\t\t\t\tny = py + H[i];\n\t\t\t\tif (nx > 0 && nx < w + 1 && ny > 0 && ny < h + 1) {\n\t\t\t\t\tif (board[nx][ny] == color) {\n\t\t\t\t\t\tqueue.offer(new int[] { nx, ny });\n\t\t\t\t\t\tboard[nx][ny] = EMPTY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x-1,y) || move(x,y+1) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean ans = move(xs, ys);\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint w, h;\n\tint sx, sy;\n\tint gx, gy;\n\tint[][] a;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tw=sc.nextInt();\n\t\t\th=sc.nextInt();\n\t\t\tif((w|h)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsx=sc.nextInt()-1;\n\t\t\tsy=sc.nextInt()-1;\n\t\t\tgx=sc.nextInt()-1;\n\t\t\tgy=sc.nextInt()-1;\n\t\t\tint n=sc.nextInt();\n\t\t\ta=new int[h][w];\n\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\tint c=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\tif(d==0){\n\t\t\t\t\t\t\ta[y+j][x+i]=c;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ta[y+i][x+j]=c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tboolean[][] visited=new boolean[h][w];\n\n\t\tint[] dx={0, 0, -1, 1};\n\t\tint[] dy={-1, 1, 0, 0};\n\n\t\tque.offer(new P(sx, sy));\n\t\tvisited[sy][sx]=true;\n\n\t\tfor(; !que.isEmpty();){\n\t\t\tP p=que.poll();\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.x+dx[i], p.y+dy[i]);\n\t\t\t\tif(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&a[q.y][q.x]==a[sy][sx]\n\t\t\t\t\t\t&&!visited[q.y][q.x]){\n\t\t\t\t\tque.offer(q);\n\t\t\t\t\tvisited[q.y][q.x]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(visited[gy][gx]?\"OK\":\"NG\");\n\t}\n\n\tclass P{\n\t\tint x, y;\n\n\t\tP(int x, int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\tstatic int mat[][] = new int[105][105];\n\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint w = in.nextInt(), h = in.nextInt();\n\t\t\tif(w==0 && h==0) return ;\n\t\t\tint sx = in.nextInt(), sy = in.nextInt();\n\t\t\tint gx = in.nextInt(), gy = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tfor(int i=0; i<105; i++)\n\t\t\t\tfor(int j=0; j<105; j++)\n\t\t\t\t\tmat[i][j] = -1;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint c = in.nextInt(), d = in.nextInt(), x = in.nextInt(), y = in.nextInt();\n\t\t\t\tif(d==1){\n\t\t\t\t\tfor(int j=0; j<2; j++)\n\t\t\t\t\t\tfor(int k=0; k<4; k++)\n\t\t\t\t\t\t\tmat[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int j=0; j<4; j++)\n\t\t\t\t\t\tfor(int k=0; k<2; k++)\n\t\t\t\t\t\t\tmat[x+j][y+k] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(mat[sx][sy]==-1){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdfs(sx,sy,mat[sx][sy]);\n\t\t\tSystem.out.println((mat[gx][gy]==-2)?\"OK\":\"NG\");\n\t\t}\n\t}\n\t\n\tstatic void dfs(int i, int j, int col){\n\t\tif(mat[i][j] != col) return ;\n\t\tmat[i][j] = -2;\n\t\tdfs(i+1,j,col);\n\t\tdfs(i,j+1,col);\n\t\tdfs(i-1,j,col);\n\t\tdfs(i,j-1,col);\n\t\treturn ;\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\n/**\n * Block\n */\npublic class Main {\n\n\tstatic int[][] board;\n\tfinal static int BLOCK_WIDTH = 4;\n\tfinal static int BLOCK_HEIGHT = 2;\n\tfinal static int EMPTY = 0;\n\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0 0\")) {\n\n\t\t\tw = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\th = Integer.parseInt(line.trim().substring(line.indexOf(' ') + 1));\n\n\t\t\tboard = new int[w + 1][h + 1];\n\n\t\t\tline = br.readLine();\n\t\t\tint xs = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint ys = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tline = br.readLine();\n\t\t\tint xg = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint yg = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tputBlock(br.readLine());\n\t\t\t}\n\n\t\t\tif (solve(xs, ys, xg, yg)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic void putBlock(String info) {\n\t\tStringTokenizer st = new StringTokenizer(info);\n\n\t\tint c, d, x, y;\n\t\tc = Integer.parseInt(st.nextToken());\n\t\td = Integer.parseInt(st.nextToken());\n\t\tx = Integer.parseInt(st.nextToken());\n\t\ty = Integer.parseInt(st.nextToken());\n\n\t\tputBlock(c, d, x, y);\n\t}\n\n\tstatic void putBlock(int c, int d, int x, int y) {\n\n\t\tif (d == 0) {\n\t\t\tfor (int i = x; i < x + BLOCK_WIDTH; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_HEIGHT; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = x; i < x + BLOCK_HEIGHT; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_WIDTH; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean solve(int xs, int ys, int xg, int yg) {\n\n\t\tfinal int V[] = { 1, -1, 0, 0 };\n\t\tfinal int H[] = { 0, 0, 1, -1 };\n\n\t\tif (board[xs][ys] != board[xg][yg]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint[] next, prev;\n\t\tnext = new int[] { xs, ys };\n\t\tArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n\t\tqueue.offer(next);\n\n\t\twhile (!queue.isEmpty()) {\n\n\t\t\tprev = queue.poll();\n\n\t\t\tint px, py, nx, ny, c;\n\t\t\tpx = prev[0];\n\t\t\tpy = prev[1];\n\t\t\tc = board[px][py];\n\t\t\tboard[px][py] = EMPTY;\n\n\t\t\tif (px == xg && py == yg) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tnx = px + V[i];\n\t\t\t\tny = py + H[i];\n\t\t\t\tif (nx > 0 && nx < w + 1 && ny > 0 && ny < h + 1) {\n\t\t\t\t\tif (board[nx][ny] == c) {\n\t\t\t\t\t\tqueue.offer(new int[] { nx, ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    boolean[][] visit;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    visit = new boolean[h][w];\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      マンハッタン距離が近くなるように道を選ぶ\n      (マンハッタン短縮を見つけられなければ)行ける所に行く\n      どこにも行けなければほげ。\n    */\n    boolean search(int x, int y){\n\tvisit[y][x] = true;\n\tint d = getD(x, y);\n\tboolean[] goodRoute = new boolean[4];\n\tboolean[] canRoute = new boolean[4];\n\tint gc = 0;\n\tint cc = 0;\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a] && !visit[b][a]){\n\t\tcanRoute[i] = true;\n\t\tcc++;\n\t\tif(getD(a, b)<d){\n\t\t    goodRoute[i] = true;\n\t\t    gc++;\n\t\t}\n\t    }\n\t}\n\t\n\tif(gc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(goodRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\telse if(cc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(canRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\t\t    \n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\t//Input\n\t\t\tfinal int w = sc.nextInt(); final int h = sc.nextInt();\n\t\t\tif(w==0 && h==0){ break; }\n\t\t\tfinal int xs = sc.nextInt(); final int ys = sc.nextInt();\n\t\t\tfinal int xg = sc.nextInt(); final int yg = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tint[][] map = new int[h+2][w+2];\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tfinal int c = sc.nextInt();  final int d = sc.nextInt();\n\t\t\t\tfinal int x = sc.nextInt();  final int y = sc.nextInt();\n\t\t\t\tfor(int ty=y; ty<y+2+2*d; ++ty){\n\t\t\t\t\tfor(int tx=x; tx<x+2+2*Math.abs(d-1); ++tx){\n\t\t\t\t\t\tmap[ty][tx] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//algorithm(BFS)\n\t\t\tboolean f = true;\n\t\t\tfinal int[][] ofs = {\n\t\t\t\t\t{1, 0}, {0, 1}, {-1, 0}, {0, -1}\n\t\t\t};\n\t\t\tQueue<int[]> que = new LinkedList<int[]>();\n\t\t\tint next[] = {xs, ys};\n\t\t\tque.offer(next);\n\t\t\tfinal int col = map[next[1]][next[0]];\n\t\t\tif(col == 0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap[next[1]][next[0]] = 0;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tnext = que.poll();\n\t\t\t\tif(next[0] == xg && next[1] == yg){\n\t\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\tif(map[next[1] + ofs[i][1] ][next[0] + ofs[i][0] ] == col){\n\t\t\t\t\t\tfinal int e[] = {\n\t\t\t\t\t\t\t\tnext[0] + ofs[i][0], next[1] + ofs[i][1]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tque.offer(e);\n\t\t\t\t\t\tmap[e[1]][e[0]] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      マンハッタン距離が近くなるように道を選ぶ\n      選べなければ行ける所に行く\n      どこにも行けなければほげ。\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tif(route[b][a] && getD(a, b)<d){\n\t\t    if(search(a, b)) return true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint [][] field;\n\tint goalx;\n\tint goaly;\n\tint moveColor;\n\n\tprivate boolean move(int x, int y){\n\n\t\tif(x == goalx && y == goaly){\n\t\t\treturn true;\n\t\t}\n\t\tif(field[y][x] != moveColor){\n\t\t\treturn false;\n\t\t}\n\t\tfield[y][x] = -1;\n\t\tif(move(x+1,y) || move(x-1,y) || move(x,y+1) || move(x,y-1))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new int[h+2][w+2];\n\t\t\tint xs = sc.nextInt();\n\t\t\tint ys = sc.nextInt();\n\t\t\tgoalx = sc.nextInt();\n\t\t\tgoaly = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\t//read a block\n\t\t\tint [][] block = new int[n][4];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\t\tblock[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tint x = block[i][2];\n\t\t\t\tint y = block[i][3];\n\t\t\t\tif(block[i][1] == 0){\n\t\t\t\t\tfor(int k=y; k < y+2; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+4; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k=y; k < y+4; k++ ){\n\t\t\t\t\t\tfor(int j=x; j < x+2; j++){\n\t\t\t\t\t\t\tfield[k][j] = block[i][0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set flame\n\t\t\tfor(int i=0; i <= w + 1; i++){\n\t\t\t\tfield[0][i] = -1;\n\t\t\t\tfield[h+1][i] = -1;\n\t\t\t\tfield[i][0] = -1;\n\t\t\t\tfield[i][w+1] = -1;\n\t\t\t}\n\n\t\t\t//start\n\t\t\tmoveColor = field[ys][xs];\n\t\t\tif(moveColor == 0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean ans = move(xs, ys);\n\n\t\t\t//print\n\t\t\tif(ans)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int W,H;\n\tstatic int map[][];\n\tstatic int C,xg,yg,judge;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tmap=new int[H+1][W+1];\n\t\t\tint xs=in.nextInt(),ys=in.nextInt();\n\t\t\txg=in.nextInt();yg=in.nextInt();\n\t\t\tint n=in.nextInt();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tint c=in.nextInt(),d=in.nextInt();\n\t\t\t\tint x=in.nextInt(),y=in.nextInt();\n\t\t\t\tif(d==0)\n\t\t\t\t{\n\t\t\t\t\tfor(int h=y;h<y+2;h++)\n\t\t\t\t\t\tfor(int w=x;w<x+4;w++)\n\t\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int h=y;h<y+4;h++)\n\t\t\t\t\t\tfor(int w=x;w<x+2;w++)\n\t\t\t\t\t\t\tmap[h][w]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tC=map[ys][xs];\n\t\t\tjudge=0;\n\t\t\tif(solve(ys,xs)==1)\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t}\n\t}\n\n\tpublic static int solve(int h, int w)\n\t{\n\t\tif(h==yg&&w==xg)\n\t\t{\n\t\t\tjudge=1;\n\t\t\treturn judge;\n\t\t}\n\t\tmap[h][w]=6;\n\t\tif(h-1>=1&&map[h-1][w]==C)\n\t\t\tsolve(h-1,w);\n\t\tif(w-1>=1&&map[h][w-1]==C)\n\t\t\tsolve(h,w-1);\n\t\tif(h+1<=H&&map[h+1][w]==C)\n\t\t\tsolve(h+1,w);\n\t\tif(w+1<=W&&map[h][w+1]==C)\n\t\t\tsolve(h,w+1);\n\t\treturn judge;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint w, h;\n\t\twhile ((w = in.nextInt()) != 0 && (h = in.nextInt()) != 0) {\n\t\t\tint xs = in.nextInt();\n\t\t\tint ys = in.nextInt();\n\t\t\tint xg = in.nextInt();\n\t\t\tint yg = in.nextInt();\n\t\t\tint[][] b = new int[w + 1][h + 1];\n\t\t\tint n = in.nextInt();\n\t\t\twhile (n-- > 0) {\n\t\t\t\tsetBlock(b, in.nextInt(), in.nextInt(), in.nextInt(),\n\t\t\t\t\t\tin.nextInt());\n\t\t\t}\n\t\t\tString ans;\n\t\t\tif (b[xs][ys] == b[xg][yg]) {\n\t\t\t\tsolid(b, b[xs][ys], xs, ys, xg, yg);\n\t\t\t\tans = b[xs][ys] == b[xg][yg] ? \"OK\" : \"NG\";\n\t\t\t} else {\n\t\t\t\tans = \"NG\";\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tstatic void setBlock(int[][] b, int c, int d, int x, int y) {\n\t\tb[x][y] = b[x + 1][y] = b[x][y + 1] = b[x + 1][y + 1] = c;\n\t\tif (d == -1) {\n\t\t\treturn;\n\t\t} else if (d == 0) {\n\t\t\tsetBlock(b, c, -1, x + 2, y);\n\t\t} else if (d == 1) {\n\t\t\tsetBlock(b, c, -1, x, y + 2);\n\t\t}\n\t}\n\n\tstatic void solid(int[][] b, int c, int x, int y, int xg, int yg) {\n\t\tif (b[x][y] == c) {\n\t\t\tb[x][y] = -1;\n\t\t\tif (x == xg && y == yg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsolid(b, c, x + 1, y, xg, yg);\n\t\t\tsolid(b, c, x - 1, y, xg, yg);\n\t\t\tsolid(b, c, x, y + 1, xg, yg);\n\t\t\tsolid(b, c, x, y - 1, xg, yg);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h, xs, ys, xg, yg, n, c, d, x, y;\n\tint[][] map;\n\tint[][] visit;\n\t\n\tvoid loop(int p, int q, int r){\n\t\tvisit[p][q] = 1;\n\t\t\n\t\tif(visit[p][q+1]==0 && map[p][q+1]==r) loop(p,q+1,r);\n\t\tif(visit[p+1][q]==0 && map[p+1][q]==r) loop(p+1,q,r);\n\t\tif(visit[p][q-1]==0 && map[p][q-1]==r) loop(p,q-1,r);\n\t\tif(visit[p-1][q]==0 && map[p-1][q]==r) loop(p-1,q,r);\n\t}\n\t\n\tvoid solve(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0) return;\n\t\t\txs = sc.nextInt();\n\t\t\tys = sc.nextInt();\n\t\t\txg = sc.nextInt();\n\t\t\tyg = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tvisit = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc = sc.nextInt();\n\t\t\t\td = sc.nextInt();\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tif(d==0){\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y][x+j]=c;\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+1][x+j]=c;\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+j][x]=c;\n\t\t\t\t\tfor(int j=0;j<4;j++) map[y+j][x+1]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(map[ys][xs]==0){\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}else{\n\t\t\t\tloop(ys, xs, map[ys][xs]);\n\t\t\t\tif(visit[yg][xg]==1) System.out.println(\"OK\");\n\t\t\t\telse System.out.println(\"NG\");\t\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static final int[] blockW = {4,2};\n\tpublic static final int[] blockH = {2,4};\n\tpublic static final int INF = 100000000;\n\tpublic static final int[] vx = {1,0,-1,0};\n\tpublic static final int[] vy = {0,-1,0,1};\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif (w+h==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tPos2d start = new Pos2d(sc.nextInt()-1,sc.nextInt()-1);\n\t\t\tPos2d goal = new Pos2d(sc.nextInt()-1,sc.nextInt()-1);\n\n\t\t\tint n = sc.nextInt();\n\t\t\tint[][] maze = new int[w][h];\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt()-1;\n\t\t\t\tint y = sc.nextInt()-1;\n\t\t\t\tfor (int j=0;j<blockW[d];j++) {\n\t\t\t\t\tfor (int k=0;k<blockH[d];k++) {\n\t\t\t\t\t\tmaze[x+j][y+k] = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ans = false;\n\t\t\tif (maze[start.x][start.y]!=0) {\n\t\t\t\tint mc = maze[start.x][start.y];\n\t\t\t\tboolean[][] reach = new boolean[w][h];\n\t\t\t\tQueue<Pos2d> q = new ArrayDeque<Pos2d>();\n\t\t\t\tq.offer(start);\n\t\t\t\twhile(!q.isEmpty()) {\n\t\t\t\t\tPos2d p = q.poll();\n\t\t\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\t\t\tint nx = p.x + vx[i];\n\t\t\t\t\t\tint ny = p.y + vy[i];\n\t\t\t\t\t\tif (nx>= 0 && nx<w && ny>=0 && ny<h) {\n\t\t\t\t\t\t\tif (maze[nx][ny]==mc) {\n\t\t\t\t\t\t\t\tif (!reach[nx][ny]) {\n\t\t\t\t\t\t\t\t\treach[nx][ny]=true;\n\t\t\t\t\t\t\t\t\tq.offer(new Pos2d(nx,ny));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = reach[goal.x][goal.y];\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"OK\" : \"NG\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int[] vx={0,1,0,-1}, vy={-1,0,1,0};\n\tstatic class Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\tthis.x=x;\tthis.y=y;}\n\t\tPoint(){\tthis.x=0; this.y=0;}\n\t\t@Override public String toString(){\treturn \"(\"+this.x+\",\"+this.y+\")\";}\n\t\tstatic boolean ok(int x,int y,int X,int Y,int min){\n\t\t\treturn (min<=x&&x<X && min<=y&&y<Y)?true:false;\n\t\t}\n\t\tstatic boolean ok(int x,int y,int X,int Y){\treturn ok(x,y,X,Y,0);}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0207();\n\t}\n\t\n\tvoid AOJ1114(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint[][] b=new int[5][5];\n\t\t\tfor(int y=0; y<5; y++){\n\t\t\t\tfor(int x=0; x<5; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tint ans=0;\n\t\t\tfor(int i=0; i<5; i++){\n\t\t\t\tfor(int j=0; j<5; j++){\n\t\t\t\t\tif(b[i][j]==1)\tans=max(ans,solve1114(i,j,b));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint solve1114(int x,int y,int[][] b){\n\t\tint ans=0;\n\t\tfor(int i=0; i+x<5; i++){\n\t\t\tif(b[i+x][y]==0)\tbreak;\n\t\t\tboolean flag=true;\n\t\t\tfor(int j=0; j+y<5; j++){\n\t\t\t\tfor(int k=0; k<=i; k++){\n\t\t\t\t\tfor(int l=0; l<=j; l++){\n\t\t\t\t\t\tif(b[k+x][l+y]==0){\n\t\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flag)\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!flag)\tbreak;\n\t\t\t\tans=max(ans,(i+1)*(j+1));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint step=0;\n\t// バックトラック（TLE）\n\tvoid AOJ1126(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++)\tc[x][y]=line.charAt(x);\n\t\t\t}\n\t\t\tString ans=\"\";\n\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\tif(Character.isDigit(c[x][y])){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]) && c[x-1][y]!='0')\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]) && c[x][y-1]!='0')\tcontinue;\n\t\t\t\t\t\tif(c[x][y]=='0')\tcontinue;\n\t\t\t\t\t\tString temp=solve1126(x,y,\"\"+c[x][y],c,W,H);\n\t\t\t\t\t\tans=compara1126(temp,ans)?temp:ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\t// TODO debug\n\t\tout.println(step+\"steps\");\n\t}\n\tString solve1126(int x,int y,String ans,char[][] c,int W,int H){\n\t\tString r=ans;\n\t\t//TODO debug\n\t\tstep++;\n\t\t//out.println(ans);\n\t\tfor(int i=1; i<3; i++){\n\t\t\tint xx=x+vx[i], yy=y+vy[i];\n\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\tString temp=solve1126(xx,yy,ans+c[xx][yy],c,W,H);\n\t\t\t\tr=compara1126(r,temp)?r:temp;\n\t\t\t\tout.println(temp);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\t// 第一引数aの方が大きい時のみtrue\n\tboolean compara1126(String a,String b){\n\t\tif(a.length()>b.length())\treturn true;\n\t\tif(a.length()==b.length()){\n\t\t\tfor(int i=0; i<a.length(); i++){\n\t\t\t\tif(a.charAt(i)>b.charAt(i))\treturn true;\n\t\t\t\tif(a.charAt(i)<b.charAt(i))\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t// 横型探索（TLE）\n\tvoid OldAOJ1126(){\n\t\tint step=0;\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tString ans=\"\";\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W][H];\n\t\t\tString[][] close=new String[W][H];\n\t\t\tLinkedList<C1126> open=new LinkedList<C1126>();\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t\tif(Character.isDigit(line.charAt(x))){\n\t\t\t\t\t\tif(x>0)\tif(Character.isDigit(c[x-1][y]))\tcontinue;\n\t\t\t\t\t\tif(y>0)\tif(Character.isDigit(c[x][y-1]))\tcontinue;\n\t\t\t\t\t\topen.add(new C1126(x,y,\"\"+c[x][y]));\n\t\t\t\t\t\tclose[x][y]=\"\"+c[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC1126 now=open.poll();\n\t\t\t\t// TODO debug\n\t\t\t\tout.println(\"ANS\"+ans+\" NOW\"+now.ans);\n\t\t\t\tans=now.compara(ans)?new String(now.ans):ans;\n\t\t\t\tfor(int i=1; i<3; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx,yy,W,H))\tcontinue;\n\t\t\t\t\tif(Character.isDigit(c[xx][yy])){\n\t\t\t\t\t\tC1126 temp=new C1126(xx,yy,now.ans+c[xx][yy]);\n\t\t\t\t\t\tif(close[xx][yy]==null){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}else if(temp.compara(close[xx][yy])){\n\t\t\t\t\t\t\topen.add(temp);\n\t\t\t\t\t\t\tclose[xx][yy]=temp.ans;\n\t\t\t\t\t\t\tstep++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.println(step+\"step\");\n\t}\n\tclass C1126{\n\t\tint x,y;\tString ans;\n\t\tC1126(int x,int y,String ans){\n\t\t\tthis.x=x;\tthis.y=y;\n\t\t\tif(ans.length()>0){\n\t\t\t\tint i=0;\n\t\t\t\twhile(ans.charAt(i)=='0'){\n\t\t\t\t\tif(++i>=ans.length()-1)\tbreak;\n\t\t\t\t\tans=ans.substring(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ans=ans;\n\t\t}\n\t\tboolean compara(String ans){\n\t\t\tif(this.ans.length()>ans.length())\treturn true;\n\t\t\tif(this.ans.length()==ans.length()){\n\t\t\t\tfor(int i=0; i<ans.length(); i++){\n\t\t\t\t\tif(ans.charAt(i)<this.ans.charAt(i))\treturn true;\n\t\t\t\t\tif(ans.charAt(i)>this.ans.charAt(i))\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tvoid AOJ0165(){\n\t\tfinal int MAX=1000000;\n\t\tboolean[] prime=Sieve(MAX);\n\t\tint[] prime2=new int[MAX+1];\n\t\tfor(int i=2; i<=MAX; i++)\tprime2[i]=(prime[i]?prime2[i-1]+1:prime2[i-1]);\n\t\twhile(sc.hasNext()){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)\tbreak;\n\t\t\tint ans=0;\n\t\t\tfor(int i=1; i<=N; i++){\n\t\t\t\tint p=sc.nextInt(), m=sc.nextInt();\n\t\t\t\tint min=max(1,p-m), max=min(MAX, p+m);\n\t\t\t\tint temp=prime2[max]-prime2[min-1];\n\t\t\t\t//out.println(\"TEMP\"+temp);\n\t\t\t\tans+=temp-1;\n\t\t\t}\n\t\t\tout.println(max(0,ans));\n\t\t}\n\t}\n\t\n\tvoid AOJ1144(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt();\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// TODO 果樹園　RE　横型\n\tvoid AOJ0118(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(), ans=0;\n\t\t\tif((X|Y)==0)\tbreak;\n\t\t\tchar[][] c=new char[X+10][Y+10];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\t\tif(c[x][y]=='&')\tcontinue;\n\t\t\t\t\tans++;\n\t\t\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\tchar mark=c[x][y];\n\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\tc[now.x][now.y]='&';\n\t\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]==mark){\n\t\t\t\t\t\t\t\t//out.println((now.x+vx[i])+\" \"+(now.y+vy[i]));\n\t\t\t\t\t\t\t\topen.add(new Point(now.x+vx[i],now.y+vy[i]));\n\t\t\t\t\t\t\t\tc[now.x+vx[i]][now.y+vy[i]]='&';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//out.println(\"ANS\"+ans);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// Red and Black 横型探索\n\tvoid AOJ1130(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(), Y=sc.nextInt(),sx=0,sy=0,ans=0;\n\t\t\tif(X==0)\tbreak;\n\t\t\tchar[][] c=new char[X][Y];\n\t\t\tfor(int y=0; y<Y; y++){\n\t\t\t\tchar[] line=sc.next().toCharArray();\n\t\t\t\tfor(int x=0; x<X; x++){\n\t\t\t\t\tc[x][y]=line[x];\n\t\t\t\t\tif(line[x]=='@'){\n\t\t\t\t\t\tsx=x;\tsy=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tboolean[][] close=new boolean[X][Y];\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tans++;\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(now.x+vx[i]<0 || now.x+vx[i]>=X || now.y+vy[i]<0 || now.y+vy[i]>=Y)\tcontinue;\n\t\t\t\t\tif(c[now.x+vx[i]][now.y+vy[i]]=='.' && !close[now.x+vx[i]][now.y+vy[i]]){\n\t\t\t\t\t\topen.add(new Point(now.x+vx[i], now.y+vy[i]));\n\t\t\t\t\t\tclose[now.x+vx[i]][now.y+vy[i]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\t\n\t// TODO デパート　TLE MLE WA\n\tvoid AOJ0223(){\n\t\twhile(sc.hasNext()){\n\t\t\tint X=sc.nextInt(),\tY=sc.nextInt();\n\t\t\tif(X==0)\tbreak;\n\t\t\tint tx=sc.nextInt(), ty=sc.nextInt(), kx=sc.nextInt(), ky=sc.nextInt();\n\t\t\tint[][] b=new int[X+1][Y+1];\n\t\t\tfor(int y=1; y<=Y; y++){\n\t\t\t\tfor(int x=1; x<=X; x++)\tb[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tLinkedList<C0223> open=new LinkedList<C0223>();\n\t\t\topen.add(new C0223(tx,ty,kx,ky,0));\n\t\t\tint[][][][] close2=new int[X+1][Y+1][X+1][Y+1];\n\t\t\tclose2[tx][ty][kx][ky]=-1;\n\t\t\tint ans=-1;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tC0223 now=open.poll();\n\t\t\t\tif(now.ans()){\n\t\t\t\t\tans=now.sec;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(now.sec>=99)\tbreak;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(0<now.tx+vx[i]&&now.tx+vx[i]<=X && 0<now.ty+vy[i]&&now.ty+vy[i]<=Y && 0<now.kx-vx[i]&&now.kx-vx[i]<=X && 0<now.ky-vy[i]&&now.ky-vy[i]<=Y){\n\t\t\t\t\t\ttx=now.tx;\tty=now.ty;\tkx=now.kx;\tky=now.ky;\n\t\t\t\t\t\tif(b[tx+vx[i]][ty+vy[i]]==0){\n\t\t\t\t\t\t\ttx+=vx[i];\tty+=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(b[kx-vx[i]][ky-vy[i]]==0){\n\t\t\t\t\t\t\tkx-=vx[i];\tky-=vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//out.println(\"TEMP:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t//if(tx==kx && ty==ky)\tans=ans<0?now.sec+1:min(ans,now.sec+1);\n\t\t\t\t\t\tif(close2[tx][ty][kx][ky]==0 || close2[tx][ty][kx][ky]>now.sec+1){\n\t\t\t\t\t\t\t//out.println(\"ADD:\"+tx+\" \"+ty+\" \"+kx+\" \"+ky);\n\t\t\t\t\t\t\topen.add(new C0223(tx,ty,kx,ky,now.sec+1));\n\t\t\t\t\t\t\tclose2[tx][ty][kx][ky]=now.sec+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans<0? \"NA\": ans);\n\t\t}\n\t}\n\tclass C0223{\n\t\tint tx,ty,kx,ky,sec;\n\t\tC0223(int tx, int ty, int kx, int ky, int sec){\n\t\t\tthis.tx=tx;\tthis.ty=ty;\tthis.kx=kx;\tthis.ky=ky;\tthis.sec=sec;\n\t\t}\n\t\tboolean ans(){\n\t\t\tif(this.tx==this.kx && this.ty==this.ky)\treturn true;\n\t\t\telse\treturn false;\n\t\t}\n\t}\n\t\n\t\n\t// TODO WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\t\n\t// TODO レゴ　WA\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[W+1][H+1];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO debug\n\t\t\t//de0207(b,W,H);\n\t\t\tint c=b[sx][sy];\n\t\t\tif(c==0){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\tboolean[][] close=new boolean[W+1][H+1];\n\t\t\topen.add(new Point(sx,sy));\n\t\t\tclose[sx][sy]=true;\n\t\t\tString ans=\"NG\";\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tPoint now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\tif(!Point.ok(xx, yy, W+1, H+1, 1))\tcontinue;\n\t\t\t\t\tif(b[xx][yy]!=c)\tcontinue;\n\t\t\t\t\tif(close[xx][yy])\tcontinue;\n\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t\tif(xx==gx && yy==gy){\n\t\t\t\t\t\tans=\"OK\";\n\t\t\t\t\t\topen.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t\tArrayList<Integer> prime = new ArrayList<Integer>();\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[1]=false;\n\t\tfor (int i=2; i<=N; i++) {\n\t\t\tif(list[i]) {\n\t\t\t\tprime.add(i);\n\t\t\t\tfor (int j=i+i; j<=N; j+=i)\tlist[j] = false;\n\t\t\t}\n\t\t}\n\t\treturn prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t\tboolean[] list = new boolean[N+1];\n\t\tArrays.fill(list, true);\n\t\tlist[0]=false;\tlist[1]=false;\n\t\tfor(int j=4; j<=N; j+=2)\tlist[j]=false;\n\t\tfor(int i=3; i*i<=N; i+=2)\tif(list[i])\tfor (int j=i+i; j<=N; j+=i)\tlist[j]=false;\n\t\treturn list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t\tfor(int i=2; i*i<=n; i++){\n\t\t\tif(n%i==0)     return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 0, -1, 0};\n    int[] dirY = {0, 1, 0, -1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==1 && h==1) break;\n\t    put();\n\t    makeRoute();\n\t    //show();\n\n\t    if(!route[ys][xs] || !route[yg][xg]){\n\t\tSystem.out.println(\"NG\");\n\t\tcontinue;\n\t    }\n\t    else System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    /*\n      マンハッタン距離が近くなるように道を選ぶ\n      (マンハッタン短縮を見つけられなければ)行ける所に行く\n      どこにも行けなければほげ。\n    */\n    boolean search(int x, int y){\n\tint d = getD(x, y);\n\tboolean[] goodRoute = new boolean[4];\n\tboolean[] canRoute = new boolean[4];\n\tint gc = 0;\n\tint cc = 0;\n\tif(d==0) return true;\n\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<w && b>0 && b<h && route[b][a]){\n\t\tcanRoute[i] = true;\n\t\tcc++;\n\t\tif(getD(a, b)<d){\n\t\t    goodRoute[i] = true;\n\t\t    gc++;\n\t\t}\n\t    }\n\t}\n\t\n\tif(gc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(goodRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\telse if(cc!=0){\n\t    for(int i=0; i<4; i++)\n\t\tif(canRoute[i]) \n\t\t    if(search(x+dirX[i], y+dirY[i])) return true;\n\t}\n\t\t    \n\treturn false;\n    }\n\n    int getD(int x, int y){ return Math.abs(xg-x) + Math.abs(yg-y); }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(route[i][k] ? \"□\":\"■\");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"----------------\");\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[h][w];\n\troute = new boolean[h][w];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[b][a] = c;    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[b][a] = c;\n\t}\n    }\n\n    void makeRoute(){\n\tint tcolor = block[ys][xs];\n\tfor(int i=0; i<w; i++)\n\t    for(int k=0; k<h; k++)\n\t\tif(block[k][i]==tcolor) route[k][i] = true;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ0207();\n\t}\n\t\n\t// WA\n\tvoid AOJ0142(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tint nn=(n-1)/2;\n\t\t\tboolean[] b=new boolean[n];\n\t\t\tfor(int i=1; i<n; i++)\tb[(i*i)%n]=true;\n\t\t\tArrayList<Integer> ar=new ArrayList<Integer>();\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tif(b[i])\tar.add(i);\n\t\t\t}\n\t\t\tint[] ans=new int[nn+1];\n\t\t\tfor(int i=0; i<ar.size(); i++){\n\t\t\t\tfor(int j=0; j<ar.size(); j++){\n\t\t\t\t\tif(i==j)\tcontinue;\n\t\t\t\t\tint temp=ar.get(i)-ar.get(j);\n\t\t\t\t\ttemp+= temp<0? n:0;\n\t\t\t\t\ttemp= temp>nn? n-temp: temp;\n\t\t\t\t\tans[temp]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1; i<=nn; i++)\tout.println(ans[i]);\n\t\t}\n\t}\n\t\n\tvoid AOJ0207(){\n\t\twhile(sc.hasNext()){\n\t\t\tint w=sc.nextInt(), h=sc.nextInt();\n\t\t\tif(w==0)\tbreak;\n\t\t\tint sx=sc.nextInt(), sy=sc.nextInt(), gx=sc.nextInt(), gy=sc.nextInt(), n=sc.nextInt();\n\t\t\tint[][] b=new int[w+2][h+2];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tint color=sc.nextInt(), d=sc.nextInt(), x=sc.nextInt(), y=sc.nextInt();\n\t\t\t\tif(d==0){\t// 横 4x2\n\t\t\t\t\tfor(int j=y; j<y+2; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+4; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}else{\t// 縦 2x4\n\t\t\t\t\tfor(int j=y; j<y+4; j++){\n\t\t\t\t\t\tfor(int k=x; k<x+2; k++)\tb[k][j]=color;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t\tint[] vx={1,0,-1,0}, vy={0,1,0,-1};\n\t\t\tint xx=sx, yy=sy, cc=b[sx][sy], v=0;\n\t\t\tif(cc<1){\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tif(xx==gx && yy==gy && b[xx][yy]==cc){\n\t\t\t\t\tout.println(\"OK\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb[xx][yy]=6;\n\t\t\t\tboolean flag=false;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t//out.println(\"X\"+xx+\" Y\"+yy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\txx-=vx[v];\tyy-=vy[v];\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tif(b[xx+vx[i]][yy+vy[i]]==cc){\n\t\t\t\t\t\txx+=vx[i];\tyy+=vy[i];\tv=i;\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag)\tcontinue;\n\t\t\t\t//out.println(\"END : X\"+xx+\" Y\"+yy);\n\t\t\t\tout.println(\"NG\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//debug\n\t\t\t//de0207(b,w,h);\n\t\t}\n\t}\n\tvoid de0207(int[][] b, int w, int h){\n\t\tfor(int j=0; j<=h; j++){\n\t\t\tfor(int i=0; i<=w; i++)\tout.print(b[i][j]+\" \");\n\t\t\tout.println();\n\t\t}\n\t\tfor(int i=0; i<=w; i++)\tout.print(\"-\");\n\t\tout.println();\n\t}\n\t\n\tvoid AOJ1136(){\n\t\twhile(sc.hasNext()){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tsolve1136(n);\n\t\t\tout.println(\"+++++\");\n\t\t}\n\t}\n\tvoid solve1136(int N){\t// N本の折れ線\n\t\t// 元の直線0\n\t\tint a0=sc.nextInt();\n\t\tint[] v0=new int[a0], len0=new int[a0];\n\t\tint lx=sc.nextInt(), ly=sc.nextInt();\n\t\tfor(int i=1; i<a0; i++){\n\t\t\tint x=sc.nextInt(), y=sc.nextInt();\n\t\t\tv0[i]=v1136(x,y,lx,ly);\n\t\t\tlen0[i]=max(abs(y-ly),abs(x-lx));\n\t\t\tlx=x;\tly=y;\n\t\t}\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tint a=sc.nextInt();\n\t\t\t//if(a!=a0)\tcontinue;\n\t\t\t// a!=a0で飛ばした時に読み込みがずれる\n\t\t\tint[] v=new int[a], len=new int[a];\n\t\t\tlx=sc.nextInt();\tly=sc.nextInt();\n\t\t\tfor(int j=1; j<a; j++){\n\t\t\t\tint x=sc.nextInt(),y=sc.nextInt();\n\t\t\t\tv[j]=v1136(x,y,lx,ly);\n\t\t\t\tlen[j]=max(abs(y-ly),abs(x-lx));\n\t\t\t\tlx=x;\tly=y;\n\t\t\t}\n\t\t\tif(a!=a0)\tcontinue;\n\t\t\tif(isSame(v0,len0,v,len))\tout.println(i);\n\t\t\telse if(isSame2(v0,len0,v,len))\tout.println(i);\n\t\t}\n\t}\n\tint v1136(int x, int y, int lx, int ly){\n\t\tif(y>ly)\treturn 1;\n\t\telse if(x>lx)\treturn 2;\n\t\telse if(y<ly)\treturn 3;\n\t\telse if(x<lx)\treturn 4;\n\t\treturn 0;\n\t}\n\tboolean isSame(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<len.length; i++){\n\t\t\tif(len0[i]!=len[i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tboolean isSame2(int[] v0, int[] len0, int[] v, int[] len){\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tif(len0[i]!=len[v.length-i])\treturn false;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int j=0; j<4; j++){\n\t\t\tfor(int i=1; i<v.length; i++){\n\t\t\t\tif(v0[i]!=v[v.length-i]){\n\t\t\t\t\tv=turn1136(v,1);\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==j)\tbreak;\n\t\t}\n\t\treturn ans!=4;\n\t}\n\tint[] turn1136(int[] v, int n){\n\t\tif(n==0)\treturn v;\n\t\tint[] ans=new int[v.length];\n\t\tfor(int i=1; i<v.length; i++){\n\t\t\tans[i]=v[i]+n>4? 1: v[i]+n;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tvoid AOJ0141(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==1){\n\t\t\t\tout.println(\"#\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar[][] c=new char[n+1][n+1];\n\t\t\tfor(int i=1; i<=n; i++){\n\t\t\t\tfor(int j=1; j<=n; j++)\tc[i][j]=' ';\n\t\t\t}\n\t\t\tfor(int i=n; i>0; i--)\tc[1][i]='#';\n\t\t\tfor(int i=1; i<=n; i++)\tc[i][1]='#';\n\t\t\tif(n>2){\n\t\t\t\tfor(int i=1; i<=n; i++)\tc[n][i]='#';\n\t\t\t}\n\t\t\tif(n>3){\n\t\t\t\tfor(int i=n; i>2; i--)\tc[i][n]='#';\n\t\t\t}\n\t\t\tif(n>4){\n\t\t\t\tint[] vx={0, 1, 0, -1,1,1,-1,-1};\n\t\t\t\tint[] vy={-1, 0, 1, 0,-1,1,-1,1};\n\t\t\t\tc=solve141(3, n-1, n, c, vx, vy, 0);\n\t\t\t}\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tfor(int i=1; i<=n; i++)\tout.print(c[i][j]);\n\t\t\t\tout.println();\n\t\t\t}\n\t\t\tif(I!=N)\tout.println();\t// 最後のデータセットの改行\n\t\t}\n\t}\n\t// 今のx,y　n縦横　c版　vx,vy移動,　f方向\n\tchar[][] solve141(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\twhile(true){\n\t\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\t\tboolean flag=true;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\tc[x][y]='#';\n\t\t\t\t//return solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tx=xx;\ty=yy;\n\t\t\t\tf= f+1<4? f+1: 0;\n\t\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\t\t//return solve141(x, y, n,c,vx,vy,f);\n\t\t\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\t\tbreak;\n\t\t}\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t// 再帰だとスタックオーバーフロー（手元では106まで行けたが）\n\tchar[][] solve141old(int x, int y, int n, char[][] c, int[] vx, int[] vy, int f){\n\t\tint xx=x-vx[f], yy=y-vy[f];\n\t\tboolean flag=true;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tif(x+vx[i]==xx || y+vy[i]==yy)\tcontinue;\n\t\t\tif(0>=x+vx[i]||x+vx[i]>n || 0>=y+vy[i]||y+vy[i]>n){\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(c[x+vx[i]][y+vy[i]]=='#')\t{\n\t\t\t\tflag=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\t//out.println(\"A:\"+x+\" \"+y);\n\t\t\treturn c;\n\t\t}\n\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\tc[x][y]='#';\n\t\t\treturn solve141(x+vx[f], y+vy[f], n,c,vx,vy,f);\n\t\t}else{\n\t\t\tx=xx;\ty=yy;\n\t\t\tf= f+1<4? f+1: 0;\n\t\t\tx+=vx[f];\ty+=vy[f];\n\t\t\tif(c[x+vx[f]][y+vy[f]]==' '){\n\t\t\t\treturn solve141(x, y, n,c,vx,vy,f);\n\t\t\t}\n\t\t}\n\t\t//out.println(\"B:\"+x+\" \"+y);\n\t\treturn c;\n\t\t//if(0<x+vx[f]&&x+vx[f]<=n && 0<y+vy[f]&&y+vy[f]<=n)\n\t}\n\t\n\tvoid AOJ0140(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint n=sc.nextInt(), m=sc.nextInt();\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tif(n>5){\n\t\t\t\tif(m<6){\n\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\tfor(int i=5; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t\t}else{\n\t\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int i=n; i<=9; i++)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=5; i>=0; i--)\tsb.append(i+\" \");\n\t\t\t\t\t\tfor(int i=1; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(n<m)\tfor(int i=n; i<=m; i++)\tsb.append(i+\" \");\n\t\t\t\telse\tfor(int i=n; i>=m; i--)\tsb.append(i+\" \");\n\t\t\t}\n\t\t\tsb.deleteCharAt(sb.length()-1);\n\t\t\tout.println(sb);\n\t\t}\n\t}\n\t\n\tvoid AOJ1135(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=sc.nextInt(), year=sc.nextInt(), n=sc.nextInt(), ans=0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(sc.nextInt()==1)\tans=max(ans, huku(a,year,sc.nextDouble(),sc.nextInt()));\n\t\t\t\telse\tans=max(ans, tan(a,year,sc.nextDouble(), sc.nextInt()));\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tint huku(int a, int year, double rate, int t){\n\t\tfor(int i=0; i<year; i++){\n\t\t\tint temp=(int) (a*rate);\n\t\t\ta+=temp-t;\n\t\t}\n\t\treturn a;\n\t}\n\tint tan(int a, int year, double rate, int t){\n\t\tint r=0;\n\t\tfor(int i=0; i<year; i++){\n\t\t\tr+=a*rate;\n\t\t\ta-=t;\n\t\t}\n\t\treturn a+r;\n\t}\n\t\n\tvoid AOJ1142(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tHashMap<String,Integer> map=new HashMap<String,Integer>();\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=1; i<s.length(); i++){\n\t\t\t\tString a=s.substring(0, i), b=s.substring(i);\n\t\t\t\tString aa=new StringBuilder(a).reverse().toString(), bb=new StringBuilder(b).reverse().toString();\n\t\t\t\t//out.println(\"A:\"+a+\" AA:\"+aa+\" B:\"+b+\" BB:\"+bb);\n\t\t\t\tmap.put(a+b,1);\n\t\t\t\tmap.put(aa+b,1);\n\t\t\t\tmap.put(a+bb,1);\n\t\t\t\tmap.put(aa+bb,1);\n\t\t\t\tmap.put(b+a,1);\n\t\t\t\tmap.put(bb+a, 1);\n\t\t\t\tmap.put(b+aa, 1);\n\t\t\t\tmap.put(bb+aa, 1);\n\t\t\t\t//out.println(map);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(map.size());\n\t\t}\n\t}\n\t\n\tvoid AOJ1137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int I=1; I<=N; I++){\n\t\t\tint a=toInt(sc.next()),b=toInt(sc.next());\n\t\t\t//out.println(\"A:\"+a+\" B:\"+b);\n\t\t\tout.println(toMcxi(a+b));\n\t\t}\n\t}\n\tint toInt(String s){\n\t\tint ans=0,temp=1;\n\t\tchar[] c=s.toCharArray();\n\t\tfor(int i=0; i<c.length; i++){\n\t\t\tif(c[i]=='m'){\n\t\t\t\tans+=temp*1000;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='c'){\n\t\t\t\tans+=temp*100;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='x'){\n\t\t\t\tans+=temp*10;\n\t\t\t\ttemp=1;\n\t\t\t}else if(c[i]=='i'){\n\t\t\t\tans+=temp;\n\t\t\t\ttemp=1;\n\t\t\t}else{\n\t\t\t\ttemp=Character.digit(c[i],10);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tString toMcxi(int n){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tif(n/1000>0){\n\t\t\tsb.append(n/1000==1?\"m\":(n/1000)+\"m\");\n\t\t\tn%=1000;\n\t\t}\n\t\tif(n/100>0){\n\t\t\tsb.append(n/100==1?\"c\":(n/100)+\"c\");\n\t\t\tn%=100;\n\t\t}\n\t\tif(n/10>0){\n\t\t\tsb.append(n/10==1?\"x\":(n/10)+\"x\");\n\t\t\tn%=10;\n\t\t}\n\t\tif(n>0)\tsb.append(n==1?\"i\":n+\"i\");\n\t\treturn sb.toString();\n\t}\n\t\n\tvoid AOJ0139(){\n\t\tint N=sc.nextInt();\n\t\tfinal Pattern ap=Pattern.compile(\"^>'(=+)#(=+)~$\");\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tString s=sc.next();\n\t\t\tMatcher m=ap.matcher(s);\n\t\t\tif(m.matches()){\n\t\t\t\tif(m.group(1).length()==m.group(2).length()){\n\t\t\t\t\tout.println(\"A\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(Pattern.compile(\"^>\\\\^(Q=)+~~$\").matcher(s).matches()){\n\t\t\t\tout.println(\"B\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout.println(\"NA\");\n\t\t}\n\t}\n\t\n\tvoid AOJ0137(){\n\t\tint N=sc.nextInt();\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tlong s=sc.nextLong();\n\t\t\tout.println(\"Case \"+i+\":\");\n\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\ts*=s;\ts/=100;\ts%=10000;\n\t\t\t\tout.println(s);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tArrayList<Integer> Sieve2(int N){\n\t    ArrayList<Integer> prime = new ArrayList<Integer>();\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for (int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            prime.add(i);\n\t            for (int j=i+i; j<=N; j+=i)    list[j] = false;\n\t        }\n\t    }\n\t    return prime;\n\t}\n\n\tboolean[] Sieve(int N){\n\t    boolean[] list = new boolean[N+1];\n\t    Arrays.fill(list, true);\n\t    list[1]=false;\n\t    for(int i=2; i<=N; i++) {\n\t        if(list[i]) {\n\t            for (int j=i+i; j<=N; j+=i)     list[j] = false;\n\t        }\n\t    }\n\t    return list;\n\t}\n\t\n\tboolean isPrime(int n){\n\t    for(int i=2; i*i<=n; i++){\n\t        if(n%i==0)     return false;\n\t    }\n\t    return true;\n\t}\n\t\n\tint gcd(int x, int y){\n\t\tif(y==0)\treturn x;\n\t\telse\treturn gcd(y, x%y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static int[][] setColor (int[][] board, int c, int d, int x, int y) {\n\t\tint w = d == 0 ? 4 : 2;\n\t\tint h = d == 1 ? 4 : 2;\n\t\tfor (int i = y; i <= y + h - 1; i++) {\n\t\t\tfor (int j = x; j <= x + w - 1; j++)\n\t\t\t\tboard[i][j] = c;\n\t\t}\n\t\treturn board;\n\t}\n\n\tpublic static boolean bfs (int[][] board, int xs, int ys, int xg, int yg, boolean[][] check) {\n\n\t\tint[] dx = {0,0,-1,1}, dy = {-1,1,0,0};\n\t\tint startColor = board[ys][xs];\n\n\t\tQueue<Integer> queueX = new LinkedList<Integer>();\n\t\tQueue<Integer> queueY = new LinkedList<Integer>();\n\n\t\tqueueX.add(xs);\n\t\tqueueY.add(ys);\n\t\tcheck[ys][xs] = true;\n\n\t\twhile (!queueX.isEmpty()) {\n\n\t\t\tint x = queueX.poll();\n\t\t\tint y = queueY.poll();\n\n\t\t\tfor (int i = 0; i < dx.length; i++) {\n\n\t\t\t\tint nextX = x + dx[i];\n\t\t\t\tint nextY = y + dy[i];\n\n\t\t\t\tif (0 <= nextY && nextY < board.length &&\n\t\t\t\t\t0 <= nextX && nextX < board[0].length &&\n\t\t\t\t\tboard[nextY][nextX] == startColor &&\n\t\t\t\t\t!check[nextY][nextX]) {\n\n\t\t\t\t\tcheck[nextY][nextX] = true;\n\t\t\t\t\tqueueX.add(nextX);\n\t\t\t\t\tqueueY.add(nextY);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn check[yg][xg];\n\n\t}\n\n\tpublic static void main (String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif (w == 0 && h == 0) break;\n\n\t\t\tint[][] board = new int[h][w];\n\t\t\tboolean[][] check = new boolean[h][w];\n\n\t\t\tint xs = sc.nextInt() - 1;\n\t\t\tint ys = sc.nextInt() - 1;\n\t\t\tint xg = sc.nextInt() - 1;\n\t\t\tint yg = sc.nextInt() - 1;\n\t\t\tint n = sc.nextInt();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tboard = setColor(board,c,d,x,y);\n\t\t\t}\n\n\t\t\tSystem.out.println(bfs(board,xs,ys,xg,yg,check) ? \"OK\" : \"NG\");\n\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\n/**\n * Block\n */\npublic class Main {\n\n\tstatic int[][] board;\n\tfinal static int BLOCK_WIDTH = 4;\n\tfinal static int BLOCK_HEIGHT = 2;\n\tfinal static int EMPTY = 0;\n\n\tstatic int w, h;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\twhile (!(line = br.readLine()).equals(\"0 0\")) {\n\n\t\t\tw = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\th = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tboard = new int[w + 1][h + 1];\n\n\t\t\tline = br.readLine();\n\t\t\tint xs = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint ys = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tline = br.readLine();\n\t\t\tint xg = Integer.parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tint yg = Integer.parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tputBlock(br.readLine());\n\t\t\t}\n\n\t\t\tif (solve(xs, ys, xg, yg)) {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic void putBlock(String info) {\n\t\tStringTokenizer st = new StringTokenizer(info);\n\n\t\tint c, d, x, y;\n\t\tc = Integer.parseInt(st.nextToken());\n\t\td = Integer.parseInt(st.nextToken());\n\t\tx = Integer.parseInt(st.nextToken());\n\t\ty = Integer.parseInt(st.nextToken());\n\n\t\tputBlock(c, d, x, y);\n\t}\n\n\tstatic void putBlock(int c, int d, int x, int y) {\n\n\t\tif (d == 0) {\n\t\t\tfor (int i = x; i < x + BLOCK_WIDTH; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_HEIGHT; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = x; i < x + BLOCK_HEIGHT; ++i) {\n\t\t\t\tfor (int j = y; j < y + BLOCK_WIDTH; ++j) {\n\t\t\t\t\t// assert board[i][j] == EMPTY;\n\t\t\t\t\tboard[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean solve(int xs, int ys, int xg, int yg) {\n\n\t\tfinal int V[] = { 1, -1, 0, 0 };\n\t\tfinal int H[] = { 0, 0, 1, -1 };\n\n\t\tif (board[xs][ys] != board[xg][yg]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint[] next, prev;\n\t\tnext = new int[] { xs, ys };\n\t\tArrayDeque<int[]> queue = new ArrayDeque<int[]>();\n\t\tqueue.offer(next);\n\n\t\twhile (!queue.isEmpty()) {\n\n\t\t\tprev = queue.poll();\n\n\t\t\tint px, py, nx, ny, c;\n\t\t\tpx = prev[0];\n\t\t\tpy = prev[1];\n\t\t\tc = board[px][py];\n\t\t\tboard[px][py] = EMPTY;\n\n\t\t\tif (px == xg && py == yg) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tnx = px + V[i];\n\t\t\t\tny = py + H[i];\n\t\t\t\tif (nx > 0 && nx < w + 1 && ny > 0 && ny < h + 1) {\n\t\t\t\t\tif (board[nx][ny] == c) {\n\t\t\t\t\t\tqueue.offer(new int[] { nx, ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Point {\n\tfinal int x;\n\tfinal int y;\n\n\tPoint( final int x, final int y ) {\n\t\tthis.y = y;\n\t\tthis.x = x;\n\t}\n\n\tpublic boolean equals( final Point p ) {\n\t\treturn x == p.x && y == p.y;\n\t}\n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\t\tfinal Scanner stdin = new Scanner( System.in );\n\n\t\twhile ( true ) {\n\n\t\t\tfinal int w = stdin.nextInt();\n\t\t\tfinal int h = stdin.nextInt();\n\t\t\tfinal int[][] map = new int[ h + 2 ][ w + 2 ];\n\t\t\t\n\t\t\tif ( w == 0 && h == 0 ) break;\n\n\t\t\tfinal Point start = new Point( stdin.nextInt(), stdin.nextInt() );\n\t\t\tfinal Point end = new Point( stdin.nextInt(), stdin.nextInt() );\n\n\t\t\tfinal int n = stdin.nextInt();\n\t\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\t\tfinal int c = stdin.nextInt();\n\t\t\t\tfinal int d = stdin.nextInt();\n\t\t\t\tfinal int xs = stdin.nextInt();\n\t\t\t\tfinal int ys = stdin.nextInt();\n\n\t\t\t\tfinal int dx = d == 0 ? 4 : 2;\n\t\t\t\tfinal int dy = d == 0 ? 2 : 4;\n\t\t\t\t\n\t\t\t\tfor ( int y = ys; y < ys + dy; y++ ) {\n\t\t\t\t\tfor ( int x = xs; x < xs + dx; x++ ) {\n\t\t\t\t\t\tmap[ y ][ x ] = c;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif ( solve( map, start, end ) ) {\n\t\t\t\tSystem.out.println( \"OK\" );\n\t\t\t} else {\n\t\t\t\tSystem.out.println( \"NG\" );\n\t\t\t}\n\t\t}\n    }\n\n\tstatic final int VISITED = -1;\n\tstatic final int[] dx = {-1, 0, 1, 0};\n\tstatic final int[] dy = {0, 1, 0, -1};\n\t\n\tstatic boolean solve( final int[][] map, final Point start, final Point end ) {\n\t\t\n\t\tfinal int color = map[ start.y ][ start.x ];\n\t\tfinal int w = map[ 0 ].length - 2;\n\t\tfinal int h = map.length - 2;\n\t\t\n\t\tfinal Queue<Point> que = new ArrayDeque<>();\n\n\t\tque.add( start );\n\n\t\twhile ( !que.isEmpty() ){\n\t\t\tfinal Point p = que.poll();\n\t\t\tmap[ p.y ][ p.x ] = VISITED;\n\t\t\tif ( p.x == end.x && p.y == end.y ) return true;\n\n\t\t\tfor ( int i = 0; i < 4; i++ ) {\n\t\t\t\tfinal int nx = p.x + dx[ i ];\n\t\t\t\tfinal int ny = p.y + dy[ i ];\n\n\t\t\t\tif ( 1 <= nx && nx <= w && 1 <= ny && ny <= h &&\n\t\t\t\t\t map[ ny ][ nx ] == color ) {\n\n\t\t\t\t\tque.offer( new Point( nx, ny ) );\n\t\t\t\t}\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int w, h, xs, ys, xg, yg, n;\n    int c, d, x, y;\n\n    int[][] block;\n    boolean[][] route;\n    int[] dirX = {1, 1, 0, -1, -1, -1, 0, 1};\n    int[] dirY = {0, -1, -1, -1, 0, 1, 1, 1};\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt()+1;\n\t    h = sc.nextInt()+1;\n\t    if(w==0 && h==0) break;\n\t    put();\n\n\t    if(block[xs][ys]!=block[xg][yg]){\n\t\tSystem.out.println(\"NG\");\n\t\tbreak;\n\t    }\n\t    \n\t    int rc = block[xs][ys];\n\t    for(int i=1; i<w; i++)\n\t\tfor(int k=1; k<h; k++)\n\t\t    if(block[i][k]==rc) route[i][k] = true;\n\t\n\t    System.out.println(search(xs, ys) ? \"OK\":\"NG\");\n\t}\n    }\n\n    boolean search(int x, int y){\n\tint dx = Math.abs(xg-x);\n\tint dy = Math.abs(yg-y);\n\n\tif(x==xg && y==yg)\n\t    return true;\n\t\n\tfor(int i=0; i<dirX.length; i++){\n\t    int a = x+dirX[i];\n\t    int b = y+dirY[i];\n\t    if(a>0 && a<h && b>0 && b<w){\n\t\tint ndx = Math.abs(xg-a);\n\t\tint ndy = Math.abs(yg-b);\n\t\tif(route[a][b] && (dx>ndx || dy>ndy)){\n\t\t    if(search(a, b))\n\t\t\treturn true;\n\t\t}\n\t    }\n\t}\n\treturn false;\n    }\n\n    void show(){\n\tfor(int i=1; i<w; i++){\n\t    for(int k=1; k<h; k++)\n\t\tSystem.out.print(block[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n\n    void put(){\n\txs = sc.nextInt();\n\tys = sc.nextInt();\n\txg = sc.nextInt();\n\tyg = sc.nextInt();\n\tn = sc.nextInt();\n\n\tblock = new int[w][h];\n\troute = new boolean[w][h];\n\n\tfor(int i=0; i<n; i++){\n\t    c = sc.nextInt();\n\t    d = sc.nextInt();\n\t    x = sc.nextInt();\n\t    y = sc.nextInt();\n\n\t    if(d==0)\n\t\tfor(int a=x; a<x+4; a++)\n\t\t    for(int b=y; b<y+2; b++)\n\t\t\tblock[a][b] = c;\n\t    \n\t    else\n\t\tfor(int a=x; a<x+2; a++)\n\t\t    for(int b=y; b<y+4; b++)\n\t\t\tblock[a][b] = c;\n\t}\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class Program\n    {\n\n        const int BLOCK_W = 2;\n        const int BLOCK_H = 4;\n\n        private int w, h;\n        private int[,] borad;\n        private int start_x;\n        private int start_y;\n        private int goal_x;\n        private int goal_y;\n\n        private bool isToGoal(int c,int x,int y){\n\n            if (x > w || y > h) return false;\n            if (borad[x, y] != c) return false;\n            if (x == goal_x && goal_y == y) return true;\n\n            borad[x, y] += 10; //通過フラグ\n\n            bool r = false;\n            r = isToGoal(c, x + 1, y);\n            if (!r) r = isToGoal(c, x - 1, y);\n            if (!r) r = isToGoal(c, x, y + 1);\n            if (!r) r = isToGoal(c, x, y - 1);\n            return r;\n        }\n\n        private string solve(int p_w,int p_h)\n        {\n            w = p_w;\n            h = p_h;\n            string[] tmp_start = Console.ReadLine().Split(new char[] { ' ' });\n            string[] tmp_goal = Console.ReadLine().Split(new char[] { ' ' });\n            start_x = int.Parse(tmp_start[0]);\n            start_y = int.Parse(tmp_start[1]);\n            goal_x = int.Parse(tmp_goal[0]);\n            goal_y = int.Parse(tmp_goal[1]);\n\n            borad = new int[w+1,h+1];\n            \n            int n = int.Parse(Console.ReadLine());\n\n            //ブロック読み込み\n            for (int i = 0; i < n; i++)\n            {\n                string[] block_i = Console.ReadLine().Split(new char[] { ' ' });\n                int color = int.Parse(block_i[0]);\n                int d = int.Parse(block_i[1]);\n                int x = int.Parse(block_i[2]);\n                int y = int.Parse(block_i[3]);\n\n                int x_e,y_e;\n                if (d == 0)\n                {\n                    x_e = x + BLOCK_H - 1;\n                    y_e = y + BLOCK_W - 1;\n                }\n                else\n                {\n                    x_e = x + BLOCK_W - 1;\n                    y_e = y + BLOCK_H - 1;\n                }\n                for(int x_i = x;x_i<= x_e;x_i++){\n                    for (int y_i = y; y_i <= y_e;y_i++ )\n                    {\n                        borad[x_i, y_i] = color;\n                    }   \n                }\n            }\n\n            //for (int i = 0; i < w; i++)\n            //{\n            //    for (int j = 0; j < h; j++)\n            //    {\n            //        Console.Write(borad[i, j].ToString() + \",\");\n            //    }\n            //    Console.WriteLine();\n            //}\n\n            for (int c = 1; c <= 5; c++)\n            {\n                if (isToGoal(c, start_x, start_y)) return \"OK\";\n            }\n            return \"NG\";\n\n        }\n        \n        static void Main(string[] args)\n        {\n            Program obj = new Program();\n            while (true) {\n                string[] s = Console.ReadLine().Split(new char[] { ' ' });\n                if (s[0] == \"0\" && s[1] == \"0\") break;\n                Console.WriteLine(obj.solve(int.Parse(s[0]), int.Parse(s[1])));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ.Volume2\n{\n    public class Block\n    {\n        private class Point\n        {\n            public int X { get; set; }\n            public int Y { get; set; }\n        }\n\n        public static int Main()\n        {\n            while (true)\n            {\n                var input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n                if (w == 0 && h == 0) { break; }\n\n                // ?????????????????´?????????????????????\n                input = Console.ReadLine().Split(' ');\n                int start_x = int.Parse(input[0]);\n                int start_y = int.Parse(input[1]);\n                input = Console.ReadLine().Split(' ');\n                int goal_x = int.Parse(input[0]);\n                int goal_y = int.Parse(input[1]);\n\n                // ?????????????????±\n                int n = int.Parse(Console.ReadLine());\n                // ????????????????????¨???????????????\n                int[,] map = new int[h + 2, w + 2];\n                for(int i = 1; i <= n; i++)\n                {\n                    input = Console.ReadLine().Split(' ');\n                    int color = int.Parse(input[0]);\n                    bool vertical = input[1] == \"1\" ? true : false;\n                    int x = int.Parse(input[2]);\n                    int y = int.Parse(input[3]);\n                    // ???????????????\n                    int loop_x, loop_y;\n                    if (vertical)\n                    {\n                        loop_x = 2;\n                        loop_y = 4;\n                    }\n                    else\n                    {\n                        loop_x = 4;\n                        loop_y = 2;\n                    }\n\n                    for(int j = 0; j < loop_y; j++)\n                    {\n                        for(int k = 0; k < loop_x; k++) { map[y + j, x + k] = color; }\n                    }\n                }\n\n                // ????????????\n                // ???????????????????????´?????????0(?????????)???NG\n                if (map[start_y, start_x] == 0 || map[goal_y, goal_x] == 0)\n                {\n                    Console.WriteLine(\"NG\");\n                    continue;\n                }\n                // ??????????????¨??´????????????????????????NG\n                if (map[start_y, start_x] != map[goal_y, goal_x])\n                {\n                    Console.WriteLine(\"NG\");\n                    continue;\n                }\n\n                // ??±???????????¢?´¢??§??´???????????¢???\n                int start_color = map[start_y, start_x];\n                var p = new Point() { X = start_x, Y = start_y };\n                var st = new Stack<Point>();\n                st.Push(p);\n                bool success = false;\n                while (st.Count > 0)\n                {\n                    p = st.Pop();\n                    if ((p.X == goal_x) && (p.Y == goal_y))\n                    {\n                        success = true;\n                        break;\n                    }\n                    // ?¨????????????§????????????????????????\n                    map[p.Y, p.X] = 0;\n\n                    // ????????????????????????????????¢???\n                    if (map[p.Y - 1, p.X] == start_color) { st.Push(new Point() { X = p.X, Y = p.Y - 1 }); }\n                    if (map[p.Y + 1, p.X] == start_color) { st.Push(new Point() { X = p.X, Y = p.Y + 1 }); }\n                    if (map[p.Y, p.X - 1] == start_color) { st.Push(new Point() { X = p.X - 1, Y = p.Y }); }\n                    if (map[p.Y, p.X + 1] == start_color) { st.Push(new Point() { X = p.X + 1, Y = p.Y }); }\n                }\n                if (success) { Console.WriteLine(\"OK\"); }\n                else { Console.WriteLine(\"NG\"); }\n            }\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class Program\n    {\n\n        const int BLOCK_W = 2;\n        const int BLOCK_H = 4;\n\n        private int w, h;\n        private int[,] borad;\n        private int start_x;\n        private int start_y;\n        private int goal_x;\n        private int goal_y;\n\n        private bool isToGoal(int c,int x,int y){\n\n            if (borad[x, y] != c) return false;\n\n            if (x == goal_x && goal_y == y) return true;\n\n            if (x > w || y > h) return false;\n\n            borad[x, y] += 10; //通過フラグ\n\n            bool r = false;\n            r = isToGoal(c, x + 1, y);\n            if (!r) r = isToGoal(c, x - 1, y);\n            if (!r) r = isToGoal(c, x, y + 1);\n            if (!r) r = isToGoal(c, x, y - 1);\n            return r;\n        }\n\n        private string solve(int p_w,int p_h)\n        {\n            w = p_w;\n            h = p_h;\n            string[] tmp_start = Console.ReadLine().Split(new char[] { ' ' });\n            string[] tmp_goal = Console.ReadLine().Split(new char[] { ' ' });\n            start_x = int.Parse(tmp_start[0]);\n            start_y = int.Parse(tmp_start[1]);\n            goal_x = int.Parse(tmp_goal[0]);\n            goal_y = int.Parse(tmp_goal[1]);\n\n            borad = new int[w+1,h+1];\n            \n            int n = int.Parse(Console.ReadLine());\n\n            //ブロック読み込み\n            for (int i = 0; i < n; i++)\n            {\n                string[] block_i = Console.ReadLine().Split(new char[] { ' ' });\n                int color = int.Parse(block_i[0]);\n                int d = int.Parse(block_i[1]);\n                int x = int.Parse(block_i[2]);\n                int y = int.Parse(block_i[3]);\n\n                int x_e,y_e;\n                if(d == 0){\n                    x_e = x+BLOCK_H;\n                    y_e = y+BLOCK_W;\n                }else{\n                    x_e = x+BLOCK_W;\n                    y_e = y+BLOCK_H;\n                }\n                for(int x_i = x;x_i<= x_e;x_i++){\n                    for (int y_i = y; y_i <= y_e;y_i++ )\n                    {\n                        borad[x_i, y_i] = color;\n                    }   \n                }\n            }\n\n            //for (int i = 0; i < w; i++)\n            //{\n            //    for (int j = 0; j < h; j++)\n            //    {\n            //        Console.Write(borad[i, j].ToString() + \",\");\n            //    }\n            //    Console.WriteLine();\n            //}\n\n            for (int c = 1; c <= 5; c++)\n            {\n                if (isToGoal(c, start_x, start_y)) return \"OK\";\n            }\n            return \"NG\";\n\n        }\n        \n        static void Main(string[] args)\n        {\n            Program obj = new Program();\n            while (true) {\n                string[] s = Console.ReadLine().Split(new char[] { ' ' });\n                if (s[0] == \"0\" && s[1] == \"0\") break;\n                Console.WriteLine(obj.solve(int.Parse(s[0]), int.Parse(s[1])));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0207\n{\n    public class Program\n    {\n\n        class Point\n        {\n            public int X { get; private set; }\n            public int Y { get; private set; }\n            public Point(int x, int y) { X = x; Y = y; }\n            public Point(int[] v) { X = v[0] - 1; Y = v[1] - 1; }\n            public static bool operator ==(Point point1, Point point2) { return point1.X == point2.X && point1.Y == point2.Y; }\n            public static bool operator !=(Point point1, Point point2) { return !(point1 == point2); }\n            public static bool Equals(Point point1, Point point2) { return point1.X.Equals(point2.X) && point1.Y.Equals(point2.Y); }\n            public override bool Equals(object o)\n            {\n                if ((null == o) || !(o is Point)) return false;\n                return Equals(this, (Point)o);\n            }\n            public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n        }\n\n        private static int[,] d = new int[,] { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } };\n        private static int[,] map;\n        private static bool[,] visited;\n        private static Point start, goal;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] wh = RIntAr(); if (wh.Sum() == 0) break;\n                Init(wh);\n                Console.WriteLine(SearchRoute() ? \"OK\" : \"NG\");\n            }\n        }\n\n        private static void Init(int[] wh)\n        {\n            const int BLOCK_W = 4;\n            const int BLOCK_H = 2;\n\n            map = new int[wh[1], wh[0]];\n            visited = new bool[wh[1], wh[0]];\n            start = new Point(RIntAr());\n            goal = new Point(RIntAr());\n\n            int n = RInt();\n            for (int k = 0 ; k < n ; k++)\n            {\n                int[] items = RIntAr();\n                int w, h;\n                if (items[1] == 0) { w = BLOCK_W; h = BLOCK_H; }\n                else { w = BLOCK_H; h = BLOCK_W; }\n\n                for (int i = 0 ; i < h ; i++)\n                {\n                    for (int j = 0 ; j < w ; j++)\n                    {\n                        map[i + items[3] - 1, j + items[2] - 1] = items[0];\n                    }\n                }\n            }\n        }\n\n        private static bool SearchRoute()\n        {\n            int color = map[start.Y, start.X];\n            Queue<Point> q = new Queue<Point>();\n            q.Enqueue(start);\n            visited[start.Y, start.X] = true;\n\n            while (q.Count > 0)\n            {\n                Point p = q.Dequeue();\n                visited[p.Y, p.X] = true;\n\n                if (p == goal) return true;\n\n                for (int i = 0 ; i < d.GetLength(0) ; i++)\n                {\n                    int nextX = p.X + d[i, 0];\n                    int nextY = p.Y + d[i, 1];\n                    if (IsInArea(nextX, nextY))\n                    {\n                        if (map[nextY, nextX] == color && !visited[nextY, nextX])\n                        {\n                            q.Enqueue(new Point(nextX, nextY));\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        private static bool IsInArea(int x, int y)\n        {\n            return (0 <= x && x < map.GetLength(1) && 0 <= y && y < map.GetLength(0));\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1 {\n    class Program {\n        static void Main(string[] args) {\n            String line;\n            while ((line = Console.ReadLine()) != null) {\n                string[] strs = line.Split(' ');\n                int w = int.Parse(strs[0]);\n                int h = int.Parse(strs[1]);\n                if (w == 0 ) { break; }\n                int[,] maze = new int[w+1, h+1];\n                strs = Console.ReadLine().Split(' ');\n                int xs = int.Parse(strs[0]), ys = int.Parse(strs[1]);\n                strs = Console.ReadLine().Split(' ');\n                int xg = int.Parse(strs[0]), yg = int.Parse(strs[1]);\n                int n = int.Parse(Console.ReadLine());\n                for (int i = 0; i < n; i++) {\n                    strs = Console.ReadLine().Split(' ');\n                    int n0 = int.Parse(strs[0]);\n                    int n1 = int.Parse(strs[1]);\n                    int n2 = int.Parse(strs[2]);\n                    int n3 = int.Parse(strs[3]);\n                    if (n1 == 0) {//Yoko ni Nagai\n                        maze[n2, n3] = n0; maze[n2 + 1, n3] = n0;\n                        maze[n2 + 2, n3] = n0; maze[n2 + 3, n3] = n0;\n                        maze[n2, n3 + 1] = n0; maze[n2 + 1, n3 + 1] = n0;\n                        maze[n2 + 2, n3 + 1] = n0; maze[n2 + 3, n3 + 1] = n0;\n                    }\n                    else {\n                        maze[n2, n3] = n0; maze[n2 + 1, n3] = n0;\n                        maze[n2, n3+1] = n0; maze[n2 + 1, n3+1] = n0;\n                        maze[n2, n3 + 2] = n0; maze[n2 + 1, n3 + 2] = n0;\n                        maze[n2 , n3 + 3] = n0; maze[n2 + 1, n3 + 3] = n0;                    \n                    }                \n                }\n                if (solvable(maze, xs, ys, xg, yg, maze[xs, ys])) {\n                    Console.WriteLine(\"OK\");\n                }\n                else {\n                    Console.WriteLine(\"NG\");\n                }\n\n            }\n\n        }\n\n        static bool solvable(int[,] maze, int x, int y, int xg, int yg, int color) {\n            if(x==0||x==maze.GetLength(0)||y==0||y==maze.GetLength(1)){return false;}\n            if (maze[x, y] != color) { return false; }\n            if (x == xg && y == yg) { return true; }\n            maze[x, y] = -1;\n            if (solvable(maze, x + 1, y,xg, yg, color)) { return true; }\n            if (solvable(maze, x , y+1, xg, yg, color)) { return true; }\n            if (solvable(maze, x - 1, y, xg, yg, color)) { return true; }\n            if (solvable(maze, x , y-1, xg, yg, color)) { return true; }\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static void Main()\n    {\n        var sc = new Scanner();\n        while (true)\n        {\n            w = sc.Integer();\n            h = sc.Integer();\n            if (w == 0 && h == 0)\n                break;\n            var xs = sc.Integer();\n            var ys = sc.Integer();\n\n            xg = sc.Integer();\n            yg = sc.Integer();\n\n            var n = sc.Integer();\n            board = new int[102, 102];\n            for (int i = 0; i < n; i++)\n            {\n                var c = sc.Integer();\n                var d = sc.Integer();\n                var x = sc.Integer();\n                var y = sc.Integer();\n                for (int j = 0; j < 4; j++)\n                {\n                    for (int k = 0; k < 2; k++)\n                    {\n                        if (d == 0)\n                            board[x + j, y + k] = c;\n                        else board[x + k, y + j] = c;\n                        \n                    }\n                    \n                }\n            }\n            Program.c = board[xs, ys];\n            var b = Solve(xs, ys);\n            if(b)  \n                Console.WriteLine(\"OK\");\n            else\n                Console.WriteLine(\"NG\");\n        }\n    }\n    static int[,] board;\n    static int w, h, xg, yg, c;\n    static int[] dx = { 1, 0, -1, 0 };\n    static int[] dy = { 0, 1, 0, -1 };\n\n\n    static bool Solve(int posx, int posy)\n    {\n        \n        if (board[posx, posy] != c || board[posx,posy]==0)\n        {\n            return false;\n        }\n        if (posx == xg && posy == yg)\n        {\n            return true;\n        }\n        \n        board[posx, posy] = 0;\n        \n        for (int r = 0; r < 4; r++)\n        {\n            if (Solve(posx + dx[r], posy + dy[r]))\n                return true;\n        }\n            \n        return false;\n            \n    }\n     \n}\n\n\npublic class Scanner\n{\n    readonly TextReader reader;\n    string[] buffer = new string[0];\n    int position;\n\n    public char[] Separator { get; set; }\n    public Scanner(TextReader reader = null, string separator = null)\n    {\n        if (reader == null)\n            reader = Console.In;\n        if (string.IsNullOrEmpty(separator))\n            separator = \" \";\n        this.Separator = separator.ToCharArray();\n        this.reader = reader;\n\n    }\n    public string Scan()\n    {\n        if (this.position < this.buffer.Length)\n            return this.buffer[this.position++];\n        this.buffer = this.reader.ReadLine().Split(this.Separator, StringSplitOptions.RemoveEmptyEntries);\n        this.position = 0;\n        return this.buffer[this.position++];\n    }\n\n    public string[] ScanToLineEnd()\n    {\n        if (this.position >= this.buffer.Length)\n            return this.reader.ReadLine().Split(this.Separator, StringSplitOptions.RemoveEmptyEntries);\n        var size = this.buffer.Length - this.position;\n        var ar = new string[size];\n        Array.Copy(this.buffer, position, ar, 0, size);\n        return ar;\n\n    }\n\n    public string ScanLine()\n    {\n        if (this.position >= this.buffer.Length)\n            return this.reader.ReadLine();\n        else\n        {\n            var sb = new StringBuilder();\n            for (; this.position < buffer.Length; this.position++)\n            {\n                sb.Append(this.buffer[this.position]);\n                sb.Append(' ');\n            }\n            return sb.ToString();\n        }\n    }\n\n    public int Integer()\n    {\n        return int.Parse(this.Scan());\n    }\n    public long Long()\n    {\n        return int.Parse(this.Scan());\n    }\n    public double Double()\n    {\n        return int.Parse(this.Scan());\n    }\n\n    public int[] IntArray(int length)\n    {\n        var a = new int[length];\n        for (int i = 0; i < length; i++)\n            a[i] = this.Integer();\n        return a.ToArray();\n    }\n    public long[] LongArray(int length)\n    {\n        var a = new long[length];\n        for (int i = 0; i < length; i++)\n            a[i] = this.Long();\n        return a.ToArray();\n    }\n    public double[] DoubleArray(int length)\n    {\n        var a = new double[length];\n        for (int i = 0; i < length; i++)\n            a[i] = this.Double();\n        return a.ToArray();\n    }\n\n}\n\n\nstatic public class Repeat\n{\n    static public void For(this int range, Action<int> action, int start = 0)\n    {\n        for (int i = start; i < range + start; i++)\n            action(i);\n    }\n\n    static public IEnumerable<T> Enumerate<T>(this int range, Func<int, T> func, int start = 0)\n    {\n        for (int i = start; i < range + start; i++)\n        {\n            yield return func(i);\n        }\n    }\n\n    static public void ForEach<T>(this IEnumerable<T> source, Action<T> action)\n    {\n        foreach (var x in source)\n            action(x);\n    }\n\n}\n\n\n\n//*/\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ.Volume2\n{\n    public class Block\n    {\n        private struct Coordinate\n        {\n            public int X;\n            public int Y;\n        }\n\n        private static bool Check(int[,] map, Coordinate start, Coordinate goal)\n        {\n            int col = map[start.Y, start.X];\n            // スタートとゴールの色が違う場合は失敗\n            if (map[goal.Y, goal.X] != col) { return false; }\n\n            // 幅優先探索\n            var que = new Queue<Coordinate>();\n            que.Enqueue(start);\n            while (que.Count > 0)\n            {\n                var q = que.Dequeue();\n                Coordinate move;\n                // 上に移動\n                move.X = q.X;\n                move.Y = q.Y - 1;\n                if (move.X == goal.X && move.Y == goal.Y) { return true; }\n                else if (map[move.Y, move.X] == col) { que.Enqueue(move); }\n                // 右に移動\n                move.X = q.X + 1;\n                move.Y = q.Y;\n                if (move.X == goal.X && move.Y == goal.Y) { return true; }\n                else if (map[move.Y, move.X] == col) { que.Enqueue(move); }\n                // 下に移動\n                move.X = q.X;\n                move.Y = q.Y + 1;\n                if (move.X == goal.X && move.Y == goal.Y) { return true; }\n                else if (map[move.Y, move.X] == col) { que.Enqueue(move); }\n                // 左に移動\n                move.X = q.X - 1;\n                move.Y = q.Y;\n                if (move.X == goal.X && move.Y == goal.Y) { return true; }\n                else if (map[move.Y, move.X] == col) { que.Enqueue(move); }\n\n            }\n            return false;\n        }\n\n        public static int Main()\n        {\n            while (true)\n            {\n                var w_h = Console.ReadLine().Split(' ');\n                if (w_h[0] == \"0\") { break; }\n                int w = int.Parse(w_h[0]);\n                int h = int.Parse(w_h[1]);\n\n                var coor = Console.ReadLine().Split(' ');\n                Coordinate start, goal;\n                start.X = int.Parse(coor[0]);\n                start.Y = int.Parse(coor[1]);\n                coor = Console.ReadLine().Split(' ');\n                goal.X = int.Parse(coor[0]);\n                goal.Y = int.Parse(coor[1]);\n\n                int n = int.Parse(Console.ReadLine());\n                // 迷路を読み込む\n                var map = new int[h + 2, w + 2];\n                for (int i = 0; i < n; i++)\n                {\n                    var input = Console.ReadLine().Split(' ');\n                    int color = int.Parse(input[0]);\n                    int pos_x = int.Parse(input[2]);\n                    int pos_y = int.Parse(input[3]);\n                    if (input[1] == \"0\")\n                    {\n                        // 横に長い\n                        for (int i_h = pos_y; i_h <= pos_y + 1; i_h++)\n                        {\n                            for (int i_w = pos_x; i_w <= pos_x + 3; i_w++)\n                            {\n                                map[i_h, i_w] = color;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // 縦に長い\n                        for (int i_h = pos_y; i_h <= pos_y + 3; i_h++)\n                        {\n                            for (int i_w = pos_x; i_w <= pos_x + 1; i_w++)\n                            {\n                                map[i_h, i_w] = color;\n                            }\n                        }\n                    }\n                }\n                // 迷路になっているか確認\n                if (Check(map, start, goal)) { Console.WriteLine(\"OK\"); }\n                else { Console.WriteLine(\"NG\"); }\n            }\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace AOJ\n{\n    class Program\n    {\n\n        const int BLOCK_W = 2;\n        const int BLOCK_H = 4;\n\n        private int w, h;\n        private int[,] borad;\n        private int start_x;\n        private int start_y;\n        private int goal_x;\n        private int goal_y;\n\n        private bool isToGoal(int c,int x,int y){\n\n            if (x > w || y > h) return false;\n            if (borad[x, y] != c) return false;\n            if (x == goal_x && goal_y == y) return true;\n\n            borad[x, y] += 10; //通過フラグ\n\n            bool r = false;\n            r = isToGoal(c, x + 1, y);\n            if (!r) r = isToGoal(c, x - 1, y);\n            if (!r) r = isToGoal(c, x, y + 1);\n            if (!r) r = isToGoal(c, x, y - 1);\n            return r;\n        }\n\n        private string solve(int p_w,int p_h)\n        {\n            w = p_w;\n            h = p_h;\n            string[] tmp_start = Console.ReadLine().Split(new char[] { ' ' });\n            string[] tmp_goal = Console.ReadLine().Split(new char[] { ' ' });\n            start_x = int.Parse(tmp_start[0]);\n            start_y = int.Parse(tmp_start[1]);\n            goal_x = int.Parse(tmp_goal[0]);\n            goal_y = int.Parse(tmp_goal[1]);\n\n            borad = new int[w+1,h+1];\n            \n            int n = int.Parse(Console.ReadLine());\n\n            //ブロック読み込み\n            for (int i = 0; i < n; i++)\n            {\n                string[] block_i = Console.ReadLine().Split(new char[] { ' ' });\n                int color = int.Parse(block_i[0]);\n                int d = int.Parse(block_i[1]);\n                int x = int.Parse(block_i[2]);\n                int y = int.Parse(block_i[3]);\n\n                int x_e,y_e;\n                if (d == 0)\n                {\n                    x_e = x + BLOCK_H - 1;\n                    y_e = y + BLOCK_W - 1;\n                }\n                else\n                {\n                    x_e = x + BLOCK_W - 1;\n                    y_e = y + BLOCK_H - 1;\n                }\n                for(int x_i = x;x_i<= x_e;x_i++){\n                    for (int y_i = y; y_i <= y_e;y_i++ )\n                    {\n                        borad[x_i, y_i] = color;\n                    }   \n                }\n            }\n\n            //for (int i = 0; i < w; i++)\n            //{\n            //    for (int j = 0; j < h; j++)\n            //    {\n            //        Console.Write(borad[i, j].ToString() + \",\");\n            //    }\n            //    Console.WriteLine();\n            //}\n\n            for (int c = 1; c <= 5; c++)\n            {\n                if (isToGoal(c, start_x, start_y)) return \"OK\";\n            }\n            return \"NG\";\n\n        }\n        \n        static void Main(string[] args)\n        {\n            Program obj = new Program();\n            while (true) {\n                string[] s = Console.ReadLine().Split(new char[] { ' ' });\n                if (s[0] == \"0\" && s[1] == \"0\") break;\n                Console.WriteLine(obj.solve(int.Parse(s[0]), int.Parse(s[1])));\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "function block(c,d,x,y){\n   var dx,dy;\n   if(d==0){dy=[0,0,0,0,1,1,1,1];dx=[0,1,2,3,0,1,2,3];}\n   if(d==1){dy=[0,1,2,3,0,1,2,3];dx=[0,0,0,0,1,1,1,1];}\n   for(var i=0;i<8;i++){\n      yx[(y-1)+dy[i]][(x-1)+dx[i]]=c;\n   }\n}\n\nfunction bomb(y,x){\n   var dy=[-1,0,0,1];\n   var dx=[0,-1,1,0];\n   for(var i=0;i<4;i++){\n      var yy=y+dy[i];\n      var xx=x+dx[i];\n      if(yy<0 || yy>=H || xx<0 || xx>=W)continue;\n      if(yx[yy][xx]==color){yx[yy][xx]=\"a\";bomb(yy,xx);}\n   }\n}\n\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\n   var WH=(Arr.shift()).split(\" \").map(Number);\n   var W=WH[0];\n   var H=WH[1];\n   if(W==0 && H==0)break;\n   var xyS=(Arr.shift()).split(\" \").map(Number);\n   var xS=xyS[0]-1;\n   var yS=xyS[1]-1;\n   var xyE=(Arr.shift()).split(\" \").map(Number);\n   var xE=xyE[0]-1;\n   var yE=xyE[1]-1;\n   var n=(Arr.shift())-0;\n   var yx=[];\n   for(var i=0;i<H;i++){\n      yx[i]=[];\n      for(var j=0;j<W;j++){\n          yx[i][j]=0;\n      }\n   }\n   for(var i=0;i<n;i++){\n      var cdxy=(Arr.shift()).split(\" \").map(Number);\n      block.apply(null,cdxy);\n   }\n   var color=yx[yS][xS];\n   if(color==0){console.log(\"NG\");continue;}\n   if(yx[yS][xS]==color){yx[yS][xS]=\"a\";bomb(yS,xS);}\n   var result=(yx[yE][xE]==\"a\")?\"OK\":\"NG\";\n   console.log(result);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j,\n  wh, startXY, goalXY, n,\n  board;\n  for (;;) {\n    wh = input[i++].split(' ').map(Number);\n    if (!wh[0] && !wh[1]) break;\n    \n    board = initBoard(wh[0], wh[1]);\n    \n    startXY = input[i++].split(' ').map(Number);\n    goalXY  = input[i++].split(' ').map(Number);\n    n = Number(input[i++]);\n    for (j = 0; j < n; j++) {\n      putBlock.bind(null, board).apply(null, input[i++].split(' ').map(Number));\n    }\n    \n    console.log(canGoToGoal(board, startXY, goalXY) ? 'OK' : 'NG');\n  }\n}\n\nfunction initBoard(w, h) {\n  var\n  i, j,\n  board = [];\n  for (i = 0; i < w; i++) {\n    board.push([]);\n    for (j = 0; j < h; j++) {\n      board[i][j] = 0;\n    }\n  }\n  return board;\n}\n\nfunction putBlock(board, c, d, x, y) {\n  var\n  i, j,\n  b = [[4,2], [2,4]][d];\n  for (i = 0; i < b[0]; i++) {\n    for (j = 0; j < b[1]; j++) {\n      board[x - 1 + i][y - 1 + j] = c;\n    }\n  }\n}\n\nfunction canGoToGoal(board, startXY, goalXY) {\n  var\n  queue = [],\n  to = [[-1,-1], [ 0,-1], [ 1, -1],\n        [-1, 0],          [ 1,  0],\n        [-1, 1], [ 0, 1], [ 1,  1]],\n  sx = startXY[0] - 1, sy = startXY[1] - 1,\n  gx = goalXY[0] - 1, gy = goalXY[1] - 1,\n  xym, x, y,\n  m = {},\n  c = board[sx][sy];\n  \n  if (c === 0) return false;\n  \n  queue.push([sx, sy, {}]);\n  \n  for (;queue.length >= 1;) {\n    xy = queue.shift();\n    x = xy[0]; y = xy[1];\n    m[[x, y]] = true;\n    \n    if (x < 0 || board.length <= x || c !== board[x][y]) continue;\n    if (x === gx && y === gy) return true;\n    \n    for (i = 0; i < 8; i++) {\n      if (!m[[x + to[i][0], y + to[i][1]]]) {\n        queue.push([x + to[i][0], y + to[i][1]]);\n      }\n    }\n  }\n  \n  return false;\n}\n\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    main(input)\n});\n\nfunction main(input){\n    var args = input.trim().split('\\n');\n\n    var i = 0;\n    while(true) {\n        var map = [];\n        var wh = splitNum(args[i++]);\n        if(isEnd(wh)) break;\n        initMap(wh, map);\n\n        var startXY = splitNum(args[i++]);\n        var goalXY = splitNum(args[i++]);\n\n        var blockCount = parseInt(args[i++]);\n        for(var j = 0; j < blockCount; j+=1){\n            var block = splitNum(args[i++]);\n            putBlock(map, block);\n        }\n\n        var res = isReachable(map, startXY[0]-1, startXY[1]-1, goalXY[0]-1, goalXY[1]-1);\n        console.log(res ? \"OK\" : \"NO\");\n    }\n}\n\nfunction initMap(wh, map){\n    for(var x = 0; x < wh[0]; x+=1){\n        var buff = [];\n        for(var y = 0; y < wh[1]; y += 1){\n            buff.push(0);\n        }\n        map.push(buff);\n    }\n}\n\nfunction putBlock(map, block){\n    var isHorizontal = !block[1];\n    var bw = isHorizontal ? 4 : 2;\n    var bh = isHorizontal ? 2 : 4;\n    var x = block[2]-1;\n    var y = block[3]-1;\n\n    for(var mx = x; mx < x + bw; mx += 1){\n        for(var my = y; my < y + bh; my += 1){\n            map[mx][my] = block[0];\n        }\n    }\n}\n\nfunction isReachable(map, nowX, nowY, goalX, goalY){\n    if(nowX === goalX && nowY === goalY){\n        return true;\n    }\n    var color = map[nowX][nowY];\n    map[nowX][nowY] = -2;\n\n    var flag = false;\n    [-1, 1].forEach(function(dx){\n        [-1, 1].forEach(function(dy){\n            var cx = nowX + dx, cy = nowY + dy;\n            if(map[cx] && map[cx][cy] === color){\n                flag = flag || isReachable(map, cx, cy, goalX, goalY);\n            }\n        })\n    });\n    return flag;\n}\n\nfunction splitNum(str){\n    return str.split(' ').map(Number);\n}\n\nfunction isEnd(arr){\n    return arr[0] === 0 && arr[1] === 0;\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j,\n  wh, startXY, goalXY, n,\n  board;\n  for (;;) {\n    wh = input[i++].split(' ').map(Number);\n    if (!wh[0] && !wh[1]) break;\n    \n    board = initBoard(wh[0], wh[1]);\n    \n    startXY = input[i++].split(' ').map(Number);\n    goalXY  = input[i++].split(' ').map(Number);\n    n = Number(input[i++]);\n    for (j = 0; j < n; j++) {\n      putBlock.bind(null, board).apply(null, input[i++].split(' ').map(Number));\n    }\n    \n    console.log(canGoToGoal(board, startXY, goalXY) ? 'OK' : 'NG');\n  }\n}\n\nfunction initBoard(w, h) {\n  var\n  i, j,\n  board = [];\n  for (i = 0; i < w; i++) {\n    board.push([]);\n    for (j = 0; j < h; j++) {\n      board[i][j] = 0;\n    }\n  }\n  return board;\n}\n\nfunction putBlock(board, c, d, x, y) {\n  var\n  i, j,\n  b = [[4,2], [2,4]][d];\n  for (i = 0; i < b[0]; i++) {\n    for (j = 0; j < b[1]; j++) {\n      board[x - 1 + i][y - 1 + j] = c;\n    }\n  }\n}\n\nfunction canGoToGoal(board, startXY, goalXY) {\n  var\n  queue = [],\n  to = [[-1,-1], [ 0,-1], [ 1, -1],\n        [-1, 0],          [ 1,  0],\n        [-1, 1], [ 0, 1], [ 1,  1]],\n  sx = startXY[0] - 1, sy = startXY[1] - 1,\n  gx = goalXY[0] - 1, gy = goalXY[1] - 1,\n  xym, x, y,\n  m = {},\n  c = board[sx][sy];\n  \n  if (c === 0) return false;\n  \n  queue.push([sx, sy, {}]);\n  \n  for (;queue.length >= 1;) {\n    xy = queue.shift();\n    x = xy[0]; y = xy[1];\n    if (x < 0 || board.length <= x || c !== board[x][y]) continue;\n    if (x === gx && y === gy) return true;\n    m[[x, y]] = true;\n    \n    for (i = 0; i < 8; i++) {\n      if (!m[[x + to[i][0], y + to[i][1]]]) {\n        queue.push([x + to[i][0], y + to[i][1]]);\n      }\n    }\n  }\n  \n  return false;\n}\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j,\n  wh, startXY, goalXY, n,\n  board;\n  for (;;) {\n    wh = input[i++].split(' ').map(Number);\n    if (!wh[0] && !wh[1]) break;\n    \n    board = initBoard(wh[0], wh[1]);\n    \n    startXY = input[i++].split(' ').map(Number);\n    goalXY  = input[i++].split(' ').map(Number);\n    n = Number(input[i++]);\n    for (j = 0; j < n; j++) {\n      putBlock.bind(null, board).apply(null, input[i++].split(' ').map(Number));\n    }\n    \n    console.log(canGoToGoal(board, startXY, goalXY) ? 'OK' : 'NG');\n  }\n}\n\nfunction initBoard(w, h) {\n  var\n  i, j,\n  board = [];\n  for (i = 0; i < w; i++) {\n    board.push([]);\n    for (j = 0; j < h; j++) {\n      board[i][j] = 0;\n    }\n  }\n  return board;\n}\n\nfunction putBlock(board, c, d, x, y) {\n  var\n  i, j,\n  b = [[4,2], [2,4]][d];\n  for (i = 0; i < b[0]; i++) {\n    for (j = 0; j < b[1]; j++) {\n      board[x - 1 + i][y - 1 + j] = c;\n    }\n  }\n}\n\nfunction canGoToGoal(board, startXY, goalXY) {\n  var\n  to = [[-1,-1], [ 0,-1], [ 1, -1],\n        [-1, 0],          [ 1,  0],\n        [-1, 1], [ 0, 1], [ 1,  1]],\n  sx = startXY[0] - 1, sy = startXY[1] - 1,\n  gx = goalXY[0] - 1, gy = goalXY[1] - 1,\n  m = {}, c = board[sx][sy];\n  \n  if (c === 0) return false;\n  \n  return (function search(x, y) {\n    var\n    i;\n    if ([x, y] in m) return m[[x, y]];\n    if (x < 0 || board.length <= x || board[x][y] !== c) return m[[x, y]] = false;\n    if (x === gx && y === gy) return m[[x, y]] = true;\n    \n    m[[x, y]] = false;\n    \n    for (i = 0; i < 8; i++) {\n      if (!([x + to[i][0], y + to[i][1]] in m)) {\n        if (search(x + to[i][0], y + to[i][1])) return m[[x, y]] = true;\n      }\n    }\n    \n    return m[[x, y]] = false;\n  })(sx, sy);\n}\n\n/*\nfunction canGoToGoal(board, startXY, goalXY) {\n  var\n  queue = [],\n  to = [[-1,-1], [ 0,-1], [ 1, -1],\n        [-1, 0],          [ 1,  0],\n        [-1, 1], [ 0, 1], [ 1,  1]],\n  sx = startXY[0] - 1, sy = startXY[1] - 1,\n  gx = goalXY[0] - 1, gy = goalXY[1] - 1,\n  xym, x, y,\n  m = {},\n  c = board[sx][sy];\n  \n  if (c === 0) return false;\n  \n  queue.push([sx, sy, {}]);\n  \n  for (;queue.length >= 1;) {\n    xy = queue.shift();\n    x = xy[0]; y = xy[1];\n    m[[x, y]] = true;\n    \n    if (x < 0 || board.length <= x || c !== board[x][y]) continue;\n    if (x === gx && y === gy) return true;\n    \n    for (i = 0; i < 8; i++) {\n      if (!m[[x + to[i][0], y + to[i][1]]]) {\n        queue.push([x + to[i][0], y + to[i][1]]);\n      }\n    }\n  }\n  \n  return false;\n}\n*/\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    main(input)\n});\n\nfunction main(input){\n    var args = input.trim().split('\\n');\n\n    var i = 0;\n    while(true) {\n        var map = [];\n        var wh = splitNum(args[i++]);\n        if(isEnd(wh)) break;\n        initMap(wh, map);\n\n        var startXY = splitNum(args[i++]);\n        var goalXY = splitNum(args[i++]);\n\n        var blockCount = parseInt(args[i++]);\n        for(var j = 0; j < blockCount; j+=1){\n            var block = splitNum(args[i++]);\n            putBlock(map, block);\n        }\n\n        var res = isReachable(map, startXY[0]-1, startXY[1]-1, goalXY[0]-1, goalXY[1]-1);\n        console.log(res ? \"OK\" : \"NG\");\n    }\n}\n\nfunction initMap(wh, map){\n    for(var x = 0; x < wh[0]; x+=1){\n        var buff = [];\n        for(var y = 0; y < wh[1]; y += 1){\n            buff.push(0);\n        }\n        map.push(buff);\n    }\n}\n\nfunction putBlock(map, block){\n    var isHorizontal = !block[1];\n    var bw = isHorizontal ? 4 : 2;\n    var bh = isHorizontal ? 2 : 4;\n    var x = block[2]-1;\n    var y = block[3]-1;\n\n    for(var mx = x; mx < x + bw; mx += 1){\n        for(var my = y; my < y + bh; my += 1){\n            map[mx][my] = block[0];\n        }\n    }\n}\n\nfunction isReachable(map, nowX, nowY, goalX, goalY){\n    if(nowX === goalX && nowY === goalY){\n        return true;\n    }\n    var color = map[nowX][nowY];\n    map[nowX][nowY] = -2;\n\n    var flag = false;\n    [-1, 0, 1].forEach(function(dx){\n        [-1, 0, 1].forEach(function(dy){\n            if(!dx && !dy){ return; }\n            var cx = nowX + dx, cy = nowY + dy;\n            if(map[cx] && map[cx][cy] === color){\n                flag = flag || isReachable(map, cx, cy, goalX, goalY);\n            }\n        })\n    });\n    return flag;\n}\n\nfunction splitNum(str){\n    return str.split(' ').map(Number);\n}\n\nfunction isEnd(arr){\n    return arr[0] === 0 && arr[1] === 0;\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    main(input)\n});\n\nfunction main(input){\n    var args = input.trim().split('\\n');\n\n    var i = 0;\n    while(true) {\n        var map = [];\n        var wh = splitNum(args[i++]);\n        if(isEnd(wh)) break;\n        initMap(wh, map);\n\n        var startXY = splitNum(args[i++]);\n        var goalXY = splitNum(args[i++]);\n\n        var blockCount = parseInt(args[i++]);\n        for(var j = 0; j < blockCount; j+=1){\n            var block = splitNum(args[i++]);\n            putBlock(map, block);\n        }\n\n        var res = isReachable(map, startXY[0]-1, startXY[1]-1, goalXY[0]-1, goalXY[1]-1);\n        console.log(res ? \"OK\" : \"NO\");\n    }\n}\n\nfunction initMap(wh, map){\n    for(var x = 0; x < wh[0]; x+=1){\n        var buff = [];\n        for(var y = 0; y < wh[1]; y += 1){\n            buff.push(0);\n        }\n        map.push(buff);\n    }\n}\n\nfunction putBlock(map, block){\n    var isHorizontal = !block[1];\n    var bw = isHorizontal ? 4 : 2;\n    var bh = isHorizontal ? 2 : 4;\n    var x = block[2]-1;\n    var y = block[3]-1;\n\n    for(var mx = x; mx < x + bw; mx += 1){\n        for(var my = y; my < y + bh; my += 1){\n            map[mx][my] = block[0];\n        }\n    }\n}\n\nfunction isReachable(map, nowX, nowY, goalX, goalY){\n    if(nowX === goalX && nowY === goalY){\n        return true;\n    }\n    var color = map[nowX][nowY];\n    map[nowX][nowY] = -2;\n\n    var flag = false;\n    [-1, 0, 1].forEach(function(dx){\n        [-1, 0, 1].forEach(function(dy){\n            if(!dx && !dy){ return; }\n            var cx = nowX + dx, cy = nowY + dy;\n            if(map[cx] && map[cx][cy] === color){\n                flag = flag || isReachable(map, cx, cy, goalX, goalY);\n            }\n        })\n    });\n    return flag;\n}\n\nfunction splitNum(str){\n    return str.split(' ').map(Number);\n}\n\nfunction isEnd(arr){\n    return arr[0] === 0 && arr[1] === 0;\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    main(input)\n});\n\nfunction main(input){\n    var args = input.trim().split('\\n');\n\n    var i = 0;\n    while(true) {\n        var map = [];\n        var wh = splitNum(args[i++]);\n        if(isEnd(wh)) break;\n        initMap(wh, map);\n\n        var startXY = splitNum(args[i++]);\n        var goalXY = splitNum(args[i++]);\n\n        var blockCount = parseInt(args[i++]);\n        for(var j = 0; j < blockCount; j+=1){\n            var block = splitNum(args[i++]);\n            putBlock(map, block);\n        }\n\n        var res = isReachable(map, startXY[0]-1, startXY[1]-1, goalXY[0]-1, goalXY[1]-1);\n        console.log(res ? \"OK\" : \"NG\");\n    }\n}\n\nfunction initMap(wh, map){\n    for(var x = 0; x < wh[0]; x+=1){\n        var buff = [];\n        for(var y = 0; y < wh[1]; y += 1){\n            buff.push(0);\n        }\n        map.push(buff);\n    }\n}\n\nfunction putBlock(map, block){\n    var isHorizontal = !block[1];\n    var bw = isHorizontal ? 4 : 2;\n    var bh = isHorizontal ? 2 : 4;\n    var x = block[2]-1;\n    var y = block[3]-1;\n\n    for(var mx = x; mx < x + bw; mx += 1){\n        for(var my = y; my < y + bh; my += 1){\n            map[mx][my] = block[0];\n        }\n    }\n}\n\nfunction isReachable(map, nowX, nowY, goalX, goalY){\n    if(nowX === goalX && nowY === goalY){\n        return true;\n    }\n    var color = map[nowX][nowY];\n    map[nowX][nowY] = -2;\n\n    var flag = false;\n    [-1, 1].forEach(function(dx){\n        [-1, 1].forEach(function(dy){\n            var cx = nowX + dx, cy = nowY + dy;\n            if(map[cx] && map[cx][cy] === color){\n                flag = flag || isReachable(map, cx, cy, goalX, goalY);\n            }\n        })\n    });\n    return flag;\n}\n\nfunction splitNum(str){\n    return str.split(' ').map(Number);\n}\n\nfunction isEnd(arr){\n    return arr[0] === 0 && arr[1] === 0;\n}"
  },
  {
    "language": "JavaScript",
    "code": "function main() {\n  var\n  i = 0, j,\n  wh, startXY, goalXY, n,\n  board;\n  for (;;) {\n    wh = input[i++].split(' ').map(Number);\n    if (!wh[0] && !wh[1]) break;\n    \n    board = initBoard(wh[0], wh[1]);\n    \n    startXY = input[i++].split(' ').map(Number);\n    goalXY  = input[i++].split(' ').map(Number);\n    n = Number(input[i++]);\n    for (j = 0; j < n; j++) {\n      putBlock.bind(null, board).apply(null, input[i++].split(' ').map(Number));\n    }\n    \n    console.log(canGoToGoal(board, startXY, goalXY) ? 'OK' : 'NG');\n  }\n}\n\nfunction initBoard(w, h) {\n  var\n  i, j,\n  board = [];\n  for (i = 0; i < w; i++) {\n    board.push([]);\n    for (j = 0; j < h; j++) {\n      board[i][j] = 0;\n    }\n  }\n  return board;\n}\n\nfunction putBlock(board, c, d, x, y) {\n  var\n  i, j,\n  b = [[4,2], [2,4]][d];\n  for (i = 0; i < b[0]; i++) {\n    for (j = 0; j < b[1]; j++) {\n      board[x - 1 + i][y - 1 + j] = c;\n    }\n  }\n}\n\nfunction canGoToGoal(board, startXY, goalXY) {\n  var\n  to = [[-1,-1], [ 0,-1], [ 1, -1],\n        [-1, 0],          [ 1,  0],\n        [-1, 1], [ 0, 1], [ 1,  1]],\n  sx = startXY[0] - 1, sy = startXY[1] - 1,\n  gx = goalXY[0] - 1, gy = goalXY[1] - 1,\n  m = {}, c = board[sx][sy];\n  \n  if (c === 0) return false;\n  \n  return (function search(x, y) {\n    var\n    i;\n    if ([x, y] in m) return m[[x, y]];\n    if (x < 0 || board.length <= x || board[x][y] !== c) return m[[x, y]] = false;\n    if (x === gx && y === gy) return m[[x, y]] = true;\n    \n    m[[x, y]] = false;\n    \n    for (i = 0; i < 8; i++) {\n      if (!([x + to[i][0], y + to[i][1]] in m)) {\n        if (search(x + to[i][0], y + to[i][1])) return m[[x, y]] = true;\n      }\n    }\n    \n    return m[[x, y]] = false;\n  })(sx, sy);\n}\n\n/*\nfunction canGoToGoal(board, startXY, goalXY) {\n  var\n  queue = [],\n  to = [[-1,-1], [ 0,-1], [ 1, -1],\n        [-1, 0],          [ 1,  0],\n        [-1, 1], [ 0, 1], [ 1,  1]],\n  sx = startXY[0] - 1, sy = startXY[1] - 1,\n  gx = goalXY[0] - 1, gy = goalXY[1] - 1,\n  xym, x, y,\n  m = {},\n  c = board[sx][sy];\n  \n  if (c === 0) return false;\n  \n  queue.push([sx, sy, {}]);\n  \n  for (;queue.length >= 1;) {\n    xy = queue.shift();\n    x = xy[0]; y = xy[1];\n    m[[x, y]] = true;\n    \n    if (x < 0 || board.length <= x || c !== board[x][y]) continue;\n    if (x === gx && y === gy) return true;\n    \n    for (i = 0; i < 8; i++) {\n      if (!m[[x + to[i][0], y + to[i][1]]]) {\n        queue.push([x + to[i][0], y + to[i][1]]);\n      }\n    }\n  }\n  \n  return false;\n}\n*/\n\nvar\ninput = '';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n  input += chunk;\n});\nprocess.stdin.on('end', function() {\n  input = input.split('\\n');\n  main();\n});"
  },
  {
    "language": "Ruby",
    "code": "while true\n    w, h = gets.chomp.split.map(&:to_i)\n    break if [w, h] == [0, 0]\n    start = gets.chomp.split.map{|x| x.to_i - 1}\n    goal = gets.chomp.split.map{|x| x.to_i - 1}\n    map = Array.new(h){\".\" * w}\n    n = gets.to_i\n    n.times{\n        c, d, x, y = gets.chomp.split.map(&:to_i)\n        addx, addy = 4, 2\n        if d == 1\n            addx, addy = 2, 4\n        end\n        for tempy in 0...addy\n            map[tempy + y - 1][x - 1, addx] = c.to_s * addx\n        end\n    }\n\n    result = \"NG\"\n    color = map[start[1]][start[0]]\n    if color != \".\"\n        list = [start]\n        until list.empty?\n            px, py = list.pop\n            map[py][px] = \"0\"\n            if [px, py] == goal\n                result = \"OK\"\n                break\n            end\n            list << [px + 1, py] if px < w - 1 && map[py][px + 1] == color\n            list << [px - 1, py] if px >     0 && map[py][px - 1] == color\n            list << [px, py + 1] if py < h - 1 && map[py + 1][px] == color\n            list << [px, py - 1] if py >     0 && map[py - 1][px] == color\n        end\n    end\n    puts result\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[xt - 1][yt - 1] = c\n      end\n    end\n  end\n\n  dfs(maze, xs - 1, ys - 1) unless maze[xg - 1][yg - 1] == 0\n  puts (maze[xg - 1][yg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[y][x]\n  return if c == 0\n\n  maze[y][x] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[y][x - 1] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[y - 1][x] == c\n  dfs(maze, x + 1, y) if maze[y][x + 1] && maze[y][x + 1] == c\n  dfs(maze, x, y + 1) if maze[y + 1] && maze[y + 1][x] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[yt - 1][xt - 1] = c\n      end\n    end\n  end\n\n#  dfs(maze, xs - 1, ys - 1)\n#  puts (maze[yg - 1][xg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[y][x]\n  return if c == 0\n\n  maze[y][x] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[y][x - 1] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[y - 1][x] == c\n  dfs(maze, x + 1, y) if maze[y][x + 1] && maze[y][x + 1] == c\n  dfs(maze, x, y + 1) if maze[y + 1] && maze[y + 1][x] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n#        maze[yt - 1][xt - 1] = c\n      end\n    end\n  end\n\n#  dfs(maze, xs - 1, ys - 1)\n#  puts (maze[yg - 1][xg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nBLOCK = [[4, 2], [2, 4]]\nNBRS = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n\n### main\n\nwhile true\n  w, h = gets.strip.split(' ').map{|s| s.to_i}\n  break if w == 0 && h == 0\n\n  bds = h.times.map{[0] * w}\n  visited = h.times.map{[false] * w}\n\n  xs, ys = gets.strip.split(' ').map{|s| s.to_i}\n  xs -= 1\n  ys -= 1\n\n  xg, yg = gets.strip.split(' ').map{|s| s.to_i}\n  xg -= 1\n  yg -= 1\n\n  n = gets.strip.to_i\n\n  n.times.each do\n    c, d, x, y = gets.strip.split(' ').map{|s| s.to_i}\n    x -= 1\n    y -= 1\n\n    for dy in (0...BLOCK[d][1])\n      for dx in (0...BLOCK[d][0])\n        bds[y + dy][x + dx] = c\n      end\n    end\n  end\n\n  cs = bds[ys][xs]\n  visited[ys][xs] = true\n  q = [[xs, ys]]\n\n  reached = false\n\n  while ! q.empty?\n    x, y = q.shift\n    if x == xg && y == yg\n      reached = true\n      break\n    end\n\n    for nb in NBRS\n      xn = x + nb[0]\n      yn = y + nb[1]\n\n      if xn >= 0 && xn < w && yn >= 0 && yn < h &&\n          ! visited[yn][xn] && bds[yn][xn] == cs\n        q << [xn, yn]\n        visited[yn][xn] = true\n      end\n    end\n  end\n\n  puts (reached ? \"OK\" : \"NG\")\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[y][x]\n  return if c == 0\n\n  maze[y][x] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[y][x - 1] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[y - 1][x] == c\n  dfs(maze, x + 1, y) if maze[y][x + 1] && maze[y][x + 1] == c\n  dfs(maze, x, y + 1) if maze[y + 1] && maze[y + 1][x] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h) {Array.new(w, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[yt - 1][xt - 1] = c\n      end\n    end\n  end\n\n  dfs(maze, xs - 1, ys - 1)\n  puts (maze[yg - 1][xg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[y][x]\n  return if c == 0\n\n  maze[y][x] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[y][x - 1] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[y - 1][x] == c\n  dfs(maze, x + 1, y) if maze[y][x + 1] && maze[y][x + 1] == c\n  dfs(maze, x, y + 1) if maze[y + 1] && maze[y + 1][x] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h) {Array.new(w, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[yt - 1][xt - 1] = c\n      end\n    end\n  end\n\n#  dfs(maze, xs - 1, ys - 1)\n#  puts (maze[yg - 1][xg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[xt - 1][yt - 1] = c\n      end\n    end\n  end\n\n  #dfs(maze, xs - 1, ys - 1)\n  puts (maze[xg - 1][yg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[xt - 1][yt - 1] = c\n      end\n    end\n  end\n\n  dfs(maze, xs - 1, ys - 1) unless maze[xs - 1][ys - 1] == 0\n  puts (maze[xg - 1][yg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = 3; ye = 1\n    else\n      xe = 1; ye = 3\n    end\n    (x - 1).upto(x + xe - 1) do |xt|\n      (y - 1).upto(y + ye - 1) do |yt|\n        maze[xt][yt] = c\n      end\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0 || c == 9\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[xt - 1][yt - 1] = c\n      end\n    end\n  end\n\n  dfs(maze, xs - 1, ys - 1)\n  puts (maze[xg - 1][yg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[y][x]\n  return if c == 0\n\n  maze[y][x] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[y][x - 1] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[y - 1][x] == c\n  dfs(maze, x + 1, y) if maze[y][x + 1] && maze[y][x + 1] == c\n  dfs(maze, x, y + 1) if maze[y + 1] && maze[y + 1][x] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n#    x.upto(xe) do |xt|\n#      y.upto(ye) do |yt|\n#        maze[yt - 1][xt - 1] = c\n#      end\n#    end\n  end\n\n#  dfs(maze, xs - 1, ys - 1)\n#  puts (maze[yg - 1][xg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\ndef f a,b,c,e,m;[a,b]==e||[[a,b+1],[a,b-1],[a+1,b],[a-1,b]].any?{|i,j|m[j][i]==c&&(m[j][i]=7;f i,j,c,e,m)}end\nwhile(w,h=g)[0]>0\ns,t=g\ne=g\nm=[v=[6]*(w+2)]+(1..h).map{[6]+[0]*w<<6}<<v\ng[0].times{c,d,x,y=g;o=d<1?4:2;m[y,6-o].map{|i|i[x,o]=[c]*o}}\nputs f(s,t,m[t][s],e,m)?:OK:\"NG\"end"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nwhile(w,h=g)[0]>0\nt,u=s=g;e=g\nm=[v=[6]*(w+2)]+(1..h).map{[6]+[0]*w<<6}<<v\ng[0].times{c,d,x,y=g;o=d<1?4:2;m[y,6-o].map{|i|i[x,o]=[c]*o}}\nq=[s]\nc=m[t][u]\n(q.uniq!;a,b=q.shift;m[a][b]=7;[[a,b+1],[a,b-1],[a+1,b],[a-1,b]].map{|i,j|m[i][j]==c&&q<<[i,j]})while q[0]&&q[0]!=e\nputs q[0]?:OK:\"NG\"end"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[y][x]\n  return if c == 0\n\n  maze[y][x] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[y][x - 1] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[y - 1][x] == c\n  dfs(maze, x + 1, y) if maze[y][x + 1] && maze[y][x + 1] == c\n  dfs(maze, x, y + 1) if maze[y + 1] && maze[y + 1][x] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[yt - 1][xt - 1] = c\n      end\n    end\n  end\n\n  dfs(maze, xs - 1, ys - 1)\n  puts (maze[yg - 1][xg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "Position = Struct.new(:x, :y)\n\nloop do\n  w, h = gets.split.map(&:to_i)\n  break if (w + h).zero?\n  field = Array.new(h + 1) {Array.new(w + 1, 0)}\n  \n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n  start = Position.new(xs, ys)\n  \n  gets.to_i.times do\n    color, direction, x, y = gets.split.map(&:to_i)\n    width, height = direction.zero? ? [4, 2] : [2, 4]\n    height.times do |h1|\n      width.times {|w1| field[y + h1][x + w1] = color}\n    end\n  end\n  \n  start_color = field[ys][xs]\n  field[ys][xs] = 100\n  stack = [start]\n  result = \"NG\"\n  \n  while (po = stack.shift)\n    if po.x == xg && po.y == yg\n      result = \"OK\"\n      break\n    else\n      [[1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n        next_x, next_y = po.x + dx, po.y + dy\n        next if next_x <= 0 || next_x > w || next_y <= 0 || next_y > h\n        if field[next_y][next_x] == start_color\n          stack << Position.new(next_x, next_y)\n          field[next_y][next_x] = 100\n        end\n      end\n    end\n  end\n  \n  puts result\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\nwhile(w,h=g)[0]>0\nt,u=s=g;e=g\nm=[v=[6]*(w+2)]+(1..h).map{[6]+[0]*w<<6}<<v\ng[0].times{c,d,x,y=g;o=d<1?4:2;m[y,6-o].map{|i|i[x,o]=[c]*o}}\nq=[s]\nc=m[t][u]\n(a,b=q.pop;m[a][b]=7;[[a,b+1],[a,b-1],[a+1,b],[a-1,b]].map{|i,j|m[i][j]==c&&q<<[i,j]};q.uniq!)while q[0]&&q[-1]!=e\nputs q[0]?:OK:\"NG\"end"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings, :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\nend\n\ndef get_ints\n\tgets.split.map(&:to_i)\nend\n\nloop {\n\tw, h = get_ints\n\tbreak if w == 0\n\txs, ys = get_ints\n\txg, yg = get_ints\n\tn = gets.to_i\n\t\n\tg = Graph.new \n\tnodes = (0..h+1).map{ (0..w+1).map{ g.add_node(0) } }\n\n\tn.times {\n\t\tc, d, x, y = get_ints\n\t\tfor i in y..y+(d==0 ? 2 : 4)\n\t\t\tfor j in x..x+(d==0 ? 4 : 2)\n\t\t\t\tnodes[i][j].label = c\n\t\t\tend\n\t\tend\n\t}\n\n\tfor y in 1..h\n\t\tfor x in 1..w\n\t\t\tu = nodes[y][x]\n\t\t\t[[1,0], [-1,0], [0,1], [0,-1]].each{|dx, dy|\n\t\t\t\tv = nodes[y+dy][x+dx]\n\t\t\t\tg.add_edge(u, v) if u.label == v.label\n\t\t\t}\n\t\tend\n\tend\n\n\ts = nodes[ys][xs]\n\tif s.label > 0 && g.get_path_dfs(s, nodes[yg][xg])\n\t\tputs 'OK'\n\telse\n\t\tputs 'NG'\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = 1; ye = 3\n    else\n      xe = 3; ye = 1\n    end\n    (x - 1).upto(x + xe - 1) do |xt|\n      (y - 1).upto(y + ye - 1) do |yt|\n        maze[xt][yt] = c\n      end\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\ndef f a,b,c,e,m;[a,b]==e||[[a,b+1],[a,b-1],[a+1,b],[a-1,b]].any?{|i,j|m[i][j]==c&&(m[i][j]=7;f i,j,c,e,m)}end\nwhile(w,h=g)[0]>0\ns,t=g\ne=g\nm=[v=[6]*(w+2)]+(1..h).map{[6]+[0]*w<<6}<<v\ng[0].times{c,d,x,y=g;o=d<1?4:2;m[y,6-o].map{|i|i[x,o]=[c]*o}}\nputs f(s,t,m[s][t],e,m)?:OK:\"NG\"end"
  },
  {
    "language": "Ruby",
    "code": "def g;gets.split.map &:to_i;end\ndef f a,b,c,e,m;[a,b]==e||[[a,b+1],[a,b-1],[a+1,b],[a-1,b]].any?{|i,j|m[j][i]==c&&(m[j][i]=7;f i,j,c,e,m)}end\nwhile(w,h=g)[0]>0\ns,t=g\ne=g\nm=[v=[6]*w*2]+(1..h).map{[6]+[0]*w+v}<<v\ng[0].times{c,d,x,y=g;o=d<1?4:2;m[y,6-o].map{|i|i[x,o]=[c]*o}}\nputs f(s,t,m[t][s],e,m)?:OK:\"NG\"end"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y, c)\n  return if c == 0 || maze[x][y] != c\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y, c) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1, c) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y, c) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1, c) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[xt - 1][yt - 1] = c\n      end\n    end\n  end\n\n  dfs(maze, xs - 1, ys - 1, maze[xs - 1][ys - 1])\n  puts (maze[xg - 1][yg - 1] == 9) ? 'OK' : 'NG'\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n\n      end\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def dfs(maze, x, y)\n  c = maze[x][y]\n  return if c == 0\n\n  maze[x][y] = 9\n\n  dfs(maze, x - 1, y) if x > 0 && maze[x - 1][y] == c\n  dfs(maze, x, y - 1) if y > 0 && maze[x][y - 1] == c\n  dfs(maze, x + 1, y) if maze[x + 1] && maze[x + 1][y] == c\n  dfs(maze, x, y + 1) if maze[x][y + 1] && maze[x][y + 1] == c\nend\n\nwhile true\n  w, h = gets.split.map(&:to_i)\n  break if w == 0 && h == 0\n\n  maze = Array.new(h - 1) {Array.new(w - 1, 0)}\n\n  xs, ys = gets.split.map(&:to_i)\n  xg, yg = gets.split.map(&:to_i)\n\n  n = gets.to_i\n  n.times do |i|\n    c, d, x, y = gets.split.map(&:to_i)\n    if d == 0\n      xe = x + 3; ye = y + 1\n    else\n      xe = x + 1; ye = y + 3\n    end\n    x.upto(xe) do |xt|\n      y.upto(ye) do |yt|\n        maze[xt - 1][yt - 1] = c\n      end\n    end\n  end\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strings\"\n\t\"strconv\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nvar (\n\tdx = []int{0, -1, 0, 1}\n\tdy = []int{1, 0, -1, 0}\n)\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\tw, _ := strconv.Atoi(buf[0])\n\t\th, _ := strconv.Atoi(buf[1])\n\t\tif w == 0 && h == 0 {\n\t\t\tbreak\n\t\t}\n\t\tscanner.Scan()\n\t\tbuf_ := strings.Split(scanner.Text(), \" \")\n\t\txs, _ := strconv.Atoi(buf_[0])\n\t\tys, _ := strconv.Atoi(buf_[1])\n\t\tscanner.Scan()\n\t\tbuf__ := strings.Split(scanner.Text(), \" \")\n\t\txg, _ := strconv.Atoi(buf__[0])\n\t\tyg, _ := strconv.Atoi(buf__[1])\n\t\txs--\n\t\tys--\n\t\txg--\n\t\tyg--\n\t\tscanner.Scan()\n\t\tn, _ := strconv.Atoi(scanner.Text())\n\t\tfield := make([][]int, 100)\n\t\tfor i := range  field {\n\t\t\tfield[i] = make([]int, 100)\n\t\t}\n\t\tvisited := make([][]bool, 100)\n\t\tfor i := range visited {\n\t\t\tvisited[i] = make([]bool, 100)\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tscanner.Scan()\n\t\t\tbuf___ := strings.Split(scanner.Text(), \" \")\n\t\t\tc, _ := strconv.Atoi(buf___[0])\n\t\t\td, _ := strconv.Atoi(buf___[1])\n\t\t\tx, _ := strconv.Atoi(buf___[2])\n\t\t\ty, _ := strconv.Atoi(buf___[3])\n\t\t\tx--\n\t\t\ty--\n\t\t\tswitch d {\n\t\t\tcase 0:\n\t\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\t\tfor k := 0; k < 2; k++ {\n\t\t\t\t\t\tfield[x+j][y+k] = c\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\tfor j := 0; j < 2; j++ {\n\t\t\t\t\tfor k := 0; k < 4; k++ {\n\t\t\t\t\t\tfield[x+j][y+k] = c\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif field[xs][ys] != field[xg][yg] || // スタートとゴールの色が等しくないと\"NG\"\n\t\t\tfield[xs][ys] == 0 { // スタートの色が無職\n\t\t\tfmt.Println(\"NG\")\n\t\t\tcontinue\n\t\t}\n\t\tQ := make([]Entry, 0)\n\t\tvisited[xs][ys] = true\n\t\tQ = append(Q, Entry{xs, ys})\n\t\tfor len(Q) > 0 {\n\t\t\trow := Q[0].x\n\t\t\tcol := Q[0].y\n\t\t\tQ = Q[1:]\n\t\t\tfor i := 0; i < 4; i++ {\n\t\t\t\tif 0 <= row+dx[i] && row+dx[i] < w &&\n\t\t\t\t\t0 <= col+dy[i] && col+dy[i] < h && // 移動可能な範囲内かどうか\n\t\t\t\t\t!visited[row + dx[i]][col + dy[i]] && // 訪問済みか\n\t\t\t\t\tfield[row+dx[i]][col+dy[i]]==field[row][col] { // 色が同じかどうか\n\t\t\t\t\t\tvisited[row+dx[i]][col+dy[i]] = true\n\t\t\t\t\t\tQ = append(Q, Entry{row+dx[i],col+dy[i]})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif visited[xg][yg] {\n\t\t\tfmt.Println(\"OK\")\n\t\t} else {\n\t\t\tfmt.Println(\"NG\")\n\t\t}\n\t}\n}\n\ntype Entry struct {\n\tx, y int\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n//(map座標全てに0を入れる) $map[$c][$y][$x]として、ブロックがある座標を１に。\n//スタート地点上にあるブロックの「色」を調べる。なければNG。その色のブロックの座標のみたどる。\n//スタート地点から深さ優先探索でmove。ゴールまでたどり着ければOK。ダメならNG\n\n$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));\n\n//dfs\nfunction dfs($c, $y, $x){\n\tglobal $move;\n\tglobal $map;\n\tglobal $goal_flag;\n\tglobal $yg;\n\tglobal $xg;\n\n\tif ($y === $yg && $x === $xg){\t//終了条件\n\t\t$goal_flag = 1;\n\t\treturn;\n\t}\n\n\t$map[$c][$y][$x] = 0;\t//再訪防止\n\tfor ($i=0; $i<=3; $i++){\t//上下左右を調査\n\t\t$y2 = $y + $move[$i][1];\n\t\t$x2 = $x + $move[$i][0];\n\t\tif (!empty($map[$c][$y2][$x2]) && $map[$c][$y2][$x2]===1){\n\t\t\tdfs($c, $y2, $x2);\n\t\t}\n\t}\n\treturn;\n}\n\nwhile(1){\n\t//初期化\n\t$goal_flag = 0;\n\t$map = array();\n\t$usecolor = 0;\t\t//たどる色\n\n\t//ファイル読み込み\n\tfscanf(STDIN, '%d %d', $w, $h);\n\t//終了判定\n\tif ($w==0 && $h==0){\n\t\tbreak;\n\t}\n\tfscanf(STDIN, '%d %d', $xs, $ys);\n\tfscanf(STDIN, '%d %d', $xg, $yg);\n\tfscanf(STDIN, '%d', $n);\n\tfor ($i=0; $i<$n; $i++){\n\t\tfscanf(STDIN, '%d %d %d %d', $c, $d, $xblock, $yblock);\n\t\t//ブロックがある座標を１に\n\t\tif ($d === 0){\t\t//方向転換なし\n\t\t\tfor ($p=0; $p<=3; $p++){\n\t\t\t\tfor ($q=0; $q<=1; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ($p=0; $p<=1; $p++){\n\t\t\t\tfor ($q=0; $q<=3; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//スタート地点上の色判定\n\tfor ($c=1; $c<=5; $c++){\n\t\tif (!empty($map[$c][$ys][$xs]) && $map[$c][$ys][$xs] === 1){\n\t\t\t$usecolor = $c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//スタート地点から探索\n\tif ($usecolor !== 0){\n\t\tdfs($usecolor, $ys, $xs);\n\t}\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo 'OK';\n\t} else {\n\t\techo 'NG';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//(map座標全てに0を入れる) $map[$c][$y][$x]として、ブロックがある座標を１に。\n//スタート地点上にあるブロックの「色」を調べる。なければNG。その色のブロックの座標のみたどる。\n//スタート地点から深さ優先探索でmove。ゴールまでたどり着ければOK。ダメならNG\n\n$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));\n\n//dfs\nfunction dfs($c, $y, $x){\n\tglobal $move;\n\tglobal $map;\n\tglobal $goal_flag;\n\n\tif ($y === $yg && $x === $xg){\t//終了条件\n\t\t$goal_flag = 1;\n\t\treturn;\n\t}\n\n\t$map[$c][$y][$x] = 0;\t//再訪防止\n\tfor ($i=0; $i<=3; $i++){\t//上下左右を調査\n\t\t$y2 = $y + $move[$i][1];\n\t\t$x2 = $x + $move[$i][0];\n\t\tif (!empty($map[$c][$y2][$x2]) && $map[$c][$y2][$x2]===1){\n\t\t\tdfs($c, $y2, $x2);\n\t\t}\n\t}\n\treturn;\n}\n\nwhile(1){\n\t//初期化\n\t$goal_flag = 0;\n\t$map = array();\n\t$usecolor = 0;\t\t//たどる色\n\n\t//ファイル読み込み\n\tfscanf(STDIN, '%d %d', $w, $h);\n\t//終了判定\n\tif ($w==0 && $h==0){\n\t\tbreak;\n\t}\n\tfscanf(STDIN, '%d %d', $xs, $ys);\n\tfscanf(STDIN, '%d %d', $xg, $yg);\n\tfscanf(STDIN, '%d', $n);\n\tfor ($i=0; $i<$n; $i++){\n\t\tfscanf(STDIN, '%d %d %d %d', $c, $d, $xblock, $yblock);\n\t\t//ブロックがある座標を１に\n\t\tif ($d === 0){\t\t//方向転換なし\n\t\t\tfor ($p=0; $p<=3; $p++){\n\t\t\t\tfor ($q=0; $q<=1; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ($p=0; $p<=1; $p++){\n\t\t\t\tfor ($q=0; $q<=3; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//スタート地点上の色判定\n\tfor ($c=1; $c<=5; $c++){\n\t\tif (!empty($map[$c][$ys][$xs]) && $map[$c][$ys][$xs] === 1){\n\t\t\t$usecolor = $c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//スタート地点から探索\n\tif ($usecolor !== 0){\n\t\tdfs($usecolor, $ys, $xs);\n\t}\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo 'OK';\n\t} else {\n\t\techo 'NG';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//(map座標全てに0を入れる) $map[$c][$y][$x]として、ブロックがある座標を１に。\n//スタート地点上にあるブロックの「色」を調べる。なければNG。その色のブロックの座標のみたどる。\n//スタート地点から深さ優先探索でmove。ゴールまでたどり着ければOK。ダメならNG\n\n$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));\n\n//dfs\nfunction dfs($c, $y, $x){\n\tglobal $move;\n\tglobal $map;\n\tglobal $goal_flag;\n\tglobal $yg;\n\tglobal $xg;\n\n\tif ($y === $yg && $x === $xg){\t//終了条件\n\t\t$goal_flag = 1;\n\t\treturn;\n\t}\n\n\t$map[$c][$y][$x] = 0;\t//再訪防止\n\tfor ($i=0; $i<=3; $i++){\t//上下左右を調査\n\t\t$y2 = $y + $move[$i][1];\n\t\t$x2 = $x + $move[$i][0];\n\t\tif (!empty($map[$c][$y2][$x2]) && $map[$c][$y2][$x2]===1){\n\t\t\tdfs($c, $y2, $x2);\n\t\t}\n\t}\n\treturn;\n}\n\nwhile(1){\n\t//初期化\n\t$goal_flag = 0;\n\t$map = array();\n\t$usecolor = 0;\t\t//たどる色\n\n\t//ファイル読み込み\n\tfscanf(STDIN, '%d %d', $w, $h);\n\t//終了判定\n\tif ($w==0 && $h==0){\n\t\tbreak;\n\t}\n\tfscanf(STDIN, '%d %d', $xs, $ys);\n\tfscanf(STDIN, '%d %d', $xg, $yg);\n\tfscanf(STDIN, '%d', $n);\n\tfor ($i=0; $i<$n; $i++){\n\t\tfscanf(STDIN, '%d %d %d %d', $c, $d, $xblock, $yblock);\n\t\t//ブロックがある座標を１に\n\t\tif ($d === 0){\t\t//方向転換なし\n\t\t\tfor ($p=0; $p<=3; $p++){\n\t\t\t\tfor ($q=0; $q<=1; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ($p=0; $p<=1; $p++){\n\t\t\t\tfor ($q=0; $q<=3; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//スタート地点上の色判定\n\tfor ($c=1; $c<=5; $c++){\n\t\tif ($map[$c][$ys][$xs] === 1){\n\t\t\t$usecolor = $c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//スタート地点から探索\n\tif ($usecolor !== 0){\n\t\tdfs($usecolor, $ys, $xs);\n\t}\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo 'OK';\n\t} else {\n\t\techo 'NG';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\n//(map座標全てに0を入れる) $map[$c][$y][$x]として、ブロックがある座標を１に。\n//スタート地点上にあるブロックの「色」を調べる。なければNG。その色のブロックの座標のみたどる。\n//スタート地点から深さ優先探索でmove。ゴールまでたどり着ければOK。ダメならNG\n\n$move = array(array(1,0),array(0,1),array(-1,0),array(0,-1));\n\n//dfs\nfunction dfs($c, $y, $x){\n\tglobal $move;\n\tglobal $map;\n\tglobal $goal_flag;\n\tglobal $yg;\n\tglobal $xg;\n\n\tif ($y === $yg && $x === $xg){\t//終了条件\n\t\t$goal_flag = 1;\n\t\treturn;\n\t}\n\n\t$map[$c][$y][$x] = 0;\t//再訪防止\n\tfor ($i=0; $i<=3; $i++){\t//上下左右を調査\n\t\t$y2 = $y + $move[$i][1];\n\t\t$x2 = $x + $move[$i][0];\n\t\tif (!empty($map[$c][$y2][$x2]) && $map[$c][$y2][$x2]===1){\n\t\t\tdfs($c, $y2, $x2);\n\t\t}\n\t}\n\treturn;\n}\n\nwhile(1){\n\t//初期化\n\t$goal_flag = 0;\n\t$map = array();\n\t$usecolor = 0;\t\t//たどる色\n\n\t//ファイル読み込み\n\tfscanf(STDIN, '%d %d', $w, $h);\n\t//終了判定\n\tif ($w==0 && $h==0){\n\t\tbreak;\n\t}\n\tfscanf(STDIN, '%d %d', $xs, $ys);\n\tfscanf(STDIN, '%d %d', $xg, $yg);\n\tfscanf(STDIN, '%d', $n);\n\tfor ($i=0; $i<$n; $i++){\n\t\tfscanf(STDIN, '%d %d %d %d', $c, $d, $xblock, $yblock);\n\t\t//ブロックがある座標を１に\n\t\tif ($d === 0){\t\t//方向転換なし\n\t\t\tfor ($p=0; $p<=3; $p++){\n\t\t\t\tfor ($q=0; $q<=1; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ($p=0; $p<=1; $p++){\n\t\t\t\tfor ($q=0; $q<=3; $q++){\n\t\t\t\t\t$map[$c][$yblock + $q][$xblock + $p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//スタート地点上の色判定\n\tfor ($c=1; $c<=5; $c++){\n\t\tif (!empty($map[$c][$ys][$xs]) && $map[$c][$ys][$xs] === 1){\n\t\t\t$usecolor = $c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//スタート地点から探索\n\tif ($usecolor !== 0){\n\t\tdfs($usecolor, $ys, $xs);\n\t}\n\t//出力\n\tif ($goal_flag === 1){\n\t\techo 'OK';\n\t} else {\n\t\techo 'NG';\n\t}\n\techo PHP_EOL;\n}"
  },
  {
    "language": "Python",
    "code": "def dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y][x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny][nx] == m[y][x] and v[ny][nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nwhile True:\n    H, W = list(map(int, input().split()))\n    if H == 0 and W == 0:\n        break\n    xs, ys = list(map(lambda x: int(x)-1, input().split()))\n    xg, yg = list(map(lambda x: int(x)-1, input().split()))\n    n = int(input())\n    m = [[0 for _ in range(W)] for __ in range(H)]\n    v = [[False for _ in range(W)] for __ in range(H)]\n\n    for _ in range(n):\n        c, d, x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if d == 0:\n            for y in range(2):\n                for x in range(4):\n                    m[y][x] = c\n        else:\n            for y in range(4):\n                for x in range(2):\n                    m[y][x] = c\n\n    dfs(xs, ys, m, v, W, H, xg, yg)\n    if v[yg][xg]:\n        print('OK')\n    else:\n        print('NG')"
  },
  {
    "language": "Python",
    "code": "def block(board, y, x, direction, color):\n    # ???\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[x + i][y + j] = color\n    # ??±\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[x + j][y + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_x, s_y, g_x, g_y):\n    place = board[s_x][s_y]\n    if place == 0:\n        return 'NG'\n    x, y = s_x, s_y\n    stack = []\n\n    while True:\n        # print(x, y)\n        board[x][y] = place + 1\n        if board[x + 1][y] == place:\n            x += 1\n            stack.append((x, y))\n        elif board[x][y + 1] == place:\n            y += 1\n            stack.append((x, y))\n        elif board[x - 1][y] == place:\n            x -= 1\n            stack.append((x, y))\n        elif board[x][y - 1] == place:\n            y -= 1\n            stack.append((x, y))\n        else:\n            if len(stack) == 0 and board[x + 1][y] != place and board[x][y + 1] != place and board[x - 1][y] != place and board[x][y - 1] != place:\n                return 'NG'\n            (x, y) = stack.pop()\n\n        if x == g_x and y == g_y:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w)] for _ in range(h)]\n        s_x, s_y = map(int, input().split())\n        g_x, g_y = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, x, y = map(int, input().split())\n            block(board, x, y, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_y, s_x, g_y, g_x))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "\t\tB[y][x] = -1\n\t\tcheck(B,x-1,y,c);check(B,x,y-1,c);check(B,x+1,y,c);check(B,x,y+1,c)"
  },
  {
    "language": "Python",
    "code": "import Queue\nblockpos = [[[0,0], [0,1], [1,0], [1,1], [2,0], [2,1], [3,0], [3,1]], [[0,0], [0,1], [0,2], [0,3], [1,0], [1,1], [1,2], [1,3]]]\ndxy = [[0,1], [1,0], [0,-1], [-1,0]]\nq = Queue.Queue()\nW, H = 0, 0\n\ndef checker(xs, ys, xg, yg, field, color):\n  if color == 0:\n    return False\n  global W, H\n  x = xs\n  y = ys\n  while True:\n    if x == xg and y == yg:\n      return True\n    for dx, dy in dxy:\n      if x+dx < 1 or y+dy < 1 or x+dx > W or y+dy > H:\n        continue\n      if field[x+dx][y+dy] == color:\n        field[x+dx][y+dy] = 0\n        q.put([x+dx, y+dy])\n    if q.empty():\n      return False\n    x, y = q.get()\n\n\nwhile True:\n  # input\n  W, H = map(int, raw_input().split())\n  if W==0 and H==0:\n    break\n  field = [[0 for i in range(H+1)] for j in range(W+1)]\n  xs, ys = map(int, raw_input().split())\n  xg, yg = map(int, raw_input().split())\n  n = int(raw_input())\n  for i in range(n):\n    c, d, x, y = map(int, raw_input().split())\n    for dx, dy in blockpos[d]:\n      field[x+dx][y+dy] = c\n  result = checker(xs, ys, xg, yg, field, field[xs][ys])\n  if result:\n    print \"OK\"\n  else:\n    print \"NG\""
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nBlock = namedtuple('Block', ['color', 'direction', 'x', 'y'])\n\n\ndef occupation_point(block):\n    x, y = block.x, block.y\n    d = [(0, 0), (1, 0), (0, 1), (1, 1)]\n    for dx, dy in d:\n        yield x + dx, y + dy\n    if block.direction:\n        y += 2\n    else:\n        x += 2\n    for dx, dy in d:\n        yield x + dx, y + dy\n\ndef paintout(board, start, value):\n    color = board[start.y][start.x]\n    if color == 0:\n        return\n    que =[(start.x, start.y)]\n    print('cv',color, value)\n    while que:\n        x,y = que.pop()\n        if board[y][x] == color:\n            board[y][x] = value\n            que.extend([(x + dx, y + dy) for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]])\n\n\ndef is_reachable(size, start, goal, blocks):\n    board = [[0] * (size.x + 2) for _ in range(size.y + 2)]\n    for bi in blocks:\n        for x, y in occupation_point(bi):\n            board[y][x] = bi.color\n    paintout(board, start, -1)\n    for bi in board:\n        print(bi)\n    return board[goal.y][goal.x] == -1\n\n\nwhile True:\n    size = Point(*map(int, readline().split()))\n    if size.x == 0:\n        break\n    start = Point(*map(int, readline().split()))\n    goal = Point(*map(int, readline().split()))\n    blocks = []\n    for _ in range(int(readline())):\n        blocks.append(Block(*map(int, readline().split())))\n    print('OK' if is_reachable(size, start, goal, blocks) else 'NG')"
  },
  {
    "language": "Python",
    "code": "def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\""
  },
  {
    "language": "Python",
    "code": "global B\ndef check(B,x,y,c):\n\tif 0 < x < w+2 and 0 < y < h+2 and B[y][x] == c:\n\t\tB[y][x] = -1\n\t\tcheck(B,x-1,y,c);check(B,x,y-1,c);check(B,x+1,y,c);check(B,x,y+1,c)\n\nwhile 1:\n\tw,h = map(int,raw_input().split())\n\tif w == 0: break\n\tB = [[0]*(w+2) for i in range(h+2)]\n\txs,ys = map(int,raw_input().split())\n\txg,yg = map(int,raw_input().split())\n\tfor i in range(input()):\n\t\tc,d,x,y = map(int,raw_input().split())\n\t\tif d == 0:\n\t\t\tB[y][x:x+4] = [c]*4\n\t\t\tB[y+1][x:x+4] = [c]*4\n\t\telse:\n\t\t\tfor j in range(4):\n\t\t\t\tB[y+j][x:x+2] = [c]*2\n\tif B[ys][xs] != B[yg][xg]:\n\t\tprint \"NG\"\n\telse:\n\t\tcheck(B,xs,ys,B[xs][ys])\n\t\tprint \"OK\" if B[yg][xg] == -1 else \"NG\""
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y, x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny, nx] == m[y, x] and v[ny, nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nwhile True:\n    H, W = list(map(int, input().split()))\n    if H == 0 and W == 0:\n        break\n    xs, ys = list(map(lambda x: int(x)-1, input().split()))\n    xg, yg = list(map(lambda x: int(x)-1, input().split()))\n    n = int(input())\n    m = np.array([[0 for _ in range(W)] for __ in range(H)])\n    v = np.array([[False for _ in range(W)] for __ in range(H)])\n\n    for _ in range(n):\n        c, d, x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if d == 0:\n            m[y:y+2, x:x+4] = c\n        else:\n            m[y:y+4, x:x+2] = c\n\n    dfs(xs, ys, m, v, W, H, xg, yg)\n    if v[yg, xg]:\n        print('OK')\n    else:\n        print('NG')"
  },
  {
    "language": "Python",
    "code": "import Queue\nblockpos = [[[0,0], [0,1], [1,0], [1,1], [2,0], [2,1], [3,0], [3,1]], [[0,0], [0,1], [0,2], [0,3], [1,0], [1,1], [1,2], [1,3]]]\ndxy = [[0,1], [1,0], [0,-1], [-1,0]]\nq = Queue.Queue()\nW, H = 0, 0\n\ndef checker(xs, ys, xg, yg, field, color):\n  if color == 0:\n    return False\n  global W, H\n  x = xs\n  y = ys\n  while True:\n    if x == xg and y == yg:\n      return True\n    for dx, dy in dxy:\n      if x+dx < 1 or y+dy < 1 or x+dx > H or y+dx > W:\n        continue\n      if field[x+dx][y+dy] == color:\n        field[x+dx][y+dy] = 0\n        q.put([x+dx, y+dy])\n    if q.empty():\n      return False\n    x, y = q.get()\n\n\nwhile True:\n  # input\n  W, H = map(int, raw_input().split())\n  if W==0 and H==0:\n    break\n  field = [[0 for i in range(W+1)] for j in range(H+1)]\n  xs, ys = map(int, raw_input().split())\n  xg, yg = map(int, raw_input().split())\n  n = int(raw_input())\n  for i in range(n):\n    c, d, x, y = map(int, raw_input().split())\n    for dx, dy in blockpos[d]:\n      field[x+dx][y+dy] = c\n  result = checker(xs, ys, xg, yg, field, field[xs][ys])\n  if result:\n    print \"OK\"\n  else:\n    print \"NG\""
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 9/20/16. \"\"\"\n\n\ndef block(board, w, h, direction, color):\n    # horizontal.\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[h + i][w + j] = color\n    # vertical.\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[h + j][w + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndirect = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n\ndef is_goable(board, w, h, color):\n    for x, y in direct:\n        if board[h + x][w + y] == color:\n            return True\n    return False\n\n\ndef go_maze(board, s_w, s_h, g_w, g_h):\n    place = board[s_h][s_w]\n    if place == 0:\n        return 'NG'\n    w, h = s_w, s_h\n    stack = []\n\n    while True:\n        board[h][w] = place + 1\n        is_no_way = True\n        for x, y in direct:\n            if board[h + x][w + y] == place:\n                w, h = w + y, h + x\n                stack.append((w, h))\n                is_no_way = False\n                break\n\n        if is_no_way:\n            if len(stack) == 0 and not is_goable(board, w, h, place):\n                return 'NG'\n            (w, h) = stack.pop()\n        if w == g_w and h == g_h:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(110)] for _ in range(110)]\n        s_w, s_h = map(int, input().split())\n        g_w, g_h = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, w, h = map(int, input().split())\n            block(board, w, h, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_w, s_h, g_w, g_h))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def block(board, y, x, direction, color):\n    # ???\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[x + i][y + j] = color\n    # ??±\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[x + j][y + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_x, s_y, g_x, g_y):\n    place = board[s_x][s_y]\n    if place == 0:\n        return 'NG'\n    x, y = s_x, s_y\n    stack = []\n\n    while True:\n        # print(x, y)\n        board[x][y] = place + 1\n        if x + 1 < len(board) and board[x + 1][y] == place:\n            x += 1\n            stack.append((x, y))\n        elif y + 1 < len(board[x]) and board[x][y + 1] == place:\n            y += 1\n            stack.append((x, y))\n        elif x - 1 > 0 and board[x - 1][y] == place:\n            x -= 1\n            stack.append((x, y))\n        elif y - 1 > 0 and board[x][y - 1] == place:\n            y -= 1\n            stack.append((x, y))\n        else:\n            if len(stack) == 0 and board[x + 1][y] != place and board[x][y + 1] != place and board[x - 1][y] != place and board[x][y - 1] != place:\n                return 'NG'\n            (x, y) = stack.pop()\n\n        if x == g_x and y == g_y:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w + 1)] for _ in range(h + 1)]\n        s_x, s_y = map(int, input().split())\n        g_x, g_y = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, x, y = map(int, input().split())\n            block(board, x, y, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_y, s_x, g_y, g_x))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "while True:\n    w,h=map(int, input().split())\n    if w==h==0:\n        break\n    xs,ys=map(int, input().split())\n    xg,yg=map(int, input().split())\n    xs-=1\n    ys-=1\n    xg-=1\n    yg-=1\n    n=int(input())\n    dataset=[]\n    for _ in range(n):\n        dataset.append(list(map(int,input().split())))\n\n    maze=[ [0 for i in range(w) ] for j in range(h)]\n\n    for data in dataset:\n        color=data[0]\n        drc=data[1]\n        x=data[2]-1\n        y=data[3]-1\n        x_list=[x,x+1] if drc==1 else [x,x+1,x+2,x+3]   \n        y_list=[y,y+1,y+2,y+3] if drc==1 else [y,y+1]\n\n        for dy in y_list:\n            for dx in x_list:\n                maze[dy][dx]=color\n\n    history=[[-1 for i in range(w)] for j in range(h)]\n    ws=[]\n    dx_list=[0,0,1,-1]\n    dy_list=[1,-1,0,0]\n\n    flag=False\n\n    if maze[ys][xs]!=0:\n        ws.append([xs,ys])\n\n    while len(ws)!=0:\n        current=ws.pop(0)\n        current_color=maze[current[1]][current[0]]\n        if current[0]==xg and current[1]==yg:\n            flag=True \n            break\n        for dx,dy in zip(dx_list,dy_list):\n            next_x=current[0]+dx\n            next_y=current[1]+dy\n            if next_x>=0 and next_x<w and next_y>=0 and next_y<h and maze[next_y][next_x]==current_color and history[next_y][next_x]==-1:\n                history[next_y][next_x]=0\n                ws.append([next_x,next_y])\n\n    if flag:\n        print('OK')\n    else:\n        print('NG')\n\n"
  },
  {
    "language": "Python",
    "code": "global B\ndef check(B,x,y,c):\n\tif 0 < x < w+2 and 0 < y < h+2 and B[y][x] == c:\n\t\tB[y][x] = -1\n\t\tcheck(B,x-1,y,c);check(B,x,y-1,c);check(B,x+1,y,c);check(B,x,y+1,c)\n\nwhile 1:\n\tw,h = map(int,raw_input().split())\n\tif w == 0: break\n\tB = [[0]*(w+2) for i in range(h+2)]\n\txs,ys = map(int,raw_input().split())\n\txg,yg = map(int,raw_input().split())\n\tfor i in range(input()):\n\t\tc,d,x,y = map(int,raw_input().split())\n\t\tif d == 0:\n\t\t\tB[y][x:x+4] = [c]*4\n\t\t\tB[y+1][x:x+4] = [c]*4\n\t\telse:\n\t\t\tfor j in range(4):\n\t\t\t\tB[y+j][x:x+2] = [c]*2\n\tif B[ys][xs] != B[yg][xg]:\n\t\tprint \"NG\"\n\telse:\n\t\tcheck(B,xs,ys,B[xs][ys])\n\t\tprint \"OK\" if B[yg][xg] == -1 else \"NG\""
  },
  {
    "language": "Python",
    "code": "# Aizu Problem 0207: Block\n\nimport sys, math, os\n\n# read input:\nPYDEV = os.environ.get('PYDEV')\nif PYDEV==\"True\":\n    sys.stdin = open(\"sample-input.txt\", \"rt\")\n\n\ndef build_grid(W, H, N, blocks):\n    grid = [[0 for _ in range(W)] for __ in range(H)]\n    for c, d, x, y in blocks:\n        x, y = x - 1, y - 1\n        if d == 0:\n            # horizontal long:\n            dx, dy = 4, 2\n        else:\n            # vertical long:\n            dx, dy = 2, 4\n        for xi in range(x, x + dx):\n            for yi in range(y, y + dy):\n                grid[yi][xi] = c\n    return grid\n\n\ndef bfs(W, H, grid, xs, ys, xg, yg):\n    delta = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    color = grid[ys][xs]\n    if color == 0:\n        return \"NG\"\n    visited = set()\n    queue = [(xs, ys)]\n    while len(queue) > 0:\n        current = queue.pop(0)\n        visited.add(current)\n        col, row = current\n        for drow, dcol in delta:\n            row2, col2 = row + drow, col + dcol\n            if 0 <= row2 < H and 0 <= col2 < W and grid[row2][col2] == color:\n                # neighboring piece has same color:\n                neighbor = (col2, row2)\n                if neighbor == (xg, yg):\n                    return \"OK\"\n                if neighbor not in queue and neighbor not in visited:\n                    queue.append(neighbor)\n    return \"NG\"\n\n    \nwhile True:\n    W, H = [int(_) for _ in input().split()]\n    if W == H == 0:\n        break\n    xs, ys = [int(_) - 1 for _ in input().split()]\n    xg, yg = [int(_) - 1 for _ in input().split()]\n    N = int(input())\n    blocks = [[int(_) for _ in input().split()] for __ in range(N)]\n    grid = build_grid(W, H, N, blocks)\n    print(bfs(W, H, grid, xs, ys, xg, yg))\n    \n    #for row in grid:\n    #    print(''.join([str(r) for r in row]))\n    #print(color)"
  },
  {
    "language": "Python",
    "code": "def tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\""
  },
  {
    "language": "Python",
    "code": "def dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y][x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny][nx] == m[y][x] and v[ny][nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nif __name__ == '__main__':\n    while True:\n        H, W = list(map(int, input().split()))\n        if H == 0 and W == 0:\n            break\n        xs, ys = list(map(lambda x: int(x)-1, input().split()))\n        xg, yg = list(map(lambda x: int(x)-1, input().split()))\n        n = int(input())\n        m = [[0 for _ in range(W)] for __ in range(H)]\n        v = [[False for _ in range(W)] for __ in range(H)]\n\n        for _ in range(n):\n            c, d, x, y = list(map(int, input().split()))\n            x -= 1\n            y -= 1\n            if d == 0:\n                for y in range(2):\n                    for x in range(4):\n                        m[y][x] = c\n            else:\n                for y in range(4):\n                    for x in range(2):\n                        m[y][x] = c\n\n        dfs(xs, ys, m, v, W, H, xg, yg)\n        if v[yg][xg]:\n            print('OK')\n        else:\n            print('NG')"
  },
  {
    "language": "Python",
    "code": "BLOCK_WIDTH = 4\nBLOCK_HEIGHT = 2\nfield = []\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\nw = 0\nh = 0\nxg = 0\nyg = 0\n\ndef main():\n    global field, w, h, xg, yg\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        field = [[0] * w for _ in range(h)]\n        for i in range(n):\n            c, d, x, y = map(int, input().split())\n            arrangement(c, d, x, y)\n\n        if dfs(field[xs][ys], xs, ys):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\n\ndef arrangement(c, d, x, y):\n    global field\n    if d == 0:\n        for i in range(BLOCK_HEIGHT):\n            for j in range(BLOCK_WIDTH):\n                field[y + i][x + j] = c\n    else:\n        for i in range(BLOCK_WIDTH):\n            for j in range(BLOCK_HEIGHT):\n                field[y + i][x + j] = c\n\n\ndef dfs(c, x, y):\n    global field\n\n    if x < 0 or x >= w or y < 0 or y >= h:\n        return False\n    if field[y][x] != c:\n        return False\n    if x == xg and y == yg:\n        return True\n    field[y][x] = -1\n    for i in range(4):\n        next_x = x + dx[i]\n        next_y = y + dy[i]\n        if dfs(c, next_x, next_y):\n            return True\n\n    return False\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "sys.setrecursionlimit(10000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    [clx,cly]=cl\n    for i in range(clx-1,clx+2):\n        for j in range(cly-1,cly+2):\n            if [i,j] in nc:\n                nc.remove([i,j])\n                ok.append([i,j])\n                tansaku([i,j],nc,ok,goal)\n\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\""
  },
  {
    "language": "Python",
    "code": "def block(board, y, x, direction, color):\n    # ???\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                print(x + i, y + j)\n                board[x + i][y + j] = color\n    # ??±\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[x + j][y + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_x, s_y, g_x, g_y):\n    place = board[s_x][s_y]\n    if place == 0:\n        return 'NG'\n    x, y = s_x, s_y\n    stack = []\n\n    while True:\n        # print(x, y)\n        board[x][y] = place + 1\n        if x + 1 < len(board) and board[x + 1][y] == place:\n            x += 1\n            stack.append((x, y))\n        elif y + 1 < len(board[x]) and board[x][y + 1] == place:\n            y += 1\n            stack.append((x, y))\n        elif x - 1 > 0 and board[x - 1][y] == place:\n            x -= 1\n            stack.append((x, y))\n        elif y - 1 > 0 and board[x][y - 1] == place:\n            y -= 1\n            stack.append((x, y))\n        else:\n            if len(stack) == 0 and board[x + 1][y] != place and board[x][y + 1] != place and board[x - 1][y] != place and board[x][y - 1] != place:\n                return 'NG'\n            (x, y) = stack.pop()\n\n        if x == g_x and y == g_y:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w + 1)] for _ in range(h + 1)]\n        s_x, s_y = map(int, input().split())\n        g_x, g_y = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, x, y = map(int, input().split())\n            block(board, x, y, direction, color)\n\n        print_board(board)\n        # print(go_maze(board, s_y, s_x, g_y, g_x))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0207\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\n\ndef solve(w, h, xs, ys, xg, yg, blocks):\n    # ????????????????????±????????°???????????????l\n    field = [[0] * (w+1) for _ in range(h+1)]\n    for c, d, x, y in blocks:\n        field[y][x] = c\n        field[y][x+1] = c\n        field[y+1][x] = c\n        field[y+1][x+1] = c\n\n        if d == 0:              #  ?¨????\n            field[y][x+2] = c\n            field[y][x+3] = c\n            field[y+1][x+2] = c\n            field[y+1][x+3] = c\n        else:                   #  ??????\n            field[y+2][x] = c\n            field[y+3][x] = c\n            field[y+2][x+1] = c\n            field[y+3][x+1] = c\n\n    # ????????????????§????????????´????????§?¨??????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n\n    explored = set()            #  ??¢?´¢????????§?¨?(x, y)????¨????\n    explored.add((xs, ys))\n    Q = deque()\n    Q.append((xs, ys))\n    color = field[ys][xs]       #  ?????????????????¨?????§?????????????????????????????°?????¨???????????????\n\n    while Q:\n        xc, yc = Q.popleft()        #  ?????¨??°?????§?¨?\n        if xc == xg and yc == yg:\n            return 'OK'\n        for i in range(len(dx)):\n            xn = xc + dx[i]\n            yn = yc + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0 < xn <= w and 0 < yn <= h and field[yn][xn] == color and (xn, yn) not in explored:\n                Q.append((xn, yn))\n                explored.add((xn, yn))\n    return 'NG'\n\n\ndef main(args):\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        blocks = [list(map(int, input().split())) for _ in range(n)]\n\n        result = solve(w, h, xs, ys, xg, yg, blocks)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "def block(board, y, x, direction, color):\n    # ???\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[x + i][y + j] = color\n    # ??±\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[x + j][y + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_x, s_y, g_x, g_y):\n    place = board[s_x][s_y]\n    if place == 0:\n        return 'NG'\n    x, y = s_x, s_y\n    stack = []\n\n    while True:\n        # print(x, y)\n        board[x][y] = place + 1\n        if x + 1 < len(board) and board[x + 1][y] == place:\n            x += 1\n            stack.append((x, y))\n        elif y + 1 < len(board[x]) and board[x][y + 1] == place:\n            y += 1\n            stack.append((x, y))\n        elif x - 1 > 0 and board[x - 1][y] == place:\n            x -= 1\n            stack.append((x, y))\n        elif y - 1 > 0 and board[x][y - 1] == place:\n            y -= 1\n            stack.append((x, y))\n        else:\n            if len(stack) == 0 and board[x + 1][y] != place and board[x][y + 1] != place and board[x - 1][y] != place and board[x][y - 1] != place:\n                return 'NG'\n            (x, y) = stack.pop()\n\n        if x == g_x and y == g_y:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w)] for _ in range(h)]\n        s_x, s_y = map(int, input().split())\n        g_x, g_y = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, x, y = map(int, input().split())\n            block(board, x, y, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_y, s_x, g_y, g_x))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(100000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    directions=[[-1,0],[1,0],[0,-1],[0,1]]\n    [clx,cly]=cl\n    for dd in directions:\n        [i,j]=[clx+dd[0],cly+dd[1]]\n        if [i,j] in nc:\n            nc.remove([i,j])\n            ok.append([i,j])\n            tansaku([i,j],nc,ok,goal)\n \n \nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\""
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0207\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\n\ndef solve(w, h, xs, ys, xg, yg, blocks):\n    # ????????????????????±????????°???????????????l\n    field = [[0] * (w+1) for _ in range(h+1)]\n    for c, d, x, y in blocks:\n        field[y][x] = c\n        field[y][x+1] = c\n        field[y+1][x] = c\n        field[y+1][x+1] = c\n\n        if d == 0:              #  ?¨????\n            field[y][x+2] = c\n            field[y][x+3] = c\n            field[y+1][x+2] = c\n            field[y+1][x+3] = c\n        else:                   #  ??????\n            field[y+2][x] = c\n            field[y+3][x] = c\n            field[y+2][x+1] = c\n            field[y+3][x+1] = c\n\n    # ????????????????§????????????´????????§?¨??????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n\n    # ??????????????°???(S)??¨??´????????°???(G)?????????\n\n    d = [[float('inf')] * (w+1) for _ in range(h+1)] #  ??????????????°?????????????????¢???INF??§?????????\n    Q = deque()\n    Q.append((xs, ys))\n    d[ys][xs] = 0\n    color = field[ys][xs]\n\n    while Q:\n        xc, yc = Q.popleft()        #  ?????¨??°?????§?¨?\n        if xc == xg and yc == yg:\n            return 'OK'\n        for i in range(len(dx)):\n            xn = xc + dx[i]\n            yn = yc + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0 < xn <= w and 0 < yn <= h and d[yn][xn] == float('inf') and field[yn][xn] == color:\n                Q.append((xn, yn))\n                d[yn][xn] = d[yc][xc] + 1\n    return 'NG'\n\n\ndef main(args):\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        blocks = [list(map(int, input().split())) for _ in range(n)]\n\n        result = solve(w, h, xs, ys, xg, yg, blocks)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10000) \n\ndef tansaku(cl,nc,ok,goal): #currentlocation,nonchecked,ok,goal\n    directions=[[-1,0],[1,0],[0,-1],[0,1]]\n    [clx,cly]=cl\n    for dd in directions:\n        [i,j]=[clx+dd[0],cly+dd[1]]\n        if [i,j] in nc:\n            nc.remove([i,j])\n            ok.append([i,j])\n            tansaku([i,j],nc,ok,goal)\n \n \nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for i in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append([xx,yy])\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cl=[startx,starty]\n            nc=blist[c]\n            nc.remove(cl)\n            ok=[cl]\n            goal=[goalx,goaly]\n            tansaku(cl,nc,ok,goal)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\""
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 9/20/16. \"\"\"\n\n\ndef block(board, w, h, direction, color):\n    # horizontal.\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[h + i][w + j] = color\n    # vertical.\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[h + j][w + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_w, s_h, g_w, g_h):\n    place = board[s_h][s_w]\n    if place == 0:\n        return 'NG'\n    w, h = s_w, s_h\n    stack = []\n\n    while True:\n        board[h][w] = place + 1\n        if h + 1 < len(board) and board[h + 1][w] == place:\n            h += 1\n            stack.append((w, h))\n        elif w + 1 < len(board[h]) and board[h][w + 1] == place:\n            w += 1\n            stack.append((w, h))\n        elif h - 1 > 0 and board[h - 1][w] == place:\n            h -= 1\n            stack.append((w, h))\n        elif w - 1 > 0 and board[h][w - 1] == place:\n            w -= 1\n            stack.append((w, h))\n        else:\n            if len(stack) == 0 and board[h + 1][w] != place and board[h][w + 1] != place and board[h - 1][w] != place and board[h][w - 1] != place:\n                return 'NG'\n            (w, h) = stack.pop()\n\n        if w == g_w and h == g_h:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(110)] for _ in range(110)]\n        s_w, s_h = map(int, input().split())\n        g_w, g_h = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, w, h = map(int, input().split())\n            block(board, w, h, direction, color)\n\n        print_board(board)\n        print(go_maze(board, s_w, s_h, g_w, g_h))\n        print_board(board)\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nBLOCK_WIDTH = 4\nBLOCK_HEIGHT = 2\nfield = []\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\nw = 0\nh = 0\nxg = 0\nyg = 0\nstart_color = 0\n\ndef main():\n    global field, w, h, c, xg, yg, start_color\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        xs -= 1\n        ys -= 1\n        xg -= 1\n        yg -= 1\n        n = int(input())\n        field = [[0] * w for _ in range(h)]\n        for i in range(n):\n            c, d, x, y = map(int, input().split())\n            arrangement(c, d, x - 1, y - 1)\n\n        start_color = field[ys][xs]\n        if dfs(xs, ys):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\n\ndef arrangement(c, d, x, y):\n    if d == 0:\n        [[draw(x + j, y + i, c) for j in range(BLOCK_WIDTH)] for i in range(BLOCK_HEIGHT)]\n    else:\n        [[draw(x + j, y + i, c) for j in range(BLOCK_HEIGHT)] for i in range(BLOCK_WIDTH)]\n\n\ndef draw(x, y, c):\n    global field\n    field[y][x] = c\n\n\ndef dfs(x, y):\n    global field\n\n    if x == xg and y == yg:\n        return True\n    if start_color == 0:\n        return False\n    field[y][x] = 0\n    for i in range(4):\n        next_x = x + dx[i]\n        next_y = y + dy[i]\n        if next_x < 0 or next_x >= w or next_y < 0 or next_y >= h:\n            continue\n        if field[next_y][next_x] != start_color:\n            continue\n        if dfs(next_x, next_y):\n            return True\n\n    return False\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 9/20/16. \"\"\"\n\n\ndef block(board, w, h, direction, color):\n    # horizontal.\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[h + i][w + j] = color\n    # vertical.\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[h + j][w + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_w, s_h, g_w, g_h):\n    place = board[s_h][s_w]\n    if place == 0:\n        return 'NG'\n    w, h = s_w, s_h\n    stack = []\n\n    while True:\n        board[h][w] = place + 1\n        if board[h + 1][w] == place:\n            h += 1\n            stack.append((w, h))\n        elif board[h][w + 1] == place:\n            w += 1\n            stack.append((w, h))\n        elif board[h - 1][w] == place:\n            h -= 1\n            stack.append((w, h))\n        elif board[h][w - 1] == place:\n            w -= 1\n            stack.append((w, h))\n        else:\n            if len(stack) == 0 and board[h + 1][w] != place and board[h][w + 1] != place and board[h - 1][w] != place and board[h][w - 1] != place:\n                return 'NG'\n            (w, h) = stack.pop()\n\n        if w == g_w and h == g_h:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w)] for _ in range(h)]\n        s_w, s_h = map(int, input().split())\n        g_w, g_h = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, w, h = map(int, input().split())\n            block(board, w, h, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_w, s_h, g_w, g_h))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "global B\ndef check(B,x,y,c):\n\tif 0 < x < w+2 and 0 < y < h+2 and B[y][x] == c:\n\t\tB[y][x] = -1\n\t\tcheck(B,x-1,y,c);check(B,x,y-1,c);check(B,x+1,y,c);check(B,x,y+1,c)\n\nwhile 1:\n\tw,h = map(int,raw_input().split())\n\tif w == 0: break\n\tB = [[0]*(w+2) for i in range(h+2)]\n\txs,ys = map(int,raw_input().split())\n\txg,yg = map(int,raw_input().split())\n\tfor i in range(input()):\n\t\tc,d,x,y = map(int,raw_input().split())\n\t\tif d == 0:\n\t\t\tB[y][x:x+4] = [c]*4\n\t\t\tB[y+1][x:x+4] = [c]*4\n\t\telse:\n\t\t\tfor j in range(4):\n\t\t\t\tB[y+j][x:x+2] = [c]*2\n\tif B[ys][xs] != B[yg][xg]:\n\t\tprint \"NG\"\n\telse:\n\t\tcheck(B,xs,ys,B[ys][xs])\n\t\tprint \"OK\" if B[yg][xg] == -1 else \"NG\""
  },
  {
    "language": "Python",
    "code": "def dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y][x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny][nx] == m[y][x] and v[ny][nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nwhile True:\n    H, W = list(map(int, input().split()))\n    if H == 0 and W == 0:\n        break\n    xs, ys = list(map(lambda x: int(x)-1, input().split()))\n    xg, yg = list(map(lambda x: int(x)-1, input().split()))\n    n = int(input())\n    m = [[0 for _ in range(W)] for __ in range(H)]\n    v = [[False for _ in range(W)] for __ in range(H)]\n\n    for _ in range(n):\n        c, d, x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if d == 0:\n            for y in range(2):\n                for x in range(4):\n                    m[y][x] = c\n        else:\n            for y in range(4):\n                for x in range(2):\n                    m[y][x] = c\n\n    dfs(xs, ys, m, v, W, H, xg, yg)\n    if v[yg][xg]:\n        print('OK')\n    else:\n        print('NG')"
  },
  {
    "language": "Python",
    "code": "def block(board, y, x, direction, color):\n    # ???\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[x + i][y + j] = color\n    # ??±\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[x + j][y + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_x, s_y, g_x, g_y):\n    place = board[s_x][s_y]\n    if place == 0:\n        return 'NG'\n    x, y = s_x, s_y\n    stack = []\n\n    while True:\n        # print(x, y)\n        board[x][y] = place + 1\n        if x + 1 < len(board) and board[x + 1][y] == place:\n            x += 1\n            stack.append((x, y))\n        elif y + 1 < len(board[x]) and board[x][y + 1] == place:\n            y += 1\n            stack.append((x, y))\n        elif x - 1 > 0 and board[x - 1][y] == place:\n            x -= 1\n            stack.append((x, y))\n        elif y - 1 > 0 and board[x][y - 1] == place:\n            y -= 1\n            stack.append((x, y))\n        else:\n            if len(stack) == 0 and board[x + 1][y] != place and board[x][y + 1] != place and board[x - 1][y] != place and board[x][y - 1] != place:\n                return 'NG'\n            (x, y) = stack.pop()\n\n        if x == g_x and y == g_y:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w + 1)] for _ in range(h + 1)]\n        s_x, s_y = map(int, input().split())\n        g_x, g_y = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, x, y = map(int, input().split())\n            block(board, x, y, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_y, s_x, g_y, g_x))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "mv=((0,1),(0,-1),(1,0),(-1,0))\ndef dfs(y,x):\n    if color==0:\n        return False\n    if y==yg-1 and x==xg-1:\n        return True\n    L[y][x]=0\n    for i,j in mv:\n        mx=x+i\n        my=y+j\n        if 0<=mx<w and 0<=my<h and L[my][mx]==color:\n            if dfs(my,mx):\n                return True\n    return False\n\nwhile True:\n    w,h=map(int,raw_input().split())\n    if w==h==0:break\n    xs,ys=map(int,raw_input().split())\n    xg,yg=map(int,raw_input().split())\n    L=[[0]*w for i in range(h)]\n    n=input()\n    for i in range(n):\n        c,d,x,y=map(int,raw_input().split())\n        if d==0:\n            for j in range(2):\n                for k in range(4):\n                    L[y+j-1][x+k-1]=c\n        elif d==1:\n            for j in range(4):\n                for k in range(2):\n                    L[y+j-1][x+k-1]=c\n    color=L[ys-1][xs-1]\n    if dfs(ys-1,xs-1):\n        print \"OK\"\n    else:\n        print \"NG\""
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 9/20/16. \"\"\"\n\n\ndef block(board, w, h, direction, color):\n    # horizontal.\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[h + i][w + j] = color\n    # vertical.\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[h + j][w + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_w, s_h, g_w, g_h):\n    place = board[s_h][s_w]\n    if place == 0:\n        return 'NG'\n    w, h = s_w, s_h\n    stack = []\n\n    while True:\n        board[h][w] = place + 1\n        if h + 1 < len(board) and board[h + 1][w] == place:\n            h += 1\n            stack.append((w, h))\n        elif w + 1 < len(board[h]) and board[h][w + 1] == place:\n            w += 1\n            stack.append((w, h))\n        elif h - 1 > 0 and board[h - 1][w] == place:\n            h -= 1\n            stack.append((w, h))\n        elif w - 1 > 0 and board[h][w - 1] == place:\n            w -= 1\n            stack.append((w, h))\n        else:\n            if len(stack) == 0 and board[h + 1][w] != place and board[h][w + 1] != place and board[h - 1][w] != place and board[h][w - 1] != place:\n                return 'NG'\n            (w, h) = stack.pop()\n\n        if w == g_w and h == g_h:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(w)] for _ in range(h)]\n        s_w, s_h = map(int, input().split())\n        g_w, g_h = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, w, h = map(int, input().split())\n            block(board, w, h, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_w, s_h, g_w, g_h))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\nwhile True:\n    W, H = map(int, input().split())\n    if W == 0:\n        break\n    (xs, ys), (xg, yg) = map(int, input().split()), map(int, input().split())\n    square = [[0]*(W+2) for _ in [0]*(H+2)]\n    visited = [[0]*(W+2) for _ in [0]*(H+2)]\n    visited[ys][xs] = 1\n    N = int(input())\n    for c, d, from_x, from_y in (map(int, sys.stdin.readline().split()) for _ in [0]*N):\n        to_x, to_y = (from_x+4, from_y+2) if d == 0 else (from_x+2, from_y+4)\n        for y in range(from_y, to_y):\n            square[y][from_x:to_x] = [c]*(to_x-from_x)\n\n    color = square[ys][xs] or -1\n    dq = deque([(ys, xs)])\n    popleft, append = dq.popleft, dq.append\n    while dq:\n        y, x = popleft()\n        if y == yg and x == xg:\n            print(\"OK\")\n            break\n        for ny, nx in ((y+1, x), (y-1, x), (y, x+1), (y, x-1)):\n            if not visited[ny][nx] and square[ny][nx] == color:\n                visited[ny][nx] = 1\n                append((ny, nx))\n    else:\n        print(\"NG\")\n"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\nwhile True:\n\n\tN=101\n\tflag=0\n\tq=Queue()\n\tw,h=map(int,(raw_input().split()))\n\n\tif w+h==0:\n\t\tbreak\n\n\txs,ys=map(int,(raw_input().split()))\n\txg,yg=map(int,(raw_input().split()))\n\tn=int(raw_input())\n\n\tc=[]\n\td=[]\n\tx=[]\n\ty=[]\n\n\troot=[[0  for i in range(N)] for j in range(N)]\n\n\n\tdx=[0,0,1,1,2,2,3,3]\n\tdy=[0,1,0,1,0,1,0,1]\n\n\tddx=[1,0,-1,0]\n\tddy=[0,1,0,-1]\n\n\n\n\n\tfor i in range(n):\n\t\ta1,a2,a3,a4=map(int,(raw_input().split()))\n\t\tif a1==2:\n\t\t\tif a2==0:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dx[j]][a4+dy[j]]=1\n\t\t\t\t\t\n\n\t\t\telse:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dy[j]][a4+dx[j]]=1\n\t\t\t\t\t\n\n\t\telse:\n\t\t\tif a2==0:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dx[j]][a4+dy[j]]=0\n\n\t\t\telse:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dy[j]][a4+dx[j]]=0\n\n\troot[xg][yg]=2\n\n\n\tst=\"\"\n\tfor i in range(10):\n\t\tfor j in range(10):\n\t\t\tif i*j==0:continue\n\t\t\tif root[i][j]==1:\n\t\t\t\tst+=\"@\"\n\n\t\t\telif root[i][j]==2:\n\t\t\t\tst+=\"G\"\n\t\t\telse:\n\t\t\t\tst+=\".\"\n\t\tst+=\"\\n\"\n\n\n\t#print st\n\n\n\n\n\tr=[xs,ys]\n\tq.put(r)\n\t\n\twhile True:\n\t\tif q.empty():\n\t\t\tbreak\n\n\t\telse:\n\t\t\tr=q.get()\n\t\t\t#print r\n\t\t\tif r==[xg,yg]:\n\t\t\t\tflag=1\n\t\t\t\tbreak\n\t\t\tx=r[0]\n\t\t\ty=r[1]\n\t\t\troot[x][y]=0\n\t\t\tif 0<x and x<=xg and 0<y and y<=yg:\n\t\t\t\tfor i in range(4):\n\t\t\t\t\txx=x+ddx[i]\n\t\t\t\t\tyy=y+ddy[i]\n\n\t\t\t\t\t\n\t\t\t\t\t#print xx,yy,root[xx][yy]\n\t\t\t\t\tif root[xx][yy]>0:\n\t\t\t\t\t\tq.put([xx,yy])\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\tif flag==1:\n\t\tprint \"OK\"\n\telse:\n\t\tprint \"NG\""
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y, x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny, nx] == m[y, x] and v[ny, nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nwhile True:\n    H, W = list(map(int, input().split()))\n    if H == 0 and W == 0:\n        break\n    xs, ys = list(map(lambda x: int(x)-1, input().split()))\n    xg, yg = list(map(lambda x: int(x)-1, input().split()))\n    n = int(input())\n    m = np.array([[0 for _ in range(W)] for __ in range(H)])\n    v = np.array([[False for _ in range(W)] for __ in range(H)])\n\n    for _ in range(n):\n        c, d, x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if d == 0:\n            m[y:y+2, x:x+4] = c\n        else:\n            m[y:y+4, x:x+2] = c\n\n\n    dfs(xs, ys, m, v, W, H, xg, yg)\n    if v[yg, xg]:\n        print('OK')\n    else:\n        print('NG')"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y, x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny, nx] == m[y, x] and v[ny, nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nwhile True:\n    H, W = list(map(int, input().split()))\n    xs, ys = list(map(lambda x: int(x)-1, input().split()))\n    xg, yg = list(map(lambda x: int(x)-1, input().split()))\n    n = int(input())\n    m = np.array([[0 for _ in range(W)] for __ in range(H)])\n    v = np.array([[False for _ in range(W)] for __ in range(H)])\n\n    for _ in range(n):\n        c, d, x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if d == 0:\n            m[y:y+2, x:x+4] = c\n        else:\n            m[y:y+4, x:x+2] = c\n\n\n    dfs(xs, ys, m, v, W, H, xg, yg)\n    if v[yg, xg]:\n        print('OK')\n    else:\n        print('NG')\n\n    # print(m)\n    # print(v)"
  },
  {
    "language": "Python",
    "code": "\"\"\" Created by Jieyi on 9/20/16. \"\"\"\n\n\ndef block(board, w, h, direction, color):\n    # horizontal.\n    if direction == 0:\n        for i in range(2):\n            for j in range(4):\n                board[h + i][w + j] = color\n    # vertical.\n    elif direction == 1:\n        for i in range(2):\n            for j in range(4):\n                board[h + j][w + i] = color\n\n\ndef print_board(board):\n    for i in range(len(board)):\n        print(board[i])\n\n\ndef go_maze(board, s_w, s_h, g_w, g_h):\n    place = board[s_h][s_w]\n    if place == 0:\n        return 'NG'\n    w, h = s_w, s_h\n    stack = []\n\n    while True:\n        board[h][w] = place + 1\n        if h + 1 < len(board) and board[h + 1][w] == place:\n            h += 1\n            stack.append((w, h))\n        elif w + 1 < len(board[h]) and board[h][w + 1] == place:\n            w += 1\n            stack.append((w, h))\n        elif h - 1 > 0 and board[h - 1][w] == place:\n            h -= 1\n            stack.append((w, h))\n        elif w - 1 > 0 and board[h][w - 1] == place:\n            w -= 1\n            stack.append((w, h))\n        else:\n            if len(stack) == 0 and board[h + 1][w] != place and board[h][w + 1] != place and board[h - 1][w] != place and board[h][w - 1] != place:\n                return 'NG'\n            (w, h) = stack.pop()\n\n        if w == g_w and h == g_h:\n            return 'OK'\n\n\ndef main():\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n\n        board = [[0 for _ in range(110)] for _ in range(110)]\n        s_w, s_h = map(int, input().split())\n        g_w, g_h = map(int, input().split())\n        for _ in range(int(input())):\n            color, direction, w, h = map(int, input().split())\n            block(board, w, h, direction, color)\n\n        # print_board(board)\n        print(go_maze(board, s_w, s_h, g_w, g_h))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef search(xs, ys, xg, yg, board):  \n  direct = ((-1, 0), (1, 0), (0, -1), (0, 1))\n  visited = [[False] * (w + 2) for _ in range(h + 2)]\n  visited[ys][xs] = True\n  que = deque()\n  que.append((xs, ys))\n  while que:\n    x, y = que.popleft()\n    for dx, dy in direct:\n      nx, ny = x + dx, y + dy\n      if (nx, ny) == (xg, yg):\n        print(\"OK\")\n        return\n      if not visited[ny][nx]:\n        visited[ny][nx] = True\n        if board[ny][nx] == color:\n          que.append((nx, ny))\n  else:\n    print(\"NG\")\n\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n\n  xs, ys = map(int, input().split())\n  xg, yg = map(int, input().split())\n\n  board = [[0] * (w + 2) for _ in range(h + 2)]\n  n = int(input())\n  for _ in range(n):\n    c, d, x, y = map(int, input().split())\n    if d == 0:\n      for xi in range(x, x + 4):\n        for yi in range(y, y + 2):\n          board[yi][xi] = c\n    else:\n      for xi in range(x, x + 2):\n        for yi in range(y, y + 4):\n          board[yi][xi] = c\n  \n  color = board[ys][xs]\n  if color == 0 or board[yg][xg] != color:\n    print(\"NG\")\n    continue\n  \n  search(xs, ys, xg, yg, board)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nBlock = namedtuple('Block', ['color', 'direction', 'x', 'y'])\n\n\ndef occupation_point(block):\n    x, y = block.x, block.y\n    d = [(0, 0), (1, 0), (0, 1), (1, 1)]\n    for dx, dy in d:\n        yield x + dx, y + dy\n    if block.direction:\n        y += 2\n    else:\n        x += 2\n    for dx, dy in d:\n        yield x + dx, y + dy\n\ndef paintout(board, start, value):\n    color = board[start.y][start.x]\n    if color == 0:\n        return\n    que =[(start.x, start.y)]\n    while que:\n        x,y = que.pop()\n        if board[y][x] == color:\n            board[y][x] = value\n            que.extend([(x + dx, y + dy) for dx, dy in [(-1, 0), (0, -1), (1, 0), (0, 1)]])\n\n\ndef is_reachable(size, start, goal, blocks):\n    board = [[0] * (size.x + 2) for _ in range(size.y + 2)]\n    for bi in blocks:\n        for x, y in occupation_point(bi):\n            board[y][x] = bi.color\n    paintout(board, start, -1)\n    return board[goal.y][goal.x] == -1\n\n\nwhile True:\n    size = Point(*map(int, readline().split()))\n    if size.x == 0:\n        break\n    start = Point(*map(int, readline().split()))\n    goal = Point(*map(int, readline().split()))\n    blocks = []\n    for _ in range(int(readline())):\n        blocks.append(Block(*map(int, readline().split())))\n    print('OK' if is_reachable(size, start, goal, blocks) else 'NG')"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef dfs(x, y, m, v, W, H, xg, yg):\n    '''\n    '''\n    v[y, x] = True\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx = x + dx\n        ny = y + dy\n        if nx in range(W) and ny in range(H) and m[ny, nx] == m[y, x] and v[ny, nx] == False:\n            dfs(nx, ny, m, v, W, H, xg, yg)\n\nwhile True:\n    H, W = list(map(int, input().split()))\n    if H == 0 and W == 0:\n        break\n    xs, ys = list(map(lambda x: int(x)-1, input().split()))\n    xg, yg = list(map(lambda x: int(x)-1, input().split()))\n    n = int(input())\n    m = np.array([[0 for _ in range(W)] for __ in range(H)])\n    v = np.array([[False for _ in range(W)] for __ in range(H)])\n\n    for _ in range(n):\n        c, d, x, y = list(map(int, input().split()))\n        x -= 1\n        y -= 1\n        if d == 0:\n            m[y:y+2, x:x+4] = c\n        else:\n            m[y:y+4, x:x+2] = c\n\n\n    dfs(xs, ys, m, v, W, H, xg, yg)\n    if v[yg, xg]:\n        print('OK')\n    else:\n        print('NG')"
  },
  {
    "language": "Python",
    "code": "BLOCK_WIDTH = 4\nBLOCK_HEIGHT = 2\nfield = []\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\nw = 0\nh = 0\nxg = 0\nyg = 0\n\ndef main():\n    global field, w, h, xg, yg\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        field = [[0] * w for _ in range(h)]\n        for i in range(n):\n            c, d, x, y = map(int, input().split())\n            arrangement(c, d, x, y)\n\n        if dfs(field[ys][xs], xs, ys):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\n\ndef arrangement(c, d, x, y):\n    global field\n    if d == 0:\n        [[draw(x + j, y + i, c) for j in range(BLOCK_WIDTH)] for i in range(BLOCK_HEIGHT)]\n    else:\n        [[draw(x + j, y + i, c) for j in range(BLOCK_HEIGHT)] for i in range(BLOCK_WIDTH)]\n\n\ndef draw(x, y, c):\n    field[y][x] = c\n\n\ndef dfs(c, x, y):\n    global field\n\n    if x == xg and y == yg:\n        return True\n    field[y][x] = -1\n    for i in range(4):\n        next_x = x + dx[i]\n        next_y = y + dy[i]\n        if next_x < 0 or next_x >= w or next_y < 0 or next_y >= h:\n            continue\n        if field[next_y][next_x] == c:\n            if dfs(c, next_x, next_y):\n                return True\n\n    return False\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "\nfrom Queue import Queue\nwhile True:\n\n\tN=101\n\tflag=0\n\tq=Queue()\n\tw,h=map(int,(raw_input().split()))\n\n\tif w+h==0:\n\t\tbreak\n\n\txs,ys=map(int,(raw_input().split()))\n\txg,yg=map(int,(raw_input().split()))\n\tn=int(raw_input())\n\n\tc=[]\n\td=[]\n\tx=[]\n\ty=[]\n\n\troot=[[0  for i in range(N+1)] for j in range(N+1)]\n\n\n\tdx=[0,0,1,1,2,2,3,3]\n\tdy=[0,1,0,1,0,1,0,1]\n\n\tddx=[1,0,-1,0]\n\tddy=[0,1,0,-1]\n\n\n\n\n\tfor i in range(n):\n\t\ta1,a2,a3,a4=map(int,(raw_input().split()))\n\t\tif a1==2:\n\t\t\tif a2==0:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dx[j]][a4+dy[j]]=1\n\t\t\t\t\t\n\n\t\t\telse:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dy[j]][a4+dx[j]]=1\n\t\t\t\t\t\n\n\t\telse:\n\t\t\tif a2==0:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dx[j]][a4+dy[j]]=0\n\n\t\t\telse:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dy[j]][a4+dx[j]]=0\n\n\troot[xg][yg]=2\n\n\n\tst=\"\"\n\tfor i in range(10):\n\t\tfor j in range(10):\n\t\t\tif i*j==0:continue\n\t\t\tif root[i][j]==1:\n\t\t\t\tst+=\"@\"\n\n\t\t\telif root[i][j]==2:\n\t\t\t\tst+=\"G\"\n\t\t\telse:\n\t\t\t\tst+=\".\"\n\t\tst+=\"\\n\"\n\n\n\t#print st\n\n\n\n\n\tr=[xs,ys]\n\tq.put(r)\n\t\n\twhile True:\n\t\tif q.empty():\n\t\t\tbreak\n\n\t\telse:\n\t\t\tr=q.get()\n\t\t\t#print r\n\t\t\tif r==[xg,yg]:\n\t\t\t\tflag=1\n\t\t\t\tbreak\n\t\t\tx=r[0]\n\t\t\ty=r[1]\n\t\t\troot[x][y]=0\n\t\t\tif 0<x and x<=xg and 0<y and y<=yg:\n\t\t\t\tfor i in range(4):\n\t\t\t\t\txx=x+ddx[i]\n\t\t\t\t\tyy=y+ddy[i]\n\n\t\t\t\t\t\n\t\t\t\t\t#print xx,yy,root[xx][yy]\n\t\t\t\t\tif root[xx][yy]>0:\n\t\t\t\t\t\tq.put([xx,yy])\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\tif flag==1:\n\t\tprint \"OK\"\n\telse:\n\t\tprint \"NG\""
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\nwhile True:\n\n\tN=101\n\tflag=0\n\tq=Queue()\n\tw,h=map(int,(raw_input().split()))\n\n\tif w+h==0:\n\t\tbreak\n\n\txs,ys=map(int,(raw_input().split()))\n\txg,yg=map(int,(raw_input().split()))\n\tn=int(raw_input())\n\n\tc=[]\n\td=[]\n\tx=[]\n\ty=[]\n\n\troot=[[0  for i in range(N+10)] for j in range(N+10)]\n\n\n\tdx=[0,0,1,1,2,2,3,3]\n\tdy=[0,1,0,1,0,1,0,1]\n\n\tddx=[1,0,-1,0]\n\tddy=[0,1,0,-1]\n\n\n\n\n\tfor i in range(n):\n\t\ta1,a2,a3,a4=map(int,(raw_input().split()))\n\t\tif a1==2:\n\t\t\tif a2==0:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dx[j]][a4+dy[j]]=1\n\t\t\t\t\t\n\n\t\t\telse:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dy[j]][a4+dx[j]]=1\n\t\t\t\t\t\n\n\t\telse:\n\t\t\tif a2==0:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dx[j]][a4+dy[j]]=0\n\n\t\t\telse:\n\t\t\t\tfor j in range(8):\n\t\t\t\t\troot[a3+dy[j]][a4+dx[j]]=0\n\n\troot[xg][yg]=2\n\n\n\tst=\"\"\n\tfor i in range(10):\n\t\tfor j in range(10):\n\t\t\tif i*j==0:continue\n\t\t\tif root[i][j]==1:\n\t\t\t\tst+=\"@\"\n\n\t\t\telif root[i][j]==2:\n\t\t\t\tst+=\"G\"\n\t\t\telse:\n\t\t\t\tst+=\".\"\n\t\tst+=\"\\n\"\n\n\n\t#print st\n\n\n\n\n\tr=[xs,ys]\n\tq.put(r)\n\t\n\twhile True:\n\t\tif q.empty():\n\t\t\tbreak\n\n\t\telse:\n\t\t\tr=q.get()\n\t\t\t#print r\n\t\t\tif r==[xg,yg]:\n\t\t\t\tflag=1\n\t\t\t\tbreak\n\t\t\tx=r[0]\n\t\t\ty=r[1]\n\t\t\troot[x][y]=0\n\t\t\tif 0<x and x<=xg and 0<y and y<=yg:\n\t\t\t\tfor i in range(4):\n\t\t\t\t\txx=x+ddx[i]\n\t\t\t\t\tyy=y+ddy[i]\n\n\t\t\t\t\t\n\t\t\t\t\t#print xx,yy,root[xx][yy]\n\t\t\t\t\tif root[xx][yy]>0:\n\t\t\t\t\t\tq.put([xx,yy])\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\tif flag==1:\n\t\tprint \"OK\"\n\telse:\n\t\tprint \"NG\""
  },
  {
    "language": "Python",
    "code": "lx,ly = [4,2],[2,4]\ndx = [-1,0,1,0]\ndy = [0,-1,0,1]\nwhile 1:\n    w,h = map(int, raw_input().split())\n    if w==0 and h==0: break\n    xs,ys = map(int, raw_input().split())\n    xg,yg = map(int, raw_input().split())\n    f = [[0 for i in range(102)] for j in range(102)]\n    s = []\n    n = input()\n    for i in range(n):\n        c,d,x,y = map(int, raw_input().split())\n        for p in range(lx[d]):\n            for q in range(ly[d]):\n                f[y+q][x+p] = c\n    ans = 0\n    if f[ys][xs]>0 and f[ys][xs]==f[yg][xg]:\n        c = f[ys][xs]\n        s.append([xs,ys])\n        while len(s)>0:\n            x,y = s.pop()\n            if x==xg and y==yg:\n                ans = 1; break;\n            for k in range(4):\n                if f[y+dy[k]][x+dx[k]]==c:\n                    s.append([x+dx[k],y+dy[k]])\n                    f[y+dy[k]][x+dx[k]] = 0\n    print (\"OK\" if ans==1 else \"NG\")"
  },
  {
    "language": "Python",
    "code": "def searchsameid(nc,bid,biddict):\n    sameidpoints=[]\n    for point in nc:\n        if biddict[point]==bid:\n            sameidpoints.append(point)\n    for point in sameidpoints:\n            nc.remove(point)\n    return sameidpoints\n\ndef tansakub(cbid,nc,ok,biddict): #currentblockid,noncheckedpoints,okpoints\n    sameblockpoints=searchsameid(nc,cbid,biddict)\n    ok.extend(sameblockpoints)\n    for point in sameblockpoints:\n        (px,py)=point\n        for surpoint in [(px-1,py),(px+1,py),(px,py-1),(px,py+1)]:\n            if surpoint in nc:\n                newcbid=biddict[surpoint]\n                tansakub(newcbid,nc,ok,biddict)\n\nwhile(1):\n    [boardw,boardh]=[int(x) for x in raw_input().split()]\n    if boardw==0 and boardh==0:\n        break\n    else:\n        [startx,starty]=[int(x) for x in raw_input().split()]\n        [goalx,goaly]=[int(x) for x in raw_input().split()]\n        blockn=int(raw_input())\n        blist={1:[],2:[],3:[],4:[],5:[]}\n        biddict={}\n        startc=-1\n        goalc=-1\n        #mark location of block\n        for bid in range(blockn):\n            [c,d,x,y]=[int(x) for x in raw_input().split()]\n            if d: #d=1,tatenaga\n                for xx in range(x,x+2):\n                    for yy in range(y,y+4):\n                        blist[c].append((xx,yy))\n                        biddict[(xx,yy)]=bid\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                            sid=bid\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n                            gid=bid\n            else:\n                for xx in range(x,x+4):\n                    for yy in range(y,y+2):\n                        blist[c].append((xx,yy))\n                        biddict[(xx,yy)]=bid\n                        if [xx,yy]==[startx,starty]:\n                            startc=c\n                            sid=bid\n                        if [xx,yy]==[goalx,goaly]:\n                            goalc=c\n                            gid=bid\n        if startc==-1 or goalc==-1:\n            print \"NG\"\n        elif startc != goalc:\n            print \"NG\"\n        else:\n            #check if connected\n            cbid=sid\n            nc=blist[c]\n            ok=[]\n            goal=(goalx,goaly)\n            tansakub(cbid,nc,ok,biddict)\n            if goal in ok:\n                print \"OK\"\n            else:\n                print \"NG\""
  },
  {
    "language": "Python",
    "code": "BLOCK_WIDTH = 4\nBLOCK_HEIGHT = 2\nfield = []\ndx = [-1, 0, 1, 0]\ndy = [0, 1, 0, -1]\nw = 0\nh = 0\nxg = 0\nyg = 0\n\ndef main():\n    global field, w, h, xg, yg\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        field = [[0] * w for _ in range(h)]\n        for i in range(n):\n            c, d, x, y = map(int, input().split())\n            arrangement(c, d, x, y)\n\n        if dfs(field[ys][xs], xs, ys):\n            print(\"OK\")\n        else:\n            print(\"NG\")\n\n\ndef arrangement(c, d, x, y):\n    global field\n    if d == 0:\n        for i in range(BLOCK_HEIGHT):\n            for j in range(BLOCK_WIDTH):\n                field[y + i][x + j] = c\n    else:\n        for i in range(BLOCK_WIDTH):\n            for j in range(BLOCK_HEIGHT):\n                field[y + i][x + j] = c\n\n\ndef dfs(c, x, y):\n    global field\n\n    if x < 0 or x >= w or y < 0 or y >= h:\n        return False\n    if field[y][x] != c:\n        return False\n    if x == xg and y == yg:\n        return True\n    field[y][x] = -1\n    for i in range(4):\n        next_x = x + dx[i]\n        next_y = y + dy[i]\n        if dfs(c, next_x, next_y):\n            return True\n\n    return False\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "# ref: https://qiita.com/masashi127/items/0c794e28f4b295ad82c6\nimport heapq\nimport itertools\n\n\ndef astar(init_pos, goal,dg):\n    passed_list = [init_pos]\n    init_score = distance(passed_list) + heuristic(init_pos,goal)\n    checked = {init_pos: init_score}\n    searching_heap = []\n    heapq.heappush(searching_heap, (init_score, passed_list))\n    while len(searching_heap) > 0:\n        score, passed_list = heapq.heappop(searching_heap)\n        last_passed_pos = passed_list[-1]\n        if last_passed_pos == goal:\n            return passed_list\n        for pos in nexts(dg,last_passed_pos):\n            new_passed_list = passed_list + [pos]\n            pos_score = distance(new_passed_list) + heuristic(pos,goal)\n            if pos in checked and checked[pos] <= pos_score:\n                continue\n            checked[pos] = pos_score\n            heapq.heappush(searching_heap, (pos_score, new_passed_list))\n    return []\n\ndef solve_dungeon(dungeon):\n    init = find_ch(dungeon,\"S\")\n    goal = find_ch(dungeon,\"G\")\n    path = astar(init, goal,dungeon)\n\n    if len(path) > 0:\n        return True\n    else:\n        return False\n\ndef find_ch(dg,ch):\n    for i, l in enumerate(dg):\n        for j, c in enumerate(l):\n            if c == ch:\n                return (i, j)\n\ndef nexts(dg,pos):\n    wall = \"x\"\n    for a, b in [[' + 1',''], [' - 1',''], ['',' + 1'], ['',' - 1']]:\n        if a or b:\n            if dg[eval('pos[0]' + a)][eval('pos[1]' + b)] != wall:\n                yield (eval('pos[0]' + a), eval('pos[1]' + b))\n\ndef heuristic(pos,goal):\n    return ((pos[0] - goal[0]) ** 2 + (pos[1] - goal[1]) ** 2) ** 0.5\n\ndef distance(path):\n    return len(path)\n\ndef render_path(dg,path):\n    buf = [[ch for ch in l] for l in dg]\n\n    for pos in path[1:-1]:\n        buf[pos[0]][pos[1]] = \"*\"\n\n    buf[path[0][0]][path[0][1]] = \"s\"\n    buf[path[-1][0]][path[-1][1]] = \"g\"\n    return [\"\".join(l) for l in buf]\n\nif __name__ == \"__main__\":\n    while(True):\n        w,h = map(int,input().split())\n        if w == 0 and h == 0:\n            break\n        xs,ys = map(int,input().split())\n        xg,yg = map(int,input().split())\n        n = int(input())\n        d = [ list(map(int,input().split())) for _ in range(n)]\n        m = [[0]*w for _ in range(h)]\n        for e in d:\n            for r in m[e[3]-1:e[3]+2*(e[1]+1)-1]:\n                r[e[2]-1:e[2]+2*(2-e[1])-1] = [e[0]]*2*(2-e[1])\n        ans = False\n        for col in range(1,6):\n            txt = [''.join(str(' ' if e==col else 'x') for e in f)  for f in m]\n            if txt[ys-1][xs-1] == \"x\" or txt[yg-1][xg-1] == \"x\":\n                continue\n            txt[ys-1] = txt[ys-1][:xs-1] + 'S' + txt[ys-1][xs:]\n            txt[yg-1] = txt[yg-1][:xg-1] + 'G' + txt[yg-1][xg:]\n            for i in range(len(txt)):\n                txt[i] = 'x' + txt[i] + 'x'\n            txt.insert(0,'x'*(w+2))\n            txt.append('x'*(w+2))\n            ans |= solve_dungeon(txt)\n            if ans:\n                print(\"OK\")\n                break\n        if not ans: print(\"NG\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0207\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\n\ndef solve(w, h, xs, ys, xg, yg, blocks):\n    # ????????????????????±????????°???????????????l\n    field = [[0] * (w+1) for _ in range(h+1)]\n    for c, d, x, y in blocks:\n        field[y][x] = c\n        field[y][x+1] = c\n        field[y+1][x] = c\n        field[y+1][x+1] = c\n\n        if d == 0:              #  ?¨????\n            field[y][x+2] = c\n            field[y][x+3] = c\n            field[y+1][x+2] = c\n            field[y+1][x+3] = c\n        else:                   #  ??????\n            field[y+2][x] = c\n            field[y+3][x] = c\n            field[y+2][x+1] = c\n            field[y+3][x+1] = c\n\n    # ????????????????§????????????´????????§?¨??????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n\n    d = [[-1] * (w+1) for _ in range(h+1)] #  ?????¢?´¢?????°??¨???????????¨??????-1???\n    Q = deque()\n    Q.append((xs, ys))\n    d[ys][xs] = 0\n    color = field[ys][xs]       #  ?????????????????¨?????§?????????????????????????????°?????¨???????????????\n\n    while Q:\n        xc, yc = Q.popleft()        #  ?????¨??°?????§?¨?\n        if xc == xg and yc == yg:\n            return 'OK'\n        for i in range(len(dx)):\n            xn = xc + dx[i]\n            yn = yc + dy[i]\n            #  ?§????????????§???????????? ?????? ??¢?????¢?´¢?????§???????????°??????????????§?????¢?´¢????¶???????\n            if 0 < xn <= w and 0 < yn <= h and d[yn][xn] == -1 and field[yn][xn] == color:\n                Q.append((xn, yn))\n                d[yn][xn] = d[yc][xc] + 1\n    return 'NG'\n\n\ndef main(args):\n    while True:\n        w, h = map(int, input().split())\n        if w == 0 and h == 0:\n            break\n        xs, ys = map(int, input().split())\n        xg, yg = map(int, input().split())\n        n = int(input())\n        blocks = [list(map(int, input().split())) for _ in range(n)]\n\n        result = solve(w, h, xs, ys, xg, yg, blocks)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "def solve(x, y, flag):\n\tif y == yf and x == xf or y == yh and x == xh:\n\t\tMap[y][x] = \"tintin\"\n\tif x < 0 or x >= w or y < 0 or y >= h or Map[y][x] != flag: return\n\tMap[y][x] = \"tintin\"\n\tsolve(x + 1, y,flag)\n\tsolve(x - 1, y,flag)\n\tsolve(x, y + 1,flag)\n\tsolve(x, y - 1,flag)\n\t\n\nwhile True:\n\tw, h = map(int, raw_input().split())\n\tif w == 0 and h == 0 : break\n\n\tMap = [list(\"0\" * w) for _ in range(h)]\n\t\n\txf, yf = map(int, raw_input().split())\n\tMap[yf - 1][xf - 1] = \"flag\"\n\t\n\txh, yh = map(int, raw_input().split())\n\tMap[yh - 1][xh - 1] = \"flag\"\n\t\n\tn = input()\n\tfor i in range(n):\n\t\tc,d,x,y = map(int, raw_input().split())\n\t\tif d == 0 :\n\t\t\tfor xc in range(4):\n\t\t\t\tfor yc in range(2):\n\t\t\t\t\tif Map[y - 1 + yc][x - 1 + xc] == \"flag\" or Map[y - 1 + yc][x - 1 + xc] == \"flag\": \n\t\t\t\t\t\tMap[y - 1 + yc][x - 1 + xc] = \"flag\" + str(c)\n\t\t\t\t\telse : Map[y - 1 + yc][x - 1 + xc] = c\n\t\telif d == 1:\n\t\t\tfor xc in range(2):\n\t\t\t\tfor yc in range(4):\n\t\t\t\t\tif Map[y - 1 + yc][x - 1 + xc] == \"flag\" or Map[y - 1 + yc][x - 1 + xc] == \"flag\": \n\t\t\t\t\t\tMap[y - 1 + yc][x - 1 + xc] = \"flag\" + str(c)\n\t\t\t\t\telse : Map[y - 1 + yc][x - 1 + xc] = c\n\t\t\t\t\t\n\tif Map[yf - 1][xf - 1] == Map[yh - 1][xh - 1]:\n\t\tflag = int(Map[yf - 1][xf - 1][4:])\n\t\tsolve(xf - 1, yf - 1, flag)\n\t\tif Map[yf - 1][xf - 1] == Map[yh - 1][xh - 1]:\n\t\t\tprint \"OK\"\n\t\telse:\n\t\t\tprint \"NG\"\n\telse:\n\t\tprint \"NG\""
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\nuse std::collections::HashSet;\n\nfn main(){\n  loop {\n    let wh: Vec<usize> = read_vec();\n    let w = wh[0];\n    let h = wh[1];\n    \n    if w == 0 && h == 0 { break; }\n\n    let xys: Vec<usize> = read_vec();\n    let sp: (usize, usize) = (xys[0]-1, xys[1]-1);\n    let xyg: Vec<usize> = read_vec();\n    let gp: (usize, usize) = (xyg[0]-1, xyg[1]-1);\n    let n: usize = read();\n\n    let mut fv:Vec<Vec<usize>> = vec![vec![0;w];h];\n\n    for _ in 0 .. n {\n      let cdxy: Vec<usize> = read_vec();\n      let c = cdxy[0];\n      let d = cdxy[1];\n      let x = cdxy[2] - 1;\n      let y = cdxy[3] - 1;\n\n      if d == 0 {\n        fv[y][x] = c;\n        fv[y][x+1] = c;\n        fv[y][x+2] = c;\n        fv[y][x+3] = c;\n        fv[y+1][x] = c;\n        fv[y+1][x+1] = c;\n        fv[y+1][x+2] = c;\n        fv[y+1][x+3] = c;\n      } else {\n        fv[y][x] = c;\n        fv[y][x+1] = c;\n        fv[y+1][x] = c;\n        fv[y+1][x+1] = c;\n        fv[y+2][x] = c;\n        fv[y+2][x+1] = c;\n        fv[y+3][x] = c;\n        fv[y+3][x+1] = c;\n      }\n    }\n\n    let sc: usize = fv[sp.1][sp.0];\n    let gc: usize = fv[gp.1][gp.0];\n\n    let mut ans: &str = \"NG\";\n    \n    if sc != 0 && gc != 0 && sc == gc {\n      let mut que: VecDeque<(usize, usize)> = VecDeque::new();\n      let mut hs: HashSet<(usize, usize)> = HashSet::new();\n      \n      que.push_back(sp);\n      hs.insert(sp);\n      \n      \n      loop {\n        match que.pop_front() {\n          None => { break; },\n          Some((bx, by)) => {\n            if gp == (bx, by) {\n              ans = \"OK\";\n              break;\n            }\n      \n            if bx + 1 < w && fv[by][bx+1] == sc && !hs.contains(&(bx+1, by)) {\n              que.push_back((bx+1, by));\n              hs.insert((bx+1, by));\n            }\n            if bx > 0 && fv[by][bx-1] == sc && !hs.contains(&(bx-1, by)) {\n              que.push_back((bx-1, by));\n              hs.insert((bx-1, by));\n            }\n            if by + 1 < h && fv[by+1][bx] == sc && !hs.contains(&(bx, by+1)) {\n              que.push_back((bx, by+1));\n              hs.insert((bx, by+1));\n            }\n            if by > 0 && fv[by-1][bx] == sc && !hs.contains(&(bx, by-1)) {\n              que.push_back((bx, by-1));\n              hs.insert((bx, by-1));\n            }\n          },\n        }\n      }\n    }\n    println!(\"{}\", ans);\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]