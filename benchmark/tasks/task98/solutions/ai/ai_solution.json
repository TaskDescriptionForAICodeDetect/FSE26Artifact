[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y, color, orientation;\n} Block;\n\nint w, h, n;\nBlock blocks[100];\nint start_x, start_y, goal_x, goal_y;\nint board[101][101];\nbool visited[101][101];\n\nbool dfs(int x, int y, int color) {\n    if (x == goal_x && y == goal_y) {\n        return true;\n    }\n    if (x < 1 || x > w || y < 1 || y > h || board[x][y] != color || visited[x][y]) {\n        return false;\n    }\n    visited[x][y] = true;\n    if (dfs(x + 1, y, color)) return true;\n    if (dfs(x - 1, y, color)) return true;\n    if (dfs(x, y + 1, color)) return true;\n    if (dfs(x, y - 1, color)) return true;\n    return false;\n}\n\nvoid fill_block(int x, int y, int color, int orientation) {\n    if (orientation == 0) {\n        for (int i = x; i < x + 4; ++i) {\n            for (int j = y; j < y + 2; ++j) {\n                board[i][j] = color;\n            }\n        }\n    } else {\n        for (int i = x; i < x + 2; ++i) {\n            for (int j = y; j < y + 4; ++j) {\n                board[i][j] = color;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &w, &h);\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", &blocks[i].x, &blocks[i].y, &blocks[i].color, &blocks[i].orientation);\n        fill_block(blocks[i].x, blocks[i].y, blocks[i].color, blocks[i].orientation);\n    }\n    scanf(\"%d %d %d %d\", &start_x, &start_y, &goal_x, &goal_y);\n\n    if (board[start_x][start_y] == 0 || board[goal_x][goal_y] == 0 || \n        board[start_x][start_y] != board[goal_x][goal_y]) {\n        printf(\"NG\\n\");\n        return 0;\n    }\n\n    for (int i = 1; i <= w; ++i) {\n        for (int j = 1; j <= h; ++j) {\n            visited[i][j] = false;\n        }\n    }\n\n    if (dfs(start_x, start_y, board[start_x][start_y])) {\n        printf(\"OK\\n\");\n    } else {\n        printf(\"NG\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BlockMaze {\n    static class Block {\n        int x, y, color, orientation;\n        \n        Block(int x, int y, int color, int orientation) {\n            this.x = x;\n            this.y = y;\n            this.color = color;\n            this.orientation = orientation;\n        }\n    }\n    \n    public static String checkMaze(int w, int h, List<Block> blocks, int[] start, int[] goal) {\n        int[][] board = new int[h + 1][w + 1];\n        \n        // Place blocks on board\n        for (Block block : blocks) {\n            if (block.orientation == 0) {  // Horizontal\n                for (int dx = 0; dx < 4; dx++) {\n                    board[block.y][block.x + dx] = block.color;\n                }\n            } else {  // Vertical\n                for (int dy = 0; dy < 4; dy++) {\n                    board[block.y + dy][block.x] = block.color;\n                }\n            }\n        }\n        \n        // Check if start and goal are valid\n        if (board[start[1]][start[0]] == 0 || board[goal[1]][goal[0]] == 0) {\n            return \"NG\";\n        }\n        \n        int startColor = board[start[1]][start[0]];\n        if (startColor != board[goal[1]][goal[0]]) {\n            return \"NG\";\n        }\n        \n        // BFS to find path\n        boolean[][] visited = new boolean[h + 1][w + 1];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(start);\n        visited[start[1]][start[0]] = true;\n        \n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            \n            if (current[0] == goal[0] && current[1] == goal[1]) {\n                return \"OK\";\n            }\n            \n            for (int[] dir : directions) {\n                int nx = current[0] + dir[0];\n                int ny = current[1] + dir[1];\n                \n                if (nx >= 1 && nx <= w && ny >= 1 && ny <= h && \n                    board[ny][nx] == startColor && !visited[ny][nx]) {\n                    queue.offer(new int[]{nx, ny});\n                    visited[ny][nx] = true;\n                }\n            }\n        }\n        \n        return \"NG\";\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int w = scanner.nextInt();\n        int h = scanner.nextInt();\n        int n = scanner.nextInt();\n        \n        List<Block> blocks = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int color = scanner.nextInt();\n            int orientation = scanner.nextInt();\n            blocks.add(new Block(x, y, color, orientation));\n        }\n        \n        int[] start = new int[]{scanner.nextInt(), scanner.nextInt()};\n        int[] goal = new int[]{scanner.nextInt(), scanner.nextInt()};\n        \n        String result = checkMaze(w, h, blocks, start, goal);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:36:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nstruct Block {\n    int x, y, color, orientation;\n};\n\nint w, h;\nint grid[101][101]; // Assuming max size is 100x100\nbool visited[101][101];\n\nbool isSameColorConnected(int startX, int startY, int goalX, int goalY, int color) {\n    if (grid[startX][startY] != color || grid[goalX][goalY] != color) {\n        return false;\n    }\n    \n    memset(visited, false, sizeof(visited));\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startX][startY] = true;\n    \n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        int x = current.first;\n        int y = current.second;\n        \n        if (x == goalX && y == goalY) {\n            return true;\n        }\n        \n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (nx >= 1 && nx <= w && ny >= 1 && ny <= h && !visited[nx][ny] && grid[nx][ny] == color) {\n                visited[nx][ny] = true;\n                q.push({nx, ny});\n            }\n        }\n    }\n    \n    return false;\n}\n\nvoid fillGrid(int x, int y, int color, int orientation) {\n    if (orientation == 0) { // horizontal\n        for (int i = x; i < x + 4; ++i) {\n            for (int j = y; j < y + 2; ++j) {\n                grid[i][j] = color;\n            }\n        }\n    } else { // vertical\n        for (int i = x; i < x + 2; ++i) {\n            for (int j = y; j < y + 4; ++j) {\n                grid[i][j] = color;\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> w >> h >> n;\n    \n    vector<Block> blocks(n);\n    memset(grid, 0, sizeof(grid));\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> blocks[i].x >> blocks[i].y >> blocks[i].color >> blocks[i].orientation;\n        fillGrid(blocks[i].x, blocks[i].y, blocks[i].color, blocks[i].orientation);\n    }\n    \n    int startX, startY, goalX, goalY;\n    cin >> startX >> startY >> goalX >> goalY;\n    \n    if (grid[startX][startY] == 0 || grid[goalX][goalY] == 0) {\n        cout << \"NG\" << endl;\n        return 0;\n    }\n    \n    int color = grid[startX][startY];\n    \n    if (isSameColorConnected(startX, startY, goalX, goalY, color)) {\n        cout << \"OK\" << endl;\n    } else {\n        cout << \"NG\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_BLOCKS 50\n#define MAX_BOARD_SIZE 20\n\ntypedef struct {\n    int x, y, color, orientation;\n} Block;\n\nint w, h, n;\nBlock blocks[MAX_BLOCKS];\nbool visited[MAX_BOARD_SIZE][MAX_BOARD_SIZE];\nint board[MAX_BOARD_SIZE][MAX_BOARD_SIZE];\n\nbool is_valid_coordinate(int x, int y) {\n    return x >= 1 && x <= w && y >= 1 && y <= h;\n}\n\nvoid mark_block_on_board(Block block) {\n    if (block.orientation == 0) {\n        for (int i = 0; i < 4; i++) {\n            board[block.y][block.x + i] = block.color;\n        }\n    } else {\n        for (int i = 0; i < 2; i++) {\n            board[block.y + i][block.x] = block.color;\n        }\n    }\n}\n\nvoid dfs(int x, int y, int color) {\n    if (!is_valid_coordinate(x, y) || \n        board[y][x] != color || \n        visited[y][x]) {\n        return;\n    }\n\n    visited[y][x] = true;\n\n    dfs(x + 1, y, color);\n    dfs(x - 1, y, color);\n    dfs(x, y + 1, color);\n    dfs(x, y - 1, color);\n}\n\nbool is_maze_path(int start_x, int start_y, int goal_x, int goal_y) {\n    memset(visited, 0, sizeof(visited));\n    int color = board[start_y][start_x];\n\n    if (color != board[goal_y][goal_x]) {\n        return false;\n    }\n\n    dfs(start_x, start_y, color);\n    return visited[goal_y][goal_x];\n}\n\nint main() {\n    scanf(\"%d %d %d\", &w, &h, &n);\n\n    memset(board, 0, sizeof(board));\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &blocks[i].x, &blocks[i].y, &blocks[i].color, &blocks[i].orientation);\n        mark_block_on_board(blocks[i]);\n    }\n\n    int start_x, start_y, goal_x, goal_y;\n    scanf(\"%d %d %d %d\", &start_x, &start_y, &goal_x, &goal_y);\n\n    printf(\"%s\\n\", is_maze_path(start_x, start_y, goal_x, goal_y) ? \"OK\" : \"NG\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Block {\n    int x, y, color, orientation;\n};\n\nbool is_valid(int x, int y, int w, int h) {\n    return x >= 1 && x <= w && y >= 1 && y <= h;\n}\n\nbool can_move(const Block& b1, const Block& b2) {\n    return b1.color == b2.color;\n}\n\nbool find_path(vector<Block>& blocks, int w, int h, int start_x, int start_y, int goal_x, int goal_y) {\n    vector<vector<bool>> visited(h + 1, vector<bool>(w + 1, false));\n    queue<pair<int, int>> q;\n    q.push({start_x, start_y});\n    visited[start_y][start_x] = true;\n\n    vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    while (!q.empty()) {\n        int curr_x = q.front().first;\n        int curr_y = q.front().second;\n        q.pop();\n\n        if (curr_x == goal_x && curr_y == goal_y) return true;\n\n        for (auto& dir : directions) {\n            int next_x = curr_x + dir.first;\n            int next_y = curr_y + dir.second;\n\n            if (!is_valid(next_x, next_y, w, h) || visited[next_y][next_x]) continue;\n\n            for (auto& block : blocks) {\n                bool can_traverse = false;\n                if (block.orientation == 0) { // horizontal\n                    if (block.x <= next_x && next_x < block.x + 4 && block.y == next_y) can_traverse = true;\n                } else { // vertical\n                    if (block.x == next_x && block.y <= next_y && next_y < block.y + 4) can_traverse = true;\n                }\n\n                if (can_traverse) {\n                    q.push({next_x, next_y});\n                    visited[next_y][next_x] = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int w, h, n, start_x, start_y, goal_x, goal_y;\n    cin >> w >> h >> n >> start_x >> start_y >> goal_x >> goal_y;\n\n    vector<Block> blocks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> blocks[i].x >> blocks[i].y >> blocks[i].color >> blocks[i].orientation;\n    }\n\n    cout << (find_path(blocks, w, h, start_x, start_y, goal_x, goal_y) ? \"OK\" : \"NG\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MazeChecker {\n    static int w, h;\n    static int[][] board;\n    static int startX, startY, goalX, goalY;\n    static boolean[][] visited;\n    static int[] dx = { -1, 1, 0, 0 };\n    static int[] dy = { 0, 0, -1, 1 };\n\n    static class Block {\n        int x, y, color, orientation;\n        Block(int x, int y, int color, int orientation) {\n            this.x = x;\n            this.y = y;\n            this.color = color;\n            this.orientation = orientation;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        w = sc.nextInt();\n        h = sc.nextInt();\n        int n = sc.nextInt();\n        List<Block> blocks = new ArrayList<>();\n        board = new int[w + 1][h + 1];\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n            int color = sc.nextInt();\n            int orientation = sc.nextInt();\n            blocks.add(new Block(x, y, color, orientation));\n            if (orientation == 0) {\n                for (int dx = 0; dx < 4; dx++) {\n                    for (int dy = 0; dy < 2; dy++) {\n                        if (x + dx <= w && y + dy <= h) {\n                            board[x + dx][y + dy] = color;\n                        }\n                    }\n                }\n            } else {\n                for (int dx = 0; dx < 2; dx++) {\n                    for (int dy = 0; dy < 4; dy++) {\n                        if (x + dx <= w && y + dy <= h) {\n                            board[x + dx][y + dy] = color;\n                        }\n                    }\n                }\n            }\n        }\n        startX = sc.nextInt();\n        startY = sc.nextInt();\n        goalX = sc.nextInt();\n        goalY = sc.nextInt();\n\n        if (board[startX][startY] == 0 || board[goalX][goalY] == 0 || \n            board[startX][startY] != board[goalX][goalY]) {\n            System.out.println(\"NG\");\n            return;\n        }\n\n        visited = new boolean[w + 1][h + 1];\n        int targetColor = board[startX][startY];\n        boolean canReach = dfs(startX, startY, targetColor);\n\n        System.out.println(canReach ? \"OK\" : \"NG\");\n    }\n\n    static boolean dfs(int x, int y, int targetColor) {\n        if (x == goalX && y == goalY) {\n            return true;\n        }\n        visited[x][y] = true;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 1 && nx <= w && ny >= 1 && ny <= h && \n                !visited[nx][ny] && board[nx][ny] == targetColor) {\n                if (dfs(nx, ny, targetColor)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 18:37:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef in_bounds(x, y, w, h):\n    return 1 <= x <= w and 1 <= y <= h\n\ndef is_valid_move(x, y, color, visited, board, w, h):\n    return in_bounds(x, y, w, h) and not visited[y][x] and board[y][x] == color\n\ndef bfs(start, goal, board, w, h):\n    queue = deque([start])\n    visited = [[False] * (w + 1) for _ in range(h + 1)]\n    start_x, start_y = start\n    goal_x, goal_y = goal\n    color = board[start_y][start_x]\n    visited[start_y][start_x] = True\n\n    while queue:\n        x, y = queue.popleft()\n        if (x, y) == goal:\n            return True\n\n        # Check all four possible directions\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid_move(nx, ny, color, visited, board, w, h):\n                visited[ny][nx] = True\n                queue.append((nx, ny))\n\n    return False\n\ndef create_board(w, h, blocks):\n    board = [[0] * (w + 1) for _ in range(h + 1)]\n    for x, y, orientation, color in blocks:\n        if orientation == 0:  # horizontal\n            for i in range(2):\n                for j in range(4):\n                    board[y + i][x + j] = color\n        else:  # vertical\n            for i in range(4):\n                for j in range(2):\n                    board[y + i][x + j] = color\n    return board\n\ndef solve_maze(w, h, blocks, start, goal):\n    board = create_board(w, h, blocks)\n    return 'OK' if bfs(start, goal, board, w, h) else 'NG'\n\n# Example usage:\nif __name__ == \"__main__\":\n    w, h = 8, 4  # board size\n    blocks = [(1, 1, 0, 1), (3, 3, 1, 1)]  # list of blocks: (x, y, orientation, color)\n    start = (1, 1)  # start coordinates\n    goal = (4, 4)  # goal coordinates\n    print(solve_maze(w, h, blocks, start, goal))  # Output: 'OK' or 'NG'",
    "timestamp": "2025-08-13 00:07:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass Block {\n    int x, y, color, orientation;\n\n    Block(int x, int y, int color, int orientation) {\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.orientation = orientation;\n    }\n\n    Set<Point> getPoints() {\n        Set<Point> points = new HashSet<>();\n        if (orientation == 0) { // Horizontal\n            for (int dx = 0; dx < 4; dx++) {\n                for (int dy = 0; dy < 2; dy++) {\n                    points.add(new Point(x + dx, y + dy));\n                }\n            }\n        } else { // Vertical\n            for (int dx = 0; dx < 2; dx++) {\n                for (int dy = 0; dy < 4; dy++) {\n                    points.add(new Point(x + dx, y + dy));\n                }\n            }\n        }\n        return points;\n    }\n}\n\nclass Point {\n    int x, y;\n\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (!(obj instanceof Point)) return false;\n        Point other = (Point) obj;\n        return this.x == other.x && this.y == other.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}\n\npublic class Maze {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int w = scanner.nextInt();\n        int h = scanner.nextInt();\n        int blockCount = scanner.nextInt();\n\n        List<Block> blocks = new ArrayList<>();\n        for (int i = 0; i < blockCount; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            int color = scanner.nextInt();\n            int orientation = scanner.nextInt();\n            blocks.add(new Block(x, y, color, orientation));\n        }\n\n        int startX = scanner.nextInt();\n        int startY = scanner.nextInt();\n        int goalX = scanner.nextInt();\n        int goalY = scanner.nextInt();\n\n        scanner.close();\n\n        Map<Point, Integer> pointColorMap = new HashMap<>();\n\n        for (Block block : blocks) {\n            for (Point point : block.getPoints()) {\n                pointColorMap.put(point, block.color);\n            }\n        }\n\n        Point start = new Point(startX, startY);\n        Point goal = new Point(goalX, goalY);\n\n        if (!pointColorMap.containsKey(start) || !pointColorMap.containsKey(goal)) {\n            System.out.println(\"NG\");\n            return;\n        }\n\n        int startColor = pointColorMap.get(start);\n        int goalColor = pointColorMap.get(goal);\n\n        if (startColor != goalColor) {\n            System.out.println(\"NG\");\n            return;\n        }\n\n        Set<Point> visited = new HashSet<>();\n        Queue<Point> queue = new LinkedList<>();\n        queue.add(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n            if (current.equals(goal)) {\n                System.out.println(\"OK\");\n                return;\n            }\n\n            for (Point neighbor : getNeighbors(current)) {\n                if (!visited.contains(neighbor) && pointColorMap.getOrDefault(neighbor, -1) == startColor) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n\n        System.out.println(\"NG\");\n    }\n\n    private static List<Point> getNeighbors(Point point) {\n        List<Point> neighbors = new ArrayList<>();\n        neighbors.add(new Point(point.x + 1, point.y));\n        neighbors.add(new Point(point.x - 1, point.y));\n        neighbors.add(new Point(point.x, point.y + 1));\n        neighbors.add(new Point(point.x, point.y - 1));\n        return neighbors;\n    }\n}",
    "timestamp": "2025-08-13 00:08:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_W 100\n#define MAX_H 100\n\nint width, height;\nint startX, startY, goalX, goalY;\nint board[MAX_H][MAX_W];\n\ntypedef struct {\n    int x, y, color, orientation;\n} Block;\n\nvoid placeBlock(Block block) {\n    int dx[] = {0, 1, 0, 1};\n    int dy[] = {0, 0, 1, 1};\n    if (block.orientation == 0) { // horizontal\n        for (int i = 0; i < 4; i++) {\n            board[block.y][block.x + i] = block.color;\n            board[block.y + 1][block.x + i] = block.color;\n        }\n    } else { // vertical\n        for (int i = 0; i < 4; i++) {\n            board[block.y + i][block.x] = block.color;\n            board[block.y + i][block.x + 1] = block.color;\n        }\n    }\n}\n\nbool isInside(int x, int y) {\n    return x >= 0 && x < width && y >= 0 && y < height;\n}\n\nbool dfs(int x, int y, int color, bool visited[MAX_H][MAX_W]) {\n    if (x == goalX && y == goalY) return true;\n    visited[y][x] = true;\n\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dirs[i][0];\n        int ny = y + dirs[i][1];\n        if (isInside(nx, ny) && !visited[ny][nx] && board[ny][nx] == color) {\n            if (dfs(nx, ny, color, visited)) return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d %d\", &width, &height);\n    scanf(\"%d %d\", &startX, &startY);\n    scanf(\"%d %d\", &goalX, &goalY);\n    startX--; startY--; goalX--; goalY--; // zero-indexing\n\n    memset(board, 0, sizeof(board));\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        Block block;\n        scanf(\"%d %d %d %d %d\", &block.x, &block.y, &block.color, &block.x, &block.orientation);\n        block.x--; block.y--; // zero-index for placement\n        placeBlock(block);\n    }\n\n    bool visited[MAX_H][MAX_W] = {false};\n    if (dfs(startX, startY, board[startY][startX], visited)) {\n        printf(\"OK\\n\");\n    } else {\n        printf(\"NG\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 00:08:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_valid_maze(w, h, blocks, start, goal):\n    def can_reach(color):\n        visited = [[False] * (w + 1) for _ in range(h + 1)]\n        \n        def dfs(x, y):\n            if x < 1 or x > w or y < 1 or y > h or visited[y][x] or board[y][x] != color:\n                return False\n            \n            if x == goal[0] and y == goal[1]:\n                return True\n            \n            visited[y][x] = True\n            \n            for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n                nx, ny = x + dx, y + dy\n                if dfs(nx, ny):\n                    return True\n            \n            return False\n        \n        return dfs(start[0], start[1])\n    \n    board = [[0] * (w + 1) for _ in range(h + 1)]\n    \n    for block in blocks:\n        color, orient, x, y = block\n        if orient == 0:  # horizontal\n            for i in range(x, x + 4):\n                for j in range(y, y + 2):\n                    board[j][i] = color\n        else:  # vertical\n            for i in range(x, x + 2):\n                for j in range(y, y + 4):\n                    board[j][i] = color\n    \n    color = board[start[1]][start[0]]\n    return 'OK' if color and color == board[goal[1]][goal[0]] and can_reach(color) else 'NG'\n\ndef main():\n    w, h = map(int, input().split())\n    n = int(input())\n    blocks = []\n    \n    for _ in range(n):\n        color, orient, x, y = map(int, input().split())\n        blocks.append((color, orient, x, y))\n    \n    start_x, start_y = map(int, input().split())\n    goal_x, goal_y = map(int, input().split())\n    \n    result = is_valid_maze(w, h, blocks, (start_x, start_y), (goal_x, goal_y))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:09:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    from collections import deque\n\n    w, h = map(int, sys.stdin.readline().split())\n    n = int(sys.stdin.readline())\n    blocks = []\n    grid = [[0] * (h + 2) for _ in range(w + 2)]\n    \n    for _ in range(n):\n        x, y, c, o = map(int, sys.stdin.readline().split())\n        blocks.append((x, y, c, o))\n        if o == 0:  # horizontal\n            for i in range(x, x + 4):\n                for j in range(y, y + 2):\n                    grid[i][j] = c\n        else:  # vertical\n            for i in range(x, x + 2):\n                for j in range(y, y + 4):\n                    grid[i][j] = c\n    \n    sx, sy = map(int, sys.stdin.readline().split())\n    gx, gy = map(int, sys.stdin.readline().split())\n    \n    if grid[sx][sy] != grid[gx][gy]:\n        print(\"NG\")\n        return\n    \n    color = grid[sx][sy]\n    if color == 0:\n        print(\"NG\")\n        return\n    \n    visited = [[False] * (h + 2) for _ in range(w + 2)]\n    q = deque()\n    q.append((sx, sy))\n    visited[sx][sy] = True\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    found = False\n    \n    while q:\n        x, y = q.popleft()\n        if x == gx and y == gy:\n            found = True\n            break\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= w and 1 <= ny <= h:\n                if not visited[nx][ny] and grid[nx][ny] == color:\n                    visited[nx][ny] = True\n                    q.append((nx, ny))\n    \n    print(\"OK\" if found else \"NG\")\n\nsolve()",
    "timestamp": "2025-08-13 00:09:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Block {\n    int x, y;   // Top-left corner\n    int color;  // Color of the block\n    int orientation; // 0 for horizontal, 1 for vertical\n};\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nbool isValid(int x, int y, int w, int h) {\n    return x >= 1 && x <= w && y >= 1 && y <= h;\n}\n\nbool bfs(int startX, int startY, int goalX, int goalY, int w, int h, vector<vector<int>>& board) {\n    if (board[startX][startY] != board[goalX][goalY]) return false;\n    int color = board[startX][startY];\n    vector<vector<bool>> visited(w + 1, vector<bool>(h + 1, false));\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startX][startY] = true;\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        if (x == goalX && y == goalY) return true;\n        \n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (isValid(nx, ny, w, h) && !visited[nx][ny] && board[nx][ny] == color) {\n                visited[nx][ny] = true;\n                q.push({nx, ny});\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int w, h, n, startX, startY, goalX, goalY;\n    cin >> w >> h >> n >> startX >> startY >> goalX >> goalY;\n    \n    vector<vector<int>> board(w + 1, vector<int>(h + 1, 0));\n    \n    for (int i = 0; i < n; ++i) {\n        int x, y, color, orientation;\n        cin >> x >> y >> color >> orientation;\n        \n        if (orientation == 0) { // horizontal\n            for (int dx = 0; dx < 4; ++dx)\n                for (int dy = 0; dy < 2; ++dy)\n                    board[x + dx][y + dy] = color;\n        } else { // vertical\n            for (int dx = 0; dx < 2; ++dx)\n                for (int dy = 0; dy < 4; ++dy)\n                    board[x + dx][y + dy] = color;\n        }\n    }\n    \n    if (bfs(startX, startY, goalX, goalY, w, h, board)) {\n        cout << \"OK\" << endl;\n    } else {\n        cout << \"NG\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:52:42"
  }
]