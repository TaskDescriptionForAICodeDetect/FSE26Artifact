[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x, y, z;\n} Point;\n\nint n, k;\nPoint positions[20];\nbool selected[20];\nint min_surface = INT_MAX;\n\nint surface_area(bool* sel) {\n    int area = 0;\n    for (int i = 0; i < n; i++) {\n        if (!sel[i]) continue;\n        area += 6; // Each cube contributes 6 faces initially\n        \n        for (int j = 0; j < n; j++) {\n            if (i == j || !sel[j]) continue;\n            // Check if cubes are adjacent\n            int dx = abs(positions[i].x - positions[j].x);\n            int dy = abs(positions[i].y - positions[j].y);\n            int dz = abs(positions[i].z - positions[j].z);\n            \n            if (dx + dy + dz == 1) {\n                area -= 2; // Subtract 2 for each adjacent face\n            }\n        }\n    }\n    return area;\n}\n\nbool is_connected(bool* sel) {\n    bool visited[20] = {false};\n    int queue[20];\n    int front = 0, rear = 0;\n    \n    // Find first selected cube\n    int start = -1;\n    for (int i = 0; i < n; i++) {\n        if (sel[i]) {\n            start = i;\n            break;\n        }\n    }\n    if (start == -1) return false;\n    \n    queue[rear++] = start;\n    visited[start] = true;\n    int count = 1;\n    \n    while (front < rear) {\n        int current = queue[front++];\n        \n        for (int i = 0; i < n; i++) {\n            if (i == current || !sel[i] || visited[i]) continue;\n            \n            int dx = abs(positions[current].x - positions[i].x);\n            int dy = abs(positions[current].y - positions[i].y);\n            int dz = abs(positions[current].z - positions[i].z);\n            \n            if (dx + dy + dz == 1) {\n                queue[rear++] = i;\n                visited[i] = true;\n                count++;\n            }\n        }\n    }\n    \n    return count == k;\n}\n\nvoid backtrack(int idx, int selected_count) {\n    if (selected_count == k) {\n        if (is_connected(selected)) {\n            int current_surface = surface_area(selected);\n            if (current_surface < min_surface) {\n                min_surface = current_surface;\n            }\n        }\n        return;\n    }\n    \n    if (idx >= n) return;\n    \n    // Select current position\n    selected[idx] = true;\n    backtrack(idx + 1, selected_count + 1);\n    \n    // Don't select current position\n    selected[idx] = false;\n    backtrack(idx + 1, selected_count);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &positions[i].x, &positions[i].y, &positions[i].z);\n    }\n    \n    backtrack(0, 0);\n    \n    printf(\"%d\\n\", min_surface);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:03:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y, z;\n    Point(int x, int y, int z) : x(x), y(y), z(z) {}\n    bool operator==(const Point& other) const {\n        return x == other.x && y == other.y && z == other.z;\n    }\n};\n\nint surfaceArea(const vector<Point>& cubes) {\n    int area = 0;\n    vector<Point> dirs = {\n        Point(1, 0, 0), Point(-1, 0, 0),\n        Point(0, 1, 0), Point(0, -1, 0),\n        Point(0, 0, 1), Point(0, 0, -1)\n    };\n\n    for (const auto& cube : cubes) {\n        int exposed = 6;\n        for (const auto& dir : dirs) {\n            Point neighbor(cube.x + dir.x, cube.y + dir.y, cube.z + dir.z);\n            if (find(cubes.begin(), cubes.end(), neighbor) != cubes.end()) {\n                exposed--;\n            }\n        }\n        area += exposed;\n    }\n    return area;\n}\n\nbool isConnected(const vector<Point>& cubes) {\n    if (cubes.empty()) return false;\n    vector<bool> visited(cubes.size(), false);\n    queue<int> q;\n    q.push(0);\n    visited[0] = true;\n    int count = 1;\n\n    vector<Point> dirs = {\n        Point(1, 0, 0), Point(-1, 0, 0),\n        Point(0, 1, 0), Point(0, -1, 0),\n        Point(0, 0, 1), Point(0, 0, -1)\n    };\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        for (const auto& dir : dirs) {\n            Point neighbor(cubes[current].x + dir.x, cubes[current].y + dir.y, cubes[current].z + dir.z);\n            for (int i = 0; i < cubes.size(); ++i) {\n                if (!visited[i] && cubes[i] == neighbor) {\n                    visited[i] = true;\n                    q.push(i);\n                    count++;\n                }\n            }\n        }\n    }\n    return count == cubes.size();\n}\n\nvoid findMinSurfaceArea(const vector<Point>& positions, int k, vector<Point>& current, int index, int& minArea) {\n    if (current.size() == k) {\n        if (isConnected(current)) {\n            int area = surfaceArea(current);\n            if (area < minArea) {\n                minArea = area;\n            }\n        }\n        return;\n    }\n    if (index >= positions.size()) return;\n\n    current.push_back(positions[index]);\n    findMinSurfaceArea(positions, k, current, index + 1, minArea);\n    current.pop_back();\n    findMinSurfaceArea(positions, k, current, index + 1, minArea);\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<Point> positions;\n    for (int i = 0; i < n; ++i) {\n        int x, y, z;\n        cin >> x >> y >> z;\n        positions.emplace_back(x, y, z);\n    }\n\n    int minArea = INT_MAX;\n    vector<Point> current;\n    findMinSurfaceArea(positions, k, current, 0, minArea);\n\n    cout << minArea << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimalPolyhedron {\n    static class Point {\n        int x, y, z;\n        Point(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Point point = (Point) o;\n            return x == point.x && y == point.y && z == point.z;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n    }\n\n    public static int minimalSurfaceArea(int n, int k, int[][] positions) {\n        List<Point> points = new ArrayList<>();\n        for (int[] pos : positions) {\n            points.add(new Point(pos[0], pos[1], pos[2]));\n        }\n        \n        int minSurface = Integer.MAX_VALUE;\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (Integer.bitCount(mask) != k) continue;\n            \n            Set<Point> selected = new HashSet<>();\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    selected.add(points.get(i));\n                }\n            }\n            \n            if (!isConnected(selected)) continue;\n            \n            int surface = calculateSurface(selected);\n            if (surface < minSurface) {\n                minSurface = surface;\n            }\n        }\n        return minSurface;\n    }\n\n    private static boolean isConnected(Set<Point> selected) {\n        if (selected.isEmpty()) return false;\n        Queue<Point> queue = new LinkedList<>();\n        Set<Point> visited = new HashSet<>();\n        Point start = selected.iterator().next();\n        queue.add(start);\n        visited.add(start);\n        \n        int[][] dirs = {{1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}};\n        \n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n            for (int[] dir : dirs) {\n                Point neighbor = new Point(current.x + dir[0], current.y + dir[1], current.z + dir[2]);\n                if (selected.contains(neighbor) && !visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n        return visited.size() == selected.size();\n    }\n\n    private static int calculateSurface(Set<Point> selected) {\n        int surface = 0;\n        int[][] dirs = {{1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}};\n        \n        for (Point p : selected) {\n            int exposed = 6;\n            for (int[] dir : dirs) {\n                Point neighbor = new Point(p.x + dir[0], p.y + dir[1], p.z + dir[2]);\n                if (selected.contains(neighbor)) {\n                    exposed--;\n                }\n            }\n            surface += exposed;\n        }\n        return surface;\n    }\n}",
    "timestamp": "2025-08-05 21:04:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[] dx = {1, -1, 0, 0, 0, 0};\n    private static final int[] dy = {0, 0, 1, -1, 0, 0};\n    private static final int[] dz = {0, 0, 0, 0, 1, -1};\n\n    public double minSurfaceArea(int[][] positions, int k) {\n        int n = positions.length;\n        List<int[]> selectedPositions = new ArrayList<>();\n        \n        // Generate all possible combinations of k positions\n        backtrack(positions, k, 0, selectedPositions);\n        \n        double minArea = Double.MAX_VALUE;\n        \n        // Evaluate each combination\n        for (List<int[]> combination : validCombinations) {\n            double surfaceArea = calculateSurfaceArea(combination);\n            minArea = Math.min(minArea, surfaceArea);\n        }\n        \n        return minArea;\n    }\n\n    private List<List<int[]>> validCombinations = new ArrayList<>();\n\n    private void backtrack(int[][] positions, int k, int start, List<int[]> current) {\n        if (current.size() == k) {\n            if (isValidConfiguration(current)) {\n                validCombinations.add(new ArrayList<>(current));\n            }\n            return;\n        }\n\n        for (int i = start; i < positions.length; i++) {\n            current.add(positions[i]);\n            backtrack(positions, k, i + 1, current);\n            current.remove(current.size() - 1);\n        }\n    }\n\n    private boolean isValidConfiguration(List<int[]> cubes) {\n        Set<String> occupiedPositions = new HashSet<>();\n        \n        for (int[] cube : cubes) {\n            String pos = cube[0] + \",\" + cube[1] + \",\" + cube[2];\n            if (occupiedPositions.contains(pos)) {\n                return false;\n            }\n            occupiedPositions.add(pos);\n        }\n\n        // Check connectivity\n        return isConnected(cubes);\n    }\n\n    private boolean isConnected(List<int[]> cubes) {\n        if (cubes.isEmpty()) return false;\n        \n        Set<String> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(cubes.get(0));\n        visited.add(cubes.get(0)[0] + \",\" + cubes.get(0)[1] + \",\" + cubes.get(0)[2]);\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            \n            for (int[] cube : cubes) {\n                if (!visited.contains(cube[0] + \",\" + cube[1] + \",\" + cube[2]) && \n                    isAdjacent(current, cube)) {\n                    queue.offer(cube);\n                    visited.add(cube[0] + \",\" + cube[1] + \",\" + cube[2]);\n                }\n            }\n        }\n\n        return visited.size() == cubes.size();\n    }\n\n    private boolean isAdjacent(int[] cube1, int[] cube2) {\n        return Math.abs(cube1[0] - cube2[0]) + \n               Math.abs(cube1[1] - cube2[1]) + \n               Math.abs(cube1[2] - cube2[2]) == 1;\n    }\n\n    private double calculateSurfaceArea(List<int[]> cubes) {\n        Set<String> surfaceFaces = new HashSet<>();\n\n        for (int[] cube : cubes) {\n            for (int i = 0; i < 6; i++) {\n                int nx = cube[0] + dx[i];\n                int ny = cube[1] + dy[i];\n                int nz = cube[2] + dz[i];\n                \n                String face = nx + \",\" + ny + \",\" + nz;\n                if (!containsCube(cubes, new int[]{nx, ny, nz})) {\n                    surfaceFaces.add(face);\n                }\n            }\n        }\n\n        return surfaceFaces.size();\n    }\n\n    private boolean containsCube(List<int[]> cubes, int[] cube) {\n        for (int[] c : cubes) {\n            if (c[0] == cube[0] && c[1] == cube[1] && c[2] == cube[2]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 21:04:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_K 10\n\ntypedef struct {\n    int x, y, z;\n} Point;\n\nint n, k;\nPoint positions[MAX_N];\nint selected[MAX_K];\nint best_selected[MAX_K];\ndouble min_surface_area = INT_MAX;\n\nint is_valid_placement(int *current_selected, int count) {\n    // Check connectivity and no overlap conditions\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            Point p1 = positions[current_selected[i]];\n            Point p2 = positions[current_selected[j]];\n            \n            int dx = abs(p1.x - p2.x);\n            int dy = abs(p1.y - p2.y);\n            int dz = abs(p1.z - p2.z);\n            \n            // Check connectivity\n            if (!((dx == 1 && dy == 0 && dz == 0) ||\n                  (dx == 0 && dy == 1 && dz == 0) ||\n                  (dx == 0 && dy == 0 && dz == 1))) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\ndouble calculate_surface_area(int *current_selected, int count) {\n    double surface_area = 0;\n    \n    // Calculate surface area of the polyhedron\n    for (int i = 0; i < count; i++) {\n        surface_area += 6; // Initial surface of a cube\n        \n        Point p1 = positions[current_selected[i]];\n        \n        // Reduce surface area for adjacent cubes\n        for (int j = 0; j < count; j++) {\n            if (i != j) {\n                Point p2 = positions[current_selected[j]];\n                \n                int dx = abs(p1.x - p2.x);\n                int dy = abs(p1.y - p2.y);\n                int dz = abs(p1.z - p2.z);\n                \n                // Reduce surface area for adjacent faces\n                if ((dx == 1 && dy == 0 && dz == 0) ||\n                    (dx == 0 && dy == 1 && dz == 0) ||\n                    (dx == 0 && dy == 0 && dz == 1)) {\n                    surface_area -= 2;\n                }\n            }\n        }\n    }\n    \n    return surface_area;\n}\n\nvoid backtrack(int start, int count) {\n    if (count == k) {\n        if (is_valid_placement(selected, count)) {\n            double current_surface_area = calculate_surface_area(selected, count);\n            \n            if (current_surface_area < min_surface_area) {\n                min_surface_area = current_surface_area;\n                memcpy(best_selected, selected, k * sizeof(int));\n            }\n        }\n        return;\n    }\n    \n    for (int i = start; i < n; i++) {\n        selected[count] = i;\n        backtrack(i + 1, count + 1);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &positions[i].x, &positions[i].y, &positions[i].z);\n    }\n    \n    backtrack(0, 0);\n    \n    printf(\"Minimal surface area: %.2f\\n\", min_surface_area);\n    \n    printf(\"Selected positions:\\n\");\n    for (int i = 0; i < k; i++) {\n        printf(\"%d %d %d\\n\", \n            positions[best_selected[i]].x, \n            positions[best_selected[i]].y, \n            positions[best_selected[i]].z);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y, z;\n    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}\n};\n\nclass PolyhedronMinimizer {\nprivate:\n    int n, k;\n    vector<Point> positions;\n    \n    bool isValidPlacement(vector<Point>& selectedPositions) {\n        // Check overlap and separation conditions\n        for (int i = 0; i < selectedPositions.size(); i++) {\n            for (int j = i + 1; j < selectedPositions.size(); j++) {\n                Point& p1 = selectedPositions[i];\n                Point& p2 = selectedPositions[j];\n                \n                // Check adjacency and no overlap\n                if (abs(p1.x - p2.x) + abs(p1.y - p2.y) + abs(p1.z - p2.z) > 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    int calculateSurfaceArea(vector<Point>& selectedPositions) {\n        int surfaceArea = 0;\n        int directions[6][3] = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};\n        \n        for (Point& cube : selectedPositions) {\n            int cubeSurfaceArea = 6;\n            \n            for (auto& dir : directions) {\n                Point neighbor(cube.x + dir[0], cube.y + dir[1], cube.z + dir[2]);\n                \n                for (Point& other : selectedPositions) {\n                    if (neighbor.x == other.x && neighbor.y == other.y && neighbor.z == other.z) {\n                        cubeSurfaceArea--;\n                        break;\n                    }\n                }\n            }\n            \n            surfaceArea += cubeSurfaceArea;\n        }\n        \n        return surfaceArea;\n    }\n    \npublic:\n    PolyhedronMinimizer(int n, int k, vector<Point>& positions) \n        : n(n), k(k), positions(positions) {}\n    \n    int minimizeSurfaceArea() {\n        int minSurfaceArea = INT_MAX;\n        vector<bool> selection(n, false);\n        \n        // Fill first k positions with true\n        fill(selection.begin(), selection.begin() + k, true);\n        \n        do {\n            vector<Point> selectedPositions;\n            \n            // Collect selected positions\n            for (int i = 0; i < n; i++) {\n                if (selection[i]) {\n                    selectedPositions.push_back(positions[i]);\n                }\n            }\n            \n            // Validate and update minimum surface area\n            if (isValidPlacement(selectedPositions)) {\n                minSurfaceArea = min(minSurfaceArea, calculateSurfaceArea(selectedPositions));\n            }\n            \n        } while (prev_permutation(selection.begin(), selection.end()));\n        \n        return minSurfaceArea;\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    vector<Point> positions(n);\n    for (int i = 0; i < n; i++) {\n        cin >> positions[i].x >> positions[i].y >> positions[i].z;\n    }\n    \n    PolyhedronMinimizer minimizer(n, k, positions);\n    cout << minimizer.minimizeSurfaceArea() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef get_surface_area(positions, selected_positions):\n    dx = [1, -1, 0, 0, 0, 0]\n    dy = [0, 0, 1, -1, 0, 0]\n    dz = [0, 0, 0, 0, 1, -1]\n    \n    cubes = set(selected_positions)\n    surface_area = 0\n\n    for x, y, z in selected_positions:\n        for i in range(6):\n            nx, ny, nz = x + dx[i], y + dy[i], z + dz[i]\n            if (nx, ny, nz) not in cubes:\n                surface_area += 1\n\n    return surface_area\n\ndef is_connected(selected_positions):\n    visited = set()\n    queue = [selected_positions[0]]\n    visited.add(selected_positions[0])\n\n    while queue:\n        cube = queue.pop()\n        for dx, dy, dz in [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]:\n            neighbor = (cube[0] + dx, cube[1] + dy, cube[2] + dz)\n            if neighbor in selected_positions and neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n    return len(visited) == len(selected_positions)\n\ndef find_minimum_surface_area(positions, k):\n    min_surface_area = float('inf')\n    best_combination = None\n\n    for combination in combinations(positions, k):\n        if is_connected(combination):\n            surface_area = get_surface_area(positions, combination)\n            if surface_area < min_surface_area:\n                min_surface_area = surface_area\n                best_combination = combination\n\n    return min_surface_area if best_combination else None\n\n# Define positions and k here\npositions = [\n    # (x, y, z) coordinates for cube positions\n]\nk = 0  # Set the desired number of cubes\n\n# Call the function with provided positions and k\nresult = find_minimum_surface_area(positions, k)\n\n# Output the result\nprint(result)",
    "timestamp": "2025-08-13 04:42:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinimalPolyhedronSurface {\n    \n    private static final int[][] DIRECTIONS = {{1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[][] positions = new int[n][3];\n\n        for (int i = 0; i < n; i++) {\n            positions[i][0] = sc.nextInt();\n            positions[i][1] = sc.nextInt();\n            positions[i][2] = sc.nextInt();\n        }\n\n        System.out.println(findMinimalSurfaceArea(positions, k));\n        sc.close();\n    }\n\n    private static int findMinimalSurfaceArea(int[][] positions, int k) {\n        int minSurfaceArea = Integer.MAX_VALUE;\n        int n = positions.length;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (Integer.bitCount(mask) == k) {\n                List<int[]> selected = new ArrayList<>();\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        selected.add(positions[i]);\n                    }\n                }\n\n                if (areConnected(selected)) {\n                    int surfaceArea = calculateSurfaceArea(selected);\n                    minSurfaceArea = Math.min(minSurfaceArea, surfaceArea);\n                }\n            }\n        }\n\n        return minSurfaceArea;\n    }\n\n    private static boolean areConnected(List<int[]> cubes) {\n        if (cubes.isEmpty()) return false;\n\n        Set<String> visited = new HashSet<>();\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(cubes.get(0));\n        visited.add(serialize(cubes.get(0)));\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n\n            for (int[] direction : DIRECTIONS) {\n                int[] neighbor = new int[]{current[0] + direction[0], current[1] + direction[1], current[2] + direction[2]};\n                if (!visited.contains(serialize(neighbor)) && cubes.contains(neighbor)) {\n                    visited.add(serialize(neighbor));\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        return visited.size() == cubes.size();\n    }\n\n    private static int calculateSurfaceArea(List<int[]> cubes) {\n        Set<String> cubeSet = new HashSet<>();\n        for (int[] cube : cubes) {\n            cubeSet.add(serialize(cube));\n        }\n\n        int exposedFaces = 0;\n        for (int[] cube : cubes) {\n            int adjacent = 0;\n            for (int[] direction : DIRECTIONS) {\n                int[] neighbor = new int[]{cube[0] + direction[0], cube[1] + direction[1], cube[2] + direction[2]};\n                if (cubeSet.contains(serialize(neighbor))) {\n                    adjacent++;\n                }\n            }\n            exposedFaces += (6 - adjacent);\n        }\n\n        return exposedFaces;\n    }\n\n    private static String serialize(int[] cube) {\n        return cube[0] + \",\" + cube[1] + \",\" + cube[2];\n    }\n}",
    "timestamp": "2025-08-13 04:42:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n#define INF 1000000000\n\nint n, k;\nint positions[MAX_N][3];\nint dp[MAX_N][1<<MAX_N];\n\nint distance(int a, int b) {\n    int dx = abs(positions[a][0] - positions[b][0]);\n    int dy = abs(positions[a][1] - positions[b][1]);\n    int dz = abs(positions[a][2] - positions[b][2]);\n    return (dx + dy + dz == 1);\n}\n\nint surface_area(int state) {\n    int surface = 0;\n    for (int i = 0; i < n; i++) {\n        if (state & (1 << i)) {\n            int exposed_sides = 6;\n            for (int j = 0; j < n; j++) {\n                if (i != j && (state & (1 << j))) {\n                    if (distance(i, j)) {\n                        exposed_sides--;\n                    }\n                }\n            }\n            surface += exposed_sides;\n        }\n    }\n    return surface;\n}\n\nint solve(int idx, int selected) {\n    if (selected == k) {\n        return surface_area(idx);\n    }\n    if (idx == (1 << n)) {\n        return INF;\n    }\n    if (dp[idx][selected] != -1) {\n        return dp[idx][selected];\n    }\n\n    int min_surface = INF;\n    for (int i = 0; i < n; i++) {\n        if (!(idx & (1 << i))) {\n            int next_state = idx | (1 << i);\n            min_surface = fmin(min_surface, solve(next_state, selected + 1));\n        }\n    }\n\n    dp[idx][selected] = min_surface;\n    return min_surface;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &positions[i][0], &positions[i][1], &positions[i][2]);\n    }\n\n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\\n\", solve(0, 0));\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:42:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nimport numpy as np\n\ndef manhattan_distance(pos1, pos2):\n    return sum(abs(a - b) for a, b in zip(pos1, pos2))\n\ndef is_valid_placement(cubes):\n    for i in range(len(cubes)):\n        for j in range(i + 1, len(cubes)):\n            if manhattan_distance(cubes[i], cubes[j]) != 1:\n                return False\n    return True\n\ndef surface_area(cubes):\n    surface = set()\n    for cube in cubes:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                for dz in [-1, 0, 1]:\n                    if sum(abs(x) for x in [dx, dy, dz]) == 1:\n                        surface.add(tuple(cube[i] + x for i, x in enumerate([dx, dy, dz])))\n    for cube in cubes:\n        surface.discard(tuple(cube))\n    return len(surface)\n\ndef minimal_surface_polyhedron(positions, k):\n    best_surface = float('inf')\n    best_cubes = None\n\n    for cubes in combinations(positions, k):\n        if is_valid_placement(cubes):\n            current_surface = surface_area(cubes)\n            if current_surface < best_surface:\n                best_surface = current_surface\n                best_cubes = cubes\n\n    return best_cubes, best_surface\n\n# Example usage\nn = 10  # Total number of positions\nk = 5   # Number of cubes to place\npositions = [(x, y, z) for x in range(n) for y in range(n) for z in range(n)]\n\nresult_cubes, result_surface = minimal_surface_polyhedron(positions, k)\nprint(\"Best cubes:\", result_cubes)\nprint(\"Minimal surface area:\", result_surface)",
    "timestamp": "2025-08-13 04:43:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import combinations\n\ndef minimal_surface_area(n, k, positions):\n    if k == 0:\n        return 0\n    min_area = float('inf')\n    for selected in combinations(positions, k):\n        cubes = set(selected)\n        surface_area = 6 * k\n        for (x, y, z) in selected:\n            neighbors = [(x+1, y, z), (x-1, y, z), (x, y+1, z), (x, y-1, z), (x, y, z+1), (x, y, z-1)]\n            for neighbor in neighbors:\n                if neighbor in cubes:\n                    surface_area -= 1\n        if surface_area < min_area:\n            min_area = surface_area\n    return min_area\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    n, k = map(int, input_lines[0].split())\n    positions = []\n    for line in input_lines[1:n+1]:\n        x, y, z = map(int, line.split())\n        positions.append((x, y, z))\n    print(minimal_surface_area(n, k, positions))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 04:43:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <array>\n\nusing namespace std;\n\nstruct Position {\n    int x, y, z;\n    bool operator<(const Position& other) const {\n        return tie(x, y, z) < tie(other.x, other.y, other.z);\n    }\n};\n\nclass Polyhedron {\npublic:\n    vector<Position> positions;\n    Polyhedron(const vector<Position>& positions) : positions(positions) {}\n    int surfaceArea() const {\n        int area = 0;\n        std::set<Position> cubes(positions.begin(), positions.end());\n        std::array<std::pair<int, int>, 3> directions = {{{1, 0}, {0, 1}, {0, 0}}, {{-1, 0}, {0, -1}, {0, 0}}, {{0, 0}, {0, 0}, {1, 0}}, {{0, 0}, {0, 0}, {-1, 0}}};\n        for (auto &pos : positions) {\n            int uncov_faces = 6;\n            for (auto &d : directions) {\n                Position neighbor = {pos.x + d.first, pos.y + d.second, pos.z};\n                if (cubes.count(neighbor)) uncov_faces--;\n                neighbor = {pos.x, pos.y + d.first, pos.z + d.second};\n                if (cubes.count(neighbor)) uncov_faces--;\n                neighbor = {pos.x + d.second, pos.y, pos.z + d.first};\n                if (cubes.count(neighbor)) uncov_faces--;\n            }\n            area += uncov_faces;\n        }\n        return area;\n    }\n};\n\nint minimalSurfacePolyhedron(int n, int k, vector<Position>& available_positions) {\n    int min_surface_area = INT_MAX;\n    vector<bool> visit(n, false);\n\n    function<void(int, int, vector<Position>&)> dfs = [&](int idx, int placed, vector<Position>& current) {\n        if (placed == k) {\n            Polyhedron p(current);\n            min_surface_area = min(min_surface_area, p.surfaceArea());\n            return;\n        }\n        for (int i = idx; i < n; ++i) {\n            if (visit[i]) continue;\n            if (!current.empty()) {\n                auto& last = current.back();\n                if (!((abs(last.x - available_positions[i].x) + abs(last.y - available_positions[i].y) + abs(last.z - available_positions[i].z)) == 1)) continue;\n            }\n            visit[i] = true;\n            current.push_back(available_positions[i]);\n            dfs(i + 1, placed + 1, current);\n            current.pop_back();\n            visit[i] = false;\n        }\n    };\n\n    vector<Position> current;\n    dfs(0, 0, current);\n\n    return min_surface_area;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<Position> positions(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> positions[i].x >> positions[i].y >> positions[i].z;\n    }\n    cout << minimalSurfacePolyhedron(n, k, positions) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:21:18"
  }
]